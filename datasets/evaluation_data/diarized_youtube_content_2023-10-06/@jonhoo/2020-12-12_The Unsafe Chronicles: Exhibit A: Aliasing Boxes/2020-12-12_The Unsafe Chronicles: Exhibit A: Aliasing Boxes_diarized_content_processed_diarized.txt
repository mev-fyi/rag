00:00:01.080 - 00:00:48.285, Speaker A: Hello, everyone. Welcome back to, I guess, or welcome for the first time, I suppose, to the first episode of the Unsafe Chronicles. I feel like maybe I should be wearing some, like, scary outfit or something. But the reality is that unsafe code has this reputation in the rust world of being, like, scary and hard and somewhat unknowable and like, to an extent, that's an earned reputation. The number of ways you can shoot yourself in the foot with unsafe, there are a lot of them, and sometimes it is really hard to get right. But I think being scared of it is not the right approach. The right approach is to look at what can go wrong and try to learn from it so that you don't make the same mistakes in the future.
00:00:48.285 - 00:02:21.275, Speaker A: To me, unsafe code has always sort of been like, if you're in unsafe world, you're just writing C, so if most of your code is not unsafe, you're still better off than what you would have been otherwise. Regardless, though, this series is focusing on a subset of that problem, which is just as the name implies, talking about stories with the unsafe. Like cases where, I guess starting off like cases where I run into oddities with unsafe where I didn't know that something was okay, and then I learned and then I fixed the problem. And I'm hoping that just by sort of surfacing a lot of these stories about where you might go wrong with unsafe, or where there might be tricky scenarios to get right, just talking about those cases and what the sort of underlying principles are might be helpful for other people who are trying to write unsafe code and do so safely. And in particular, for this first chronicle, what we're going to be looking at is a crate called Left Right, and Left Right is a crate that I built in my previous stream, which is sort of a longer live coding stream. I'll link it in the video somewhere around here, I guess. And at its core, it's a concurrency primitive that allows you to have really fast concurrent read access to some backing data structure.
00:02:21.275 - 00:03:26.185, Speaker A: And it does this with very little synchronization between the readers, which means that it scales really well as you add more threads that end up reading from the data structure, where Left right gets a little complicated, or one of the places it gets complicated is that it does this by keeping two copies of the backing data structure. If it's a map, for example, you would have a left map and a right map, and the data structure sort of keeps these in sync. And then make sure that the readers only read from one and the writers only write to the other. And this is how it ensures that the reads can be fast because they don't have to do any synchronization. They can just read from the read half, if you will. And Left right sort of realizes that duplicating all of your data is probably not okay. So it wants to pull this trick of aliasing where you have think of it as instead of having all your values be stored in both the left and right data structure, you have both of them store a sort of shallow copy, if you will, or an alias of the true value that's stored somewhere else.
00:03:26.185 - 00:04:18.815, Speaker A: So the trivial example here is if you have something that's on the heap, instead of having one heap allocation for the left map and one or for the left copy and one heap allocation for the right copy, you just have one heap allocation. You have the left and the right both point to that same heap allocation. And sort of conceptually this works because Left right only ever gives out read access to the values that are stored in the copies. Like the moment after you've inserted it, you can no longer get immutable reference to it anymore, except when the value is actually dropped. And so this should be fine, like aliasing should be fine because you only have readers and it should be fine to have shared references to a value. Like multiple shared references. We know from the Rust borrow checker is okay.
00:04:18.815 - 00:05:20.165, Speaker A: And what we're going to be looking at is specifically that mechanism for aliasing, because there sort of necessarily has to be some unsafe code. If you think of this as something like if you have a box, what you're now going to be doing is you're going to construct two boxes that point to the same underlying allocation, which means you need to use the actually, let me pull this up here box. So the box trait has a from raw method or function, I guess is a freestanding function that takes a raw pointer and gives you a box t. And similarly there's a Torah or into raw that takes a box t and gives you a mutable pointer to that t. And going from a box to a pointer is a safe operation because it gives you a raw pointer. And dereferencing a raw pointer in Rust is unsafe anyway. But going from a raw pointer into a box is unsafe.
00:05:20.165 - 00:06:31.295, Speaker A: There are many reasons for this. The primary one being that you need to guarantee that this pointer actually is a box, that it's like a pointer to a heap allocated thing, because box, when you drop it, is going to free the underlying object, right? So so far so good, right? There is a mechanism for if you have one box to sort of construct a second box. The points to the same underlying heap allocation. And this was the trick that left right and its predecessor evmap used for the longest time, it would just create two boxes to the same heap allocation, or if you had a vec, it would create two vec elements that both pointed to the same underlying data structure on the heap. And that seemed fine enough. And I thought that this was entirely safe because remember, the data structure guarantees that it only ever gives out shared references to the backing memory. So what's the problem? Well, it turns out that there are two problems, and both of these actually came up in the previous stream when we were working through how to factor out the concurrency primitive in evmap.
00:06:31.295 - 00:07:17.365, Speaker A: And some of this is described in this PR that I started working on shortly after that stream. But I'm going to try to summarize it here with some actual code. So let's do a cargo new lib aliasing. Okay, so the basic problem we have is that we have a, let's say struct aliased T. It stores internally a box T. And then what we're going to be giving out is alias T, right? We're going to have like. We're going to have.
00:07:17.365 - 00:08:12.035, Speaker A: I guess. How are we going to describe this? Like we're going to have a. Here, let me actually write out the code that's going to help. Let's imagine that we have a left, which is an aliased, where the real is a box. New let's just use a number for now aliased this and then we're going to construct an alias just by doing real box from raw box into raw of left real. This won't actually compile, and I'll talk about that in a second too, but sort of conceptually, this is what's going on, right? We have a left and a right. They both contain a box, but the box is the same underlying pointer.
00:08:12.035 - 00:09:16.667, Speaker A: And as long as we only ever use left real and oops and write real. Like if we only ever use those behind shared references, then why is this not okay? And the first issue we're going to talk about here is about aliasing rules. So box, I don't know. Let me pull up the documentation for box. Oh, why does my scroll bar look weird? That's weird. Where is this? So this might actually not be documented. So the documentation for box talks about a bunch of the sort of invariants about boxes, right? So it says that a boxy value will always be fully aligned.
00:09:16.667 - 00:10:14.335, Speaker A: Box will always be a non Null pointer. And if we look at from raw, which is the unsafe function we're using, it says that for safety this function is unsafe because improper use may lead to memory problems. Okay, that's fine, but it doesn't really say very much about what is and isn't. Okay? It just sort of assumes that you know what the correct thing is. It does say, for this to be safe, the memory must have been allocated in accordance with the memory layout used by box, which is sort of trivially guaranteed for us, because we know that we constructed this from a box in the first place. But it turns out that in general, in Rust, when you have a box T, what this compiles into in like lvm, like in the underlying code generation pipeline, is it turns into. Or it uses an attribute called no alias or no aliased.
00:10:14.335 - 00:10:59.555, Speaker A: Forget whether I think it's no alias. And what this means is that Rust is telling the underlying code generation tool that the pointer that the box contains is not aliased anywhere else in the code. And normally that's true, right? If you have a box T, then you own that box T, and you know that no one else has the actual box. So if you're operating on this box, you know that that pointer itself is not aliased. It doesn't exist anywhere else in the system. And you might wonder, well, why does this matter? It matters because LLVM gets to optimize your code under that assumption. The silliest example of this might be.
00:10:59.555 - 00:11:40.085, Speaker A: Let's say that you. Let's. Let's say that we didn't have. Right, we didn't do anything funky with this. We just have like a. A normal like box somewhere because the compiler knows that box is not aliased, it doesn't exist anywhere else, and it sees that five fits inside a usize. What's to stop the compiler from just not doing the heap allocation right? Just have 5 be stored in the field where the pointer normally would have been stored.
00:11:40.085 - 00:12:59.955, Speaker A: I don't think LLVM does this currently, but if we know that there are no aliases of this pointer, we know that no one else has the actual pointer, then why do we have to have the actual pointer? If the value fits in the pointer itself, anytime we move the pointer somewhere else, we can just copy the value that's stored in the pointer field instead. If we give out pointer like references to the box, those are just references to the actual usize. So everything sort of just works, right? And the compiler might not do this optimization today, but we have no guarantee that it won't do in the near future, because we are telling the compiler when we construct a box that this pointer is not aliased. But if we write code like this, where we are aliasing the box, Rust doesn't know that we are aliasing this box. So it will continue under the assumption that box the box is not alias, because the rules for box is that it's not aliased. And therefore let's imagine that it did the same optimization for the box here, right? So it just didn't do the heap allocation here and instead just stuck the value 5 into the pointer field of box. And then when we did this alien thing, it would Basically just copy the 5 into this other pointer.
00:12:59.955 - 00:13:41.011, Speaker A: But now let's say that we modified this value, right? We modified the value that's pointed to by left in theory. And we do this sort of guaranteeing that no one is using right yet. Like right is right, Someone has an alias pointer, but they're not using it for anything, so we're allowed to mutate it. Let's assume that that's the case. Well, now let's say we set that value to 10. If this optimization has been applied, it's just going to change the value inside the box pointer to be 10 because it's using this optimization. But anyone who reads from the other alias is not going to see that change because the optimization has removed the pointer.
00:13:41.011 - 00:14:27.955, Speaker A: There's no longer a shared thing. They're pointing to that the change to left actually mutated. They just muted their own local copies. You can think of this as box sort of becoming copyright under this optimization, right? And so now this is just going to lead to completely weird behavior where changing one side doesn't change the other. It's true that we only ever access them through these shared references. Maybe you think everything was okay because we can't mutate anything anyway, but then you have types like unsafe cell or mutex or I guess ref cell, technically right or cell for that matter, that give you interior mutability. They let you mutate a type with a shared reference.
00:14:27.955 - 00:15:09.995, Speaker A: Well, what happens if left or right contains one of these? Like let's say that this contained a unsafe or a cell of usize. The optimization can still happen, but now changing the left is not going to reveal that to things on the right. So basically by aliasing box, we've invalidated an optimization that the compiler still thinks is legal. And again, this particular optimization isn't really the point. I don't know that this is an optimization that even makes sense, or one that LLVM does. It probably does not. But it's more that because of the aliasing rules of Box, which is you're not allowed to alias a box.
00:15:09.995 - 00:16:00.089, Speaker A: The compiler tells LLVM that doing any kind of optimization like this is okay. It's telling LLVM that this pointer is not aliased and therefore you can make optimizations accordingly. And so it's just not okay to alias a box. Now this is a problem for us, right, because the whole point of Left right, was to use aliasing to share the underlying values. And so I was trying for a while to try to figure out what, like how to fix this problem. Because ultimately if we can't alias a box, we just like, can't do this trick. We just can't share values between left and right, because you can imagine that you have some data structure that internally contains a box somewhere, and then this optimization would become invalid.
00:16:00.089 - 00:17:12.663, Speaker A: Again, isn't noalias still fine as long as all the no alias pointers are only used for reading, which is how reference T can be? No alias, no. So that's the point, that even if we only use the box through shared references on both sides, this is still not okay. Because this optimization, again, if what the box contained was a cell of use size, the optimization can still happen. But now if you mutate through one, right, you're doing a completely safe operation, which is to mutate a cell through a shared reference. But that change doesn't actually propagate to the other side, which that in itself is not unsound behavior. And I don't know what unsound behavior this might trigger, but that's sort of not the point. And this is something that comes up a lot in discussions of unsafe, which is you don't know what optimizations might happen in the future, right? So you need to code against what the, what the guarantees are and what the requirements are of the underlying types.
00:17:12.663 - 00:18:24.179, Speaker A: So if Box says it can't be aliased, even if there's no current problem with aliasing a box, you should still avoid it because there might be an optimization in the future that then randomly breaks your code. Now, as we saw from the documentation on Box there, it's not actually documented anywhere that you're not allowed to alias 1. It just sort of kind of implied. And so after the discussion on the previous stream, someone filed an issue, someone filed an issue against the repository that, that I was working on for the stream, saying that, like basically Ralph Jung, who's one of the, one of the big people working on like safety and Rust and how to do things like formal verification of the safety of Rust programs and just figuring out what the spec for unsafety even is pointed out that like you're not allowed to alias a box. At least that was his opinion. And I think he's probably right about that, that Rust currently assumes that that is the case. And this ultimately ended up with an open issue in the Unsafe Code Guidelines Working group.
00:18:24.179 - 00:19:23.145, Speaker A: So this working group is working on basically trying to codify what the actual requirements of unsafe Rust code is. What do you need to guarantee in order for your code to be sound? And really what came out of this discussion was Box probably should have the requirement that the value that the pointer is not aliased, but it doesn't currently specify this anywhere. Like this is not a current part of the requirements of Box. The question is whether it should be. And so I recommend you read through this discussion. It's gotten pretty long. If you're curious about sort of the trade offs that are involved here and the arguments for why should aliasing a box be okay? Why should aliasing a box not be okay? And where that discussion sort of ended up was that we probably want boxt to not be aliasable, but we probably also want some way to override that behavior.
00:19:23.145 - 00:20:16.535, Speaker A: Like if you do want to alias a box, there has to be some way to do it that doesn't violate the sort of soundness requirements of Rust code. And what we ended up with there is Rust has this type called maybe an initial. So maybe on init of T is a wrapper type. This wrapper type is. This wrapper type is wrapper transparent. So that is it has the same memory layout as whatever the underlying type T is. And maybe on INIT is interesting because it doesn't require that the sort of bits inside the bits that make up the T actually make a valid T.
00:20:16.535 - 00:21:06.295, Speaker A: The most simple example of this is in Rust if you have a boolean, the sort of validity of boolean says that the bit pattern for a boolean can only be 0 or 1. It's not allowed to be anything else. If you have some byte whose value is like 255 that is not a valid boolean. And there are a bunch of other types like this. Like if you have a, if you have a box, the bit pattern of all zeros is not a valid bit pattern for a box because the pointer is not allowed to be null. Right? So in general, Rust always requires its values to be valid. And maybe on INIT is a way to tell the compiler that the bit pattern for this type might not be valid yet.
00:21:06.295 - 00:22:06.663, Speaker A: And this basically forces Rust to disable a bunch of optimizations because it can't assume the same things that it normally assumes about the inner type. And then on maybe on init, on maybe on init there is a. So for example, if you, if you try to create a T by just zeroing a bunch of bits using mem0ed like that's not a valid reference, for example, because references have to be non null, but if you stick them inside a memunit, then you're fine, because Rust doesn't assume that this is actually a valid T yet. And then maybe aninit has a method. This documentation is great, by the way. You should read it if you're curious. It has a method called where are you? Assume init and assume init consumes the maybe un in it and gives you the inner t.
00:22:06.663 - 00:23:54.551, Speaker A: And this is unsafe because when you call this function, you are telling the compiler, now the bit pattern of the inner type is valid. And so now you can start to have all the normal assumptions you have about that type. Like for example, for a bool, you can now assume that it's 01 if it's a pointer, if it's a reference, you can assume that it's a valid reference, it's a live reference that hasn't been dropped, it's aligned all of those good things. The reason this comes up as being relevant for a box case is that if we stick a box inside a maybe uninit, we're disabling the optimization of passing things like no aliased, right? And this means that now we can alias the box, we can have a maybe uninit boxt and then an alias of that maybe uninit with an alias of that same box. And the compiler won't emit no alias because it's not allowed to assume anything about the inner bit pattern, about the inner type. And then what we can use is we can use the as mute pointer method on the maybe on init or the as pointer method to get a reference to the inner t, which we can then sort of dereference and go the whole way, because we know that while it, while Rust assumes that you're not allowed to alias a box, if we cast it into a reference into the inner T, we know that that is a valid reference, right? So to try to rephrase that, if we have a actually maybe I should write it down. So if we have a maybe on in it box of T, right, Rust assumes nothing about the validity of this box.
00:23:54.551 - 00:24:22.865, Speaker A: But if we now call dot as pointer. Right? So that gives us. This gives us a star const box T. Right. And then we do a this on that. Ah, right. That's going to give us a reference to T.
00:24:22.865 - 00:24:53.785, Speaker A: And this reference to T matches all the validity requirements of a reference to T. Right. Specifically it has to be a valid pointer, which it is because we know that the value still lives. It's aligned. We know that that is true because a box creates an aligned value. It hasn't been dropped because we haven't dropped the target value. And crucially, a reference to T does not have any requirements about it not being aliased because shared reference or references are always aliased.
00:24:53.785 - 00:25:45.265, Speaker A: And so by doing this transformation, we're now able to alias the box T and still get out shared references. Okay, that was a lot of technical detail. So I'm going to take some questions on how this works before we talk about a related problem around aliasing boxes. But there's a lot of complexity to unpack here, so please ask questions about why this is or is not. Okay, Any part that was unclear and I'll try to go into more detail. This is some pretty hairy stuff and it's hard to talk through too because there's so many subtle interactions and a lot of new types, probably for many of you. And it's also hard to.
00:25:45.265 - 00:26:41.455, Speaker A: It's hard to explain the problem concisely because we're just working with this sort of very basic example here. But the basic summary of the problem and the solution is that you're not allowed to have two box T's that point to the same T. And this is because boxt requires that it is not aliased. That is a validity requirement of box T. But we can use a maybe uninit because maybe uninit relaxes the requirements on the inner type. It, for example, removes the requirement that the type is valid and that makes things ok. What are the aliasing rules for manually drop T? That's a great question that we're going to get to next.
00:26:41.455 - 00:27:47.945, Speaker A: Does this fix the issue with nested boxes being alias because we will sometimes reveal both shared references? That is a good question. So the question, if I understand you correctly, is what if we have a type like box box box T, Right? Or we have some like wrapper type that has a box T or something? Right. Then what we're doing is we're constructing a maybe an init of that type which we're then going to turn into a reference to this type. And the question is, is this okay? Because now we're. This box is still aliased, right? Because we were aliasing this type. And the answer is that yes, this is okay. And the reason this is okay is because I'm allowed to write this code, right? This is totally valid Rust code.
00:27:47.945 - 00:28:56.413, Speaker A: So Rust doesn't assume. It's not that Rust doesn't allow you to have multiple pointers to a box, multiple references to a box, it's that it doesn't allow you to have multiple owned boxes that are aliased. So this is fine, which is also why this is fine. Because here the shared reference part is what means is what sets the sort of aliasing rules for this value. If you try to access this box through the shared reference, Rust knows that it can't give no alias because you're already going through a shared reference where this is not the case. If you have like we had above, right? If you had left and right there actual aliases of the box, then if you do a left dot alias dot. I don't know, like something that accesses the inner value, right? Let's say you did these concurrently.
00:28:56.413 - 00:29:49.695, Speaker A: As far as Russ is concerned, this is not going through a shared reference and neither is this. It's just accessing a box that you own and therefore it does give the no alias attribute. That makes sense. Can you unpack the types of ampersand, star, star, more deer of the pointer and getting a reference? Yeah. So the transformation here is from maybe on init, box T goes to a star const of box T goes to a star const of T. So then we do so just to give like the methods we call. This is the first.
00:29:49.695 - 00:30:58.075, Speaker A: So the as pointer gives you this, the star gives you this, the second star gives you this, and the reference gives you reference. T is the progression. And we can't just do a reference here, because if we did a reference here, you would end up with this, which is not what you wanted. So you need the star and then the reference, which ends up being a no op, right? This ends up just being a cast, and you could do it as a cast instead if you wanted to. Why is it called maybe on init? It's called maybe on init because maybe oninit is primarily used for cases where the inner type is like just zeroed bits, for example, so the value is not initialized. It just so happens that it's sort of poorly named. Right? Because really it's like maybe valid would maybe be a better word for it because it's not only that it hasn't been initialized, it can also be there's some other reason why it isn't valid yet or at the moment.
00:30:58.075 - 00:31:41.067, Speaker A: Why is box no alias in the first place? Box is no alias because of optimizations. I'm sure there are other cases where no alias allows you to do optimizations, but I'm not sure. I think this is part of the reason why this is still an open issue in the Unsafe Code Guidelines group is because it's not entirely clear whether box itself should be no alias. So it makes a lot of sense for mu T to be no alias, right? Mu T is no alias. Because what's the sort of canonical example here is the one that's given in the nomicon. Let's see if I can find this aliasing. Yeah, so this is a.
00:31:41.067 - 00:32:26.647, Speaker A: Let me zoom in a little maybe. So the nomicon is great for anything that has to do with unsafe. And this function is kind of neat. So it takes an input and an output and the output is a mutable reference in Rust because, and this is specifically because of the no alias optimization llvm, the code generation tool, knows that input and output cannot point to the same value. And it knows this because output is no alias. So it knows that even though input is a reference, it cannot be a reference to whatever output is pointing to because the output pointer or the output reference is not alias. And that lets it do a neat optimization here where it only needs to read the input once instead of twice, which in turn means that it can do some other optimization.
00:32:26.647 - 00:33:36.273, Speaker A: So no alias does enable some cool optimizations for mutable references to T. Whether it also enables cool optimization for things like box T is a little unclear so far, but that's what that discussion is about. Why would you need to alias a box? So the reason need to alias a box is so that the two, the left and right copy both share the same underlying data. What's the advantage of using maybe on it box t over turning the box T into mut and just aliasing that one. The biggest advantage is actually one of generality. So it's true that any time where you have a box T that you want to alias, what you can do is you can turn it into a star mut and then you can just alias the star mut. But the more general case is you have some type X and you want to alias X.
00:33:36.273 - 00:34:27.225, Speaker A: This is the case we run into with the left right map where X is a user defined type that may be a box, but it Might also be a vector, right? And if someone gives you a vect, then the correct way to alias is like usize. Usize, right. That's a real way to alias a vector. So what we want is some way to do aliasing in general rather than how to alias a particular type. Because left right is generic over whatever the backing type is. And maybe lets us do that because we can alias boxt by doing maybe uninit boxt and we can alias vect by doing maybe oninit vect. Right? So it's a general purpose mechanism.
00:34:27.225 - 00:35:52.905, Speaker A: Rust doesn't give no alias to mut. I think it's currently that optimization is disabled at the moment, but it is an optimization that they would like to have enabled. When can you assume that maybe on init is safe is valid? You mean so the maybe oninit assumeinit method, which is the one that goes from a maybe uninit t to an actual T which is unsafe. The safety requirement is there is basically you need to know that the bit pattern that's stored inside the maybe oninit is now a valid representation for T. Sorry. So for example, if you have a maybe uninted boxt, in order to get the boxt, you would have to ensure that it now meets all the validity requirement of boxt, which would be things like the box is not aliased and also things like the pointer is not null, the pointer is aligned, the pointer points to a heap allocation that was originally allocated by box. Basically every requirement for the backing type is there a way to disable those optimizations? And in the example of the double fetch, actually fetch the value two times.
00:35:52.905 - 00:36:43.097, Speaker A: So the way you disable the optimizations is to. Well, in general you should not assume that you can turn these optimizations off even with optimization level 0. Some of this might leak through because these are optimizations about the compiled code that may or may not result in optimizations. Remember, the code generation tool is always converting your code into assembly and it might choose to do so in a different way if it knows that something is not aliased in some sense. Maybe oninit here is one way in which we disable that optimization. And if you're thinking of disable these optimizations, you should think really carefully through why that is. Keep in mind that generally Rust's rules around borrow checking are for a good reason.
00:36:43.097 - 00:37:31.223, Speaker A: And if you're choosing to override those, what's the reason? If you're trying to do things like mutate through a shared reference, then use the unsafe cell type because that's what it's for. And one of the reasons you will specifically want to use the unsafe cell type rather than doing pointer like. One thing that's just never okay in Rust is to if you have a ref t to cast that into a mutable reference. There are all sorts of ways for you to do this. Like with a transmute, you can make this happen, but you should never do it, because even if you manage to do it, it is not safe. And one of the reasons is things like no alias. The only safe way to go from a shared reference to immutable reference is using the unsafe cell wrapper type.
00:37:31.223 - 00:38:20.339, Speaker A: And the reason for that is the unsafe cell wrapper type. Basically, the compiler knows about this particular type and knows not to emit things like no alias for it. Think of it as. This is the way that you disable those optimizations. Is there a difference when you say shared reference and alias? Yes. So this is a shared reference to a T. Whereas if I have a box t whose value is a pointer like this, and I have a second box t, I have a second box T that has the same pointer value, then this is.
00:38:20.339 - 00:39:11.485, Speaker A: This is aliased. So a shared reference to T is always an always aliases T. Right, because you can have multiple shared references and those are aliased pointers to the T. But you can have aliases that are not shared references, so they're not quite the same. Does maybe INIT do more than basically just transmuting? No, maybe on INIT is really just a transmute, but it's a type that Rust knows about and knows to, for example, not assume aliasing about. It mostly just changes the flags that it passes to llvm. Why not use raw pointers instead of an aliased box? The reason is the one that I talked about before, which is we want a mechanism that works for any user defined type and not just specifically for box.
00:39:11.485 - 00:39:45.495, Speaker A: What does maybe on INIT do for pointers? If there's no null Maybe oninit doesn't. It doesn't deal with pointers. Maybe uninit is just. You can think of it as whatever type is the inner type. So if it holds a box T, then the maybe oninit is a box T, but with all the. But that you can't directly use without unsafe code because it doesn't have the same validity requirements. So maybe oninit is just a transparent type that makes it unsafe to access the underlying type.
00:39:45.495 - 00:40:34.911, Speaker A: Okay, I think we've. We've now talked through most of the stuff around around aliasing. But there is one point that comes up and which did also come up in chat a little bit, which is one trick that Left right was trying to pull was it didn't actually start a box. Because what would happen is if you have, if you have this case right, you have a left and a right to both point to the same heap allocation. Then if we drop left and then we drop right, this is a double free right, the drop of left is going to drop the box and that's going to do free the heap allocation. And then we drop the right, it's going to drop its box, which is going to try to free that heap allocation a second time. Clearly not.
00:40:34.911 - 00:41:14.865, Speaker A: Okay, so what Left right did was it used a type called manually drawn in the standard library and manually drop. Let me pull it up here. So manually drop is also a transparent wrapper type, sort of similar to maybe on Init, but not really the same. Manually drop is a wrapper that just disables dropping. That's all it really does. It doesn't require any unsafe to access the inner T. Maybe arguably it should, but it does not.
00:41:14.865 - 00:41:55.063, Speaker A: Manually drop just is a T but will never drop that T. And there are a bunch of cases you might think of that where this is useful and this is one of them, right? Where now if you drop left, it's not going to drop the T because manually drop prevents the drop. But now if you drop the right, that's also not going to drop the box T. And so now you never end up dropping. But at least that sound, it's going to leak a bunch of memory. But it is sound behavior. But if you look at manually drop, you'll see I wish this was the default expansion that manually drop implements D ref and D ref mute.
00:41:55.063 - 00:42:35.115, Speaker A: So if you have a manually drop T, you can easily just get a shared reference to that T or an exclusive reference to that T just by using like ampersand mute or stars to get at the inner, or dot for that matter, to get at the inner type. There's also an into inner which just removes the manually drop wrapper and gives you the inner T. And you'll notice that that function is not unsafe, right? That function just gives you the T and that's all there is to it. So in other words, manually drop just disables drop. It doesn't do anything else, it doesn't prevent, it doesn't enable you to do aliasing or anything like that. So, so far so good. That looks nice.
00:42:35.115 - 00:43:34.395, Speaker A: But we do obviously sometimes need to drop the box T no, the code I've written so far, like if you have manually drop would never drop the box T. Like when you drop left, nothing gets dropped or the box doesn't get dropped. When you drop right, the box doesn't get dropped. And when the scope ends, the box doesn't get dropped. The box just leaked. And this is obviously not okay, the way that this, the way that I did this in, or the way you're supposed to do this. Let's start with that part is that you're supposed to like drop something like left, right? And then when you know that you actually want to drop the inner type in our case, because we know that this is the last copy, then what you do is you do right into inner and remember, into inner gives you the T that's inside a manually drop and then that you drop or just let go out of scope.
00:43:34.395 - 00:44:19.573, Speaker A: Like you could just do this as well and it would work just fine. But basically you sort of tail manually drop. Okay, now I do want to drop the T and at that point you would only end up with a single free. Okay, so far so good. Where we run into issues is that imagine that I don't actually have a manually Dropbox T. What I have, or I do have a manual Dropbox T, but what I have is actually like let hashmap equals hashmap new insert. I don't know.
00:44:19.573 - 00:45:15.657, Speaker A: Zero, right? I don't know. I'm not necessarily writing valid code. But that's fine. Let me comment this out. So actually what we have is we have a left map and a right map and they each one contains an aliased copy, right? And now imagine that the user wants to execute an operation like they want to call retain, right? So you want to call like left hashmap retain Retain, if you don't know of it, is a method on most collection types that just walks the. It walks all the elements of the collection. And if the retain closure returns true for that element, it remains in the collection.
00:45:15.657 - 00:45:46.775, Speaker A: If retain returns false for that element, it gets removed from the collection. It's a really easy way to do, just like remove a bunch of things that are related or keep only the things that have a certain property. So let's say like E. I don't know, in this case E not equal to 5 or. Yeah, so this is going to remove any element in the map whose. I guess technically this is key value. So let's do this.
00:45:46.775 - 00:46:32.785, Speaker A: So it's going to remove any value in the map whose value is not 5, and that includes left, right because left's value is 5. So here that's going to get removed, which means that the map is going to drop the value. Now that's fine because in this case, let me add these annotations here too. Manually drop new and here as well. Manually drop new this. All right, let me just get rid of some warnings here. Manually drop and collection just to make this a little less noisy.
00:46:32.785 - 00:47:31.895, Speaker A: Yeah, yeah, yeah, yeah, that's fine. Box five box into RAW I'm just cleaning this up so that the code will actually compile because that way there are fewer distracting error messages from RAW V. And it also shows you more what the code actually used to look like. Hashmap I can't. Can't spell. Expected to take two distinct arguments, fin and V Real. V real.
00:47:31.895 - 00:48:03.481, Speaker A: Ah, fine. Now what? This. Great. Ok, so now that compiles and now you can believe me that it's possible to write this code. Ok, so the retain here is going to remove left, right? Because the left value is indeed 5, so it doesn't match retain. So that map, when you call retain, the inner code of retain is going to end up dropping the left. Now left has a manually drop for the box, so it's not going to drop the box.
00:48:03.481 - 00:48:33.255, Speaker A: Great. But now we need to do the same operation to the other map. Right? So we call the same thing on the right hash map. Great. But this also ends up dropping. Right, but it drops right with the manually dropped wrapper. So this means that the underlying box, the box that's aliased, does not actually get dropped anywhere.
00:48:33.255 - 00:49:13.411, Speaker A: And we don't really here have a way to use into inner. Remember how before we would call like write into inner when we actually wanted to drop it? Well, how do we do that here? Because we are not the ones writing the drop code. Of course we could re implement retain ourselves and have it like walk the thing. And anything that we decide to remove we call like into, in or on. We could do that, but it's really annoying. It would be nice if the code could just look the same. So this is where the second trick that ended up biting me in the ass earlier came up, which is I pulled this trick where I did the following.
00:49:13.411 - 00:51:26.295, Speaker A: I'm going to write it out and then we're going to talk about why it's wrong. Sorry, let me just. I think I now have it right do user op just to signify that step specifically, this is actually what that used to be. And then the manual D drop was on the alias. Sorry, I promise I will explain what this does I just need to write it out first. So I just moved the manually drop from being unreal to being around the alias. And then this was aliased, and this is real and this is the star.
00:51:26.295 - 00:52:11.305, Speaker A: Okay, great. So what I decided was to do this cast and in order to understand this cast, which is looking really ugly, we need to look really carefully at the types here. So the type of write hash map is a hash map from, in this case, I guess the key is an i32 and the value is a manually drop aliased usize. Right. That's the type of the right hash map. And this should make it pretty clear why removing something from the right hash map doesn't drop it. It's because the values are manually dropped and so dropping the manually dropped does nothing.
00:52:11.305 - 00:52:51.359, Speaker A: So what we're doing here is we're casting the reference that we have to this thing, the mutable reference we have to this thing, into a mutable reference to this thing. And if you look really carefully, you'll see. So we have this and we're trying to turn it into this thing. So essentially what we're doing is we're doing a typecast that casts away the manually drop. Right. And you might think this should be okay. Right.
00:52:51.359 - 00:53:30.987, Speaker A: Manually drop has the annotation rep or transparent. So it has the repertransparent, which means that casting from this to this should be fine because this should be laid out in memory exactly the same as this is. Right. And why does this solve the problem? Well, if we have one of these and then we drop this thing, there's no manually drop here. So it is actually going to drop the inner value, which means that it's going to drop the box. So now we can keep using retain and it will do the right thing. We'll end up actually calling drop when we do this operation the second time on the.
00:53:30.987 - 00:54:08.629, Speaker A: On the right map, on the second alias, which is the last alias, does this. Before I talk about why this doesn't actually work, does this make sense? Like why, why this seems like it should work? Repertransparent. Does repertransparent work across generics? Yes. So. So repertransparent. All repertransparent does is it says when you put repertransparent on a type, that type has to have only a single field. That's it has to have only a single non zero sized field, which is to say it basically just has to have one field.
00:54:08.629 - 00:54:33.115, Speaker A: And the layout of the outer type has to be exactly the same as the layout of the type of that one field. So that includes things like generics. It's just the outer type is exactly the same as the inner type for any value of the outer type. For any instance of the outer type. Sorry. So in that sense, yes, it does work across generics. Oh, op here is operation.
00:54:33.115 - 00:55:24.135, Speaker A: Operation. Right, so we do some operation on the map here. I've chosen retain because it's sort of an obvious case of where we don't choose how the dropping happens. So the idea behind this cast is that it lets us just not worry about what this operation does internally and instead just cast away the manually drop so that whatever it does, when it drops things, it drops them correctly. So this trick seems nice enough. Unfortunately, this is not sound. This is a problem.
00:55:24.135 - 00:55:58.719, Speaker A: And to understand why, we need to dig into the trait system. So let's start some code up here. So we assume the standard library hash map, but let's just make our own hash map. So our hash map is going to take a k and a V and it's going to hold like, values, which is going to be a vec of tuples of k and V. This is not actually how hashmap works, but we're going to go ahead and do that. Seems fine. And then we're going to have a bunch of methods on hashmap.
00:55:58.719 - 00:56:32.745, Speaker A: But now this particular hashmap that I have is wonky. It's going to require that the V is wonky. And wonky is going to be a trait that we define. And wonky has an associated type. Foo doesn't have any requirements on that type, it just has an associated type. And we're actually going to store a foo right here. We're going to have a prefix which is going to be a V foo comma.
00:56:32.745 - 00:57:15.305, Speaker A: Fine, that's fine. Let's do this. Well, actually, let's do hashmap. Let's do my hashmap. All right, so it's a little weird, like, who would write hashmap this way? But there's nothing stopping anyone from writing code that looks this way, right? Like this could be any wrapper type that is in some other crate or even in the standard library. Who knows, right? And now what I'm going to do is I'm going to implement wonky for aliased. Oops.
00:57:15.305 - 00:58:31.785, Speaker A: And here foo is going to be a ua and then I'm going to implement wonky for manually drop alias T&FOO is going to be U32. Do you see the problem? The layout of my hash map depends on what this type is. And this type is U8 if you have an alias T&U32 if you have a manually drop alias T. So this means that the layout of a My hash map I32 aliased T, right, is a U8 followed by a vector of I32 and alias T. But the layout of a MY hashmap manually dropped alias T is also a vector of these, but it's prefixed by U32 instead, because that's what the associated type foo is for the wonky trait. So these are not the same. They're not laid out the same at all.
00:58:31.785 - 00:59:10.715, Speaker A: And this is a trivial example where this is like another field, but you can imagine that, like, it sticks some of those in the vector itself. Like the whole structure could be laid out differently depending on whether you use this or this. Now, this seems a little malicious, but there's no unsafe code here, right? And now imagine that we don't like here either. Imagine that the user could choose what hashmap implementation to use here. But crucially, imagine that they just. The value type the T that we're wrapping in our box has. Well, not the type we wrap in our box, but the collection type we use.
00:59:10.715 - 00:59:52.615, Speaker A: If the user, if there's anything at all in that wrapper type right inside of like hashmap contains a vector, and maybe the vector contains some other structure. If any of those are dependent on any associated types, depending on the value, then. Now, this transmute is not sound, because going from this to this is like going from casting from a mute U8 to a mute U32. It's just not okay. They're not the same. You can't do the same things with both of these. So this transmute, even though it seems like it should just be identical, it isn't.
00:59:52.615 - 01:01:02.985, Speaker A: They can be different if you have a particularly wonky outer structure. All right, so how do we fix this? This sounds like a huge pain, and it is finding a way to work out this work around this was really hard. And I have a solution that is probably sound, but it depends on another thing that has still not been decided in the type system, which is, okay, we have this observation that the reason why this isn't sound is because someone could depend on some implementation that uses an associated type. And really what that comes down to is somewhere else, someone outside of the current crate can tell the difference between these two types and therefore can choose that the layout of their type depends on it. So the solution has to be to construct the types that we cast between in such a way that no Other crate can distinguish between them. And the way we're going to do this is as follows. Instead of having manually drawn, what we're going to have is this.
01:01:02.985 - 01:02:08.525, Speaker A: We're going to cast. We're going to add an associated. We're going to add a sorry, not an associated type. We're going to add another generic type parameter to aliased that dictates whether or not it should drop the inner type. And so you can imagine that we implement drop for aliased, right? And then depending on what the type the second type is, we choose whether to actually drop the inner t instead of call manually drop into inner or we're going to not do that. And casting between these two should be sound as long as these two types are both private. And the reason for that is if no other crate knows about this type, if they can't name this type and they can't name this type, they have no way of implementing a trait for this differently than how they implement it for this.
01:02:08.525 - 01:03:01.245, Speaker A: This also means that these types no drop and do drop have to not cause any differences in what alias looks like. So, for example, if aliased implemented debug only if it was no drop, but not if it wasn't do drop. Sorry. If aliased implements debug, if it has no drop but it doesn't implement debug when it's do drop, then now we have the same problem. So we can implement the wonky trait for any aliased sort of t U where u is debug and then implement the wonky trait differently for any alias t U where u does not implement debug. So they have these two have to be indistinguishable outside of the current crate. This is complicated, but it does work.
01:03:01.245 - 01:03:59.545, Speaker A: The way we're going to do this is we're going to have a trait drop behavior that just has like a do drop method. And do drop doesn't need to know about the current value, it's just a method on the trait, if you will, returns a bool and we implement drop behavior. We have a struct no drop and we have a struct do drop and they must not be public. And we implement drop behavior for no drop which says false. And we implement drop behavior for do drop which returns true. And then we implement we changed aliased so that it takes a t and a u. It holds a manually drop box t again, so it no longer holds.
01:03:59.545 - 01:05:24.595, Speaker A: We don't put the manually drop outside the alias, we put it inside the alias again and it holds a u It has to be repr transparent. And I'll talk about the U here and repertransparent in a second. And U is going to have to implement drop behavior. And then we do this impldrop where U implements drop behavior. And when you're asked to drop one of these, if you do drop then self real into inner drop that the code can't actually look quite like this, but it's close enough to explain what's going on. And so now there's no way for an attacker, if you will, or just for innocuous library that doesn't know that you have this requirement that they're castable to implement. Like they have no way to distinguish between no drop and do drop.
01:05:24.595 - 01:06:17.003, Speaker A: It can't, because no drop and dewdrop are not public. They're not available outside of the create the defined aliased. So if we don't export them, all it can do is this. But these are overlapping implementations, so the compiler will reject them. It doesn't have a way to change the layout depending on what this this other type is, which means that these the associated type here must always be the same, which means that the layout should always be the same. Which in turn means that this cast from alias no drop to alias do drop should be valid because there's no way that this type can vary in its layout depending on what this inner type is. So it's a fairly sophisticated argument and it's not actually guaranteed that this is sound.
01:06:17.003 - 01:07:23.421, Speaker A: So this gets back to another discussion that came up which is talking about deterministic but undefined layout. There's also an issue from the unsafe code guidelines issue number 35. And here I recommend you read through the discussion. It's fascinating stuff. And what we got to here was basically I proposed is this a valid cast? Let me see if I can dig into this some more so further down here. Yeah, so here is where I give this proposal a transmute from some wrapper mytype T and then some private second type to the same type with a private type B where their unit structure implement no traits and where the sort of mytype is repertransparent. And the response was that sounds like a very reasonable request, right, for there to be some way to have this kind of type parametricity cast be safe.
01:07:23.421 - 01:08:28.945, Speaker A: Now, it's not currently guaranteed that this is valid, but it is much more likely to be sound than the previous version, which we could clearly demonstrate was not sound. This one I haven't been able to demonstrate is unsound. And this is why this issue is still open because it's not clear that this is something the compiler currently guarantees or something it wants to guarantee. And this is why the Unsafe Code Guidelines Working Group is so important, because they're trying to figure out like what are the actual rules and what are the rules that we're willing to commit to. Right, because if you commit to some kind of behavior being sound, you're not allowed to add an optimization that requires different behavior in the future because people have written code that assumes that a given behavior is sound. So yeah, this is the solution that I've come up with and that I think is sound, and hopefully it will remain sound. I didn't actually modify this cast, but the cast remains basically the same, right? It just turns into this.
01:08:28.945 - 01:09:40.401, Speaker A: And yeah, there's one more thing here to get back to, which is repertransparent requires that there's only a single non zero sized field. So we're not really allowed to store you here because even though we only ever use it with no drop and dewdrop, which are zero sized, there's nothing stopping someone from creating like an aliased usize, right? And now this couldn't be rep transparent because it's not just one field. And so we use this is where the marker trait phantom data comes from, which is we want to retain information about you at compile time, but we're not actually going to store a U in this type. And this means that this field is always zero sized. This field basically disappears at runtime. It's only used at compile time for sort of carrying around the generics information. And the reason why it's okay for us to store phantom data here is because the drop behavior trait does not take a reference to self.
01:09:40.401 - 01:10:43.825, Speaker A: It doesn't require that you actually have an instance of the trait in order to answer whether or not to drop, because the drop behavior is determined by the type. Overall, like do drop always drops, no drop never drops, and there's no value for us to care about. Okay, so this now gets at how we ended up getting hopefully at least sound aliasing in left right, we use. So we had to combine both these approaches, which I haven't showed you in the code so far, which is aliased has to contains a maybe on init. It can't be a manually drop, it has to be a maybe on init because we have to remove things like the aliasing requirement from box. So the real alias in left, right, if you go look at it actually holds a maybe on in it, not a manually drop. And then we need to have this associate or this not associated type, the second generic type parameter that is entirely private that we cast between in order to make sure that the.
01:10:43.825 - 01:11:07.221, Speaker A: The cast is actually valid. Who. All right, that's a lot of complexity that I've thrown at you. And so let's do some more questions around this. I don't. What's a little weird about this particular type of stream is that there's like not that much coding. It's really just talking through the complexities and how to resolve them.
01:11:07.221 - 01:11:38.725, Speaker A: So I don't actually have anything more I want to talk about today, but we have talked about a lot of really complex stuff and interactions. And so I'm sure there are a lot of just related questions and things that I can go into more detail on and help you understand why things work or don't work. So please fire away with questions. And that will probably take some time too. If I understand correctly, the user of this library is only given an abstract alias. All the fields are private. Yes, that is correct.
01:11:38.725 - 01:12:29.403, Speaker A: So if we go back here and look at left right. So left right has this aliasing module that actually talks a bunch about this, and it has an alias type. And the alias type has no fields but the alias type. The alias type does implement de ref into the inner type. So if you have an alias T, then you can always get. You can safely get at the inner T. The reason why you can do this is because it's sort of like the same argument as manually drop, that it's unsafe to construct the alias in the first time, and it's.
01:12:29.403 - 01:13:21.913, Speaker A: Well, it's unsafe to cause the alias to be dropped to drop the inner T and therefore as long as that part is unsafe and you have to manually guarantee that it's safe, then it should always be safe to deref an alias because of the safety invariant of actually dropping. These arguments are all understandable. But any unsafe seems so difficult to get right. Accidentally being unsound is so easy. I feel unsafe somewhat deserves its reputation. You're not wrong. It is true that unsafety is complicated, and it sort of is complicated for a good reason, right? Like the reason why this code is so hairy or this why the reasoning here is so hairy is because there's a very sophisticated property that we're trying to guarantee.
01:13:21.913 - 01:13:53.935, Speaker A: Like think of if you. If you were to do this in C code, right? All the same conditions would apply. Aliasing, not so much. Because in C you generally don't pass no alias to llvms. You don't get the same optimizations, but if you try to cast between two different types and they have a different layout, you would have the same problem. It is true that in C it's sort of hard for them to not have the same layout because you don't have things like generics in the same way. So the same problems can't arise, but the.
01:13:53.935 - 01:14:51.355, Speaker A: The properties that you're trying to maintain are the same. I think the reason why it becomes complicated in Rust is because there's so many interactions with the rest of the Rust type system to think about. And it's hard. Like, evmap did this the wrong way for years, but it worked right? Like it was being used in sort of a real research system for lots of benchmarks and testing, and everything worked just fine. So, like, it's tricky, right, because unsound and unsafe behavior is. Or unsound behavior specifically is like, it is a problem because it could randomly break at any time, right? The next compiler release might suddenly cause everything to go wrong, and it might go wrong in really bad ways. So that's why you should avoid unsound behavior or undefined behavior.
01:14:51.355 - 01:15:26.055, Speaker A: But if it currently works, then that means as long as you don't upgrade anything, you're probably fine. That's not a good safety requirement to rely on. But. But oftentimes it's like, good enough. And I have a lot of understanding for people who write unsafe code and go, this might technically be unsound in some way, but it generally works the way that I use it, so therefore I won't fix it. I understand the argument. I think it really depends on what the.
01:15:26.055 - 01:16:01.125, Speaker A: What the sort of blast radius of being wrong is right. If you, if you're just like writing your own code base for some hobby project, it probably doesn't matter. But if you're writing like code for the space shuttle, this probably really matters. So you get all the unsafety right. And that does require you to do a lot of pretty sophisticated reasoning. I think in general, you can get pretty far by just being extremely skeptical of anything that says unsafe. In general, the best rule of thumb I've heard for unsafe is that unsafety is a crate property.
01:16:01.125 - 01:16:46.015, Speaker A: If you do anything unsafe in your crate, it's not just about whether the surrounding lines are right or anything. It's that you need to guarantee that all of the other code in your crate is still sound now that this unsafe thing is happening. And that requires really hard reasoning. And that's why for basically any piece of unsafe code you write, you should write A safety comment above explaining why this doesn't invalidate any of the other safe code in your system. But it's hard. The other way to get at this is to run everything through Miri. So Miri, if you don't know about it, is a really handy tool that basically it sort of runs your.
01:16:46.015 - 01:17:41.665, Speaker A: Runs is a fudgy word when it comes to Miri, but it basically runs your Rust code in a mode where it can detect unsafe behavior. Now, Miri is a little limited in that it only detects unsound behavior if it occurs. So it can't detect if your code like sometimes does something unsolved sound if your tests don't trigger that particular case. But it is really good at if you do something that is unsound, it will tell you. And this is why for unsafe code like testing is just absolutely key. You want to run it through Miri, you want to run it through things like address sanitizer or through valgrind. You probably want to run it through something like Loom, which is a sort of concurrency testing tool that's really handy in Rust.
01:17:41.665 - 01:18:33.155, Speaker A: You just need to be really thorough about vetting unsafe code. How did you figure out that the cast without do drop no drop trait was incorrect in the first place? So this came up in the previous stream, actually, where someone was like, are you guaranteed that this cast is safe? And I was like, I think this cast is safe. But let me ask. So if we go back to here, let me see if I can find my particular comment. Yeah, I recently came across a case where I specifically wanted to cast a some type T into a some type manually dropped T. And in trying to figure out whether that was safe, I found this discussion. I think that case works correctly in the compiler today, but I suspect that it's still an open question whether it should, should or will be guaranteed by the language to be okay, subject to the discussion in this issue.
01:18:33.155 - 01:19:01.737, Speaker A: So that's really where this stemmed from that I was like, I think this transmute is okay, but it might not be okay because this is super subtle stuff. I googled around for a bit. I found this open issue, I commented on it and then a lot of really interesting discussion happened. Can you explain it? Like at five, like I'm five. That unsafe cast line. Okay, yeah. So this is a sort of fun aside, this cast line.
01:19:01.737 - 01:19:42.155, Speaker A: So let's dig into what this is doing. It's like worthwhile to go through because casts are nasty. So right. Hash map here is really a hashmap. Right. Of aliased use I32 aliased use size, no drop. Right? We can't cast the actual own type.
01:19:42.155 - 01:20:17.085, Speaker A: We want to cast a mutable reference to it. So that's why this takes a mutable reference out of that. So that gives us a mutash map of that same inner type. Then you're not allowed to cast directly between reference types. So if you have a. Like, you can't just cast directly from this to this. You can only do that kind of typecasting either by using MEM transmute, which you should generally avoid because it lets you do really unsound things.
01:20:17.085 - 01:21:09.985, Speaker A: But you can cast between raw pointer types to things like this. So for example, if you have a. One thing that comes up a lot is if you have a mute U32 and you want to cast it to a mute U84, this is sort of a. This is safe because they're the same layout, right? You can't cast directly between them without using a MEM transmute, which you want to avoid. So what you do is you turn this into a Starmute U32 and a Starmute U32 you can cast into a Starmute U84 and then you use a starmute star to turn it into ref mute. So that's the same song and dance that goes through here. This.
01:21:09.985 - 01:22:23.575, Speaker A: This turns it into a. This turns the mutable reference to the hash map into a mutable pointer to the hash map. This is what actually does the cast to do drop. The reason this is a cast to do drop is because I've specified that the type should be dewdrop here, so the compiler can sort of reason backwards to what type, what type I wanted this cast to turn into. And this star mute star is the way that we go from a mutable pointer to immutable reference. Have you found that most unsafe usages can be replaced with safe code at no performance penalty? Yes, unsafe code generally, you should only generally need it if you're writing like core primitives, like I write a lot of concurrency primitives, things like left right, or like concurrent hashmaps and stuff, where you're really in the low level. And there you sort of need unsafe because you're relying on invariants that the compiler doesn't know about and that aren't common.
01:22:23.575 - 01:23:31.795, Speaker A: And when I say common, what I mean is like if you look back at. I did a stream a while back about interior immutability and things like cell, and the interface to cell is completely safe, and it's common enough that someone actually wrote the cell type and put IT in the standard library. Usually, if you're writing like your own concurrency primitive, the invariants you're relying on are so specific to your particular problem domain that no one else has written the thing that you need and so you need to implement it. But outside of writing really low level code, you probably don't need unsafe. There's probably already a safe wrapper that you can use, and in general those do the unsafe internally to mitigate the performance cost. So it's probably just as fast as the safe code. You should not think of safety as requiring a performance cost, because if you can do it with unsafe code and have it be safe, that means that there's some way to write a safe wrap around the code that does exactly the same thing you did, and therefore has no performance cost.
01:23:31.795 - 01:24:42.307, Speaker A: Isn't the compiler going to drop the manually drop in case of memory optimized programs, since the code won't require the variables? Again, no. So the whole point of manually drop is that when you drop it, it never drops the inner type. How could an implementation of the left right look like that does not use unsafe aliasing at all? The safe implementation of left right? Well, there's other unsafety in left right that's not related to this particular problem. But if we look just at this particular problem, the version of left right that doesn't use this unsafe aliasing is that you use arc. So use an ARC of usize or an ARC of whatever the inner type is, and then you just keep one clone for each map and that's totally safe. Left right could do this. There are a couple of reasons why I didn't want to do it.
01:24:42.307 - 01:25:29.025, Speaker A: One is that this means that you have to. The copies are. Well, you end up having to do reference counting every time you want to create an alias. And anytime you drop the aliases and that reference counting isn't really needed because it just sort of does the right thing already. Like the left right primitive already knows when to when you should when you're dropping an alias so you shouldn't drop, and when you're dropping the last copy, in which case you should drop. So the reference counting is sort of just overhead. The other reason why I didn't want to do an ARC T, and this is sort of the primary one, is that imagine that the user specifies a T of like box foo.
01:25:29.025 - 01:26:11.491, Speaker A: Then now what this data structure is going to store is ARC of box of foo, which is sort of wasteful, right? Like you're having an extra heap allocation just to store a box, which is heap allocation. Even worse yet, imagine that the user gives a type of ARC foo. Then now we're going to store an ARC of ARC of foo. So every access is going to be sort of penalized because it has to go through an extra level of indirection. Now, this is not impossible. It's not like you could totally do this. The cost would be fairly small for many applications.
01:26:11.491 - 01:27:13.421, Speaker A: But left right is specifically for where you have really, really, really high throughput reads, where you care a lot about the latency of each individual read. If you didn't, you could just use like a reader writer lock or something like that. And so I'm assuming that the people who use left right will care about things like an extra pointer dereference and therefore I didn't want to force the additional use of a reference count update and the extra pointer dereference, which the aliasing avoids. That said, this would fix another outstanding unsafety problem in evmap, which is. So actually this is worth touching on briefly, which is imagine that the retain here, right retain here is doing a comparison right of the inner value. Now let's say that instead of being 5, this was some user defined type like foo. And I imagine the implementation of EEK for foo is non deterministic.
01:27:13.421 - 01:27:51.665, Speaker A: It just like randomly returns true or false. Then when you do the operation on the left map, you might choose not to remove the value because the randomized implementation of eek returns false. And then in the right hashmap when you do the retain, it randomly turns true and so it does get removed. Then now you didn't remove the value from the left map, but you did remove it from the right map. But because you thought it was removed from both, you end up actually dropping the value even though an alias still exists. And guarding against this is really, really difficult. There's an open issue already on EVMAP for this problem with arc.
01:27:51.665 - 01:28:49.411, Speaker A: This wouldn't be a problem because the reference counting would notice that it's not safe to drop the second alias because one still exists. So I don't have a good solution for this. ARC would solve the problem, but it comes with its own costs. It might be that the solution is that creating an EVMAP has to be unsafe and that you need to guarantee that every operation like hash eek partial eek is deterministic. An analogy I was thinking of here is that Russ has a lot of powerful tools and the more powerful the tool, the worse things can go wrong when you have to take off the safety guard. It's a good way to think about it. The alternative way to think about it is that you have a really complicated machine and you're fiddling with one little bit on it, but everything else is connected.
01:28:49.411 - 01:29:43.335, Speaker A: So fiddling with this one bit might cause a problem over here. And so this is like the interconnectedness of. There are lots of features that interact in interesting ways, and you need to reason about how all of them interact with the change that you're making. It's sort of tight coupling, if you will. And I think this point came up in chat too, that one challenge, especially with generics and unsafety, is that you have to ensure that your unsafety holds for any value for the generic type, which might be tricky. Why not transmute to maybe on Init instead? That should always be fine. Here you have the same problem.
01:29:43.335 - 01:30:30.865, Speaker A: If this was like casting between not maybe on init and maybe on init or the other way, you still have the wonky problem. Now, of course, internally, Alias does have to do have a maybe in it. So if you look at the code for left, right, you'll see that that's there. Don't U32 and U84 have different alignments? Yes, they do. So you're not allowed to cast this into this, but you are allowed to transmute this into this. So you can go one way but not the other. Doesn't Alias already introduce a layer of indirection with the box to me, that looks like an arc without the reference counting? No, not quite.
01:30:30.865 - 01:31:04.273, Speaker A: So maybe on init is not a heap allocation. Maybe on init is not a pointer. Same with manually drop. It's not a pointer. The definition of manually init, you can maybe in it you can sort of think of as this. It doesn't store like if this means that if you have a maybe, maybe if you have a maybe uninit box T that really is just a box T. There's no.
01:31:04.273 - 01:31:43.763, Speaker A: There's no additional pointer or anything. It's just that the compiler knows that you can't actually assume that it. That it's a valid box T, but there's no extra indirection. All right, let's see. This test seems kind of simple at this point. Might as well just make it wrong. Okay, so hopefully that was useful.
01:31:43.763 - 01:32:20.463, Speaker A: Hopefully you feel like you learned a little bit about. Learned a little bit more about how this stuff works under the hood. And there are many issues with unsafe. This journey is not over. And the point of the stream was not necessarily to teach you how to write safe code. And that's never going to be My goal with this particular series, it's just to expose you to the kind of things you have to think about when writing unsafe code. I don't know when the next stream will be.
01:32:20.463 - 01:33:06.375, Speaker A: It'll be whenever. I have another interesting thing to talk about, but hopefully just sort of talking through the kind of problems that can arise is useful and interesting. There is and hopefully, hopefully it was possible to follow. Like this stuff is super involved and I highly recommend that you look at the issues Both on the NSF coding guidelines and the ones on EvMap and maybe even look at the code of left, right. I'll link all of those in the video description eventually because it's some really fascinating discussion around it as well that I think is useful. If you're going to write code like this yourself, just getting into the right mindset helps a lot. Someone asked about structural EEK for the EQ bug.
01:33:06.375 - 01:33:44.385, Speaker A: Structural EEK doesn't actually solve the problem because first of all, structural EQ is really limited. So the advantage of structural EEK is that it's derived by the compiler and so you're guaranteed that it's deterministic. But it doesn't actually. But it means that if someone has their own type that is not structurally, then they can't use your data structure, which seems really sad. The other is that structuraleq is not the only problem. Imagine that we do this. Here's an example of something that does not rely on eek.
01:33:44.385 - 01:34:45.109, Speaker A: So imagine that we had this instead and of course we do the same thing for. Do the same thing down here for the right map, right? Now this depends on the iteration order of the map, right? Whichever thing you iterate to first, that's the thing you're not going to drop. You're going to drop all those. All the subsequent elements. Well, what if. So the iteration order of a hash map depends on the hashes of the values that are in there. So if the user controls the key type right here, let's imagine this is like foo some user type and the user implementation of hash for foo is non deterministic.
01:34:45.109 - 01:35:28.445, Speaker A: You have the same problem because the iteration order will be non deterministic. So which thing is first? It also varies. So we actually need to require both that. Sorry, let me leave the code up. We actually need to require both that the keys and values are deterministic in their permatation of E and of hash and maybe even of or depending on what the value type is. I think maybe the takeaway from this is like do not write unsafe code unless you have to. There are some cases where you have to, where there's some invariant that you know is maintained, but the compiler can't know.
01:35:28.445 - 01:36:17.167, Speaker A: But for most of the code you write, that shouldn't be true, right? For most of the code you write, someone probably ran into the same sort of data structure problem you had and wrote a data structure that is safe, that internally does the unsafe stuff. Like don't do unsafe stuff yourself, unless there really is no safe implementation of it that you can use. Because getting unsafe stuff right is hard. It requires a lot of thinking, and not just a lot of thinking, but a lot of understanding of what the actual rules that the compiler enforces are and that the typesysm enforces are. All right, I think. I think that's everything for today. Hopefully that was useful.
01:36:17.167 - 01:36:41.369, Speaker A: I'll upload this to YouTube and then I will see you next time. I don't know when the next stream will be. I don't even know what topic it'll be on, whether it'll be sort of a crust of rust or a Long Live coating or another Unsafe Chronicles. I guess we'll see. But hopefully this was interesting. If you think that this particular series is like, valuable, then please, like, please. Which is the opposite of what people usually say or just like mention it in the comments.
01:36:41.369 - 01:37:08.075, Speaker A: It's really useful for me to get a sense for what people find interesting and useful and educational and what they don't. If this kind of stuff just sort of goes over everyone's head and you feel like the only takeaway was everything is hard, then this is not a valuable stream, but so any input you can give me is always valuable. All right, everyone, thank you for coming and I'll see you next time. So long. Farewell. Bye.
