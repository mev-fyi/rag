00:00:01.160 - 00:00:29.535, Speaker A: All right. Hello everyone. This is part three of the Tokyo Zookeeper adventure that we're on together. Just to mention it again, because I do, every time I'm John, I do a bunch of these open source streams. This is one of the more advanced. This is like a later part of a more advanced stream. You can find them all on my Patreon page or on my Twitter page, or if you look at YouTube, my account there, there's a playlist of all the different Rust videos that I've made.
00:00:29.535 - 00:01:05.837, Speaker A: What we're doing in this particular instance is we're building Tokyo Zookeeper. So the idea is to build an asynchronous crate that allows you access to an Apache Zookeeper instance. So Zookeeper, you can think of sort of as a key value store, except it's highly consistent. You can have multiple servers running and they will all give consistent responses. We're writing this in Rust. I recommend that if you have not seen the first parts of this video, then you go look at the. Look at the Original or the YouTube playlist and look at the previous parts before you watch this one.
00:01:05.837 - 00:02:05.329, Speaker A: Otherwise this one is unlikely to make much sense. And so from this point forward, I'll assume that you've at least seen parts of the previous videos and that you're somewhat familiar with Rust. If at any point you have questions during the stream, then feel free to ask them in chat and I'll try to monitor that on the side and answer them as we go. Do you know how to get Rust 2018 async functions working with Tokyo? You can't quite yet because Tokyo is still built with future 0.1. There's a bit of discussion about exactly how this is going to pan out, because a bunch of modifications are needed to bring it up to speed and it's going to be backwards incompatible in some weird way. So you can't currently use Async functions with Tokyo, sadly, but hopefully in not too long. So the place we left off last time was that we have basically all of Tokyo working like we can interact with a running Zookeeper instance.
00:02:05.329 - 00:02:23.784, Speaker A: The API is not particularly exciting so far. I don't remember if we push this to Docs rs. I don't think so. Yeah. Ok. But the API is pretty straightforward. You can call exists, you can delete, you can insert.
00:02:23.784 - 00:03:17.195, Speaker A: I don't think we implemented get, so that's the first thing we'll implement today. And then we'll add support for watches that are not the global watcher. So if you remember from previously, in fact, if we look at the documentation for the synchronous Zookeeper client that exists today. So notice that for basically all of the methods there is an exist thing that takes a boolean of whether to watch it or not. And if this is true, then a watch event is sent to the Global Watcher that was passed in when you initially connect to Zookeeper or create the Zookeeper client. There's also an exist W. So notice that this is also the case for GetChildren, Get Data and various other methods where you pass in a watcher and this watcher will be notified if this thing changed.
00:03:17.195 - 00:04:20.725, Speaker A: So you have a choice of either making it the Boolean one or sorry, either make it the Global Watcher that's notified or no watcher of course, or some one shot watcher that you give it. So adding this style of watchers is something we'll also add today and then hopefully we'll also get to the ability to connect to multiple Zookeeper servers, which is not currently something we support to build on that here I find this Sorry for the suddenly white background. I found a FAQ for Zookeeper that talks about how you should handle things like connection loss and session expired and especially how that interacts with multiple servers. So that might be something that comes in handy. It's a little annoying actually to test this because Zookeeper doesn't really. It's a little annoying to run multiple instances on one machine. So we'll see if we get to this and if we get to it, whether we get to test it, and if we haven't tested it, then arguably it doesn't work even if we think it does.
00:04:20.725 - 00:05:14.623, Speaker A: There's also the Zookeeper Java API that we're going to be referring to a bunch. If you look at the documentation here, you notice that it is a similar pattern to the Rust Crate in that there's an exists that has a boolean and there's an exist that takeawatcher here. There's also a synchronous version and an asynchronous version. For us, all of these will be asynchronous and so we'll take a look at that. Someone also pointed out after the last stream they had some questions about whether we're breaking linearizable semantics given that we're using an asynchronous implementation. So linearizable semantics. The idea is that if you perform well, there are many definitions of this, but the general idea of the property is that if you perform one operation and you perform another operation later in time, they should be Visible in that order too.
00:05:14.623 - 00:05:59.221, Speaker A: So if you do something to Zookeeper and then you do something else to Zookeeper strictly later in time, like after the first one completed, then you should make sure that all your reads should be consistent with the operations having happened in that order. And this person has a question about whether this also applies when we have asynchronous implementations. You can read the discussion here. We haven't quite come to a resolution yet because I'm not quite sure where they believe the issue arises. But this might also be something worth keeping an eye on. I also found the Java implementation that has a lot of the client code. I haven't had a chance to read through it yet, but there are some interesting comments here that we can look at in terms of processing things in order.
00:05:59.221 - 00:06:45.971, Speaker A: We probably won't do that in the stream, but this might be a good way to compare the Java and Rust implementations and see that we do things correctly. So if you recall from last time, there was some discussion about how when you get disconnected, which servers you choose to connect two that the client library has some thundering herd prevention. And so some of this we might be able to lift from the Java library, but that might become relevant today, but it's unclear. But the place we're going to start is to implement Get Data, because if you can't get data, then what are you even really doing with Zookeeper? So let's pull up our. Our library here. So for. Let me make this a little bit larger.
00:06:45.971 - 00:07:08.485, Speaker A: So for Zookeeper, remember we have Connect, which gives you a new Zookeeper instance. We added create, we added exists, and we added Delete. We don't yet have a get. Now we believe the get should be pretty straightforward to add, so let's just check that. Now it'll also be a good way to just refresh our memory of how the system works. So we're going to have a. I don't know if I want to call it get data, maybe.
00:07:08.485 - 00:07:43.973, Speaker A: So there's. GetChildren is also a useful operation in Zookeeper, and we might want both of these. GetChildren gives you the names or the names of all the nodes that are underneath you. So in Zookeeper you essentially construct a hierarchy of nodes similar to a file system almost. And so you can get the children of a given node and getdata gives you the contents of a given node. And so let's start out with Get GetChildren. Why not? I think they'll basically end up being the same get children.
00:07:43.973 - 00:08:32.723, Speaker A: Oh yeah. The other thing we'll do today, just because it's going to be necessary in order for this library to be even remotely usable, is we'll try to incorporate a bunch of the documentation from the Java code into this. It shouldn't be too hard, it's just important to do. And we'll hopefully, while doing that, also observe if there are any mistakes we've made along the way, or if our API doesn't actually conform to what the Zookeeper API is supposed to be. All right, so get children, we're going to ignore this watch parameter for now, so the way we're going to end up doing watch, we've already added it to exists as a boolean because remember, we tested this last time. I think what we'll want to do is actually remove it from exists and then have a pub exists watch, which takes like. Actually, it might not.
00:08:32.723 - 00:09:43.327, Speaker A: Well, it's a little unclear how we'll do this, but it'll take something like a self and a watcher, which is going to be an option watcher. And so the idea here is that if you want to use the global watcher, you would call exists watch with none. But that's the discussion for slightly later in the stream for GetChildren, though, the only parameter then is path, because we're going to ignore watchers for now. So similar to many of the other API endpoints, and like all the other ones, we're going to return something that is a future that contains both self, so the client itself and some kind of result. In our case, of course, the result is going to be a vex string, so a list of all of the child nodes names and an error getchildren which we haven't added yet. So if you remember this pattern from last time, the item of the stream is the client and a result in the sense of whether the given operation succeeded or failed. So this vec here, this OK value of this result is notice the item of the future.
00:09:43.327 - 00:10:38.857, Speaker A: So this is the future resolved correctly and the operation gave you an okay, or the operation gave you an error. Right? So this would be you try to delete a node that doesn't exist, for example, the error case. So if the future results with an error, what that means is there was a protocol protocol level error of some kind and those we want to expose separately from just your operation failed. If there's a protocol level error, then it might be that your connection has been severed. It might be that, like it's unclear that you can keep using the same client, you might have to start a new one, whereas if only the operation failed, then you only really care about how that operation failed. So if we look back at error notice here that for delete, for example, we only expose specifically the errors that are possible to get with delete so that the user can match them as necessary. So let's see.
00:10:38.857 - 00:11:32.965, Speaker A: So forget children, we get to the client block and a list of children. There's going to be some kind of error for create children, similar to all the other errors. These are also going to derive all these nice things. And we'll have to figure out exactly what kind of errors can occur when you do not getchildren. What kind of errors can occur when you get children. And as for what GetChildren does, the exact definition is pretty straightforward. If you recall, the way that we issue requests is we have this packetizer that runs as a spawned future in the background and we have a channel to it that we on that channel we send a request and a response channel.
00:11:32.965 - 00:12:49.731, Speaker A: And so what the packetizer does is it's in this loop where it sends requests out on the wire, receives responses asynchronously, and sends on all the stored reply channels whenever the response comes in. And so in this case, if you look at Protomod, we have this enqueue, which is what's given to the client. The enqueue method takes a request and returns something that is a future that will resolve into the result of that request. And internally all it does is it creates a one shot channel and sends both the request and the transmit end of that channel to the other side and then returns the response end which will be resolved whenever the response comes in. So in our case, what we want to send here is we want to send a GetChildren request and we're going to do the same thing as we've done in the past here, where we'll lift this from here actually from I want this file open too. Yeah, so get children is the opcode. So now we're going to have to go through all of these, all these steps of adding all the various enum variants for this operation.
00:12:49.731 - 00:13:25.759, Speaker A: So here, for requests that can currently be a connect, exist, delete or create. And now of course, it can also be a GetChildren request. We don't exactly know what that contains yet. In fact, we should probably find out. GetChildren. So a GetChildrenrequest is a string in bool. So string and bool, just as in the same thing exists is the reason it's a string in bool is because it also has this watch flag which we will always set to zero when we send it currently, because we are not also doing watchers quite yet for these operations.
00:13:25.759 - 00:14:06.105, Speaker A: So it'll really just be the path and watch, which we'll just set to zero and it's going to start warning us that we haven't implemented all these. We'll do those with compiler warnings because it's nicer here. We'll set watch to be zero because we don't want to watch the getchildren the response we get back. That's a good question. So getchildrenresponse looks like it is just a vec of string here. So that just reads an i32 and those things. OK, so just like we added a variant to request, we'll also have to add one to response.
00:14:06.105 - 00:14:44.271, Speaker A: In this case, response here going to be a children. It's going to be a vector string. Actually, how about we just do this? Because that might be usable for other methods too. And we already have this. Well, maybe we don't have that yet. Hmm. So we need a way to parse vectors that come back.
00:14:44.271 - 00:15:38.835, Speaker A: It sort of looks from this implementation as though the only thing that gets a vector back is GetChildren, but that sounds a little weird. So I think what we'll do is will implement read from for vecstring and here again, we can just sort of lift this implementation because they're all basically the same. Like the protocol level is the same. Right. So in this case we want to read an i32, which is going to be the number of things. I'll create a vector with that capacity and then read that many strings and then return. Ok.
00:15:38.835 - 00:16:41.785, Speaker A: Nope. Great. Because now down here, if what we sent was a request response, then the response is going to be a strings and then a reader dot no vec. Well, how do we want to do this vecstring from read from buff like so. So the idea is that if we get in a. If we get in a. Or if the thing we sent to the server was a request, then parse the response as a vec of strings using the read from trait that we just implemented and then wrap that in a strings response.
00:16:41.785 - 00:17:18.605, Speaker A: Expected vec. It doesn't sound right. Oh, no. Oh, I updated my nightly. Oh, well, we'll have to wait for that for a little bit. That's interesting. Why? So apparently it doesn't like this because.
00:17:18.605 - 00:18:13.285, Speaker A: Oh, this should be Reader still complains maybe this, but I don't think that should be necessary. Expected mute fe found u8 oh, right, right, right. So the Read trait is only implemented for mutable pointers to slices, so that as you read, you can change how far into it you've read. Whereas Reader here is just a buff, which is just a slice of U8s. Now, no variant named request. Yes, this should be GetChildren. So if the request was a GetChildren is what it should have said then Parse response is a vector of strings.
00:18:13.285 - 00:18:52.755, Speaker A: Now that should be happy. We don't need version here. That can go away. And now we know that the response should be a strings children then resolve to children if we get something else. Got non strings response to GetChildren. This is one of those things where we've mentioned this in past streams too, but we're in this unfortunate place where the response we get is also an enum. And even though we know that we can't get anything that's not a strings response to GetChildren, we have to handle that case because we need to exhaustively match.
00:18:52.755 - 00:19:23.837, Speaker A: What we do here is if we get a response that is not of the correct type, we just panic. In theory, we could return like a protocol level error here, right? Like resolve this into an error. And that might actually be the right thing to do, come to think of it. Yeah. In fact, maybe we should just do that. I don't really like having unreachables that aren't actually unreachable. They should be unreachable right in the common case.
00:19:23.837 - 00:20:16.885, Speaker A: But we don't really want panics in our code. So I think what we'll do is change this to a bail. So bail comes from the failure crate and is basically a return error, format error and then whatever you give it, where format error is the thing that creates a failure error. So in our case we'll do this like. So this is going to be so. Ooh, did not like that. What did I do wrong? Oh, this should be okr.
00:20:16.885 - 00:20:52.125, Speaker A: So this. I'm basically just changing all of the. All of the unreachables to be bails so they won't actually panic. The user will get to. The user will get to choose how they want to handle that kind of error. So I think that's all of them. Okay, so in response to GetChildren, we know that we should get a strings and we handle that case.
00:20:52.125 - 00:21:25.445, Speaker A: If we get something else that was not an error, then it must have been the wrong return type. What other responses can we get to getchildren is the real question. Ooh, where did we use to get these? Where's the da da da da Da. Not here, not there. Where is it? Here. So getchildren is the one we want to look at. So let's see.
00:21:25.445 - 00:22:02.251, Speaker A: Not sorted, no guarantees provided. No node if the path does not exist. Okay, so no node is something we can get, right? So that's something we want to let the user match on. Because it's an error that can totally come up, which is not terribly surprising. This is the case for most of the zookeeper operations. What else can we get? Looks like that's actually the only. Right? So not empty is not an error we can get.
00:22:02.251 - 00:22:40.035, Speaker A: Badversion is not one we can get. Node exist won't be a problem. No children for ephemerals apparently can't be raised. Invalid ACL doesn't apply. So the only thing you can really get with getchildren is node doesn't implement display that is not true anymore. And so any other error is unexpected, right? Any error that is not node is not one that it should be possible to get with GetChildren. And so at this point it's unclear whether this should even be a result.
00:22:40.035 - 00:23:38.095, Speaker A: It could just be an option like so then this would be an OK sum and this would be an OK none. And then we don't need this error type, right? So it's a result, it's an enum with only one variant where the variant does not contain any information, which is basically the same as an option. So what we're saying here is if you try to get children of a node that does not exist, you would get none, which seems totally reasonable. And that should be basically it. What is it complaining about here? Oh, did I mess up syntax somewhere? I did, but where? Here. This is missing a thing. There we go.
00:23:38.095 - 00:24:54.073, Speaker A: All right, so we can add this to our ever growing test case down here of saying like so, so in theory, we would create a node then under foo, like so foo bar, I guess would do that after all the exist calls. Then we'll do this, right? So we've in our test, we first create a slash foo, we check that it exists and whatnot. And now we're creating a bar under foo with some different contents. And then we want to check both. Well, actually we don't really care about the exists as much. What we do, however, care about is, well, that should have created foo bar. And then we want to do get children of foo, right? And we would inspect what we get back children.
00:24:54.073 - 00:25:25.375, Speaker A: And we want to assert that children is a sum vec bar. That's a good question. Exactly what it will return. But in theory, that should work fine. And then we have to delete bar. I mean, we could also test that deleting foo does not succeed. So in Zookeeper you're not allowed to delete a node that has children.
00:25:25.375 - 00:25:47.487, Speaker A: And so in this case we would expect to get an error back. And that error is going to be a delete not empty. Right. So we're basically trying to we check that foo indeed got the new bar child. We try to delete foo. We should get an error, says it's not empty. We then delete foo bar, which should work.
00:25:47.487 - 00:26:08.951, Speaker A: And then we should delete foo, which should work. So if I now start zookeeper and then run Turbo T. Oh, that probably does it not compile. I think we have all the components we need. Could be wrong. Let's see. 203.
00:26:08.951 - 00:26:52.005, Speaker A: It's complaining that it can't compare a reference to an option with an option. How about now request 109? Okay, so here, this is one of those places where rust pattern matching saves us. We forgot to say how to encode a create request. And we happen to know that a create request is serialized exactly the same as a existing request. Sorry, get children request is exactly the same as an exist request. Right. They both just take a path and a watch flag.
00:26:52.005 - 00:27:20.555, Speaker A: And then we want to. Ooh. Well, this one's a little tricky because we want to write a different auth code. It might be cleaner to just have them be separate. So I guess let's do that. Like unclear. There's a big advantage to sharing those two lines when we also need to add a match on self again to write out the correct opcode.
00:27:20.555 - 00:27:52.121, Speaker A: All right, now what does it complain about?159opcode. It doesn't know what the mapping from a request to an opcode is. We can tell it that pretty easily. All right, let's see what happens. Well, that worked. So in theory, let's see if we can find this. So up here, this is.
00:27:52.121 - 00:28:17.175, Speaker A: Remember, we're doing a lot of logging internally that we'll probably want to turn off too. Or actually that might be a good idea. What we could do is use the slog crate or some. Some other logging crate and actually have all of this be proper logging. That might make our lives a lot easier. So we create bar. And then this is request for foo, which gets a response.
00:28:17.175 - 00:28:41.141, Speaker A: This looks a lot like bar in ascii. So that would be my guess that that is bar. So then we handle the get children and then we do delete foo, which gives the error. Then we delete again, foo bar. Okay, great. So that seems to just have worked. And notice how little we had to do.
00:28:41.141 - 00:29:00.975, Speaker A: Like this is extremely straightforward. So let's then try to add, I guess, get data. I'm a little bit tempted to just call it get, but let's stick with get data for now. What is in. What's the. This calls it get data. Okay.
00:29:00.975 - 00:29:47.605, Speaker A: And. Oh, interesting. Okay, so get data just takes a path and a watch similar to the other ones, but it also takes a status. Oh, that's interesting. I'm not sure why a stat is passed in. That doesn't make any sense to me. Like why is that here? Not a boolean, I guess it returns byte.
00:29:47.605 - 00:30:15.555, Speaker A: And so this is like a reference to a stat that will be updated. Okay, so there's a. So the way to think about this is there are two variants of get data. One is get just the contents of the node, and one is get the contents of the node and it's sort of meta information. So let's look at here. Get data request. Huh? Get data request just takes a path and a watch just like the others.
00:30:15.555 - 00:30:54.465, Speaker A: Get data response always returns the stat. Okay, so it sounds a little bit like it is just a more convenient API. That seems odd, I guess. Here another question is whether where's the here. So if we get data, what kind of errors can we get? Only node. Okay, so option is still going to work pretty well. In this case though, what you're going to get back is a vec of U8s.
00:30:54.465 - 00:31:25.825, Speaker A: Right here is one of those places where it's a little sad that we can't just slide slice out the U8 that we got off the wire. We have to actually copy all the data. It's a little sad. The fact that there's a stat though means that sort of in theory this is also this. I don't remember where we put stat in types. Okay, so it's sort of a tuple of the bytes that are contained within the node and the meta information about the node. And we can.
00:31:25.825 - 00:31:52.447, Speaker A: Basically the decision they've made in the Java API is to have two different methods. One that you call if you want just the bytes, and one that you call if you want both. I wonder what the rest one has. Get data just returns the topple. Yeah, I think we'll do the same. There's no reason for us to remove the stat, so I think we'll just do that. And this is going to be get data.
00:31:52.447 - 00:32:43.577, Speaker A: So again, notice how straightforward these are now to implement because we spent so Much time in part one, especially building a nice API for the packetizer. And that's paying off now, Right. So the response should be a get data response, which is going to contain bytes and stat and we're going to return bytes and status. So got non data response to get data. So these are all basically the same, right? Like in response to a get data, we would expect to get a get data response. If we don't, then something is wrong on the wire. In terms of errors, we can get no node.
00:32:43.577 - 00:33:07.255, Speaker A: That's an expected result. Any other error is unexpected and we propagate that as a protocol level error. And then we'll have to do the same thing here. So there's now a new request type which is get data also takes a path and a string. We might as well also add this at this point. It might actually be worth even. It looks like a lot of these are actually the same.
00:33:07.255 - 00:33:23.665, Speaker A: Hmm. Because like this is going to be. Get data is going to look exactly the same. Get children. I think we'll just do this after all. Change my mind. Given that get data is also the same.
00:33:23.665 - 00:34:10.975, Speaker A: And so the way we do this is we match on self, I guess let opcode is equal to this. And then actually we already have a method that does that. So we can just do here self opcode, right? I think so. And now that will be the same for all of them. So Get Data GetChildren exists. All have the same contents, so their serialization is the same. And we call self opcode to get the opcode to write out, which does have to vary between the requests.
00:34:10.975 - 00:34:56.469, Speaker A: Well, that looks good. Of course, we have the map get data to get data. We now know that there's a new type of response which is a get data response, which has bytes. Actually, I guess this is going to be a bytes. Instead it's going to be a struct bytes, which is going to be a vec, just the byte contents of the file and a stat. And then down here, here, get data. And now of course, the question is how is the response structured? Get data response.
00:34:56.469 - 00:35:32.257, Speaker A: It has a data first and then the stat and evacuate. My guesses, evacuate is something that we can parse pretty efficiently. In fact, we already have a thing for doing that. Right. So that's this that we implemented a while ago, where read buffer just gives you a vec. And so we're going to do bytes is reader read buffer, right. And stat is stat read from reader.
00:35:32.257 - 00:36:13.275, Speaker A: So we notice that the order is important. Even though we could do this like they're sort of the same in terms of defining the struct, but we actually do have to read out first the buffer, then the stat because that's the order they are in the response. And this should be get. This produces a get data response. How does that sound? Beautiful. So notice that that's all we had to do. Now we have get data in theory and now we're going to try to test that by calling get data on foo.
00:36:13.275 - 00:37:02.745, Speaker A: And that's going to return us a bytes and a stat. And we want to assert that the bytes. Oh, actually I guess this is going to be a response and we're going to res is unwrappable as in we don't expect to get none. We get expect to get some. Oh actually we could even do better than this. I think we could do the data length is actually the data is going to be this, right? And then we're going to assert equal the response to. Oh no, that's going to be annoying.
00:37:02.745 - 00:37:43.769, Speaker A: We're going to assert that rest. Well, we're going to make sure it's sum. So this unwrap would fail, which is what we want. We expect it to be sum. And then we're going to check that rest zero, which is bytes is the same as data and we're going to assert that rest one which is the stat Datalength is data let. Right. And then I guess we could do the same thing with down here with Food Bar.
00:37:43.769 - 00:38:07.979, Speaker A: Not that we expect that to be any different, but we might as well have the test for it and let's see how that does. Fantastic. So now we have get data. Notice how straightforward that was. I promised last stream that it would be straightforward to add and indeed it was straightforward to add. If you look at here, this is the response we get back. Right? So somewhere around here.
00:38:07.979 - 00:38:37.125, Speaker A: Yeah, this is. This is hello bar, right? Nine characters. H E L L O space var and then the rest here is the stat. And similarly up here somewhere we should have get data for foo, which gets the response here. 11 characters. Hello space. So 32 is space and the world.
00:38:37.125 - 00:39:20.429, Speaker A: Great. So now we have get data and getchildren. Great, let's commit that while we're at it. Add get commands. All right, so now the time is to add more sophisticated watchers. Now there are a couple of ways we could do this. We could add a separate version of each of these methods where that separate function you pass in an optional watcher and that like that's totally something we could do.
00:39:20.429 - 00:40:13.423, Speaker A: It makes me a little sad because it means that you end up with a pattern like this where you. For every method, you have both that method and that method with an underscore W or some other similar kind of. Similar kind of pattern. One thing that I like doing instead is to have something like this. This is parameterized over anything. No, I don't think so. It's going to take a W.
00:40:13.423 - 00:41:39.575, Speaker A: I guess this can take a W, maybe something like this. So we're going to have some auxiliary data structure is going to be this and watcher or and watch, which is going to contain a zookeeper and a watcher. And on and watch. We add all the same methods that we have on the main structure. So there's going to be unimplemented. We'll have the same for delete and we'll have the same for get data, right? So the reason for writing the pattern this way is now if a user wants to not watch something, they'll do like they'll have the zookeeper and do get data and they give some path, right? So that's all fine. If they want to start watching that, then they will do.
00:41:39.575 - 00:42:56.297, Speaker A: Well, I guess the exact naming of this will be a little weird, but they can do something like this, right? Where this is a watcher, we're using a trait watchable or something like that with some default method. So it's extensible for all the interactions. Not entirely sure what you're thinking. So the problem we have is that the. Well, we could change the return type of all the methods to be something that the user can then call like dot and watch on. The problem is that if they don't call and watch like we wouldn't know when to issue the request is the issue, right? So if, imagine that get data returned like a watch or not, we call it whatever we want. And then now the user like stores this in an X, right? The question is when does the request get sent? Because we can't send the request yet because we don't know whether or not it should be watched.
00:42:56.297 - 00:43:34.737, Speaker A: So the user, if they wanted to watch, would do something like and watch, whatever, right? And at that point now we could send the request. Ah, ooh, not what I meant. At that point we could totally send the request. But what if the user doesn't want to add a watcher, right? They would have to do something like X dot, send or something, which is a little awkward. I wouldn't want them to have to do that. And then the send is what would return the future that they then wait on Right. Which would lead to real, really weird patterns like dot, wait.
00:43:34.737 - 00:44:02.529, Speaker A: Right. Whereas in this case, if we have the watch precede get data, then now this is still going to return the future, just like in the API above. And if you don't want to do the watcher, the pattern is the same. Right. Get Data just returns you a future. And so that's why I don't want this to be a property of the return value of get data, but rather, by the time you call Get Data, it is fully determined whether or not you have a watcher. Of course, this is also something you could do with this.
00:44:02.529 - 00:44:47.821, Speaker A: Right. If there was a Get data W, then this has the same semantics that the moment get data W is called, you know, whether or not there's a watcher, it's a little. Right. So I think there's going to be a watch, which is you want to use the Global Watcher. Well, I think actually this needs to not be parameterized over W. So this is going to be a none, there's going to be a sum, and we're going to have to box this up somehow. Right.
00:44:47.821 - 00:45:44.875, Speaker A: So the way this is actually going to work behind the scenes on the protocol level is Zookeeper doesn't know about the fact that you might have many watchers. Actually, this is going to get really awkward. So the way Watchers work in Zookeeper, if you want to have more than just the Global Watcher that's notified of all events, is that you just keep track of the paths. So if a, if a notification comes in for a path, you check for any watcher that may be watching that path and then you send to all of them, which is a little weird because. Because here the watch doesn't know the path yet. Oh, but it, it will know the path though, because those methods will be called on and Watch. Right.
00:45:44.875 - 00:46:59.845, Speaker A: So here, once we get here, we have the path and so then we could register it. So the basic idea is we're going to register with the Global Watcher. The fact that there's now an additional watcher, they should notify for this given path. So we're gonna have to figure out the pattern. But I think this is how we want this to be set up. Yeah, I think, yeah, the, the way this is gonna have to work is something like, oh, actually here's what we're. Well, we'll find a better name for it later.
00:46:59.845 - 00:47:22.695, Speaker A: So we don't want to re. Implement all of these methods either. Right. And so what I want to do is have this be something like. And Watch with like watch or none dot get data. And then I want all the implementation of all these methods to only be in the watcher because otherwise we have to duplicate them between the two. Right.
00:47:22.695 - 00:48:00.889, Speaker A: Which is annoying. And so I think for us to do that, we're going to need an enum that has something like how would you like to watch this call? And the options are like none, global or like. I don't know how we want to particular. I don't know how to. We could call it local, but it's not really local. So there's a global watcher. There's no watcher as in you don't want to watch the call.
00:48:00.889 - 00:48:22.581, Speaker A: And there's custom. And custom I think is going to be. I don't think we want watch settings to be parameterized. So there's. It's sort of tempting to do this. Right. And make it generic over F.
00:48:22.581 - 00:49:21.881, Speaker A: The problem then is what do you set F2 if you're giving it a none or a global because we don't have any trait bounds on it, it might be sure we'll try it and see what happens. I think this is going to get really weird, but I guess we'll find out. So that takes a watch settings W and now the idea would be that if you call watch, it's going to create an end. What? I don't really want it to be called and watch because the user is going to see one of these. Right? Like when they call watch they're going to get back some type. Oh actually no, that's fine. So they will only ever see it in the context of watching.
00:49:21.881 - 00:49:58.205, Speaker A: They won't see that it's being used for exists. So I think this is okay. So that gives you an end watch where zookeeper itself and watcher is like watch settings none sorry global. Right. So this means that if the user does something like ZK Watch getdata of foo then the global watcher will be notified of that. I think that looks pretty nice. Right.
00:49:58.205 - 00:50:29.611, Speaker A: And then the alternative for watch with is going to be something like watch with and they're going to give some F. Just like a print line F or something. It's not terribly important. Getdatafoo then now if the data of foo changes then this closure will be called. And also the global watchers I think always called. Not sure. Actually, I think it is always called.
00:50:29.611 - 00:51:21.675, Speaker A: We should check this. Exactly what the watcher protocol here is. Watches one watch when the data is changed. Yep. Well, this doesn't really answer the question. Am I clicking Server it doesn't really say ok, the client will never see a change for which it has a set watch until it first sees the watch event. That's fine.
00:51:21.675 - 00:51:53.171, Speaker A: Watches are ordered. User watches are one time triggers. That's fine. The same watch objects register for an exist and get data. The watch object will only be invoked once with the deleted notification for the file. Okay, so they are only sent once. So that.
00:51:53.171 - 00:52:52.555, Speaker A: So if you have. Well, it doesn't quite answer the question either, but I think what this means is the watch. If the same watch object is registered for two calls, then it will only be invoked once. Well, that's sort of interesting. I guess it depends whether we're expecting these to be closures or whether we're expecting these to be some kind of like global objects. So for watch. Sorry, for watch with are we expecting users to call like self watch with like event and then some closure dot get data, get data foo or are we expecting them to watch with and then pass in like a custom watcher? Right.
00:52:52.555 - 00:53:30.299, Speaker A: Where custom watcher is reused across many of these. I think it's the former because you can encapsulate the latter pattern in the former but not the other way around. Well, actually you could do it the other way around too. I think we want to do it this way and then the user can choose whatever they want to do. And so in that case the question then becomes if we get a watch event, we notify all of the watchers for that path. So that's fine. Do we also notify the global watcher? I think so, but I don't have a good answer for that.
00:53:30.299 - 00:54:03.765, Speaker A: I think we do. Let's assume that we do. All right, so this takes a. This makes one of those. That's fine. This makes a watch settings, custom watcher and then local. Well, this is not going to be public.
00:54:03.765 - 00:54:48.557, Speaker A: This is what all the other methods are going to call. They're going to call I guess. Well, I just want to shortcut for these methods are all going to have to do something like and watch none dot exists path. Right. And I just want a shortcut for the inner part here which I think we're just going to call like no watch. We'll find a better, better name for it. This now has to be parameterized by the W.
00:54:48.557 - 00:55:30.633, Speaker A: I think it's a little awkward. No, let's not do that. These don't have to be high performance anyway in which case this can be a box new where W. Oops. Where W is an FN ones from. Well that's A good question. What's our watcher type again? Right.
00:55:30.633 - 00:55:58.695, Speaker A: It just gives a watched event. So the FN1S is given a watched event which hopefully is clone. Otherwise we have a problem. Watched event is clone, all right? And it returns nothing. Right. So we're basically saying the user gives us a closure that's going to be given the event that happened and can do whatever it wants with it. Now watch does nothing.
00:55:58.695 - 00:57:06.695, Speaker A: So and exists is just going to be self now watch exist path and then we'll move the exists implementation into the and watch exists. Right? And now this is going to be the watch here is going to be if let watch settings none is equal to self W then 0 otherwise 1. So if we're not watching, then give a 0 otherwise give a 1. Apart from that the implementation is the same, right? And then we'll do the same for all the other methods. So for delete will be this delete and version these go down. Actually, no, I guess delete doesn't really have this because you can't watch a delete. So I think this.
00:57:06.695 - 00:57:45.057, Speaker A: We're gonna hoist that up here. You might want to make these two different dimple blocks, actually, just for our own sanity's sake. So we'll have one input block of things that can't be watched and one of things that can be watched. So exist does that. GetChildren does this. So notice how these are all basically the same, right? And the condition under which they watch is also the same. Delete won't be here.
00:57:45.057 - 00:58:36.261, Speaker A: Then I guess get data is the last one. So get data will be the same. Get data like here and right. So now we have at least the this is not W anymore and this is not F anymore. And this is I guess box FN1's watch event to nothing probably has to be send. But what's exactly for a game or. No, this is a programming.
00:58:36.261 - 00:59:07.623, Speaker A: This is not Rust the game, this is Rust the programming language. This confusion comes out roughly twice every stream. Let's see. Right. So this does not take a watch settings. These will all have to be self zk. So of course this only sort of works because currently, if we set watch to one, all that will happen is that the Global Watcher will be triggered.
00:59:07.623 - 01:00:18.605, Speaker A: Google put go language too much. Right? So currently this will only ever trigger the Global Watcher because we're not storing this custom watcher in. So what we're going to want is something like FN Register Watcher that's going to take a path and a watch settings path is Going to be a string. Yeah, I guess if we want to make this really convenient, we do this. I'll explain why in a second. So this will return zk. This is going to have to do something to register W with whatever dispatches events, right? So that's all well and good.
01:00:18.605 - 01:00:57.865, Speaker A: This is then going to do something like letzelf register Watcher path. And actually this doesn't even need to take a W. So this is the reason why I wanted this to be why I wanted this to return Zookeeper. Because it means that we can do the destructuring here. Because otherwise here would have to do something like register this and then we'd have to give Self dot W. But we want to move self W out of self. And then I guess we could use ZK here still be fine.
01:00:57.865 - 01:01:24.885, Speaker A: But this just reads a lot cleaner. And so this will now use Z zk, I guess ZK connection. And then we'll do the same for all the others. Right? So all of them are gonna somehow register the Watcher. We haven't defined how yet. And then they're gonna issue the request. This is complaining for some reason.
01:01:24.885 - 01:02:07.693, Speaker A: This is complaining for some reason. Why? Not sure why that is complaining. Expected type and watch found on Zuki. Oh, right. This does have to, right? Self here is a different type. Self here is and Watch. But we really wanted to return back to the Zookeeper type.
01:02:07.693 - 01:03:15.225, Speaker A: Can't use Self anymore in the ones that are on and watch like so this is gonna be ZK and ZK and zk, Right? So the question now is, how are we going to register these Watchers? So if you remember, the way the Global Watcher is set up is when you first connect, you're given a future that will resolve into a tuple of a Zookeeper client and a stream. And that stream is over all watched events. And that stream is given to us by the packetizer. I think maybe I'm wrong. Yeah, I am wrong. The stream is actually generated here. So really what we want to keep track of is like instead of having these, instead of just directly exposing the stream, we want to sort of interpose on the global event channel.
01:03:15.225 - 01:03:57.165, Speaker A: And any events that match paths that we've stored, we want to dispatch to that too. It's not entirely clear how we're going to do that though. Huh? That is a very good question. Because basically somehow whenever we receive on this global event stream, we want that notification to also go elsewhere. The alternative, of course, is instead of doing this in Zookeeper, we do it in Packetizer. So this Registration that we do. Wait, why is this complaining? W does not count Static.
01:03:57.165 - 01:04:31.485, Speaker A: This no longer take watch. So that's nice. Sort of what we wanted to get rid of. And this. Wait, why is this complaining? Oh right. This has to do something like. I guess that's awkward.
01:04:31.485 - 01:05:11.975, Speaker A: This also has to return. Whether or not it should just make this true for now. We need to have something to match on here. Right. So this is going to be something like if watch then 1, otherwise 0 and that's going to be the same for all of them because we've moved self W when we did the register path. So this is arguably the reason not to do that. But this is going to be this and watch and the same up here.
01:05:11.975 - 01:06:02.115, Speaker A: All right. Yeah. So the thing we could do here is we could send the watcher to the packetizer and have the packetizer do the work of also dispatching to other things. I think that might be the easiest way to go actually. So we would do something like ZK connection. Oh, that's a sync, isn't it? The enqueuer. So what I was thinking was on enqueuer to have a method that's not enqueue but like send watcher or something that would send that onto the.
01:06:02.115 - 01:06:23.031, Speaker A: Onto the channel that the packetizer is listening on. However, the stuff we send there has to take this form. Right. So we would sort of have to. We'd have to have some kind of enum. That is the kind of stuff you could send. It's probably the nicest way to do it though.
01:06:23.031 - 01:06:48.325, Speaker A: So we'll just do that. So there's going to be enum task. Let's call it task. So there's going to be request which is going to take a. Well, a request and a response. Right. So that's going to be that.
01:06:48.325 - 01:07:33.295, Speaker A: Or a task can be an ad watcher which is going to take a path and a. Ooh. Actually we don't even have to register the watcher if it's for the global one because global one will always be notified regardless. So I think this is going to be something like if let. Well actually let's just match on W. So if we get a watch settings none then we just return ZK and true and false. Right.
01:07:33.295 - 01:08:03.881, Speaker A: We don't even want to add a set watch to 1. If we get a global then we can just return true. All we really need to do is set the watch flag to true and then the event will be propagated correctly. It is only if we get a custom that we need to do some Stuff and then at the end also return. And then also return true. So that we set the flag to be. To be one.
01:08:03.881 - 01:08:42.094, Speaker A: Right. So I think this is what we're going to have to do and then we're going to have to figure out what to do in between here. And the idea that we're working with is that we're going to do something like send or add watcher path to string and W. Right. So we're going to send to the packetizer, the watcher and the path that we want to register that watcher for. Right. So add washer is going to take a path string and a like notify.
01:08:42.094 - 01:09:24.215, Speaker A: Hmm. So instead of the other way we could go about this is instead of passing a closure that gets called like a callback, we could have it return a future instead. So currently we're going to end up with this like fn1 swatched event to nothing static. Actually the static isn't necessary. But like currently we're gonna end up with this. Right. And notify is gonna be called as the watcher.
01:09:24.215 - 01:10:24.777, Speaker A: The alternative would be that when you call, when you call watch or actually when you call watch with what it returns is the thing that you're gonna call a method on and also the future that will resolve when that thing triggers. That might be better. So how would we even express this? Right, so the proposal is that this returns this launch event and error I guess is nothing. Error is. Yeah, error is nothing. So instead of it taking a watcher, it's just going to do this. That does look a lot nicer and sort of more in spirit with the asynchronous world.
01:10:24.777 - 01:11:14.229, Speaker A: The question is what to call it because I sort of want this to be called like notify and this to be called watch. But that's also a little odd, right? Because this is just saying like also notify the global watcher whenever something happens. This is give me a watcher. So maybe with the watcher and this is just watch. It's all a little bit awkward. I don't quite know how to reconcile these, but the basic idea is going to be we create a one shot. Do we have one shot somewhere here? Oh, okay.
01:11:14.229 - 01:11:59.511, Speaker A: So we're going to use future sync one shot. So this is going to create a new one shot channel and the custom is going to contain the transmit end and then we're going to return AW&RX like so. Right. So now what the. What the user gets back is both the things that are going to call the method on and the future that will Resolve when the watch event triggers. I think that's what we want. It's complaining about something though.
01:11:59.511 - 01:12:55.115, Speaker A: Oh, it's probably the error type is something else. The error type is up here somewhere. Futures cancelled, which sounds about right, right? Like the, the error of that future is that the future was canceled, which I think is basically what we want. It does make the API a little bit more awkward because now you need to. You can't just do like dot with watcher dot get data, right? Because you're going to have to remove the future that got returned. But I think this is still what we want. And now this actually makes this a lot easier because now we know that this is a one shot sender watched event, right? And now this is a tx.
01:12:55.115 - 01:13:57.201, Speaker A: This is not a box anymore. This is a one shot sender watched event, like so. And then cure is now going to have down here, it's going to have another method that's going to be add Watcher. It's going to take a path that's a string and a tx which is this one shot business, right? It's not going to return anything. It is just going to do an unbounded send of task add watcher path tx. So I guess it's a little awkward that this unwraps currently but. And this of course now has to be tasks.
01:13:57.201 - 01:15:10.241, Speaker A: So the things that we. The channel that we have to the to the packetizer is now different, right? Because now we're sending an enum instead of just a tuple like we were before. So this is going to be a request where the request and response is going to be TX in theory, everybody's happy except for whatever reason, oh, this should be tx. And this is complaining because this is now a request found task expected type. Oh no, this is now a sender of tasks and it's complaining about that because it does not implement debug. That's fine, we can implement debug. In fact we can.
01:15:10.241 - 01:15:56.945, Speaker A: No, we can't implement clone, but we can implement debug. So now the packetizer actually has a channel here that is not this. But instead it gets task. Right? And so now the main loop of the packetizer. Where's our. The thing that reads things from the channel? Let's see, it reads from the timer pol ENQ RX poll. This no longer gives an item TX instead.
01:15:56.945 - 01:17:03.405, Speaker A: Well, so now it can get either a task request which has a request and a response, in which case we want to give back the request and the response just like before. But in addition to this it can now get an add watcher which has a path and a tx. So the question is what should it do here? Right, so this is the packetizer gets told to add a new watcher. What does that even mean? The way we're going to implement this is basically it's going to keep a track of all the path paths that it's supposed to send things on and then it's just going to send on them now. Oh, I'll deal with that in a second. Okay, so this is going to do something like self.watchers. i guess entry path.org
01:17:03.405 - 01:17:45.095, Speaker A: or insert with Vecnew push tx. So we're going to have Watchers are going to be some kind of map from paths to. From paths to a list of watchers to notify. Right. And then we're going to have to check that whenever we send out on the watcher. Right. So this default watcher, where do we end up using default watcher is on here.
01:17:45.095 - 01:18:14.725, Speaker A: This is an active packetizer, isn't it? Yeah. So I think Watchers is gonna have to be a field here. Like Watchers is gonna be a. Let's make it a hashmap for now. It might. We might want it to be a try eventually, but for now it's fine. It's gonna be a vec of one shot senders of watched event.
01:18:14.725 - 01:19:05.955, Speaker A: Right. So the idea here is this is custom registered watchers path 2 tx and so here Watchers is going to be nothing by default. And then the setup that we want is that whenever we receive an event. So down here, Remember how XID equals 1 is a watch event that gets sent to us from the server then here in fact we already have a to do for it. Do you do unit testing? There are very few tests in this library currently. In part that's because Zookeeper is not particularly well built for testing. But that's totally something that should be added.
01:19:05.955 - 01:20:00.005, Speaker A: I agree. I have not been focusing on testing in this particular stream. Some of the earlier streams have some more focus on how to do testing. Right. So here really what we want is it's going to be a little so what is in and watched event path. Nice. So if E path I guess here's really what we want to do let some watchers is self watchers get mute path.
01:20:00.005 - 01:20:27.019, Speaker A: Right. Custom. So in this case there are custom watchers for this path and so we need to notify them. And so here for W in watchers. In fact you might just want to remove this. Come to think of it, that's not going to be correct. But let's leave it like this just for the.
01:20:27.019 - 01:21:11.465, Speaker A: For the time being. So the idea is that we're just going to loop over all the watchers and for all of them we're going to do W dot send and then clone of the watched event. This belongs there. So there's the basic pattern here. Makes sense that we have this map of paths to watchers and whenever we get an event, if we find that we have any watchers for that path and we also notify those watchers of the change. I think this should in theory be all right. This is actually going to be on the active packetizer.
01:21:11.465 - 01:21:55.325, Speaker A: It's also a little awkward because we're going to need. When we transition from active packetizer to reconnecting, we also sort of want to notify. Well, dropping them is fine. Dropping them is just going to cancel them, which is basically the behavior we want. 45 FN1S is not implemented implemented for Beck 354 here too. We just ignore if there are errors. So here.
01:21:55.325 - 01:22:48.589, Speaker A: One shot senders are also not asynchronous in futures land. So if you send on a one shot sender it will never block, which is really neat because it means that we can do it in this loop and it won't actually be a problem. It won't cause us to go to sleep or anything. You can see that if we go to documentation for future 0.1 if we look at sync one shot sender send and the only case in which we get an error is if the other side was dropped. And that's why we just ignore the response, ignore the case where the receiver has been dropped. Right? Because we don't actually.
01:22:48.589 - 01:23:09.867, Speaker A: That doesn't matter to us. We still want to continue processing and there's nowhere we can send the error. So we just drop it. Now is it happy? All right. And now what we want to test is. Let's just see that the. That the test that we had already will still pass.
01:23:09.867 - 01:24:03.999, Speaker A: Right? So remember, we have the setup where we watch exists, right? So we're going to change this to be ZK dot. What do we call the thing watch. Yeah, watch exists. This is also going to be watch exists. And are there any other where we do this delete? Nope, I think that's all of them. No, down here watch. Just to see that the watch events still work the way we expect them to when we're using the Global Watcher.
01:24:03.999 - 01:24:41.335, Speaker A: There's no big reason why it shouldn't, but it's Nice to test. And now we want to test that the localized stuff works too. So we're going to do this. Then we're going to do. Well, I guess where's our end then this thing? So we're then going to call down here. Actually do it the other way around. It's going to be a little bit easier.
01:24:41.335 - 01:25:04.511, Speaker A: So we're going to get a future and an exist watcher from calling. What do we call this? With watcher. These names aren't great. Exists foo. Right. So remember how. Oh, sorry.
01:25:04.511 - 01:25:51.315, Speaker A: With watcher food dot exists foo. And then ZK I guess we expect this to be that. ZK underscore ZK watch exist. So I don't know if you follow that, but the with watcher returns us two futures, right? It returns us one future or it returns us an and then. Or the an and watch, which is going to be this future. And that is where we continue calling exists. And it also returns this other future that will resolve when this watcher triggers.
01:25:51.315 - 01:26:28.975, Speaker A: And we expect that to trigger here. I guess we check all the watchers at the end currently. But right here. Right here. Rather we expect that exists to have resolved. Right. Where's the place where we get watch events? Down here somewhere.
01:26:28.975 - 01:27:07.097, Speaker A: Yeah. So the moment we do the create, we expect the exist W to resolve. And so we're going to check that right here. That that is not node deleted, but node created. I don't know if that. If you followed that, that was a little bit fast. But the basic idea is that after we first connect, what we do now is we set up an exists with a custom watcher and that initial exists should return nothing for foo.
01:27:07.097 - 01:27:55.025, Speaker A: And then we set up an exists with a global watcher as well, and that should also return none. Then we create that should trigger both the global and the local watcher. And then we check that the local watcher indeed has resolved before we continue. And then we go on with all the rest of the stuff. This. Ooh, did not like that. Error is failure error.
01:27:55.025 - 01:28:31.055, Speaker A: All right. This dot math error. So this entire path expects that the error types are failure errors. But for us, the error type here is canceled. Right? Like the event loop exited and you got no signal. And so here I think we just want unreachable. We might as well format error.
01:28:31.055 - 01:29:28.245, Speaker A: It's actually nicer. Got or exists w failed. Really? 281 oh, that needs to go here. Here. Can't compare watched event and option watched event. See how that fares? Beautiful. Okay, so this means that the watcher we set up also correctly works, right? So this assertion worked correctly, which means that the watch future we got back here indeed got triggered, and the global Watcher also indeed got triggered.
01:29:28.245 - 01:30:27.101, Speaker A: So that's great. That means that the basic setup works, but I don't want to commit it just yet because the current implementation actually has a bug that I just didn't tell you about. And the reason for this is this business. So notice that there are a bunch of different types of watchers, right? So there's created, deleted, changed, and child. Now, because triggers in Zookeeper are one shot, imagine that you call get data on some path and you call exists on that same path, and then a created event comes in for that path. If that happens in the current setup that we have, the created event would trigger get data or would trigger getchildren, which is wrong. That should not actually happen because get data can't be triggered by a created.
01:30:27.101 - 01:31:11.801, Speaker A: So we actually need our map of Watchers to keep track of the event type that's being requested to. And I believe that if you look at Rust Zookeeper, that is basically the same thing it does here. It has this watch type. Why is that different from watched event type? How are these different? It seems pretty weird. What is from consts watched event type. I guess that's fine. Yeah.
01:31:11.801 - 01:32:17.665, Speaker A: So that's why the synchronous Rust Kuzookeeper has this enum called watch type is precisely to track these kind of changes. And so we could test this. We could add a check for this too, by doing, I guess, a futu. Actually, it's a little annoying to do. It's just a little awkward to chain these with Watcher calls, but not impossible. The. The reason it's annoying to chain is because let's say that down here I wanted to do a ZK with Watcher, right? This is going to give me the real future that I want to continue chaining.
01:32:17.665 - 01:32:46.865, Speaker A: And the eventually thing for when the watcher, I guess we could call this Watcher, right? And then I sort of want to return watcher here. Sorry, return fut here. All right. Fuse dot exists or whatever call I want to make. Right? The problem now is of course I've lost Watcher. I have no way to carry it along. And so that means that you have to annotate all of your futures with this like dot map.
01:32:46.865 - 01:33:39.345, Speaker A: Move ZK ZK Watcher. Right? All of these calls are going to have to chain the watcher along until the point where you need it, or you have to stick it in like a data structure. You have access to somewhere, which is also a little bit annoying. So I think. I don't think we're going to do anything in particular with that now. But I wonder, I wonder, I wonder, I wonder. So what I was hoping to do was add a part to this test where it will add something like a get data watcher and check that that data watcher does not get triggered.
01:33:39.345 - 01:34:15.641, Speaker A: Actually looking at them again though, is that even possible here? So a changed event. Okay, so I guess that would actually be the thing that GetChildren can only be triggered by a deleted event. But in our current setup, a change event would trigger get children. Similarly, a child event would trigger a get data. Right, which just seems wrong. So we do have to keep track of this type. All right.
01:34:15.641 - 01:34:31.735, Speaker A: Might as well just do it. Where's my. Here. So in. Where do we want this to even live? I think we want this to live in. That's a good question. Actually.
01:34:31.735 - 01:35:00.605, Speaker A: Proto, maybe. Proto is already pretty large. I guess it'll be in Proto. That's fine. Right? So when we add a watcher down here, register Watcher is going to take a path and a. I don't know what to call it. E type.
01:35:00.605 - 01:35:38.635, Speaker A: It's going to be a watch. What do we call it? A watch type. Like so. And when you add the watcher, you're going to have to Send the eType long2. And now in Proto, a task contains an E type. I guess this really should be W type, given that it's watch type. So this takes a W type, which is a watch type.
01:35:38.635 - 01:36:32.175, Speaker A: And here when you add a watcher and you also take a W type which is so watch type and include that when you send it to the packetizer. We're basically just chaining this along, right? And then add watcher is going to push and that is now going to be a TX and a W type. So watchers. So this is now a vec of. Where's this of watch type. And now when we walk this, we can't actually remove. What we're going to want to do is what I do.
01:36:32.175 - 01:37:02.117, Speaker A: Watchers. Watchers, Watchers. Here what we're going to want to do is get mute of this and then we're going to do something like Watchers retain. And we're only going to retain the ones we remove. So where the watch type matches. So retain is a method on a vec that iterates over all of them. And if you return true, then the element is kept in the vec.
01:37:02.117 - 01:37:44.249, Speaker A: Otherwise the element is removed. Actually that's not gonna Work either because retain does not get to own the thing. That's also a little awkward. I think we're gonna do something like we have to do for I in zero to watchers dot len. If I is greater than or equal washers len then break. You'll see why. It's because we have to.
01:37:44.249 - 01:38:38.545, Speaker A: So we have to mutate the collection while we iterate over it. And retain is normally the way you'd want to do this. However, retain has the problem that it doesn't give you. You can't own the reference that it gives you easily, which is a little sad. I sort of want something that's like retained that gives you a thing and you return an option that thing to decide whether or not it stays. But that's not currently what it does. And so here what we're going to do is we have to match on the watchers I and watchers and the actual event we got.
01:38:38.545 - 01:39:23.645, Speaker A: So that is a watched event which is where. Which is eventtype E event. So we're going to match on the pair of the event this watcher is waiting for or the kind of watch this is and the event that we actually got to see whether the two match up. And then we're only going to remove the ones where it actually matches. So here let's say that we get watch type. So if we have watch up child and any just write these out watch type data exists. It seems like it's missing one.
01:39:23.645 - 01:40:26.295, Speaker A: Oh, I see. Yeah. So right, so this is. It's a get children watch which should only be triggered on deleted or on child. So this should be on watched event type delete node deleted or on what's the other one? The get children can trigger on child events where is watched event type node children changed. So node children changed. Either of those will trigger.
01:40:26.295 - 01:41:34.205, Speaker A: So that will be true. Any other thing with child will not trigger. If it is an exists then a watched event type children changed it's going to not trigger and any other type will trigger. And for data it is deleted and changed are the only two. So for data deleted and node no data changed these will return true and anything else with data is going to be false. So now we have the exact cases for when for which type of events trigger which kind of watchers. And then if triggers then we send.
01:41:34.205 - 01:42:07.571, Speaker A: Then I guess we're going to do something like. So we need to. The problem is in order to send we need to own the sender which means we need to remove it from watchers. So swap remove the current one. So Swap remove is take this thing and swap it with the last thing in watchers and then remove the last thing. The reason you want to do that is if you try to remove something in the middle of the vector, you have to shift all the things that come after it down. And that's pretty inefficient.
01:42:07.571 - 01:42:58.735, Speaker A: Whereas swap remove just gets rid of that problem. So that gives us the W and this watcher is no longer active. And then we send otherwise. Well, otherwise we don't really do anything like it stays in watchers. And so the idea here is that we're going to keep walking until we get to the end of the array or the end of the list of watchers. The reason we need this condition is because this range when we initially compute watchers actually we just do while make sure we don't walk past the end given swapper move. Right? So initially this range is going to be.
01:42:58.735 - 01:43:37.335, Speaker A: Actually we could just do this. Might as well. If we just had this be zero to watchers len and didn't have this condition, then it would compute watchers Len is the beginning of the loop, right? But then as we swap remove we're shortening the vector so it's now looping to. Let's say that the vector starts out being this long and so that's what the range is set to. And then as we move through it we remove a bunch of stuff from the end. So we're walking this and like the vector is only this. So we walk to here, which is all fine, but then we start walking this space because initially it was this long.
01:43:37.335 - 01:44:25.259, Speaker A: But here all those items have been removed and the program would crash because that's why we have to recheck the length on every iteration. It did not like that watched event type. So I guess this will be watched event type and complaining about something else too. But I don't know exactly. Oh, this. And now of course if Watchers is empty, then we want to remove it, which there isn't really a nice way to do. It might also require nll, which is a little sad.
01:44:25.259 - 01:45:20.635, Speaker A: So down here we're going to do something like remove as false. So we sort of want to remove. If there are no watchers left for a given path, then we want to remove that entry from the map just so we don't take up that additional space. Then true then remove is true. And then down here if remove then self Watchers remove the dog path and we don't care about whether it got removed. Well, it should always get removed. Try to remove Watcher that didn't exist can't swap remove causes to skip a watcher because we never look at the watcher that was lost.
01:45:20.635 - 01:45:51.327, Speaker A: No, that shouldn't be a problem because remember we keep iterating until we're past the end of the vector. So if something gets. Oh, you're right. We need to recheck the current index. Ooh, yeah, you're right. You're totally right. In fact, you're totally right.
01:45:51.327 - 01:46:35.441, Speaker A: I think this has to be watchers Len to zero. I don't know if I'm allowed to make a range that way. Let's do this the old fashioned way. While I is as is. While I is less is greater than or equal to zero Then do this. Yeah, I minus equals one. No, you're totally right.
01:46:35.441 - 01:47:02.175, Speaker A: That's a good catch. I think this should be right then. So we start at the end and we walk backwards through the array. It might be flipped for you. I'm not sure. So we walk backwards through the array and swap things to the end to remove them. So then the thing that we swap into the current location we have already processed because it was at the end and so therefore it's correct to continue moving back.
01:47:02.175 - 01:47:50.735, Speaker A: Yeah, I think you're right. Variant not found. Oh, is it just exist instead of exists? Yeah, and this is complaining because no matching send dot zero because there we don't care about the type. Great. See what that. Ooh, hello. Oh, watch types should be debug.
01:47:50.735 - 01:48:43.755, Speaker A: Why is this not? This should be clone, copy debug e partially and hash. Oh hey, you're back. 534. What's in 534W type right, we need to extract that from the struct up here. Cannot find watch type. Right, so this has to use zkerror and watch type. So do we even have it in scope 201? Right, and these now have to say what type of operation they are specific Specifically it's a watch type exists.
01:48:43.755 - 01:49:37.785, Speaker A: This is a watch type child and this is a watch type data. Oh, failed. That's failed to enqueue New request cancelled Panicked. The length is one but the index is one. That sounds like the while loop was not actually correct. 373 what? Oh, this file 373. Yep, that is correct.
01:49:37.785 - 01:50:28.255, Speaker A: This has to be minus one. Let's try that instead. Still crashed because it expected Ooh, the test failed. Oh, because it's because we ran it previously. This is one of the annoyances of testing things that are persistent because our test failed halfway through. So it created the node and so now when we ran the test again, the test assumes that the node does not exist at the beginning. So we just need to foo.
01:50:28.255 - 01:50:56.865, Speaker A: Let's try that. Great. Fantastic. All right, so now just one thing that we might want to do. It probably doesn't really matter, but we could make the path the watchers list to be a try so that it's a prefix tree instead of a hash map. If you have a lot of paths that are similar, this might save you a bunch of storage. I don't think it's terribly important for this.
01:50:56.865 - 01:51:31.871, Speaker A: So we're going to do that. All seems fine. Add custom watchers. Good job team. We have custom watchers. I'll push in case people want to see. Why do I have a file here? Oh right.
01:51:31.871 - 01:52:08.515, Speaker A: I tried to write a Travis file. It's a little bit annoying. It turns out running Zookeeper on Travis is non trivial. Okay, so. So the question is what do we want to tackle next? I think we want to add some documentation to this because it's getting pretty large. Luckily we have the advantage that there's a bunch of documentation that's been written for the Java version and most of that should just straightforward apply to our implementation as well. So let us start by adding Deny missing docs.
01:52:08.515 - 01:53:00.495, Speaker A: We also want to deny missing debug info and missing clone impulse. Not permitted following an outer. These are all outer attributes. Oh, unknown lint rust, missing impul. What's it called? Missing debug info. It's whatever this thing is. Yeah, but what is the actual.
01:53:00.495 - 01:53:32.945, Speaker A: Oh, it really is this. Okay, I think there's one for clone too. Or maybe it's copy actually inner. Oh, right. These all need to come first. Great. All right, so the top level create docs I don't want to write quite yet.
01:53:32.945 - 01:54:06.025, Speaker A: The Zookeeper crate docs Here we could use the new external docs feature where you can include documentation from external documents into your documentation directly. It's pretty neat. It just landed. Basically you can do. It's like doc include and then some path and then it just that becomes the docstring of this particular struct. I don't actually want to do that in this case because I think we don't want this verbatim. We want at least some changes to it.
01:54:06.025 - 01:55:46.685, Speaker A: Let's format this a little. One of the advantages to doing this so taking the documentation from a different library rather than or from in this case the sort of original library and then modifying it as opposed to just writing our own, is that as we read it if there's something there that we find that we've missed, we'll detect that if we just write our own. We'll just document what our library does, which is not necessarily what the library should be doing. Zookeeper I don't want to say any of this. Huh? Okay, let us not use them quite that directly. A connection to zookeeper all interactions with zookeeper are performed by calling the methods of a zookeeper. And we sort of want to say so remember how a while ago we also derived clone for zookeeper because you can have.
01:55:46.685 - 01:56:33.045, Speaker A: You can totally have multiple zookeeper instances or you could have multiple things that send to the packetizer. And so we will sort of want to say that here by calling the methods of a zookeeper instance. All clones of the same zookeeper instance use the same underlying or use the same underlying connection. Isn't it fun? Also in the. In the Java one they have to document that things are thread safe unless otherwise noted. In Rust, this is expressed in the type system the client was on. Hardware call security.
01:56:33.045 - 01:58:02.743, Speaker A: We don't currently let the user set the timeout value, so that's not terribly important. The zookeeper instance will then no longer be usable and all futures will resolve with a protocol level error to make further, the application must create a new zookeeper instance. So this is totally true for us, right? Like if the connection to the server goes away, then the logic we wrote in part two ensures that we try to reconnect to the server if the session expires. Then if we look at protomod, remember how we have this nested structure now with a packetizer has a state that is either connected or reconnecting. And so if we. Where's the place where we try to connect? Down here somewhere. Yeah.
01:58:02.743 - 01:58:53.835, Speaker A: So if we pull the underlying state, so this is trying to drive it forward and we get an error and we were connected, then we try to connect again, we send another connect request and if we get an error while we're trying to reconnect, then we just fail. So here, I guess this is something that we. Down here somewhere. Right, Sorry. Here, this bit. So if we get an error while we're in the connecting phase, like the reconnecting phase, then we currently just return that error and we give up. Now technically here we should do things like if we get a session expiry error, then we should let everyone know.
01:58:53.835 - 01:59:34.445, Speaker A: Or if we get a session expiry error, then we should return like we do now. But if we don't get a section inspiration, if we just try to connect to a server again and it fails, we should probably just retry and try a different server. That's hopefully something we'll get to today as well. But for now we just exit which will cause the packetizer to exit, which will call all futures to resolve with an error, which is the same thing we're promising here. We might want to leave a note here that we will not auto connect is Zookeeper server. The client fails and otherwise it's automatically try to connect. Yep.
01:59:34.445 - 02:00:13.455, Speaker A: And then here we sort of want to add a note that. So this is saying that we're trying to auto connect, which is true. If. Well, I guess what we could do here is add like a section on limitations up here. That might be a better way to go about it. We want to say that at least for the time being, multi server deployments are. Multi server connections are not supported.
02:00:13.455 - 02:00:48.399, Speaker A: Also, sesh errors during reconnects are. Client does not recover from errors during reconnects such as session expiry. Right. So that's totally something that we sort of would have to fix. It shouldn't be all that difficult. Right. So it's basically in this code in the packetizer where here you would have to check what kind of error you got.
02:00:48.399 - 02:01:17.205, Speaker A: And if the error was a session expiry, then you indeed want to return the error. If it was not a session expiry, then you just try to enter the connected state again. You just try to connect again. You're going to have to remember the ZX ID from last time and whatnot. But that's something that should be doable. Secure APIs are either asynchronous or synchronous. That is not true in our implementation.
02:01:17.205 - 02:02:02.445, Speaker A: The watches other successful sucker API calls. Oh, actually that's a good point. This is also something we don't handle. So this is one of the reasons why this exercise is useful. If a Zookeeper API call fails, then no what should be added. Whereas currently for us, if it fails, that's not something we do anything about. Hmm, that's a little awkward.
02:02:02.445 - 02:03:02.787, Speaker A: Basically, the watch is not actually added unless the call succeeds. In fact, there's a race condition that we've introduced. So we add the watch or the watcher. I don't know why they refer to them as both watches and watchers. We add it the moment we send the request, whereas in reality we should add it once the response comes back. Because you could imagine that we send the request and add the watcher as we currently do. Some other call modifies the node we Trigger our watcher and then the response to the original request that would have added the watcher comes back and now the watcher has been triggered.
02:03:02.787 - 02:04:07.795, Speaker A: But the watcher should only be triggered after the response the client gets back. So I think here actually we're definitely making a mistake. So let's leave some space here and deal with that. Specifically the observation here is that huh. I think what this has to do is with Watcher. I think all of these have to return just an end watch. Yeah, I think the API will actually want is instead of this just have them all return a with watcher and I guess needs a custom.
02:04:07.795 - 02:05:07.145, Speaker A: It's not going to take a TX like so custom is not going to take anything and then what we'll do is we'll have this return a zookeeper and an impul. Well, we're not allowed to use nested impulse but this will be a one shot receiver watched event. Actually it won't even be that. It'll be this. Right. So if it succeeded, if the operation succeeded, then you get back the thing that will tell you about the watch event. I think that's what it's going to have to be.
02:05:07.145 - 02:05:59.599, Speaker A: This is going to make some other things a little bit more complicated but same thing here that is going to be here and similarly it's going to be a little bit annoying for the glory global watch. This API is not pretty. It's really not pretty. I'm gonna have to find some way around that. Yeah, that's not. Well, I don't know. I don't have a good sense for how to tidy up this.
02:05:59.599 - 02:06:49.007, Speaker A: It basically means that we need to send the. The transmit end of the watcher along with the request to the packetizer and then the packetizer when it sees the response it adds the watcher. So it needs to sort of buffer up all the watchers that it's going to add. That's a little weird. I guess this just means that we need. We're just going to have enqueue be the. Yeah.
02:06:49.007 - 02:07:29.885, Speaker A: Okay. Here's how that's going to end up being so exists. It's going to take a path, a string. Right. A path is a string and a. I think we're going to move the whole watcher business the whole watch settings move that up to here. So a watch actually move it to proto I think or yeah, to proto.
02:07:29.885 - 02:09:03.055, Speaker A: Where do we put it? Up here somewhere. So watch is still going to be a one shot, a one shot sender of a watched event like so. And then we're going to have exist and get children and get data events Instead of including this watch U8 they're going to include a watch that's going to be a. Where's this use? It's going to be a watch so let me say if we get children it's going to be the same for path for get data. The reason we want to include the watch with the request is because when we enqueue the request that's when the packetizer needs to remember that when the response comes back it has to install this watcher doesn't implement debug sure it does. Now we don't need task anymore because all the things we send are just going to be requests. Yeah, actually this is not bad.
02:09:03.055 - 02:11:29.885, Speaker A: This is not bad. This is going to simplify the code a little bit. So the incure is still just going to take a request it's going to give you a. Yeah, it's going to give you a response add watcher goes away this now contains so we bring enqueuer back to include just a request and a one shot receiver of response Is that what it used to have? What do we use? 7 task, result, response and zkerror so aha. And this is now just gonna send thing it used to send which is just a top this now receives the same thing it used to receive which is just this topple again here. So the plan now is that the packetizer it's still going to have this one shot sender and watch type that's all fine but it's also going to have something like a pending watchers which is going to be a map from xid to to a watcher that it has yet to install to watcher to add when okay Right. So the idea here is if an operation with that xid succeeded then add this watcher so pending watchers down here and then down here where do we have our xid is one so so that business is all still correct.
02:11:29.885 - 02:13:10.595, Speaker A: The difference down here is if the xid is something else down here response pars here if let some watcher is self pending watchers dot remove xid Right. So if there is a. If we were. If we're supposed to add a watcher when this request completes then we do that here and that will be pretty straightforward It'll just be watchers dot insert oh, we don't have a path so pending watchers also needs to include the path because we need to insert it into we need to record the path in watchers when we do eventually add it so then that Will be actually, yeah, W0 insert W1, W2. It's not very nice code, but it'll do the trick. Right. So what we're doing is if we get something with this xid, then we extract this string, use that as the key in this map, and then we insert the ladder to things.
02:13:10.595 - 02:13:56.385, Speaker A: So these two, these two and we insert those into that back. I guess this is going to be entry this or insert with the new push that. And this is going to be default watchers. No pending watchers. And it's just going to dot insert. Oh, it doesn't know the XID yet. Doesn't need to.
02:13:56.385 - 02:14:40.365, Speaker A: This is just going to be. Now we always get request response and so we enqueue that with that xid and then we're going to match on the request. We going to get to do that? Probably not. We have to match on the item. And if the item is a request, get data. Right? So get data does have a watch property. The watch is a watch custom.
02:14:40.365 - 02:15:47.425, Speaker A: So then we need to add that depending and same for getchildren that has a custom and same for exists that has a custom. Right. So the observation now is we instead just look at the request and see whether that had a custom watcher. In that case, we will do a. We will have to do ap.pendingwatchers.insert self xid which is the XID of the request. And we're gonna have to steal the watcher, aren't we? We need to own the watcher in order to stick it into here.
02:15:47.425 - 02:16:30.635, Speaker A: So we're going to have to do a mem replace watch with a watch. This has to be global. The reason we have to. So the reason we have to swap out the watch is we need to own it so that we can insert it into pending watchers. And the reason it's okay to replace it with watch global is because from this point forward, the only thing the watch field of the request is going to be used for is whether to send a 0 or a 1 as the value for watch and global would cause it to be set to one and none would cause it to be set to zero. And we can set it to custom because custom. Well, we could have this contain an option, but that's also a little weird.
02:16:30.635 - 02:17:15.535, Speaker A: So we just set it to global which causes it to be set to one. I guess we could document that here set to global so that watch will be sent as one ua. So now we're going to insert into that the. I guess we're going to need the Path So path dot to string and W and the watch type data. And then we'll have to do the same for the other two. This is also going to be path. This is also going to be path.
02:17:15.535 - 02:18:17.655, Speaker A: Notice that these are all basically the same. The only difference is what they what the watch type is. So here we could pull the same trick as we did in the other place where we in request serialization where we match on all of them first and then just do a second match for this. Maybe that is nicer. Sure, let's do that. So it's this or this or this and then W type is going to be match item request get data is going to give a watch type of data. Get children is going to give one of child and exist is going to give of existence.
02:18:17.655 - 02:19:03.174, Speaker A: Anything else is unreachable and then this will use W type and then these can go away. Anything else we don't deal with. All right. What is it complaining about? Pattern does not mention the other fields. Don't care about the other fields. What else is it complaining about? Pattern does not mention fields. Path watch Missing fields Path watch what? It's very confused.
02:19:03.174 - 02:20:12.485, Speaker A: Why does it say that? 528am I not allowed to do this? I thought I was allowed to do this. Like I want to bind to watch but only if it's of this type. Pretty sure I'm allowed to do that. But I guess I could just do this and then if let watch type custom is watching. Sure. Apparently that's okay. Don't know why it's why it's suddenly okay with it now.
02:20:12.485 - 02:20:57.245, Speaker A: No variant custom found for oh, this was just watch, right? Plenty here. No, that's just old stuff. Undeclared typer module watch settings 2 to 4 lib224 right. Register Watcher is no longer necessary now. In fact none of these are. Oh no, they are. This has to be a watch is the only thing that's important.
02:20:57.245 - 02:22:01.705, Speaker A: So this will be self ZK and this will be watch itself. Watch and then this just has to use this and watch. Right. So the only difference is that we're instead of just sending a 01 for a watch, we're sending along the entire watch thing that we want. Right. And then I guess we're going to have to TXRx is we have to create the channel that will actually be used. Ooh, it's actually a little awkward how that's gonna work.
02:22:01.705 - 02:22:49.811, Speaker A: Let's leave that aside for now. Self ZK this is just going to self watch. This is going to be self ZK and self watch. So we need to. When we create the end watch. In order to create a watch, we have to create the transmit end of a one shot and so we'll create the receive end. Well, we have to stick the receive end somewhere so that we only return it when the thing resolves, which would be down here.
02:22:49.811 - 02:23:31.835, Speaker A: So this is where this is now in rx, I guess. Actually I could totally be down here. ZK no, it doesn't need to be here. We only want to give back the RX here. And I guess technically this should be an option. But this API is really awkward, right? Because you only get back a receiver if you asked for a receiver. I worry that we're like abstracting too much over the.
02:23:31.835 - 02:24:25.635, Speaker A: Over the fact that these may or may not be watched. Maybe the better API really is one where you. You're only exposed to the if you. It's pretty awkward. So my worry here is that. Well, actually this receiver will only be sent on if you used with the watcher because if you use watch, you also get an end watch. But then it will not be sent on because we'll be sending on the global watcher.
02:24:25.635 - 02:25:25.655, Speaker A: So it's almost like we want this to be like a watch globally struck. That is really just an end watch. But we hide the. We hide things from the return type. This would be a with watcher and this would be a. I guess. So here we can just map out the watcher, right? So in all these methods the user wouldn't see the sort of option receiver at all.
02:25:25.655 - 02:26:01.845, Speaker A: So this has an option rx. So this means that the exist type in here would have to be optional. Yeah, I don't know how to. How to make this API nicer except by having lots of methods. Right. You could totally imagine that you have like, just like in the original API you have a bool that's watch on all of them and then you have a separate version of them. They give you a watcher.
02:26:01.845 - 02:27:10.033, Speaker A: Well, it could be that we really just want to replicate these. Maybe they are different enough that here's what we can do fix. Well, map exists response. This is going to help a lot actually. Don't know why I didn't think of this. So if we move this out right then now exists is really straightforward, right? Because this is just going to be this method now map exists response. Right.
02:27:10.033 - 02:27:45.635, Speaker A: So now it doesn't really hurt to replicate exists. And so now we could have a separate one for each of these. And then the return type is just not a Problem. Right, so now it'll be this and this will be watch none. Right? Yeah, I think that's the way to go. Why is it. Right, so this will now just be self command connection and then we'll do the same for all the others.
02:27:45.635 - 02:28:19.005, Speaker A: Right. So we'll have a map get children response. Our response. We have to set the return type. But I'll do that in a second because now we can just use these and build on top of them. Right, like so. And this will then be here.
02:28:19.005 - 02:29:13.665, Speaker A: And then map getchildren response. And then what's the last. Get data response. Yeah, this is going to be much nicer data response here. That's going to be this guy dog map get data response. So now the methods that we have that do not add any kind of watcher are just straightforward here. Sorry, I'm just moving a bunch of code around.
02:29:13.665 - 02:29:49.795, Speaker A: This should be clearer once these are in place. Okay, so the things we're looking at now are the three watchable methods directly on sukeeper. So this is without watching them at all. Right. So in this case, watch should be watch none for all of them. And the return type for all of them should be this. This doesn't have to be a future at all even, does it? No, I think this just returns one of these.
02:29:49.795 - 02:30:20.939, Speaker A: A result of that? Well, sort of. That's actually a little awkward. I think I made that sillier than it needed to be. This for exists. It's really just a stat. Right? I think that's the type exists as. It's an option stat.
02:30:20.939 - 02:30:54.145, Speaker A: It's an option vex string and that's an option. Okay, so this is an option vec string like so. Great. Why is it saying that that's not okay, Next expected close delimiter. That is true. Now it's coming. Associated type bindings are not allowed here.
02:30:54.145 - 02:31:21.595, Speaker A: That is true. It in fact has to do this. In fact I'm. Oh, that's the one place damage that was unnecessary. Didn't copy it to the one place where the signature was actually correct. Here should be a vec and a step. These can actually be.
02:31:21.595 - 02:32:19.375, Speaker A: Well, it's not terribly important. All right, so these top methods, now why is it this should be self. So the reason I wanted to move them like this. Oh, what is this? Can if I type response should be proto response. Gee, this should be responsible result protoresponse zkerror. I think that's the type of R like so. Yep.
02:32:19.375 - 02:33:08.143, Speaker A: So for these, these top methods, the implementation is now very straightforward. And then what we could do is if then we don't need no watch anymore. There's now with watch, this could really just return a watch globally that just wraps self and then just calls these methods again. Right? So watch globally is just a wrapper around self, just a new type around self that has these exact same methods. So globally just has a zookeeper inside. Intel inside. Right.
02:33:08.143 - 02:34:11.655, Speaker A: And that implementation has the same methods, in fact, with the almost the exact same impression implementation. What did I do? That's not what I meant to do this. The only difference is that instead of a watch none, it's a watch global and instead of self it will be self zero. I'll give you a zookeeper. Right? This is a really awkward way to work around adding a Boolean argument, but I think it results in code that's nicer to read. Right? Like, if you think about it, all we're doing here, the only thing we're doing is to change the. In fact, we could do this even better.
02:34:11.655 - 02:35:25.105, Speaker A: We could here find watch bool if watch, then watch global, else watch none. Just to make us all a little bit happier. Isis w path false. Because now this implementation could be self0 exists w true. Even less duplication and then this would be getchildren w watch bool. So notice that behind the scenes, we sort of have the same API as the Synchronous crate, really, but we're just trying to expose it in a slightly nicer way, using what essentially amounts to combinators. So W methods are not public.
02:35:25.105 - 02:36:04.025, Speaker A: The public methods all just take path. Now, getchildren W false. And the one in here is going to be get children W true. And the same for get data. It's going to be this. It's going to use this just like the other one. And it's going to be a 1 without a W down here.
02:36:04.025 - 02:36:34.995, Speaker A: Oh. In fact, we can actually make this even better. So I'm going to do that in a second. But. So this is self get data W. This is the exact same pattern for all of them. And down here this is just going to be get data W true.
02:36:34.995 - 02:37:27.305, Speaker A: So the question of course now is how do we get the actual. Why does it takes two parameters? Oh, right. Path and path and path. The question is how we add the ones that have custom watchers. And we can do that a little bit nicer by instead of it having it take a bool. Having it taken option actually having to take a watch, I guess, is really what it should do. So this takes a watch and then just uses that directly here and then this we just pass in watch none.
02:37:27.305 - 02:38:02.405, Speaker A: This takes a watch that in here false it with watch none. And similarly this takes a watch and this is a watch none. Right. So we now have this sort of helper building on helper building on helper. I guess in theory we don't. We didn't need to extract the maps anymore with this pattern. I don't know why I didn't think of this before.
02:38:02.405 - 02:39:17.325, Speaker A: So this just returns a bidwatcher, Right? So a watch globally is pretty straightforward and in fact a with watcher is almost as straightforward. The only difference in the with watcher is that it also includes the one shot receiver. Right. For the watched event that is the only difference. And these are now tuples, right? So if the operation succeeds then you get both back something you can wait on for the result and you get back the actual result of the operation you did. And now these all have to be watch global. These all have to be.
02:39:17.325 - 02:40:35.630, Speaker A: They have to make a one shot, right? Nope, one shot channel and then they do something like watch custom tx and then we're going to have to here.ma r and we're gonna actually let's do mutar no r not char if R is okay, yeah. So R here is basically a result where this is the okay value and this is the error. Actually no R here is just that tuple Right, So map is only called on the OK of the future, which in this case is this from the underlying exist W Right, the item is this which. So we're mapping on one of those. So I think what we want to do is let ZK is R0 and then let V. So the value is going to be R1.
02:40:35.630 - 02:41:38.445, Speaker A: If it is none, well I guess it's just going to be R1 map that's going to be a stat and we're going to make that be move rx instead and then we're going to return fact becomes even more straightforward. It's just this. I don't know if that makes sense but we're calling the underlying exist W right, which just takes any watch it doesn't really care. And then on the result that we get back we map the option that normally just contains a stat when you call exist w and we put in the rx when it succeeded. If it did not exceed it just gets dropped. In which case we never give out the receiver either. So it's not really a problem.
02:41:38.445 - 02:42:17.117, Speaker A: Right. So here whenever u one takes you to something with the watcher we create the one shell channel. We send the transmitter down the Pipe as a request. When the response comes in, the response will be generated here. If the response is an ok, which we know because map only triggers an OK and the option is sum, which we know by this map, then we give out the rx. Otherwise we don't give out the RX and it's just dropped and nothing happens. Nice.
02:42:17.117 - 02:43:03.425, Speaker A: So the same pattern we can basically use for all of these, I think. So this is just going to be this instead. And this is going to be a little bit different just because it's already a tuple. So this will be bytes instead. And we're going to make that just a three tuple instead of a nested tuple, like so, I guess instead of S we should call this C for children. It's not terribly important. And now all the stuff down here can all go away.
02:43:03.425 - 02:44:22.753, Speaker A: And now of course the API here changed a little in that the API is this with watcher exists and this is going to give us a. Yeah, this is where it's going to be a little bit annoying, right? Because here we're going to get the RX back here and we're going to. We sort of want to eventually receive on this rx, right? How do we pass the RX forward? Specifically we need the. This is the watcher, right? We need the watcher to be passed forward to down here. Well, sorry, to down here. So this is now what used to be exists W. Of course the way to do that is we inspect and then here we actually have to.
02:44:22.753 - 02:45:18.755, Speaker A: This is where it gets an annoying where we have to map it forward.map x move xw I guess we could be a little bit nicer here and this so that this becomes a little bit less annoying, right? So notice we're just like chain. This is what. We've done this a bunch before with futures too. We sort of end up having to chain values along the futures because we get the exist W like all the way up here and then we need to access it all the way down here. And so we need to make sure that all of the futures are resolved in between. Carry that value along.
02:45:18.755 - 02:46:04.735, Speaker A: So here we get it in and then we have to make sure that we pass it along down here. Sysw this ignores it. This is exist W and uses the exist W. Let's see what. Ooh, that's a lot of. A lot of errors there. Protomod547, right? These have a bunch of fields that we do not care about.
02:46:04.735 - 02:47:02.765, Speaker A: Watch is private on 29. Is it really? Can I make it private no, it does have to be pub crate watch type also only has to be Pub Crate 29. 69 don't need watch time. That is true. 69 expected receiver found sender oh, right, this should be a sender. And similarly I guess this should be a sender. All right, we're getting there slowly but surely.
02:47:02.765 - 02:48:20.775, Speaker A: 425 remove xid has to be a ref 549ambiguous associated type exists. That is the weirdest error I've seen for that before. Expected sender found watch Right. It's a little awkward W We need to extract the actual watcher. So this will be a watch, right? It won't be the inner thing of a watch custom. So we need to extract that out. And we know that we can't possibly get here because we just observed that it was watch Quest 137.
02:48:20.775 - 02:50:04.811, Speaker A: Right, and this now has to be two eight and where else? Right, so the now that we have this watch type, when we serialize that onto the wire, I guess create 2U8. Then all we really want is we want to write out a 1 if we want the thing to be watched and 0 if it does not. Which is pretty straightforward. It's just if let watch none itself then is a 0 and in every other case it's 1. This returns a U8 request 132, right? This now has to be a watch a ref it used to be a copy type, right? It used to be U8 540 cannot borrow field of immutable binding as mutable and now we're back to missing documentation which will just. So this is how much work can end up being by just following the documentation of the official implementation just to check that your implementation actually matches. Because that's what we were doing when this started.
02:50:04.811 - 02:51:06.515, Speaker A: All right, let's see. 359. This should just be zookeeper expected option. Oh, that's a good point. So for exists you actually get the watcher even if the operation did not succeed. This is not true for GetChildren or for GetData, because the only way they can fail is if the node does not exist. But for exists the watcher is still added because you can learn that the node was added.
02:51:06.515 - 02:51:50.745, Speaker A: I don't think this is true for get data. It's a very good question. Let's see what the javadoc system say. So for get children with a watcher and the call is successful, no exception is thrown. And an exception is thrown. If the no note exists is this not true for exists, then yeah, so exists does not throw an exception, it just returns null. So therefore the watcher is added.
02:51:50.745 - 02:52:41.541, Speaker A: What about get data? Get data throws an exception if it does not exist. Okay, so it's only for exists that this is the case. Specifically for with Watcher 1 exists, the one shot receiver is outside of the option is all this means that here you always get the rx if the operation succeeded. Sorry, Even if the operation failed, there's a protocol error, obviously don't get one. Let's see how that turns out. 361. Right.
02:52:41.541 - 02:53:16.755, Speaker A: So now you always get that. And this is not a nested tuple. Oh, that's not great. That's not great. So that sounds like we didn't get a notification somewhere. So let's see. POD request exists.
02:53:16.755 - 02:54:08.055, Speaker A: So where is the even node created? So it's handling the response to node created. And at that point that's where we block for exist W. So this suggests that the dispatcher never actually sends out the signal here. So something is definitely wrong. Right. So it does get the watcher, right? It gets both the custom watcher up here and the global watcher down here. Then it gets the event down here, but it never sends to the custom watcher.
02:54:08.055 - 02:55:24.165, Speaker A: So the question is why? So let's see, in the packetizer exists. So I guess this is here adding pending watcher for xid this on this path for and then the W type and I guess pending watchers we want to see whenever that gets triggered. For xid this turned into real watcher. I guess this is xid. Let's just see what that gives us. Oh, we're gonna have to delete the node again. Delete foo.
02:55:24.165 - 02:56:00.845, Speaker A: Let's see what happens. So here, let's see. Added. So it did add it for xid1 on/foo for exists handling response xid1 with opcode exists. This doesn't seem like it's. It doesn't do anything in return to this. So that's probably our problem.
02:56:00.845 - 02:57:36.145, Speaker A: So for whatever reason this doesn't trigger because it prints this, right? It prints that the. It prints that it got the response to XID1 and we know that. Oh, it does produce an error, huh? Yeah, that's why. But that's still a little awkward, right? So this means that we sort of end up installing this thing. I guess this is like if error is none, it's sort of a special case, right? So normally if an operation fails, we don't want to to turn the pending watcher into a real watcher. The exception to this Is if the. Is if the operation was an exists and the result was no node.
02:57:36.145 - 02:58:44.053, Speaker A: That's pretty awkward. I wonder what other. Are there other errors that we can get for an exists call? Map exists response. Where is it? So map exists response only handles the case of node, right? Hmm. It's like either there's an error, either there is no error, or the opcode. I don't actually know what the nicest way to do this is. I sort of want to do, like, if the opcode is equal to opcode exists and the error is equal to ZK error.
02:58:44.053 - 02:59:32.483, Speaker A: No, no. Right. Like that is the only case in which you want to add the watcher. Normally, watchers are. Or I guess watches are only added for successful operations. The exception to this is if an exists call fails with node. But it's telling me that I can't compare zkerrors.
02:59:32.483 - 03:00:07.275, Speaker A: That is definitely true, because here. Eek and partial E, please. And now it should be. Okay. Do I not have opcode here? Oh, it's request all code. And we need to delete foo again because the test failed halfway through. All right, great.
03:00:07.275 - 03:00:48.555, Speaker A: Now we're back. We are back. Let's just see that the progression here works the way we expected. So it creates the session. So that's all fine. It adds a pending watcher, right? And then when it gets the response, it turns it into a real watcher, even though the exist call failed Here, it gets a watcher that's global, but it does not add a pending watcher, nor does it add a normal watcher. Then when it gets this foo, it just notifies the global watcher, which is still what we expected to do.
03:00:48.555 - 03:01:12.285, Speaker A: Nice. I think we're all good. So let's see. Nope. And then we add. Actually, I do want to get rid of these. These map things because they're no longer needed.
03:01:12.285 - 03:01:59.885, Speaker A: So map exists response. Where is that? Up here. It's gonna r. So that goes away. Map get children response goes away. And this goes away with first trying to add a watcher from the pending ones. You do not leak the watchers for the unsuccessful requests.
03:01:59.885 - 03:02:56.305, Speaker A: Let me see if I parse that correctly with first trying to add a watcher from the pending ones. Yeah. You do not leak the watches for the unsuccessful requests. Well, so it gets removed from pending watchers. Right? And then if this condition, if these conditions are not true, it doesn't get inserted into watchers, and therefore it will be dropped, which is the correct thing to do. Right? Because in this case, it should never be used by any of the consumers anyway, like the RX should also be dropped in this case. So I'm not entirely sure what you think is wrong with this.
03:02:56.305 - 03:03:37.035, Speaker A: I think this is right, but I've been wrong in the past. You first remove it from the pending ones on a successful request. Yes, it always gets removed. So remember, pending watchers are tied to an X id, right? Which there will only be one of. We should only get one response from an hxid, so I think this should be right. All right, so let's commit this before we continue our crazy path of docs here. Let's see.
03:03:37.035 - 03:04:27.535, Speaker A: Sure, why not. That's a formatting change. Oh well, that's all fine. And we want this to be only register watches once request has succeeded. Right Back to the docs. Now that this statement is true again. Some successful Zookeeper API calls can leave watches on the data nodes in the Zookeeper server.
03:04:27.535 - 03:04:46.565, Speaker A: Other calls can trigger those watches once watch triggered. Yep, serving the interruption. Oh, I see. You just wanted to point out that. No, no, that's fine. So you pointed out that in the. The code is better now because in the past it would leak watchers.
03:04:46.565 - 03:05:17.155, Speaker A: Yeah, that's true. The other reason why it's better now is because it also doesn't have to create one shot channels that will never be used. The old code sort of had to create them regardless because of the abstraction that is now gone. So I agree with you. I think this is much better. Okay, so this is slightly different for us. We don't actually send that.
03:05:17.155 - 03:06:21.777, Speaker A: So this is something that we'll want to add but don't currently have. I also want to add some examples here why they added paragraphs break here. It seems a little bit weird for some of this documentation to be on Zookeeper. Yeah, I think some of this I want to be top level documentation. In fact, probably what we want is something like this. Right? The Zookeeper programmers guide is sort of like this is the kind of stuff that. Or even the where's the getting started Guide or the overview.
03:06:21.777 - 03:06:32.785, Speaker A: Right. It's almost like. Well, this stuff is almost like what I want to. Well, no, Bookkeeper. What is Bookkeeper Overview? This overview. Right. It's like these kind of things.
03:06:32.785 - 03:06:56.665, Speaker A: I want to be in the. In the docs, but I think like I will probably do some tidying up of this after I finish the stream because moving text around is not particularly interesting to watch. It's more that I want us to add it and do a parsing of the text to see whether there are things that we haven't implemented. Right. Which we've already found one. Right. All right, so back to this.
03:06:56.665 - 03:08:03.165, Speaker A: So I guess. Well, I guess this connect, which would be what, new in Java? I don't know if there's a documentation for the constructor. Sure. Let's see whether any of this is true for us. Yeah, so we certainly don't have chroot yet, which we'll want. This is similar to what the synchronous Rust zookeeper implementation has, where if you add this chroot argument, then any path you get back will have that prefix removed for you, so you don't need to deal with it. It's a very convenient feature that we just haven't implemented because it's not particularly interesting, but definitely something that we would want to add going forward.
03:08:03.165 - 03:09:31.567, Speaker A: And also, of course, currently we only support a single server to create a zookeeper instance, connect to a zookeeper server instance at the given address. Yep. I guess here we don't actually take a watch or argument. Right. We just return. Let's see, when the connection. When the session is established, a zookeeper instance is returned along with a watcher that will provide notifications of any changes in client state.
03:09:31.567 - 03:10:05.125, Speaker A: Well, I guess it really is state because it's server state as well. This notification. No, it's not important for us. Right. So this is a part of that that we don't yet have that we may get time to do in the stream. It's a little unclear given that we ended up in the rat hole of watchers. We'll see.
03:10:05.125 - 03:11:09.031, Speaker A: If the connection to the server fails, the client will automatically try to reconnect if reconnection fails. So this is the code we wrote last time. So only if reconnection fails is an error returned to the client. Requests that are in flight during a disconnect may fail and have to be retried. Handshake is private, so that's fine. All right, let's look at Create. I guess this one, the asynchronous version of Create.
03:11:09.031 - 03:11:49.163, Speaker A: Great, thanks. Good docs. Create a node with a given path. The node data will be the given data and node ACL will be the given ACL that seems unhelpful as its contents. Let's not be overly verbose in docs. The flags argument. Do we have a flags argument? No.
03:11:49.163 - 03:12:37.589, Speaker A: The mode argument specifies whether it will be created as ephemeral or not. Specifies additional options for the newly created mode. If mode is set to ephemeral, what do we call this mode? Do we remember? Oh, we also. We need to do a Bunch of work on this ACL stuff. We currently just copied that straight out of Zookeeper and I think this can also be tidied up a lot. In particular these lazy statics things should just not be necessary. So let's see.
03:12:37.589 - 03:15:00.285, Speaker A: Create mode if mode is set to ephemeral or I guess here it also applies if they're ephemeral sequential the node will be removed by zookeeper automatically when the session is associated with the creation of the node expires. If mode is set to persistent sequential or ephemeral sequential the actual path given path plus the suffix I where I is the current sequential number of the node. The sequence number is always fixed length of 10 digits. That's not controlled by us so that's fine. The I guess we'll document elsewhere that the final the returned the newly created nodes full name is returned when the future resolved the future is resolved. What else do we have? If a node with the same actual path already exists in Seattle keeper, then error create node exists has returned. If a node with the same actual path already exists in Zookeeper, this is returned no exceptions in rust so that's nice.
03:15:00.285 - 03:16:43.243, Speaker A: Note that since a different actual path this is a different actual path is used for each invocation of creating sequential nodes with the same path argument calls with sequential modes will never return node exists if you return async not ready once, does your future not get polled anymore? So not ready does not actually impact whether you get polled again. In general, not ready just tells all it does is tell the thing that runs the future that the future is not yet ready. It does not say when to wake up that future again or when to politics. In fact, normally it will never be polled again until something notifies that future. And so this is why you need to make sure that if you have a future, you poll all the underlying futures so that eventually they will like pull a network socket or something that zookeeper or sorry, not zookeeper that Tokyo or whatever drives your futures knows to wake things up again. So for example, if you had if you had implemented a future that just like all it did was return immediately return async ready it will be called once and never again. You need something to so this is what notifications are for.
03:16:43.243 - 03:18:29.935, Speaker A: To notify that something has to be woken up again. Error create what's the other no node or I guess it's weird to say is returned for futures, right? The return future resolves with an error of yeah, that's better if the parent exists the return future resolves to since ephemeral Nodes cannot have children if the parent node of the given path is ephemeral. Or I guess ephemeral nodes cannot have children in Zookeeper. Therefore, if the parent of the ephemeral the returned future resolves to. In that case it will be error create. This is the one that has the funky name. No children for ephemerals.
03:18:29.935 - 03:19:29.265, Speaker A: All watches left on the node of the given path by exists and Get Data API false which is a parent node by GetChildren. If a node is created successfully, the super server will trigger watches on the path. Wait, isn't this saying the same thing? This operation, if successful, will trigger all the watches left on the node of the given pathway exists and get data API calls. I don't think that's true. I don't think get data will be triggered. Wasn't this what we looked at? Or semantics of watches? Yeah, created should not trigger get data. I think that's false.
03:19:29.265 - 03:20:44.477, Speaker A: If a node is created successfully, the zookeeper server will trigger the watches on the path left by exist calls and the watches on the parent of the node by getchildren calls. Wait, so this documentation is just wrong? These two sentences are contradictory and I think only the second one is true, so. Oh, arrays larger than this will cause a keeper except exception to be thrown. Is this an error that we don't handle? Like, is there a too large thing here? I think we looked at this last time. Doesn't look like it. Maybe like a bad arguments or something. Let's just leave it like that for now.
03:20:44.477 - 03:21:20.969, Speaker A: It's a little underspec, but we'll live. All right, so it looks like we have create working correctly. So let's look at delete. Where's delete? Delete Async version. Thanks. How do we feel about this one? Delete the node with the given path. The call will succeed if such a node exists and the given version matches the nodes version.
03:21:20.969 - 03:22:19.345, Speaker A: If the given version is minus 1, it matches any nodes versions. I don't think we actually need to include any of that information because that's already documented on our error struct. Right? So I think that's still fine. Like this is not because this is not Java, right? Like it's not like you might randomly get exceptions thrown. So I think we can remove that too. I think that's good. This operation is will trigger all watches on the node of the given path left by exists API calls and the watches on the parent node left by Getchildren calls.
03:22:19.345 - 03:22:42.995, Speaker A: That also seems correct. Great. These we're going to have to do A little bit later because they're a little bit special. But exists we might as well right now. So exists. And this exists without a watcher. So it's this one.
03:22:42.995 - 03:23:12.537, Speaker A: Thanks. Does this have a special docs? Yeah, probably. All right, so this one. Return the stat note of the given path. There's a space in the first sentence of the delete method. Did I? You missed a space. Ah, good catch.
03:23:12.537 - 03:23:42.575, Speaker A: Thanks. I think the deletes version could be none instead of minus one. Oh yeah, no, you're totally right. If the given version is none matches any node versions, it is sort of true that like you could also give sum minus one. It's just that none is the right. You're totally right. Return the stat to be given no path if it exists.
03:23:42.575 - 03:24:47.465, Speaker A: Well, and I guess here what we'll really do is we'll take the same docs and put them on watch globally for exists. If no errors occur, a watch will be left should be triggered by a successful operation that creates or deletes the node or set that creates or deletes the node comma or sets the data on the node. Wait, really? Changing the data triggers and exists. That's really weird. I don't know why that would be the case. Oh, I guess it changes the stat is what they're thinking. Great.
03:24:47.465 - 03:26:14.085, Speaker A: So that means that here it is really just or none if the node does not exist, which I guess we probably want down here too. If no errors occur. Alright, get children. I guess we might as well add this one as well, actually. I guess realistically the watch will be triggered by system and a notification will be sent to the default to the watch to the global watcher. And then here the documentation for exist with watcher is going to be and a notification and the included one shot receiver will be notified. Great.
03:26:14.085 - 03:26:52.265, Speaker A: All right, so get children. Get children on up here. Return the list of the children of the node of the given. This is terrible. English. Turn the list. Return the names of the children of the node with the given path.
03:26:52.265 - 03:28:49.825, Speaker A: Better watch can't be true. The return the returned list of children is not sorted or none if the node does not exist. I guess this we're going to put down on here too. And then we're going to remove the stuff about watches down there. This is now, if no errors occur, why is this all passive voice? A watch is left on the node and is triggered by a successful operation that deletes the node with the given path or comma or creates or deletes a child of that node. I guess the Watch is triggered. And.
03:28:49.825 - 03:29:06.365, Speaker A: Well, the phrasing here is a little bit. There are more path that miss the ticks. Let's see. Probably. Oh, down here. Probably. Yeah.
03:29:06.365 - 03:29:57.945, Speaker A: Well, I'm still trying to find the right way to phrase this. Let's look at exist first. If no errors occur, a watch is left on the node with a given path. Path. The watch is triggered by a successful operation that creates or deletes the node or sets the data or sets the nodes data triggered by any successful operation or sets the nodes data. When the watch triggers an event is sent to the Global Watcher Watcher stream. Right.
03:29:57.945 - 03:30:28.295, Speaker A: The watch is triggered by. When the watch triggers an event to send to the Global Watcher stream. Great. And then of course, the same will be for GetChildren. And this should now be. The watch is triggered by any successful operation. I really think that should be any.
03:30:28.295 - 03:31:19.645, Speaker A: By any. The watch is triggered by any success successful and causes the included one to resolve. The watch triggered by. So that's the same thing. Any successful operation and in turn causes the included one shot saver to resolve. Okay, I think that's decently clear. All right, what else do we have? Get data.
03:31:19.645 - 03:32:17.945, Speaker A: Get data. This one. Return the data and the stat of the node at the given path with the node. Great. At. Great. Much better.
03:32:17.945 - 03:32:44.595, Speaker A: Where were we? Get data. Right. And this and that. Great. There are no watches here. So this is just. Or none if it does not exist.
03:32:44.595 - 03:33:37.829, Speaker A: Yes, let's do this. And then this gets moved down to get data. And then this phrasing is basically the same. If no errors occur, a watch is left on the node at the given path. The watch is triggered by any successful operation that sets data on the node. That sets the node's data or deletes it. Right.
03:33:37.829 - 03:34:18.855, Speaker A: Great. And then we add this bit. When the watch triggers an event is sent to the Global Watchers stream and that error goes away. And then get data down here gets the same docs except that it does not trigger on the global stream. It instead does this. Fantastic. All right, what have we missed? Probably a bunch of things.
03:34:18.855 - 03:34:56.435, Speaker A: This is per operations you keeper error types. Oh, it's really reads good so far. Okay, that's great. I think it's certainly better than the Java version. We'll see whether it actually ends up being good. Error. An error that occurs.
03:34:56.435 - 03:35:57.695, Speaker A: I want to phrase this as it's an error that occurs because of the request and not because of like the protocol or the server. A reason. It's like reasons. I don't want to call it reasons either. It's like errors that may cause a delete operator. Great. Oh, do I need to document all the variants? No, the target.
03:35:57.695 - 03:36:48.795, Speaker A: The target node does not exist. Exists. The target node has a different version then was specified by the call to delete. Let's split these up a little. The target node has child nodes and therefore cannot be deleted. I also want some of these to have links to the Java docs or to the zookeeper web docs, but that seems like something that's slightly less important. The target node already exists.
03:36:48.795 - 03:37:34.255, Speaker A: I guess a node with the given path already exists. No node exists with the given. Then target. Target node is fine. The parent node. Well, how do I even want to phrase this? I guess this. The parent node of the given path does not exist.
03:37:34.255 - 03:38:19.005, Speaker A: The parent node of the given path is ephemeral and cannot have children given ACL is invalid. It's so unfortunate that invalid ACL does not give you further information. It seems like a. Seems like a mistake. Oh, I guess these should derive. Well, certainly debug and I guess in theory clone. Although I guess there's no reason not to have it derived clone.
03:38:19.005 - 03:38:48.985, Speaker A: It's just a little weird to clone it. But zookeeper cannot. Oh, you can't debug Zookeeper. Let's see. Proto error. That should definitely derive both copy and clone. Arguably also like hash ord partial ord.
03:38:48.985 - 03:39:27.195, Speaker A: We're getting pretty close. Oh, no error. Bad version. Really. I need to document every field the expected node version minus 1 indicates. I guess here it basically has to not be minus one because you can never get this error if you expected version minus 1 because it matches any version. So there's no reason to include it there.
03:39:27.195 - 03:41:18.425, Speaker A: We also need to document this. So I guess this is a proxy for operations that. Well, this is a proxy for zookeeper that adds watches for any triggered operations. For any. For initiated operations, triggered watches produce events on the global event global watcher stream. And then I guess for with watcher that adds watches that adds non global watches produce events on triggered watches. Or I guess events from triggered watches are yielded through returned one shot channels.
03:41:18.425 - 03:42:15.935, Speaker A: All events are also produced on the global Watcher stream. All right, what's left? Well, we're almost there. FN watch. So this is perform the following operation, I guess next chained operation or add a watch on the node targeted. I'll add a watch for the next chained operation and just call it a global watch. And I guess we could say c. It's not even necessary.
03:42:15.935 - 03:43:04.025, Speaker A: Add a watcher add a watch for the next change operation and Return a future for any received event along with the operations. Result Successful. Wow. Successful result. All right, so now we have docs. Add lots of docs. We don't really have top level docs yet though.
03:43:04.025 - 03:43:59.035, Speaker A: Let's just do this for now. We'll obviously want it to be much more expensive. There are probably still some things we want to tidy up. I don't think I want to start multi server connections in part because I don't have a good way to test it. Chroot would be a great thing for someone to add. I don't think it's particularly interesting to watch me implement it because it's mostly just like cutting strings in various places. Let's see what else do we have here? I guess we could add all these to do's office limitations be like the right thing to do.
03:43:59.035 - 03:45:32.435, Speaker A: Or we could add them as issues. Really there's a better thing to do. So actually let's do that while we're here. Issues new issue Give send connection event on Global Watchers Stream from javadocs I guess I want these. It's a nice way to just like track things that still need to be done. So there's that. There is seven support connecting to multiple well, support pools of Zookeeper servers.
03:45:32.435 - 03:46:35.505, Speaker A: More than one other. Yeah, we also don't currently distinguish between an expired session and just an error during our connection. And technically those are very different in the Zookeeper world. Along those lines. Also handle session expiry differently from errors during reconnect. What else we have right? Support Chroot. Yes, we can call it a feature.
03:46:35.505 - 03:47:28.605, Speaker A: I guess I should tag these too. These are great if you just want to like start playing around with the code from javadocs. Note that this needs to affect all paths in the code base, including watched events, including fields in watched event. So we probably have other to dos too. Let's see what do we have to do? Test this. Nice. Yeah, that's true.
03:47:28.605 - 03:48:18.915, Speaker A: We don't really have tests for connection failure in part because they're a little tricky to do. I think we basically have to mock the network, which is totally something we could do. It's just a little bit annoying to get set up. I don't think realistically that's going to change anymore. Yeah, that is true. Actually this is something that we don't say specifically. We sort of need to say here somewhere that all of these future require you to run them on a Tokyo run time because we use things like timers, right? So you can't just like call dot wait on this and expect it to work.
03:48:18.915 - 03:49:23.501, Speaker A: So I think we'll do that up here. Note that all operations that all futures in this crate expect to be running under a Tokyo runtime. In the common case, you cannot simply resolve. You cannot resolve them solely using wait because wait wouldn't run a runtime. What else do we have? Okay, so this has now been done connect here direct. Oh, that's right. So now when we added the Zookeeper transport trait in the previous stream, we now have this weird setup right where connect only call.
03:49:23.501 - 03:50:11.345, Speaker A: It calls like TCP stream connect directly and then does the handshake. But now we can just do that directly in Packetizer New because Zookeeper transport has this connect method directly and it's sort of unfortunate for this to be tied up in the. In the outer connect because it means that this outer connect can't be generic. Right? We sort of want this to be generic over S where this is like S adder and I guess S would be Zookeeper transport adder or something. I don't remember exactly what it was. I committed this already. Right? Yeah, I mean we could try that.
03:50:11.345 - 03:51:06.425, Speaker A: So in theory that just takes any adder. I don't think we actually want to do this right now. Yeah, I think. I think this is definitely an addition that we want to add. So usually support non PCP connections and handshakes because Packetizer is fully generic over the underlying transport, but Zookeeper is not. But it only really requires that for connect. So we should.
03:51:06.425 - 03:52:17.891, Speaker A: We should use the Zookeeper transport trait to bring all the network connectivity stuff things into packetizer New, including the handshake because the handshake can be then be reused used for session reestablishment. So if you recall from the last stream establishment. If you recall from the last stream in the session reestablishment stuff, we have to create a new one of these request connect objects, which is basically what handshake does already. And it's sort of unfortunate for this to be happening in two places. And so that's also something that should be. Would be nice to fix up what else we have that's a to do. I think this one can go away that we can go away because we know an issue for it that error.
03:52:17.891 - 03:53:10.167, Speaker A: I don't know if we even need. Oh, maybe we should do logging. How do we feel about logging? Do we want to do like just like do a pass and get rid of all the print lines and debug stuff and add proper logging throughout the thing? Would that be interesting to watch? I mean, if you think so, write it in the chat. Just finishing the pass through for to do's or if there's something else you want to see, then now's the time to chat out. Move to do's to GitHub issues. Oops. Yeah, do it.
03:53:10.167 - 03:53:41.595, Speaker A: All right then, let's do it. Let's see. So let's get rid of some of these. I guess we do want to add links to some of these later. It's not terribly important for now. I'll probably do a pass on the documentation after I finish the stream because we've now done the important thing which is walk through and see that we actually conform to what the Java client says that we should do. But there's a bunch of other tidying up that we can do and you can watch the commits on the repo if you want.
03:53:41.595 - 03:53:58.961, Speaker A: If you want to see what things I end up doing later. Not sure whether I get to it today, but we'll see. So for logging there are a bunch of rust logging libraries. One that I like really quite a lot is Slog. I don't know how you pronounce that. Slog. Slog.
03:53:58.961 - 03:54:48.245, Speaker A: Slog sounds good because it has multiple logging levels which log also does, but it also has. It's customizable in terms of the output format. So you can have like, there's like a colored terminal logger for example. This is really handy. So let's do that. Slog is like 1 point something, 2 point something, 2 point, 3.2. I know extern crates, log and ooh, what we want.
03:54:48.245 - 03:55:32.265, Speaker A: That's a good question. So the basic setup is log is you have what's known as a drain or a logger. And if you look at the logger, where's logger? Logger. So a logger like you can create new loggers pretty easily, but the crucial thing that you want is there's a bunch of macros that are basically up here like crit, debug, error info and log that are the different logging levels. And if you have a logger, you can always create a new nested logger with some values preset. So this is a really nice way to make nested loggers where you have some logger that always in includes data from the parent logger. So you can create a hierarchy of loggers.
03:55:32.265 - 03:56:04.733, Speaker A: Loggers are also cloned, which is really nice. So what we want to do here is well, they're cloned of the underlying drain. So a logger is connected to a drain and the drain is sort of where you output stuff. And so what we're going to say in our case is we're going to use the default drain because. Because we might as well. And we're going to say that a zookeeper has a logger which is a slogger. Slogger.
03:56:04.733 - 03:56:43.751, Speaker A: Why not? We're also going to have our protomod contain a. This file has a lot of stuff now should be broken up some more new issue. Break up source photo mall into smaller files. It's getting ridiculous. It's a great issue with description. Probably going to end up hating myself for that, but it's fine. All right, so we want on packetizer.
03:56:43.751 - 03:57:40.745, Speaker A: Where's our packetizer? Not on active packetizer, but on packetizer itself. What? Where's packetizer? There we go. Logger is a slog logger. I guess we want to use slogan. Oh, and we also need to bring the logging macros in and that's a little awkward. So we sort of want the user to be able to specify the logger but default to something that's just a drain. So sorry, to clarify, there's a logger that is called.
03:57:40.745 - 03:58:38.125, Speaker A: Is it drain? I think it's no. Where's the discard? So a logger discard is just a thing that you log to and nothing happens. And so it makes a lot of sense for that to be the default logger in our case. I think we just do logger argument to new. So and I guess exit logger is log clone because now finally we can do do info. Well, actually, no, this is an error. Exit logger.
03:58:38.125 - 03:59:37.925, Speaker A: The other thing that's nice about slog is you can have tagged fields. I don't actually use this right now, but you can do things like at the end do like foo. It's like I and it will be printed nicely and formatted if you have structured output and whatnot. For this though, we actually just want the printout, right? And then I think what we want Here is for ActivePacketizer to also carry a logger around, probably just so we don't have to. Well, we can just pass it in each time. There's some advantage to having each packetizer have its own logger because then we could set fields for every logger, like for every packetizer. I mean, to say that whenever an active packetizer prints, it also includes its iteration ID or something.
03:59:37.925 - 04:00:13.465, Speaker A: So that we can tell if we go from reading the log output from one active packetizer to the log output from a different one. But I think we'll probably leave that alone for now. It's probably not Terribly important. So specifically poll it's going to be logger and take one of these and we'll get back to actually making that work. It does mean the packetizer new down here. Third argument. It's getting long.
04:00:13.465 - 04:00:42.875, Speaker A: Let's see. So we sort of want a like a connect with logger. This is where you get a builder. Right. So I guess we can do that. So pub struct Zookeeper Builder. It's going to have I guess session timeout is the other thing that we.
04:00:42.875 - 04:01:29.175, Speaker A: The session timeout we currently just like set to zero and in theory the user should be allowed to specify that. So session timeout, what is in i32 probably. Yeah, i32. I guess this should really be because we have a good language time duration. And what was the other thing we want to write like at logger? And we want to implement default for Zookeeper Builder. Nice. Catching a live stream.
04:01:29.175 - 04:02:00.925, Speaker A: Always better to watch it live, I think. Unclear actually. You tell me. So the session timeout is gonna be zero by default and the logger is gonna be slog discard. I think that's how you normally do it. The docs for this are not always great. Like there's a bunch of like here features we have, but I don't really care about the features.
04:02:00.925 - 04:02:28.695, Speaker A: I want to see how to use it. Discard. Yeah, you gotta do this. All right. So this is how we created discard log. So the default is that we don't do any logging. And then Zookeeper Builder, it's going to be this.
04:02:28.695 - 04:03:28.793, Speaker A: I guess we'll probably move the handshake too because this might as well just be on builder self then self. And this I guess can be cloned. It's unclear that you want to be able to clone it, but might as well have it be all of those useful things. Yep. So connect is just gonna do that. It's gonna move self handshake. Handshake is gonna also take self and it's gonna get the adder.
04:03:28.793 - 04:05:15.105, Speaker A: And then here this is gonna be self session timeout. Then I guess here we'll get to do our first debug self log. Well, self is it logger or logger about to perform handshake? Great Packetizer new is going to be given the logger and I guess here this is going to be a connection log self logger clone and that's going to be here because we probably will want to trace that. So if you enable trace output, you want to be able to see the connection, you want to be able to see the response to Connect handshakes are not important enough that we want to always show them. So you should think of info as info is shown in release mode, Debug is shown in debug mode and trace is only shown if you turn it on. All right, so now I guess we might still want to with default parameters C Zookeeper Builder connect. So this is going to be Zookeeper Builder default connect adder like so.
04:05:15.105 - 04:05:37.235, Speaker A: And now we don't need handshake there anymore. In theory we could store a logger inside zookeeper too. I guess we already decided we were gonna. Nice. In that case, how does it. Oh, this does not return a self. This returns a zookeeper.
04:05:37.235 - 04:06:27.615, Speaker A: This returns a zookeeper. Right. So we're going to make this BP log and then we're going to have here we're going to put in the logger itself, right? So we have one logger that we give away to the packet dicer which we're going to spawn up in the background. And then we have another logger that we're going to keep for the zookeeper instance. Right. And now here we're going to do something like trace self logger create and path is here path probably don't want to log the data. Probably want to include mode.
04:06:27.615 - 04:07:34.505, Speaker A: It also has this nice thing where you can prefix something with a question mark to use the debug output of that value. So we have that we have delete version version we have here exists path. And this will just be watch I guess because we'll want to see that as well. And we don't need to log in the sort of the leaf things because they all end up calling these children and get data. I don't think those are much left in this file. Nope. And so now the question is what we want to log in proto mod.
04:07:34.505 - 04:08:04.235, Speaker A: So here we now have the logger inside the packetizer. So let's start at the bottom of the packetizer where is new. Right. So that just. That's really just packetizer pull. That's sort of the main loop. These we sort of need to decide how noisy we want debug output to be.
04:08:04.235 - 04:09:19.785, Speaker A: I think things like this are probably trace because that's not terribly important. Right? There are other things that will be important like I guess you don't actually print that much here. Reconnection response is definitely a trace about to handshake again. So this. There's probably an info here where we want to say like down here info connection lost reconnecting. And then here we want to include the session ID and The last because it may be relevant. We could include the password here too, but it's not terribly important.
04:09:19.785 - 04:09:52.721, Speaker A: Also, I want Rust to start formatting macros, even though I know macros are hard to format. Okay. And then I guess the rest of this really goes on in the state polling. So self logger. I don't know if that matters. The name is slog. Slog.
04:09:52.721 - 04:10:22.735, Speaker A: It's this great. Or are you asking the. Oh, the. Yeah, yeah. This is logging great poll. So this is given a logger. But crucially this I guess is given a logger and it calls this with the logger for reconnecting.
04:10:22.735 - 04:11:04.295, Speaker A: I guess we do need to include the logger. So where does reconnecting pole go? Oh actually that doesn't need to do that at all. Great. So the packetizers pull nq. That's going to have to take the logger. Loggers just like end up everywhere. So this takes a logger that's a mute S log logger.
04:11:04.295 - 04:11:50.615, Speaker A: Let's see. This is definitely a trace. I mean so got a request. Could be a debug actually and because this is enqueue. Not really. Yep. And queuing requests, this is I mean trace at best because it could be debug.
04:11:50.615 - 04:12:22.765, Speaker A: But no, it's probably trace. Great. Wait, why does it complain? Oh, so print line. Where do else do we have one of these? Right, so active packetizer. That's the one we want. So for active packetizer we call poll. I think this poll read is not terribly important.
04:12:22.765 - 04:13:34.455, Speaker A: This is going to be given the logger. I guess this is trace sending heartbeat. Oh, I guess that's why I guess we do need the trace here to know that we're about to do a poll read to distinguish it from doing a pull write down here. And we want to pass the logger to pull right two and then this should be debug logger because it's useful to know when the packet archer exits. And now I guess pull right. Pull right takes a logger again. Logger.
04:13:34.455 - 04:14:38.035, Speaker A: Well, it's a mute logger and it will do. This is going to be a trace resetting heartbeat timer. So this is where we reset the heartbeat timer because we wrote something on the wire. Heartbeat is since last inactive since last wire traffic. This is debug and then pull read which is going to be where most of the logging will probably go. Oh, I see here we have a bunch of things just to even figure out where request boundaries are. I think these.
04:14:38.035 - 04:15:45.605, Speaker A: We probably don't even want to make logging statements. Could have this Be trace. So we could do trace logger need bytes. The other thing that's nice about SLOG is it compiles out any logging statements that are below the threshold of the current build mode. So for example, if you're compiling in release mode, all trace and debug statements will not even be compiled. So like this computation of inland for example will not be computed here. I think the bail is sufficient.
04:15:45.605 - 04:17:15.765, Speaker A: This is probably a debug server closed connection. This is not important. This is definitely a trace. Right. So this is updated ZXID from this is a trace Watcher events I think we also want to trace but notice how very few of these are actually debug. Right. So here that's another good question.
04:17:15.765 - 04:18:24.167, Speaker A: This is going to be something like found waiting custom loggers watchers found potentially waiting custom watchers. Right. Because some of them might be for a different for a different event type. This is the fix we did earlier. Probably don't want to notify on every watch. This is definitely a trace. Unclear that it's even important enough to log, but probably so here this is where we get a response to a user request handling server response.
04:18:24.167 - 04:19:18.395, Speaker A: So here we certainly want to put out the XID and the opcode. The bigger question is whether we also want to print out the contents of the response. I think we might actually. What did we make? Request debug. Yeah so enqueueing request is a debug. So I feel like the response should then also be a debug. I guess one question is whether we want to include the body of the response in the debug output too.
04:19:18.395 - 04:20:29.573, Speaker A: Probably. Well, this is definitely a trace. That is a very good question. I guess here not turn into realwatcher Here we probably want to include the error and again because trace things are compiled out, it's not a problem for us to include some like it's not even expensive but just to include some additional information here. Right. What else do we want? Let's see. I do wonder whether we actually want to print out the response.
04:20:29.573 - 04:22:09.177, Speaker A: But it's a little annoying to do so because it's not parsed until down here. I guess we could just move this whole thing down, right? Handling server error response which would just be E. And then down here we would do the same for handling server response. So that works pretty well. That gives us basically I think the debug response we want because here we might want to make this info like this is an operation that failed. So it seems infoworthy. I don't think we need timeout we may want to log the fact that we've set a timeout though trace negotiated session timeout and that value is timeout and what did we decide it was millisecond and I think that's most of it.
04:22:09.177 - 04:22:59.957, Speaker A: Do we still have any print lines here? Nope. Do we have any here? Got through all futures. That's a part of testing. It's probably not going to compile because I probably missed something out. In fact I know that the session timeout this should be rust at time duration I I want sub that's awful. I want just into millis and this is still not something that's here. So you need to compute it manually, which is pretty annoying.
04:22:59.957 - 04:24:05.695, Speaker A: So it's this ASX times 1000 plus seems unhelpful. 610 format argument must be a string literal. Wait, these should not be like this. This should be xid is this it should be path is this and it should be W type is this what logger. Ooh, use of undeclared time. Well, we do need time. It's true.
04:24:05.695 - 04:24:49.053, Speaker A: You're missing two logger in the macro. Oh yeah, sorry. There's a slight delay in the stream and so I. By the time I saw your comment I'd already fixed it, but thanks. 128 this is just going to be self logger 77 time duration mu0 oh I guess. Right. So the crucially the thing we need here is we need the ability to set these values otherwise it doesn't really work.
04:24:49.053 - 04:25:41.685, Speaker A: This is going to be a pubfnsetimeout which is going to be a T. Can this just take a mute itself there? There's a lot of discussion about exactly how the builder pattern should work out. There's an argument for the best thing is if your builder can be this. That's a little tough for us. Or sorry, if your pattern can be this and then your build can be this. In our case that's a little awkward. So I don't really want to do it because it would require that the pointer is static which is all sorts of messed up so that people can chain builders.
04:25:41.685 - 04:27:08.775, Speaker A: Instead I think we're just going to take mute self for now, something we could optimize. But so session timeout is T and similarly we want to set logger where L is an slog logger because now in down here builder is zookeeper builder default and then we're going to do builder setlogger and now we're going to steal one of these slogloggers. Specifically where is it we need to pull in a bunch of crates, which is a little sad. Oops. So this is going to be only in debug mode. Well, only in test mode actually. So we're gonna have dev dependencies and those are gonna be Slog ASync and Slug Terminal 24.
04:27:08.775 - 04:28:02.993, Speaker A: Because now we can use the where is it this business to make our logger. This is going to be logger. I guess we can just do this and then this becomes Builder Connect. If you aren't doing anything special, why are you using setters rather than modifying the struct fields? Or if I missed out on something, I don't like to make fields pub. Whether that's a good thing or a bad thing is unclear. But the test like I don't really want to mark these two fields as pub. Right.
04:28:02.993 - 04:28:53.637, Speaker A: And theoretically I could, I guess so that you can read them out as well. I just have like an aversion to doing so. The other reason is because it's easier. Well, yeah, I mean it's a good question. I guess one of the reasons to do this is because it means that I can imagine that later I wanted to change session timeout to like just hold an i32 directly, right? Then I can still present the same external API of taking a duration, but then just store it as an i32 internally. If I give make the fields pub, then I'm committing to this being the context of builder. The other reason I don't want to do it is because it's totally reasonable for us to want to add more fields to builder later.
04:28:53.637 - 04:30:15.335, Speaker A: That would then be a backwards incompatible change. Because if these fields are public, it means that people might be matching on Zookeeper Builder, which I don't want them to do. Let's see, why is it complaining about this? Oh yeah, that's wrong. So still gonna yell at me somewhere but 164 found u32 so I would want this to be as i32 and I want this to be oh, it's like logger not send or something. Wait, this has never been a problem one before. What did I change? Yes, I mean it's a. It's a good question.
04:30:15.335 - 04:30:37.581, Speaker A: In Java you definitely do getters and setters everywhere. I often don't even do getters where in the builder pattern. Specifically I only do setters. Not for any good reason. It's just usually the setters are all you need. I do like not exposing the fields directly because it means that you can change them. I think that's generally a good pattern and Especially in a.
04:30:37.581 - 04:31:27.805, Speaker A: In a language like Rust where you have pattern matching too on top of this. Right? I wonder why it's saying that this has changed. It's got to be that logger is not send. Oh no it is not. It is because this has to be logger clone and then it has to move in this so that's fine. And then it's complaining in 707. Oh actually it's really this.
04:31:27.805 - 04:32:52.287, Speaker A: This needs to just be log now where does it complain? 492 oh, 492. Right. This is because I need to use use as log drain opcode 461 really use of moved value opcode but opcode should be copyrighted. Why didn't Noah warn me about that tonight? Oh, we're almost there. 643 cannot borrow it mutably more than once at a time. Where is it already borrowed? Oh that's right. Does not need to take a logger.
04:32:52.287 - 04:34:36.924, Speaker A: It already has the logger itself and same down here. Oh, this should probably say the XID it's going to enqueue it with. Right? Builder that allows creating more customized allows customizing options for Zookeeper connections. Uh huh. And these of course the session expiry timeout. See that's just like an unhelpful comment. Arguably there should be a link here to something like where's the FAQ that I found here? Really they don't have direct links to this? It seems false actually I guess in theory it should be here right? It should link to sessions.
04:34:36.924 - 04:36:11.365, Speaker A: That's a lot more helpful logging instance to use the default timeout is dictated by the the server. Defaults are always something that like should be documented more than aren't used internally in the Zookeeper client by default all logging is disabled and I guess also I sort of want to link to the docs. See also the Slog documentation. That's not that URL. All right, how about now let's see what it gives us. That's beautiful. Beautiful.
04:36:11.365 - 04:37:18.748, Speaker A: So notice now it's not included any of the trace output. So what I like to do is there's a. The way to turn that on is by saying features is max level max debug level trace I think so I like to have that line commented out so that it's easy to add again what's it called? Slog. What's the name of the feature? Max level trace. Really do like seeing other people program in Rust. So I get to see very different styles to programming. As I said mine is quite different but then again, the only sizable Rust project I have is my MSC project, so I don't really have to worry about other people ever using it.
04:37:18.748 - 04:37:45.085, Speaker A: I mean, that's true. I do think that they're seeing other people. Code is like interesting in its own way, right? So here, notice here, there's now a bunch of trace output, right? And all of that is normally just hidden. Oh, that's interesting. Dropping messages due to channel overflow. Wow. I don't think I've seen that before.
04:37:45.085 - 04:38:26.484, Speaker A: Really? I feel like there's a better way to do this, but it's not important enough for me to care. At least this means that we have all the tracing that we need. So I'll pop this back to this. It's a little annoying actually, that it's not easy for users of this library to then turn on max level traceres log and I don't know how to fix that. I think I asked the developer at some point and he didn't have a good idea. All right. So all of this to say that we now have logging add support for logging.
04:38:26.484 - 04:39:29.278, Speaker A: Great push. Also, let's do a cargo publish. It's like version 0.1. Oh, it might complain about all sorts of other things because this file, I guess Dev minor Fantasimi probably. Let's see what kind of things we're missing. So we need this asynchronous client library for interacting with Apache. Zookeeper Documentation is going to be at docs on rs.
04:39:29.278 - 04:40:36.923, Speaker A: Tokyo Zookeeper. I don't think we even need to set that anymore, actually. Oh, I guess we'll have to figure out what keywords are going to be things like Zookeeper, Tokyo Asynchronous. I also found out recently about Crates IO category slugs, which is basically the page I wanted last time because we want categories, API bindings. What else? It's not really a database. Arguably it is a database because it's a key value store, but ignore that for now. What else? Network programming, I guess.
04:40:36.923 - 04:41:04.785, Speaker A: I think that's true. Arguably not web programming. I think the game is just include as many as possible. Well, sort of. There's actually an upper limit. You can't publish if there are more than seven or something. I ran into this unintentionally.
04:41:04.785 - 04:42:03.211, Speaker A: We don't have Travis yet. I did not try to categorize it with all the categories, but just wouldn't. Wouldn't let me. I guess there's still. We still don't really have any top level crate documentation, but that's something I'll add later. Commit am better cargo automl oh I guess I also need to do this so we push and then we do cargo publish allow dirty so that it doesn't complain about my Travis Yumo file. Have they mentioned that categories of publicly? I've never heard of that part of the site before.
04:42:03.211 - 04:42:52.105, Speaker A: Now I know I hadn't heard of it before either, but there's a pull request that just landed. That means that it will now be listed somewhere here list of category slugs. It's now under docs it did not used to be it was added like in the last week but it has apparently existed for a very long time just like no one knew about it. All right Docs RS Tokyo Zookeeper probably hasn't been built yet, but in theory should be there pretty soon. Ooh typesave chunk of memory. That's pretty cool though. I think we're in a pretty good place now.
04:42:52.105 - 04:43:29.575, Speaker A: What I'll do is also go through the GitHub issues and tag them for like things that are beginner friendly. I think many of them should be pretty straightforward to like dive into and try to implement yourself if you like. Won a challenge and I'm happy to review pull requests in general while we wait for this to finish. I think we'll basically finish up here. I don't think there's too much more I wanted to cover multi server connection. Sadly we did not really get time for that. It's also a little bit tricky to test because I didn't find a good efficient way of running many servers on one machine in a way that's not super annoying.
04:43:29.575 - 04:44:13.253, Speaker A: So that's still something that's relatively major to do, but it's also somewhat uninteresting from the asynchronous part of things. So I think at this point I probably won't do more livestreams on Tokyo Zookeeper unless they're questions. I'll still continue fiddling with the crate, but I'll probably do that more in my own time. And so if you have ideas for other things you'd like to see me do, then reach out either in chat now, on Twitter, on Patreon, any of the other places. Like I love getting ideas for this kind of stuff. The last thing I toyed with was doing some kind of standard library data structures. So we did a hash map a little while ago using a link touch map which has turned out to be quite popular.
04:44:13.253 - 04:44:47.167, Speaker A: And so I could do something like that that's sort of a little bit more introductory rust, but also pretty interesting. Or we could do some other crate that's asynchronous. There's a bunch of other ideas there, so if you have ideas, feel free to reach out or email me for that matter. Why is this not building? I'll be gone for the next four weeks, probably, and so it'll be a while until the next stream. But all the recordings for the past streams are online, so you could watch those if you haven't already. I'll post this as soon as we're. As soon as I finish recording, I wanna.
04:44:47.167 - 04:45:12.005, Speaker A: There we go. Tokyo Zookeeper. We have a thing that's out. That's fantastic. I think we might want to clean up some of the structs, like maybe put some of the ACL stat under a module or something. Let's see how this generally looks. Decently respectable.
04:45:12.005 - 04:45:48.091, Speaker A: Decently respectable. I guess here there's a bunch of documentation we haven't done because the stat in ACL we've just copied from the synchronous Zookeeper stuff, but it's a good start. All right. Thanks for hanging out with me and writing Zookeeper stuff. It's been fun. I didn't mention this. If you have feedback about the streams as well, then I love to hear that.
04:45:48.091 - 04:46:14.525, Speaker A: There have been people who pointed out that some of the pages I visit are too white, which actually makes a lot of sense. Like I'm switching back and forth between dark and light windows, or like some people wanted larger font sizes. Any of those kind of things. Just reach out and I'll try to do my best. Thanks for watching and feel free to try to address things in the repo if you want. I'm happy to review pull requests. All right, Bye everyone.
