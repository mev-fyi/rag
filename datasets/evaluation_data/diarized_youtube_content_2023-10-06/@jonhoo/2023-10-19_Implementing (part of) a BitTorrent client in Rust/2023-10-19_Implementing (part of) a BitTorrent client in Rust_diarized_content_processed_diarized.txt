00:00:01.320 - 00:00:31.435, Speaker A: Okay, folks, welcome back. It's good to virtually see you all again. It's been a while since we did one of these implementation streams, but I'm pretty excited. I like writing code and I get to do more of them. This stream is actually inspired by a stream I did previously, which was implementing the Fly IO distributed systems challenges. So we didn't do all of these, but we sort of started from the beginning and worked our way through the challenges. It was a really fun way to just get into distributed systems a little bit and think about some of the problems that come up.
00:00:31.435 - 00:01:21.125, Speaker A: And I think we got. Did we get through 1 and 2 and maybe partially 3. So it was fun. There's a bunch more challenges, and I thought about doing a sort of part two where I continue those challenges, but I was sort of hesitant because I also want to leave some room for people to do it on their own without sort of being led through it by the nose. And so instead of doing those, I was, like, trying to figure out something else to do instead. And then shortly after I did that stream, a company reached out to me and was like, hey, we actually make coding challenges that are intended for, like, learning where you build real things. And they were like, well, because I've been fairly public about not really taking sponsorships, at least so far.
00:01:21.125 - 00:01:49.374, Speaker A: That's not really a thing I've been doing. And they were like, we don't necessarily want to sponsor you. We just think you might find these interesting. And also, you know, here's a referral code you can give people if they sign up. So I went to, took a look, and they actually have a catalog of, like, challenges that are, build your own X, so build your own redis, build your own git, build your own whatever. And they sort of give you a test suite kind of thing for each one. And in particular, I saw that they have a build your own BitTorrent.
00:01:49.374 - 00:02:26.867, Speaker A: And I was like, okay, great. BitTorrent is a fun distributed system. Let's go ahead and build that. Now, there are sort of two ways to go about this, right? One of them is to follow the actual BitTorrent spec. It's not too bad, actually. I've skimmed it a little bit, and I feel like you could probably implement it just from the spec, but I wanted to do it through this codecrafters thing. So codecrafters is the company that reached out to me because it has a sort of sequence of steps of, like, do these challenges in roughly this order and eventually you'll end up with a working BitTorrent and it starts from, like, the.
00:02:26.867 - 00:02:53.261, Speaker A: Just decode the strings that are encoded in this particular format that are used in torrent files all the way down to like, okay, actually download a whole file with like, difficulties and stuff. Now I want to prefix this with. I have never used this thing before. I don't know if it's any good. It might be that we start going through this and it's just absolute garbage. But. But I figured it might be useful because if this works, then this is like a teaching mechanism that I really believe in.
00:02:53.261 - 00:03:29.067, Speaker A: I've told you this before on stream, that one of the things that I really like is learning by doing, like, building real things. And this feels like a thing that encourages that and hopefully makes it easier. So we'll go through this and if we find the structure of this website too annoying, then we'll switch to something else. But otherwise we'll go through and see how it fares. Let me also send you. So should you think this is interesting and verdict's still out on this one, you can also go join them from there. But let's see what happens if I click.
00:03:29.067 - 00:03:43.915, Speaker A: Start building. Welcome to build your own BitTorrent. Great. I would prefer to work in Rust, thank you very much. Yes, please. Language proficiency. I'm gonna go with advanced.
00:03:43.915 - 00:03:59.191, Speaker A: Great. Next question. Every day? Sure, why not? Accountability. I'll pass. No accountability. Ooh, they give me a GitHub repo. All right, let's see what happens.
00:03:59.191 - 00:04:15.735, Speaker A: Git. Clone this thing. Okay. No, I don't want the whole thing. All right, let's see what's in here. Push an empty commit. All right, all right, fine.
00:04:15.735 - 00:04:31.399, Speaker A: I'll do the thing they want me to do. Ooh, okay. So you do a commit, and when you push, I guess they run a test suite. Nice. Okay, great. I have a thing now. Great.
00:04:31.399 - 00:04:48.375, Speaker A: I successfully pushed. Okay. Ben code or B encode is a serialization format used in the BitTorrent protocol. Is used in torrent files and communication trackers. Ben code supports four data types, strings, integers, arrays and dictionaries. Focus on decoding strings. Strings are encoded as length, colon, contents.
00:04:48.375 - 00:05:08.323, Speaker A: Hello is encoded as 5. Hello. Okay, this is pretty standard length encoding. Implement a decode command which takes a bin coded value as input and prints the decoded value as JSON being invoked like this. All right, let's. I want to look at the actual code here before we just blindly accepted. Okay.
00:05:08.323 - 00:05:24.775, Speaker A: Source main. They have a serdi Ben code. No, that doesn't sound any fun. Oh, okay, great. So the thing they give me is really Just there's a. It's a sample torrent file. There's whatever this your BitTorrent is.
00:05:24.775 - 00:05:41.437, Speaker A: That just is the thing to run. Okay, that's fine. It's fine. Oh, rust 170. Okay, let's do. I guess we could pin our rust up to 170. Nah, I don't want to do that.
00:05:41.437 - 00:06:09.535, Speaker A: It's fine. What do they have in cargo tunnel? Don't edit this anyhow. Bytes clap hex regex Serdi Tokyo okay, this seems like a fine place to start. I'm not okay, so they give you very little. That seems totally fine. Main args if command is decode. Otherwise who knows what else uncomfortable this block to pass the first stage.
00:06:09.535 - 00:06:37.611, Speaker A: Right. So this takes the second argument on the command line, calls this decode and then prints the result. Okay, great. So now we got to implement this thing. Oh, and they already did it for me. Why? I guess it's just to ensure that you actually have running code encoded value. So iterates over the characters, takes the first character.
00:06:37.611 - 00:07:19.865, Speaker A: So if the first character is a digit with Radix 10, so it's a base 10 number, then find the first colon. This is not how I would do it. I want to do it differently. I want to do let some. I want to do len and rest encoded value dot split once on colon if let. Okay. Len dot parse.
00:07:19.865 - 00:08:01.743, Speaker A: I don't want all these unwraps then and they parse it as an i64, which I think is probably a lie. Probably can't be negative because it's the length of a string. In fact, it's probably a use size. And now we don't need all this like string offset indexing. So we can then just do return 30 value string rest until len. Now this is also a little weird because this assumes that there are no UTF 8 characters in there. So this is one of those places where I kind of want to look at the spec.
00:08:01.743 - 00:08:36.295, Speaker A: I'm going beyond what the exercise really tells me to do already, which is arguably not what I should be doing. But where is the. Here strings are length prefixed base 10 followed by a colon and the string. Okay, so that's entirely unhelpful when they say length length prefixed. So length in terms of bytes length in search of code points. Who knows? Who knows? All right, fine. We'll just assume that this is basically what they mean.
00:08:36.295 - 00:09:01.145, Speaker A: Can I write like cargo test? Is that a thing that they let me do? Because that's what I want to do. File contains an unclosed delimiter. Oh, yes, it does. And then I actually want this early return. Oh, I guess I can just. I think they. Yeah, they do this.
00:09:01.145 - 00:09:18.675, Speaker A: Okay, here's how the tester will execute your program. All right. So I can execute it the same way. Right? This runs cargo run behind the scenes. That's fine. So it needs to build string length I 64. Yeah, I know, I know, I know.
00:09:18.675 - 00:09:37.685, Speaker A: Yeah. I wonder whether it's different because I selected, like, advanced as my, you know, difficulty level. I wonder whether that actually makes a difference or not. Okay. It printed hello. Which is the correct input. Okay, that's fine.
00:09:37.685 - 00:10:13.585, Speaker A: What I'm also curious about here is. Yeah, this is a byte offset, which I don't love. But it's fine. We'll leave it the way it is. So I guess if I go back here, what do they want me to do? I guess they want me to push. Okay, so Ben code decode strings git push expected blueberry as standard output. Oh, it's because this print line has to go away.
00:10:13.585 - 00:10:44.695, Speaker A: Let's make it an E print line. Maybe wonder if that's okay. That's interesting. Debug output on std. I wish they had that in the code itself. Like, this should not be a change I need to make. Compilation successful.
00:10:44.695 - 00:10:59.983, Speaker A: Grape and logs from here will appear here. Test passed. Beautiful. All right, so we go back. Should the will this now? Yeah. View next stage. Okay.
00:10:59.983 - 00:11:41.525, Speaker A: In the stage you'll extend decode to support Ben Encoded integers. Integers are coded as I number E. Why? I guess E for end. I don't want to use a library crate. That's no fun. Okay, so here's a good question. I guess I can do encoded value 0 is equal to I.
00:11:41.525 - 00:12:20.275, Speaker A: I want. I want that branch first because this one has to. Has to split and then parse. So if the first letter is I, then it's, you know, easier to figure out what we do. Then we go and I guess actually here's what I want to do. If let sum rest equals encoded value dot strip prefix because that way I don't have to index afterwards. Then if let.
00:12:20.275 - 00:13:02.405, Speaker A: If let some digits, I suppose is rest.split ones on E. And I don't actually care about what comes after the E. And then if. Okay, and is digits.parse. this time it is an i64 because it can be negative. Then return this.
00:13:02.405 - 00:13:34.963, Speaker A: Now, this is obviously not ideal. I don't love this. This. I don't love this nesting here. Really. I think even I can just do into here. I'm pretty sure that's supported as I'm tempted here to change this one a little bit because what I want, I guess the.
00:13:34.963 - 00:13:55.811, Speaker A: These two conditions are actually exclusive. So what I'm worried about, right, is that we go in here, we don't find an E, and therefore we might have to take this case. But I don't think that's possible. Right. I think if we go in here, then it. This really is the only valid pattern. And so if we don't hit any of these ifs, then we're going to hit the panic.
00:13:55.811 - 00:14:21.469, Speaker A: The nested ifs here are a little sad. I wish I could avoid those, but I'm okay with leaving this here. I could also implement this whole parsing in num, but feels maybe excessive. So if I now run, I guess I 25E. Okay. I minus 25E. Okay, that seems fine.
00:14:21.469 - 00:14:39.461, Speaker A: And if I don't have an E, then it panics because it says unhandled encoded value. Beautiful. All right. Parsnips. Yeah. So the other way we could do this is we could do. And then.
00:14:39.461 - 00:15:14.599, Speaker A: Right. So I could do if let sum n is. Strip prefix. And then digits. But I don't know if this is really better, right? Like, wait, no, that's not what I want. I want. And then.
00:15:14.599 - 00:15:45.125, Speaker A: So this is going to be. Ignore the first and I take the rest and then I do. I mean, we can look at it and see whether we actually think this is more readable. I don't know that it's going to be, but we can try. So that's going to be this and then digits parse. Okay. So that it turns into an option.
00:15:45.125 - 00:16:35.275, Speaker A: And then. And then, I guess. Yeah. Is that better? I don't know if I think that's better. Where did I mess this up? Oh, strip prefix just gives you rest, right? Mm. It is true that now it will fall through if it doesn't go through these. Like, it'll go to the other cases.
00:16:35.275 - 00:17:07.715, Speaker A: I suppose it's nicer. I mean, we can do the same thing here, right? So we could do. And then if we do actually think it's nicer. So len rest and then we do len parse. Okay. If let's. Well, this one's more awkward because we actually also want to keep the rest part here.
00:17:07.715 - 00:17:43.285, Speaker A: So this has to return len and rest. And so here we're gonna have to go let len is this. And then some len rest. And the reason we have to do that is so that we keep the length here as well. If I Now go back and do five. Hello. Great.
00:17:43.285 - 00:18:07.545, Speaker A: And if I do like four. Hello. Then should skip the O. Yeah, Great. I don't know if that one's nicer for the string case actually, especially because we need to have this block in the middle here. So I think that one I actually want to keep the way it was. The digital encoding I think is okay.
00:18:07.545 - 00:18:36.229, Speaker A: Avoid deep ifs. Amazing. In progress. No more completed view next stage. In the stage you'll extend decode to support bin coded lists. Lists are encoded as L. I see.
00:18:36.229 - 00:19:15.355, Speaker A: So this is. Okay, so this is where we get into nested handling. So I actually think I want to change this a little bit now. I want to match on encoded value. I forget whether you can match on strings this way. So with slices you can do this, but I don't know whether you can do the same thing for strings. Didn't complain about it, but that might be my rust analyzer being broken.
00:19:15.355 - 00:19:36.085, Speaker A: Yeah. Pattern cannot match with input type. That's awkward. Can I do like this? Because that's a range. I don't think I get to do this. I guess I can just do. Is there a split first? I don't think there's a split first.
00:19:36.085 - 00:20:15.061, Speaker A: Yeah, that's fine. All right, we'll match on zero and then we'll say. Okay, if we get I. If we get L and if we get I guess any. This is really anything. So the string case is anything between 0 and 9. Chai is very sad.
00:20:15.061 - 00:20:42.635, Speaker A: I don't know if. I don't know if you can hear her. Are you very sad? Yeah. Come here. Why are you so sad? Do you want to say hello? Are you so disgruntled? Are you a disgruntled employee? Yeah. I'm sorry I couldn't help you. But see, this is where it makes me sad because arguably the strip prefix, like we know that the prefix is I.
00:20:42.635 - 00:21:32.253, Speaker A: That's fine. I suppose. So then this will be serdi JSON value number. And then for the L case we'll do. Or rather for the number case we'll do here. If let sum N is this return N. We could actually do the same thing here.
00:21:32.253 - 00:22:36.247, Speaker A: We could do.in two. The reason I want the match here is just so that this is more like a table. You can cross reference more easily. So what do they say with L it's encoded as l and then a bunch of valid elements and then E. Okay, so this is where it gets trickier, right? This is where arguably you want an actual parser because we're going to have to recursively call, decode ben coded value, which I think means we're actually going to have to. We're going to want to either take a mutable reference to a string here and so we could move the string along to be past everything we've parsed, or we could have it return a value and a stir to say, okay, I parsed out this value.
00:22:36.247 - 00:23:08.275, Speaker A: This is the remainder of the encoded value. Either of those are. Okay, let's maybe go with this one for now. And this is the same kind of thing you see with. If you use a parser combinator like, like nom, what you end up doing is you pass in an input and it gives you back the thing you parsed out and then the remainder of the input. So we can do the same thing here. So this is then going to be rest, rest.
00:23:08.275 - 00:24:39.105, Speaker A: And then really we want to pass that rest. So everything that comes after the E will do here and now this gets into the ugly and rusts. And then here will then do this and len one and onwards like so. And once we have that, then this now becomes. Oh, I guess there is a split at, isn't there? Encoded value dot split at. Yeah. And is this for split at? The two slices returned go from the start of the string slice to mid and from mid to the end of the string slice.
00:24:39.105 - 00:25:05.945, Speaker A: So I think that means it has to be split at one. And then I can do I and rest. And I can do L and rest. Now where this gets awkward is that split at doesn't know that it's returning a single character. So this won't work. It'll have to be this. And I don't know if you can do this.
00:25:05.945 - 00:25:47.623, Speaker A: I don't know if you can have a range of strings. I guess we'll find out. All right, so at this point, that means we no longer have to strip that and we no longer have to do this. And so now for the rest here. I suppose what we'll do is we can't actually search for the E because you could have nested elements, like nested lists, for example, where. So the. You can't look for the first E because that might terminate an inner list.
00:25:47.623 - 00:26:35.575, Speaker A: You can't look for the last E because there might be an earlier E that we could use. Yeah, So I think what we'll do is actually just recur. We'll just call the decoder over time. So we'll do like let mute values is vec new and then we'll do loop. We'll do. Actually, I Suppose we'll do while rest. So we'll make this a mutable string reference.
00:26:35.575 - 00:27:11.597, Speaker A: While not rest is empty, it's not going to be empty actually it's going to be while not rest is empty and rest zero not equal to E. Right. So either. Actually, realistically, we could also not have the is empty clause here. But we don't want it to panic if we have an endo string. Or rather we would want it to panic with the unhandled encoded value. So we want to here sort of terminate the loop cleanly.
00:27:11.597 - 00:28:11.283, Speaker A: And then what we'll do is as long as we see that there are still values we'll do let's V and remainder is decode but encoded value of rest and then we'll set rest equals remainder and we'll do values push V. Right. So we called the decoder. The decoder tells us both what value got out and what the remainder of the string is. Then we stick that there and then at this point we then do rest dot is there a shift because it's. I want to remove the. I guess I can do return values dot into and rest from one and onwards.
00:28:11.283 - 00:28:40.725, Speaker A: Right. Because the one is going to be the E. Sweet. See how that works? So I guess if we can. We can make up one of these. So L for start a list I for a number 25e we could nest the list. Then we could have a three link string foo.
00:28:40.725 - 00:29:09.935, Speaker A: There's no need for an end there. And then we could have another integer which is minus 43. We could end that and then we end the inner list and then we have another value like five. Hello. And then we end the outer list. Let's see what that does. Oh, and this thing down here would have to be dot zero because that's what we actually want out.
00:29:09.935 - 00:29:47.155, Speaker A: String indices are ranges of use size. I could just do N. Rest starts with E. If it's not empty and it does. And it doesn't start with an E. Now. Yeah, I was worried about this.
00:29:47.155 - 00:31:02.185, Speaker A: See, one option is to do the split at and then to map the first character into a map the. So the string of length length one into a character. I suppose I can do lead and rest or. Or if you will tag and rest and then I could match on the tag and I'll keep this mute for the list case. And then now we just need to map. Now we just need to turn the one length string into character and I think we should just do let tag equals tag dot cars next unwrap. Or this can actually be an Expect split at.
00:31:02.185 - 00:31:56.005, Speaker A: I guess split at probably panics if. Yeah, the split at panics if mid is too far. Did not panic. So tag is length one tag equals tag 17. All right, this no longer needs to have an and then because the rest of the outset here is not an option anymore and it's non exhaustive pattern, which is fine. Do nothing in the case of unknown here. Ooh, panicked.
00:31:56.005 - 00:32:17.715, Speaker A: Did not like that one. Unhandled encoded value 3 colon foo. So that's here. That's in the nested list case. Unhandled encoded value. So this is where we got a. We got to start to give ourselves a little bit to go on here.
00:32:17.715 - 00:32:59.185, Speaker A: So eprint line tag is tag. Tag is L. Tag is I. Tag is L, tag is three. So. So why is it unhappy about that? So what goes into this case? And that's where it breaks Eprint line rest LEN is len rest is rest. I could arguably just use the debug macro here would probably been easier.
00:32:59.185 - 00:33:13.865, Speaker A: LEN is empty. Okay, so we. Oh, it's beautiful. Damn it. Okay, so actually I take this all back. We don't want to split out the tag because we need. The tag is part of the length of the string.
00:33:13.865 - 00:33:58.955, Speaker A: So I actually take this all back and this has to be. We don't want to split. We want encoded value.cars. next and then we can do sum of this, sum of this. Which also means now we're gonna have to. We're gonna have to skip the value again, which is a little awkward. So rest now indeed has to be rest split at one, not one.
00:33:58.955 - 00:34:29.341, Speaker A: And I guess here we do let mute rest is. This is actually now encoded value. This is going to be rest split at 1.1. This is going to be encoded value. Note. Encoded values split at 1.1. See how it likes that.
00:34:29.341 - 00:35:00.705, Speaker A: No, field rest 14, right? How does cars next differ from zero? So you're not allowed to index into a string. You can't do encoded value zero. That's. That's not a thing that you're allowed to do. If I do this, it says string indices are ranges of usize. So you can take a slice, but you can't take a single character out of a string that way. And it's because it's UTF encoded.
00:35:00.705 - 00:35:34.765, Speaker A: So the indexing into here is not character index, it's byte index. And an arbitrary byte index into a UTF encoded string is not necessarily a valid character. Like you might be in the middle of a U16 encoded character, for example. And so that's why you can't. You can't do this. Okay, so we still get into this case. Oh, that's because here we don't want to split at is why.
00:35:34.765 - 00:36:05.185, Speaker A: Great. Len is 3 rest is this so len is 3 rest is foo. So it also eats up the I for some reason. Is that because we. So for the string case. Oh yeah, that's because the. This actually needs to be not plus one.
00:36:05.185 - 00:36:35.235, Speaker A: Great. So now we get back a list that parses out all our values. Great. And now we can get rid of this. Eprint, parse lists, git push. See what it does. Amazing.
00:36:35.235 - 00:36:57.915, Speaker A: Next stage, extend decode to support Ben coded dictionaries. Dictionaries are encoded as D key value, key value, key value, et cetera, and followed by E. Great. So this hopefully should be a trivial extension of L. Right. So we say, great. We should also handle D.
00:36:57.915 - 00:37:54.105, Speaker A: This is going to be a hash map, or I think technically a B tree map, because I believe that's what serdejson uses internally. So we skip the D while we haven't encountered an E. Decode the key, decode the value values, insert. I guess this is a dict in Insert adjacent speak. Oh, no, in Ben code speak. And then we set the rest to be the remainder after parsing out both the key and the value. And then we turn the rest at one because we want to also skip the E.
00:37:54.105 - 00:38:55.815, Speaker A: Okay, let's see how that does. So if I do now, the whole thing is going to be a D with a three bar as the key and this list as a value. All right? Import from btrump is not implemented for value, so Serdi Jason value object. Interesting. So what is the map? Okay, let's just do Serdi Jason map New. Can I do this? Is it going to be mad at me or is it going to let me do it right now? I don't need the B tree map anymore. 39.
00:38:55.815 - 00:39:34.353, Speaker A: It requires that this is a string. Okay, so this gets a little bit awkward. So I guess if I think what we want to do here is match on K and if it's a Serdi Jason value string, then. Because in serde. Sorry, in JSON, keys have to be strings, right? So the decode that we do here could be any arbitrary type. Like, for example, the key might happen to be an integer or a list or something, or another dictionary. And in JSON you can't represent that.
00:39:34.353 - 00:40:10.627, Speaker A: So what we want to do is something like here panic. Really? This should use like, proper error handling. One of the reasons I'm not Doing that is because I think realistically I'm going to swap this entire thing out for serdeben code the moment we get to implement a more interesting part of BitTorrent. So this is sort of temporary parsing code, if you will. Dictkeys must be strings. Not great. So that worked.
00:40:10.627 - 00:40:44.815, Speaker A: But if I tried here to use say a I42E Dickies must be string, not number 42. Nice. So now we can do parsedicts git push. These are indeed very easy. It's funny, when we first started this, like these first few steps were listed as very easy and then easy. And I agree, I think these are straightforward. Now we get to the fun part.
00:40:44.815 - 00:40:57.679, Speaker A: Okay, you'll parse a torrent file and print information about the torrent. Torrent file, also known as a metainfo file. Contains. Oh, nice. They link to the spec. That makes me happy. Contains a ben coded dictionary of the following keys and values.
00:40:57.679 - 00:41:34.415, Speaker A: Announce info, length, name, pieces, lengths and pieces. Torrent files contain bytes that aren't valid UTF 8 characters. You'll run into problems if you've tried to read the contents of this file as a string. Use U8 or VECU8. See? Okay, this is where I want to now switch over to not using our own decoder, but instead use the SERDE implementation that they do. Because I think the actual implementing this in a way where we can get nice structs out of it is not, not not the thing I want to spend time on. It's not that it's not interesting, it's just not the thing that I want to spend time on.
00:41:34.415 - 00:42:18.995, Speaker A: So if we go to cargo toml, do I have SERDI with derive here? I do so use serde deserialize and then I can do a struct where they say the keys are announced info and these keys let's grab. In fact, I'm guessing there's more in here. Announce info. So torrent. So announce is a URL. Did they give me a URL library I can pull in here? Yeah, probably serdi URL encoded, maybe request URL. Beautiful.
00:42:18.995 - 00:43:22.629, Speaker A: And we'll keep the documentation from the spec in there as well. I like to have the spec text more easily available to me, which this would do. And then we'll derive, debug, clone, deserialize and then info dictionary. So we'll have a struct info name maps to a UTF encoded string. Great. Piece length. Piece length.
00:43:22.629 - 00:43:45.949, Speaker A: Oh no, I guess I can close that one. Yeah. So I think it's just Length. Piece length maps into the number of bytes each pieces of the file is split into. I guess we can also here just look at the torrent file. This is D8. So announce.
00:43:45.949 - 00:44:21.369, Speaker A: I guess now we can read this format, which is nice. So if I look for info, info has the keys length, right? This is length as a key with this value then it has name. It literally is piece space length as the name of the dict. Wow. All right. I mean maps the number of bytes. Okay, so this is going to be a serde Rename equals piece length.
00:44:21.369 - 00:44:56.295, Speaker A: That's wild. That's a chaos move to have a dictionary whose keys have spaces in them. Pieces maps to a string whose length is a multiple of 20 wild. Okay, so this is. It's subdivided into strings of length 20, each of which is the SHA1 hash of the piece of the corresponding index. This I got to see. So pieces here.
00:44:56.295 - 00:45:29.965, Speaker A: Oh yeah, how about that? Pieces is a 60, a 60 length byte string that is going to be subdivided into substrings of length 60. Okay. Of length 20. This one we can also do a little bit better. We can actually split this when deserializing. So we'll get to that in a second. There's also a key length or a key files, but not both or neither.
00:45:29.965 - 00:46:38.065, Speaker A: Okay, so then we can use serde flatten to say keys and that's going to be a keys and then so serde flattened. Here, let me, I'll show you in a second what that does. So we're going to do enum keys and this one is going to use serde untagged. I'll explain that one in a second too. So there's either single file which has a field length which is a use size, or there is a multi file, I guess instead of keys. This should arguably be files, but for the multifile case. In the single file case, length maps the length of the file in bytes.
00:46:38.065 - 00:47:34.899, Speaker A: Stick this one up here. If the length is present, then the download represents a single file. Otherwise it represents a set of files which go in a directory structure. The multi file case treated as only having a single file by concatenating the files for the purposes of the other keys. The multifile case is treated as only having a single file by concatenating the files in the order they appear in the files list. The files list is the value files maps to and is a list of dictionaries containing the following keys. Okay, so that suggests that there's a files which is a dictionary, which means it's just A type for us.
00:47:34.899 - 00:48:08.243, Speaker A: Like types are dictionaries file. And then I guess we're gonna have a struct file. Okay. And we have a struct file which has length. Okay. Resize as path. Oh, no.
00:48:08.243 - 00:48:42.985, Speaker A: Which is A list of UTF8 encoded strings corresponding to subdirectory names. Okay, so it's a vec of string, the last of which is the actual file name. A zero length list is an error case. Okay, that's fine in the single file. This single file case seems very specialized. Okay, let's. Let's tidy this up a little bit so that it actually, you know, gets formatted.
00:48:42.985 - 00:49:08.355, Speaker A: Great. Let's see if we can make any sense of this. So metafiles, we can do this meta info file. It has a URL and has an info. An info they don't really say anything about here, but maybe the. This one says. Nope.
00:49:08.355 - 00:49:39.323, Speaker A: Okay. Info. Oh, right. Name is a string disappeared in the comment. The name key maps to UTF encoded string, which is the suggested name. Suggested name to save the file or directory as it is purely advisory. This is the number of bytes in each piece the file is split into for the purposes of transfer.
00:49:39.323 - 00:50:11.103, Speaker A: Files split into fixed size pieces which are all the same length, except for possibly the last one, which may be truncated. Piece length is almost always a power of 2. Most commonly 2 to the power of 18, which is 26k. That's fine. Pieces maps. All right, so this one is just batshit insane. So this is actually, we have to make a decision here on how we want to decode this.
00:50:11.103 - 00:51:00.215, Speaker A: Because we could just decode it into a VECU 8 or we could write a custom serde deserializer that will turn it directly into something like a VEC of U8 of 20. That's not too bad, actually. So the way that we would do this in practice. Yeah, I mean, why not? That seems like fun. So, drs. So if we do implementing deserialize. Deserializing a.
00:51:00.215 - 00:52:09.625, Speaker A: No, that's not what I want. I want. I think it's just this guy is all I'm going to need. So we'll do. Yeah, we'll grab these two up here and we're going to have. I guess this is like a hash STR visitor and the value it's going to produce is a vec of U8 each of length 20, a byte string whose length is a multiple of 20. And the only thing we support here is visit bytes and visit borrowed bytes.
00:52:09.625 - 00:53:44.853, Speaker A: And notice it can't be visit string because this is not necessarily a valid UTF8 string. And so now we're going to do if V.len modula 20 not equals to zero, then we can do a. We can return serde error. I forget what the E custom is the one I want or e. Yeah, I guess custom format just to be a little helpful. Length is v len and so now we should be able to say let mute values is a vec new and in fact we should be able to do with capacity here, which is v len divided by 20 and we're going to return okay values and then there's a V chunks that's what I want of size 20 returns an iterator over chunk size elements of the slice at a time.
00:53:44.853 - 00:54:24.701, Speaker A: Starting at the beginning of the slice. The chunks are slices and do not overlap. If chunksize does not divide the length of the slice, then the last chunk will not have length Chunksize chunk exact for a variant of this iterator that returns chunks of always exactly chunk size elements. Okay, so chunk chunks exact 20 returns the integer of a chunk size elements of the slice at a time. If chunksize does not divide the length of the slice, then the last up to chunk size minus 1 elements will be omitted and can be retrieved from the remainder function of the iterator. Perfect. Great.
00:54:24.701 - 00:55:17.507, Speaker A: So this one now I think we should be able to just do. In fact we could just do collect, right? At least in theory. I guess it depends on what exactly the this returns if I go to chunks exact. No, it's not nightly. It was stabilized in 131. The question is what it produces. Where's the implementation of Iterator? Oh, it gives me a slice.
00:55:17.507 - 00:55:52.799, Speaker A: That's lame. Chunks exact should be able to give me a reference to an array. Is there. Is there an array chunks v dot? I don't think there is an array chunks. There is a. Oh, there is. Yeah, but that one's nightly only.
00:55:52.799 - 00:56:14.535, Speaker A: See. So to do use array chunks when stable. That makes me sad. What's the source of array chunks? Oh, that's entirely unhelpful. Okay, fine. So we have a couple of options here. I think what I want to do is actually a.
00:56:14.535 - 00:57:50.615, Speaker A: We can just do a map of slice 20 and we should be able to do slice 20 dot into I guess it's like a. It's really trying to expect guaranteed to be length 20 and we can do the same thing here or actually we don't even need visit borrowed bytes here because we're not going to do sub slices in the first place. So now that we have this visitor. What's the here? Yeah, Implement deserialize. So now we can do this. Implement deserialize for. I guess I technically want this to be a struct hash or hashes which holds a vec of u820 hashes visitor and then this now is going to be in OK of hashes this and now we can do hashes deserialize bytes hashes visitor a little bit custom 30 here.
00:57:50.615 - 00:58:59.535, Speaker A: But what that lets us do is now we can say hashes here. And now we know that this will actually give it will. It will only deserialize things that are actually multiple of 20 and afterwards we can just index into them directly as U820 arrays. So this now should be able to say each entry of pieces is the SHA1 hash of the piece of the corresponding index. And now keys There is a key length or a key files but not both are neither. So 30 flatten here really means treat this enum or treat this type as though it was here. So basically ignore this keys like this key will not be represented in the serialized format.
00:58:59.535 - 00:59:35.715, Speaker A: Instead just inline this definition as though it were placed here. And the reason we want to do this is because we want an enum and you can't really put an enum in here. At least you wouldn't want to. So that way it's like these fields are as though they were placed directly here, but they let us express it through a separate type. And then the enum keys here is serde untagged because there's no tag that tells us whether we're in the single file case or the multifier case. Right. There's no like, you know, tag equals single file.
00:59:35.715 - 00:59:59.145, Speaker A: That's not a thing that's there. It's just. It's a single file if it has a length field and if it doesn't have a length field, then it should match this kind of type. And that's what serdeuntag does. Now serdeuntag comes with some performance implications like we looked at in the decrusting the certicrate stream. But basically it has to try deserialize twice. Once for the single file case and once for the multi file case.
00:59:59.145 - 01:00:41.345, Speaker A: So it's a little slower, but it at least lets us express this pretty nicely. If length is present, then the download represents a single file. Okay, so we can stick that over there. Okay. If length is present, then the download represents a single file. In the single file case, length maps to the length of the file in Bytes. Okay, so this goes here.
01:00:41.345 - 01:01:32.095, Speaker A: Otherwise it represents a set of files which go in a directory structure for the purposes of other keys, the multifile case of the other keys. Oh, for the purposes of the other keys, as in these ones like piece length pieces, et cetera. For the purposes of the other keys in info, the multiple case is treated as having only a single file by concatenating the files in the order they appear in the files list. So this is actually. So we actually do need. The order here needs to be preserved because it has to. The pieces come in the order that they appear in this files list.
01:01:32.095 - 01:02:29.605, Speaker A: The. Okay, so this is a vector of files. The files list is the value files maps to. Okay, so basically they say nothing useful there. So file is the length of the file in bytes and A list of UTF8 encoded strings corresponding to subdirectory names. Okay, names for this file, the last of which is the actual file name in the single fog case. The name key is that.
01:02:29.605 - 01:03:03.655, Speaker A: Wait, there's a name key as well. All right, where is our spec? Let's make this a little larger. Thank you very much. Length path. But which name key? Oh, this name key. Okay, so the top level name key of info. Great, so that means this really is documentation on name.
01:03:03.655 - 01:03:46.095, Speaker A: In the single file case, name key is the name of a file. In the multiple case, it's the name of a directory. Oh, what did I do? Great. And I guess we will derive. I actually want to move this hashes thing somewhere else because it's in the way. Let's do 35 mod hashes. And then I can grab this and this and stick them in mod hashes.
01:03:46.095 - 01:04:46.621, Speaker A: And then I can use hashes hashes. And then we can derive this on all of these ones. And then now we can say, I guess now the question is what do they want us to do with this in this thing? Info followed by sample torrent. Okay, so time to pull out clap here as well. I can never remember the overall structure for clap, so I always just do this, which is fine. Oop, that's not what I meant to do. So instead of like.
01:04:46.621 - 01:05:15.607, Speaker A: And currently we have this. If command is equal to decode, I want to do a little bit better. Which is going to be. We want a where's the sub command example. I want the derived reference sub command. Ooh, I just want the. I guess there's maybe the tutorial is nicer.
01:05:15.607 - 01:06:22.955, Speaker A: Derived tutorial. Okay, so we want the clap parser and we want clap subcommand. And we want to Derive sub command for this, which has decode, which is just a value, which is a string. And we now also have info which has a torrent file, which is a path buff and we don't take any other arguments. And then it's just what command sub command of command command. Great. And now if I go down to my main, instead of having this be just random string parsing, I can get rid of my STD env here as well.
01:06:22.955 - 01:08:08.067, Speaker A: I can do match args command. And if we get decode, then we'll do the same thing that we previously did, right? Which is we do serde v is 30 JSON value is serde ben code. So this is where we're going to start using that serde implementation of bencode that they gave us. Value unwrap and print line V. If we had a torrent, we don't know what to do yet. Now, just to see that this still works with our old like decode things, right? Hashes should be pub, right? Use serde deserializer and deserialize. And then I did something silly here, which is this should be self clone, right? So this is hashes which should really derive debug and clone request.
01:08:08.067 - 01:08:22.975, Speaker A: URL deserialize is not implemented. All right, we'll keep this a string for now. That's fine. URLs are strings. Command cannot be formatted with debug. Okay, that's fine. We'll do derived debug for you.
01:08:22.975 - 01:09:06.595, Speaker A: Amazing, right? And this is the one that we intentionally broke because integers can't be keys, but we can do, you know, 3 bar invalid type byte array expected a string key. Ooh. Also, there's a whole lot of things that it's upset about about these structs. Oh, that's because we never parse one. Okay, so I guess we can. We can set this code up too. So here we're going to do mute F is file open torrent unwrap.
01:09:06.595 - 01:09:51.902, Speaker A: We could stick in some anyhow now too, I guess just to make this a little bit nicer. Anyhow result. And I also want to bring in use anyhow context. And so now we should be able to do here context opentorrent file. And then I should now be able to do T is of type torrent is serdi Ben code from. Oh, they only give from bytes. That's sad.
01:09:51.902 - 01:10:30.945, Speaker A: Fine, read instead readtorrent file from bytes. Torrent torrent parse torrent file. Okay, so that should give us a torrent that we don't really know what to do with. Yet and this whole thing can return. Okay, how about now? It still says all of these fields are never read. An unused variable. That's fine.
01:10:30.945 - 01:11:02.235, Speaker A: That's just noise. But this one's interesting. So. Invalid type byte array expected a string key. Give me a rust. Backtrace equals one line 87. That's interesting.
01:11:02.235 - 01:11:47.097, Speaker A: Did I do something weird in this one to make it not valid lists? That should be fine. List of foo i43ee that's valid. Type byte array expected a string key. This is a dictionary with a key bar and the value as a list here. That ends. That's an inner list. Inner list ends here.
01:11:47.097 - 01:12:40.615, Speaker A: Outer list ends here. Dictionary ends there. Why is this invalid? Just to see that I'm not doing something obviously stupid. Okay, that works. Invalid type byte array expected a string key. So for whatever reason, this 30Ben code thing they have isn't happy with this input. I think their decoder is wrong.
01:12:40.615 - 01:13:10.405, Speaker A: No, but this is. This is the decode. So someone pointed out in chat that this is because of from bytes versus from string. But this is the decode option. So this is not the torrent files, the tar files we read as a U8 and then from bytes. But we're not executing this code path right now. We're executing this code path, which is just from stir from the value that we get in on the command line, which is this value right here.
01:13:10.405 - 01:13:45.523, Speaker A: And this value is just straightforward, like dar. No, it's the B prefix doesn't do anything. Dictionary item keys must be alphabetically sorted. Yeah, but there's only one dictionary key, and that's bar. So it is alphabetically sorted. All right, let's try a simpler version of this. So let's just do D3 bar I25E.
01:13:45.523 - 01:14:51.323, Speaker A: So that's the key is bar, the value is 25, and that's the end of the dictionary. What if I just do 3 bar any valid j invalid type byte array expected any valid JSON value. I think I know why this is actually. I bet you if we go crates IO crates serdi ben code GitHub. I wonder if someone's reported this as an issue. Oh, no. Oh, no.
01:14:51.323 - 01:15:47.095, Speaker A: Serdieflatten isn't going to be working, is it? Bytearray. I want to see if anyone is. Ooh, this seems like something that might come handy in a second. I wonder if we look at the source here. D tuple variant struct variant enum access deserialize parse in. Yeah, so here, if you squint at it, you can sort of See the remainders of the code that we wrote to parse our. Parse the integers and stuff.
01:15:47.095 - 01:16:48.485, Speaker A: Right. You know, I bet you that, yeah, it parses this crate, parses anything that has 0 through 9 as bytes, not as strings, just always. So when it hits, do not delegate this to deserialize any, because we want to call visit str instead of visit bytes on the visitor to correctly support adjacently typed enums. Right. So I think what happens here is that when you try to deserialize into 30 JSON value, serdejsonvalue doesn't tell you which type you're supposed to get back. Right? Because serdejsonvalue supports both bytes and strings. So what actually happens is when the deserializer runs, it doesn't know whether it's expected to produce a string or to produce bytes, and then it just errs on the side of producing bytes.
01:16:48.485 - 01:18:00.755, Speaker A: So I bet you it actually works if you have a, if you actually have a type here. Because when you try to deserialize into this type, then we know that this key is supposed to be an actual string. And similarly for the value, we know it's supposed to be an actual string. And so then the deserializer knows to deserialize into a string rather than into bytes. But when we try to do it into serdejson, then serdejson doesn't dictate what we should do, although it should, because the keys, the keys of maps are known to be strings. That's fascinating. I mean, I guess we can do, we can do our torrent to see what happens.
01:18:00.755 - 01:18:54.015, Speaker A: Oh, that does nothing, does it? Okay, but it didn't error either. So print line or I guess eprintline. See what it got out of that file. Okay, so it actually parses the, the torrent file correctly. So I think the problem really is trying to turn this into just an arbitrary JSON value. I think that's what's going on, which is pretty frustrating because that's what the earlier exercises tell us to do. I guess we should just do like unimplemented, right? I guess I could do like object to require that the top level is a map string serd JSON value.
01:18:54.015 - 01:20:15.623, Speaker A: All right, so that, that it's okay with. So if I tell it that it's a map, whatever. What about my bigger fancy one that it's not okay with? So I think the actual problem here is that when deserializing into serde Jason, then it will always try to parses parse strings as bytes and that just doesn't work. I don't really know what to do about that. But it's also not important because this is just the decoder they're using for earlier exercises. So what if we just do like to do or I guess unimplemented serdibencode to serd JSON value is worked. Right? What were we supposed to do? What was even the challenge here? Right? Like it just parse the torrent file and it asks us to output this stuff.
01:20:15.623 - 01:20:44.735, Speaker A: Okay, that's easy enough. Now that we have it all parsed. No, wrong thing. Okay, so we want a print line tracker URL, which is just T announce. Right. And then we also want to do length, which is supposed to be T dot. Mmm.
01:20:44.735 - 01:21:24.591, Speaker A: T keys. So I think they're probably focused on the single file use case. Right. Also, is there a dark mode for this? No. Oh, the length of the file. So if let keys single file is t.keys Then print out length else to do because we don't know what they want us to print there yet.
01:21:24.591 - 01:22:04.115, Speaker A: So if I now try to give it an info file T. Oh, did I make this files instead? What do I make this? Oh, no, it's dot info keys. Yep. Track URL and length. And that's what it expects. That's indeed what we print. Okay, parse torrent Torrent file git push Application didn't terminate correctly.
01:22:04.115 - 01:22:54.575, Speaker A: So they still call us with the old test cases. I suppose. I mean, all right, I guess. I guess what we can do is wait. Why is it not happy with this? Main.rs fine show. Is that the last one we had this one.
01:22:54.575 - 01:23:32.595, Speaker A: You're going to hate this. Get rid of this. And then we'll take our little comment that this is broken, so keep our manual implant. Yeah, I know, I know. This is terrible. I know. It makes me a terrible human being.
01:23:32.595 - 01:24:13.635, Speaker A: So then we do let V is decode encoded value 0 and then print V. And now I can go back to my old decode. Probably working. Yep. Restore, restore manual impl for old stages of tests. Good push. See what it does.
01:24:13.635 - 01:24:38.563, Speaker A: That seems promising. All tests ran successfully. Fantastic. Okay, next stage. Info hash is unique identifier for a torrent file. It's used when talking to trackers or peers. In this stage, you'll calculate the info hash for a torrent file and print it in hexadecimal format.
01:24:38.563 - 01:25:21.745, Speaker A: Extract the info dictionary from the torrent file after parsing. Okay, we already did this, Ben. Code the contents of the info direction and calculate the SHA1 hash of the bencoded dictionary. Okay, so this suggests that we will need to be able to not just deserialize, but also serialize. Not so important for the torrent, but we might as well. This also means that we're going to have to implement serialize for hashes. Where's my serde? Implement serialize.
01:25:21.745 - 01:25:58.909, Speaker A: Luckily, serialize is a lot easier. Implement serialize. This one don't be afraid of like putting wrap making wrappers for serde. It's actually not that bad, especially once you get used to it. And it can give you much nicer types for parsing. So we want us to self.len so 20 times that because we want to serialize it as all the bytes basically flattened.
01:25:58.909 - 01:26:39.595, Speaker A: Right. And I wonder whether we could wonder whether serde flatten would work on vec. Probably not. And then I suppose what we want here is it's a little awkward because we're kind of serializing them one at a time, which makes me sad. But I suppose that's really what should happen here. So we're going to do self.zero.iter. flatten bite.
01:26:39.595 - 01:27:09.285, Speaker A: That's really how this is supposed to be serialized, right? Like it's a. Oh, I guess. Actually no, it's supposed to be a string. Huh. It's supposed to be encoded as a string and not as a list. So we actually want serialize stir. But no, serialize bites is what we want.
01:27:09.285 - 01:27:50.505, Speaker A: Which is awkward because Serialize Bytes wants a single slice. So I guess single slice, we'll do it the stupid way. Self.it's going to be a vac with capacity 20 times self0.len. Isn't there a. I think we can actually just do self concat. I want to see whether that is true.
01:27:50.505 - 01:28:34.815, Speaker A: So I think we can do self.zero.iter.com concat yeah, and then single slice. See if it lets me do this. Yeah, nice. So concat is just. You can call it on a vector and it takes all the elements of the vector and basically iterates over and collects. So sort of like a iter flattened collect type thing.
01:28:34.815 - 01:29:15.585, Speaker A: So say you see the example here for hello and World. For example, if you have a an array of hello and world and you'd call dot concat what you get back is those things concatenated together together, which is indeed what we want here. So now we implement serialize. I'm actually interested if we go back to the spec like what this Info hash, the 20 byte SHA1 hash of the BEN coded form of the info value from the metainfo file. This value will almost certainly have to be escaped. Note that this is a substring of the metainfo file. The info hash must be the exact.
01:29:15.585 - 01:30:10.439, Speaker A: The info hash must be the hash of the encoded form as found in the torrent file, which is identical to B encoding the metainfo file, B decoding the metainfo file, extracting the info dictionary and encoding it if and only if the B decoder fully validated the input, such as key ordering, absence, deleting zeros. I see. So this is. This is really saying the info hash should be after you validated that the input is actually accurate. Such as, for example, for path like this, path should never. The number of strings here should never be zero. Key ordering, an absence of leading zeros keys must be strings and appearance sorted order sorted as raw strings.
01:30:10.439 - 01:30:53.525, Speaker A: Right? So. So there are a bunch of these requirements that we could verify. And I guess I wonder whether the Serde Ben code implementation will do that verification for us. Because you could imagine that it doesn't do this, right? That when it deserializes a dictionary it's fine with the keys being in non alphabetical order. That could very well be. It would make me sad, but it could be. So just the fact that we were able to deserialize into this does not necessarily mean that we're able to serialize out.
01:30:53.525 - 01:32:33.063, Speaker A: I also worry that the serialized implementation, I wonder whether it actually walks the fields in, whether it's going to serialize the fields in alphabetical order the way the format requires. Like if we look at Serdi Ben code sir serializer and I want to look at serialize map serialize map serialize key sir dot into vec values are not allowed to be empty. And then it pushes into entries the key and the value end self end map and I'm guessing end map sorts the keys. Okay, great. So it does take care of sorting the keys for me when I write them back out. So I guess the argument here then is that if the file that comes in let me just manually do this. I guess because it's being annoying HTML, let's go ahead and do background black.
01:32:33.063 - 01:33:33.205, Speaker A: No, let's do two to two. I guess they have a color here. Huh? What? Where is this background color coming from? Here? Go away. And then let's do color DDD dark mode. So one of the advantages, I suppose, of deserializing the. Deserializing the torrent file and then serializing it again before hashing it is that we ensure that even if the torrent file had, say, dictionaries whose keys were in the wrong order. When we serialize it again, we know we'll be serializing it with the keys in alphabetical order, which means that we're more likely to get a hash that matches what everyone else has because they've also sorted their keys.
01:33:33.205 - 01:33:50.195, Speaker A: All right, I. I think that's okay. I think this also doesn't need to be fully exact, so I'm. I'm okay with this just doing its own thing. This is also. I can't make this one dark as easily. Oh, maybe I can.
01:33:50.195 - 01:34:27.419, Speaker A: Let's see. This is going to be annoying, isn't it? Background color. Yeah, I figured this one maybe background color, black, bulk. Aha. Okay, let's make this one two to two, because this one I mostly don't care about. And let's do this one. Aha.
01:34:27.419 - 01:35:09.257, Speaker A: Great. So now I can do here I can say background 3, and I can also maybe do color TDD. Oh, no. This is going to be going to be real annoying. Huh? Oh, because the highlighting and everything is going to be super annoying. All right, I think this one just has to be freaking light mode. Apologize in advance, but I'm afraid.
01:35:09.257 - 01:35:55.135, Speaker A: I'm afraid this one is not going to do what we want. All right, we'll leave it light. Okay, so we have to calculate the thing. We have to bend code, and then we have to calculate the SHA1 hash. Okay, that seems fine. So let's do. Then let info hash or info encoded is serdi bankode 2 bytes of T dot info re encode info section.
01:35:55.135 - 01:36:39.567, Speaker A: And then we want info hash, which is going to be SHA1. SHA1. This is never. Remember the SHA1 interface, right? Do they also use hex literal or do they use hex? They use hex. That's fine. Back to here. So the actual way is you make a hasher.
01:36:39.567 - 01:37:15.001, Speaker A: I think there's a faster way to do it. I remember there being like a shortcut for like, hey, I just want to. I just want to hash a single piece of content encoded and hash or dot finalize. So this is going to be the info hash, and then we do print line. How do they want this printed? They want info hash. Okay. Info hash and they want that to be hex encoded.
01:37:15.001 - 01:37:56.825, Speaker A: So we'll do hex encode info hash, see if we can get this to run on the sample torrent file. Serialize is not implemented for info. What do you mean it's not implemented for info? Ah, it's because I did not import serd Serialize. How about now? Amazing. So we have a hash that ends at a 7F. A 7F. Great.
01:37:56.825 - 01:38:23.255, Speaker A: Get diff commit. That means we are also correctly serializing hashes here, which is nice. Compute info hash. Let's try git push again, see what it does. It's running a bunch of tests. All tests ran successfully. Congrats.
01:38:23.255 - 01:38:47.851, Speaker A: Okay, so we successfully computed the info hash. See if this is going to be happy listening for a git push. Oh, I might have to refresh this too because of the outage. Which means I need to apply my little trick again. Where's HTML tag? HTML tag element this. Thank you very much. Completed.
01:38:47.851 - 01:39:01.067, Speaker A: Amazing. Next day. Wow, these smileys look pretty. Pretty terrifying in inverted colors. Okay. Piece hashes. In a torrent, a file is split into equally sized parts called pieces.
01:39:01.067 - 01:39:26.419, Speaker A: A piece is usually 256 kilobytes or 1 megabyte in size. Each piece is assigned a SHA1 hash value. On public networks, there may be malicious peers to send fake data. These hash values allow us to verify the integrity of each piece that we'll download. Piece length and piece hashes are specified in the info dictionary of the torrent file under the following keys, piece length and pieces. Yes, we already parsed these. The BitTorrent protocol specification has more information about these keys.
01:39:26.419 - 01:40:14.669, Speaker A: In this stage, the tester will expect your program to print piece length and a list of piece hashes in hexadecimal format. Oh, I mean, this is going to be easy, right? Because we already have all this stuff parsed, so we should be able to now just do. Oh, I guess the. Yeah, this should just be print line. Piece length is going to be t.info.p length and then 4/ash in t.info.pieces, i guess dot zero.
01:40:14.669 - 01:40:55.235, Speaker A: We could implement some convenience functions for hashes here, but zero is fine. Print line. Oh, I see. It wants us to print line p and then it wants us to just print the hash hex encoded. Okay, so hex encode hash. Easy, easy. Print piece hashes.
01:40:55.235 - 01:41:14.161, Speaker A: Good push. I guess we should get rid of some of these warnings. How? They're. They're getting annoying. We don't need serialized map. We don't need serialize sec. What else is it complaining about? That's just output stuff.
01:41:14.161 - 01:41:54.229, Speaker A: And then it's also the debug print of the torrent, which we don't really need in here just to make the output a little less ridiculous. Edcommon less noise. Okay, so this one's happy. New next stage. Discover peers. Trackers are a central servers to maintain information about peers participating in the sharing and downloading of a torrent. In this stage you'll make a get request to an HTTP tracker to discover peers to download the file from, you'll need to make a request to the tracker URL you extracted in the previous stage and include these query parameters.
01:41:54.229 - 01:42:38.895, Speaker A: Info #Peer ID Port Uploaded Ooh, this is a whole lot of things. Okay so I want to grab these and then we're going to do. Should really start to split this up a little bit more arguably. Let's go ahead. Let's make our lives a little bit easier and open a lib RS which is going to have this stuff and also this stuff I want pub. I'm going to make all of these pub for now they're all going to be. They're all going to be useful to main.
01:42:38.895 - 01:43:30.327, Speaker A: This is mostly just to allow us to split things into more files when you. I don't need those to be pub because it's not as easy to have submodules for binaries. I mean you can but it's kind of annoying. And then I guess we'll do up here pub use hashes hashes and then we can grab this one. This may be the main one that we want. And then here what. What do they call this crate? BitTorrent starter rust.
01:43:30.327 - 01:44:25.639, Speaker A: Okay with underscores and I guess we'll. We'll just grab all the types from there. And now I don't think even think we need serde deserialize and serialize because we just have the torrent files right here. So if I run this again right it'll complain about hashes because that's now in this still works. That's great. And now that we have these in a lib now we can do so now we could even imagine splitting this up into like torrent.rs which is going to have I guess actually all of this.
01:44:25.639 - 01:45:37.005, Speaker A: All of that goes into torrent rs so we do pub mod torrent and then we also want a pub mod I guess tracker and you'll see why in a second. It's because I want this type to actually be defined in here too. Pub struct tracker request debug clone only really needs serialized I don't think we need to deserialize these. We're not running a tracker server. And then in main now I suppose we're. We'll do torrent Torrent and tracker tracker requests are going to be the main two we need. And so for this one now we can say Info hash, which is going to.
01:45:37.005 - 01:46:08.575, Speaker A: So the info hash of the torrent 20 bytes long. This is not the hexadecimal representation which is 40 bytes. Oh, this is the actual like U820. Okay. Peer ID is a unique identifier for your client and it's a string of length 20 that you get to pick. All right, we'll make all these pub 2 the port. So that's a U16.
01:46:08.575 - 01:47:06.185, Speaker A: I just happened to know from experience the ports are U16 uploaded. Okay. So that's, that's an amount of bytes that sort of by definition is usize left also usize and compact. Whether the peer list should use the compact representation for the rest of this challenge is set this to one. So it's a U8, but really it's a boolean encoded as an integer. Okay, that's fine. All right, so now we have our tracker request.
01:47:06.185 - 01:47:41.585, Speaker A: So this is the info hash of the Torrent and it's 20 bytes long. Will need to be URL encoded. That's fine. The library we're going to use for this is going to do that for us. Unique identifier for the client. And so here I guess we can. We can just use this value over in our main when we make this request, which we'll do somewhere down here shortly.
01:47:41.585 - 01:48:16.395, Speaker A: Port. I'm just sort of setting these up for. For when we later write the code to actually instantiate one of these. Great. The total amount uploaded so far. So that's going to be zero. Total amount downloaded so far is going to be zero number bytes left to download.
01:48:16.395 - 01:48:41.101, Speaker A: This will be the length of the file. That's fine. Whether the peerless use the compact representation. The compact representation is more commonly used in the wild. The non compact representation is mostly supported for backwards compatibility. So we're going to set it to one that seems reasonable. So just record that here too.
01:48:41.101 - 01:49:23.837, Speaker A: Okay, so now we have a tracker request that implements serialize and so let's just see what that request would look like or that URL would look like. So request to the tracker. It's going to be a tracker request. Oh, did I not save librs? It might be mad at me. Rust Analyzer Seems like it doesn't really like when you change the module hierarchy under it. There we go. Fill struct fields.
01:49:23.837 - 01:50:01.995, Speaker A: Thank you very much. The info hash is going to be the info hash that we computed, not the hex encoding. That's fine. The peer ID we're going to set to what they told us to set it to, which is going to Be string from port they told us is at the six eight one. So we'll do that uploaded to zero because we haven't uploaded anything. Downloaded a zero because we haven't uploaded anything. Size is going to be the entire size of the file which we extracted up here as length.
01:50:01.995 - 01:50:55.925, Speaker A: And so we can stick the length here and compact. We should set to one because now we have one of these requests that they asked us to add. The tracker's response will be a BEN coded dictionary with two keys. Okay, so we go back tracker here and then we do struct tracker response which is going to derive debug, clone and deserialize. Deserialize. No, I wanted all of this. Interval is an integer indicating how often your client should make a request to the tracker.
01:50:55.925 - 01:51:39.789, Speaker A: How often? What's the unit for this? Let's go to the spec tracker responses are BEN coded dictionaries. If a tracker response is a key failure reason, okay, otherwise it must have two keys interval which matches the number of seconds the downloader should wait between requests in seconds. That feels important. So that's going to be a usize. Realistically, it's much less than a usage, right? Like you're never going to wait for like usize max seconds. Arguably this can probably be a U8 or something. But let's do usize.
01:51:39.789 - 01:52:11.791, Speaker A: Pierce is a string which contains a list of strings. Oh no. One of these encodings. Again, each peer is represented using six bytes. The first four bytes are the peers IP address and the last two bytes are the peers port number. This is going to be another one of those fun implementations of a custom data format. Let's do it.
01:52:11.791 - 01:52:54.215, Speaker A: It's more fun that way. So we grab our mod hashes thing and we'll do something similar. So mod peers. So peers is going to be a vector of socket adder. And I know this is a V4 because it says 4 bytes for IP address. So it's IPv4, not IPv6. So we're going to have a peers visitor that's going to produce a peers.
01:52:54.215 - 01:53:40.173, Speaker A: And I guess we can do for the reason why we expect something 6 bytes. The first four are a peer's IP address and the last two are peers port number. That's what we expect to get visit bytes. I assume it's going to be bytes because if it's an IP address, then the bytes here are basically arbitrary. So it can't be a string. It wouldn't be a valid UTF string almost certainly. So that means this should be a modulo six chunks.
01:53:40.173 - 01:54:15.879, Speaker A: Exact six. Slice six. And so we try into U8. Six. We actually don't even need to convert it that way because we, we know that it is six bytes here. And what we actually want to slice this into is we Want to socket ATTRV4. What are the fields in here? Oh, socket hour before.
01:54:15.879 - 01:54:37.239, Speaker A: I think we need to say like new. Really? It doesn't. Doesn't want to give me that. Oh right. Because I have all these other things here. Okay. Peers, Peers, visitor.
01:54:37.239 - 01:55:09.497, Speaker A: Serialize for peers. It's actually going to be a little bit annoying this one because we're going to have to serialize that bytes. Yeah, we'll do that one a little bit later. What's it. It's unhappy about something over here. How about now? Oh, I don't have. That's why I need to import this now.
01:55:09.497 - 01:55:37.902, Speaker A: Am I allowed to do this? Yeah. Okay, so the IP here is an IPv4 adder. And I wonder. Ha. Great. Slice 60, slice sig one, slice 62 and slice 63. The port is a U16.
01:55:37.902 - 01:56:39.179, Speaker A: So that's going to be U16 from. That's a good question. The port, is it big endian or little endian? Does the high byte come first or last port number respectively? Does the spec really not say whether the port should be big Endian or little Indian? Why. Why would they not specify the. The byte encoding of port? It's probably network byte order. I agree. Which is big Indian.
01:56:39.179 - 01:57:23.851, Speaker A: But like. But like why? But like okay, 4 and slice 65 and I'm not allowed to use that constructor. Fine. Um, so the, the reason I use chunks exact here and the reason I do modular is I think it is not. It is a list of peers. Yeah. Which contains a list of peers.
01:57:23.851 - 01:57:56.641, Speaker A: And each peer is 6 bytes. And so that's why we want modulo 6 here not equal to 6 and why we chunk it this way. Yeah, but I don't want any bytes. Oh yeah, because NE is native, it's not network. And so we wouldn't want which order it uses to be dependent on the architecture of the machine we're compiling for. That wouldn't be right. All right.
01:57:56.641 - 01:58:45.409, Speaker A: I mean, we'll see. Luckily, this is something where at least in theory, this old test and whether it does correctly. Okay, so this slicing is going to be a little bit annoying because we actually need to. We can't use concat here because it's not a slice of slice of U8s. So instead what we'll do is single slice is a vec with capacity of 6 times self 0 len and then for peer in self 0 we'll do single slice.extend peer.ip.octets and then we'll do peer.port2be
01:58:45.409 - 01:59:50.725, Speaker A: bytes and then single slice. And now main is complaining at 57 because info hash. Because the info hash we get back from finalize is actually this weird generic array thing. But I think we can just do this maybe. Okay, so in the type of info hash over here is it's where's my SHA1 crate? The result that you get back from finalizing the hash is generic array of U8 and self output size. Now the question is, how can I turn. First of all, where does generic array comes from? That's an excellent question.
01:59:50.725 - 02:00:33.117, Speaker A: Crypto common maybe What? The file that it claims has this type. Does not have this type. Someone pointed out. Oh, you can just. In the, in the function argument here. I could just unpack it. So B1, B2, B3.
02:00:33.117 - 02:01:21.935, Speaker A: Unfortunately that doesn't work because it's not an array, it's a slice. I think maybe I could do like before P1, P2, dot dot. But the problem is this is a fallible pattern because if the slice is shorter, this pattern wouldn't match. So that will only work when we move move to array chunks and then we can also d. We can also pattern match in closure args. So unfortunately that doesn't work. All right, this has to be now.
02:01:21.935 - 02:02:35.305, Speaker A: Torrent keys. Yeah, so the problem is the thing you get back from finalizing SHA1 hash is this generic array type. And what we want is an actual array, not this weird wrapper type generic array. And doing that is a little bit annoying because in part I can't find the generic type implementation. It makes me wonder whether like, can I write UA20 here? So going to let me do that? No, it's not, is it? But. But I don't understand where this generic array thing is because that's from crypto common. All right, give me crypto common then, please.
02:02:35.305 - 02:03:29.545, Speaker A: Does this have a generic array that comes from the generic array crate? Okay, uh, Core rust can't be used generically with respect to N so that. I see. So this is create the preceded const. Generics. Uh, okay, is there a way for me to do it now that it's no longer true? There's not, is there? 0.14.5, 14.7. Please tell me one of them added a way to turn it into a intergeneric array Generic array.
02:03:29.545 - 02:04:37.875, Speaker A: Oh no, this is all slice stuff. See, my guess IS generic array version 1 does allow you to expand one of these. If I do this, surely this uses const generics to give you back the actual. Yeah, into array. I want this one. But we're not using the latest one, are we? Generic array. Generic array.
02:04:37.875 - 02:05:36.775, Speaker A: Yeah, they're using generic array 014 and 014 does not have this method. Okay. I'm surprised that they haven't added a, a converter to this old version of the crate. Like, that's fine, it's fine, it's fine, it's fine, it's fine, it's fine. We'll just do dot try into dot expect this is the generic array 20 is UA20 expected. U820 found a reference. Oh, that's because this needs to go away now.
02:05:36.775 - 02:06:24.875, Speaker A: Great. What do they actually want us to do? All right, this is just so that we can correctly parse peers. And so now we have a new peers command. It presumably also takes a torrent file and it expects to get a list of all the peers. All right, peers command. Peers torrent. I guess just for our own sanity sake, we could now do impltorrent and give it a method to compute the info hash.
02:06:24.875 - 02:07:27.995, Speaker A: Pubfnfohash self returns you a U820 and so now I should be able to do info hash is t dot info hash over here. And as a result I can do the same thing now over here. Why is it T? Oh, right, because we still need to actually parse the file. That's fine. And then the request, I guess I don't need to do yet, but they're going to ask me to do it at some point and I guess I don't need the info hash either. In this command there's going to be some later one where I'm going to need this. That's fine.
02:07:27.995 - 02:08:10.417, Speaker A: And so here what they want me to do is for peer in T. Oh no, they do want me to make a request actually. Never mind. So the request is going to be this. The I guess tracker response is going to be request URL from and I want to use T announce. Right. So I'm basically constructing a URL to the tracker.
02:08:10.417 - 02:09:57.635, Speaker A: And so that's based on the announce URL in the torrent file query pairs. Mute tracker URL is going to be this. And then I guess what I want to do here is pairs is this. Pretty sure there's a better way to do. I don't think this is actually what I want to do. I think what I want to do istracker URL.set Query and I want the URL params to be using the serde URL encoded crate which lets you take URL encode any type which is what we have tostring of request wrap I guess context URL encode tracker parameters and now I should be able to set that to URL params and then I should be able to do a request get tracker URL.
02:09:57.635 - 02:10:37.723, Speaker A: Oh, this is. Let's use the sync one for now. Let response is equal to that if we have the oh, why don't I get context anymore use anyhow context. But I have context. Something's wonky. Oh, it's because. Okay, that's fine.
02:10:37.723 - 02:11:33.025, Speaker A: This guy needs to go over in this file. Oh right. This guy arguably now needs to start returning a result. I'm gonna just expect here should be fine. Some shortcuts are legal and right. And then this is gonna be try into expect generic array. I guess I can just steal the same one I wrote over here like so.
02:11:33.025 - 02:12:24.895, Speaker A: Oh, I guess they haven't brought in the Fine. So we're going to make this whole thing now be Tokyo main and async event because now this has to do a HTTP request so await context fetch tracker Expected URL found string cannot find length in the scope. Oh, I see. Okay, fine. So we still need to do this because they're still assuming that the file is is single. Oh, that the torrent is single file. That's easy enough.
02:12:24.895 - 02:13:41.295, Speaker A: Expected URL found string do they have a new instead? They do not docs RS request Yeah, that's fine, but how do I create a. Can I just make myself a URL instead? Parse parse parse tracker Announce URL expected STR found string all right, reference to that. Beautiful. So I guess now we want peers unsupported value. Interesting. We're going to have to dig into that one. So this is saying when trying to URL encode the tracker parameters this one it's not happy with for whatever reason.
02:13:41.295 - 02:14:48.675, Speaker A: Huh. Why? Why? Why, why, why, why, why, why? I wish it would give me more context here. Unsupported value is not particularly helpful. It's probably the byte array. Yeah. So if we do serde URL encode what URL encoded. My bad tostring actually, I want to see Give me, give me, give me, give me repository and then I want to search for what's the error? I got unsupported value.
02:14:48.675 - 02:15:47.727, Speaker A: Put it value. Okay, okay. I think that's just anything that Right. This gets called for anything that's not one of these. So it can serialize strings, static strings and STRS and sum. Really? No, it specifically said it's not hex encoded. So look over here in Flash.
02:15:47.727 - 02:16:35.615, Speaker A: Note, this is not the hexadecimal representation representation. It is a URL encoded version of the bytes. Which I would hope that the URL encoded crate would do for me, but I suppose not. Which I guess means it does not encode values for me. Regard to bytes support. Serializing bytes only deals with UTF 8 strings. Look, someone else is implementing a BitTorrent HTTP tracker which have already been percent encoded.
02:16:35.615 - 02:17:35.735, Speaker A: This sounds like we could actually just. I mean, we could just URL encode it ourselves. I suppose I just kind of was hoping that we didn't have to because it gets real messy because now, like, what even should the type of this be? Here's what I think we have to do. We have to do. What's the serdi trick for this? Field attributes serialize with. Serialize with equals path copy. Serialize with URL and code.
02:17:35.735 - 02:18:35.534, Speaker A: And so then we're going to do this. And I think this has to be a module. Oh no, function. Okay, so we can do this and has to take a serializer and it has to take a T which is going to be one of these UA twenties. And the way we're going to do that, I suppose is serializer.console stir and we're going to serialize stir encoded is going to be URL. Do they even give me a handle for this? They just kind of claim that I can use SERDE URL encoder for this, but I don't think that's actually true.
02:18:35.534 - 02:20:07.169, Speaker A: I think what we have to do here is. Yeah, I suppose we can just manually encode. It just feels really awkward, right? Like, okay, mute encoded is vec with capacity. So every byte is going to end up being 2 bytes plus a percent. So 3 times t lens and then, you know, for byte in T encoded dot push percent encoded, push hex encode byte I guess string with capacity encoded, which just feels dirty. The trait ostra is not implemented for you. That's fine.
02:20:07.169 - 02:20:31.855, Speaker A: Okay, like, this just feels gross. Oh boy. What? All right, this should be fine. That's gross. That's. That's. That's gross is what that is.
02:20:31.855 - 02:21:47.795, Speaker A: But it works like we get the response back and then I guess we want the. The actual response is going to be tracker response. It's going to be response dot oh, forgot the question mark. Response dot buddy dot bytes. And then we're going to do Ben code from bytes Response parse. Ooh, parcel tongue over here. Parse tracker response.
02:21:47.795 - 02:22:26.893, Speaker A: And that's going to be a tracker response. And then they want for peer in response peers, print line, peer.ip and peer.port. wait, did we not. Did I like not mark it as pub or something? I did not today. Pub. Pub.
02:22:26.893 - 02:22:49.205, Speaker A: Pub. And this is a P. This is a pierce. So pub use pierce. Pierce. Great. And we're almost there because this peers has to be response peers.
02:22:49.205 - 02:24:05.291, Speaker A: 0 missing field interval is interval required. I feel like the response we're getting here is wrong somehow. What? Failure provided invalid info hash. Yeah, I mean, of course is the invalid fucking info hash. Because I guess the encoding did not actually work. What is the actual URL we end up setting here? Info hash. Yeah, see, it ends up URL encoding, the thing that we outputted.
02:24:05.291 - 02:25:03.235, Speaker A: That's. So we URL encode the bytes and then it URL encodes our URL encoding of the bytes. But we can't give just the bytes because then. Okay, here's the way we're going to do this. Note the info hash field is not included. This is very stupid. This feels very stupid.
02:25:03.235 - 02:25:49.775, Speaker A: So there's not going to be an info hash field. Instead we're going to do this and then we're going to do tracker URL query, query pairs, mute, append pair, info hash, URL and code. And this is no longer going to be taking a serializer. It's just going to return a string. And it still makes me very sad. And the thing it's going to do is URL encode t info hash Or I guess we already have it. So info hashtag.
02:25:49.775 - 02:26:53.055, Speaker A: Yeah, thanks. I hate it is right. And it's no longer generic over s either. Provided invalid info hash. It's still getting URL encoded. Why is there like an append. What do we have here? Extend encoding override.
02:26:53.055 - 02:27:46.775, Speaker A: Oh boy, oh boy. Am I really going to do this? Is there really not just a. Okay, request URL. Show me what you got. Okay, so we have querypairs mute, which gives us back a serializer. Manipulate this URL's query string viewed as a sequence of name value pairs in encoded syntax. Yeah, I can apparently append Unicode, but that doesn't help me.
02:27:46.775 - 02:29:40.355, Speaker A: Okay, URL query. These all require strings and serializer is not a public type. Okay, where does that comes from? Form URL encoded form URL encoded Serializer we got here. Set the character encoding to be used for names and values before percent encoding, before percent coding. That's not what I want either. I don't understand why isn't there a way for me to just set bytes in the URL bytes allow non utfa key event value pairs. Okay, that's not super helpful.
02:29:40.355 - 02:31:15.835, Speaker A: No, the encoding override is used instead. I guess the question becomes okay, okay, okay, okay, okay, okay, okay, okay, okay, okay, okay, okay, okay, okay. Encoding override sum. No, because the input to this still has to be a string and this is not a valid string. That's sort of the whole point. Okay, so that's not going to work. Yeah, I suppose the way we have to do this actually is then just tracker URL is going to be format T announce URL params and this.
02:31:15.835 - 02:33:02.631, Speaker A: Now the reason this is awkward is because it's because the. If there are query parameters in t dot announce this won't do the right thing because you would end up with multiple question marks in the URL. What? It. It cuts off the entire query string? Why does it cut off the entire query string? That's wild. Okay, so I guess just. We can just not go through parse. Just don't parse it.
02:33:02.631 - 02:33:32.415, Speaker A: Just pass it straight to request get. Okay, so if you pass it to get, which presumably has to turn it internally into a URL, then it's okay with it. But if you pass it via request URL parse, then it doesn't work. This is just wrong. This is just wrong. This should not be the case. Oh boy.
02:33:32.415 - 02:33:49.771, Speaker A: I've. Yep. Okay, fine. Well, it does the thing. It does the thing. This. That's just this guy.
02:33:49.771 - 02:34:06.383, Speaker A: Okay, great. Thank you. All right, well, we did the thing, at least in theory. 178, 62 with port ends with ND support is wrong. The port is fucking wrong. Look at it. The port here 51470.
02:34:06.383 - 02:34:51.953, Speaker A: The port here 514. Wait, the first. What? Oh no, they're just in the. A different order. Why are they in a different order? Okay, so we are parsing the ports, right? So it is big endian. Okay, I was about to say. But why are they in a different order? Are they in a different order each time? Split files and split modules and contact tracker.
02:34:51.953 - 02:35:13.005, Speaker A: See what happens if I push? The values are random in the instructions. Okay, well, I guess we'll see. I would just like assume that they shouldn't need to be ordered. All right. Well, I guess we did it. Nice. Okay.
02:35:13.005 - 02:35:39.975, Speaker A: Peer handshake. In this stage, you'll establish a TCP connection with a peer and complete a handshake. The handshake is a message consisting of the following parts are described in the peer protocol. So that's also further down here, the peer protocol. Okay, let's close some of these just because otherwise they're going to continue to make me sad. Okay, the length of the protocol string. Wait.
02:35:39.975 - 02:36:14.693, Speaker A: Peer connections are symmetrical. Messages sent in both directions look the same and data can flow in either direction. The pure wire protocol consists of a handshake followed by a never ending stream of length prefixed messages. The handshake starts with character 19 followed by the string bittorrent protocol. The leading character is a length prefix, but there in the hope that other new protocols may do the same and thus be trivially distinguishable from each other. All later integers sent in the protocol are encoded as 4 bytes big endian. So here they specify endianness.
02:36:14.693 - 02:36:43.635, Speaker A: Okay, great. After the fixed headers come eight reserved bytes, which are all zero in the current implementations. If you wish to extend the protocol using these bytes, please coordinate with Bram Cohen, okay. To make sure all extensions are done compatibly. Next comes 20 byte SHA1 hash of the B encoded form of the info value from the met info. Okay, this is the info hash, except it's raw instead of coded. Okay.
02:36:43.635 - 02:37:46.763, Speaker A: Both sides don't send the same value. This ever the connections. Okay, so this is fine. So the handshake, let's go back into here, we'll go to lib, we'll do a pub mod. Handshake or peer. Peer is good, like pier, peer, peer, pump, struct, handshake. Now this one I actually think is going to be kind of interesting.
02:37:46.763 - 02:38:54.555, Speaker A: So I think what I want to do here is actually a. Maybe I want to do something quite unsafe here, which is I want repr C. And then I'm going to say this is going to be the length, which is a U8. It's BitTorrent, which is a U819, it is a 8 reserved bytes 8. Then it is a SHA1 info hash info hash, which is U8 20 and then it's a peer ID which is a U8 also 20. Oh, what did I even do there? Okay, these are all pub. Nope, semicolon.
02:38:54.555 - 02:40:05.605, Speaker A: Okay, so now in my main. What's the. Okay, so there's a new handshake now and handshake supposed to take a torrent and a pier where the peer is peer IP and port. That's fine string. So if we get a handshake, we do this, we do that, we do peer is peer dot split ones on a colon. Actually we can just do. I Think socket adder v4 lets you parse peer Parse peer address.
02:40:05.605 - 02:41:02.853, Speaker A: Oh, there's a URL parse with params. Interesting. That's fine. I'll leave it the way it is now. Okay, so we parse out the peer and then we just do a straight TCP connection to it. Okay, so peer is Tokyo net TCP stream Connect to peer, connect to peer. And then we want to do peer send.
02:41:02.853 - 02:41:50.903, Speaker A: And this is where it all gets tricky. So handshake is going to be a handshake like so Rust analyzer really doesn't like when you make new modules in the middle of writing now it's gonna tell me where it is. I think lib oh, it's because I don't even import it. Peer handshake. There we go. The length is gonna be. Should always be 19.
02:41:50.903 - 02:43:30.961, Speaker A: So I guess actually to make this a little bit nicer for ourselves, we'll do impl handshake pub defend new and it's going to only take info hash, which is a U820 and peer ID which is U820 and return to self and the length is going to be 19. BitTorrent is going to be the string BitTorrent protocol. And to be clear, like the reason why they do this, right, is because the reason why this length here is hard coded but it's still present is so that you could have other strings of different lengths and you can still decode them like this. Now given that we know this is always 19, we could just do it that way for right now 08 we could write a full parser for this that like does a length encoded string decode. But because we know it's 19 and it's fixed length, how about we just do it nicely? So we do handshake new and what's the right. So the peer ID we can use this thing and the info hash we already have. The reason I make it mute here is because I actually want to use this to read the thing back out to.
02:43:30.961 - 02:44:40.451, Speaker A: You'll see in a second. So I want to write and I guess I got a use Tokyo IO async right next write all and I want to do a at handshake as U8 of length man size of handshake. Right handshake. Now this is almost certainly unsafe. It should be at least. All right, star of that something here. Star of that mem size of this is not a runtime argument.
02:44:40.451 - 02:45:45.379, Speaker A: This is a compile time argument. Non primitive cast. Yeah, so this is where it'll actually be this as const to this and then it'll be Unsafe. Well, all right, let's do this a little bit nicer. So handshake bytes is going to be this and then this is going to be unsafely turning that back into handshake bytes. Casting a reference to handshake as oh right, I need to do const handshake to cast it all the way. And it's upset about my socket adder.
02:45:45.379 - 02:46:26.735, Speaker A: Before I thought there was a parse. Is there really not? I think it's. Then I think it's peer dot parse. I'm pretty sure this supports like from string. Yeah, write all dot await. So what I'm doing here is I'm constructing one of these handshake things. And because the struct is repr C, that means that I can treat it as a byte array.
02:46:26.735 - 02:47:17.285, Speaker A: It's not really what it means directly, but indirectly it means I can treat it as a just series of bytes. Like I just take the bytes that are in the in memory representation of the struct and then I take that and just cast it into a byte array of the appropriate size. And that thing I can then cast back into a reference to a byte array instead of a raw pointer or reference. And that in turn I can then pass the right all which takes a slice. And now it's upset that this needs to be mute, which is fine. And I guess actually, I guess that's a good point. I need to find a valid peer.
02:47:17.285 - 02:48:06.505, Speaker A: So handshake to this thing. Oh, right. Okay, great. So I wrote it, but I didn't get anything back. So now here's what I want to do. I want to do peer read all handshake bytes is going to be a mutable reference to a U8 of this length. So I'm just turning handshake bytes into a mutable reference over the same thing.
02:48:06.505 - 02:49:06.299, Speaker A: I'm passing that into write all and then I'm going to pass it into read all as well. So I want, I guess read X as well. Async read x and then I want to read exact into handshake bytes awaits context read handshake. And so now I want to do some assertions on this thing. Like I want to assert that the, I guess I'll drop the, the handshake bytes thing is only valid within here. And now I want to check that the handshake which remember I passed in a mutable reference into this thing. So after the read, the contents of this struct should now be the bytes that we got from the other end of the other side's Handshake.
02:49:06.299 - 02:49:46.065, Speaker A: So I should now still have the case that the length here is 19. It should still be the case that BitTorrent reads whatever BitTorrent was supposed to read this thing. And it should also be the case that reserved is equal to 08. Right. Casting. Oh, right. This has to be mute now because I want immutable.
02:49:46.065 - 02:50:42.765, Speaker A: Can't compare U819 with U819. That seems like a lie. Oh, I forgot parentheses. Assertion failed. Oh, they do set reserved bytes. The reserved bytes are supposed to be all zero. Why are the reserved bytes not all zero? That's kind of interesting.
02:50:42.765 - 02:51:12.545, Speaker A: We certainly set them to all zero. I know extensions use them, but like the. This. Like what, what's it called? Codecrafters? Peer presumably doesn't, but that's fine. Okay, we can just ignore them, I suppose. And then what they want us to do is print out the peer ID hex encoded. Okay, so print line.
02:51:12.545 - 02:51:51.171, Speaker A: And I guess this actually means that we don't need the length in this particular exercise. Peer id. This would be hex and code handshake peer id. Now, the only reason why this casting here is actually. Okay, I should probably write a safety comment here. So handshake is a pod with repr C. POD here means plain old data, which means that any byte pattern is valid.
02:51:51.171 - 02:52:28.863, Speaker A: So you see, the types in here are all valid for any byte pattern. So there are no sequence of bits that would make any of these types have an invalid or value with undefined behavior. All values are valid. Okay, so basically, no matter what the other end sends us back, any bit string is a valid interpretation of the struct. Great. So if I now run this, I get back a peer id. I wonder if it's happy with that.
02:52:28.863 - 02:53:02.129, Speaker A: Like print peer ID push. Let's see. Yes. All right, so we correctly hand shook with a pier. Next stage, download a piece. Oh, this is hard. All the other ones have been easy.
02:53:02.129 - 02:53:17.643, Speaker A: Supposedly in this stage, you'll download one piece and save it to disk. In the next stage, we'll combine these pieces into a file. To download a piece, your program will need to send peer messages to a peer. The overall flow looks like this. Read the torn file to get the tracker URL. Perform the tracker. Get to get a list of peers.
02:53:17.643 - 02:53:35.595, Speaker A: Establish a TCP connection with a peer. Perform a handshake. Okay, we've done that. Exchange multiple peer messages to download the file. Okay. Peer messages consist of a message length prefix, message ID and a payload of variable size. Here are the peer messages you need exchange once the handshake is complete.
02:53:35.595 - 02:54:01.705, Speaker A: Wait for a bit field message from the peer indicating which pieces it has. The message ID for this message type is 5. You can read and ignore the payload for now. The tracker we use for this challenge ensures that all peers have all pieces available. Send an interested message. Wait until you receive an unchoke message. Break the piece into blocks of 16 kilobytes and send a request message for each block.
02:54:01.705 - 02:55:16.125, Speaker A: Interesting. Okay, so this doesn't seem too bad. This doesn't seem too bad at all. So there are a couple of ways we could do this. We could either actually write out a codec. Maybe that's actually what I want to do here, because presumably there's like a format for each of these messages here too, I guess Intra said has no payload, but we can actually use Tokyo Codec for this. Tokyo Codec basically lets you.
02:55:16.125 - 02:55:54.145, Speaker A: This creates deprecating token moved into Tokyo util codec. Okay, that's fine. Yeah. So this is a way to convert between an async read and async write to a stream and a sink. So sync is a thing where you can send values in, and a stream is a thing where you can take values out that are well typed. Whereas async read and async write only work on the sort of byte level. This does tend to make the protocol a little less efficient because you go via this sync thing, so you don't get to.
02:55:54.145 - 02:56:29.235, Speaker A: It makes memory management a little bit less nice, but at the same time it can be very, very convenient. You get a much nicer interface on top of the top of the protocol. So I think what we'll do here is. So let's go to peer. So there's going to be something like Serdi. If we can do this with serde, that'd be cool too. And I think we probably can.
02:56:29.235 - 02:57:19.807, Speaker A: So. So what I really want to express here, right, is something like enum message or peer message or whatever it is, but message because it's in the module peer. And then we have. What was the example? So bit field is one message type. And what I really would like to express is something like, I guess message type. And then we do something like wrapper U8 and bit field is message ID5. Right.
02:57:19.807 - 02:58:19.773, Speaker A: So we can encode all of these. Like interested is 2, unchoke is 1, request is 6, piece is 7, and who knows what the other things are? Okay, so we have 1, 2, 5, 6, 7. So those are the sort of message, I guess message tag is really the appropriate one. And then I want to say enumerated message. And then I suppose what I really want to say right, is that the where's the serde docs is bright. I'm apologizing a little bit too late. Field at no container attributes tag enum representations.
02:58:19.773 - 02:59:16.125, Speaker A: So for tags you can say this is like the name of the field that holds the tag for the. For which variant you have. Now this is a little weird in this protocol because the. There's not a named tag really. I think this is going to be a little bit weird and serdi land. So I guess then what we really have is a struct message which has a tag, which is a message tag and a payload which is really just a vec of, you know, U8s. Yeah, I think that's.
02:59:16.125 - 02:59:51.985, Speaker A: I think. I think what we'll do here is we'll do. We'll do a codec and just see how that turns out. So let's write a little encoder and decoder. So we'll grab both the encoder and decoder in the same thing here. This all goes at the top. Am I bringing in the same thing multiple times? No, I'm not.
02:59:51.985 - 03:00:21.745, Speaker A: Okay, so what I want is message decoder. So implement decoder for message decoder. And the thing message decoder is going to produce is a message. So it's going to be given a bunch of bytes. And we know that the length in this protocol is. It's always a length prefix of four bytes and a message ID of one byte. So it should be at least five.
03:00:21.745 - 03:00:57.665, Speaker A: And then I guess the length. Let's read the length marker first. Let's do five marker tag. So then we return oknone to say there's not enough data available for us to decode a full message. And then we read the length bytes out of the slice. Does it say whether they're big endian or little endian this time they. It did, right.
03:00:57.665 - 03:01:24.561, Speaker A: Pure messages. Oh, here are the other ones listed. Let's stick those in there while we're at it. Not. Not interested. Is three and have is four and cancel is eight. Yeah, I think.
03:01:24.561 - 03:02:06.495, Speaker A: I think it said or. All later integers sent in the protocol are encoded as 4 bytes big endian. Okay, great. So that means over here we could say from be bytes. So that's the length. I'm not too concerned about this one, but I guess we know that the payloads you can get. I guess peace is probably the thing that choke.
03:02:06.495 - 03:02:56.835, Speaker A: So pieces are. I think they said somewhere the pieces are not larger than. Yeah, 16 kilobytes usually 2 to the power of 14 bytes. So Max here is actually going to be 116 or I guess 14, but it's 114, but it's plus the headers. And I also don't know that we want to use the max here. So let's do 16. Great.
03:02:56.835 - 03:03:49.405, Speaker A: If the source length is. Does the length include the mandatory tag? Okay, Yep. Messages of length 0 are keep alives and ignored. Okay, so there are messages of length 0, which means the messages of length 0 have no tag, which means that the tag length is included in the length. Great. Here we can just keep the stuff from the example encoder. That's fine.
03:03:49.405 - 03:04:32.263, Speaker A: So this is if we. If the bytes. So we're giving a byte buffer here, right? If the byte buffer's length is shorter than how long the length field says the package should be, then we reserve some more space and then we say we don't have enough data yet. Otherwise that means we have enough data. We have every data that's supposed to be there according to the payload length of the in the header. And so therefore we extract out everything, follow the length. And I think actually what I want to do here is I want to grab the tags separately.
03:04:32.263 - 03:05:47.595, Speaker A: So I want tag is source 5 and then I want data is 5 to 5, 5 plus length minus 1, which is 4 plus length. But wait, that's not right. 4 plus length minus 1. The reason I want to do this is because the VEC that we extract here, otherwise that VEC would have a tag at the beginning, and then we would need to allocate a new VEC to all the actual data bytes, which we would then need to copy all the bytes into that bit, which just seems unnecessary. So we advance it by four. We don't want to convert it to a string. Instead, what we want is at this point an okay of a message with tag and the payload is data.
03:05:47.595 - 03:06:15.865, Speaker A: So this is just the framing protocol really expected option. All right, Sum. Because we successfully decoded the next thing. Oh, did I grab the wrong code for encoder? I think I did. Aha. Example encoder. That's what I wanted.
03:06:15.865 - 03:06:39.515, Speaker A: The payload data contains the tag. No, it does not contain the tag. We pull that out first. Oh, choke is equal to zero. Did I miss one of the. Oh, choke is equal to zero. How about that? Choke is equal to zero for.
03:06:39.515 - 03:07:26.925, Speaker A: So this is. Then down here, this is going to be message encoder. And really we can just call this whole thing Message framer. Right, because that. That really is what it Is it frames for both decoding and encoding. And this can encode anything that is of type message. So item here has to be message.
03:07:26.925 - 03:08:09.115, Speaker A: And really we could do even better here, actually, which is to say this is going to make our lives a little bit easier in the future. So we could have a trait here, which is a message that we implement for multiple different types. Let me backtrack a little bit. So the awkward part here is that the tag that we pull out is separate from the payload, which is a vacuate. So we're going to need to have some code somewhere that like matches on tag and depending on the tag deserializes the payload. In reality, which tag you get dictates what type payload should have. So it would be kind of nice if there was a way to express that.
03:08:09.115 - 03:09:02.693, Speaker A: But there's not an easy way to do this with SERDE, because it sort of expects fields to have names, which isn't really true here. I suppose we could make message generic over T and then if T be some kind of enum. Doesn't feel quite right. Yeah, I think we're just going to keep it this way and then we'll just. Because this is also a sort of test implementation, if you will. I think it's okay for us to end up with a. With that match.
03:09:02.693 - 03:09:36.245, Speaker A: It's okay. I won't do the trait thing here either. Don't send a message if it's longer than the other end will accept. That's fine. If item.loadload.len/1 because of the tag or did we count in the tag here when we check the length? Yeah, we do. So if this plus one is greater than the max, we're going to refuse to send it.
03:09:36.245 - 03:10:17.987, Speaker A: The length is going to be payload length plus as U32 plus 1 to big endian bytes 4. So that's the length plus 1. That's the tag plus the length of the payload. So we want to reserve space in the buffer for all the bytes we're trying to send. And then we extend it with the length slice. We also. Is there a push or put.
03:10:17.987 - 03:10:56.505, Speaker A: Put. Yeah, put u8 of item tag and then payload asbytes. So that's our encoder, that's our decoder. So now we have this framed thing where we should. Now we should now over in. No, over in main. Oh, what's the actual command they want us to add? So the command is download piece.
03:10:56.505 - 03:11:27.095, Speaker A: All right. Download piece supposed to be arg. Short output is a path buff. Torrent is a path buff. What's the zero here. Oh, this is. And then which piece? I guess.
03:11:27.095 - 03:12:05.545, Speaker A: Great. So if we get a. It's a little annoying to split these into so many sub parts, but it's okay. Download piece. We could also pretty easily start to refactor this so that these pieces of code are just like contained elsewhere. But I don't want to do that yet. Torrent output and piece.
03:12:05.545 - 03:12:36.045, Speaker A: So we still need to parse the torrent file. We still need to grab the info hash. We still need to do the handshake. We do the handshake. I suppose we don't actually know which peer to connect to. Should we just connect to a random peer? I guess we can connect to as many peers as we want. Really? Or we could connect to a random peer.
03:12:36.045 - 03:13:24.093, Speaker A: Yeah, all. All the peers have all the data. So I think instead what we'll do here is we'll just connect to a single peer for now. So we'll do t dot info dot Wait a second. No, we need to. Right? We need to string all this stuff together. Like it's awkward that we have to support all the previous test cases still because it.
03:13:24.093 - 03:13:46.589, Speaker A: Otherwise I would not have. I would just not keep this old code around and have to copy paste it. But fine. So we do this. Parse the torrent file, compute the info hash, send the tracker request. That gives us back the response. And then I want this to have a better name than response.
03:13:46.589 - 03:14:13.437, Speaker A: This is really tracker info. And then peer is going to be tracker info. Peers zero. We're just going to pick the first one. Then we connect to the peer, we do the handshake. Now we have the peer id. Okay.
03:14:13.437 - 03:14:51.025, Speaker A: And so now the next step arrives, which is when you have one of these codec things. What you can do. Where's the example of calling it here? So now I can do this. I can create a buff. I can take the peer connection read into the buff. Wait, no. Yeah, I don't want the equivalent to the following loop.
03:14:51.025 - 03:15:20.975, Speaker A: I want the actual framed where's framed here. This is what I want. So I want a. I don't want all this ugly code. Tokyo codec takes care of that for me. So Pier is now going to be Tokyo Util. Can I add to Tokyo utility? Any changes here will not reflect when codecrafters test your code.
03:15:20.975 - 03:15:53.229, Speaker A: Really? I don't get to use Tokyo codec here? I can add things. But it says changes here will not reflect when it tests your code. We added support last week. You can edit and save. All right, I will. I will trust this random Person in chat. So Tokyo codec.
03:15:53.229 - 03:16:37.385, Speaker A: No Tokyo util version 0.7. If they added this, it makes me very happy. Are there feature flags? Yeah, let's do full. That seems fine. All right, so Tokyo UTIL codec framed new and I want Then the peer and then I want handshake and message tag. Message message tag. Message and message framer.
03:16:37.385 - 03:17:11.423, Speaker A: And where's my message framer? Over here. There's no real need for it to have fields. Now I have a framed thing over the pier. And now I should be able to just use that as a stream and a sink. As you see, it implements. Now framed implements stream and sync. And this means that I should be able to.
03:17:11.423 - 03:17:51.855, Speaker A: Now go back to. Let's see, where's the. So the stream trait and the sync trait. It gets from Futures Sync and Futures Core. Okay, so let's pull those in here. So futures core 03 and futures sync 03. And now if I remember correctly, I should be able to just do while let.
03:17:51.855 - 03:19:23.635, Speaker A: I guess I know that I'm first supposed to wait for a message, so I'll do message is peer.next.await. let me see if this even does anything useful. Tokyo UTO Peer scope Bytes Byte bytes buff mute okay, this as U8 easy payload len right. This doesn't need to be 2 vec and this should now be. Right, this is where this gets awkward because any arbitrary byte is not valid as a message tag, but any message tag is valid as an arbitrary byte. So what we really need to do here is we need to match on this byte and we need to say that you is really what I want is like a message tag. Try from here.
03:19:23.635 - 03:20:26.675, Speaker A: But I don't think you automatically get one. So I'm actually going to do this mapping manually, which is there's a. There's a crate that helps with these that basically lets you derive the try from here. And having this mapping in two different places is obviously not ideal because it means that you might accidentally update one but not the other, and they get really hard to debug problems as a result. All right. And then if I add anything else, I guess I will return a one of these. Oops.
03:20:26.675 - 03:21:02.239, Speaker A: Unknown Message tag Message type tag. And somewhere here too. It's unhappy. It doesn't need us bytes because this is already a byte slice. My string framer. This should be message framer. Aha.
03:21:02.239 - 03:21:18.995, Speaker A: We're getting there. We're getting there. This needs to be pub. This needs to be pub. This needs to be pub. This needs to be pub. This needs to be Pub Main 196 next.
03:21:18.995 - 03:22:09.615, Speaker A: Right, so now I want futures util because I want use futures util stream x and sync ext. I'm pretty sure there's supposed to be a sync x2 but do stream next for now at least. Cannot borrow here as mutable. That's easy to do something about. Amazing. Okay, so now we get a message and we should be able to now do like an eprint line of message tag. So let's see what message tag we get.
03:22:09.615 - 03:22:44.875, Speaker A: Right. So this is going to be. It's an option so we're going to unwrap because we know we're supposed to receive a message. I guess. Yeah, we're going to do Expect peer always sends a first message. Always sends a bit fields and then context as in if we do get a message, it should be a valid one. Peer message was invalid.
03:22:44.875 - 03:23:14.733, Speaker A: Message tag cannot be formatted with a default formatter. That's easy to do. Message can derive debug and clone and message tag can even derive copy but not display. That's fine. See what we get. Ooh. Oh, right.
03:23:14.733 - 03:23:41.911, Speaker A: This is because I'm calling handshake. I need to call download piece. I don't know Foo. Actually do they give like a. Oh, they just use a temp file. Okay, so if I do this. Okay, they give you clap to work with, but then they use the wrong sub command shortening for that.
03:23:41.911 - 03:24:11.925, Speaker A: Clap uses this. I guess I need to do clap. Rename equals downloadpiece. Alright. Clap derived reference rename. I guess I will have to do rename all snake case. That's fine.
03:24:11.925 - 03:24:52.867, Speaker A: Peer message was invalid. Unknown message type 224. That does indeed seem like an invalid message, doesn't it? Eprint line. Let's see what length it claims this first message has. First message has length two. Interesting. That doesn't seem right at all.
03:24:52.867 - 03:25:31.635, Speaker A: Because they say wait for a bit field message from the peer. Like there's not supposed to be any 224. Wait for a bit field message from the peer indicating which piece it has. Message should be 5. You can read and ignore the payload for now. A length of two. You say.
03:25:31.635 - 03:26:19.729, Speaker A: Can they send you wrong messages until you get a bit filled message? I assume not. Like it'd be very weird if the peer just sends you random garbage messages. Right? At least like a length of two is not entirely unreasonable. It's tag plus one byte. But the 224 is a tag. Seems odd. And we know that we're parsing out the peer ID correctly because that's what the previous step like tests.
03:26:19.729 - 03:26:38.883, Speaker A: Right. So the next 20 bytes is the info hash. After the download hash comes the 20 byte peer ID. That's fine. We don't val. It was supposed to validate peer IDs, but I guess we don't do that. That's fine.
03:26:38.883 - 03:27:31.215, Speaker A: That's for handshake. Next comes an alternating stream of length prefixes and messages. Messages of length 0 are keep alives and are ignored. Keep alives. Right. This is actually something we should implement which is if this needs to be four because we have to allow for there to be heartbeats. And so now if length is equal to zero, this is a heartbeat message.
03:27:31.215 - 03:28:16.601, Speaker A: Discard it. Now there's an argument here about whether heartbeat messages should be discarded or whether we should emit them as like a null message. I think I actually want to just discard them here. Like realistically you might actually want to bubble these up so that the sort of caller can keep track of which peers are actually alive. But for our implementation it's going to be annoying to like we would have to make message here and I guess it could produce an another option wrapping here. Right. But I don't really want to do that.
03:28:16.601 - 03:29:02.101, Speaker A: We can't easily add anything to message tag because it's supposed to be valid for all U8s. Like I don't want to have like message tag. 255 mean heartbeat. And then some protocol decides to extend it and put semantic meaning to that value. So we don't really have a way to represent up the stack a heartbeat message. So I think I just want to discard it here. The way that we have to do that is we have to do here and then what I want to do.
03:29:02.101 - 03:30:02.675, Speaker A: So we need to advance the source pass the heartbeat. And now this is where it gets awkward because imagine that the source buffer here actually had two elements in it. So we're sort of supposed to either return none if there's not enough data or some if there is. So there's actually a case here where you would need to recurse or you would need to sort of loop like you would need to try again in cases another one. And I guess we can, we can just actually recurse here. This is an unlikely case to happen very often and then try again in case the buffer has more messages. So we do return self decode source.
03:30:02.675 - 03:31:26.905, Speaker A: So we advance path past the heartbeat and then we just try to decode the next message. And then we have to do if source length is less than 5 then not enough data to read the tag, in which case we got to return. Okay, none. Not. That's not going to be the cause of this, but it's just interesting. Okay, so I guess we got to print out these bytes then. So we get the length and then here I want to eprint line, I suppose a hex and code of 4 to 4, length 05.
03:31:26.905 - 03:32:06.345, Speaker A: E0 what? 05 should be parsed as 5. Why does it say 224? I think E0 is 224. I think we're. We just have enough by one here. We actually do. Because I'm completely stupid. This should be four.
03:32:06.345 - 03:32:20.119, Speaker A: The tag is number four. The data is five and onwards. Okay, good. Great. Fantastic. Great. So it was just.
03:32:20.119 - 03:32:36.607, Speaker A: I was just being stupid. Beautiful. Great. Okay, so we got a bit field. We printed out. It is indeed a bit field. Okay, well, we're not done yet.
03:32:36.607 - 03:32:52.255, Speaker A: This is just. We got a bit field. You can read and ignore the payload for now. The track we use for this challenge ensures all pieces, all peers of all pieces available. I see. So there's a. We assume that the.
03:32:52.255 - 03:33:50.035, Speaker A: So this is going to be, I suppose, Bitfield we assert equals bit field. Tag is message tag bit field bit field covers all pieces. Send an interested message. Okay. Payload is empty. Okay, so now we can do again because we have this codec, we can do peer.send and we can send a message which has a tag of message tag interested and a payload of nothing interested message.
03:33:50.035 - 03:34:32.445, Speaker A: And I think now it's going to yell at me because send isn't found. Oh, oh. This is another thing we should do over in peer is that message tag should implement partial just to make life a little easier for ourselves. Send doesn't work because futures util is supposed to be. Yeah, sync ext. That's what I thought, but why doesn't it let me do that? Unresolved found an item that was configured out. Thank you.
03:34:32.445 - 03:35:19.845, Speaker A: Compiler feature flag sync Right. Version is this features equals sync. Well, it didn't crash on us, so I guess that means it compiled. So this send is now going to send that message and then it will be encoded using the length encoding through the framer. And so now wait until you receive an unchoke message back. Okay, so now we should do. Let's unchoke.
03:35:19.845 - 03:35:53.085, Speaker A: Unchoke. And here we're sort of hard coding the protocol, right? Where we sort of assume that every time you send an interest that you get an unchoke. Really we should encode this as like a full state machine so that we could reuse it when we want to request different pieces from different peers. But this is just to see that the basic flow works. Right. We should get an unchoke payload should be empty. So this should be unchoke.
03:35:53.085 - 03:36:45.865, Speaker A: Unchoke payload is empty. Break the piece into blocks of 16 kilobytes and send a request message for each block. Okay, so now we need to do this splitting thing. Break the piece. Okay, so we need to pick a piece first. T.info.pieces. the number of bytes in each piece the file is split into.
03:36:45.865 - 03:37:10.475, Speaker A: I want to see what the spec says here. This is not Break the piece which. The piece. I guess the piece we're going to download. All current implementations use two to the power of 14 and close connections. Request an amount greater than that. Okay, that's fine.
03:37:10.475 - 03:37:46.905, Speaker A: Downloaders generally download pieces in random order, which is a reasonable good job of keeping them from having a strict subset or superset of the pieces of any of their peers. Okay, so I guess we're just going to pick a random piece, which means we might as well just pick piece zero. Does it? There's no R. There's nothing in the argument here that. Oh, no, it is. Okay, we do know what piece to pick. It gives us the argument.
03:37:46.905 - 03:38:43.815, Speaker A: Right. Okay, so the piece hash is going to be the pieces. I guess we should have an assert at the beginning here. That piece is less than t pieces len. Oops. So that here we can do piece and let piece size is going to be if piece is equal to t.info.pieces.len else.
03:38:43.815 - 03:39:23.287, Speaker A: In fact, do we even need to send the size? Yeah, this will be 2 to the power of 14 for all blocks except the last one. The last block will contain fewer. You'll need to calculate this using the piece length. Yeah, that's what I figured. Okay, so the full length we're going to download is the one we have up here because we still assume single file. So if it is the. If the piece is equal to the last piece, otherwise I guess we'll have a constant up here.
03:39:23.287 - 03:40:05.235, Speaker A: So this is something like piecemax is 2 to the power of like. So so then it's peacemax. Or if it is the last piece, then it will be length modulo peacemax. Is that right? Yeah. The remainder after dividing by piecemax. Okay. And that means we.
03:40:05.235 - 03:40:44.453, Speaker A: We should now have let mute request is going to be avec. In fact, we have a couple of options for this. I think what I actually want here is a. I want to do the struct thing again and I'LL I'll be nice and stick it over in peer. So we're going to pull the same thing that we did with handshake. Going to do a sort of cast here. So a request is going to be the index which is a zero based piece index.
03:40:44.453 - 03:41:32.135, Speaker A: And remember all of these are big Indian encoded 4 byte integers. And so what I want to do here is U8 of 4 and actually don't think I want these to be pub. I want these all to be set. So it's index, begin and length. And then I want an impl on request pub new and I'll take an index which will then be a U32, a begin which will be a U32 and a length U32. The last param was the piece. Last param was the piece.
03:41:32.135 - 03:42:23.485, Speaker A: Oh yeah, we haven't gotten to piece yet. Okay, so this will then construct a self and it can now basically enforce the fact that these will be big endian encoded. So we can do U32 or actually we can just do index 2be bytes. Let me do the same for begin and we can do the same for length. And similarly we can do index and have that return a U32 by doing self.index or U32 from B bytes. And so that way we sort of can't use this incorrectly from the outside.
03:42:23.485 - 03:43:12.625, Speaker A: So now I should be able to let request is should really just grab from here. I think is request new index is going to be the zero based piece index. Okay. Begin is going to be the 0 based byte offset within the piece. Oh I see. Because you're downloading multiple blocks of a piece. Okay, let's try to download just like the first block for now.
03:43:12.625 - 03:44:20.325, Speaker A: So this is really then not the number of pieces but the number of blocks. Okay, so we're gonna have to do piece hash. Let the number of blocks is going to be I guess the piece size is this the number of blocks is going to be the piece size divided by piece max. That's also not quite true. That'll be an off by one. Right, because we want if the piece. If the piece size perfectly divides piece max then I guess this is actually not piece max is block max.
03:44:20.325 - 03:44:59.225, Speaker A: The pieces is the hashes. But does it. I see. So this is actually. I see, I see, I see, I see. This is actually not quite right. This is going to be t.info.plngth.
03:44:59.225 - 03:46:00.825, Speaker A: so p length is the field that dictates. Yeah, the number the basically the size of each piece. And then the number of blocks is going to be the piece size divided by the block max. And will that work even if they don't divide evenly? I think this has to be. This is like an old trick of block max minus one divided by. So this basically ends up rounding up the one rounds up. And so now I guess we want for every.
03:46:00.825 - 03:47:05.725, Speaker A: For all the blocks we want to request and the piece we want to the block we want to request is I here or if you will, block. So we have the index is the piece index. The offset is going to be block times the block max. And the length is going to be the length of the block. And the length of the block is going to be if block block size is. If block is equal to M blocks minus 1 then it will be piece size modulo block max. Otherwise it will be block max.
03:47:05.725 - 03:47:44.765, Speaker A: And now that's going to be the length is going to be the block size. So that's the request we're going to want to send. Send a request message for each block. Now let's start by downloading these serially, I think and then we could do. Yeah, there's a. There's a nightly function for doing this. The equivalent of this.
03:47:44.765 - 03:48:37.355, Speaker A: I think we'll download the box serially first and then we can. We can download them in parallel later. So we send a request. So we do peer dot send message. And this is where it would actually be really cool to do. Zero copy doesn't really matter here. But like you know, from at request as const request as const U8 I actually want.
03:48:37.355 - 03:49:52.855, Speaker A: Where's my handshake trick? I kind of want to this the cast we did here too. So let's go back to the main handshake bits. Let's make this a little less bad as bytes mute and then I'll do the same for the other one. This will be so. And then we can do the same thing here for requests. Self self self bytes bytes bytes bytes. And in fact, now that it just talks about self it can be identical up here.
03:49:52.855 - 03:50:52.295, Speaker A: And so now we can do handshake bytes is handshake asbytes mute and get rid of the unsafety from up here. What? Oh, I misspelled mute. So now I should be able to do the same thing. I should be able to down here. Say let request bytes vec from request asbytes mute. This vec from is going to end up doing a mem copy which is a little sad, but we'll survive. Wait context send requests.
03:50:52.295 - 03:52:00.885, Speaker A: We can even do this to make it send request for block block and Then when we send that, we're supposed to get a peace message. Peace is supposed to be the message we get back. Piece tag is supposed to be a piece. Assert, not piece. Payload is empty. The payload of the piece message we get back is supposed to be whatever this thing is. Okay, so we'll go back here, we'll say so requests.
03:52:00.885 - 03:53:24.605, Speaker A: Wait, did I not do that right? I did not do that right? So this should be a piece, and a piece is supposed to be an index, a begin, and a block. And the block here is of unknown size. So be interesting to see whether we're allowed to do unsized last field. Almost certainly not. I can't construct a new one of these, but I can grab the index and the begin and the block. All right, so I should now be able to do like piece is piece dot payload. So what I want to do here, right, is the payload is the raw bytes and I want to cast it into this piece type.
03:53:24.605 - 03:54:38.133, Speaker A: So I want the reference to that to be this. This might not work the way I want it to. Const U8 as const piece. See how happy it is about that? Like, if I run this, does does it compile? Oh, I accidentally copied some code I didn't intend to somewhere I copied message tag up here. That was not on purpose. Peas payload ass pointer. So what I'm trying to do is I'm casting the payload to be a raw pointer to one of these structs, and then I'm turning that raw pointer into an actual reference to that type so that I can access its fields.
03:54:38.133 - 03:55:08.575, Speaker A: And the trick I'm trying to pull, and we'll see whether it works, is you're generally allowed when you have reproceed, for the last field to be unsized. So you notice here, this doesn't have a size, it's just a U8 slice, which normally is, you know, it's not sized, it's. It doesn't. You don't know how long this slices. And it's also not an array. Normally it's allowed for the last field to be that because you make the type sized by storing it in a reference and the reference knows its own. Basically becomes a fat pointer.
03:55:08.575 - 03:56:21.415, Speaker A: So it also stores its own length, which then stores the length of the last field. So at least in theory, this should be okay. Can I cast thin pointer to fat pointer? Yeah. How are you supposed to do this, though? Let me just get rid of some of the other compiler warnings here. And yes, I'm doing some type crimes here with overflows and such. But you know, such is life. I just want to get it to the point where only that part is the.
03:56:21.415 - 03:57:03.163, Speaker A: The one that makes us sad. 53 pieces len what info pieces.0.len this is all just because we have the. We have hashes which is this new type. That's why I need all these zeros. I could implement D ref for hashes to make that problem go away, but I don't want to. And the reason I say I don't want to is because it's not like it's a bunch of reorganization of the code that's not super interesting really.
03:57:03.163 - 03:57:26.935, Speaker A: So I want to focus on the relatively interesting parts. Okay, so here the. It's now giving me just that one piece where it's complaining. So it wants me. I'm wanting it to cast a thin pointer. So a pointer to a U8 to a fat pointer which is a piece. But I think think the way to do this is.
03:57:26.935 - 03:58:42.965, Speaker A: I think there is a way to do this cast the way that I want it to. Yeah, so. So fat pointers are for dynamic dispatch, it is the pointer to the V table and for, for a slice it is the length and for a reference to an unsized struct whose last field is uncertain sized, it is the length of the last field. And so that, that last part is the one I'm trying to take advantage of. And there is a way. Oh boy. Yeah, I mean I can create a raw slice, but that's not quite, quite what I want.
03:58:42.965 - 03:59:30.295, Speaker A: I actually think the way I have to do this is this. So now it's a slice as this as that. It's not telling me. I can't. That's not terrible. It compiles. It's complaining somewhere here peer at 182 slice index starts at 5 but ends at 4.
03:59:30.295 - 04:00:20.967, Speaker A: What? Oh, I see it only as a tag. And so this is lit data is if source len is more is more than 5 than this else like new. That worked. I got a piece. Well, I got a block of a piece. Interesting. Yeah.
04:00:20.967 - 04:01:28.469, Speaker A: So now I can start actually checking the integrity of the pieces by bringing all the blocks together. So I guess now I should be able to do let all blocks vecuate Let all blocks is vec with capacity P slen and then I should be able to do all blocks extend piece block. And at the end now where's my SHA1 code? Where's my SHA1 code? Oh, it's in tracker. No, it is in torrent. Oh ah. I have a thing in 10 minutes. So I need to.
04:01:28.469 - 04:02:13.852, Speaker A: I need to be fast here. Let's see. So if I update this with all blocks hash is this. And then I guess assert equals the hash with the piece hash. Right? In theory, if I haven't completely messed up, use SHA1 Digest. Definitely doing something wrong. 229 Opie size.
04:02:13.852 - 04:02:41.545, Speaker A: What? Why can't I. Oh, right. U8. 20. Can't compare U8 with U8. That's a lie. Can't borrow all blocks is mutable it seems.
04:02:41.545 - 04:03:26.879, Speaker A: Well, we get the wrong hash. That's awkward. Why do we get the wrong hash? I guess we should also like Oops. Assert. Eek. That all blocks len is actually equal to piecesize. Aha.
04:03:26.879 - 04:05:27.065, Speaker A: We don't get all the pieces. Well, we don't get all the blocks. In fact, we get one but not two piece size divided by block max. Like, am I only downloading one block? No, two piece block lens. Something's not right here. Because look, we're downloading first a block of that size and then a block of that size, which doesn't seem right given that the total size is this. What if I just make that three? Then now I have too much data.
04:05:27.065 - 04:06:14.725, Speaker A: I don't think this one's wrong. I mean, I could make it smaller, I suppose. No, there's something wrong in our. I think it's maybe in our modulo computation here. Oh, that's because this should be. No cert. Equal that with block size.
04:06:14.725 - 04:07:02.985, Speaker A: Yeah, we're not getting back blocks that are the same size as what we request. And that could be because this one's wrong. There's seven too short. In fact, seven is like. Is this just like stupid? Like it needs. I need to tell it to also include space for the headers. No.
04:07:02.985 - 04:07:39.599, Speaker A: Well, okay, here's the problem. I have another meeting in. Or I have an actual meeting in five minutes, which means I actually have to stop, which is very frustrating. So there might be a part two to this one, but there it sounds like it seems like we're very, very close and we have a one off here somewhere. I guess I could try one last thing, which is 1 to 15, and see what happens. Oh, or where's our encoder peer? Peer. Where's our const.
04:07:39.599 - 04:08:15.065, Speaker A: No encoder max. Where's our max? No, we have a bug here somewhere that's like off by seven. I'm a little unclear why, but I do really, really actually have to stop. And so I think this was pretty fun. I think this was a good way to guide you through something interesting. I think having the tests and having the steps was pretty useful in guiding you through the. The actual protocol.
04:08:15.065 - 04:08:44.485, Speaker A: Yeah, I think I would recommend this. You know, I've talked about this in the past that I think it's really, it's a really good way to learn to build real things. And this certainly forces you to write like real code to do interesting things. And afterwards you get to have like a real BitTorrent client, which I think is pretty cool. So I'll give this as a sort of endorsement, if you will. So what I'll do is I'll put the link in chat for where you can try this on your own. So it's.
04:08:44.485 - 04:09:04.561, Speaker A: Yeah, this is really fun. I might. I might just continue this on my own. So codecrafters gets a plus one for me. And again, I don't actually get paid to tell people to do this, but it's like this actually seems like a good idea. I like this way of teaching. And with that I'm going to stop.
04:09:04.561 - 04:09:12.755, Speaker A: Thank you all for watching. So much fun. And I hope you had as much fun as I did doing this. Thank you all for coming. I'll see you all later.
