00:00:01.240 - 00:00:45.109, Speaker A: Hello, folks. Welcome back. Or I should say welcome for the first time, because this is a new kind of stream. It's one that people have asked me for for a while. And it's basically taking a look at core crates in the Rust ecosystem and looking at sort of how they work, like what's happening under the surface here. Not necessarily, like, read through all the code, maybe that could be interesting too, and a sort of separate thing, but rather like, I want to understand this crate better. So we're not going to be like, after watching this, you're not going to immediately know how to like, make changes to serde's, like, proc macro code.
00:00:45.109 - 00:01:24.405, Speaker A: That's not the goal. The goal is for you to have a better understanding of what actually goes on when you're using serde, whether that is deriving, serialize and deserialize, or implementing your own. Implementing your own data formats. Like, basically, what's the mental model you should use? The basic constructs are in use by the library. Maybe some of the design decisions and subtleties that are useful to know. And SERDE seemed like a great place to start because so many people use survey every day and don't really know how it works, which is not to their detriment. Like there is a lot of.
00:01:24.405 - 00:02:12.527, Speaker A: In some sense it's a compliment to SERDE that you don't have to know exactly how it works in order to be able to use it, but it makes it very worthwhile to dig into a little bit. We are also in a position where, because of scheduling snafu, I actually have a hard stop for this in a little under two hours, which means that I'm going to try to be efficient, which is not always something I'm good at, but we'll see how well that goes. Um, speaking of scheduling, I've also started now committing to a regular streaming schedule, which people have asked for a while. Um, so every fourth Friday. So that is today and four Fridays from now and so on. Uh, I'm gonna do a stream at this time. Um, I'm gonna stick to the UTC time.
00:02:12.527 - 00:02:48.725, Speaker A: So if, if there are like daylight savings and stuff, then the UTC time is gonna be the correct one. The UTC time is gonna be 6:00pm um, and my plan is to stick to that for the foreseeable future. Maybe it ends up changing if I move to Europe and such, but. But at least this is the, the starting plan. I put this on Mastodon and co host as well, and there's a link to a calendar that you can actually like subscribe to so that you can see when streams come up and add it to your calendar. So at least that's the start. And without further ado, I think we should just dive into serde.
00:02:48.725 - 00:03:47.297, Speaker A: First of all, how do you pronounce serdi? Honestly, I'm not entirely sure. I don't know whether it says anywhere. I feel like I've seen, and I know this is not the most important thing I'm fully aware, but I feel like it says somewhere, maybe I forget, but. So SERDE is a, is a library that's short for serialization and deserialization. So SER D, but I've also heard it described as CERDA or serd, which is also weird. I think it's just serde, but you know, who knows at this point? And the goal of SERDE is not actually to provide any particular serialization or deserialization format. Instead its goal is to provide the infrastructure for doing serialization and deserialization, specifically of RUST data structures.
00:03:47.297 - 00:04:42.955, Speaker A: And it tries to do so in a way where in the general case it gives you fairly high efficiency and performance. It doesn't always give you like a zero cost abstraction between the data that you have and the data format that you're writing to. But the general goal is for it to be a relatively sort of thin glue layer that hopefully mostly gets optimized out. And SERDE has a bunch of concepts that are really useful to sort of get into your head when you start working with or try going beyond just the very basic like derive serde. And the start for that is the SERDE data model. And there's a page on this, on the SERDE docs that's pretty good. But basically, and in fact maybe I should draw this I haven't drawn for a while seems maybe appropriate.
00:04:42.955 - 00:05:40.325, Speaker A: Let's go with a nice orange serialization color here. So SERDE has a data model that consists of sort of three parts. So we're just going to make them arbitrary shapes. So one is the data format, one is the, let's call it data type and one is the SERDE data model. And in terms of the actual type in serde, the data type is the rust data type that's in use. So in general that's going to be blue is types, right? We all agree the blues, blue things are types. So this is where you have serialize and deserialize.
00:05:40.325 - 00:06:29.605, Speaker A: And I apologize for my handwriting, over here is where you have serializer, notice the ER&D serializer. And the goal of the SERDE data model is basically to provide the mapping between these. So in serializer and deserializer, the only thing that you know about, the only thing that those traits provide you information about is stuff from the data model. So essentially the data model provides a sort of layer of. Not just a layer of abstraction, but encapsulation, so to speak. So that. So that there's a separation of concerns between the data format and the data type.
00:06:29.605 - 00:07:13.467, Speaker A: Each data format only needs to sort of know about the sort data model and each data type also only needs to know about the SERDE data model. And then the sort of little bit in between here takes care of mapping one to the other. We'll talk more about the concrete specifics here. You might also have heard of the visitor type. We'll look at that a little bit as well. And the visitor type lives over here. And it's also a thing that's visitor is a little weird because it's sort of a little bit a part of here in that the serializer and deserializers will make use of visitor, but visitor is implemented by the data type.
00:07:13.467 - 00:07:58.697, Speaker A: It's sort of owned by the data type side of things. And it's essentially part of the interface which serialize and deserialize this too. But that is sort of the abstraction boundary that you get here. And so you might wonder, well, what is the SERDE data model? And so that's what we're going to look at next. So the SERDE data model is mostly a set of types and this is a set of types that they're not entirely arbitrarily chosen, but they're chosen to represent the kinds of primitives that we usually have for data. Right. So these are the numeric types, the string type, byte arrays, options, units structs and various kinds of structs.
00:07:58.697 - 00:08:46.741, Speaker A: So unit structs, new type structs, and just regular data structs and enums and their constituent components. So this is things like unit variant, new type variants and just straight up enum variants sequences which can be whether there's a vector or dequeue, it doesn't really matter to serde. It's just a sequence of elements that has some order and tuples and maps. So these are all the things that are in the SERDE data model. And the goal for any given data type is to. For serialize is to take the data that's stored in the rust data type and turn it into one of these. Right.
00:08:46.741 - 00:10:03.327, Speaker A: So if you internally have, you know, a field that is a, I don't know, non0usize then you're going to emit that as a U64 into the Serde data model. So when the SERDE data model asks you how do you get serialized? You answer with using u64 in the data model. And for deserialize is sort of the other way, where you say my type can be constructed from the following types in the data model. So if your type contains again, let's say a non0u64, you might say I can be created from the following unsigned integer types from the SERDE data model. And then there are other variants of this, right? So you could say, for example, structs, you could possibly construct from anything that is a map, as long as the keys of the map map to the names of the fields in the struct. So you can start to get a sort of sense for how that mapping works on the data type to data model model side, on the data format side. Your goal with the, with the data model is to figure out how the bytes of the serialized format map into the data model.
00:10:03.327 - 00:11:36.405, Speaker A: So for serializer, the goal is to take types from the data model and turn them into the bytes of the serialized protocol, right? So you're going to be told, you know, here is a sequence, and then you're going to be told about the elements of the sequence one after the other. And the goal of the serializer implementation is to turn those into whatever the bytes for a sequence with things of that particular type are, or how those are represented in the data format. And for deserializer, so going the other way, your goal is to take the stuff that you're getting out of the the underlying data format and turn them into the SERDE data model. And when I say turn it into, that's not actually, it's not like you're turning it into like a value in memory. But instead the way that the mapping here works is that when the data format is, or the deserializer in particular encounters something of a given type, it calls a method through the SERDE data model, such as, let's say, deserialize. Technically it's visit. But just for clarity here, deserialized string like I found a string, I found a string as described in the SERDE data model and that ultimately ends up calling the D serialized string on the D serialize of the data type.
00:11:36.405 - 00:12:50.335, Speaker A: But these two are disconnected. So you can take any data format and any data type and sort of say connect these two, right? Like use this data format to turn something into this type. And that's one of the ways in which sort of becomes really, really versatile is that you can mix and match these. So this is why you can put, you know, derive deserialize on one of your rust types and then you can deserialize them from both TOML and JSON is because when you're using the JSON deserializer, what you do is you pass in your type and when the deserializer run, it's going to call the deserialized methods on your derived deserialized type. Or you can pass in the, you can do the TOML deserializer again, pass in your type. And when it calls the sort of deserialize or the visit methods, those will end up going to your data type again. And because it all goes through the SERDE data model, you know, if there's a string in the TOML or a string in the JSON, they will both end up calling the same method through the data model, which ends up calling your method on the data type.
00:12:50.335 - 00:14:04.255, Speaker A: Okay, does that make sense so far? I'm just in terms of the sort of mental model we're going to dig into what the code actually looks like as well. But just before we go forward, I think it's useful to ensure that this sort of relative separation makes sense. Does this kind of model have performance implications? Might have a straight JSON parser before faster or fewer allocations than serde. It's possible. Like SERDE doesn't claim to be like a zero cost abstraction. That said, the deserializers, they don't, they don't actually generally do allocation unless it's specifically necessary. Like if you visit a, if you give the JSON deserializer like a string, like a STR reference, then when the deserializer walks that STR and gets and sort of encounters something that it discovers is a string in JSON, it can actually just give a slice of that into the data model.
00:14:04.255 - 00:14:45.965, Speaker A: To say I encountered a string, here's a reference to it. So it doesn't actually need to do any allocation, it only does the mapping to the data model. That's not always possible though, right? Imagine the best example for this is probably when you have escape values in the string. So imagine someone using like backslash something in a JSON string. Then now you can't actually just give a reference to that string in through the data model because you actually need to decode the escapes. And so that means you have to allocate a new string, you don't really have an option and then you pass that own string in. But Even so, in both of these cases, this is the same kind of thing that you would need to do in a manual implementation.
00:14:45.965 - 00:16:01.645, Speaker A: And so it's really just generics going all the way through. Okay, so I think we have a rough sense of what's going on here. So what we're actually going to do now is dive in the complete deep end on the other side and do, let's see, cargo New lib. No, fine, let's do a bin. What are we going to call this? We're going to call it 30 what now? Okay, and we're going to go in here and we're going to say 30 equals 1. And we're actually going to pull in the derived feature so that we can derive deserialize. And then we're going to go to source main, and then we're going to use this, and then we're going to derive, serialize, deserialize on what type struct, foo, which has an A, which is a U64 and a B, which is a string.
00:16:01.645 - 00:16:29.351, Speaker A: And then we're going to go ahead and just do cargo. Expand, expand. It's going to expand all the macros. Let's see what it generates. Okay, so obviously, you know, this is a proc macro, so it generates a lot of stuff. Let's see if I can just put that in a expanded dot rs. Okay, so there's a lot of stuff here.
00:16:29.351 - 00:17:07.017, Speaker A: You see, there's like a bunch of macro tricks that you have to play. Like this anonymous const here, which is used to basically generate a new scope where we know that we can only have impulse, where we know that we can control the namespace a little bit better. So this is not generally stuff that you need to think about in terms of writing your own SERDE stuff. This is just like macro magic. These lines here, same with the automatically derived attribute here, has to do with whether it's considered like unused code for the purposes of warnings and stuff. So you can ignore that as well. Where it gets interesting is down here.
00:17:07.017 - 00:17:47.621, Speaker A: Okay, so we have implement serialize for foo. And so let's go before we move on to SERDE serialize. So the serialized trait, again, this is on the data type side of things, not the data format. The serialized trait just says, how do you serialize yourself? That's all it does. And it's given access to a serializer, but it's generic over that serializer. And the job of serialize, as we talked about before, is to turn self into the data model of serde. And the Way you do that is by calling the appropriate method on serializer.
00:17:47.621 - 00:18:21.445, Speaker A: So serializer here has a bunch of methods that correspond to the different components of the data model. So the goal for your implementation of serialize is to call the appropriate serialize method on the serializer that you're passed. So remember, serializer here could be, for example, adjacent serializer. It could be a TOML serializer. You don't know. All you know is that that encapsulation boundary, all you get to know is the data model. And so you know you might, if you contain a bool, you would serialize a bool.
00:18:21.445 - 00:19:03.707, Speaker A: If you're a struct, realistically, what you're going to do is probably call the serialize struct method, which in order to call you have to pass in the name of the struct. For some protocols, you actually want to encode the names of the types as well. You're told the length, so as in the number of fields in the struct. And interestingly, when you call serialize struct, you don't pass in anything else. You get back one of these serialize struct things. Things. And this is a common pattern in 32 that for more complex structures you have sort of sub serializers for things like sequences and tuples and enums and maps and structs.
00:19:03.707 - 00:20:02.305, Speaker A: So here you see there's an associated type on serializer, so we're still on serializer here. There are associated types for each of these. And in particular there's a, there's a associated type for serialize struct, which implements the serialize struct trait, which has the methods serialize field and end. It also has skip field. This is so that you can have a type where you explicitly communicate that you're skipping a field during serialization, which sometimes matters, right? So there are some protocols where you're expected to produce a complete description of the value. And so if you choose not to include a field, you have to say so in the serialized format. And so the idea here is that if you want to serialize the structure, if you in you're implementing serialize, right? And you're serializing a struct, you're going to call the serialize struct method on the serializer, you're given in giving the name of the struct and the number of fields.
00:20:02.305 - 00:20:44.785, Speaker A: And in the thing you get back, you're going to call serialize field repeatedly for each field you want to serialize and then call end when you have finished serializing the structure. Okay, so if we go back to the code, the generated code, hopefully that's what we should see. Right, so you see here all of these like, underscores and stuff is again just macro bits that we don't need to worry too much about the complexities of it. You see that there's a return type which is a result that can either be, you know, okay or error. This is also dictated by the serializer. So for some serializers, they'll actually return the serialized data format in. Usually though, like if you create a, you know, adjacent serializer or something, it actually just wraps an IO writer.
00:20:44.785 - 00:21:17.575, Speaker A: So the okay value here is empty. It actually gets written to a buffer somewhere or just directly to disk. This again, to avoid overhead of first having to serialize like into a byte string or something and then putting it to disk. And the error is both errors in the serializer, but can also be errors in the serializer serialization into the data model. Well, we'll see that as we go a little bit further down. Okay, so you see here we create, we call serialize struct. So that's what we expected.
00:21:17.575 - 00:21:47.085, Speaker A: We pass in foo, which is the name of the struct. So the macro, the proc macro here, because we put derive serialize on foo, it knows that the name of the struct is foo. Passes that in here. This again is some macro magic. And what this ultimately ends up giving us is the number two, which is indeed the number of fields in foo, why it's written out this way. Macros are complicated. I'm sure there's a good reason, mostly irrelevant to what we're talking about now.
00:21:47.085 - 00:22:34.125, Speaker A: And you see that if serialized struct completes successfully, then we assign the value that we get back, which is this sort of constructor, if you will, that we're going to call serialize field on into SERD state. And if it errors, we return. So this is basically the question mark operator is what's going on here. And I'm guessing it generates it this way so that it works with older versions of Rust as well. That would be my guess here. Okay, and then you see, then it calls serialize field. It serializes the field A by calling serialize field, giving a as the key, the field name, and giving a reference to the value of A as the second argument.
00:22:34.125 - 00:23:04.591, Speaker A: So if we go back here and look at serialized field, you see that the. The second argument to serialize field is a reference to the value of the field, which is also expected to implement serialize. Right? So this is how it sort of nests. So when you're serializing a struct, what you're actually doing is you are serializing each field. You're first telling the serializer, here's comes a struct. It has this name and this number, number of fields. And then for each field you tell the serializer this field has this value.
00:23:04.591 - 00:24:17.595, Speaker A: And when you give the value, you give a thing that itself implements serialize. So then we're going to call the serialized methods on each of those values and give those into the to the data format as well. Right. They also need to map into the data model. And so, you know, if that succeeds and we continue, otherwise we return again, this is just question mark and we do the same thing for B. And then we call end and that's the end of serialize. So if we were to write this ourselves, right? So instead of deriving serialize, we could impulse serialize for foo and all we would do is, you know, struct is serializer dot serialize struct foo and two? S dot serialize field a self A B self B and then S end.
00:24:17.595 - 00:24:48.737, Speaker A: And this is complaining because we need to import the serialized struct trait and this needs to be mute. That's fine. So now we've replicated the same thing that serialize did, that this is all the derived serialize actually does. Now that's not quite fair to say. Right? So there are other things that serialize does. Namely it's configurable. So if you do thing, if you do serialize, right.
00:24:48.737 - 00:25:24.419, Speaker A: You can do things like serdeskip. And so if we now go ahead and comment this out, let's look at how that changes what gets generated. So cargo expand vim expanded. If we go now back up to serialize. So you see that now in the generated code, serialize, struct serialize field A. But there's no code for the field, the field that we ended up skipping. I'm curious why this doesn't call skip.
00:25:24.419 - 00:25:42.859, Speaker A: So remember in the data model there's a skip field. Not sure why it doesn't call that. That seems odd. It's not using question mark because question mark produces slower code and larger binary size due the implicit into conversion being done. Oh, I see. That's fair. Yeah.
00:25:42.859 - 00:26:35.761, Speaker A: So here, remember the question mark operator in Rust actually is not quite equivalent to this code. It is slightly different. So if this were written with question mark, what it would actually generate is this. So it has a call to into to allow conversion of error Types, and this is one of the ways in which question mark makes it nicer to work with error types is that the error type doesn't need to exactly match, it just needs to be compatible with the thing you return. But this, of course, is extra machinery, extra stuff that the compiler has to run on. And in this case it's entirely unnecessary because we know that the error type is directly translatable here, and so therefore we do it with this. Okay, so that's an example of the kind of attribute that you can get.
00:26:35.761 - 00:27:35.705, Speaker A: And there are other ones, right? So if we did here, let's say rename equals X. So now this one, in fact, then of course we're not going to skip it. If we now look at what it generates, you see that instead of saying that this field was called B, it says that the field is called X. So in general, all of these additional attributes that you can put on serialization, most of them are just relatively simple modifications to the serialization code that gets generated. There are some exceptions, right? So you can do things like completely switch what serializer is being used for this type. But at the same time, even that's not that complicated. It just means that in the generated code, instead of calling, you know, the, the standard serialized implementation for B, so instead of just using this, you're going to construct, you're going to call some other type here to do the serialization itself.
00:27:35.705 - 00:28:20.295, Speaker A: We're not going to get too much into that, but just so you're aware, and it's sometimes fun to. You can read the serted derived code and it's sometimes a little hard to parse because it needs to do a lot of like, token manipulation. But with Cargo Expand, it's usually pretty easy to figure out, you know, what actually happened under the, under the hood here. Okay, so that's serialized. We're going to talk a little bit more about serialize later, but for now let's move over to deserialize and see what that looks like. So I've removed the rename and we go back here, and we go back to deserialize. You see, for deserialize 2, it generates this sort of macro wrapping stuff that we can mostly ignore.
00:28:20.295 - 00:29:36.339, Speaker A: And for the implementation of deserialize for Foo here, you see the structure is similar, right? So there's a deserialized method takes a deserializer that's generic over the deserializer trait. Now, there are a couple of things that are going to be different here. And the first one is this de generic lifetime Parameter this one is more or less a reference to the input that the deserializer is working over. So imagine something like serdejson. If you call serdejson from string or from bytes, so anything where you actually have a, it has a reference to its input, then in order, basically for efficiency, we want to be able to return references into that input, right? So imagine there's some like huge string in there, for example, that we really just want to return a reference to directly, rather than having to like copy it out into an own string. Then what is the lifetime of that string reference? That's what DE is. It is a reference into the origin data for the deserializer, if available.
00:29:36.339 - 00:30:16.673, Speaker A: Some deserializers aren't going to have this, right? So if you're reading from disk, for example, then this lifetime is static and you're never going to produce any owned references, any borrowed references. You're only going to return own data. So if you read, you know, from disk and you're deserializing JSON and the thing that you get out is actually a string reference, what you're going to do is construct a string. Because by the time you read more from the file, a reference into the buffer that you read from disk is no longer going to be valid. So you're only going to generate owned values. Okay, so that's where the dereference comes from. We'll see this come up later as well.
00:30:16.673 - 00:31:21.205, Speaker A: And then the implementation here, you see, we start talking about this visitor thing. And visitor is what's the best way to describe this? The visitor pattern is Cerny's way of making it easy to deserialize sort of nested structures. So in some sense you can think of this as sort of the inverse of what we're doing with serialization, where things like serialized struct actually return a constructor that you then calls, you know, serialized field on and whatever. With visitors, that's sort of the inverse pattern where it's not quite as easy to do that with associated types. With visitors, you can do it pretty easily. So let's, let's see what that actually looks like. So in this case, SERDE generates this private, private type, in this case an enumerated, that is a field visitor.
00:31:21.205 - 00:31:52.853, Speaker A: That's what it's called it here, which is going to visit. It's going to be the thing that visits each of the fields of the struct, and it implements visitor for it. So let's go look at visitor. So if we go back to SERDE here So we have deserialize. So it's given a deserializer, that's fine. And deserializer has all of these. No, that's another one.
00:31:52.853 - 00:32:37.085, Speaker A: I want visitor here. Yeah, so the bits you want here is that when you call D serialize, ultimately what you're given is a deserializer. And what you have to tell the deserializer is what do you want it to deserialize? What do you expect it to deserialize? And you can say deserialize any which is, you know, as the, as the thing that's being deserialized into. You can say I don't know what type this is going to be. You just, you need to know ahead of time. This only works for self describing formats. So you know formats where the underlying data type actually encodes things like this is a map, this is the start of end of a field, that kind of stuff.
00:32:37.085 - 00:33:11.815, Speaker A: So JSON for example, has a deserialize any. There are some especially compact binary formats where if you told it, just give me whatever comes next, right? If it's a string, give me a string. If it's a number, give me a number. It's just a sequence of bytes with no structured information. And so the deserializer would go, I don't know what comes next, you have to tell me. And so there's this sort of separation here between self describing formats and non self describing formats. And in general all of these deserialized bool deserialized i8 et cetera.
00:33:11.815 - 00:34:02.475, Speaker A: The deserialize any is going to sort of forward into these methods if it can detect the type and for data structures where it cannot detect the type, it's going to just refuse an error out saying you told me to guess the type and I cannot guess the type. So in general when you implement deserialize, what you want to do is give the deserializer information about what you're expecting to come next. So if you know that the next field you're going to deserialize is, let's say a Usize, then you should call deserialize. Usize is a bad example here. U64. So if you know the next field is going to be U64, you should tell the deserializer. The next thing I want from you is a U64 because that way if the data format is not self describing, it still can actually decode and give you what you needed.
00:34:02.475 - 00:35:19.459, Speaker A: Now what you'll see here is that when you call any of these deserialize methods you give in a visitor and this is where the mapping is a little odd, right? So you tell the deserializer what I want now or what is coming next in the data format is a U16. Or to take a slightly more complex example, the next thing that's going to come is a sequence and then you give it a visitor, and the visitor is what the deserializer is going to call methods on when it does in fact find that sequence. So you tell it when you hit a like, the next thing you find is a sequence. And when you find that sequence, use this visitor to explore that sequence. So you see all of these consume self so that you end up basically passing control back and forth between the implementation of deserialize into the deserializer which consumes self. So this is now where execution is happening. It is going to then find a sequence and then call a method on the visitor, and the visitor is then going to call deserializer again.
00:35:19.459 - 00:36:22.397, Speaker A: And then we go back and forth. Well, we'll see how that works when we start looking at the code here as a visitor has visit bool visit i8. So these are roughly equivalent to deserialized from the data model, right? So this is saying so in the deserializer, when it finds the thing you asked it for, then it will call the appropriate visit method on the visitor that it was passed in. Um, so again, if you use, for example, tell the data data model, let's say DC or lice bytes, then the data, when you say the data format is then going to presumably call visit bytes in response. Okay, so let's get with that in mind. Let's see what it actually generated for us here. So the field visitor here is going to be a visitor for the fields of the struct, right? So when you encode a struct, usually you want to emit both the fields and the values.
00:36:22.397 - 00:37:19.513, Speaker A: Think of something like JSON, right? If we were to see if you, if you had this struct, this foo struct that we have serializes JSON, the way that would look like in the JSON is like, you know, string a colon and some number string b colon and some string. And so the field visitor is going to be the visitor for the keys of that of the underlying data format. And then presumably there's going to be a value visitor further down. You see that the value that the field visitor produces is field, which in this case is an enum saying field zero or field one which corresponds to A and B. Now ignore here is interesting, which is this comes from the fact that SERDE by default. Let me dig up the docs here to make sure I'm not lying to you. SERDE by default will allow unknown fields.
00:37:19.513 - 00:38:43.015, Speaker A: And there are a couple of reasons for this. The primary one is backwards compatibility, where if someone imagine that you're like deserializing JSON or something, and if the underlying JSON files that you're parsing actually changes, like someone adds a field to it, your code shouldn't necessarily break, right? If, if there's just more data in the JSON, then this is a great way to just be able to subset that information or just allow the underlying JSON to evolve over time while you are still able to run, because all the stuff you cared about is still in there. And so you can set SERDE deny unknown fields to say every field must be in my data type. If you ever encounter a field in the data format that I don't have in my data type, that should error rather than just be ignored. And so this is where that ignore comes from, which is if we encounter a field while deserializing that isn't one of the ones we know about, then it's going to be mapped to this ignore field and then get ignored. If you pass denyunknownfields, this enum variant wouldn't be there and we would end up erroring instead if we were to encounter a field that we couldn't map. So onvisitor, there's this expecting method which is primarily used for error message generation.
00:38:43.015 - 00:39:45.985, Speaker A: So this is if you've ever done SERDE deserialization, and you see a message like expected something, did not get that or got something else. Usually you don't necessarily get the got something else, you just get, you know, unknown or unexpected input expected X that expecting comes from here. So this would be something like, imagine that you are visiting a JSON structure, a dictionary or a map, if you will. In JSON, every field, every key has to be a string. But if the data format is in the process of visiting a dictionary and it's encountering a key, so you're in sort of this field mode, and then it finds something that isn't a string, then it's going to call expecting. And the way this works in practice is I think that can be numbers too. I think it's only strings and numbers, but I could be lying.
00:39:45.985 - 00:40:46.825, Speaker A: And the way this works is actually pretty simple in sort of rust type terms, which is that there's a default implementation for all of these visit methods. So if we look at visitbool, for example, the default implementation just calls well, error invalid type. Let's see if we can find the. Oh, these are not. These aren't great examples because these actually have specialized implementations. But I thought there was a expecting call to expecting in here, right? So here for visit Bill, for example, it says error invalid type and it passes in, you know, unexpected bool and the unexpected type when it gets debug printed. I guess I can go back to using this search.
00:40:46.825 - 00:41:32.881, Speaker A: The expected type when it's debug printed will use the expecting method of the visitor to say what was expected instead of what you actually got. So if the. So the default implementation for the various visit methods is to emit a message saying, I got this, I expected this. And for the I expected this part, it's going to print what the expecting method of visitor is. So in this case, the expecting for field visitor is going to be field identifier. Right? So we're expecting a field or something that is a struct field. And then we're going to override the implementation of visit U64 because U64 is how we're going to.
00:41:32.881 - 00:42:11.955, Speaker A: Okay, so this here is. We're going to allow two ways to encode the struct. We're going to allow people to encode it as the 0th field on the first field. So if, if you are visiting a dictionary, Serde basically allows you to say you can either produce the fields in order where the keys is the index of the field. So in this case you can see, you know, field zero. If the value of the key is zero, then it gets mapped to field zero, which we know is A. If it's one, it gets mapped to field one.
00:42:11.955 - 00:42:44.415, Speaker A: And it also has a visit str, which is A or B which gets mapped to 0 and 1. It also allows visiting bytes. So if, if it's not a string but it happens to be bytes, this could be something like, you know, the underlying data format doesn't support strings. It only knows about byte slices. But that's okay. If there's a byte slice that represents the string A, that's just as, just as good. And so in this case, you know, numbers are OK as long as they're the field indices and strings and bytes are OK if they map to the names of the field.
00:42:44.415 - 00:43:23.245, Speaker A: So that's the visitor implementation for this field visitor. We'll see how that gets used a little bit further down. And so now we can implement deserialize for field. So again, this is, this is just a Field visitor. And so we want to implement deserialize for field because ultimately what we're going to do is say we want to deserialize a map and the visitor is going to be a visitor that alternates between getting fields and getting values. And the fields therefore need to implement deserialize and the values need to implement deserialize. So now what we're doing is we're implementing deserialize for the field part of that deserialization process.
00:43:23.245 - 00:43:56.517, Speaker A: So down here we implement deserialize for field and that's going to deserialize Deserialize identifier. That's interesting. I didn't know it had a D serial deserialize identifier. Huh, I'm surprised. It's special case. It might just be to give better error messages. Although maybe there are some data formats where identifiers are kept as a are encoded differently.
00:43:56.517 - 00:44:47.141, Speaker A: That could totally be. Okay, so deserialized identifier, it's not super important which method it called here, but it's basically telling the deserializer. Okay, the next thing you should expect now is something that's an identifier and you should visit it using the field visitor, which is the thing that we just constructed further above. So that's all you need for the deserialize here is to use the visitor we just had and then call the appropriate deserialize method on the deserializer. And here, you know, you could have called deserializer any deserialize any. But if you did, the data format underneath has to be self describing. But by calling deserialized identifier, even data formats that aren't self describing will roughly know what thing they're expected to produce.
00:44:47.141 - 00:45:22.551, Speaker A: And so they might actually now succeed where previously they wouldn't. Not okay, and then we're going to have a visitor for all of foo. So ultimately what we're trying to produce with this deserialized implementation is we're trying to deserialize into a foo. So we need a visitor that produces a foo. And that's what this thing is. So here we implement visitor for this anonymous visitor types and it produces here a value of type foo. So this is the visitor that's actually going to produce what we want.
00:45:22.551 - 00:46:21.395, Speaker A: The expecting message here is we expect to destruct foo. Okay, great. And we're going to implement here visit seek and visit map and those are the only two things we're going to implement. So again, this comes back to we want to be helpful in that the data format is allowed to serialize structs as the fields serialized in order. It doesn't need to capture the fields. Right. There are some data formats where, because the fields are static, like if you actually have a highly compressed and optimized storage format that's standardized, it has a schema, then you don't need to put the fields, the string contents of the fields, into the data format.
00:46:21.395 - 00:46:43.823, Speaker A: The order of the values is all you need. So that's why we want to be able to deserialize from just a sequence that produces the fields in order. Yeah. So grpc, for example. So visit seek here is going to be. So seek access here is access to something that is a sequence. So this is a.
00:46:43.823 - 00:47:30.767, Speaker A: This is one of the associated types on D serializers that allow them to basically have a. You might have. If you have a JSON deserializer, it has a different impulse that just deals with stuff that has to do with arrays that implements a seek access trait and that produces things like nextelement. So here for visit seek, we're first going to try to access the next element of the sequence that we're currently in that we're visiting, and we're going to try to deserialize that as a U64, which is the type of the first field. If we get it, great, that's the value of field zero. If we don't, it's an error. Yeah.
00:47:30.767 - 00:48:13.675, Speaker A: And we can produce error messages here saying if what we got is actually if what we got is the end of the iterator. Right. So remember, next element here is basically like an iterator. So if what we got back here is none, saying the sequence has ended, then we say, well, we expected to get two elements and we didn't. But ultimately field 0 here, assuming all of this ended up in the OK branches, field 0 here is going to be the value of field 0. So which is the U64, which is the field A and then field 1? We do the same thing, call NextElement, tell it to deserialize as a string. And this could be any type here, right? It's any type that implements deserialize.
00:48:13.675 - 00:49:07.805, Speaker A: And we do the same thing. If we stop, then we say, you know, we expected two elements, ultimately field one is going to contain the string value of whatever was deserialized. And now that we're done, right, now that we have the values for both fields, all we have to do is say, great, we succeeded this visit seek succeeded and it produced a value foo where A is field 0 and B is field 1. And I think you can already see where this is going for visit map, it does the same thing, right? So it, Ooh, this is a very long line. Okay, so this starts out, I guess it's structured a little differently. This starts out by saying field zero and field one are both options that are set to none. And the reason why it has to do it this way is because you don't know if the key, if the field name is encoded in the data structure, that means it could come out of order.
00:49:07.805 - 00:49:45.225, Speaker A: So you don't know which you're going to get first. So therefore you can't just read one and store it in a value and then read the other and store it in a variable because you wouldn't know the types of the two variables because they could be in either order. And so instead you create variables for both of them, say that they're options, store them as none, and then you keep asking for the next key in the. So see, this uses map access instead of seek access. Keep asking for the next key. And then you look at, okay, which key did I get out which field? Right? So this is saying deserialize the next key as a field. This is why we have the deserialize implementation for field in the first place.
00:49:45.225 - 00:50:24.287, Speaker A: And if it's field zero, then if we already have a value for field zero, then we say this is not okay, duplicate field. Otherwise we try to decode the next value from the map as a U64, which is the type we know the field 0 has. And now we have a value for field 0. If the key that we got is field 1, we do the same thing. We check whether we already have a value for field one. And if, assuming we don't, then we ask for the next value, say, deserialize it as a string. Again, this could be any type and stored in Field 1 and any other fields we just ignore.
00:50:24.287 - 00:51:02.895, Speaker A: And so we say give us any value and we're just going to ignore it. And then ultimately down here, we're going to check that we indeed have a value for field zero and we have a value for field one. If we don't, we emit like a missing field error. And then we produce again foo with A set to field zero and B set to field one. And so now this, remember this is still the visitor, right? This is the visitor implementation for the type that can visit a foo value. And so then we need to tie that into a call to the deserializer. And that call is pretty Straightforward.
00:51:02.895 - 00:51:43.075, Speaker A: That call down here is just saying deserializer, deserialize a struct. So telling the data format, the next thing you should try to grab from the data stream is a struct. This is just self, right? So this could be written as this. Those are equivalent. The only reason it's written like this, I think, is because you don't need to use the trait or bring the trait into scope. You give the name of the structure, you give the list of fields. And again, this is because the data format might actually need to know the fields and the order that they're defined in.
00:51:43.075 - 00:52:21.071, Speaker A: So we pass that in. This is just a requirement of deserialized struct. And then we pass in the visitor, which is ultimately the thing that we wrote up here. And so what that's going to end up doing, right, is it's going to call the deserializer. The deserializers are going to continue walking its input stream, its data format, looking for whatever comes next. If it discovers that the next thing that came in was a map, then it's going to call visit map on this visitor. And then the visit map code runs which is going to call back into the deserializer's map access, saying give me the next key, give me the next value, give me the next key, give me the next value.
00:52:21.071 - 00:52:50.345, Speaker A: Until it feels like it's gotten all the fields or until there are no more keys. Actually, only until there are no more keys. And then it will produce the value. If what the deserializer realizes that there's a seek and not a map, it'll call visit seek on this visitor. It'll do the same thing. It'll keep calling the seek access part of the deserializer to continually get the next value and ultimately produce a foo. Okay, so that's the deserialize.
00:52:50.345 - 00:53:44.735, Speaker A: Does this make sense? We've now been through both serialize and deserialize. We're going to talk a little bit more about the subtleties here. But are there questions about the basic structure here of the serializer call graph and the deserializer call graph? Is there an attribute to force the generator of only seek or name deserializer visitors? No, that's a good question. I mean, the way that you do it is just you write your own implementation. I don't know if there's an attribute you can set specifically. No, it doesn't look like it, actually. I don't think so, except writing your own implementation.
00:53:44.735 - 00:54:26.735, Speaker A: Okay, so that was a flurry through deserialize. So let's look through now that we have a rough idea of the structure here. Let's look at the kind of attributes you can have for certed derive and sort of look at how they might change both the serialize and deserialize. We already looked at rename, rename all is the same, right? It's saying before you put in the field name in deserialize and serialize code, you know, turn things into lowercase, turn things into uppercase, that kind of stuff. Easy enough. Denial. Known fields we talked about only applies to deserialization.
00:54:26.735 - 00:55:35.957, Speaker A: And in fact, I mean, we can, we can add this if we want to see what it looks like. So if I now look at this, most of this code is going to look basically the same. One difference you'll see is that now up here, when we match on the key in visit map, there's no longer a sort of field ignore that calls ignore any on next value. And further up here, the field visitor, if it now gets a a name of a field that it doesn't recognize, it just errors rather than producing field ignore because there is no fieldignore in the field. Enum tag type. Okay, so this goes into how we do enums. So let's hold that for a second and then we'll look at enums tag tag untagged.
00:55:35.957 - 00:56:58.853, Speaker A: That's fine. Serdebound. This is a way to get the serde auto generated code to include additional bounds that might be necessary. This is because by default, when you derive serde deserialize and serialize, the impl of deserialize and the impl of serialize just generate this impl block. But imagine the foo was like generic over some X, right? And foo only is deserialized when X implements radical, right? Then serde has no way to know that this bound is required in order for deserialize on foo to work, right? So the reason why this might be necessary is that imagine that our structure foo X has a field x of type X and the impul of deserialize for x only works where X is radical. Or let's say there's a bar and the implementation for bar of x is only when x is radical. So this might be one reason why you need such a bound is because this simple exists and is constrained.
00:56:58.853 - 00:57:34.275, Speaker A: And so in your definition of food there's not even a mention of radical. And so the derived implementation wouldn't know that this bound is necessary. So that's where you can use serdebound and this one it's really Just it copy pastes the text you put in here into the basically here after the impl serialize and same for impulserialize. Just copy paste whatever you put inbound there. Default. Default is a fun one. Let's look at what default does.
00:57:34.275 - 00:58:41.321, Speaker A: Let's do here 30 default. So what default is saying is if this field isn't in the input, then actually here's what we're going to do. We're going to do even better expanded and then we're going to do 30 default and we're going to expand that to expanded two and then we're going to diff expanded to expanded two. I know this is very narrow, but you'll see very much of the code that was produced is actually the same. You see it's 170 lines here that are the same and the place where it differs down here. Let me expand this a little bit. So we're here in this is in the deserialized code and you see that if after having extracted the fields we find that field one is none, then in the old implementation we would error saying invalid length and in the new generation we set the value to be default.
00:58:41.321 - 00:59:46.049, Speaker A: That's the only thing it changes that gets hidden by my face here. So it changed from producing an error if Field 1 was none to producing just the default value into that field instead. And default equals path is just call this function to get the default rather than using the default trait remote. I think we're not really going to talk about Transparent is similar to repertransparent. This is just saying don't try to generate any code for this type. Like don't call d serialized struct with a thing that has only one field and stuff just directly call the serialize and serialize on the the single inner values. This only works for new type structs 30 from and try from.
00:59:46.049 - 01:00:35.569, Speaker A: So this is used if you have proxy types where you want to say hey serdi in order to like. Let's see, let me give you here. So this is going to say serdi deserialize into a string and then use the from trait to turn that string into a foo. So that way foo doesn't need to implement deserialize only this type needs to implement deserialize and then cert is going to take care of the conversion just by calling the from trait. This can be really useful if you have a type that's from some other crate for example here. And that crate doesn't implement deserialize for its types. It doesn't have a dependency on SERDE at all.
01:00:35.569 - 01:01:23.295, Speaker A: So you can have your own type that can be deserialized and then all you need to do is implement a mapping from your type into that crates type. I don't know if you. Yeah, so default on the container is just the same as default on all fields. So that's from and try from and into. They're all sort of analogous here. SERDI crate is just used for, you know, in this, in the generated code here, there are a bunch of places where it refers to. Go up to the top of this extern create Serde as underscore 30.
01:01:23.295 - 01:02:10.205, Speaker A: Sometimes you want to use a different crate than serdi or you have serd available but under a different name. And so this just lets you change what this value is. So if we said here create equals foo bar, see if it even lets me do that. Am I not? Yeah, it's gonna refuse to do that. This doesn't work because I haven't actually set it up so that FUBAR works, but maybe if I do. Let's see how that works. So if I do fubar package equals 30, I don't know if it'll let me do this.
01:02:10.205 - 01:02:41.515, Speaker A: Bring in the same dependency twice. Yeah, maybe if I do this fubar. There we go. So now it uses foobar as serdi instead of having its own external crate serde. That's all it changes. It just changes all of the imports. Like anywhere where this type is talking about SERDE uses the name you specified instead.
01:02:41.515 - 01:03:22.703, Speaker A: Those are all the container attributes. So let's then talk about enums. So if this is an enum foo instead, and it has bar and buzz, let's say this has a something like this. And then now we expand. Let's see what we get here. So now this is an enum instead. And what gets generated is very similar actually.
01:03:22.703 - 01:04:09.215, Speaker A: You see for serialize. Now instead of serialize struct, we call serialize struct variant. And the main difference between serialize struct and serialize struct variant is that we give both the name of the enum itself and the name of the variant and the index of the variant in the definition of the enum. Again, for formats that don't bother encoding the names of the types into the thing and just rely on the sequence and what we get back from that is again a sort of constructor, this time that implements the serialized struct variant trait rather than the serialized struct trait. And it has a serialized field just like the other one. So very Very similar code calls end. So this should be entirely unsurprising.
01:04:09.215 - 01:04:53.015, Speaker A: For deserialize, things are a little different. So for deserialize we. Where's the. So this is when it says field visitor here, what is actually a visitor of is the variant name, right? So you see here it can visit a U64, which is the index of the variant. So again, variant index here field is a little misleading because it's not a struct field at the moment. It can visit a string, in which case it expects the name of the variant. And same with bytes.
01:04:53.015 - 01:06:11.445, Speaker A: And then the deserialize is uninteresting. This is deserialized identifier, like before visitor for foo. Now is where we're going to see things be a little different. So we're going to expect to be visiting an enum, and when we do, we want to know from the data format, okay, you're visiting an enum, what is the variant of this enum? So again, the data format gets to dictate how enums are encoded, right through basically how it implements the enum access trait and deserialize enum, which we'll see later. And so we say, okay, tell me the variant. And if that is field zero, then. And then you see here, this, this code now sort of nests, right? So this is first deserializing which variant am I in? And then if it discovers that it's in field zero, which is bar, then it just generates out the code for deserializing that variant type, right? So, and it can do this because the deserialized code, if we go all the way up here, the deserialized code for this is exactly the same as the deserialized code for just struct bar with one field U64.
01:06:11.445 - 01:07:06.665, Speaker A: So that's why it just. When it generates the deserialize for a foo, it really just generates the code for a deserialized for bar and a deserialized for baz, like for each variant separately. And then it generates a sort of macro, like an outer deserialized for it, that determines which of those it should use. And so that's what we're seeing down here is it first asks for which variant, and depending on the variant, it calls either the derived deserialized for variant 1, which has visit U64 visit string for the fields. So this is all basically the code we looked up from the old foo. And then a little further down here, this is if the variant we got was field one. Then again, this is just the derived deserialized code for the baz variant, the second variant.
01:07:06.665 - 01:08:06.391, Speaker A: And then if we go to the bottom of that, we see this is the end of the visitor implementation. For foo, then we call deserializeenum. Again, instead of deserialized struct, we give foo, which is the name of the enum. Instead of the list of fields, we give the list of the variants and then we give the visitor. And that's all there is to it. Now where this gets, you know, where the details are here is in when we say sorry for all the scrolling, I know it's going to be disorienting when we tell the data format, which variant are we in, how it determines this is going to matter a lot. And this is going to vary by data format, right? And not just by data format, but even within a data format, you might have multiple ways of encoding an enum.
01:08:06.391 - 01:09:38.925, Speaker A: In fact, if we go back to the SERDE bit here, you'll see enum representations. There's a separate page on enum representations that gives, you know, here's an example, an example type, so they can be externally tagged, in which case the variant is placed outside a representation of the contents of that variant, right? So this is just you separately serialize the contents of it, and then you'd make that the value of a thing that holds the variant. So that's what SERDE refers to as externally tagged, and that's what it uses by default. Here, internally tagged is you have a field, you serialize the contents of the type, but you add an additional field inside that serialization that tells you which variant you're in. So that would be something here like type request and you have adjacently tagged, which is that you encode a sort of tuple of the variant and the contents of that variant. Like here, you know, T is the variant name and C is the encoding of that variant. And then untagged, which is you don't even encode which variant it is, you just serialize the contents.
01:09:38.925 - 01:10:22.017, Speaker A: And so when you deserialize an untagged, you basically just look at what fields you're given. And depending on which fields you're given, you make an assumption about which variant it originally was. We can look at untagged too. There's a lot of interesting complexity in how you deserialize an untagged. So let's look at what happens if we try to switch this to an internally tagged thing here. So if we go back here and we say 30 tag, the value here is the name of the field inside the representation you can use tab, that's fine. Expanded.rs
01:10:22.017 - 01:11:12.915, Speaker A: and expanded int rs. So let's see here. Okay, so one of the things that changes in Serialize here is that instead of serializing a particular variant, we're actually now just serializing a struct. So basically we're not telling the data format that what we're serializing is an enum, we're just telling it we're going to serialize a struct now, and it just happens to have an extra field. So it's not like this is cheating. Right, but it's basically saying that if you use internal tagging then serde, then as far as the data format is concerned, this just isn't an enum anymore. This is just a struct that happens to have one field more.
01:11:12.915 - 01:12:03.265, Speaker A: And so that's going to be represented in the remainder of the code. So there's going to be a pretty big diff here. So if I just open expanded int and we look at the implementation of serialize, it really just serializes a foo and then it serializes a field called type, where the value is bar and then it serializes all the other fields. So this one is actually very straightforward. It's really just serialize it as it serialize and deserialize as if it were a struct within one additional field. So for deserialize, if we go back here, so you see we have, we still have a type that represents which variant. So field zero here is bar, field one is bars.
01:12:03.265 - 01:12:28.705, Speaker A: We implement deserialize. That's fine. Deserialize any. Interesting. So here there's some like, private types involved. So the deserialize any here is telling the. I wonder why this is a deserialized any and not a deserialized struct.
01:12:28.705 - 01:13:10.715, Speaker A: That's interesting. Yeah, so this is telling the deserializer. Okay, Deserialize whatever comes next. And we're going to visit it using this tagged content visitor, which apparently is the thing that's in SERDE itself. So let's go look at what that looks like. SERDE source. Where did it come from? Private de Tagged content visitor Pub use self content.
01:13:10.715 - 01:13:51.273, Speaker A: Self content. Oh, it's just a sub module in the same file. Private D. Here we go. Not public API. Yeah, so this is a public type that's basically hidden from the API that the generated code gets to use, just so that it doesn't have to generate just tons and tons of code in every implementation. So what does this visitor do? Internally tied enums are only Supported in self describing formats.
01:13:51.273 - 01:14:37.171, Speaker A: I wonder why, why this isn't just considered a struct serialization. I guess it's because you are changing the struct. So it's sort of. It would be weird to have this be part of your schema because you're already having your data type be a different definition from what's actually in the format. So maybe that's the rationale here. So visitor for tide content, if it's a sequence that expects the first thing to be that the tag. If it's a map, then it oh, interesting.
01:14:37.171 - 01:15:26.915, Speaker A: If it's a map, it visits everything in the map and sees is the thing I just visited the same as the tag field. And if so, then we know that this is the value of the tag. Otherwise just store it. And the reason you have to store it here is you're basically buffering, right? If you know that this is an internally tagged enum, then you need to keep parsing out of the data format until you get the thing that tells you which variant it is. And that means that anything that you parse out of the data format before you get to the tag you have to put somewhere because you're later going to have to actually use those values in your deserialization. So that's what this vector is for. This is just keeping around those extra fields, those fields that you passed by while trying to get to the tag.
01:15:26.915 - 01:16:24.165, Speaker A: And it looks like it actually walks all the way through. So it doesn't try to like stop early when it hits the tag, it actually just walks all of them so that the tagged content has the tag and a vector of all of the other fields. And so this is one of the reasons why this representation is actually going to be slightly less performant than the externally tagged variant because it has to buffer. And this might be the reason why it needs to serialize any. Well, unclear. Okay, so tagged content, the visitor for the thing that tells you whether this is the tag or not the tag is just if it is the name of the thing that they said they wanted us to tag, then it's the tag. Otherwise it's content, that's fine.
01:16:24.165 - 01:17:29.421, Speaker A: And then, Right, and then there's a deserializer. So basically we're going to cert is going to treat the buffered list of fields we walked past as a data format and implement deserializer for it. And this makes a lot of sense, right, because it is a thing that holds data that can be turned into other data types. And so you see down here, the content that we stored up here the vector. Where did it go? This content vector is a map that holds the vector of all the key value pairs. And when we implement deserializer for that, we're just going to walk the content and depending on what type we ended up putting in there, we're actually going to, you know, call the appropriate visitor method. One thing that's interesting here is when we deserialize into content, so map next value here.
01:17:29.421 - 01:18:00.359, Speaker A: We're not mapping this into the value that is, let's, let's backtrack here a little bit. Imagine that the enum variant has, you know, one field that's a U64 and one field that's a string. This code doesn't yet know which variant you're in. And so therefore it has to. But it has to capture all of the fields that it walked by until it gets to the tag. And in fact it just collects all of the ones that are not the tag. But it doesn't know their types yet.
01:18:00.359 - 01:18:30.665, Speaker A: So it has to deserialize them because it has to buffer them for later. But it doesn't know which concrete type to deserialize them into. And therefore it has to deserialize them just directly into the data model. And that's what this content thing is. So let's see if I can easily find its definition. Yes, you see tag content here as a content. Let's see if we can find its definition here.
01:18:30.665 - 01:19:16.795, Speaker A: Here we go. So content, the content enum here is the SERDE data model. Like it's a, it's a data type that can hold any value in the data model. And so this is why the format has to be self describing. As we walk through the fields that we don't know their type yet, we can't give any hints because we don't know which enum variant we're in. And so we don't know what the type is expected to be. So we just need to deserialize any, which means the format needs to be self describing and what we grab out of the data format we store directly into this content thing, which encodes all of the possible values in the data model.
01:19:16.795 - 01:20:10.505, Speaker A: So you see it has all the integer types, it has the floating types, characters, strings, new type, seek and map. And actually I happen to know if you look a little bit over here, you see to buffer the contents of the deserializer when deserializing untagged enums and internally tagged enums. So this is the same trick that's used for untagged except there you don't even know what you're looking for. You're just going to grab all of them and they're just going to try deserialize based on this buffered content that is just a direct encoding of the of the data model. And there is a separate crate called SERDE value that has this publicly exposed, this enum. And I know that there's some work on trying to move that into serde. I don't know there's been any progress on that work in part because it should be rare that you actually need this in your own code, but it is possible that you do.
01:20:10.505 - 01:20:57.177, Speaker A: And I think some people just use SERDE JSON value for this, even though SERDE value is the more appropriate mapping for the DEM model. Okay, so going all the way back to the code that we had here, that's the reason we call deserialize any is because we don't know all of the stuff that's going to be in type. We don't know the full definition of this type yet as we just need to say visit this. And one of the things that you will visit is going to be the tag and anything else will tell you later. And then we're going to match on the tag that the tag content visitor found. And if it's field zero, remember field zero here is really bar, then we're in the bar variant. And so then we have a visitor for bar.
01:20:57.177 - 01:21:40.049, Speaker A: This again is just the regular derive for the definition of the bar variant. So it visits the fields. And the interesting thing is going to be where we. So this is just the same auto generated deserialize for the variance that we looked at before. So I'm scrolling past it, but when we call deserialize what we're going to do is we're going to call deserialize any. This one could probably be deserialized struct because at this point we do know the type, but let's ignore that for now. So here we're creating one of these content deserializers that we looked at from SERDE itself, right? So this we're going to give the content of the tag.
01:21:40.049 - 01:22:43.497, Speaker A: So the content here is that vector of the content enum which is the direct encoding of the data model. And this implements the serializer just by calling the appropriate visit method for whatever that stored data model value is with the visitor that we just had. I know that was a. That's a lot to take in at once. So ask me questions about how this was confusing so that I can try to explain it again. This is certainly like a tricky deserializer, but that's one of the reasons I wanted to talk about it is because if you're implementing deserialize yourself, these are the kinds of subtleties that sometimes you have to think about if you do get into really like weird data types or in some cases data formats. Although all of this is currently data type stuff for Field 1.
01:22:43.497 - 01:23:41.915, Speaker A: For Baz, it's the same thing, right? This is the derived deserialize for the definition of baz. And then at the end we just call deserialize any with the content deserializer with the content of the tagged with the visitor that we just generated. And so this is one of the reasons why visitor comes up here, right? Is the visitor is the real implementation of these crisis. And then we sort of this is the implementation of deserialize is the connection between the visitor and the particular deserializer that we end up using. Okay, so for adjacently tagged, you know, this is going to be similar to externally tagged. It's just that instead of using the value of a field, you look for the value of an adjacent field by some name. So this one's not going to be that interesting.
01:23:41.915 - 01:24:27.237, Speaker A: Untagged is probably going to be interesting, but I'm aware of the time, so I'm going to not talk about untagged here. It's basically the same as internally tagged, except that you don't get to look for a tag. So you just end up with that vector of contents and then you're just going to try deserialize each for. For each data format. And this means you need to do even more buffering because you might start to deserialize into one of the variants and then like halfway through walking content realize actually this is not the right variant. And so now you're going to have to try deserialize into another variant. But that means you still need to deserialize the parts of content that you already walked to deserialize them in the previous variant attempt.
01:24:27.237 - 01:25:25.805, Speaker A: And so there's a little bit more complexity around there, but that gets very in the weeds. Okay, so that's enums. We've talked about their serialization and their deserialization. We can look at the variant attributes to see if there's anything interesting. Rename not really alias is just allow it to be deserialized with multiple different names is not too interesting. Skip is not that interesting here. Serialize with and deserialize with are Also, now that we know how all this code actually works, they're not that interesting because most of what they do is just change the generated code so that instead of passing in a reference to the underlying type, you have a little constructor around it that instead calls this method rather than calling the deserialized method directly on the type of the field.
01:25:25.805 - 01:26:17.235, Speaker A: Same with, with bound we talked about borrow and other. Okay, so other is just. Is for tagged enums where you can say if the tag didn't match, if like if none of the tagged enums, if none of the variants were matched by the data that came out of the data format, use this variant instead. So it's sort of a fallback. If you are default variant borrow is. Do I want to talk about borrow? Borrow I think is mainly there to ensure that serde generates the appropriate bounds. So this, this happens for something like.
01:26:17.235 - 01:27:13.911, Speaker A: Let's go back to our struct foo, it had a use 64 and a B string, right? So if we instead wanted to generate this, or perhaps more, more interestingly, something like this. So if we do this, then the serialize is straightforward, right? Because this is just serializing a string, that's totally fine. We know how to do that. But for deserialize, where this gets tricky is if the underlying data format gives us a reference to a string, then we want this to continue to use that reference. We wanted to turn into cow borrowed. But if it doesn't, if it produces an own string, then we want to produce the cow owned version of this. And in either case this will.
01:27:13.911 - 01:28:00.145, Speaker A: The deserialize will only work if the de lifetime outlives the tick a lifetime. And I'll let you mull over that separately. But we need to tell Surday that it should associate tick A with tick de because otherwise if we don't, it doesn't. It's going to generate a deserialized implementation here where tick A and tick de are unrelated. And that won't work because if we are truly going to deserialize from a reference of de into this field which has lifetime tick A, there has to be an association with it. Namely D has to live for at least as long as A does. And so that's where you stick in Serdiborough like this.
01:28:00.145 - 01:28:46.879, Speaker A: And we can look at what happens if we generate this. So serialize is still the same, it's a serialized field. It's not terribly interesting. Deserialize, you see here there's an impul which has the lifetimes de and a deserialized E for foo A. There's no association between the two of them. And when it visits a str, that's fine. It deserializes the cow.
01:28:46.879 - 01:29:18.345, Speaker A: Take a. That's fine. So all the code here looks basically exactly the same as it used to. And that's fine, you know, but when we do cargo check here, I would need to write some code that actually uses the simple of deserialize. But if you ever try to use this, you would get an error from the compiler saying that DE doesn't live long enough. And in fact, I can. I mean, I can do this, I suppose.
01:29:18.345 - 01:30:19.225, Speaker A: Serdejson is version 1 and we're going to do JSON from string and it's fine that it doesn't actually work. Ooh, why? Oh, interesting. Maybe it just did I miss a special casing here. I think so. That's interesting. I wonder why that works. Because it shouldn't let me get rid of the stuff in between.
01:30:19.225 - 01:30:56.875, Speaker A: Oh, it is static. You're right. Let's do. No, that'll still work. Oh, by default, cow will always become owned. That's why it only becomes borrowed when used with 30. Okay, so cow is sort of special cased here.
01:30:56.875 - 01:32:11.229, Speaker A: So I could do this instead by saying cow two Borrowed. It's not going to like this, is it? Yeah, there's more trickiness here. So, okay, so the answer is cow is kind of special cased here, where cow will always turn into a borrowed string, not stir, and therefore it can assume any lifetime here. It wouldn't work if I did this, for example. Why on earth does that work? Oh, because here tick A just gets set to D. How can I make this fail so that I can show what it does? I wish I had an example of the top of my head here. Yeah, use any other type.
01:32:11.229 - 01:32:35.211, Speaker A: The cow and stir here are sort of special cased. If I just did that, that's not gonna. It's not gonna like that. But if I did bool maybe. Okay, great. So here it's gonna complain at me and we don't need the drop anymore. Great.
01:32:35.211 - 01:33:47.653, Speaker A: So here it complains saying the DC or lice not in implement for bool. Fine, fine, fine, fine, fine, fine, fine, fine. We'll derive struct bar ticket and we're going to have a phantom data ticket and then this is going to be a bar ticket. Whatever. Why is it okay with me doing this now? I'm confused. It should not be okay with me doing this, unless if I have to do borrow on this one. Great.
01:33:47.653 - 01:34:22.381, Speaker A: Okay, so now we finally get the error I was after, which is lifetime may not live long enough. The lifetime tick is defined here. And the implementation of deserialized for bar requires that DE must outlive A. And this is the error we would have gotten for cow as well if it wasn't special cased. And the trick here of course is we want serde when it implements the deserialize thing here to add the bound that DE is going to outlive tick A. Because that is the case in which this is ok, because this will just be a. In fact we could do.
01:34:22.381 - 01:35:09.285, Speaker A: We can make this be a stir. So the explanation is a little easier. You know, this string reference in here is going to be a reference into the string that was passed all the way down in the deserializer into its input. And in order for that to be the case, it has to be the case in the deserialize implementation here that there's a bound saying DE outlives tick A. That's the only way in which this will end up being valid. And certiborrow makes it so that we have that bound and it's not going to do anything particularly special. Like if I expand this, you'll notice all of this is going to be pretty much the same.
01:35:09.285 - 01:35:55.081, Speaker A: The only difference is going to be here implement visitor D for visitor da. And you see it has here a bound saying D outlives tick A and the generative value is just tick A. So the only thing that borrowed really changed was it added this constraints between the D and the a lifetime parameter. And we'll see this on the impld deserialize 2 which is near the top here. So that's that bound too. And I mean I can show you without, although no, it won't compile, so I can't show you without. And if we, if we did cow here now.
01:35:55.081 - 01:36:50.645, Speaker A: So if we now go back to what we originally had with serdeborrow, then if I now expand this, what we would hope right, is that if you get a string reference it turns into a cow borrowed. If you don't, it turns into a cow own. And indeed if we scroll down here for the visitor again, this is the visitor for creating a foo. And you see there's now a visit seek. That's fine. So here the code for deserializing this field has changed a little bit. It's no longer just deserializing a string, it creates its own little deserialized with that holds a value that's a cow and it implements it Generates an implementation of D serialized for it and it uses this boro COW stir implementation from Serde Private.
01:36:50.645 - 01:37:36.505, Speaker A: So let's go look at that one Serdi over here. Oh, borocaster. So this has a cow string visitor. And you see if it visits a string like a. If it visits a string down here, it creates a cow owned. If it visits a str, then it creates a cow owned. Um, but if it visits a borrowed string that is a string where you have a reference that that is going to be long lived.
01:37:36.505 - 01:38:21.335, Speaker A: It's going to live as long as the input to the data format, then you can produce cow borrowed. Visit STR is if you have a string reference, but it doesn't point into the data format data formats input so it's not a long lived string. So specifically this extra function is the thing we wanted, which is if it turns out that this can be a reference all the way back to the input, then generate a cow borrowed and same thing for bytes. So there's visitbytes and there's visit borrowed bytes. So that's what borrow does. It primarily adds this de bound. But what that enables is that your implementation can now have fields that ultimately borrow from the data formats input.
01:38:21.335 - 01:38:51.405, Speaker A: Okay, so now we've been through all the variant attributes. The field attributes are mostly the same. Flatten just for time. I'm not going to talk about flatten. It's not super interesting. And borrow, we've talked about remote types we're not going to talk about. Okay, so then the question becomes, okay, what's left? Well, we haven't really talked about the data format, but the data format actually isn't that interesting.
01:38:51.405 - 01:39:43.137, Speaker A: Let's look at here. So there's a page on writing a data format in the SERDE docs and talks a little bit about conventions about like you should have an error type that's shared between serialization and deserialization. You should have a serializer, you should have a deserializer. And roughly what the names of the methods should be, what convenience methods you should implement and what modules you should have. This is just basically how should you structure your data format? Error handling talks about a little bit the kinds of errors that might come up and in particular the fact that you have to support custom messages. So these are errors from the data type. So if the data type says I was expecting this kind of input, you want that to be possible to propagate up through the data format.
01:39:43.137 - 01:40:27.815, Speaker A: So through the deserializer and serializer implementations, this is not super important, it's just a little detail, but the interesting parts are implementing a serializer, implementing a deserializer. And one of the things that is stressed a lot in this documentation, because it's important, is that SERDE is not a parsing library. It does not give you any mechanisms for parsing or interpreting a data format or for producing that data format. It just provides you with the connection to the serialized and deserialized trait. Implementations of data types. Basically, it gives you a connection to the SERDE data model. How you parse JSON, for example, is not serde's business.
01:40:27.815 - 01:41:16.697, Speaker A: All you are expected to do talk about serializer first, because it's sort of the easiest one to implement. Serializer all you really have to do and let's it gives the example here of JSON is you have to implement the serializer trait, which has an okay and an error associated type. The okay type. Generally you're not going to return a thing. So if you serialize to JSON, for example, you're not going to return a string. Instead, the serializer type itself is going to hold your output because it might be like a filewriter, for example, where you don't really want to have to buffer it into memory and then write it out. You just want the serializer to directly call into the underlying output socket, for example, so when the serializer has finished, it hasn't produced a value.
01:41:16.697 - 01:41:45.363, Speaker A: Hence type OK equals unit here. And the error type is the error type. We talked about these sort of sub serializers. Oftentimes, especially for simple data formats, you can just keep this all to one type. Sometimes you want to separate them out, but it's not terribly important for what we're talking about right now. And then you really just want to implement all the serialize methods, right? So serialize a bool. Well, in JSON at least, just write true or false serializing numbers.
01:41:45.363 - 01:42:42.067, Speaker A: In JSON they're all serialized the same way, which is the string representation of the number, but without quotes, serializing characters, serializing strings. You really just want to implement all of these for whatever makes sense for your data format. And then for things like serializing structs or enums. Then usually, at least for some data formats, you're just going to turn those into the equivalents of dictionaries. So there's just going to be maps and similarly, sequences are going to turn into arrays. New types are mostly going to be the same as if they were a struct. But for some data formats, like protobufs, for example, there might be more specific encodings that you could Use and so for sequence here, for example, you see what serialize SEQ does is it starts the sequence and then returns self as a serialize SEQ implementation.
01:42:42.067 - 01:43:26.267, Speaker A: Remember, this is like a separate trait associated type that implements a trait. And if we go down to the implementation of serialiseek, you see that it has a serialized element. You implement that and it just prints, you know, adds a comma to the output and then serialize itself. Same with maps, you know, it's going to the call to serialize map is going to emit a curly bracket and then return self. And the implementation of serialize, where do we have it serialized? Map is just going to add commas and then add colons between the key and the value. And ultimately the end is just going to be a closing curly. So serializing really just is you're told what to serialize.
01:43:26.267 - 01:44:01.495, Speaker A: Now do the thing. So not that bad. Deserialization is a little trickier. And in particular what you have to do is again, SERDE is not a parsing library. When you implement serializer deserializer, I mean you have the choice of whether to implement deserialize any or not. For self describing formats, you generally want to implement deserialize any and for any that you can't, you're not going to implement that method and it's just going to error if someone calls it by default. Default.
01:44:01.495 - 01:45:20.309, Speaker A: And usually your deserialize any is just going to forward to the appropriate other deserialized implementation and then you implement the appropriate deserialize the appropriate. Well, so there are two parts to this, right? So there is if you're told to deserialize a bool, then you first want to extract a bool or try to extract a bool from your input. So in the case of JSON, the string or the byte buffer or whatever, and then you want to pass that value to the appropriate visit method on the visitor that you're passed in. So really all you're doing is parse the format, however you choose to parse it and then give it back into the deserialize the data type through the data model using the visitor. So you see all these implementations are basically all the same, right? They are call visit of the appropriate type with the thing that you got out of your input by parsing. So parse assigned integer, pass it to visit. And then there are a couple of things that are a little more involved, things like deserializing options.
01:45:20.309 - 01:46:27.365, Speaker A: For example, you need to know how your data format represents values that may or may not Be there. And then if we look at deserialize sequence, you look for an open bracket and then you create, you call visit SEQ and you create a type that represents your parser for the contents of a sequence. So in this case, comma separated here is really just a, a type that the you own as in the data format owns. That is a parser for the stuff that goes in arrays. And it is going to implement the access seek trait so that you can, so that the caller can keep calling, you know, next element or next value. And then ultimately once there are no more comma separated values, then you check that you in fact have a closing thing for the array and otherwise you emit an error because the data format was broken. So same things for maps, right? So if we go back to map looks for an open curly bracket has a comma separated parser calls visit map.
01:46:27.365 - 01:47:27.405, Speaker A: So there's an implementation of access map for comma separated and we can go down and look at that too. So seek access for comma separated is just see whether we're at the end. If we're not look for a comma. If you find a comma, then you just deserialize the thing that is between you and the comma and then you emit that value up to next element. NMAP is going to be very similar, right? We look for comma that separates elements and then so that's going to be the next key is the thing that follows the next comma and the next value is the thing that follows the next colon. But again, how you actually parse your data format is not serde's business. All you are supposed to do is implement the serializer and deserializer traits and these sort of access traits for whatever your sub parsers are for maps, sequences, tuples, structs, that kind of stuff.
01:47:27.405 - 01:47:59.915, Speaker A: Okay, I think that means we're all the way through. I don't think there are any other things I really wanted to talk about for serde. There's obviously a bunch more stuff to it. Like, you know, how SERDE derived does its code generation. I'm not going to go into that. That's a, that's very low level here. Or you know, looking at the actual implementation of serializer and deserializer for SERDE JSON or look at the implementation of deserialize and serialize for serdejson value.
01:47:59.915 - 01:48:33.101, Speaker A: Those are interesting things to look at. There's a lot of like good juicy stuff there. If you want to pick up more about how SERDE works But it's not really something we need to spend time on here. And so I think with that, let's see if there are any questions at the tail end here, because I've talked a lot, but hopefully some of this now makes sense and you feel like you can start. You can rewatch some of it maybe, and then go and dig into this on your own. And now, hopefully, you have more of the. The mental model and the sort of terminology and basic.
01:48:33.101 - 01:48:55.377, Speaker A: On this understanding of the types involved and the traits involved to figure the rest out yourself. And we did it on time, too. It's pretty good also. Yeah. I mean, SERDE is. It's really fun to read through SERDE because there's so much smart engineering. Like, it's a.
01:48:55.377 - 01:49:22.491, Speaker A: It's a cool architecture. You know, there's been a decent amount of, like, let's come up with a better serde or SERDE has these problems and we want to fix them. And I think those efforts are really good. There are certainly cases where you can improve upon serde, but I still think SERDE in and of itself is an accomplishment. And I know David is in chat, so. Clap. Clap for David or D.
01:49:22.491 - 01:49:55.747, Speaker A: Tolnay for those who don't know that the D stands for dividend and. All right, I don't see any more questions in chat. I'll give YouTube a couple of minutes to catch up. All right. Oh, nice. Thank you. It's on here, apparently.
01:49:55.747 - 01:50:15.345, Speaker A: Apparently we are now on here. Hey, look at that. I will add that. So I'm going to. As usual, I'll upload this to YouTube afterwards, and that will actually have, like, chapter marks that people can scan through and stuff. So I'll send you the link to that later on. That'll be a better thing to embed than the link to the live stream.
01:50:15.345 - 01:50:37.931, Speaker A: Nice. All right, thank you, everyone. Hopefully that was useful. I'm hoping to do more of these decrusted things. I think they're going to be a useful thing for the ecosystem to go through. There are a couple of other things that I think are really good crates that are candidates for going through this kind of decrusted thing. Like, I think Tokyo is a good candidate.
01:50:37.931 - 01:50:56.599, Speaker A: Tower is probably a good candidate. Rayon, maybe crossbeam pin nom. I think there are a bunch of good candidates here. So I'm pretty excited about this. This new series. And now that I'm actually gonna do streams every four weeks, I think this is gonna be. We're.
01:50:56.599 - 01:51:17.601, Speaker A: We're gonna see some good streams. All right. Clap. Maybe Axum there's lots of good candidates. All right, thank you, everyone, for coming out, and I'll see you next time, whatever the next stream is. There might still be more streams than every four weeks if I have the time, but at least there will be a stream every four weeks. Now, thank you all.
01:51:17.601 - 01:51:17.985, Speaker A: Bye.
