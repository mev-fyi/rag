00:00:02.200 - 00:00:31.755, Speaker A: Okay. Hello everyone. So this is going to be a tutorial on a recent paper which is joint work with Tim Rothgarden and which is aimed at developing a general framework for the analysis of permissionless consensus protocols, be they proof of work, proof of stake, proof of space, or whatever. So in the tutorial I'm only going to be able to go into things at quite a high level. So if you're interested in the details, I definitely recommend you check out the actual paper which has the same title. It's called Permissionless Consensus. You can find that on our web pages.
00:00:31.755 - 00:01:25.709, Speaker A: Okay, so let's start off with a little bit of motivation. So I guess the first, most basic question to address here is why do we need a general framework? And certainly a basic answer to that is that impossibility results play a fundamental role in establishing any well developed theory. And you can't prove, you can't rigorously prove impossibility results without a well defined general framework. So certainly in the permission setting that that's been the case. Okay, so by the permission setting I just mean the classical setting that's been worked on since at least the 1980s or so. The permission setting is one in which we have a fixed set of known participants. Okay, so certainly in the permission setting, impossibility results have played a fundamental role in building the theory.
00:01:25.709 - 00:02:07.163, Speaker A: There are many examples of that. So a very well known example is the FLP theorem, right? So we have this very nice theorem of Fisher, lynch and Patism which says that if a protocol is going to operate in asynchrony, whatever that means, if a protocol is going to operate in asynchrony, then some randomness is required. Okay, so that's a nice theorem, but it also plays a role on a day to day basis as we go about defining protocols. Because if we're defining a protocol and we want it to work in asynchrony, then we know some randomness is required. Okay, so there's one example. You can give many more examples. Certainly the permission setting and possibility results have played a crucial role.
00:02:07.163 - 00:03:16.115, Speaker A: How about for the permissionless setting? Well, so there have been various frameworks which have been developed which suffice to model and analyze proof of work protocols. But prior to the stuff we're going to talk about today, there's no general framework which suffices to model and analyze permission permissionless protocols more generally. And basically the reason for that, or one of the reasons for that, as I'll explain later on, is basically because existing frameworks don't have adequate Language for talking about what we'll call on chain resources. And in particular, we'll see various results today that can't be explained in previous frameworks. Okay, so I minimize myself here, so you can see the slide. So one of the things we want to achieve in this tutorial is to precisely define what we mean by the permissionless setting. What do we mean by permissionless protocols? Something that makes that slightly more difficult is that people often think of some protocols as being, in some sense more permissionless than others.
00:03:16.115 - 00:04:02.385, Speaker A: So, for example, people might think of proof of work protocols as being in some sense more permissionless than proof of state protocols. So how can we make that precise? Well, what we'll let you do is define a hierarchy of four settings, okay? From most permissionless down to least permissionless. Okay? And I'm going to define these settings more precisely later on in the tutorial, but I thought I'd just start off by giving a brief overview. Okay, so from starting with the most permissionless, then. So the hardest of the settings to operate in is what we call the fully permissionless setting. Okay? And this is the setting that protocols like standard proof of work protocols like Bitcoin, they operate in the fully permissionless setting. And the basic idea is as follows.
00:04:02.385 - 00:04:33.765, Speaker A: In the fully permissionless setting, at each moment in time, the protocol has no knowledge about which nodes are currently running it. As I say, I'm giving us a high level overview now. We'll give a more precise version later on. So each moment in time protocol has no knowledge about which nodes are running it. Of course, in practice you might have some good idea about who the major miners are, etc. But the point is that that's not necessary for the protocol to operate effectively. So that's the basic idea behind the fully permissionless setting.
00:04:33.765 - 00:05:25.929, Speaker A: Then we consider a relaxation of that, a slight relaxation of that, which we call the dynamically available setting. Okay? And the thing to have in mind here is that standard longest chain proof of state protocols, such as Ouroboros or Snow White, they operate in the dynamically available setting. Okay? So why is this that setting? Why is the DA setting easier to operate in? Okay, so in the fully permissionless setting, the protocol has no idea who's currently running the protocol in a dynamically available setting that's no longer true at each moment in time. Now the protocol is aware of a dynamically evolving list of IDs. Okay? So think of a proof of stake protocol. Think about the set of finalized transactions and who owns stake according to that set of transactions or who owns stake in escrow according to that set of transactions. Okay? So now at each moment in time, the protocol is aware of a dynamically evolving list of IDs.
00:05:25.929 - 00:06:22.315, Speaker A: And furthermore, we can assume that some honest members of that list will be active in carrying out the protection. Okay, we might also make assumptions of the sort, at least that actually a majority of the active members of that list will be honest. Okay, so as I say, you should think of standard longest chain proof of state protocols as operating in this setting. Let me move on to consider a relaxation of the dynamically available setting, which we call the quasi permissionless setting. Okay, so now the difference is that, so again, the protocol is aware of this dynamically evolving list of IDs. But whereas in the dynamically available setting, we couldn't assume that everybody, all members, or at least all honest members of that list would be active and carry out the protocol, we don't know how many are actually going to turn up. In the quasi permissionless setting, we're able to assume that all honest members of that list of IDs will be active in carrying out the protocol.
00:06:22.315 - 00:07:01.785, Speaker A: Protocol, okay? In particular, this allows us to do to carry out protocols which require quorums. Okay, so yeah, so you should think of standard proof of stake BFT style protocols, the kind of protocols that use quorums and quorum certificates protocols such as Algorand, they operate in this setting. It's not just for proof of stake protocols though. There are also certain proof of work protocols such as Bizcoin Hybrid and Slida that operate in the quasi permissionless setting. And I'll go into that in more detail later on. So that's the quasi permissionless setting. And then finally, the easiest setting to operate in is the permission setting.
00:07:01.785 - 00:08:00.285, Speaker A: Okay? This is the standard classical setting in which we have a fixed set of known and always active participants. Okay, so this is a hierarchy of settings. It's a strict hierarchy, each level being easier than those above, which means that if we prove any impossibility result from a certain level of the hierarchy, then that impossibility result automatically holds all levels above, right? So if we prove an impossibility result for the da, the dynamically available setting, that automatically holds for the fully permissionless setting. Okay, so this is a hierarchy of settings rather than protocols. But what we'll do then is we'll allocate a protocol to the harshest setting in which it's live in the system or in which it operates effectively. Okay, so for example, we'll refer to Bitcoin as a Fully permissionless protocol, because it operates in the fully permissionless setting. We'll refer to Algorand as a quasi permissionless protocol because it operates in the quasi permissionless setting.
00:08:00.285 - 00:08:56.455, Speaker A: Okay, and then what I want to try and persuade you of in this sequence of videos is that actually, often what's possible is not necessarily so much a function of whether the protocol is proof of work or proof of stake or whatever. It's really often a function of the setting in which you operate. Okay, so often it's a setting which delineates what's possible, and we'll see lots of examples of that. Okay, so we'll see a result which suffices to separate the fp, the fully permissionless, and the dynamically available settings. So, in particular, what we'll see is that fully permissionless protocols can't be deterministic. So Bitcoin operates in the fully permissionless setting, is a probabilistic protocol. And according to the results we'll see today, now we know, in fact that's necessarily the case, fully permissionless protocols can't be deterministic, whereas the dynamically available protocols can be.
00:08:56.455 - 00:09:36.493, Speaker A: So that separates the FP and the DA settings, the fully permissionless and dynamically available settings. And then we'll also see a number of results which suffice to separate the dynamically available and quasi permissionless settings. So dynamically available protocols can't function in partial synchrony, whereas quasi permissionless protocols can do. And that's one separation. Another separation is that dynamic available protocols can't be optimistically responsive. Okay, I'll define what that means more precisely later on. But roughly, being optimistically responsive just means that the latency is a function of an actual message delay, rather than known upper bound on message delay.
00:09:36.493 - 00:10:09.865, Speaker A: So, roughly speaking, it means that the protocol proceeds at network speed. Okay, As I say, I'll define that more precisely later on. Okay, so dynamically available protocols can't be optimistically responsive. Quasi permissionless protocols can be. And it's also true that dynamically available protocols can't be accountable, or as quasi permissionless protocols can be. Again, so I'll define accountability more precisely later on. But roughly speaking, being accountable just means that the protocol produces incontrovertible proofs of guilt in the case of a consistency violation.
00:10:09.865 - 00:10:48.155, Speaker A: Okay, so this has to do with slashing. Okay, okay, so dynamically available protocols can't be countable, and quasi permissionless protocols can be. Okay, and there are various different ways we can separate the quasi permissionless and permission settings. One way is to Use the E ACC property. Okay. If you want to understand the E ACC property, then you'll have to look into another paper which is by me, Tim and Eric Budich. I'm not going to go into details of that today, but the EAC property is one way we can separate the quasi permissionless and permission settings, and we'll see another way of separating those two settings later on.
00:10:48.155 - 00:11:30.975, Speaker A: Okay, so that's a brief sort of overview, as I say. Obviously, I'll define all these settings more precisely later on and we'll see proofs of some of the separations. So next, let's just briefly say a bit about the structure of the tutorial. Okay, so, okay, if you're going to talk about permissionless protocols, then generally we're going to want to consider what we'll call resources of some kind. So by resources I mean things like hash rate, memory chips, stake, that sort of thing. Okay, so generally we're going to want to consider resources of some kind. To begin with, though, I want to introduce first of all a version of the fully permissionless setting without resource restrictions.
00:11:30.975 - 00:12:06.089, Speaker A: Okay, so we'll introduce the fully permission setting without resource restrictions first of all. And then what we'll do is we'll sketch a proof showing that consensus actually is not possible in a fully permissionless setting without resource restrictions. Okay, so that then motivates the introduction of resources. So that's what we'll do next. Okay, so then we'll go on to consider resources, and for us, resources will be of two types. Okay, Resources are either external or they're on chain. External resources are things like hash rate and memory chips.
00:12:06.089 - 00:12:51.795, Speaker A: On chain, resources are things such as stake, but we'll see some other examples later on. Then once we define resources, then we can define the fully permissionless setting proper and the fully permissionless setting with resource restrictions. From then on, by the fully permissionless setting, I will always be in the fully permissionless setting with resource restrictions. Okay, and then we'll see our first impossibility result. Consensus protocols for the fully permissioned setting cannot be deterministic. Then we'll go on to define the dynamically available setting. Relaxation of the fully permissionless setting, we'll see a couple more results for which we'll either some of the results will give foolproof, some will give sketches.
00:12:51.795 - 00:13:27.543, Speaker A: Okay, so we'll see a fairly full proof of the fact there exist protocols for solving byzantine agreement in the dynamically available setting that are deterministic. Okay, so that suffices to separate the DA and the FP settings. I Apologize for the number of acronyms on the screen, by the way. So obviously by fp I mean fully permissionless. By da, I mean dynamically available, and BA here means stands for byzantine agreement. Okay? And we'll sketch another result showing that dynamically available protocols can't solve consensus in the partial synchrony model. Okay? And then basically what we'll do is we'll just continue working down the hierarchy.
00:13:27.543 - 00:14:09.655, Speaker A: Okay, so the next thing we want to do is define the quasi permissionless setting. I'm going to start off by defining the quasi permissionless setting first of all, just for stake, okay? And then I'll give some examples of other chain from other forms of on chain resource. So you know what I mean by that. And we'll formally define what we mean by unchained resources. Having done that, we can then define the quasi permissions setting property. And then we'll see various impossibility impossibility results that suffice to separate the dynamically available and quasi permissionless settings. Okay? And then the last thing we want to do is to see at least some way of separating the quasi permissionless and permission settings.
00:14:09.655 - 00:14:49.275, Speaker A: Okay? There are various ways you can do that. In order to achieve that, I'm going to take one particular route. In particular, I want to revisit what it means for the adversary to have bounded on chain resources, because that might sound like a fairly obvious sort of thing. Okay, it seems fairly clear what it means to say the adversary always has a most of the third of the stake or whatever. But actually we'll see there are various different approaches you can take in that regard. And actually the precise definition you write down, the precise approach you take can make big differences to what's possible. Okay, so we'll go into the details there, and once we've done that, then that will give us a nice way of separating the quasi permissionless and permission setting.
00:14:49.275 - 00:14:57.135, Speaker A: Okay, so that's the basic structure. In the next video, we'll go on to start introducing the fully permissionless setting.
