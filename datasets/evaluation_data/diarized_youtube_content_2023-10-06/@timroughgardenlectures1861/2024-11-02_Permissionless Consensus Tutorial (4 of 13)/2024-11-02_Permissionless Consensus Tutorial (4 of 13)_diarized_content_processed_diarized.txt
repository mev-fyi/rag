00:00:02.600 - 00:00:34.451, Speaker A: Okay, welcome back everyone. So this is video four in the sequence. So in the last video we were working in the fully permissionless setting without resource restrictions yet, and we proved this proposition here, which basically asserts that consensus is not possible in that setting. So that motivates the introduction of resources. And what we're going to do in this video is to consider how we'll model resources. Okay, so I minimize myself. Okay, so for us, resources will either be external or on chain.
00:00:34.451 - 00:01:15.165, Speaker A: Okay, so external resources are things like ASICS or memory chips, and on chain resources or things like stake. So stake is an example. But as we'll see later on, there are other forms of on chains resources as well. It's worth noting that external and on chain resources have some fundamental differences. So first of all, external resources are generally allocated to players, whereas on chain resources are generally allocated to specific identifiers owned by those players. It's also true that on chain resources can be selectively confiscated. If you have something like that stake, then the protocol could reach out and take stake away from specific identifiers.
00:01:15.165 - 00:02:01.297, Speaker A: And obviously this becomes important when you start considering things like slashing and whether it's actually expensive to attack a specific protocol, whether specific protocols are economically secure. And another third difference is that on chain resources are user relative in the sense that different players may see different versions of the blockchain as they have different ideas about how much stake a particular player owns. And on chain resources generally only change with each consensus decision. Okay, so there are these fundamental differences between external and on chain resources, and that means that they need to be modeled differently. So we'll model them differently. Okay, so we'll focus on external resources first. And we're going to model external resources using something we call permitter oracles.
00:02:01.297 - 00:02:44.495, Speaker A: Okay, but we won't use oracles to model on chain resources. Okay, so what we'll do now, yeah, we're going to sort of have one model external resources and then we'll move on to consider how we consider on model on chain resources in the tutorial. As I said in the first video, there'll be quite a lot of stuff, like I said already, at quite a high level. So again, if you're interested in the details, I definitely encourage you to check out those details in the paper. Okay, so let's consider external resources first. Okay, so these are things like hash rate or memory chips, this sort of thing. Okay, so for each external resource we consider something that we call a resource allocation function.
00:02:44.495 - 00:03:37.709, Speaker A: So this is a simple thing, it's just a function that allocates each player a resource balance at each time slot. So you can think of each player as having a hash rate or a storage capacity each time slot. Okay, and then for each external resource, you also consider something called a permitter oracle. And we allow that players can send requests to the permitter oracle. So you can think of the request as maybe being something like a request for a proof of work, and then the permitter oracle will respond, maybe depending on their resource balance. So maybe you submit a request for a proof of work, and the permitter oracle might be more likely to grant you that request if you have a higher hash rate, a higher resource band. Okay, so that gives us a high level description of how we can model external resources.
00:03:37.709 - 00:04:39.885, Speaker A: To make that a little bit more concrete, let's think about how we model Bitcoin specifically. Okay, so to model Bitcoin, I suppose that any request that P sends to the permitted oracle at times T must be of a specific form. It has to be a pair b sigma, where B is a natural number less than their resource balance. So heat, you can think of B as being the sort of hash rate dedicated to this request, and you can think of this as being a request for a proof of work for the string sigma. We're going to allow players to make multiple requests in a single time slot, so long as they reuse hash rate. Okay, so interpreting the BI's here as hash rates devoted to each query, we require that none of our players overall hashrate can be reused. And importantly, this constraint obviously has to reply to Byzantine players as well.
00:04:39.885 - 00:05:46.673, Speaker A: Okay, and then we want to be able to model Bitcoin's proof of work in such a way that we can, we can deal with the difficulty adjustment algorithm. So we want responses to have a quality, so we define. So each proof of work Oracle response is going to be a 256 bit string Tau, say, and the quality of that string tau is just number of zeros that it begins with. So here's how they put the permitter function. So P submits the request B sigma at times T, and the permitter oracle independently samples b many 256 bit strings uniformly random, and responds with tau, which is the lexicographically smallest of these. Okay, and you can think of the responses being signed by the permitter, so they can't be faked. Okay, so that gives us a simple way of modeling external resources.
00:05:46.673 - 00:06:15.205, Speaker A: Again, for the details, I encourage you to look into the specifics in the paper. To reiterate the point, though it's worth noting that on chain resources don't work like this. Right, so the stake you think I have may depend on the version of the blockchain you've seen. So with external resources, each player really has like a fixed balance. At each time slot I have a certain hash rate mistake. That's not necessarily the case. The amount of mistake you think I have maybe to depend on the version of the blockchain that you've seen.
00:06:15.205 - 00:06:53.725, Speaker A: Okay, so then let's move on to consider how we can model on chain resources. So yeah, so stake is one form of on chain resource. As I've said before, we'll see other forms of on chain resources and in particular there are various proof of work protocols that use on chain resources. For the stake of simplicity though, I want to focus initially just on stake. Okay, so we'll focus on the case of stuff and then we'll talk about other forms of on chain resource later on. Okay, so how do we want to model stake? Okay, so we'll suppose there exists an initial stake distribution. Okay, so this just allocates some non zero amount of stake to some finite subset of the players.
00:06:53.725 - 00:07:38.057, Speaker A: We'll suppose that transactions are issued by an environment. And we'll suppose there exists a stake allocation function S for any set of transactions T s given the initial state distribution. And that set of transactions then allocates a certain amount of state to each player. Okay, so the stake allocation function just given any set of transactions basically decides who owns what. Okay, and then on chain resources basically only make sense in the context of blockchain protocols. So how we can talk about those? Well, suppose that each blockchain protocol specifies some confirmation rule C. Okay, and this is a simple thing.
00:07:38.057 - 00:08:26.817, Speaker A: Basically the confirmation rule is just a function that takes all the all the messages it receives and decides which of those are confirmed. Okay, so in particular, but we're allowing here that you can confirm arbitrary messages, but generally you might want to focus on the case of messages which are actually transactions. Okay, so it's a timeslot T. If M is the set of all messages received by P at previous timeslots, then P regards the messages in C of M as being confirmed. Okay, and then we can specify standard notions of liveness and consistency. So I'm going to assume that people are so familiar with these ideas, I won't bother going through the details here, but you can obviously write down formal definitions of these. So roughly speaking, as I hope people are aware.
00:08:26.817 - 00:09:05.637, Speaker A: So liveness is the idea that transactions that don't conflict with others eventually become confident, confirmed and consistency Essentially means honest players agree on the set of confirmed transactions or eventually agree. Okay, and then we need to define what we mean by a row bound an adversary. Okay? And this definition will be fairly straightforward, fairly natural. So first of all, let's talk about execution. So we'll say that an execution of a protocol is row bounded. So let's deal with external resources first of all. So first of all.
00:09:05.637 - 00:10:21.409, Speaker A: So resource allocations corresponding to external resources each allocate the adversary at most a row fraction of the total resources at each time slot. Okay, so we're going to assume, for example, if you're using hash rate as one of your external resources, we'll assume that each time slot the adversary has at most a row fraction of the total hash rate. Okay, and then with respect to stake, there's actually a number of different ways we could proceed. But first of all, to begin with, we're going to go with the sort of the obvious way of writing things down, which I think is the way that people normally think about things, and we'll discuss this again later on. Okay, so with respect to stake, we'll make a fairly natural sounding assumption. So we'll suppose that amongst active players, Byzantine players never control more than a row fraction of the stake, or more formally, for every honest player P at any time slot, T if TR is the set of transactions that confirm for P at T in its execution, and at most a row fraction of the stake allocated to players active at T by that set of transactions is allocated by Dante players. Okay, so as I say, this might sound like a fairly sort of natural condition, a natural definition, and we've written this definition down this way because I think this is the way that people normally think about proof of state protocols.
00:10:21.409 - 00:11:13.075, Speaker A: This is the assumption people normally make. It's worth pointing out though, that this is in some ways a slightly odd condition to assume. Why? Because it's as much an assumption on the protocol as it is on the environment that's issuing the transactions. So you might ask, why is it reasonable to assume that this is true for arbitrary protocols? What happens if some crazy protocol actually tries to confirm Byzantine transactions, for example? It's not clear this is necessarily going to be a reasonable assumption to make. Okay, so we'll come back and we'll examine that deer later on. I guess ideally what you might want to do is to replace it with an assumption on the transactions issued by the environment. As we'll see later, there are some various complexities in doing that, but that's also an approach you can take.
00:11:13.075 - 00:12:26.845, Speaker A: Okay. So as it says down, this may seem natural, but it's potentially problematic, and we'll come back to consider this later on, okay? And then just a few more basic definitions. So when we say that the adversary is row bounded, we mean that we restrict attention to row bounded executions, okay? So this definition here with respect to executions, okay? And then we can extend that definition. When we say the adversaries row bounded, we mean that we restrict attention to row bounded executions, okay? And we'll say the protocol is row resilient when it satisfies a certain claim functionality under the assumption that the adversary is row bounded. So in particular, if we're talking about blockchain protocols, when we say our protocol is row resilient, we mean that it sets this live alive and consistent under the assumption that the reverse is row bounded, okay? So that at a high level, in a way describes the way in which we're going to model root resources, both external and on chain. So in the next video, what we'll do is we'll use that definition to then define the fully permissionless setting with resource restrictions. Now.
00:12:26.845 - 00:12:27.765, Speaker A: Okay, so I'll see you there.
