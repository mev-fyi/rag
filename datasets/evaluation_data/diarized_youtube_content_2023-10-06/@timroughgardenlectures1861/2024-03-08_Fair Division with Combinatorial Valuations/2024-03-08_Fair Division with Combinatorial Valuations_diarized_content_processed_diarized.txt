00:00:00.330 - 00:00:31.286, Speaker A: Thanks norm. And thanks to Shahar and the rest of the organizers for the invitation to come speak. Always excited to come to Israel. Been here many times. I do have to say now that I've moved to the east coast, I'm especially excited to come visit Israel for. Thanks for having me. Before I forget, everything I'll say is joint work with Ben Klauut, who's an excellent PhD student at Stanford, working primarily with Ashish Goell, but also on this project with me.
00:00:31.286 - 00:00:55.050, Speaker A: I'll tell you about a sample of results from two soda papers over the last couple of years. Fair division with combinatorial evaluations. So let's go ahead and jump right into the setup. The first few ingredients will look very familiar from a couple of previous talks today, if not other things you've studied in the past. So we're thinking about a situation with n players. We're thinking about there being m goods. These goods are indivisible.
00:00:55.050 - 00:01:33.830, Speaker A: So a good has to be given entirely to a single player. It cannot be split. And players preferences are encoded with a valuation, a set function which just says, what is the value for a given bundle for that. Okay, so it specifies two to the end, different numbers, one for each bundle that they might receive. All right, so what valuations do we want to look at? Well, very much in the spirit of Tomer and Segal's talks earlier today, we're going to be looking at a range of valuation functions. I believe all of these classes have already appeared today, so I don't want to belabor most. So the biggest is just going to be general monotone functions.
00:01:33.830 - 00:02:07.140, Speaker A: And then we have subaditive, submodular and additive. So as far as the definitions, again, this is not for you to memorize. I think many of you have seen this so subaditive. This is exactly what Tommer's talk was about, and it's just like it sounds. It says the value for the union of two bundles should be at most the sum of your values for each bundle. By itself, Zagal's talk was primarily about submodular valuations, which is a stronger condition, which is just about diminishing returns. So it says as you get more and more items, your marginal value for additional items is only going down.
00:02:07.140 - 00:02:50.482, Speaker A: And then the most extreme would be an additive valuation. And so, unlike these three, which you need two to the m numbers in general to specify them, an added evaluation you can specify with only m numbers. So the assumption is you have some value for each of the items and for a set of items, your value is just the sum of your values for the items in the same. So obviously positive results are more interesting the further you go down. Negative results are more interesting the further you go up. All right, so I've deliberately misled you with these first couple of slides, trying to trick you into thinking this is going to be a talk about mechanism design and specifically combinatorial options. Because everything I've said up to this point, many of you have seen in literally dozens of talks on commeratorial options.
00:02:50.482 - 00:03:36.930, Speaker A: So this is not what I'm talking about. But how would the rest of the model look like if I were? Well, the next step, you'd say what you want. And generally you take an optimization approach. You'd like to say, of all the allocations in the world, all the way of partitioning the goods amongst the players, you'd like one that say, maximizes the social welfare, the sum of players'values, for the items that they receive. When you take the mechanism design approach, and this is in contrast to restraft's talk that we just saw, you generally assume that there are payments, the monetary transfers are possible, or it's a so called transferable utility setting. And then usually one of the goals is incentive compatibility. So you'd like to set up your allocation algorithm and your payments so that, for example, truthful revelation is a dominant strategy.
00:03:36.930 - 00:04:03.878, Speaker A: So that's what you'd normally do. It's not with contra auctions. That's not what I'm doing today. The first set of ingredients is, as I discussed, but the rest is different. We're not going to be optimizing anything per se. In lieu of optimization, we're going to insist we want to compute an allocation that meets certain fairness constraints. I'll have a lot more to say about what those constraints are exactly in the next few slides, but so, rather than optimize, compute a fair allocation.
00:04:03.878 - 00:04:50.626, Speaker A: And most work in fair division also assumes a nontransferable utility setting where there's no monetary transfers, unlike what you see in commtorial auctions. And as a consequence of these two differences, as a consequence of not doing welfare maximization, and moreover, not having monetary transfers. A lot of work in fair division, including everything I'll say today, punts on incentive compatibility just ignores it. So on commercial auctions, you assume that valuations are private and you need to elicit them from participants. Today, I'm just going to assume that players are not strategic, or if you prefer, that all of the valuations are publicly known. Okay? And that's because again, it just seems hard to get both interesting fairness properties and sense compatibility, especially with indivisible goods. Though I have to say, looking through the literature, it felt.
00:04:50.626 - 00:05:36.886, Speaker A: Thank you. I feel like there's some work to be done in formalizing this. I feel like there's some general impossibility results that should be proved, saying one's strategy proofness plus fairness is impossible, plus more work doing identifying special cases where you can get both of them. But for the most part, when you focus on fair division, you wind up giving up on inceptive compatibility, and that'll be true for me, for me today. All right, so if you're maximizing welfare, you can ask approximation questions and other stuff. If you're not optimizing something, what kind of questions can you ask? Well, we're going to be asking the same questions you would ask about, say, an equilibrium concept. So, first of all, for whatever our definition of a fair allocation is, is it guaranteed to exist? Well, there always be one in every setting of interest.
00:05:36.886 - 00:06:28.126, Speaker A: And of course, you also are interested in efficient algorithms independent of the answer to number one. Okay, if you have guaranteed existence, you'd like an efficient algorithm to actually compute the fair allocation. If you don't have guaranteed existence, you'd like an algorithm that decides whether or not the fair allocation exists. So all of the theorems I discussed will be addressing one of these two questions. All right, so how should we define a fair allocation? Well, what we're going to do is we're going to look at the much more classical divisible case of fair division, look at what the most famous notions of fairness are there, and translate them over into the indivisible case, which I'm interested in. Okay, so indivisible goods is not the usual setting for fair division. The classical setting involves a divisible good, also called a cake.
00:06:28.126 - 00:07:14.550, Speaker A: In this context, known as cake cutting. Problems and valuations are, in effect, additive over the particles in the cake, if you like. And I'm sure you're all familiar with the cut and choose protocol for the two player case. This only goes back at least as far as the Bible with Abraham and lot, or, as Ariel Krakacha likes to say, reinvented by siblings every day all over the world. So how does it work? The first player cuts the cake in half, by half, I mean, into two pieces, so that player one is indifferent between the two pieces, has equal value for each. The second player then picks whichever of those two pieces she prefers. That's gunshoot's protocol.
00:07:14.550 - 00:08:04.054, Speaker A: I don't know about you, but when I was first told this when I was six years old, or whatever, it was proposed to me as if it was some kind of fair protocol. But now we're all adults know how to do mathematics, we can ask the question, in what sense actually is this protocol fair or is it? Well, there's a bunch of things you can say about it. Let me say two things. So the first good thing you can say about it is that in some sense, each of the players is guaranteed at least their fair share of the cake, meaning they get at least 50% of their value for the full cake. Okay. This is true for player one because it actually explicitly splits the cake into two pieces, which are 50% of the value in each. And obviously, pL2 will choose whichever one is better, which will be at least 50%, possibly, possibly more.
00:08:04.054 - 00:08:31.840, Speaker A: And of course, there's a sense that this is the best you could do. You couldn't guarantee both players 51% of what they wanted, in particular if they both wanted exactly the same set. So that's good. That's sort of a basic sandy check. Each player gets their fair share in this sense. The second thing you can say about it is that the allocation is envy free. What does that mean? That means neither player would like to exchange their bundle, their part of the cake, with the other.
00:08:31.840 - 00:09:12.714, Speaker A: Each player is happier with theirs than they would be had they been given the other player's piece of cake instead. Again, for player one, this is sort of trivial, right? Because player one explicitly made the pieces, so she was indifferent between them. So there's not going to be any envy, doesn't care which one they get. PL2 will obviously not envy player one because she explicitly took the one she liked more, and then player one got the other. One thing that's a little funny, by the way I set up this slide is in this particular setting, these are actually the same property, if you think about it for a few seconds. But as soon as you get beyond the sort of two player additive type case, these are different properties, proportional, and then be freeness. We'll study both later in the talk.
00:09:12.714 - 00:09:36.010, Speaker A: So I wanted to just sort of single them out. Single them out here. All right. So these are sort of fairness notions for the divisible good case that are very well studied. And it's straightforward to translate them, at least sort of syntactically to the setting I'm looking at of indivisible goods. So now let's go back to the. Let's think about n players.
00:09:36.010 - 00:10:17.230, Speaker A: So an allocation is n subsets, it's a partition of the items, and we call it proportional. Again, if each player gets in some sense their fair share. Okay? Meaning if we look at the value that the player has for all of the items, they get at least a one over n fraction of that, where n is the number of players. Okay. Turns out, for all of the questions I'm talking about, and very often in fair division, you can scale valuations without harm. And so if you want, you can assume that everybody has value, one for all of the items. So sometimes for proportionality, I'll just write one over n on the right hand side, assuming that we scaled each valuation accordingly.
00:10:17.230 - 00:10:55.840, Speaker A: So that's proportional, you get at least a one over nth fraction of your value for everything, nb freeness. So this is now an allocation where again, no one would want to swap bundles with anyone else. So for every player, I and every other player, h I is happier with their own bundle than I would be with the other player's bundle. That should be true for all pairs of players, no player, and be any other player. So, questions, those are the two. We're going to be looking at relaxations of this shortly. But this is our starting point for talking about fair allocations, proportional and nd free.
00:10:55.840 - 00:11:37.392, Speaker A: Great. So what did I say were the kinds of questions we wanted to study? Guaranteed existence and then efficient algorithms. So guaranteed existence in the divisible case. Actually, you do always have envy free allocations and you always have proportional allocations under weak assumptions. So how about in this indivisible good model, guaranteed existence, either for proportional or envy free allocations? Kind of. Obviously not, actually. Right? Because suppose there's only one item, both players want it, it's indivisible, you got to give it to one of them.
00:11:37.392 - 00:12:18.540, Speaker A: You're not going to be proportional, you're not going to be mv free. Okay, obviously, hopefully you're like, oh yeah, we should be able to get around this somehow. And you're right, that's where we're going. But this is the immediate obstacle to just using off the shelf these proportionality and view freeness notions. So what kind of relaxations could you look at? Well, one obvious one, which won't help with the immediate question, but will be interesting later, is to say, well, let's just assume that proportionality, or earned euphrenus conditions, they only have to hold up to a constant factor. So for proportionality you could say, okay, well, maybe I don't want to make, maybe not everybody gets one over n, but they at least get 0.5 over n, something like that.
00:12:18.540 - 00:12:43.300, Speaker A: After scaling the valuations, there'll be a relaxation of proportionality. C here is between zero and one. Nb free you would say. Well, maybe a player envies someone else, but only up to a constant factor. So their bundle, they value their bundle, at least say half of their value for any other bundle. Notice this doesn't help with this example at all. If C is positive, you're still not going to have a C proportional or a CNB free allocation.
00:12:43.300 - 00:13:43.796, Speaker A: So what else could you look at? Well, for the next part of the talk, I'm going to be talking a lot about this notion of EFX allocations, which is a relatively recent proposal, so I want to make sure everybody understands it. So remember, envy free says you wouldn't want to swap bundles with anybody. EFX envy freeness up to any good says you wouldn't want to swap bundles with anybody if they accidentally dropped one of their items on the floor. Okay, so maybe I have value ten for my bundle. There's a second player where I have value twelve for their bundle, but no matter which item you take away from that player, my value for the resulting slightly smaller bundle would drop below ten. So for every other player, maybe I envy them, maybe I envy their bundle, but I wouldn't envy them if any one of the items went away. Okay, notice certainly this bad example is not relevant for EFX.
00:13:43.796 - 00:14:18.172, Speaker A: If someone only has one item, you're never going to envy them in this sense, because you take away that item, they have nothing, you're not going to envy them. So this is an important definition for us. So just give you a second to stare at questions. Okay, good. So we're going to be interested in EFX allocations when they exist. Can we compute them just for completeness? EFX was proposed as a strengthening of an earlier concept, EF one proposed by Buddhist. This is a weaker condition.
00:14:18.172 - 00:15:08.544, Speaker A: It just says for some other player you may envy them with their current bundle, but there exists a good that I could take away from that player so that I would no longer envy them. EFX says no matter which item you take away from this other player, I don't envy them. EF one just says there exists an item, we're taking it away, gets rid of the envy. What do you assume on additive? No, in general I'll be interested in non additive value. I don't know if there is one product which give me a negative reward and then remove it higher, right? So I will be assuming valuations are monotone. I said at the beginning, but very quickly. So this is a good time to reiterate that.
00:15:08.544 - 00:15:23.188, Speaker A: And that is important. Montanicity comes up quite a bit in the proofs. Sometimes we'll make stronger assumptions, but we always at least assume monotonicity. Okay, thanks for the question. Okay, so EF one will not really play a role in this talk, so don't worry about it. Just want to do that for completeness. EFX will.
00:15:23.188 - 00:15:54.408, Speaker A: Okay, so if there's any questions about the effects definition, now is your time. Any organization except the technical issues that you need to overcome either. Yeah, you just want to get as close to. You can't be any free. You just wanted to say you're as close to envy free and provable senses as possible. Yeah, like when you can't get what you want, you try to do the next best thing. So all of this is a struggle to define what is the next best thing when you can't have envy freeness.
00:15:54.408 - 00:16:36.908, Speaker A: And definitely I'm not claiming that there isn't some fit relaxation that makes more sense waiting to be discovered. All of these, I think, are reasonably natural and playable in this thought. Okay, great. So we were talking about guaranteed existence, remember? So we had this bad example, still a bad example for CProp and CEF. Not a bad example for EFX or EF one. So we can ask the question again about guaranteed existence of an approximately fair allocation of one of these things. This actually is a reasonably big open question in this part of the world, specifically whether or not EFX allocations are guaranteed to exist.
00:16:36.908 - 00:17:10.812, Speaker A: So if there's any students in the room sort of looking to make a big splash with kind of a nice result, this is a problem you can think about. It's probably pretty hard. Smart people have thought about it, but a lot of people would be interested to see some progress on that. And if you're an optimist, you should ask for what's the simplest setting where we don't already know guaranteed existence. And that simplest setting would be three players with additive evaluation. My knee jerk reaction when I see that is, come on. I don't know if it's true or false, but surely we can figure out which it is.
00:17:10.812 - 00:17:36.564, Speaker A: Three players, additive valuations. That's exactly what seduced so many people have been thinking about it, and no one solved it yet. So we'll see if you're a pessimist. If you wanted to prove a nonexistence result, that's obviously going to get easier. The more general you make things so the most general we could get would be any number of players with just arbitrary monotone valuations. We don't even know nonexistence in that case. I don't think that very few people have thought about that.
00:17:36.564 - 00:17:53.080, Speaker A: So that might not be that hard, but it would be nice to see that resolved. All right. But we don't know, we really don't know whether these are guaranteed to exist. The weaker notion of EF one allocations are always guaranteed to exist. Even the general case, or general, even in the general case. Yeah. And it's a pretty simple proof.
00:17:53.080 - 00:18:20.916, Speaker A: It's not in the talk, but I'm happy to give you the proof after the talk. It's just a five minute proof. Yeah, simple algorithm. Good. So the next year results are going to be what we could. So we did not resolve this question, Ben and I, so I'm just going to tell you some of the things we did do around this question. So, looking for cases where you do have guaranteed existence, looking for algorithmic lower bounds and algorithmic results and so on.
00:18:20.916 - 00:18:49.260, Speaker A: And for starters, I want to show you a protocol that produces an EFX allocation when you have two players. That's a big assumption of the number of players, but there's going to be no assumption on the valuation. These are totally general monotone valuations. You do have guaranteed existence there. Question is the hardness, for example, three players coming from the many items? Yes. Well, okay, good question. So people have done that.
00:18:49.260 - 00:19:28.708, Speaker A: They've sort of incremented the number of items to see how far they could get. I'd also have to check again with the people that have been working on this, but like a year ago, I think four items, they proved it, but five they weren't sure. Or maybe they proved five, they weren't sure about six. So you need some, if there's a lower bound, you need at least some number of items. Good question. Okay, and before I get into this, I just want to warn you, if you look at the papers, the papers have a pretty different emphasis than what I'm doing. In this talk, most of the page counts of the two papers are occupied by sometimes elaborate lower bound constructions.
00:19:28.708 - 00:20:05.830, Speaker A: I'm not talking about those almost at all in this talk. Instead, I'm going to cherry pick a couple sort of short and sweet upper bound results. I'm doing that for two reasons. Reason number one, you've already been sitting in 6 hours of talks, and it seems a little hostile to hit you with sort of elaborate lower bound constructions at this point. Reason number two, I'm hoping to tantalize a few of you, and that may be thinking about some of these problems. And I'm hoping the best way to do that is to give you some short and sweet results that you can maybe still remember when you wake up tomorrow morning. Okay, so claim guaranteed existence of EFX allocations when you have two players, no matter what their valuations are.
00:20:05.830 - 00:20:28.632, Speaker A: So two players, very natural place to start. Well, can you do some kind of cut and choose idea? Okay, so here's how this would work. So player one is going to propose a cut. PL2 will choose their favorite. We're not worried about pL2. So pL2 is given two options chose. The better one is certainly not going to wind up end being the other player.
00:20:28.632 - 00:21:15.128, Speaker A: So pL2 is going to be fine. Player one is responsible for doing the partition so that no matter which side the second player picks, the EFX condition will hold. So in other words, player one needs to cut partition the items into two sets so that if the player winds up getting the first one, she will not envy the other player after deleting any item. Similarly, if the first player winds up getting the second piece should not envy the other player after deleting any of their items. Now, if player one can do this, if player one can find such a partition, then we are in fact done for the reasons we discussed. PL2 is always fine, even nd free. Forget about EFX.
00:21:15.128 - 00:21:58.440, Speaker A: And then this makes player one satisfy EFX by construction. Why was this an interesting thought experiment? Well, this first step, this is actually equivalent now to finding an EFX allocation between the first player and a copy of itself. Two players, both with the same valuation, v one. So what this is accomplished, it's reduced the two player general valuation case to the two player general valuation, but identical valuation case. If we can solve that, we can solve the case where the two valuations are different. Everyone okay with that? All right, so we can do that. So let me now show you how to solve the case of two players with the same valuation.
00:21:58.440 - 00:22:31.316, Speaker A: This algorithm and argument actually works for any number of players with a common valuation. But let me just do it for the two player case, the relevant one for us. So the protocol is local search, basically. So you start with any allocation, any partition of the good. If it's e of x, great, you're done. If it's not EFX, well, what does that mean? What does a violation of EFX mean? It means one of the players say the first player is unhappy. What does it mean they're unhappy? Well, so they have some value for their bundle, maybe ten.
00:22:31.316 - 00:23:05.650, Speaker A: They would have value, say 20, a higher number for the other bundle. But not only that, even after you delete an item from that other bundle, its value would still be higher than ten. It's going to be lower. But let's say it's still something like 15. That's what it means if your allocation is not EFx. Now what do we do? We just take this good j we take it away from the second player and we give it to the first player. This could, of course introduce other violations of EFX, and there can be violations in two different ways.
00:23:05.650 - 00:23:38.490, Speaker A: First of all, perhaps player number one is still unhappy. Yeah, its value for its bundle got a little bit bigger. Its value for the other bundle got a little bit lower. But maybe there's still a big gap and it's still unhappy. Or maybe we introduced a violation for player number two. Maybe adding this good to the first bundle made it so valuable that now actually the second player has gotten jealous. And if that happens, then goods are going to start flowing in the other direction from player one back to pL2.
00:23:38.490 - 00:24:25.448, Speaker A: So pretty clear that if this protocol terminates, we're good. Terminates with an EFx allocation, obviously, but with goods flowing back and forth, why would it terminate? Why wouldn't it cycle? So it turns out it can't cycle, which presumably means there has to be some kind of monsonicity somewhere, some kind of potential function argument. And there is. And the quantity we're going to track is the minimum value of the two sets, the minimum value of s one and s two. So the claim is this only goes up over time. Let's see why. So let's again consider this situation where we move an item from the second bundle to the first one.
00:24:25.448 - 00:24:57.300, Speaker A: That means the value of the second bundle will only go down, the value of the first bundle will only go up. But notice the value of the second bundle will not get any smaller than the original value of the first bundle. So you used to have value ten for your bundle. The other bundle is 20. You remove an item, it drops to 15. Yeah, it went down, but that 15 is still bigger than the ten, and that's because of the EFX violation. All right, so if the value for the second bundle dropped below the original value for the first, then it actually wouldn't be an EFX violation.
00:24:57.300 - 00:25:31.180, Speaker A: Meanwhile. Okay, so what do we have? So we have this goes down, but it doesn't go down farther than the original value of the first item, first bundle. This has only gotten bigger and valuations are monotone. So this only goes up if this strictly increases when you add good j to it. Then the smaller of the two values has increased for sure. It is possible that actually adding j to s one doesn't add any value, in which case this stays constant. But then now player one has one more item, and every time this happens, player one is just going to keep getting more and more items.
00:25:31.180 - 00:26:06.168, Speaker A: Yeah, I'm kind of right. So the player that has s one, I should say. But maybe next step it will be the other player with s one. Good. So there's a subtle point which says that actually, while you're in this case too, the roles of the players do not reverse. Okay, it's going to be the same player who's unhappy throughout, because remember, when was the case when it flipped? That was when adding j to s one made this so valuable that all of a sudden pL2 became envious. And we're actually saying not only does it not add a lot, it adds nothing.
00:26:06.168 - 00:26:55.490, Speaker A: So it'll still be the same player playing the same role every time you're in case two. It's a subtle point. So this can only happen m times in a row before you either terminate or before this happens. This can only happen a finite number of times before you stop necessarily getting. So, questions guaranteed existence of VFx when you have two players, any valuation, one question you might have would be about the efficiency, or lack thereof, of the protocol. At least with the termination proof that I gave you, there's no really interesting bound on how many queries are needed, because in principle, this number could increase an exponential number of times. Exponential in the number of items m.
00:26:55.490 - 00:27:39.048, Speaker A: So you could ask, is there a better analysis of this algorithm which proves a polynomial bound? Or maybe there's some different protocol also guaranteed to produce an EFX allocation that needs only a polynomial number of queries. Those would be natural questions. The answer to both is no. So even in this simple case of two players, actually, even in the case where they both have the same valuation, actually, even when that common valuation is submoduular, there is no way of guaranteeing. At this point, we know an EFX allocation exists. So it's a total search problem at this point. Remember, the last algorithm shows guaranteed existence when you have identical valuations.
00:27:39.048 - 00:28:12.868, Speaker A: So even in this case, where you know one exists, an exponential number of queries might be required in the worst case to find. So there's no algorithm better in the worst case than the one I just showed you. When you start from an arbitrary allocation, what if you start from a random allocation? It's not going to help. I agree it's not obvious from what I've said, but that will not. This is a pretty robust lower bound, actually, it turns out. Okay, so I promised the talk is not going to be about lower bounds, and mostly it's not. This is the only slide that has any lower bounds.
00:28:12.868 - 00:28:48.448, Speaker A: So this is the result, exponential lower bound on the query complexity of computing an EFX allocation, even in a simple setting where they're guaranteed to exist. How does the proof go? Let me just paint sort of very broad strokes and ignore all the details about how you stitch these variance ingredients together. So the first step is we draw a connection between computing an EFX allocation and computing a local maximum in a graph. So let me explain what I mean. So here's just a problem you can think about. There's some graph, think of it as exponentially big. You know all the vertices, you know all the edges.
00:28:48.448 - 00:29:32.132, Speaker A: What you don't know, each vertex is labeled with a number and you do not know the number of any vertex. You can query a vertex to find out its number, but queries are expensive and you don't want to use too many. And your goal is to identify a locally maximum vertex. So vertex whose label is at least as big as all of its neighbors. So that's what I mean by local search in a graph. So the first thing we do is we show that even this special case of finding any of x allocation can encode the problem of local search in a specific type of graph, the Knesser graph, which is a generalization of the Peterson graph, knizzer graphs. Vertices correspond, so you have a ground set.
00:29:32.132 - 00:30:16.588, Speaker A: Vertices correspond to subsets of a given cardinality, and you have an edge between any pair of subsets. What's your disjoint? And Peterson graph is a special case of that. So it turns out that if you could always compute an EFX allocation, you could always find a local maximum in a Knesset graph. So of course, now the question is, it's like, well, how should I feel about that? Is it hard to find if it's a clique? Obviously it's hard to find a local maximum because you have to verify that all of the neighbors are only smaller. But kinesit graphs have logarithmic degree, roughly so it's not so clear. But this has been studied. There's an old result by Lulin, Toby and trick, who show that if your graph is a good vertex.
00:30:16.588 - 00:30:49.980, Speaker A: So even if it has bounded degree, as long as it's a good vertex expander, local search is hard. Everything I'm saying right now is deterministic, because this is a query complexity, lower bound randomization doesn't make that big of a difference, so it's kind of black box. The deterministic lower bounds become not quite as good, but still exponential lower bounds for random bounds. So I'm going to go ahead and just focus on the. Yes, yes, exactly. Good point. Okay, good.
00:30:49.980 - 00:31:44.760, Speaker A: So local search on a vezograph, hard or easy? Well, Lulin and I'll reduce it to showing that these graphs are good vertex expanders, and we were totally ready to roll up our sleeves and just kind of directly analyze these meso graphs and prove that they were good expanders. Turned out an MIT student, as part of a course project about three years ago, conveniently just in time for us, actually did exactly this. We checked the proofs very carefully, because we're not used to kind of relying on undergraduate course projects for keywomas in our paper, but it totally checked out. So Zenx course project indeed verifies the Kinesio graphs have good enough expansion for this lower bound to hold. Okay, when I say local, search hard, what I mean is you have to query more or less all of the vertices. And again, the graphs have an exponential number of vertices in our construction. All right, that's all I wanted to say about the lower bound.
00:31:44.760 - 00:32:39.260, Speaker A: Unless there are questions, then let me say one more thing about the effects allocations. I'm going to say this primarily because there's some very nice open questions here. So we talked about two ways of relaxing envy freeness. One would be to say only up to a constant factor, and the other was the sort of EFX idea of removing a good there's no reason you can't combine those two relaxations. So one half EFX would mean that a player doesn't envy any other player more than a factor of two after you delete an item from that player's bundle. So that's what I mean by one half EFX, and we can show actually guaranteed existence for this relaxed concept for any number of players with subaded evaluations. The proof of this is also pretty short and sweet, and actually related to the proof I mentioned in norm about guaranteed existence of EF one earlier.
00:32:39.260 - 00:33:15.956, Speaker A: But it's something I cut from the talk, but it's pretty easy to explain. So if you want to know the proof of this, just ask me after, or I'll be at Weitzman tomorrow and Tuesday as well. So ask me anytime during this visit and I'll tell you how it goes. So this is something we can prove. And again, I present to you mostly just because it presents lots of paths. So there's this big question of how generally do EFX allocations exist? And here we have a couple different dimensions along which to kind of approach the problem to break it into smaller steps. So obviously you might want to improve this one half to two thirds or three quarters.
00:33:15.956 - 00:33:53.280, Speaker A: Sorry, just to review, for all we know, you still have guaranteed existence even with a one half replaced by a one, and with sabbatic evaluations replaced by all monotone valuations. For all we know, you have guaranteed existence all the way out there. So the question is, just close the gap between this result and general existence of DfX. One dimension along which you can try to get closer is by having a better constant one half. Another way you can do it is by looking at a more general valuation class beyond sabbatical. Both of those are interesting. Another open question here is unlike so our construction, it's a simple algorithm, but again, it seems to be exponential.
00:33:53.280 - 00:34:28.880, Speaker A: And here we actually don't have an exponential query lower down. So it's also an open question whether or not you can compute these with a polynomial number of queries. Interesting question. All right, so that's kind of the first main part of the talk. I do want to spend a few minutes on a communication setup. This is from the second paper, so this is a good time for questions. If you have about all the stuff on EFX allocations and query complexity, maybe it's obvious, but also three bright.
00:34:28.880 - 00:35:02.600, Speaker A: I did not say it. It's a good question, and the answer is no. So in the case for the protocol I showed you, for two players, it actually will attain Pareto optimality. More generally, with end players with a common valuation, our protocol does give you Pareto optimality. Yeah. In general, in fact, it's not even. I believe there are examples with sufficiently weird valuations.
00:35:02.600 - 00:35:16.130, Speaker A: Say general valuations. With common valuations, everything is spread off. Say it again. With common valuation. Sure. Right. Good.
00:35:16.130 - 00:36:23.252, Speaker A: For general valuation, it's even known there need not exist a Pareto optimal EFX solution. So lower down in the valuation hierarchy you can get both, but all the way out, you actually prove you can't get both at once. Yeah, so it's a great resume. You think you said that if v one equals v two equals, all the elevations are the same? Exactly. So basically this same algorithm, pseudo generalized and even the same argument still works. Basically what this is, this is like lexographically minimizing the values, plus with an additional tiebreaking that if you have multiple sort of lexigraphically optimal strings, you want to maximize the number of items given to the worst off person. So that's actually how it's written in the paper.
00:36:23.252 - 00:36:56.490, Speaker A: It's not like a refinement of graphic ordering with this property. Other questions on EFX and query complexity. Great. So I want to mention a little bit about the work we've been doing in communication model. So previously we were just thinking about all the valuations as just sort of being known. And out there in the communication setup, we think of the valuations as being private inputs. So now each of the players knows their valuation up front, has no operatoric knowledge about anybody else's valuation.
00:36:56.490 - 00:37:32.876, Speaker A: We're looking for a communication protocol by which the players can sort of send bits around, and ideally at the end of the protocol, they've all identified a fair allocation, or perhaps figured out that no fair allocations exist. And I'm pleased to say so. There's also a parallel line of work going on for the divisible case, which is also super interesting by Noam and Simina Bronzai, and that's nicely complementary to the stuff I'm talking about on the indivisible case. So for this part of the talk, I'm going to focus on those first two relaxations I mentioned. So, just to remind you. So we're going to take proportionality. So think of the scaling.
00:37:32.876 - 00:38:25.900, Speaker A: All you scale everybody's values, so the value for all of the items is equal to one. And we want each of the players to get their fair share up to a constant c. Think of c as a half, say c and d freeness. Again, you don't want to swap bundles with anybody up to a constant factor. Okay, so say your value is at least half of the value you have for any other body. We know that these are not guaranteed to exist even when we have one item, but it's still interesting to ask, can you detect when they exist? And when they exist, can you compute one? And that will be the computational problems that we look at. And as usual with communication plus complexity, the question will be, do you need an exponential amount of communication? Would be exponential here in the number of items m, or is polynomial communication sufficient? Notice a player's private input.
00:38:25.900 - 00:38:54.590, Speaker A: That's a full blown set function. That's a vi that has two to the m numbers in it. So polynomial communication is really saying logarithmic in the description length of the private inputs. So it's a strong thing to want. So when is it polynomial and when is it not? So the answer to this question is going to depend on a lot of things. It's going to depend on how many players you have. It's going to depend on which of these two properties you choose.
00:38:54.590 - 00:39:29.156, Speaker A: It's going to depend on what value of c you want, and it's also going to depend on the valuation class that you're looking at. Okay, so let me just sort of hit you with a table that summarizes some of the results. This whole table is about the case of two players and deterministic protocols. We think about the other cases as well, but this is where almost all of the action is two players, deterministic protocols. All right, so what's true? So let's see. So for unrestricted valuations, not much is true. So let's ignore that.
00:39:29.156 - 00:39:59.644, Speaker A: So that additive gets pretty funky. So for proportionality, it turns out if C is two thirds or less, there's a polynomial communication protocol. Deterministic. If C is bigger than two thirds, there is not. With nb freeness subadive evaluations, the magic threshold is one half. It's easy if C is one half or less, hard if it's bigger than one half. Let's go to the easier case of submodular, where we might hope for stronger results.
00:39:59.644 - 00:40:30.408, Speaker A: And we do get them here, it turns out, checking for a proportional allocation. Exactly. That can be done in polynomial communication. I'll show you that on the next slide. Maybe the most complicated result is this one about submodular, which is, I guess, what I'd call a polynomial communication approximation scheme. PCAs doesn't sound very good, in my opinion. So what does that say? It says, if you want to exactly check nv freeness with some modular evaluation, you can't do it takes exponential communication.
00:40:30.408 - 00:41:16.700, Speaker A: If you're happy with a one minus epsilon approximate and vfreness, you can do that in polynomial communication. For each fixed epsilon, the dependence on one of epsilon is exponential. It's not a fully polynomial communication approximation scheme, but for fixed Epsilon, you can do it with polynomial communication. All right, so what I want to do in my remaining time is tell you a little bit about this bottom right corner. Any questions before that should be. But let me think about that. Yeah, I guess not really, right, because.
00:41:16.700 - 00:41:44.978, Speaker A: Yeah, I'm not sure, I mean, for existence, obviously, there's montanicity I'd have to check somehow in our reductions. It's clear that it's filed. Whether you can black box it, I'm not sure. Yeah. So for the case for two players, there always is. Oh, this is CMB three, not CME, correct? Yeah. So no one's catching a sort of sleight of hand I did to you, right.
00:41:44.978 - 00:42:15.710, Speaker A: I actually changed things in two ways at once, and I kind of only told you about one of them. I told you that I was going from query complexity lower bounds to communication complexity lower bounds. I should have said, why that's interesting. So, generally, it's just stronger to prove communication complexity lower bounds. Lower bounds are more interesting when they're for communication complexity than fluoride complexity. The other thing is, I'm no longer looking at EFX. I'm looking at EF or CEF.
00:42:15.710 - 00:42:39.270, Speaker A: You could, of course, talk about the communication complexity of computing an EFX allocation. That's actually an open question. I'll put that on the last slide. One thing that's weird is computing an EFX allocation. We don't know whether or not it's a total search problem. And presumably the hardness reduction is going to look different in the two cases. I would think maybe that's not a big barrier, but that's sort of where we're conceptually stuck.
00:42:39.270 - 00:43:08.690, Speaker A: All right, so we're not talking about e of x, we're talking about ef, we're not talking about query complexity, we're talking about communication flexibility. All right, so again, I owe you this bottom right corner proof sketch. Any questions before that? When you say easy to find. Yeah. So also the search problem. Okay, so here's the claim restated. So we're looking at two players.
00:43:08.690 - 00:43:39.650, Speaker A: They have sub modular evaluations, not necessarily the same one, and we want to deterministic polynomial communication protocol. The chips for proportional allocation, remember one need not exist. We've seen that. So what does this mean? So again, we've scaled the values of each of the players, so their value for everything is one. So with two players, proportional just means each of them gets a bundle that they value a half or more. That's what we want to know. Is there not an allocation with this property? Let me tell you the protocol.
00:43:39.650 - 00:44:21.150, Speaker A: Let's start with an easy case. If we get lucky, player one, of course, knows her own valuation, privately checks over all ways of partitioning the items to see if there's a partition, s one, comma s two, where she would be happy with either one, meaning her value for s one. Is at least a half, and her value for s two is at least a half. Why is this a lucky case? Well, now we can do cut and choose. Player one splits into s one, and s two doesn't care which one they get downstream. She has value one half. Either way, second player picks whichever one she prefers.
00:44:21.150 - 00:45:05.198, Speaker A: This is easy case, although actually, there's a little bit of a subtle point here. So the argument I just made would not have been true had I not assumed something like submodularity, or at least sub addativity about valuation. When you're talking about envy freeness, there's never a word, because it's just second player picks their favorite. They're certainly happier with their bundle than the other bundle proportionality. You actually have an absolute guarantee that you have to meet. You have to have value, at least one half. So cut and choose would not work if the first player passed over a partition where the second player had value less than a half for each.
00:45:05.198 - 00:45:36.694, Speaker A: Like, say it's a single minded bid, something like that. But we're assuming that the valuations are submoduular, in particular subaditive. So it is impossible for the second player to have value less than a half for both, no matter what the partition is. All right, so now we can agree that under the assumptions this is a happy case, we're just done. Okay, so suppose now that this case doesn't trigger. Okay, let me just say. So if this case doesn't trigger, that means player one.
00:45:36.694 - 00:46:24.546, Speaker A: It's never the case that both of these are at least a half. We just discussed. It can never be the case by subadativity that both of those numbers are strictly less than a half. So if this does not finish the job, we now know a structural property about player one's valuations, which is that no matter how you partition the item set, she has value at least a half for one and less than a half for the other. That has to be true at this point. Now, if pL2 only knew for each allocation, which was the side that the first player had value a half for, then the second player, Bob, could just finish privately by brute force. Basically, just look at each of the sets that Alice, the first player, would be happy to receive.
00:46:24.546 - 00:46:46.430, Speaker A: See if he would also be happy with the complimentary items. If so, great, that's a proportion allocation. If not, you've tried everything. Doesn't work, so you know that there isn't one. Of course, Bob does not know Alice's valuation. That's the whole point. And furthermore, Alice can't communicate her valuation explicitly, because that would be an exponential amount of communication.
00:46:46.430 - 00:47:22.954, Speaker A: So here's what we do instead. So Alice will communicate an approximation of her valuation, an additive approximation of her valuation. So the goods are canonically ordered in some way from one to m. Alice looks at her marginal values. So you imagine starting from the empty set, adding items one at a time until you have everything delta, sub j is how much Alice's valuation jumps when she adds good j, when she already has goods one through j minus one. So that's enough. That's one number for each item, the marginal value of getting that one.
00:47:22.954 - 00:48:11.846, Speaker A: Given you already have all of the previous goods, this is just m numbers. No problem to communicate these over to Bob. So Bob gets these m numbers and is like, well, I know these marginal values of Alice's valuation, but I don't know her valuation. Let me just assume that Alice's valuation is additive with what item values exactly? These marginal values, these delta j's. No, I mean, if Alice's valuation function really was additive, then these deltas would just literally be your values for the different items. Now that pL2 has this proxy for Alice's valuation, Bob's just going to do what we said before. He's just going to iterate over all allocations.
00:48:11.846 - 00:48:44.320, Speaker A: He's going to see if he can find one where according to his additive estimate of Alice's valuation, she has value at least half. And also he, with respect to his known valuation, to himself, has value at least a half if he finds one. He proposes that as proportion allocation. If he doesn't find one, he says none exists. So here the communication cost is the clear part. It's clearly a polynomial communication protocol. But correctness is not so obvious.
00:48:44.320 - 00:49:18.204, Speaker A: You have to think about correctness a little bit. In particular, we haven't used the sub modularity assumption yet. So here's why it's true. So let a one that's going to denote Bob's additive estimate of Alice's valuation, defined by these, defined by these deltas. Two quick properties of this additive approximation. It's a lower bound and it's tight at the set of all items. So let's start with the second one.
00:49:18.204 - 00:49:57.876, Speaker A: First, think about all items. We know that Alice's real value for all items is one just by normalization. What does the additive estimate give us for her values? It gives us the sum of the deltas by telescoping. So we also get the value for the full set or one, so they match exactly at the full set. And I'm not going to do this in detail. But basically, submodularity is used to argue that for any set, doesn't matter which one, this additive approximation will only be less. Basically because, let me just skip a lot of you have seen this argument.
00:49:57.876 - 00:50:38.084, Speaker A: If you haven't, trust me, it's just a couple lines of algebra. Sometimes Larry says the additive approximation is only less. Now, remember, we had this lucky case where Alice can find something where she has value, half for each. And so we only need to care about the unlucky case. And we argued that Alice has value at least a half for one and less than a half for the other. And if only Bob knew which was which, he could finish privately. And so, while the additive estimate is not going to be exactly the same as Alice's valuation, it's actually a perfect oracle for understanding whether Alice's real valuation is at least a half or less than a half.
00:50:38.084 - 00:51:43.100, Speaker A: That is, the estimated valuation of a bundle is going to be less than a half if and only if Alice's actual value is less than a half. Let's see. Why pick your favorite allocation, s one and s two. Let's say s one is the one that's less than a half with Alice's real valuation, well, the additive evaluation is only an underestimate, so that part of the partition will also look less than a half with respect to the estimate. On the other hand, the sum of Alice's values for s and s complement, because it's additive, is equal to her value for everything, which is one. So if her value according to the additive valuation for s one is less than a half, her estimated value for the other one has to be bigger than a half, exactly as it actually is with respect to her true valuation. So this additive evaluation is actually enough to carry out that last private sort of brute force search that Bob has to do to compute the proportional allocation.
00:51:43.100 - 00:51:53.500, Speaker A: All right, I think I'm over time, so let me just flash a slide with open questions, most of which I mentioned throughout the course of the talk, and I'll stop there. Thanks very much.
