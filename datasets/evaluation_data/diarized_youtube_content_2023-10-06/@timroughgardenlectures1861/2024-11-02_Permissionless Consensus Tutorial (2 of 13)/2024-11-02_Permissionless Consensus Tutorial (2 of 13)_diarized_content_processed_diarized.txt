00:00:01.920 - 00:00:35.347, Speaker A: Okay, welcome back, everyone. So this is video two of the tutorial. So in video one, I gave a basic overview as to what the tutorial is going to be about. So in particular, what I said was we're going to be introducing this hierarchy of permissionlessness, okay? So we have four different settings, starting from the most permissionless down to the least permissionless. It's a fully permissionless setting at the top with the permission setting at the bottom. So what we're going to be doing in this video is going to start introducing the fully permissionless setting. As I said last time, though.
00:00:35.347 - 00:01:24.017, Speaker A: So generally, if we're talking about permissionless protocols, then we're going to want to consider what we'll call resources of some kind. So resources are things like ASICS, memory chips, stake, etc. Just to begin with, though, I want to introduce first of all a version of the fully permissionless setting in which we don't yet get to talk about resources. Okay? So we'll introduce the fully permissionless setting without resources, and then we'll introduce resources later on, okay? And then as we move from the permission setting to the permissionless setting, actually what happens is that we introduce three new challenges all at once, okay? As detailed on this slide here, okay, so we introduce these three new challenges. This is what they are. So first of all, the set of distinct entities running the protocol is now unknown and of unknown size. Okay? Obviously, that's not the case.
00:01:24.017 - 00:02:07.335, Speaker A: In the permission setting, we have a fixed set of known participants, but now the set of the people running the protocol, we don't know who they are, we don't know how many there are. That's the first new challenge. Second challenge is that the entities running the protocol can now start or stop providing the protocol at any time. Okay? It can be active, then inactive, then active again, and so on. That's the second challenge. And then a third and distinct challenge is that now we have to deal with the possibility of civil attacks, okay? Each such entity can operate the protocol using unknown and unbounded number of identifiers. Okay? So we introduced these three new challenges simultaneously, which generally, I guess, might seem like a slightly sort of mad thing to do.
00:02:07.335 - 00:02:58.125, Speaker A: Generally, theoretically speaking, what you do, if you want to develop the theories, you introduce one new challenge at a time. You introduce one new challenge, see what that changes, then you introduce a second new challenge, and see what that changes, and so on. The reason that we do this, we introduce three new challenges simultaneously now, is that we have a change in motivation. Whereas previously, when we're talking in the permission setting, the aim is to deal with fault tolerance. Now our aim is decentralization. And it seems dealing with decentralization requires us to consider these three new challenges at once. Okay, so I should make it clear that I'm not going to attempt to formally define what we mean by decentralization here.
00:02:58.125 - 00:03:47.531, Speaker A: So we're trying to formally define what we mean by a permissionless protocol by the permissionless setting, but we're leaving decentralization as a vaguely sort of vague term. We're just observing that if we want to work with decentralized protocols, then it seems that we have to deal with these three new challenges. Yeah, so we introduced these three new challenges simultaneously. It is going to be interesting though, when we consider impossibility results. It's going to be interesting to analyze which of these three new challenges is really driving the new impossibility result. Is it really the case that we need all three new challenges in order to have the new impossibility result? Or is it really only one of these challenges which in particular is driving the new impossibility result? Okay, so yes, we introduced these three new challenges. Like I said, there was quite a high level.
00:03:47.531 - 00:04:20.865, Speaker A: So now what I'm going to do is say the same thing again, but in a slightly more precise way. Okay, Again, in this tutorial, I'm going to keep things at a fairly high level. Okay, so I'm not going to be completely precise. If you want a completely precise version of everything I say, then take a look at the paper. There's a precise version written down there. Okay, so in the fully permissionless setting, without resource restrictions yet. Okay, so because of the potentially potentially infinite set of players, P, each player in that set is allocated a non empty and potentially infinite set of identifiers.
00:04:20.865 - 00:05:13.525, Speaker A: Again, you can think of those identifiers, an arbitrarily large pre generated set of public keys for which P knows the corresponding private key. And a player can use identifiers to create an arbitrarily large number of sybils. Identifier sets are disjoint, so intuitively no player knows the private keys are held by the players, although we allow collaboration between Byzantine players as a standard. So we're going to assume time is divided into discrete time slots starting at one and so on. Okay, and now we're going to suppose that each player may be active or inactive at each time slot. If a player is inactive, that means that they don't receive many messages, they don't send any messages, they make no state transitions. If a player is active Then they can send and receive messages.
00:05:13.525 - 00:05:58.809, Speaker A: And if they're honest, they'll be carrying out the protocol instructions as they're supposed to, again, by a little bit of terminology. So by a player allocation, we mean a function specifying the identifier set for each player and the time slots of which they're active. So far, I haven't said very much about what's known to the protocol. That's obviously very important here. Okay, so what we have is the player set and the player allocation are unknown. Okay, so this is just a slightly more precise way of introducing those three challenges that I described in the previous slide. Okay, so I get rid of my face.
00:05:58.809 - 00:06:23.165, Speaker A: You can see the slide. So what I haven't talked about there yet is the means of communication. So generally in the permission setting, of course, we consider private channels. There's a channel between each pair of petitions, participants. In the permissionless setting, that doesn't really make sense. Right, because if you don't know who's out there, how can you have private channels to them? So there are various different approaches you can take here. The approach we take is to have a dissemination model.
00:06:23.165 - 00:06:50.005, Speaker A: So we allow that players can just disseminate messages to all. Okay. And then the time it takes to arrive might depend on the particular setting you're operating in, the synchronous or the partially synchronous setting. So that's how we do it. There are various other ways you could approach things here. You could allow that, you know, you can disseminate messages to all, and then once you learn that another player is there, then you can send them private messages. There are various different possibilities.
00:06:50.005 - 00:07:43.971, Speaker A: I don't need to worry about it too much because none of the results I talk about today will be overly sensitive to the way we set things up there. For now, we're just considering a dissemination model. We want to consider analogs of the synchronous and partially synchronous settings. Basically, we want to work in a standard synchronous and partially synchronous settings, but we have to adjust the definitions to make sense in a scenario where players might not always be active. So what I'm going to do next is just to go through an obvious way of modifying the definitions of the synchronous and partially synchronous models so that they make sense in this new context where players might not always be active. And again, there may be a number of decisions to be made here. You can write down potentially slightly different versions of these definitions, but I don't want you to worry too much about that.
00:07:43.971 - 00:08:37.439, Speaker A: Nothing I talk about today will be massively sensitive to way in which we write down these definitions. Generally, what we've done is we're writing down these definitions in such a way as to make our impossibility results as strong as possible. Okay, so what do we mean by the synchronous setting in a context where players might be active and certain or inactive at certain time slots? So here's an obvious way of writing down the definition. So, in the synchronous model, we suppose there exists some known delta, some known bound delta, such that if P disseminates the message M at T, and then some other player P prime is active at T prime greater than or equal to t plus delta, then P receives that dissemination at a time it's not less than or equal to T prime. Okay, Obviously you can't receive messages if you're not active. Okay, so that's the synchronous model. And then we make a similar adaptation for the partially synchronous model.
00:08:37.439 - 00:08:54.395, Speaker A: So in the partially synchronous model, there exists some known delta and some unknown time slot. Gst, as always. And it says here GST is less than equal to D. D here is just the duration, that's the number of time slots. Don't worry too much about that. So generally, we'll imagine that D is infinity. Consider infinite executions.
00:08:54.395 - 00:09:45.355, Speaker A: Okay, so now there exists some known Delta, some unknown times.gst. so if P disseminates a message M at T, and if P prime is active at T prime, great, or equal to a maximum GST and T plus delta, then P prime receives that determination at a time slot less than or equal to T. Okay, so, yeah, so that gives us a vaguely precise version of the fully permissionless setting without resource restrictions. Yet, as I say, if you want to see a complete, precise version, then please do look at the paper. The next thing we want to do is to sketch a proof that consensus won't be possible in that setting. In order to do that, though, we need to make precise what we mean by consensus. There are various different versions of consensus.
00:09:45.355 - 00:10:23.535, Speaker A: In particular, we want to define what we mean by xanthine agreement. And again, we have to pay attention because we have to make sure the definition makes sense and a context where players might not be active. Okay, so here's what we mean by Byzantine agreement in a context where players may not be active. Okay, so suppose we're running an infinite execution duration is infinite, and each player is given an input in 01. Well, then we say that a deterministic protocol solves byzantine agreement. If every protocol execution consistent with the setting there exists sometimes T. Let's say which the following three conditions are satisfied.
00:10:23.535 - 00:10:57.461, Speaker A: First of all, termination. So all honest players active at any time slot greater equal to T terminate and give an output in 01. Okay, so that's basically the same as your standard version of termination, but now modified to deal with the fact that players might not be active at certain time slots and therefore can't be required to terminate. You can't require players to terminate unless they're active. Okay? That's termination. And then agreement and validity are just a standard agreement, just the same as Zeba. All honest players, the output give the same output and validity.
00:10:57.461 - 00:11:34.585, Speaker A: And again, there are various different versions of validity, but one more fits a particular one. So if all players are given the same input, I, then every honest player that outputs gives I as their output. Okay, and then, so here then is the proper position. As I say so earlier on. I know the definition of the fully permissionless setting without resources restrictions that I've sort of sketched there is not completely precise. Basically the idea is I've given you hopefully enough precision that the proof sketch that we'll go through now will seem highly plausible. So here first of all though is the proposition.
00:11:34.585 - 00:12:15.201, Speaker A: So consider the fully permissionless setting without resources yet. And suppose that the player set is finite for every row greater than zero. No protocol sourced by Xantine agreement when up to a row fraction of the players may be byzantine. Okay, so this result holds even in the synchronous setting with a known player set and with all players active at all timeslots. Okay, so it's really, it's the possibility of Sybils that's driving the impossibility result here. Okay, okay, so that's the, that's the proposition in the next video. What we're going to do is sketch a proof of the proposition.
00:12:15.201 - 00:12:16.185, Speaker A: Okay, so I'll see you there.
