00:00:01.440 - 00:00:39.235, Speaker A: Okay, so welcome back. So at the moment where we're looking at the quasi permissionless and dynamically available settings, and we're considering various different ways we can separate these settings. So in the last video we talked about accountability. In this video I want to take a look at optimistic responsiveness. Okay, so remember, if you're working in partial synchrony, then we have this known bound delta of message delays after gst. Okay? Actually message delays might be much less than that. Okay, so now we want to let lowercase delta, little delta be actual and unknown bound on message delays and the message delivery after gst.
00:00:39.235 - 00:01:24.355, Speaker A: Okay, I won't write down a formal definition of responsiveness and optimistic responsiveness, but hopefully I'll give a rough definition which will be enough to understand what's going on. So roughly, a protocol is responsive after gst. Transactions are always confirmed in time order little delta. Okay? The latency, if you like, is a function of the actual message delay rather than the known upper bound. And often this could be quite important, right, because your known bound delta might be set quite conservatively so as to ensure liveness. You might have set delta to be one or two seconds. And then if the actual message delays so you know, like a third of a second or something like that, then your responsive protocol is going to have much lower latency.
00:01:24.355 - 00:02:13.995, Speaker A: Okay, so that's what it means roughly in a way to be responsive. And then we say a protocol is optimistically responsive if after GST transactions always confirmed in time order delta, as long as all players behave honestly. Basically what you want is at any period of time after GST when people behave honestly, then the protocol behaves in a responsive fashion. Then your latency is a function of the actual message delay rather than your known bound delta. Okay? So first of all, let's see our negative result for the dynamically available setting. Here's the theorem. So there is no zero resilient blockchain protocol that is optimistically responsive in the dynamically available authenticated in the synchronous setting.
00:02:13.995 - 00:02:57.135, Speaker A: Okay, so basically it's saying the dynamic available protocols can't be optimistically responsive, so certainly can't be responsive. Okay, so this is fairly easy to see. I'm just going to sketch the proof of this at a high level. Okay, so towards the contradiction, fix a zero resilient blockchain protocol that's optimistically responsive in the dynamic variable authenticated in synchronous settings. Okay, suppose the protocol satisfies the definition of optimistic responsiveness with livelihood parameter L, which is order delta. So basically you always have to finalize transactions within time L, which is order delta. Okay, and again, delta denotes the unknown maximum message delay.
00:02:57.135 - 00:03:50.155, Speaker A: Okay? So then we can let K be a constant such as L is less than k delta for all delta squared root one. Okay? And we can choose delta to be larger than k, uppercase delta to be larger than K. Okay, so we're going to. Basically what we're going to do here is expose that actual message delivery is really much, much quicker than our known bound delta, at least by this factor of K. Okay? And then we consider sort of standard indistinguishability argument. Okay, so let the player Set PBE P0 union P1, where P0 and P1, they're non empty and disjoint sets. Okay? We're going to consider three executions of the protocol E0, E1 and E2.
00:03:50.155 - 00:04:26.219, Speaker A: In all three executions, the player set is just P. Okay, let's consider the inputs then and the player allocations. By the player allocations, I just mean a determination of which players active at which time slots. Okay, so it's simple. So the active players are p0 and e0, p1 and e1 and the whole set p and e2. So p0 and e0, p 1 and e 1 and the whole set p and e 2. Okay.
00:04:26.219 - 00:05:00.105, Speaker A: Remember, we're in the dynamically available setting here, right? So we don't have very strong guarantees on when players will be active in all three executions. Every player is honest, don't need any byzantine action here. And there's a unique identifier. Okay, let's look at the resource balances and who owns what stake. So in all three instances we'll just have every resource allocation give every player a resource balance of one. And every time it's not always directive. Okay, the details here aren't too important.
00:05:00.105 - 00:05:48.343, Speaker A: And as far as state, we'll consider initial state distribution S0, which allocates all players in P resources balance 1, whether or not the players active. Again, this is not too important because in the dynamically available setting you can't really listen. Players having stake doesn't ensure that they're active necessarily. Okay, and then we want to let TR0 and TR1 donate two transactions that are conflicting relative to your initial state distribution. So basically these are conflicting transactions. Okay, and then so when a player is going to receive these transactions, that'll depend on the execution. So in execution e0, the environment sends tr0 to all players in p0.
00:05:48.343 - 00:06:29.495, Speaker A: At timestop, one symmetrical thing goes on. So in e1 requirement sends tr1 to all players in p1 at time sort 1. Remember, e0 is the players in p0 who are active. The players in p1 aren't active. In e1, it's the players in p1 are active and the players in p0 aren't active. Okay, so tr0 is sent to players in p0 time 1 in execution e0 in execution e1, tr1 is sent to all the active players, those in p1 at times 1. And in e2, the environment sends tr0 to ALL players in p0 at timeslot 1, as it did in execution e0, and sends tr1 to ALL players in p1 at timeslot 1, as IT did in execution e2.
00:06:29.495 - 00:07:19.441, Speaker A: The basic idea is that we want e0 to seem indistinguishable from e2 as far as the players in p0 are concerned, at least for a certain amount of time. We want E1 to appear indistinguishable from E2 as far as the players in P1 are concerned, at least for a certain amount of time. Okay, so how about message Delivery? So in E0, remember, the players in P0 are the only active ones there. It's very simple. So dissemination at timeslot T by a player in P0 if received by the other players in P0 at the next time slot, they're the only active players in E1 is symmetrical. The dissemination by times.t by a player in P1 is received by the other players in P1 at times t +1.
00:07:19.441 - 00:08:04.075, Speaker A: Again, it's only the players in P1 who are active here and then E2. Basically, what we do is like a little sort of network partition. It's only of length delta, but because the protocols have to be optimistic, responsive, a partition of length delta is enough. Okay, so in E2, dissemination at times lock t by any player in P0 is received by other players in P0 at time t +1 and is received by players in P1 at time t +Delta. Okay, a dissemination symmetrically. So dissemination@times.t by a player in P1 is received by other players in P1 at t +1 and received by players in P0 at times t +Delta.
00:08:04.075 - 00:09:13.195, Speaker A: Okay, so as I say, the basic idea is here that we're doing a sort of a little network partition of length delta, and that's enough. Basically, the E0 will seem indistinguishable from E2 as far as the players in P0 are concerned, at least for time of length delta. Similarly, E1 will seem indistinguishable from E2 as far as the players in P1 are concerned, at least for time of length delta. Okay, so how do we produce a probable consistency violation? Well, then it follows by induction time slots that for Each I in 01 and all T less than Delta, EI and E2 are indistinguishable for players in PI into the end of time slot t. Okay, so E0 is indistinguishable from E2 as far as the players in P0 are concerned, right up until the end of timeslot T for t less than delta. Simply, E1 is indistinguishable from E2 for players in P1 up until time plot delta. Okay, well, because little delta, our actual boundary Message delays here is 1 and the execution is E0 and E1.
00:09:13.195 - 00:10:04.941, Speaker A: Because Delta is greater than k, our upper case delta is greater than k. The definition of optimistic responsiveness implies that in E0, TR0 will be confirmed for all players in P0 by time slot Delta. Similarly, E1, TR1 will be confirmed for all players in p1 by time slot delta. Okay, let me get our contradiction by considering E2. Okay, so from this previous observation dagger, it follows in E2 similarly TR0 we confirm for all players in P0 and TR1 will be confirmed for all players in P1 by time slot Delta. Because TR0 and TR1 are conflicting transactions that provides the required contradiction. Okay, so that finishes the proof sketch.
00:10:04.941 - 00:10:34.181, Speaker A: We have our contradiction here. As we said before though. So in introducing the permissionless setting, we introduced these three new difficulties simultaneously. We have an unknown player set of unknown size. Players can now be active or inactive at each time slot, and we also have the possibility of sybil attacks. So what we said right from the beginning of the series of videos is that whenever we see an impossibility result, it's going to be interesting to consider which of these three new complexities is really driving the impossibility result. Are all three of them.
00:10:34.181 - 00:11:15.355, Speaker A: Requires one of them suffice to give the new impossibility result. So it's interesting to observe here that the proof we just went through is driven solely by the possibility of inactive players. So the prior set P using the proof can be known and finite with each player using a unique and known identifier. Okay, so that was a negative result for the dynamically available setting. Now let's see a positive result for the quasi permissionless setting. Okay, so consider the quasi permissionless, authenticated and partially synchronous setting. For every row less than a third, there exists a deterministic and row resilient proof of stake blockchain protocol.
00:11:15.355 - 00:12:13.975, Speaker A: Okay, so that before we even consider the last sentence there, that already gives us one separation between the dynamically available and quasi permissionless settings, right? Because the quasi permissionless protocols can function in partial synchrony, okay, now that we improve more than that. So moreover the protocol be made a third one accountable, okay, so that gives us a second separation. Now we know quasi permissionless protocols can be accountable, so the dynamically available protocols can't be okay and can also be made optimistically responsive. So that gives us our third separation. Dynamically available protocols can't be optimistically responsive. Quasi permissionless protocols can be okay, so that gives us three different separations between the dynamically available and quasi permissionless settings. To finish off this mini course, if you like, what we want to do is to consider one way of separating the quasi permissionless and permission settings.
00:12:13.975 - 00:12:16.235, Speaker A: We'll get on with that in the next video.
