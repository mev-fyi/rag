00:00:01.960 - 00:00:25.417, Speaker A: Okay, welcome back everyone. So this is video 11 of the series. In this video we're going to consider various different ways in which we can separate the quasi permissionless and the dynamically available settings. Okay, so in fact, what we're going to do is establish three separations between the dynamic available and quasi permissionless settings. Okay, so roughly multiplus quantum. Define these things in more detail in a bit. Three separations as follows.
00:00:25.417 - 00:01:07.907, Speaker A: So dynamically available protocols cannot function in the partially synchronous model or proof of state. Quasi permissionless protocols can do so. We've already seen that dynamically available protocols can't. But later on we'll see the proof of stake protocols can function in the partially synchronous setting and the partially synchronous and quasi permissionless setting. Dynamically variable protocols can't be accountable, while quasi permissionless protocols can be. That's our second separation and our third separation is that dynamically available protocols cannot be optimistic and responsive, while quasi permissionless protocols can be. Okay, so we haven't yet defined what we mean by accountable.
00:01:07.907 - 00:01:36.575, Speaker A: We haven't yet defined what we mean by optimistically responsive. So we'll define those things in a little bit. As I already mentioned there, for the first separation, we already saw that dynamically available protocols cannot function in partial synchrony. Later on we'll see that quasi permission as proof of state protocols can. Okay, so that'll give us the first separation. For the second separation, first of all, we need to define accountability. Okay, so let's do that next.
00:01:36.575 - 00:02:17.685, Speaker A: So intuitively a protocol is accountable, and there's always a smoking gun for consistency violations, such as two signatures by a common identifier that support conflicting transactions. So formally we adopt the definition of forensic support by saying a dao. Okay, they studied the traditional permission setting without external on chain resources. We now have to adapt things to the quasi permissionless setting. And that makes things a little bit complicated because now we have stake and resources changing hands. And you'll see that that makes things, some of the definitions a little bit more complicated. Okay, so how do we define accountability? Well, consider a blockchain protocol, sigma oc.
00:02:17.685 - 00:02:54.885, Speaker A: So I don't want you to worry too much about notation here, because in these talks I haven't gone into all the details of the paper. I haven't properly explained all the notation we use in the PA paper. Basically, sigma here is just a state machine diagram that specifies how honest players should behave when executing the protocol. O is just a set of permitters and C is your notion of confirmation determines when transactions should be considered confirmed. Okay, so consider a blockchain protocol and some security parameter epsilon for a player set P and a set of identifiers id. Let pid be the obvious sort of thing. It's just the players in P that own one of the identifiers in id.
00:02:54.885 - 00:04:02.355, Speaker A: Okay, so the set of players are controlled at least when identifier in ID. And then for row one, let's say in interval 01, you see, the ID star is await at least row one in a given execution if either basically there exists some time slot in which those identifiers only at least a Rho1 fraction of the external resources, at least a row1 fraction of one of the external resources. Or basically there's some time slot at which those identifiers own at least a row 1 fraction of the stake. On what formula exists T and someone is P, where t the set of confirmed transactions of P at that time slot t such that the stake allocation function given then the set of transactions T allocates identifies an ID star at least a row 1 fraction of the total stake. Okay, so I guess the difficulty here is, as I said before, in the permission setting, it's easy to say that, you know, a certain set of players, at least a certain fraction of their total set of players. A set of players contains at least a third of the total number of players. Now we're in the quantity permissionless setting, and we're considering resources, stake, and so on.
00:04:02.355 - 00:05:00.653, Speaker A: Now, it's not necessarily quite so simple to say that identifier owns at least a certain fraction of their resources, right? Because things are changing over time. Okay, but this is one way that we can write down such a definition. Okay, and then we say Our protocol is Ru1, Ru2 accountable the security parameter epsilon. If there exists a blame function F, we just got some points to guilty players in the end of consistency violation, basically. So there's just a blame function F which maps message sets to identifier sets and satisfies the following conditions. First of all, only Byzantine players are ever blamed, meaning in any execution, for any subset of messages M disseminated in that execution F is a possibly empty set of identifiers belonging to Byzantine players and 2. For each protocol instance in which the adversary is road 2 bounded, the following holds with probability at least 1 minus Îµ.
00:05:00.653 - 00:05:41.725, Speaker A: So if a consistency failure occurs, then there exists some finite set of disseminated messages M with f of weight at least row one. Okay, so roughly then, as long as the adversary is row two bounded, whenever there's A consistency violation, we get to blame at least a row one's weight of players. Okay, Some proof that they're guilty. Okay, so now let's just sort of examine that definition a little bit. Okay, so let's note this. A rho resilient Protocol is vacuously Rho1 Rho accountable for all Rho1. Right? Because with a row bounded adversary, consistency violations can be avoided anyway.
00:05:41.725 - 00:06:16.235, Speaker A: Okay, so there's nothing interesting happening in that case. Okay, so in the interesting parameter regime, then Rho 2 exceeds the values of rho for which rho resilient protocols exist. Okay, we're interested in accountability when the adversary is large enough to be able to cause consistency violations. Otherwise it's vacuous. So in this regime, one can expect Rho1 Rho2 accountability unless Rho1 is less than or equal to Rho2. Okay, so for fixed Rho2, the goal is the design protocol is Rho1 as close to Rho2 as possible. Okay, let's have a little think about what we already know.
00:06:16.235 - 00:07:10.615, Speaker A: Well, the previous proof that dynamically available protocols cannot function in partial synchrony, I've examined that proof that implies in the dynamic available authenticated and partial synchronous setting, no blockchain parallel can be row one, row two accountable for any row one greater than zero, zero and any row two greater equal to zero. Okay, so basically, in a dynamically variable and partially synchronous setting, there's nothing you can do with accountability. How about for the synchronous setting? So in the dynamically available authenticated. Authenticated here just means we have a signature scheme available. Okay, so in the dynamic available authenticated in a synchronous setting, the interesting case is when Rho2 is greater or equal to half because below that point, because we can just ensure there's consistency. Anyway, so an interesting case is when Rho2 is greater than or equal to half. And in that case a new TAS and say have shown that accountability is not possible and their proof is easily adapted to our framework.
00:07:10.615 - 00:07:41.023, Speaker A: So we get the following result, which is basically due to new TAs and say, okay, so for every. Well, you could do all the security parameters if you like. Basically, this just says that there's no zero resilient blockchain protocol. It's Rho1, row two accountable with security of parameters epsilon in the dynamically available authenticated and synchronous setting. Okay, so in the case of dynamically available protocols, there's nothing you can do in partial synchrony. And nothing interesting you can do in synchrony either. Okay.
00:07:41.023 - 00:08:26.923, Speaker A: We'll soon see though, that in the quasi permissionless, authenticated and partially synchronous setting there is a proof of stake blockchain protocol. There's a third one accountable. Okay, so basically we have it doesn't matter how large the adversary is, right? In the event of a consistency violation, we get to blame at least a third of the players, at least a third of the stake. Together with the previous theorem, this therefore establishes a formal separation as to what's possible in the dynamically available and quasi permissionless settings. Okay, so basically accountability is possible for quasi permissionless protocols and not for dynamically available protocols. Okay, so that gives us our first separation in the next video. So that's in fact the second separation from the sequence of three that are listed in the next video.
00:08:26.923 - 00:08:29.675, Speaker A: We'll go on to consider optimistically responsive protocols.
