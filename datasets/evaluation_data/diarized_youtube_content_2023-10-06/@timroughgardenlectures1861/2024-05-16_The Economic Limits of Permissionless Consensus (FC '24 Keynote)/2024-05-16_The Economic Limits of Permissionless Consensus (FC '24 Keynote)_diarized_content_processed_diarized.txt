00:00:00.600 - 00:00:43.444, Speaker A: Hi everyone. Today I want to tell you about a new paper that I'm quite excited about with the title the economic limits of permissionless consensus. This is joint work with two great co authors, Eric Budisch, who's an economist at University of Chicago, and Andy Lewis Pye, who's a mathematician at the London School of Economics. My name is Tim Roughgarden, and I should say at the outset that while I am head of research at a 16 z crypto, I'm here giving this talk in my academic capacity. Certainly nothing I say in this talk should be construed as the opinions of a 16 z. They're my own opinions only, or God forbid, don't construe anything in this talk as financial advice. So I don't know if blockchain protocols have really been around long enough for us to be able to call anything about them classic in any sense.
00:00:43.444 - 00:01:33.612, Speaker A: But if there is a classic topic around blockchain protocols, the subject of this paper would be one of them, namely the incentives around and costs of of 51% type attacks. So what do I mean by 51% type attack? Well, hopefully in the context of bitcoin, you all kind of know what I mean. Bitcoin has proof of work mining. It uses sort of the longest chain rule. So if you're an attacker that controls 51% of the overall hash rate, you're in a position to roll back an arbitrarily large number of blocks from the longest chain just by growing a long alternative chain. If you have 51% of the hashrate that will eventually become the actual longest chain, rolling back lots of blocks that had thought to have been confirmed, and in sort of producing a consistency violation of this form, you're able to carry out double spends. Other permissionless blockchain protocols have their own versions of these attacks, like in a PBFT style proof of stake blockchain protocol.
00:01:33.612 - 00:02:56.900, Speaker A: Like today's Ethereum, an attacker with 34% of the stake is similarly in a position to cause consistency violations, the rollback of what were thought to be confirmed transactions, and therefore carry out double spends. Now, what I want to think about in this paper is if you find yourself in this state, if someone has 51% of the hashrate, if someone has 34% of the stake, is it game over? Is basically the protocol at that point just sort of totally useless? And if not, why not? If someone finds themselves in a position to be able to carry out double spend attacks, why would they not just do that? Well, actually, all the way back in the bitcoin whitepaper, Nakamoto actually thought about this issue. So let me just give you sort of a few seconds to read a paragraph from that whitepaper. This comes from section six of the whitepaper. That's the section about block rewards. So my interpretation and summary of Nakamoto's argument would be that, okay, so first of all, if you control 51% of the hashrate, that means if you just stay the course and don't mess with anything, you're gonna be producing 51% of all future blocks. And the bitcoin protocol blocks have block rewards associated with them, denominated in the native currency, denominated in BTC.
00:02:56.900 - 00:03:57.682, Speaker A: So you will be getting, if you just stay the course, 51% of all the BTC that's minted for the rest of the protocol, assuming you keep 51% of the hashrate. On the other hand, and this, I think, is the key assumption in the argument, Knocko Modis says, suppose you do do a double spend attack, then you would undermine the value of this currency, which I interpret to mean there might be a big and sustained drop in the USD denominated value of bitcoins, of BTC. So while you would still make the same future rewards dominated in BTC as you would have before, the USD value of those BTC rewards is potentially going to be a lot lower should you carry out a double spend attack. These days, I think the dominant narrative around the quote unquote crypto economic security of proof of work protocols is a little bit different. In some ways, it's better. It's an argument that doesn't actually rely on the bitcoin price being affected by a double spend attack. The argument goes, look, Nakamoto in the white paper talked about cpu's, but these days, the only way you can really contribute meaningfully to the bitcoin protocol is to use specialized asics.
00:03:57.682 - 00:04:44.280, Speaker A: So computers that are really good at evaluating the SHA 256 cryptographic hash function and that really can't do anything else. So suppose there was a double spend attack on the bitcoin protocol. Then you know that somebody has 51% of the asics out there, and the bitcoin ecosystem, you know, as a collective, could respond with a hard fork, they could decide to change the rules of the bitcoin protocol, switching out the SHA 256 hash function and for some other cryptographic hash function that would render all of the asics of the attacker useless. Now, both of these sort of narratives around the security proof of work protocols, kind of, I find alarming, kind of for two related reasons, right. Reason number one is that while it's true. If one of these narratives plays out, the attacker is harmed. So is everybody else.
00:04:44.280 - 00:05:23.440, Speaker A: Okay, so there's just, like, a tremendous amount of collateral damage. It's sort of like, for scorched earth reasons, only that the attacker is harmed at all. Right? In the first narrative, any passive holder of BTC will also lose a tremendous amount of value. In the second narrative, any honest miner who is presumably also using asics will also have their asics be rendered useless. Secondly, it's like, even if the attacker does suffer some economic harm for one of these two reasons, it's not clear it really fixes anything. It's not clear it somehow deters the attacker from sort of double spending over and over and over again. I mean, in the first narrative, the attacker continues to control 51% of the hashrate.
00:05:23.440 - 00:06:53.922, Speaker A: Yes, the bitcoin price has dropped, but still, the attacker can continue to double spend whenever they want. Now, in the second narrative, in some sense, everybody's computational power gets reset to zero with the hard fork. But who's to say? It seems quite plausible that this apparently very motivated attacker could quickly amass 51% of the hash rate for whatever the new cryptographic hash function is, and then again continue to double spend on that blockchain at will. And so the types of questions that I like to sort of think about is, you know, all right, so this seems, like, not totally ideal. The fact that these punishments to the attacker involve all this collateral damage is that somehow, like, just a fundamental compromise you have to accept if you're designing a permissionless consensus protocol? Or is that in any way sort of an artifact of specific design decisions made in the bitcoin protocol, for example, that it's a proof of work protocol? So if you're not going to design a proof of work blockchain protocol, what are you going to do? You definitely need some way of managing sybils. And probably the next most natural thing to think about is proof of stake blockchain protocols, where the power of someone over the control of the protocol is dictated not by the computational power that they bring to the protocol, but rather their economic investment in the form of cryptocurrency native to that protocol, getting locked up in escrow in some kind of designated staking contract. And my understanding is that people first started getting excited about proof of stake around maybe 2011 or so.
00:06:53.922 - 00:07:58.114, Speaker A: And back then, the reasons were not somehow to overcome this issue with proof of work, kind of scorched earth punishment of an attacker. My understanding is the original motivation was much more to kind of have a different way of handling Sybil resistance, and in particular, one that didn't require so much energy and so much computation. By 2014, however, though, people definitely were talking about the fact that proof of stake holds the promise of being able to punish an attacker like someone who carries out a double spend surgically, rather than through some sort of scorched earth policy. The high level intuition, I think, is pretty clear. So, like a proof of work protocol, people's power comes from their Asics, and this protocol can't somehow reach out this imaginary arm and just rip asics away from miners on the other side of the world. Whereas in a proof of stake protocol, when your power stems from locked up stake, in a smart contract, that that protocol actually manages well, all of a sudden, like, it becomes conceivable that the protocol could literally just, in effect, reach out its arms and take stake away from the right people, meaning from. From the attacker.
00:07:58.114 - 00:08:48.770, Speaker A: Now, it's kind of very easy to just kind of sit in your arm chair and sort of, you talk intuitively about why this seems like a good idea that could work. But anyone who actually tries to write down a concrete proof of stake protocol that surgically confiscates stake in the aftermath of an attack will find there's actually a number of hard problems that need to be solved along the way. So let me mention three of them here. So, first of all, you want to do targeted punishment, you need to know who the target is, you need to know who to confiscate stake from. From who is responsible for a double spend attack. So you need some kind of proof of guilt to identify who it is that you want to be punishing. That's a challenge that connects very nicely to literature on accountability, on consensus protocols, which we've seen emerge over the past few years.
00:08:48.770 - 00:09:54.624, Speaker A: Now, even if you design the protocol so there's always a proof of guilt, so that always in principle, you can figure out who it is, who sort of is responsible for a double spend attack, there's still the issue that, you know, so if you're going to do, like, what's called slashing, if you're going to take stake away from the guilty parties, right, who's going to actually carry out that slashing? It's going to be the honest players. So they in particular need to make sure they receive the proof of guilt sufficiently quickly, quickly enough that the attacker hasn't had a chance to just sort of cash out all their assets from the blockchain protocol yet. Furthermore, even if all of the honest players do in fact, receive the proof of guilt, of proof of guilt quickly, in time, they still have to somehow come to a consensus about the new state post punishment. They need to still carry out the intended protocol, sort of slashing instructions. And just in case these sort of last two points strike you as like, they shouldn't be that hard. Like, isn't that what consensus protocols do? Anyways? Remind you, we're in a regime that we're not used to thinking about with consensus protocols. We're thinking about a regime where the attacker is big enough that they actually can create consistency violations.
00:09:54.624 - 00:11:00.588, Speaker A: And if the attacker is so big they can create consistency violations, who's to say they aren't also big enough to interfere with either of these last two requirements for this targeted punishment idea? So the Ethereum protocol is not the first proof of stake protocol. It's not the first protocol to use slashing, but it is the biggest one. And so it's a very natural case study. Famously, a little less than two years ago, Ethereum switched from a proof of work longest chain protocol to a proof of stake protocol, which also uses some PBFT style consensus logic as part of its operation. And the merge was in 2022, many years before that. If you look at, for example, Vitalik Buterin's writing about the vision of what proof of stake Ethereum would look like, it's quite clear that sort of higher quote unquote crypto economic security was one of the big reasons for doing it. There's some sense, there's some vision that a proof of stake Ethereum would just be fundamentally more secure, that 51% style attacks would be fundamentally more expensive than they were in the original proof of work version of the Ethereum protocol.
00:11:00.588 - 00:12:29.716, Speaker A: If you fast forward to today, to 2024, and you look at the current official documents of the Ethereum protocol, you will see those exact same sort of hopes echoed in the documentation. So when they just talk about why proof of stake at all, they mentioned sort of three things. They mentioned security and sustainability and scalability and maybe, I don't know, that it's an accident that security is the first thing that's mentioned. Then later on in sort of those, in those same documents, it said specifically that proof of stake is, quote unquote, more economically secure than the original proof of work version of Ethereum. Okay, so I would argue it's certainly a common belief, at the very least in the Ethereum community, probably more broadly, that proof of stake is somehow a more secure in the sense that, you know, higher attacker costs a 51% style attacks than in a proof of work protocol. Now I'm a theoretician, right? So I hear statements like this. I want to know, can you, can you sort of have a proof that these facts are actually true in some suitable mathematical model, right? So even just like, take this belief that proof of stake is somehow more crypto economically secure than proof of work, like what does that statement even formally mean? Like, what does it mean to say that protocol PI one is more economically secure than protocol PI two? How would you prove that statement? How would you falsify that statement? And I want a kind of rigorous treatment, not just so I can assess whether or not common beliefs like this are true, but also more broadly, I want to just sort of think about the design space of blockchain protocols.
00:12:29.716 - 00:13:23.714, Speaker A: So who's to say there couldn't be some other possibly totally different looking blockchain protocol which is more crypto economically secure than ethereum is? Or, you know, maybe there's limitations on how secure a protocol could possibly be. Whenever you're talking about consensus protocols, the guarantee is going to depend on the assumptions, right? So you need some kind of assumptions to get any kind of functionality that you want. And so, for example, you may need to make assumptions about the reliability of the network, about message delays. In our case, assumptions around the active participation of honest players are going to be very important. But in any case, this is a serious enough issue that understanding carefully which assumptions are necessary and sufficient for, for example, slashing to work properly in a proof of stake protocol. I think that's a really important thing to do. And the point of this paper is, in fact to lay out a mathematical framework in which all of these questions can be rigorously interrogated.
00:13:23.714 - 00:14:09.110, Speaker A: So the paper has three main results, which I'll give you an overview of on the next couple of slides. There's going to be two negative results of two impossibilities results. Those are going to be saying that under certain assumptions, we're not going to be able to get the types of protocols that we want, and then we're going to have a possibility result, a positive result, saying that under a set of stronger assumptions we can in fact get the type of protocol that we want. Now to state any of those three results, then I need to say, what is it that we want from our protocol? So we need some key definition that articulates that. And the idea is that we want a protocol that supports asymmetric punishment, okay, or targeted punishment. We're going to call protocols with that property an IAC protocol. The acronym.
00:14:09.110 - 00:14:44.502, Speaker A: The acronym here stands for expensive to attack in the absence of collapse, meaning in the absence of a collapse in the protocol's native cryptocurrency price. So again, it should be asymmetric punishment. So it should be that there's no scorched earth, there's no collateral damage. If you're participating in the protocol, honestly, no problem. You're never going to have resources taken away from you. On the other hand, if you carry out a double spend attack, or more generally just sort of cause a consistency violation in this protocol, then if you're responsible, you are guaranteed to lose some of your resources. So this is what we mean by an IAC protocol.
00:14:44.502 - 00:15:30.088, Speaker A: Honest players are always fine, attackers are always punished. A fully rigorous definition of what it means to be IAC in this sense is actually kind of delicate. And so you can see all the details in the paper, including some careful economic modeling about exactly how to go about this. For this talk, it will be sufficient to just keep in mind that this informal definition of honest players are always fine, the attacker is always harmed. So let's jump to the summary of results. Let's start with the negative results. So these are going to be impossibility results, stating that under certain assumptions you cannot have the EAC property, and both our impossibility results you should sort of interpret as saying there's no non trivial EAC protocol.
00:15:30.088 - 00:16:13.646, Speaker A: Because remember, you can have cases where you have a protocol that's eack just for totally vacuous reasons. If you assume that the attacker is so small that they can't even create a consistency violation in the first place, they can't even carry out a double spend, well, then there's nothing to do. You don't need slashing, you don't need punishment, you're going to be eacked just by default. So what a sort of negative result here is going to look like? It's going to say that as soon as the attacker gets big enough that it's in a position to carry out consistency violations at that exact same moment, it's big enough to prevent itself from being asymmetrically punished. So both of our two negative results are going to have that flavor. They're going to be under incomparable sets of assumptions. Each one is going to work with sort of three different assumptions.
00:16:13.646 - 00:17:11.630, Speaker A: So in theorem one, first of all, we're working with an attacker with 50% of the resources, so maybe it's 50% of the hashrate of the stake, whatever. That's what we mean by a one half bounded attacker on the one hand, we're going to make strong assumptions about the reliability of the communication network. So technically it's known as working in the synchronous setting. So every message is guaranteed delivery with some known bounded delay like at most 5 seconds. Say the challenge, what makes things hard for protocol design in this first theorem is we're going to insist that a protocol works in what's called the dynamically available setting, meaning honest players should be free to come and go as they like. Like for example a bitcoin miner, right? Maybe they go out of town for the weekend, maybe they turn off their asics in the meantime, and then they turn them back on when they get home Monday morning. I think, hopefully your intuition is that the bitcoin protocol probably is going to be just fine as long as at any moment in time, 51% of the current hash rate is controlled by honest parties.
00:17:11.630 - 00:17:54.582, Speaker A: And that is in fact true. And so what that means is that the bitcoin protocol functions as intended, even in the dynamically available setting where honest players may periodically go offline. So this first negative result says you cannot have an EAC protocol, in this case with a one two bounded attacker in the dynamically available setting. Even if you're in the synchronous setting, you cannot have an EAC protocol. And this is the best possible or worst possible, however you want to think about it. Type negative results, because if the attacker is any smaller, if the attacker has only 49% of the resources, well then even the bitcoin protocol is going to guarantee that there's no consistency violations. And again, you're going to be EAC kind of for vacuous reasons.
00:17:54.582 - 00:18:27.224, Speaker A: So as soon as the attacker is big enough to create consistency violations, as soon as it hits 50%. Also at that point it's big enough to prevent itself from being asymmetrically punished. So if we wanted to think about this as a picture, we can think about all of this sort of bounds on an attacker. On the left here we have a zero bounded attacker that controls nothing. On the right we have a 100% bounded attacker that controls everything. And what this says is that in the dynamically available synchronous setting, there's really only two regimes. The regime where no consistency violations are possible and then the regime where they are possible.
00:18:27.224 - 00:19:04.932, Speaker A: And moreover, you cannot have the EAC property. So our second result has a similar flavor, but again, an incomparable set of assumptions. So here we're going to make our lives easier by working in the quasi permissionless rather than dynamically available settings. We're going to try to evade the impossibility result in theorem one by asserting that by assuming that all of the honest players that are supposed to be active are in fact active at any given time. That's what's known as the quasi permissionless setting. So that makes our lives easier. As protocol designers, on the other hand, we're going to make a weaker assumption about the network.
00:19:04.932 - 00:20:01.728, Speaker A: The network is now going to potentially suffer periods of unreliability, for example from denial of service attacks. And the formal definition here is known as the partially synchronous setting, which basically says you start with a period of asynchrony of unknown but finite duration, and after that so called global stabilization time, or GST. After that point you basically default back to the easier synchronous setting. When you're talking about the partially synchronous setting, the right sort of type of attacker to think about is one third bounded. So think, for example, about a proof of stake protocol where the attacker has 34% of the stake. And here once again, okay, once again, you cannot have an IAC protocol, okay? So even if you make the strong assumption that you're in the quasi permissionless setting, if you have to deal with partial synchrony, then in fact you can't be IAC. Or at least as soon as the attacker is big enough that it can carry out consistency violations, which is a one third bounded attacker.
00:20:01.728 - 00:20:42.964, Speaker A: As soon as it's big enough to carry out a double spend, at that point, it's also enough, big enough to prevent itself from being asymmetrically punished. And actually, as we'll see from the proof sketch a little bit later, not only can it prevent itself from being asymmetrically punished, it can prevent itself from being punished at all. So even if you allow collateral damage and scorched earth doesn't matter in the partially synchronous setting, you cannot punish attackers in general at all. So here, like in theorem one, we get sort of a pretty simple picture, just sort of two regimes. The threshold here is one third rather than one half. That's because we're working in the partially synchronous setting rather than the synchronous setting, but again, smaller than one third. No consistency violations at all, bigger than one third.
00:20:42.964 - 00:21:27.646, Speaker A: You both get consistency violations and you cannot get EAC, you cannot punish those consistency violations. So the last result is going to be a positive result, saying that in a certain setting we actually can get protocols that are EAC in a non trivial sense, IAC, even though the attacker will be large enough to be able to create consistency violations. So what kind of assumptions should we be expecting to see in that third theorem statement? Well, theorem one says we really just can't work in the dynamically available setting, right. We really just can't allow honest players to come and go at will. We have to assume that the honest players that are supposed to be active really are active. That is, we're going to have to work in the quasi permissionless setting. Theorem two tells us that even if we work in that quasi permissionless setting, we can't get away with partial synchrony.
00:21:27.646 - 00:22:09.764, Speaker A: We need to make some kind of stronger assumption, like that we work in the synchronous setting. So you might expect in theorem three to say if we're in the quasi permissionless and synchronous setting, then you have some positive result about ex protocols, and that's in fact exactly what we have. You do need some kind of bound on the attacker. The attacker has to have at most, so it's going to be a proof of stake protocol for the positive result, and the attacker is going to have to have at most 66% of the stake. That's more than enough stake to be able to create consistency violations. But you actually still are an IAC protocol. You can carry out asymmetric punishment through slashing as long as the attacker has less than two thirds of the stake.
00:22:09.764 - 00:22:50.568, Speaker A: And the bound of two thirds is not an accident. It actually follows from a recent result of Tas et al, that once the attacker controls 67% of the stake, then there's no hope. Then you just basically can't be IAC. In effect, once an attacker controls two thirds of the resources, they basically, at that point, unilaterally control everything that happens in the blockchain protocol from then on. So we'll talk a fair bit about theorem three and its proof, like this protocol that's used to actually prove theorem three. Toward the end of this talk, two quick things I'll say now. So, first of all, just if you're wondering kind of at a high level, what does this protocol look like? The starting point is tendermints, but you have to do a lot of innovations on top of tendermint to get this result.
00:22:50.568 - 00:23:29.468, Speaker A: So, as you'll see at the end of the talk, there's multiple innovations in actually getting this IAC property. So being able to carry out punishment even when the attacker is large enough to carry out consistency violations. And also, if you sort of bear with me until the end of the talk, you will see a version of theorem three, which is, while sort of requires more words to state, is actually quite a bit mathematically stronger and more conceptually satisfying than the one I've given you here. So the real version of theorem three is in fact quite a bit stronger. Along with that, we'll sort of say a little bit about how this protocol works. Again, that'll be at the end of the talk. As far as the picture, it's now quite a bit more interesting than around theorem one and theorem two.
00:23:29.468 - 00:23:59.332, Speaker A: If you work in the synchronous and quasi permissionless model, and you think about varying the attacker size, we now have two phase transitions rather than one. We have one at a third and another at two thirds below a third. We have protocols that are EAC for sort of trivial reasons. Just because the attacker is so small, they can't carry out any consistency violations above two thirds. We have protocols can't be IAC. Basically, the attacker is so big, they can just unilaterally sort of control everything that happens in the blockchain protocol. But in this middle regime, this is where things are interesting.
00:23:59.332 - 00:24:46.734, Speaker A: So the attacker is big enough to cause consistency violations. On the other hand, the protocol can fight back, can beat back the attacker and make sure it gets asymmetrically punished for any consistency violations it might choose to cause. So that completes the high level overview of the three main results in the paper. In the rest of the talk, I want to circle back on all of these and dig deeper. I both want to say a little bit more about the theorem statements and in particular about phrases you may not have seen before, specifically dynamically available in quasi permissionless. And then I also want to say a little bit about the ideas behind the proofs of all of these results. Before that I do that, let me just sort of pause and sort of suggest, you know, what should be your main takeaways from these three main results.
00:24:46.734 - 00:26:01.072, Speaker A: What are the sort of implications? How should they shape how you think about blockchain protocol design? You know, so the first theorem, you know, like the sort of literal takeaway, is just that, you know, you can't have EAC in the dynamically available setting. If you have a protocol that kind of, in effect is meant to allow honest players to come and go, then, you know, you're not going to be able to, for example, implement slashing or any other form of asymmetric punishment. Now, many of you may prefer to think about, like, in terms of protocols, as opposed to in terms of settings, like dynamically available, maybe just seems like kind of abstract, but you can think of dynamically available as kind of a proxy for kind of traditional longest chain protocols, right? Be they proof of work longest chain protocols like bitcoin or proof of stake longest chain protocols like, for example, ouroboros or Snow White, longest chain protocols are generally by design meant to function properly, even in the dynamically available setting. So theorem one says these sort of traditional longest chain protocols, there's no hope of having the EAC property. In particular, there's no hope of implementing slashing in a proof of stake longest chain protocol. So moving on to theorem two. All right, if you can't do slashing in a longest chain protocol, maybe you should use the other dominant sort of form of protocol, which is a PBFT style or tendermint style blockchain protocol.
00:26:01.072 - 00:27:14.644, Speaker A: And what theorem two says is that even if you do that, so even if you work in the quasi permissionless setting, you assume that people who are supposed to be voting are active and actually voting. Even if you use the kind of protocol that seems like it should be able to do slashing proof of stake combined with a PBFT type consensus protocol, even then, you cannot get slashing to work unless you are willing to make some kind of assumptions about the worst case message delay, in particular the worst case message delay when the network is under attack. Even the protocols like proof of stake PBFT style, where it seems like slashing should be fine. Even then, you need more assumptions about people's ability to communicate with each other. The takeaway from the last result from theorem three is a happy takeaway that slashing can in fact be made to work provably. If you design your protocol carefully and you're willing to make the requisite assumptions, as theorem one tells us, you need to assume that honest players participate when they're supposed to, as you always need it, in a PBFT style protocol based on voting and quorum certificates. And if you furthermore make the assumption that when the protocol is under attack, there is still some finite worst case bound with which honest parties can communicate with each other.
00:27:14.644 - 00:28:10.074, Speaker A: So again, we'll say more about what our protocol looks like, the one that actually has provable slashing guarantees. We'll talk about it at the end of the talk. It's one that we designed. We just wanted a protocol where slashing worked provably. It's not meant to be a literal model of any of the big proof of stake protocols that are deployed in practice. That said, I mean, it's interesting to note that some of the features of our protocol do sort of accord quite well with design principles that are used in modern proof of stake protocols like post merge Ethereum. So, for example, our protocol does use cooldown periods, and the duration of those cooldown periods is actually really important for the provable guarantees the cooldown periods need to scale with the amount of time necessary for honest players to communicate when the protocol is under attack, which might be big, which might be something like days, which again sort of accords with the long cooldown periods you see in Ethereum and other proof of stake protocols as well.
00:28:10.074 - 00:28:41.534, Speaker A: So in the next couple of slides, I want to elaborate on the definitions of a couple of the terms in those theorem statements you may not have seen before, specifically, dynamically available and quasi permissionless. Those are both going to be kind of two levels of a hierarchy of four, four different levels. And to put that hierarchy in sort of context, let me zoom out a little bit and talk about just sort of the theory, you know, the design and analysis of consensus protocols more generally. Right. This is a totally classic topic. A couple Turing awards have been awarded for pioneers in this field. You know, got sort of got going in the 1980s.
00:28:41.534 - 00:29:18.874, Speaker A: And when you analyze, you know, when you prove guarantees for consensus protocols, usually the bare minimum you're after is consistency and liveness. Liveness, meaning that as long as there's work to get done, it's getting done. So as long as there's pending transactions, transactions should continue to be confirmed. On the other hand, you don't want any consistency violations. If a transaction is at some point regarded as confirmed, you want it to be regarded as confirmed forevermore and never rolled back. That's exactly a rollback is exactly what it would allow an attacker to carry out a double spend. So what makes this problem non trivial? Well, historically, two sort of orthogonal types of challenges have been the main focus.
00:29:18.874 - 00:30:10.870, Speaker A: Focus. Number one is that perhaps, you know, while you have this protocol that you intend for all of the nodes to be running, maybe some of them are not running it or not running it correctly. Maybe there's a hardware failure, maybe there's a software failure, maybe the node is actually controlled by a malicious actor. Who knows? Second orthogonal challenge is that maybe the communication network also isn't sort of, you know, being as reliable as you'd like. Maybe some of the messages that get sent get delayed for a very long time before they arrive at the intended destination. Now, in my opinion, one of the reasons that the sort of, you know, literature on consensus protocols has been, remained so vibrant for so long, decade after decade, is that the pioneers that kind of set up all of the initial models did so in a way that made it kind of very sort of fun and very clear how to make progress. They sort of set up a playground for researchers to explore for many, many years.
00:30:10.870 - 00:30:47.360, Speaker A: And the way they did this was through parameterization of the challenges. By parameterization, I mean hierarchies of assumptions sort of ordered from, you know, strongest to weakest. For example, think about sort of faulty nodes, nodes that are not running the protocol. You can have very benign types of faults, like crash faults, meaning the node just kind of goes offline and never shows up again. Or you can have very tricky types of faults, like the byzantine faults that you usually study in the context of permissionless blockchain protocols. Of course, you can also parameterize by the fraction of faulty nodes. But the point is, there's a hierarchy of types of faults of sort of increasing severity, increasing difficulty to deal with.
00:30:47.360 - 00:31:49.534, Speaker A: Same thing with the communication network, right? There's a hierarchy of assumptions. The strongest assumption you could make is the synchronous model where you have bounded message delay for every message, so guaranteed sort of delivery after a certain period of time. At the other extreme, sort of the weakest assumption would be the asynchronous model where you make no assumptions about message delivery other than eventual delivery. So literally no assumptions about how long it might take for a message to arrive at its destination. So these types of challenges, they're all there in the classical theory, which focuses largely on permissioned protocols, meaning consensus protocols, where you know up front exactly who it is, who's going to be running the protocol. If you're thinking about permissionless consensus, which is sort of what you need to think about if you want to capture protocols like bitcoin or ethereum, where ideally kind of anyone can just sort of join the protocol and participate, even if it's already been running for, you know, eight or 14 years or whatever. And there's a number of additional challenges a permissionless consensus protocol has to address, right? Has to address the fact it doesn't know the set of players running it up front, so that that player set could be changing over time.
00:31:49.534 - 00:32:24.512, Speaker A: It has to deal with Sybils, the fact that one player could masquerade as many by using multiple identifiers. That's why whenever you hear about a permissionless sort of blockchain protocol, there's always some kind of Sybil resistance module, like proof of work or proof of stake. And then the part I want to focus on sort of right now is what I mentioned. I alluded to it when we talked about theorem one, which is that in the permissionless setting, you might want to be ready for honest players to be periodically inactive, like the bitcoin miner that goes out of town for the weekend and turns off their asics. So what I want to introduce on the next slide is another hierarchy. A third hierarchy. Right.
00:32:24.512 - 00:33:07.248, Speaker A: So we have a third orthogonal challenge that honest players may be periodically inactive, that's on top of faults, on top of a possibly unreliable communication network. And so I want to introduce a third hierarchy. It's going to have four levels that sort of parameterizes the severity of the challenge of periodically inactive honest players. So on this slide, I'm going to lay out the hierarchy. There's going to be four levels. At the top is going to be the weakest assumptions, in some sense, the most permissionless setting. And then as we go from the top of the slide to the bottom of the slide, we're going to make stronger and stronger assumptions about the knowledge the protocol has about who is actively running it at any given time.
00:33:07.248 - 00:33:43.746, Speaker A: And at the bottom of this hierarchy is then going to be the permission setting, where you just have full advanced knowledge of who's running the protocol, and it's going to be the two levels in the middle that are particularly relevant for the results in this paper. So I should say that this paper actually appeared, or preliminary version of it appeared, in the financial Crypto conference of the previous year of 2023. The current version of the paper, the title is permissionless consensus. This is joint work with Andy Lewis, Pye from LSE. It is a long paper, actually the longest research paper I've ever co authored, 75 pages. So there is a tweet storm where I summarize kind of the paper. It's long enough.
00:33:43.746 - 00:34:33.504, Speaker A: I had to do a recursive tweet storm, a tweet storm of tweetstorms. But still, I hope you find that sort of, you know, maybe more convenient than reading the whole 75 page paper, for those of you that want to get more of the details about that. So one of the things in this paper is this hierarchy, and at the top level, sort of the weakest possible assumptions. It's basically the setting in which bitcoin is expected to operate, or some kind of proof of work. Longest chain protocol, namely the protocol, knows literally nothing about who's running it any given time, has no idea. The next block that gets produced might well be from an identifier with a public key the protocol has literally never seen before. So that setting is called the fully permissionless setting or the FP setting protocol doesn't know anything about who's actively running it at any given time.
00:34:33.504 - 00:35:37.328, Speaker A: So the next level in the hierarchy where we're going to make slightly stronger assumptions about what the protocol knows about who's running it, this is going to be the dynamically available or DA setting. And again, if you want to think about sort of a protocol as a proxy for the setting, you want to think about proof of stake, longest chain protocols, things like ouroboros or Snow White. In hindsight, those types of protocols are really designed to work properly, even if you're working in the DA setting. So specifically in the DA setting, a protocol knows a little bit about who might be running it. The assumption is that there's a list of identifiers or a list of public keys that are known to the protocol at any given moment in time, and that membership in that list of ids is a necessary condition for contributing to the protocol. So for example, in a proof of stake protocol, the only identifiers that are going to be tasked with proposing blocks are ones that have some stake currently registered in the staking contract. So importantly, in the DA setting, you do not assume that everybody registered in the staking contract is necessarily paying attention.
00:35:37.328 - 00:36:11.776, Speaker A: Some of them might have gone away from the weekend, but if you're not in the list, then you're not going to be able to contribute meaningfully to the protocol. So that's the DA setting. Then there's the QP setting or quasi permissionless setting. And so here the proxy protocol you want to think about would be proof of stake, PBFT style or tendermint style protocols like modern day post merge Ethereum or Algorand or something like that. And so here the protocol is allowed to make stronger assumptions about who's running it. Namely, you have that same list of identifiers. You still have the sort of ids of stakers in the current staking contract.
00:36:11.776 - 00:37:15.760, Speaker A: And here we allow the protocol to assume that literally every single identifier in that list controlled by an honest player is participating actively at that time. So for example, if you're running a consensus protocol that requires sort of people in the staking contract to vote, and you're looking for a supermajority, you're looking for 67% of the stake to all agree, then you really need to assume that the honest players in that list are showing up. Otherwise you're never going to, you're going to lose liveness, you're not going to reach the 67% threshold so in PBFT style protocols, like inevitably you're going to be making, you're going to be assuming that you're in the quasi permissionless setting. Okay? So here, membership in this list of ids is not just a necessary condition for participation the way it is in the DA setting, it's additionally a sufficient condition for participation. The protocol can be designed assuming that everyone honest in that list is participating when they're supposed to be participating. And then the fourth level is just the classical permissions setting where you don't have to worry about any churn in the player set, you don't have to worry about Sybils, anything like that. There's just a fixed set of players running the protocol till the end of time.
00:37:15.760 - 00:38:04.846, Speaker A: So in that permissionless consensus, in that 75 page permissionless consensus protocol, we prove strict separations between each level of the hierarchy. So each one is in fact sort of strictly more permissive than the, than the previous one. It turns out there's a ton of things, there's a ton of separations between the DA and QP settings. There's a lot of stuff you provably can't do in the DA setting that you provably can do in the QP setting. And so the present paper can be viewed as sort of yet another example of that with respect to slashing, that you can do slashing in the QP setting, but not under certain assumptions, but not in the DA setting. So at this point, I hope all of you feel like you understand, you know, intuitively all of the terms and all of the theorem statements, right? So we have EAC, IAC. Is this asymmetric or targeted punishment property? Honest players never lose resources.
00:38:04.846 - 00:38:43.944, Speaker A: Attackers are guaranteed to lose resources. We have this notion of sort of a bounded attacker, which just controls how much hash rate or stake they control. We have the assumptions on the network. So synchronous, where you have bounded worst case message delay, partially synchronous, where you begin with a period of asynchrony, of unknown but finite duration. And then we have this sort of last dynamically available versus quasi permissionless, where again, da setting, you basically need to be ready for honest players to be inactive, even if you prefer that they were active in the QP setting. You go ahead and assume that all of those honest players you're expecting to be active are indeed active. So that hopefully sort of spells out everything about everything in these three theorem statements.
00:38:43.944 - 00:39:20.294, Speaker A: So now let's talk a little bit about the ideas behind the proofs. Let's start with the two negative results and possibility results. Those of you that have read impossibility results in distributed computing for consensus protocols, certainly those of you that have tried to prove them yourselves, you know well that a lot of the devil here is in the details. Again, it's sort of, you know, as you try to write out the proof, you kind of discover a lot of the intricacies involved. In the interest of time here, I'm just going to give you one slide about theorem one. I'm just going to give you one slide about theorem two. So I'll tell you kind of the spirit of the argument at sort of the coarsest, most cartoonish level.
00:39:20.294 - 00:39:59.234, Speaker A: And obviously if you're interested in more details, I encourage you to check out the paper. So theorem one, again, theorem one says that basically dynamic availability precludes the EAC property. Okay? So specifically we're going to go ahead and be nice to ourselves and work in the synchronous setting. We need to assume that the attacker is big enough to be able to cause consistency violations. So the minimum sort of there is to have a one half bounded attacker. So an attacker with half the hashrate or half the stake, and we're going to show that then if we are in the DA setting, in fact, no protocol can be EAC. So again, as soon as an attacker is large enough to cause a consistency violation, they're also large enough to escape any attempted symmetric punishment.
00:39:59.234 - 00:40:44.970, Speaker A: So the proof idea, the cartoon of it, well, we've got a one half bounded attacker. And that, you know, if you have some experience with these things, kind of tells you how to set up the start of the proof, which is you're gonna have two sets of players, X and Y. They're gonna have equal resources 50 50 split. One of them's gonna be honest, one of them is gonna be byzantine. You could do it either way or, you know, there's two symmetric executions. Let's say that x are the byzantine players and why are the honest players. Now, what are these devious byzantine players going to do? They are going to behave honestly, except they're going to pretend that the players in Y do not exist, okay? Meaning they will never send any messages out to the players of Y and they will pretend as if they never hear any messages from Y.
00:40:44.970 - 00:41:22.422, Speaker A: So X is just going to sort of be kind of in their own universe. But other than that, they're going to be following the protocol honestly. You know, the players of Y, they of course are honest. They'll be playing the, they'll be following the protocol honestly, in particular, they will be sending messages to X which X will be ignoring. Y will not be receiving anything back from X because X is giving them the silent treatment. Now here's the key point. Because we're in the DA setting, and only because we're in the DA setting, the players of Y, despite not having heard of anything from X, they have to forge ahead and just confirm transactions anyways.
00:41:22.422 - 00:41:57.628, Speaker A: And that's because this protocol is supposed to satisfy liveness in the DA setting from the perspective of the honest players in Y. For all they know, all the players of X are honest, but happen to be inactive. So in that case, with 100% honest players, right? Yes, some of them are inactive, but everybody's honest. Well, then the players of Y, if you're going to be live, the players of Y really need to go ahead and start confirming some transactions. And that's where the DA assumption gets used. Now, the players in Capital X, right, they're behaving as if they're the only ones in the universe. Otherwise they're playing honestly.
00:41:57.628 - 00:42:47.544, Speaker A: They are also then going to be confirming their own sets of transactions. And in general, the transactions confirmed by X and by Y are going to be conflicting. Now, if someone showed up at just this moment in time, sort of an outside observer, they could still tell who were the byzantine players and who were the honest players, right? Because they'd look at X and they'd say, like, look, the players in X aren't even trying to send messages to Y, which means they're clearly deviating from the protocol. Whereas the players in Y, you can see they are dutifully trying to send messages back to X. So at this moment, you don't have indistinguishability between x and Y. But suppose then at some later time, after conflicting transactions have been confirmed by X and by y, at that point, x disseminates all of the messages it should have been sending to capital Y all along. It just sends them all out much, much later.
00:42:47.544 - 00:43:30.982, Speaker A: And the point is that now, at this point, a late arriving player can't distinguish which of x and y is the byzantine one. They both look sort of totally identical. And so that means, you know, asymmetric punishment is impossible, or at least it's not possible without sometimes hurting the honest players, right? Maybe in this execution, the protocol gets lucky and sort of magically knows to sort of, you know, slash x and leave y alone. But then you have the symmetric execution where x are the honest ones and y are the byzantine ones. And that execution, this protocol is going to be slashing the honest players instead. Okay, so conclusion, you can't have IAC, you can't have sort of asymmetric punishment without any collateral damage to the honest players. So let's move on to the second results.
00:43:30.982 - 00:44:30.694, Speaker A: That first result says basically, you know, that you're not going to be able to implement slashing or any other kind of asymmetric punishment in the DA settings. So we strengthen the assumption, we make our lives easier by moving to the QP assumption where now anyone who sort of is staking that we want to be active, we're going to just go ahead and assume that they're active. On the other hand, we're no longer in sort of the, you know, easy land of the synchronous model with bounded message delays. For this theorem we work in the partially synchronous setting where there is no bound on message delays, at least before global synchronization time, at least before the initial period of asynchrony. Now here with the partially synchronous setting, the right size attacker to think about is a one third bounded attacker. That's the size at which an attacker is going to be able to start producing consistency violations. And so here again, what we're going to see is that as soon as an attacker is that big, is big enough to produce consistency violations, they're also big enough to prevent being asymmetrically punished, actually, as we'll see, big enough to prevent being punished at all, collateral damage or not.
00:44:30.694 - 00:45:22.084, Speaker A: So it's a one third bounded attacker. So again, that kind of, if you're experienced with this kind of tells you the first line of the proof, which is you're going to think about three player sets, all with equal resources, two of which are honest, one of which is byzantine. So let's say X and Z are sets of honest players and Y is a set of byzantine players. And so now what we're going to do is we're going to basically prevent the player, the honest players in X and the honest players of Z from communicating with each other, okay? Though they're going to have no contact for a long period of time. Time. And the way we set that up is we have a conspiracy between sort of the communication network on the one hand and the byzantine players of Y on the other hand, okay? So the communication network, we're just going to assume that, you know, global stabilization time, GST is kind of far in the future. And in the meantime, any messages x and z try to send between each other just don't get delivered okay, so they're just getting delayed a very, very, very long time.
00:45:22.084 - 00:46:05.554, Speaker A: So X and z are not hearing from each other directly. Now, y, we're going to assume that y hears everything from x and everything from z right away. So y, in principle, could pass on messages from z to x and from x to z, but it's not going to do that. The players of Y are byzantine. So y in particular will behave, will interact with X as if it's never heard from Z while simultaneously interacting with the players in Z as if they've never heard from the players in X. All right, so now, again, by liveness, because we're supposed to have liveness in the partially synchronous setting. And again, remember, the only reason that the delays from, you know, the delays from x and between x and z are so long is because we're in the partially synchronous setting, right.
00:46:05.554 - 00:46:36.330, Speaker A: In the synchronous setting, that couldn't happen. There'd be some bound by which those messages got delivered. But here, working in the partially synchronous setting, totally possible. X and Z don't hear from each other for an indefinitely long period of time. By virtue of the protocol needing to be live in the partially synchronous setting, they have no choice. But x and Y together have to confirm some transactions, and y and z together have to confirm some transactions. And again, the transactions confirmed by x union y will, in general, be conflicting with the transactions in yunion Z.
00:46:36.330 - 00:47:27.580, Speaker A: Okay, so why do they need to confirm transactions? Again, from the perspective of players in X? For all they know, the players of Y are honest and the players of Z are byzantine, and Z is just giving everybody the silent treatment. And so in that case, x and y, if they're both honest and they're two thirds of the resources, they better go ahead and continue to confirm transactions symmetrically. You know, Z, for all they know, y is honest and x is giving everybody the silent treatment, in which case y and Z is a big enough set of players that they should be responsible for preserving liveness and confirming transactions. So to add insult to injuries, like, not just do you get this consistency violation, but again, y and z, or, sorry, x and z, they're not even going to necessarily see this consistency violation until after global stabilization time. Only then are the messages between x and z going to be delivered to each other. At that point, the players of X and Z will be like, ooh, crap, we sort of confirmed these conflicting transactions. Uh oh.
00:47:27.580 - 00:48:12.308, Speaker A: That could be arbitrarily far in the future, because GST can be arbitrarily far in the future. And by that time, the players of Y might have just safely cashed out and there's nothing you can do. They don't have any resources on chain, there's nothing to confiscate, and y not only created the consistency violation, but in fact didn't get punished at all. Moving on to the third positive result, and I want to spend quite a bit more time on this one than I did on either of the first two. So, theorems one and two tell us kind of some minimal assumptions we're going to need to make if we want a positive result, if we want protocols that are IAC for non trivial reasons, right. Theorem one says we can't really get away with working in the DA setting. We need to work in the QP setting and assume that the honest players that we want to be active, really are in fact active.
00:48:12.308 - 00:49:04.384, Speaker A: Theorem two says that even if you're willing to do that, make that assumption and work in the QP setting, you're going to have to actually make stronger assumptions about message delays than just what the partially synchronous model gives you. At least you're going to have to make stronger assumptions in the event that the protocol is under attack. And so what this theorem three says is those assumptions are not merely necessary for a non trivial EAC protocol. They are also sufficient if you're willing to work in the QP setting. Assume sort of activity of honest players if you're willing to make assumptions about message delays. For now, let's just say you're willing to work in the synchronous setting, then. In fact, at least if you designed your protocol carefully, there exists a protocol, specifically a PBFT style or tenement style proof of stake protocol, that as long as the attacker has at most 66% of the stake actually is IAC actually can asymmetrically punish that attacker.
00:49:04.384 - 00:49:45.368, Speaker A: Or in one sentence, slashing can be made to provably work, at least if you're willing to make the appropriate assumptions. So this is the result that gave us this kind of nice picture. With the three different regimes, depending on the size of the attacker, you have the regime on the left with a small attacker, meaning less than a third of the overall stake there. If you design the protocol carefully, you can make sure there's no consistency violations whatsoever. And so that protocol is going to be IAC vacuously, there's no attacks to punish, so you're fine. On the right part of this picture is the very large attacker that has at least 67% of the stake. At that point, the attacker basically takes over the blockchain protocol.
00:49:45.368 - 00:50:22.074, Speaker A: So not only can they create consistency violations, but they can also get away with it. You can't asymmetrically punish them. And so this theorem is really about this middle region where the attacker is, on the one hand, large enough, it has at least a third of the stake, so it can cause consistency violations. On the other hand, it's not big enough to take over the chain just sort of outright. It's less than two thirds. And in this regime, if you design your protocol carefully, you can in fact, implement the IAC property, and indeed, you can implement that asymmetric punishment through slashing. Now, you may remember that earlier in the talk when I was giving an overview of the three theorems.
00:50:22.074 - 00:51:02.812, Speaker A: When we got to theorem three, I promised you that those of you that stuck it out till the end of the talk would see a much more satisfying version of theorem three. And this is the slide where you're going to see it. I mean, maybe just why are we not happy with the current version of theorem three? The simplified one at the top of the slide is because it kind of feels like the worst of both worlds, right? So the theorem is about like a PBFT style or tendermint style consensus protocol. So, you know, no surprise, it's sort of making progress based on quorum certificates. Quorum certificates need a certain amount of participation. So you're going to need to assume that the honest players that are supposed to show up and vote actually are showing up and voting. In other words, you're going to be assuming you're in the quasi permissionless setting where you make assumptions about the activity of honest players.
00:51:02.812 - 00:51:57.696, Speaker A: On the other hand, what we are accustomed to really liking about PBFT style, tendermint style protocols is that they offer consistency guarantees even in the partially synchronous setting. So you can have network partitions, you can have no bound on message delay, doesn't matter. You never have to worry about a consistency violation with a protocol of that form if the attacker is not too large. And so we're used to partial synchrony being the payoff of this type of protocol. But here in theorem three, we're using that type of protocol, and we're making the stronger assumption that we're in the synchronous setting, and that's sort of unsatisfying. So the stronger version of theorem three is going to say, no, no, no, don't worry, we're going to give you a protocol where you get everything you're used to getting. Namely, you're going to get consistency and liveness guaranteed in the partially synchronous setting if the attacker is less than one, three, bounded.
00:51:57.696 - 00:52:51.392, Speaker A: On the other hand, I'm just going to give you something extra on top of that, above and beyond that, which is the EAC property, if the attacker is less than two thirds of the stake and the message delays are conforming to the synchronous model with respect to some delay bound. So that's really the content of this refined version of theorem three. It's really just saying this single protocol has two conceptually distinct guarantees. Guarantee number one, if the attacker is less than a third bounded, you're consistent and live in the partially synchronous setting. Guarantee number two is that if the attacker is less than two thirds, then you're getting the EAC property in the synchronous setting. Now, one thing to notice, right, the synchronous setting, right, there's a parameter, there's a delta, which is the sort of worst case message delay. And in general, the transfer, the time to transaction confirmation is going to scale with that delta.
00:52:51.392 - 00:53:24.996, Speaker A: The partially synchronous model also has a parameter delta, which is the worst case message delay after global stabilization time, after GST, after the network has sort of resumed normal operation. So in this refined sort of theorem three, where we get two different guarantees, one for the partially synchronous model and one for the synchronous model. Right. The first one about consistency and liveness for small attackers. The second one about EAC for sort of large attackers. There's no reason the parameter delta has to be the same in both of those two statements. So here we're going to use delta one as the worst case message delay in the partially synchronous model post GST.
00:53:24.996 - 00:54:00.354, Speaker A: So delta one is the parameter for the first guarantee of the protocol, delta two, that's going to be the parameter in the synchronous model when we're talking about the EAC property for attackers that are less than two thirds bounded. And as far as the interpretation, I want you to think of delta one as small. Delta one is sort of message delay when things are operating normally. So think of that on the order of a second or seconds. I want you to think of delta two as large. Delta two is how long it takes people to communicate when a protocol is under attack. And so maybe you think of delta two as like a day or even several days.
00:54:00.354 - 00:54:34.234, Speaker A: And the protocol we described, right, it's going to be a function of delta one and delta two. So the way to think about it is as a protocol designer, you decide what delta one you're happy with, like a second. You decide what delta two you're happy with like a day, and then you design the protocol accordingly. And so basically, transaction confirmation times, they're going to be proportional to delta one in times of normal operation. On the other hand, as far as the EAC property, you're going to be enacting punishments at a time scale that scales with delta two. So on the order of days. So that's the refined statement.
00:54:34.234 - 00:54:59.364, Speaker A: There's a corresponding refined picture. I mean, again, the thresholds are the same. There's a threshold of the third, there's a threshold of two thirds now on the left. So this is where the attacker is small, less than one third bounded. So now we've just strengthened the statement to say that you have no consistency violations, even if you happen to be in the partially synchronous setting with respect to the parameter delta one. The right hand side is exactly the same as before. Could even be in the synchronous setting.
00:54:59.364 - 00:55:58.824, Speaker A: If you have a two thirds, if you have two thirds of the stake, you basically take over the blockchain protocol, can't be punished. And so now in the middle regime, you'll notice here the EAC property does require the synchronous assumption, but it's with respect to a possibly large delay parameter delta two. So let me say a little bit about the innovations in the protocol that we designed to achieve the guarantees of theorem three about the sort of non trivially IAC protocol that we come up with, which is going to be a proof of stake protocol that uses slashing to carry out the asymmetric punishment. So we start from a very natural starting point, which is just the tendermint protocol. And apologies, I'm going to assume on this slide in the next that you have at least sort of vague familiarity with some of the, some concepts of PBFT style consensus protocols, you know, in particular sort of quorum certificates. So, to review tendermint, it works in views, and each view is an opportunity for players to confirm, to produce and confirm a new block. And each view is going to have two stages of voting.
00:55:58.824 - 00:56:45.002, Speaker A: And if a block proposal passes successfully through both stages of voting, acquiring a super majority of the voting power at each of those stages, then the block is considered confirmed. So the tenement protocol, it's a permissioned protocol, okay? So it assumes there's a list of whatever, 24 or 100 or whatever players and that list is just sort of known at the time of protocol deployment right in here. We really want to, we want a permissionless proof of stake protocol that operates in the quasi permissionless setting, not the permission setting. And so already here you have to do some non trivial work, right. At a high level, what do you do? You sort of break execution into epochs. Each epoch is tasked with confirming some potentially large number of blocks. Think of it as like the number of blocks you might expect to be confirmed in a typical day.
00:56:45.002 - 00:57:48.806, Speaker A: That might be sort of how you'd set an epoch. And the idea is that the sort of player set will update only at the conclusion of an epoch, right? So the stake amounts may change, players may stake, they may unstake, they may sort of transfer funds in the middle of an epoch. And at the conclusion of an epoch, you then update who gets to participate and what their voting rates are to reflect the current stake amounts. And to be honest, even getting this right is pretty tricky. I'm not going to talk about the details here because I want to focus on a couple of the other challenges that we face, but this already is quite non trivial. And let me again remind you just throughout both of these slides, if you're thinking that some of these things seem like they should be easy, remember that for this entire proof, we have to operate in a regiment, which is kind of which we're not used to thinking about the regime where the attacker actually is big enough that they can create consistency violations. So for example, even in the starting point, you have to be concerned with the possibility that the attacker would create a consistency violation exactly at the end of an epoch to somehow mess up the update of the player set.
00:57:48.806 - 00:58:30.882, Speaker A: Okay? So there's a lot of details there. They can be handled. Let me actually move on to discuss some of the other challenges that come up in the design of this protocol. Actually, before I get into those challenges, let me sort of tie them back into something I said sort of early on in the talk. So when we first started talking about proof of stake, we said, oh, it seems like that holds the promise of asymmetric punishment because now this sort of costly resource that controls our participants sort of power is actually under direct control of the protocol, and there's a possibility of sort of direct confiscation of that costly resource. But then we said, like, actually, you know, just know that if you actually try to make this work in a protocol, there's three things you have to address. The first thing is you need to know who to confiscate.
00:58:30.882 - 00:59:19.424, Speaker A: So you need a proof of guilt that determines who is responsible for a consistency violation. Now, this problem, basically, tendermint style protocols give you the proofs of guilt, right? So basically you're going to have players that are double voting on things they shouldn't be double voting on. That's going to be the proof of guilt. So that's not going to be the, that's not going to be the hard part. But then we said, you know, remember that actually not only must the proof of guilt exist, but it must be that honest players receive it sufficiently quickly so that they can punish the attacker before that attacker has, you know, for example, unstaked all their stake and cashed out their assets from the blockchain protocol. And then even if all of the honest players do in fact receive the proof of guilt in a timely manner, they still have to figure out how to come to consensus on some new post slashed state of the blockchain protocol. And I've said it a couple times, I'll say it again.
00:59:19.424 - 00:59:58.476, Speaker A: The reason these last two points, it's not obvious you can do them is because again, the attacker is unusually large. The attacker is large enough that they've already created a consistency violation. Who knows what other stuff they might be able to, might be able to interfere with. So the two challenges that I'll tell you about exactly map onto the second and third of these three bullets. So honest players need to receive the proof of guilt sufficiently quickly before the attacker is cashed out. And if in fact, you just follow the tenement approach of having two stages of voting per view, you actually wind up getting a protocol which fails to be EAC. And it fails to be EAC for exactly this reason.
00:59:58.476 - 01:00:29.370, Speaker A: Exactly. Because honest players are not guaranteed to receive proofs of guilt sufficiently quickly. And it's actually very easy to see what goes wrong if you know how the tenement protocol works. So the tenement protocol block confirmation basically follows from the existence of a stage two core quorum certificate. So you want to see a super majority of votes, all from the same view, all from stage two, all attesting to the same block. So what's really bad, what you really want to have never happen, is stage two quorum certificates for incompatible blocks. And that's something you prove.
01:00:29.370 - 01:01:11.796, Speaker A: Like if the attacker is less than one three bounded, you can prove that you will never have stage two QC's for two different conflicting blocks. But as soon as the attacker does have a third of the stake, they are in a position to potentially create stage two QC's for conflicting blocks. And here's the problem, right? So maybe the attacker, in addition to creating those conflicting stage two QC's, keeps one of them to themself, okay? They pretend as if they sort of didn't vote. So no honest players see the existence of the second conflicting stage two QC. So the blockchain protocol is then just going to proceed as if nothing's ever happened, right? No one's seen a consistency violation. There's nothing to worry about. And so the attacker is going to be able to unstake, you know, withdraw any assets and cash out.
01:01:11.796 - 01:01:37.864, Speaker A: And only then, at some later point in time after cashing out, release the conflicting stage two quorum certificate. And at that point, everybody sees as a consistency violation, but exactly. The perpetrators that you can identify by the double voting, they have in fact, long ago cashed out all of their assets and there's no way to carry out slash it. Okay, so really it literally goes wrong. You literally fail to be IAC with only two stages of voting. Exactly. Because of this problem.
01:01:37.864 - 01:02:13.744, Speaker A: Now, the simplest fix you could possibly hope might work, actually does work if you do it properly. So instead of using two stages of voting, you're going to use three stages of voting per view. So now, confirmation of a block actually requires the existence of a stage three quorum certificate. So let's talk through how that third round of voting helps. And in particular here, we're going to use, really crucially, that the attacker is less than two thirds bounded. And the reason that's important, right? So, you know, blocks get confirmed using quorum certificates. A quorum certificate is going to require two thirds of the overall stake.
01:02:13.744 - 01:02:57.474, Speaker A: If the attacker is less than two thirds bounded, that means the formation of a quorum certificate necessarily requires participation by at least one honest player. So with that in mind, think about an attacker that causes a consistency violation in this protocol. By definition, that means it causes two conflicting blocks to be confirmed. The way the protocol works, that means somehow stage three quorum certificates had to have been assembled for these two conflicting blocks. Remember what we said, the attacker is less than two, three bounded. So each of these stage three quorum certificates for each of these two conflicting blocks must have included the participation of an honest player. It's going to be a different honest player for each of the two blocks.
01:02:57.474 - 01:03:49.910, Speaker A: Now, as an honest player, you're only going to cast a vote for a stage three QC if you've already seen a stage two QC for that block. So in other words, we have two stage two QC's for these two conflicting blocks, each seen by an honest player. Honest players are always going to sort of echo any quorum certificates that they receive so that the rest of the honest players know about them as well. And then this is where we're using the synchrony assumption for the EAC property. Given that there is a maximum delay bound on messages when we prove our EAC property, that means that by virtue of these two honest players seeing stage two quorum certificates for conflicting blocks, all honest players will see those stage two quorum certificates for conflicting blocks after some bounded period of time. And that is then the smoking gun that they need. That is then the proof of guilt.
01:03:49.910 - 01:04:47.732, Speaker A: And that will be seen again under the synchrony assumption that will be seen by all of the honest players in a bounded amount of time. So that's how the protocol makes sure all the honest players sees these proofs of guilt sufficiently quickly. But remember, we still have this final challenge, which is even if all the honest players receive these proofs of guilt quickly, they still have to somehow come to consensus on the new state of the blockchain protocol post carrying out slashing. And in fact, what's cool here is that there's actually an interesting transition around five nine. So it turns out it's easier to deal with an adversary which is less than five nine bounded, as opposed to one which is merely less than two thirds bounded. What's special about five ninths? Well, if the adversary has less, at most 55% of the stake, then actually after slashing it once, if you look at sort of the new stake amounts, it's going to control less than a third of the new stake. Now that part of its old stake has been slashed.
01:04:47.732 - 01:05:26.254, Speaker A: Whereas if it started out with more than 55% of the stake, actually even after you slash it, it's generally going to still have more than a third of the remaining stake. So if it's less than five nine, this is still not trivial to do, I should say. But if it's less than five nine, the hope would be okay somehow. Like given the proof of guilt, you kind of include the proof of guilt into the sort of transcript. It's like a special type of confirmed transaction which removes stake from one of the parties. And the good news is that everywhere after the block, that includes the proof of guilt and triggers the slashing. Everywhere after there, you're back to the usual case where you have consistency and liveness because the adversary is less than one third bounded.
01:05:26.254 - 01:06:41.270, Speaker A: But what about an attacker that starts with, let's say, 60% of the overall stake? So that after some kind of slashing it still at that point only has like, it still has 40% of the stake. Now we've been talking about consistency violations all day, so probably your first thought is like, oh, I guess it can continue to sort of disrupt things with consistency violations, but actually remember that in a PBFT style protocol, like a tenement style protocol with 40% of the stake, you can also block liveness. So if there's any block you don't want other people building on, you can prevent that by just never voting for any quorum certificate, for any block that builds, you know, on, for example, the part of the chain that enacts the slashing conditions. So it would seem then that such an attacker is in a position to really just sort of hold the whole protocol hostage and thereby prevents the honest players from coming to consensus on a new state of the protocol in which the attackers funds really are permanently slashed. So to handle attackers with more than five nine of the overall stake, we're going to need some additional ideas. And I think I speak for my co authors when I say that this is kind of our favorite part of the protocol. So suppose you are trying to be EAC even for attackers that are not five nights bounded.
01:06:41.270 - 01:07:29.296, Speaker A: What the protocol is going to do is upon honest players seeing a proof of guilt, honest players are going to switch to a different sort of recovery mode. And in this recovery mode, they are well aware that the attacker might have, for example, 40% of the remaining stage. So while in recovery mode, they're going to use a different threshold for quorum certificates rather than a valid quorum certificate requiring 67% of the stake. While in recovery mode, you're only going to need, let's call it, 60% of the overall stake. That ensures liveness. That means the attacker is not in a position to hold everybody else hostage. Of course, there's trade offs between consistency and liveness, right? If you make it easier to be live by requiring only 60% of the overall stake, you also make it sort of easier to violate consistency.
01:07:29.296 - 01:08:28.404, Speaker A: Like even smaller attackers than a third are then in a position to produce consistency violations. So while you're in recovery mode, you got to be ready to see another consistency violation. And the solution is just to reboot the current epoch as many times as you need to. If there's a consistency violation, reboot with a suitable threshold for quorum certificates so that you know that you're live. If you have another consistency violation, you reboot again with a slightly different threshold for quorum certificates so that you again know that you're live while you're doing this, while you're rebooting over and over again the same epoch, with each successive consistency violation. At the same time, you are slashing the attacker each time so their fraction of the remaining stake is slowly going down. The thresholds you're using for quorum certificates are slowly going up, and eventually we can prove eventually, after a finite number of reboots, you will get back to the point where the adversary is less than one third bounded and the quorum certificate threshold is back up to two thirds.
01:08:28.404 - 01:08:50.096, Speaker A: So that's the high level idea of the protocol. Obviously, to really make this work, a lot more details kind of have to be spelled out. All of those are spelled out in the paper. If you're really interested in getting your hands dirty, I encourage you to go check it out. So that wraps up everything I wanted to say in this talk. Let me just reiterate the main takeaways of the three main results in the paper. So, first of all, you cannot carry out slashing.
01:08:50.096 - 01:09:27.130, Speaker A: You cannot guarantee that slashing will work or any other kind of asymmetric punishment technique you might think about without strong assumptions about the active participation of honest stakers. So people are staking in the staking contract. You need to assume that they are actively participating in the protocol. They cannot just turn off their machines when they go out of town for the weekend. In particular, this says for all sort of traditional longest chain protocols, you cannot have slashing. Maybe that's one of the reasons why back in 2011 when people were first talking about proof of stake, back then, people were kind of only thinking about longest chain protocols. So maybe that's why they didn't really talk about slashing in 20 11, 20 12, 20 13.
01:09:27.130 - 01:10:20.452, Speaker A: It was only in 2014 when you had the first version of the tenement protocol come out and you had PBFT style protocols start to be considered as possible blockchain protocols. Only then was it that you started hearing about the possibility of slashing in a proof of stake protocol. Maybe that's not a coincidence. Furthermore, even if you do use a PBFT style or tenement style protocol as part of, say, a proof of stake protocol, even then you cannot carry out slashing without some kind of control over message delays, specifically the delay it takes for honest players to communicate with each other, for example, to share proofs of guilt. The time for honest players to communicate with each other when the protocol is under attack, when you have, for example, an attacker with 50% of the stake creating consistency violations. And if you think about it. This accords with the kinds of cool down periods that we see, for example, in post merge ethereum.
01:10:20.452 - 01:10:55.786, Speaker A: Right? So you might, you know, so as a staker, you can try to unstake. It's a while before you get your funds back. As soon as you unstake, you lose your voting power, but you can't actually withdraw until after some long cool down period. And the choice of the cooldown period is often, in practice, chosen to be commensurate with the time needed for sort of out of band communication. And our results suggest that that is in fact the appropriate way to go about it. And finally, we prove for the first time that indeed, slashing can be made to work provably under appropriate assumptions. We give a protocol.
01:10:55.786 - 01:11:21.470, Speaker A: It is sort of derived from tendermint. It's proof of stake. It uses slashing, and it provably has the IAC property. It provably punishes, sort of surgically, an attacker responsible for a consistency violation, as long as that attacker controls less than two thirds of the stake. And as we've mentioned, that two thirds is a tight threshold. An attacker with more than two thirds actually, can always get away with whatever they want. So that's the talk.
01:11:21.470 - 01:11:23.174, Speaker A: Thanks very much for sticking with me.
