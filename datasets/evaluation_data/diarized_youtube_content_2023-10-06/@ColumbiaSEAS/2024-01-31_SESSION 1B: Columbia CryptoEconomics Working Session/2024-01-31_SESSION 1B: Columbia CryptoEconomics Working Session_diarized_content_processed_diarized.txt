00:00:07.320 - 00:00:34.550, Speaker A: Hey, everyone. Thanks for coming. Yeah, my name is Mike. I also work at the Ethereum foundation, and I'm going to be talking about a new inclusionless design called no free lunch. And, yeah, this work has built on the work of Francesco and Vitalik, who've been kind of talking about these things for a very long time. So, yeah, let's dive into it. Actually, before we start, I don't have a slide on this, so I thought I'd just draw it real quick.
00:00:34.550 - 00:01:40.276, Speaker A: As Tomod just mentioned, in the MEV supply chain, we kind of think of, broadly speaking, like, I want to focus on the three actors of builder, relay and proposer, and in terms of censorship resistance. And, yeah, I guess I'll start by saying the whole point of inclusionless is to increase the censorship resistance properties of Ethereum. So in PBS today or in Mevboost today, we have builders relays and the proposer. So, yeah, kind of immediately post merge, a lot of the censorship concern was around the relays. So the idea here is that the builders are sending blocks to the relays, and the relays see the contents of those blocks before the proposer. So the relay can decide if they want to exclude some set of transactions from that block or not. And this was kind of especially important because the largest relay, the flashbots relay after the merge, was censoring.
00:01:40.276 - 00:02:20.176, Speaker A: And so all the validators who connected to it were de facto censoring because they only received blocks that had a certain set of transactions already filtered out. So there's kind of like one censorship risk. Yeah, I guess, kind of here, right? So the relay can censor on the behalf of the proposer. Today, we actually are kind of more concerned about the builder censorship. So, beyond the relays, even if the relay doesn't filter out a set of transactions, the builder is ultimately the one who's constructing the block. So they decide at the end of the day, what goes in and what doesn't go in. And as we've seen recently, most of the builders have started censoring.
00:02:20.176 - 00:03:00.628, Speaker A: So even if the proposer is connected to a non censoring relay, if the builder sending that relay is censoring, then there's kind of not much that the relay can do because they're still serving the winning bid to the proposer. So there's kind of a second censorship vector between the builder and the relay. So that's kind of just motivating this problem. We see currently, about 70 ish percent of builders are censoring. 70% of builder blocks are censored. And yeah, about 95% of Ethereum blocks are built through the mev boost market. So we're talking about a substantial portion of Ethereum blocks that are de facto censored because of the builder censorship we see today.
00:03:00.628 - 00:03:15.364, Speaker A: So yeah, that kind of motivates this design. Hopefully we can kind of dig into some of the details around inclusionless and leave with a better understanding. Let's jump in. Yeah. Quick outline. Oh, I have it here. Yeah.
00:03:15.364 - 00:03:35.788, Speaker A: So start with a kind of basic inclusionless design. Then we'll describe what we call the free da problem. So that's the free data availability. The no free lunch design addresses this problem directly. And that's kind of the unique new aspect of it that I want to focus on. And then we talk about this deniability property, which is kind of the core component. So let's jump in.
00:03:35.788 - 00:04:00.148, Speaker A: So yeah, the simplest inclusionless design you could think about is as follows. So we have slot n, we have our beacon block. It contains execution payload. So these are kind of like the two components of the block. There's the consensus layer block and execution layer block. In the next slot there is an inclusion list specified. So the inclusion list has three transactions, transaction a, b and c.
00:04:00.148 - 00:05:11.148, Speaker A: And the kind of condition here is that the slot n forward inclusion list transactions must be valid based on the end, like the post state after slot n plus one payload has been executed at the end of this execution payload. Once that list of transactions has been simulated, the forward inclusion list transactions have to be valid and then those can be put into this list and put into the beacon block itself. The issue here is that the slot n inclusionless transactions are checked for validity after the execution payload here. And as a result, transaction a could no longer be valid. So this is important because in order for the proposers to outsource their blocks to the builder market, they actually don't know the contents of their blocks before they're constructing, before they have to build the inclusion lists. So they could end up building an inclusion list that's invalid. It could be included in their block themselves, it could have a nonce, reuse the gas limit, sorry, the gas fee might not be paying enough.
00:05:11.148 - 00:05:56.890, Speaker A: So these are like some of the issues that could cause this transaction a to become no longer valid. But this is fine. Let's just say that under our kind of basic forward inclusion list design, that even if the transaction is not valid, it can still be in the inclusion list and we just ignore it in the next slot. So now we have the next slot, slot n plus one, and we have this condition that the n plus one payload includes the slot n inclusionless transactions that are still valid. So there's kind of this conditioned on them still being valid after the slot n execution payload, they must be included in slot n plus one. So here we have transactions b and c. Basically, you can reorder and insert transactions before and after.
00:05:56.890 - 00:06:58.332, Speaker A: The only constraint is that those transactions b and c are actually in the execution payload of the subsequent block. So this is kind of the reason we call it forward inclusion list. This was Francesco's kind of original design, which is the inclusion list is enforced on the subsequent proposer rather than the proposer themselves. And this is important for incentive compatibility reasons, because if the proposer has to build an inclusion list for their own block, then they're limiting the set of builders that might build for their slot, and as a result they might just take away some optionality and reduce the value of their slot altogether, which is pretty difficult to ask people to do. So the kind of cross slot mechanic is so that the slot n proposer builds their inclusion list, but it constrains the builder for slot n plus one. And that's kind of the ideal as far as making sure that more people actually build these inclusion lists, because without the inclusion list being built, the censorship resistance properties don't change at all. Cool.
00:06:58.332 - 00:07:35.896, Speaker A: So yeah, this is like the basic forward inclusion list design. But there's an issue here, and it's around this transaction a, right, with the red x. So this is what we call the free data availability problem, and it's quite tricky. So basically the idea here is that we have a beacon block. This is kind of zooming in on slot n from the previous slide, and we have the proposer committing to this transaction, I just call it Xerox EF, before seeing the contents of their block. So now they're outsourcing their block to Mevboost. But they've already committed to this transaction.
00:07:35.896 - 00:08:15.636, Speaker A: A few important things. It's from b, from address b, and the nonsis seven nons is just the number that kind of the index of the transaction from a specific address. Now we have the payload show up. So let's say this was the proposer, they outsourced the block to a relay, and then the relay publishes the payload on their behalf. But the payload has a transaction zero XDE. And the issue here is that it's from b and it also has non seven. So these two fields match for both the inclusionless transaction and the payload transaction, but they're different transactions.
00:08:15.636 - 00:09:08.564, Speaker A: So because they have the same nonce. This is what's called a nonce reuse. Now, transaction zero X EF is not going to be considered valid. Yeah. So the issue is, even though it's not valid and it's not paying gas, because you don't pay gas for invalid transactions, it still has to be included in the historical state. Because in order for the slot n plus one proposer to build a block that conforms to the inclusion list, they have to prove that they didn't have to satisfy the inclusion list, meaning that the transaction that was in the inclusion list had to be available for them to prove that there was nons for use. So yeah, there's kind of this subtle aspect here where by specifying a specific transaction in the inclusion list, that transaction has guaranteed availability even if it doesn't necessarily show up in the block and doesn't pay gas.
00:09:08.564 - 00:10:04.116, Speaker A: And this is especially important because inclusion lists extend to blob transactions. And so this could be a way, there's kind of a strategy here for if you're a roll up and you want free data availability, which is you sign multiple blobs at the same nonce and you basically ensure that one of them doesn't end up paying for the data that it consumes. And that's kind of the main issue with most of these original inclusionless designs is the fact that these transactions have free data availability. And this kind of leads to this observation. The observation says a transaction that's valid in the slot n prestate will be invalid in the post state. So this is like before the execution payload is executed, and after the execution payload is executed. If the slot n payload includes at least one transaction from the same address, or the max fee per gas is less than the base fee of the subsequent block.
00:10:04.116 - 00:10:28.656, Speaker A: So the second one is about 1559. That's like kind of a relatively easy condition to check for. But this first one is this nonce reuse thing that we were describing before. So the key intuition here is that basically the only way you can get this free DA if you're someone who's trying to game the system and get free da, is by reusing the nonce. And this is kind of the key intuition for what we can tackle in terms of solving this problem.
00:10:28.758 - 00:10:29.936, Speaker B: Sorry, are you saying that's an if.
00:10:29.958 - 00:11:05.244, Speaker A: And only if, right? Yeah, it should say if and only if. Cool. So now we get to kind of the nuts and bolts of the design at ten minutes. So I think I'm good, right? So we have our slot and proposer and there's a little set of things going on inside this p to p object. So there's three components of the data that they gossip over the network when they're proposing their block, so they publish the block itself. That's the purple thing with the payload. That's like very much in line with what we see today.
00:11:05.244 - 00:11:46.808, Speaker A: And then they break the inclusion list into two components. There's called the summary and the transactions. And the important thing here is the summary only commits to a set of addresses and gas limits without specifying the exact details of the transaction that the inclusion list contains. So the summary is kind of just like an abbreviated version of this inclusion list that doesn't contain all the contents or any commitment to a specific transaction. And it has a signature. So the signature is from the slot and proposer over their own summary. The transactions correspond to the address gas limit pairs specified in the summary, and they have to be valid in the slot n presate.
00:11:46.808 - 00:12:26.944, Speaker A: And these are what are unsigned. So the kind of key idea here is that when the proposer signs something, they're only committing to the from address, and they're not actually committing to a specific transaction itself. Now we have our next proposal slot and proposal. This is still like the forward inclusion list mechanic. So the inclusion list is being enforced on this proposer slot, and they include a summary from the previous proposer. So this is kind of like part of the block that they construct has to include a summary from the previous proposer. That signature has to be valid.
00:12:26.944 - 00:12:57.600, Speaker A: All of this is part of the state transition function that's used to validate the block in the first place. And now we see that there's a few things going on in terms of these specific transactions. So again, we have transactions a, b, and c. Transactions a and c actually show up in the slot n proposer's block themselves. So the builder built a block that had those two transactions in it. But the transaction b, the orange one, didn't show up there. And so the slot n plus one proposer has to have transaction b in their block somewhere.
00:12:57.600 - 00:13:37.970, Speaker A: And then with all three transactions included, we have the full satisfaction of the inclusion list, and we can say that this new block is considered valid. So, yeah, this is kind of just summarizing that. So we call each entry in. The summary is one of these pairs for the address in the gas limit, and they're satisfied, meaning that transaction is included. A transaction from that address is included either in the slot n or the slot n plus one payload. And the three arrows here indicate where the summary transactions map to in terms of the transactions that they correspond to. So dashed line goes to transaction c.
00:13:37.970 - 00:14:35.970, Speaker A: Yeah, maybe a little noisy, but that's kind of the intuition here. And yeah, that's actually it. So it kind of feels like almost too simple to have solved the Freeda problem, but it turns out it did. And this kind of leads us into observation number four from this post, which says that if transaction b aims to achieve free da, there exists a transaction a such that transaction a satisfies the same entry in the summary as transaction B. So this is kind of like, sorry, this is kind of formal, but the whole point is that one I made before, which is if you're trying to get free da, you must have reused anonce. And if you reuse anonce, then both of those transactions that you signed satisfy the same entry. So you kind of lose the uniqueness property of the transaction that you tried to get Freeda for.
00:14:35.970 - 00:15:22.050, Speaker A: And the conclusion here is that validators can deny and we'll kind of go through deniability as a property. Next, having seen transaction b, because they can just say, hey, I saw transaction a, it satisfied the summary. And importantly, because the transaction list is not signed over, there's no cryptographic proof that they necessarily had to see one transaction or another. They have this deniability property, which is what solves the Freeda thing. Because ultimately the free DA is derived from the fact that in order for a block to be considered valid, that data would need to be available on each node. And this kind of removes that property by saying it could be either this piece of data or this piece of data. You have no guarantee that it was either of them, basically.
00:15:22.050 - 00:15:51.348, Speaker A: Cool. So yeah, let's kind of double click on this deniability thing. So here we are again, slot and proposer. Hopefully you're not too tired of these diagrams yet. They send their block with this summary. So the summary has a from address zero xa and it has the signature. And I guess one important observation before we move on is that transaction a satisfies this summary.
00:15:51.348 - 00:16:31.088, Speaker A: So we're saying that this inclusion list is already satisfied in their own block. Now we have the next proposer. So let's say that there's another transaction, transaction B, that also satisfies the entry to the summary. So these two transactions, transaction a and transaction B, both have the same from address zero xa. And essentially that means that that transaction originator was like trying to get free DA or signed multiple transactions with the same nonce. Let's talk a bit about slot n plus one proposer. So slot n plus one proposer has to propose their block.
00:16:31.088 - 00:17:23.652, Speaker A: They include the summary from the previous proposer, so that's contained in their block itself. But they don't have to have any transaction in it because the summary was satisfied by the slot n proposer, not the slot n plus one. Right? So now we have the slot n plus one a tester, and we can see that in their version of the inclusion list, which is this transactions set here. So remember, the summary is signed, but the set of transactions is not signed. So the slot n plus one attester sees a version of transactions that just has transaction a in it, because both of these transactions satisfy the inclusion list. So as a result, the attester sees that transaction a exists, they know that the summary is satisfied, they attest to the block without ever having seeing transaction b. And that's the important bit.
00:17:23.652 - 00:18:16.730, Speaker A: So basically, there's two versions of the list of transactions that can be constructed. They don't necessarily have to be constructed by the slot n proposer, because these transactions list are not signed. They're just kind of arbitrary data that gets gossiped around the network. And now the key thing, this key deniability property, comes from the fact that the slot n plus one a tester can say, I've never seen transaction b, and they can credibly claim that because what they saw was transaction a satisfying the summary. So it's kind of like there's a few steps here, but basically the TLDR at the end of the day is that whoever made transaction b has no guarantee that every person on the network has transaction a and has stored transaction a somewhere in their database. So they have no guarantee about the availability of that data. That data can just be pruned out from the client nodes and then you get rid of this free da problem that we were describing before.
00:18:16.730 - 00:18:52.844, Speaker A: Cool. Yeah. This is what I call extra credit, because if you really like looking at these diagrams, you can, it's probably more effort to go into it, but the TLDR is that there's a few different things you can do to compress the amount of data in the inclusion list. We use this thing called a rebuilder, which is kind of cool. There's also a few games that proposers can play by specifying which transactions are in the inclusion list and which are not. They can get, like, instead of the free da from. Yeah, I won't go into the details.
00:18:52.844 - 00:19:28.530, Speaker A: Maybe we can talk afterwards. And actually Barnabase talk, which is coming next, goes into some of these extra mechanics that arise from the fact that the proposer has another set of degrees of freedom over what they put into the inclusion list. So, yeah, that's all I got, this guy with a box, because it feels like we're kind of trying to pack stuff into blocks. But yeah, if you want to read more, this is the post that specifies the design. Again, this is a direct extension of the work with Francesco and Vitalik. So hat tip to them and I'll happily take questions. Thank you.
00:19:40.340 - 00:19:49.700, Speaker B: I'm trying to think if deniability is the right way to think about, I mean, it kind of feels like, what? So basically you're allowing a proposer to specify constraints on validity for the next block, right?
00:19:49.770 - 00:19:50.004, Speaker A: Right.
00:19:50.042 - 00:20:05.070, Speaker B: And so it feels to me you're just saying, let's relax kind of those constraints from matching a specific transaction and basically matching specific fields of a transaction. And that, like you say, seems to solve the freeda problem. Why is deniability like an important part of the story?
00:20:05.920 - 00:20:30.628, Speaker A: Right, so deniability allows participants in the network nodes to have this property of saying that they can credibly have not seen a piece of data. If they have credibly not seen it, then they're able to, even if they have seen it, they can drop it from their node and not worry about having to store it for future nodes to query and sync based on trying to get up to the head of.
00:20:30.634 - 00:20:40.032, Speaker B: The chain is another way of thinking about it, is just not so much they could say like, yeah, I saw both, I chose one, I'm not throwing the other one, deal with it. I mean, is that like another framing?
00:20:40.096 - 00:21:09.400, Speaker A: Yeah, that's another way of thinking about it for sure. And ultimately what we're trying to do here, this deniability thing, is just to solve the DEA problem. Ultimately, what we're trying to do is give some agency back to the proposer. Right now, the burden, I like to call it the burden of censorship. Resistance lies on the builders because it's their choice what transactions go in and what don't. And there's like a very limited set of decisions that the proposer can make. They can either outsource the block to the relays and then suffer from builder censorship, or they can build their block locally.
00:21:09.400 - 00:22:09.280, Speaker A: If they build the block locally, it might be worth 5% of what the block that they outsource could be worth. So fundamentally what we're doing is we're telling the proposer, hey, you have some agency over your own set of transactions that get included during your slot. Like we give some power back to the proposer. And this is better because as far as censorship resistance, we're kind of always going to have to implicitly depend on the validator set, depending on the builder set, as the source of the censorship resistance is clearly not a winning strategy in terms of getting good properties for the network. So, yeah, even if proposers, we don't expect necessarily every proposer to make use of these inclusion lists, but we expect the long tail of proposers to use them as a kind of intermediate choice between self building the block and kind of completely outsourcing everything about the block to the Mevboost market. It's kind of like somewhere in the middle in terms of what power we're giving back to the proposer.
00:22:11.560 - 00:22:17.190, Speaker C: Yeah, Matt, just in the summary, is that a minimum gas per nonce per address?
00:22:17.720 - 00:22:47.240, Speaker A: Right? Yeah. So the reason you have to include the gas here is because one way that the inclusion list can be satisfied is if the gas remaining in the subsequent block isn't sufficient to include the transaction. So this is kind of just like part of the 1559 thing, right? Like if the block is full of super valuable transactions, then we don't want to force the builder to include the transaction. So we tell them that as long as there's gas remaining in the block, such that this transaction should fit, it has to be in there, otherwise it doesn't.
00:22:47.400 - 00:23:09.444, Speaker C: I'm also thinking specifically about replacement. So replacement transactions reuse the nonce, but increase gas. And it's about, I don't know, anywhere from five to 9% of the global mem pool is replacement transactions in a given day. So that's a pretty common thing in this scenario. And so that would be satisfied by the summary, because my transaction b, that replaces transaction a as higher gas. And the summary would accept that.
00:23:09.482 - 00:23:11.604, Speaker A: Exactly, yeah.
00:23:11.642 - 00:23:49.890, Speaker D: Justin, a different perspective on Tim's question. One of the things that could happen is that the summary is unsatisfiable, and that would be a griefing vector, because now the proposer can make it in such a way that the next builder just can't build a block. And so really you invoke the attesters to make sure that the summary is satisfiable. And what does it mean for the summary to be satisfiable is that there's some transactions that match the constraints, and the deniability comes in where it doesn't matter which one satisfies, just it needs to exist at least one.
00:23:51.000 - 00:23:54.276, Speaker A: Thanks, Justin. Any other questions?
00:23:54.378 - 00:23:57.316, Speaker E: Yeah, do you use the attestors to solve this?
00:23:57.338 - 00:24:07.380, Speaker F: Problem on slot n or n plus one to verify whether they see those transactions in the memple that are in the summary.
00:24:07.540 - 00:25:08.564, Speaker A: Right. So there's kind of almost both, actually. So let me go back to this slide. So part of the fact that we bundle this all into the same p to p object is this idea that in order for a block to be considered valid in someone's view, like for the slot and a testing committee, they only consider this block valid if there exists a summary and a signature, a set of transactions that satisfy each element of that summary. So basically, like, first, you depend on the attesting committee to only attest for blocks that actually do have an available inclusion list for the slot n plus one proposer and the slot n plus one attesting committee, they do the actual enforcement of the inclusion list because that's what's actually data in the block. So they're the ones who check, hey, this block has a summary signed from the previous proposer, and all of the entries in the summary are satisfied either in the previous block or the current block.
00:25:08.612 - 00:25:44.480, Speaker F: Yeah, but is there worries that this gives proposers an extra lever to try and cause chaos throughout the network, like previously, if you want to cause as much chaos as possible, the way you do that is by kind of proposing two separate blocks in the same slot and trying to send them to as very disparate sets of the network. And I think that's a lot about how the balancing attacks work. Does this cause sort of concerns there where I can cause a little bit more chaos for a lot cheaper? There's sort of no slashing here. If I have a summary, and I only broadcast the transactions that are in that summary to a different part of the network, and I can kind of get half of the people to agree and half to disagree.
00:25:44.560 - 00:26:02.990, Speaker A: Yeah. So this is like the perfect transition into Barnabase talk, which is literally called fun and games with inclusionless and kind of pokes at all of these different games. So, yeah, there's a lot to consider there for sure. Seems like a natural breakpoint. Or one more question.
00:26:03.360 - 00:26:08.530, Speaker E: I was just curious how this affects proposers economics, right?
00:26:09.860 - 00:27:10.796, Speaker A: Yeah. I mean, generally speaking, the way we wrote it out in the original post was this doesn't change the economics at all, because for the slot and proposal themselves, the constraints that are specified by the inclusion list aren't enforced until the next slot. So it might change the next slot economics. So the only time this could potentially become an issue is if you have two slots in a row, like if you're a large proposer and you have two slots in a row, then constructing an inclusion list for the first slot means you might be constraining the set of builders that build for your second slot. Yeah, I think there's stuff to consider as far as if we can incentivize people to use the inclusion list, because one of the main concerns is like, if no one uses it, then you don't actually get the censorship resistance properties for sure. Yeah. In that case, the ideal situation would be maybe they don't use the inclusion list for the first block, but they do for the second block.
00:27:10.796 - 00:27:34.984, Speaker A: And we don't actually even know whether. So we don't have an in protocol forced inclusion mechanism yet. So we don't know whether or not censoring builders are going to build blocks for those slots or not. It could be the case that censoring builders just say, hey, this is part of the protocol. They have kind of deniability in that regard. We're going to build blocks for those slots no matter what. And then the economics don't change at all.
00:27:34.984 - 00:28:35.544, Speaker A: It's just like they add those transactions at the end of their block and they're worth like, whatever, a few dollars of gas. Yeah, I don't think we'll know until we actually put it in protocol. There's like out of protocol versions of this that you could try, but anything, generally speaking, from the conversations I've had with builders, anything that is out of protocol and they have a decision over if they use it or not is kind of like they don't have that plausible deniability. They have this legal liability of opting into something versus if it's in the protocol and it's enforced at the block validity level, then maybe all the builders will just conform. And actually, this is kind of interesting because imagine, okay, in the ideal world, every validator builds an inclusion list for every slot. And let's just say that there's like one tornado transaction per slot, then any builder that decides not to build now can build 0% of the blocks. Because if they only build conformant blocks and every conformant block must have at least one tornado transaction in it, then they just get priced out immediately.
00:28:35.544 - 00:29:09.530, Speaker A: So this could be a situation where during the kind of quote, unquote censoring slots, the non censoring builders have like, a distinct advantage by not censoring because they're the only ones who can compete. So how this pans out is going to be super interesting. Consider funding tornado cash dust for the grant. Someone had this already. It was like a thing you could send and it would just ping the tornado router once a slot. I think it was Martin Coppelman. Yeah.
00:29:09.530 - 00:29:11.656, Speaker A: Francesca. Yeah.
00:29:11.678 - 00:29:15.240, Speaker E: I just wanted to answer a question. I actually don't think Martin will in his talk.
00:29:15.310 - 00:29:15.832, Speaker A: Okay.
00:29:15.966 - 00:29:52.980, Speaker E: You can basically couple the propagation of the list with the block and you don't actually care if someone makes, let's say, propagates the same block with two different lists. That's not slashable because the lists are explicitly not meant to be signed. But you don't actually care because attesters only care about their existing list. So to a tester that's two different lists. It's irrelevant if there's like 1000 lists. But the testers will see a block as invalid if they see summary. Separate is like you reveal the list, everyone and then to half the people you view the transaction.
00:29:54.440 - 00:29:54.948, Speaker A: Right.
00:29:55.034 - 00:30:02.630, Speaker E: But I mean, it's pretty similar to releasing a block where you can put that. I've seen it. I don't think it has much of it.
00:30:03.400 - 00:30:04.124, Speaker A: Yeah.
00:30:04.282 - 00:30:05.710, Speaker E: Did one you do?
00:30:08.720 - 00:30:11.564, Speaker A: Yeah. Just erasing. Don't mind me. Yeah.
00:30:11.602 - 00:30:22.696, Speaker E: Bert thought about driving games between slots. So significantly more profitable to not have an inclusion list in the previous slot to kick back some profit.
00:30:22.808 - 00:30:29.970, Speaker A: Yeah. I think this is literally the first game that Barnaby will describe. So maybe let's end there and call Barnabay in. Thank you.
