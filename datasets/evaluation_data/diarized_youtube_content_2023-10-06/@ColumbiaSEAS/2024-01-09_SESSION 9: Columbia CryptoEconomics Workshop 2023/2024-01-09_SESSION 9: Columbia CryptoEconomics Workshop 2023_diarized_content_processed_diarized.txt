00:00:12.300 - 00:00:12.850, Speaker A: You.
00:00:14.980 - 00:00:47.784, Speaker B: Hi. So the next two sessions will be on the topic of staking on Ethereum. Just a small introduction. So Ethereum moved to proof of stake in September 22. And the economic mechanism is quite simple today. So essentially, validator put collateral stake and then they get rewarded if, if they do a good job and they get penalized otherwise. And the staking mechanism that is in protocol, like operationally, is also very simple.
00:00:47.784 - 00:01:50.344, Speaker B: Essentially, you can put 32 e at stake to become a validator. And there is no enshrined pools, there is no stake delegation, nothing fancy. But we are doing active research in order to improve the staking experience both on a micro mechanism level and also on the macro rewards aspects of it. So our two sessions will be on these two topics. So we are going to get started with the micro and staking mechanisms. So here essentially, and I'm going to introduce the next speaker. So here the question is, with the emergence of liquid staking and staking pools out of the Ethereum protocol, there is essentially this principal agent problem where the entity that is operating the validators is different from the principal that owns the capital.
00:01:50.344 - 00:02:08.100, Speaker B: So the next two talks will be around mechanisms to improve this type of function to hopefully achieve better outcome. So welcome Jason from Puffer, who's going to be the first speaker.
00:02:17.020 - 00:02:43.070, Speaker C: Thank you. All right. Yeah, thank you everyone for having me back again. I'm Jason from puffer. So what we're working on is a decentralized, permissionless liquid staking protocol. And what I wanted to do today was really talk about a lot of the mechanisms that are being used in the space and sort of not really focusing on our protocol, but really to try and how do I.
00:02:46.960 - 00:02:48.048, Speaker A: There we go.
00:02:48.214 - 00:03:27.688, Speaker C: There we go. Okay. Yeah. So the goal here, I want to really provide some general context around staking and liquid staking and really try and approach this for a general audience that really might not understand a lot of the jargon that's used within the space, within Twitter, and really try and inspire some new discussions, especially from some people with this more economics background. And another sort of side goal here is really to not piss off too many people with the oversimplifications of some of these topics. So to jump right in here for the agenda, I'm going to really try and rapid fire cover proof of stake in two minutes. Wish me luck.
00:03:27.688 - 00:04:33.548, Speaker C: And then really talk about these liquid staking tokens and protocols and the goods from the market and the bad for the protocol, and then talk about what are some of these desirable properties that we can try and build into protocols today without really relying on anything like enshrining anything. And so some things we'll talk about is reputation based versus sort of capital based, and then talk about some of these more technological mechanisms like antislashers and DVT, and then some new research that we put out a month ago on these things called smoothing commitments, and then maybe end this with maybe not a very aligned thing, but self capping, which I think is something that a lot of protocols should consider. So to jump right in, here's my attempt at proof of stake in two minutes. So you can kind of think of it as just this contract. And there's a couple of rules here. You have to deposit your ETH, you have to attest to the correctness of the chain, and occasionally you're going to propose blocks. And what you really have to do is not get slashed.
00:04:33.548 - 00:05:24.460, Speaker C: And so if you agree to these terms and do your job, you're going to be entitled to some type of payout. And if you fail to follow these, you can forfeit some or all of your deposit. And so this is really a contract between Ethereum and the validator. And of course, because Ethereum is this protocol, we don't really have to trust it, we can really trust ourself as a validator to follow along. And so let's kind of just try and get some of this jargon out of the way to try and demystify some of this. So kind of what I think of as a validator here is just one of these instances of 32 ETh. Like someone that is committed to performing validation for the proof of stake chain, a solo staker would be someone that really puts down all of their own capital.
00:05:24.460 - 00:06:14.332, Speaker C: And usually these are kind of people running this from their homes, also known as a solo validator. I think a lot of these terms are really used interchangeably. So I'll try and stick to these and then node operators, because we're going to be talking in the context of liquid staking protocols. And really what I think of as a node operator is someone that is running one or more validators, but they're not necessarily putting down all of the capital, and there's some of these jobs. So proposing, we've sort of seen all these talks throughout this week about different mechanisms around proposers, like Justin talked today about aps. So proposers are when these validators in sort of today's world are randomly chosen to add a block to the chain. And it's the job of the other validators to attest the correctness of these blocks.
00:06:14.332 - 00:06:58.988, Speaker C: So slashing happens when a validator really conflicts with themselves or contradicts themselves, also called equivocation. And really, if they're offline, they will be kind of penalized, but not as severely as if they were slashed. And there's a lot of caveats here on correlation and inactivity leaks. But I think for the purpose of this talk, just sort of understanding these terms is a good starting point. So now, liquid staking, it's this thing that's here. And really, I think there's a lot of motivation from the market. And so I guess from the market's point of view, I really want these staking rewards I want to earn from proof of stake validation.
00:06:58.988 - 00:07:47.840, Speaker C: But maybe I don't have the 32 eth capital. Maybe if I have the capital, I don't want to lock up my Eth because there's this opportunity cost where I could be putting that Eth into something else. Maybe I just don't know how, like I'm not a technical person, I don't know how to really use the command line. Or maybe I am technical and I just don't trust my own performance, because I can always get penalized sort of accidentally by flashing myself, essentially. And also, there may be people that just don't have access to the infrastructure. Maybe their computers don't have the memory or storage requirements, or they don't have access to the bandwidth. So from the point of view of the market, this is really where liquid staking protocols are useful.
00:07:47.840 - 00:08:51.540, Speaker C: So to really dive into how these could work. So the user, or kind of overloading the term, but I think this is kind of standard that we refer to them as the stakers are going to deposit ETH into the pool. And this could be sort of any arbitrary amount of ETH, and they're going to mint one of these liquid staking tokens, and this ETH is then pooled into some kind of contract. And these node operators are then able to match, to sort of acquire this ETH in order to deploy and run a validator. And the idea is that as the validators or the node operators perform their job, the LST will accrue value from the proof of stake rewards. And the caveat here is that they will also accrue any penalties from the node operator. And the idea is, eventually a staker may redeem their initial ETH deposit, plus any rewards, and of course minus any penalties, by burning this LST.
00:08:51.540 - 00:09:52.020, Speaker C: So, just to drill this in like a visual example here, if we have Alice, and she wants to deposit Eth into this pool at, let's just say the start of the protocol, she would mint one LST. And so now these node operators are going to be matched with this ETH. And I'm kind of leaving it vague because we're going to really dive into the different ways that they can get matched and they're going to do the job of running the validators. And this liquid staking protocol will accrue these rewards so that over time Alice should be able to go and burn this LST and get back more than her initial deposit. And hopefully here, because we're really trusting these node operators to have done their jobs correctly. So if we go and revisit our points of why people kind of are gravitating towards these lsts, we can kind of contrast that here. So now I can really stake any amount of ETH.
00:09:52.020 - 00:10:30.544, Speaker C: I don't need this 32 eth capital. So it's very convenient for a lot of people. Maybe if I didn't want to lock up my ETH before, now I have access to this liquid token that can be used across DFI, and if I don't know how, well it doesn't matter. I can be nontechnical because I'm not really doing anything but providing capital at this point. And now I don't have to trust my own performance, I can just trust these other guys to do that. And of course if I don't have access to the infrastructure now, all I really need is a mobile phone to make this deposit. So it's pretty convenient from the point of view of stakers.
00:10:30.544 - 00:10:54.936, Speaker C: And now from the point of view of the node operators, it's also pretty convenient. I don't need 32 ETh to run a validator. I can use significantly less than that. In some cases I also risk less. I'm like putting down less capital. So in these worst case scenarios where there's these mass slashing events, I'm actually risking less of my own capital. And of course I can start to reuse my own hardware.
00:10:54.936 - 00:11:46.568, Speaker C: So if I'm only putting down say 16 eth, now if I had the same capital, I can amortize these costs of my fixed hardware costs and run multiple validators on the same instance. So this is efficient and it really means that I can also extract more meP. So from the point of view of these node operators, they also like these liquid staking tokens. But of course if we want to think long term, we really have to keep track of Ethereum's needs. And so what are the consequences here? One is less economic security. That should be an unhappy face. Another thing is it introduces these new centralization vectors, where a lot of node operators can start to amass more and more stake and have more control over the network.
00:11:46.568 - 00:12:40.268, Speaker C: It also means that, and something that we're seeing today is that our consensus thresholds are starting to be threatened, like the one third and one half. And I'll get to this in a little more detail. Another thing is proof of stake network congestion. We have way too many validators compared to the number of people operating them, and this has really led to an actual bug this year for having just too many validators for the clients to handle. And another consequence of this is that there is too much issuance, like we're running kind of more validators than we need, and this creates more and more eth. So with all this said, how is this played out? And as you might guess, not very well. We see that there is sort of heavy concentration from one protocol, and kind of not clear signs of it slowing down in this.
00:12:40.268 - 00:13:59.912, Speaker C: I think this is a graph of deposits, so it says 33%, but I think when you factor in the actual withdrawals as well, they're still a little bit below this threshold. So if we look at this is clearly a problem, how can we try and do things like some solutions here? And I think a lot of these solutions have been talked about in the past two days, but one is really, if we look from the inside, what are these in protocol mitigations, like enshrined solutions that can help us? One from Mike is to increase the max effective balance. This really helps with that problem of congestion where we don't need as many individual validator kind of units for the amount of stake that they have. Another mitigation is coming in the next hard fork to actually just slow the rate at which these validators are able to join the protocol. So this is more of a mitigation to kind of buy us more time to think of these in protocol solutions. There's been a series of posts on potential research avenues for enshrined solutions, but these are still in their early research phase. And of course I think things like Mevburn really solve a lot of these core problems, but are again kind of a couple of years out.
00:13:59.912 - 00:15:07.096, Speaker C: So with that being said, what are things that we can do today out of protocol? What are some mechanisms that we can start to incorporate into our designs? And another way that I really can phrase this is how can we build just better liquid staking protocols in the short term, and I have better as an asterisk here because I think this is pretty opinionated, but I'm going to try and cover a lot of these different mechanisms. So first of all, what would we describe as desirable properties? So it should be permissionless. This means anyone should be able to operate, be a node operator within an LSP. It should minimize slashing risk, because we're giving in a lot of these protocols, we're giving extra leverage to these node operators. So we need these mechanisms to kind of sort of reduce the risk that they're able to slash and attack the network. We also need to incentivize for good performance because we need these, the stakers putting down eth kind of want these rewards. And if we want to build a competitive kind of liquid staking protocol, we need the node operators to also be aligned.
00:15:07.096 - 00:15:45.604, Speaker C: Governance minimization is important. I'm not going to cover that in this talk. And then something on ethos alignment, like it's good to self cap your validators skipping over here. Okay, let's talk about minimizing slashing risk. So first of all, one thing is that one problem we have is that node operators can slash themselves, and this could happen accidentally or maliciously. But from the point of view of Ethereum, it's viewed as an attack on their consensus. And from a point of view of the stakers in these protocols, it can completely erase their capital.
00:15:45.604 - 00:16:39.876, Speaker C: So this is a problem, and we need to align the node operators to make sure that they're not doing this intentionally. And so kind of the easy solution here is to use reputation as the threat of lost social capital to discourage these node operators from attacking. And so this is convenient, but I don't think it really solves the issue. So if we were to look at our players again, we have Alice here as the staker. And in the case where the node operator slashes and kind of attacks the protocol, Alice is unhappy because her ETH and the value of this LST has been diminished. Ethereum is sad because we've kind of attacked the protocol, but from the point of view of the node operator, all that's really happened is they've lost their job. And so you can see that this might not be totally aligned.
00:16:39.876 - 00:17:14.416, Speaker C: From the point of view, though, of the liquid staking protocol, this is extremely capital efficient. We don't really require these node operators to put down anything. And this means that it's really highly scalable. They can run the same hardware, they can get access to tens of thousands of validators. But this kind of just compounds the risk. And so again, from the point of view of Ethereum, this means less economic security. This permission design really introduces a lot of governance requirements and governance attack vectors, and these node operators are getting infinite leverage.
00:17:14.416 - 00:18:08.212, Speaker C: So something better that we can do is to put something at stake. And so this is to use eth capital to discourage these attacks. The idea, and this is kind of the sort of rocket pool first proposed this, the validators are going to put down some kind of bond. And so maybe this term is overloaded and might be confusing for everyone, and I don't really prefer it, but kind of, the industry calls these bonds for the node operator, and the idea was to economically bond them so they have equal skin in the game. In this case, if they put down 16 e, if they are slashed, they have as much to lose in the worst case as the stakers. And so these liquid staking protocols prefer this. I mean, it's not as efficient as these reputation based systems, but it provides better insurance for the actual stakers.
00:18:08.212 - 00:18:50.032, Speaker C: It's permissionless, anyone can operate. And from Ethereum's point of view, it's not as great as the economic security of running solo stakers, but it's still kind of a better trade off than these reputation based systems. So now to kind of move on to some of these other types of mechanisms. So the first one is anti slashers. So this was first proposed from Justin and his liquid solo staking piece. The idea is essentially to build a hardware wallet for your validator keys. And the idea is that this will prevent you, like the hardware itself has this logic to prevent you from signing any slashable messages.
00:18:50.032 - 00:19:37.264, Speaker C: And how do we do this? Well, you can use hardware based trusted execution environments. And the real reason here is that there's kind of two nice side effects. One is we're completely eliminating this class of slashing due to user error, which has been, to this point, kind of the only slashing events we've seen. The idea is if your keys live in this box and the key cannot move out of this box, then you're not going to accidentally spin it up and run it on another machine and double sign. But also for those people that are kind of nefarious and trying to actually self slash, at least this adds friction. Like these trusted execution environments aren't infallible, but you still would have to break it. And in that case, you get back your validator key, which is the status quo.
00:19:37.264 - 00:20:20.780, Speaker C: So this adds some friction. So at puffer, we built this as part of an ethereum foundation grant, but I'll kind of skip over the implementation to get into some of these other mechanisms. So another one is DVT, also known as squad staking, or consensus for consensus. The idea is that we're going to split this key share into a bunch of shards, and require some kind of quorum to generate any valid signature. So this requires collusion and sort of, just to see an example here, if everyone's honest, we produce a signature. If one person is malicious, we can still produce a valid signature. If two are, then we're not actually going to produce a valid signature.
00:20:20.780 - 00:20:58.536, Speaker C: And the sort of way that we can slash ourselves is if three out of four or four out of four are malicious. So now to skip over to some sort of incentives for good performance. The kind of obvious one here is that node operators are paid for their service. So essentially if they do the job well, the better performance, they're going to earn more from consensus and execution rewards. And in the future, I'm sure Kaido will talk about this some restaking rewards as well. But there's still some remaining problems here. One of them is mediocre performance.
00:20:58.536 - 00:21:54.816, Speaker C: So even if you're using one of these bonded models where the node is putting down collateral, if they're online and about as much as they're offline, they're not going to generate any revenue for the protocol, but they're going to be kind of floating at 32 eth. And so there's this opportunity cost where they're essentially denying rewards to the pool. Another one is rug pooling, which Justin had talked about in the earlier talk, where there's this incentive to steal these blocks that are worth more than their bond or their collateral. So one thing that we were working on are these things called smoothing commitments. And the idea is to just, you can pay upfront to run a validator for a certain amount of time. So during this time the nodes are able to keep all of the rewards that they had generated. So this is consensus and execution rewards, and they can arbitrarily extend these durations by paying more.
00:21:54.816 - 00:22:54.960, Speaker C: And this is very similar to the whole idea of paying for these tickets in aps. So just to really look at this, so you pay for this smoothing commitment for a certain amount of months, and during that time you get to keep all of their rewards. And the stakers kind of have these better aligned node operators. So maybe I'll just sort of get to some open questions here are like what is the best way to calculate these smoothing commitments? The idea is that they want to pay close to the expected value of running the validator minus some discount for profit. And so one thing is to look at a lot of past historical data and these current on chain metrics, but something else is to actually use some kind of auction mechanism to discover this price. And finally, kind of, why do we want to do this? Well, it helps align the incentives. Like the node operators have to be performing well in order to recoup their initial fee.
00:22:54.960 - 00:23:37.712, Speaker C: It also decouples performance from rewards. Now, the node operator can be like a mediocre node operator, but from the point of view of the liquid staking protocol, they've already paid the expected value from this validator. And it also addresses rug pooling, because we really don't care if they take the MEV because they've kind of paid for those rights. And finally, this also kind of addresses protocol growth. So they're able to node operators, when they join the protocol is when they're actually paying rewards to the stakers. So as opposed to slowly paying them out over the course of several months. And I think with that, I'm kind of out of time.
00:23:37.712 - 00:23:54.310, Speaker C: The last thing is just self capping. We really encourage people building these liquid staking protocols to try and cap the amount of stake that their validators can get to something like 22%. And with that. Thank you. Yeah, I'll leave it there.
00:23:57.900 - 00:23:59.850, Speaker B: Thanks, Jason. Questions?
00:24:05.180 - 00:24:47.300, Speaker A: Hi, thank you for the talk. I have a quick question, just something I've been hearing from a lot of the staking companies when they talk to their stakers. So in a lot of the analytics model we present is that we talk about social sashing as a weak form of slashing. But in real life, social sashing are informed through legal sashing. And some people, traditional finance, a lot of people call this kind of sashing as infinite slashing, because you go to jail if you screw up where you breach their contract. So how do you think if we treat social sashing through these legality contract in a more trusted relationship, where the cost from deviating for the protocol is actually much more than 32 e, things like that? Curious your thoughts?
00:24:47.720 - 00:25:28.004, Speaker C: Interesting. Yeah, I guess maybe I can't speak too much to the legal side, but I think that is something that I glossed over on the whole reputation based thing. So you're losing your job, but there are also kind of consequences beyond the context of the chain. So you're losing reputation sort of on chain, but you're also probably in some sort of legal agreements with some of these protocols. But if we're trying to get to this world where we have permissionless protocols that might also rely on reputation, I think that's also where things start to get hairy. We don't really know, I guess. Or we couldn't really enforce anything legal in that sense.
00:25:28.122 - 00:25:29.350, Speaker A: Got it. Thank you.
00:25:31.720 - 00:25:53.340, Speaker B: Other questions? Let's thank Jason. And the next speaker is Skydo from my gamelayer. He's going to talk about PBS for ABS.
00:26:03.230 - 00:26:28.130, Speaker A: All right, first of all, thank you for the invite and thank you for putting me at a very challenging spot. It's 03:00 p.m. It's the sleepiest time for any conference, so I'll try to keep this a little bit more entertaining. I would say the slides, I try to remove all the memes, but I'll try to make this a little bit fun through my narrative. So today I'm going to be talking about PBS for avs. Offloading avs compute. You might not know what avs is.
00:26:28.130 - 00:26:36.242, Speaker A: Don't worry about it. Treat it as an acronym. Black box for now. We're going to talk about it shortly. My name is Kaido. I'm a protocol researcher at egenlabs. We build eigen layer.
00:26:36.242 - 00:26:55.820, Speaker A: Sriram talked about Egen layer yesterday, so I'm not going to go too deep into that. A quick disclaimer. Overviews are my own, doesn't represent my employer or my colleagues. And I want to give a quick special thanks to Drew, who's probably in the audience, but the light's really bright. I can't see you. Say hi to him afterward. A lot of these ideas also come from him.
00:26:55.820 - 00:27:39.914, Speaker A: And now the disclaimer out of the way. I want to preface this talk by saying I'm not an expert in a lot of things I'm going to be talking about here, but the hope of this talk is to get a lot of you guys who are expert in very, very numerous domains to think about really important problems. Okay, so the outline is very simple. I'm going to talk about four different things. Why PBS? What is ABS? Why PBS for ABS? Lastly, what are some open questions? First, why PBS? We spend this entire morning talking about a lot PBS. So I'm going to keep it super short, but try to talk about represented in my own mental model. So, YPBS, we start with some observations, namely three.
00:27:39.914 - 00:28:18.098, Speaker A: The first one is block building ability impacts validator yield. The second one is build the most profitable block is difficult. The last one is block building ability compounds. A quick TLDR to summarize all these three is if you build a really good block you can make more money therefore build better blocks. And what this observation could lead to is the following scenario. Imagine a builder and a validator pool merges. The validator pool can offer higher APR because you can build better block and the stake curves will give more stake to the validator pool because it offers more APR.
00:28:18.098 - 00:29:03.890, Speaker A: And I put it in bolt because we're going to touch on this a little bit later. And because you have more stake, more AuM, you can reinvest more of your fees into building better blocks. You offer more apR, you get more stake. The cycle continues. So this is why PBS was placed such that we want to equalize the difference in validator rewards, because difference in validator rewards could lead to centralization. We spent a lot of morning talking about it, so I'm just going to leave it like that. And the current implementation of PBS is mefboost and it represents validator can access a permissionless market from builders who build the best competitive block.
00:29:03.890 - 00:29:49.422, Speaker A: However, MEV is not the only source that contribute to different yield within Ethereum. These are different ways that you can have different yield profile or rewards profile based on what validator pool you choose liveness how often your validators are up slashing risk. What if your validator is wrong? You double sign custody risk. What if your validating pool actually loses its key? This happened in 2021 when a staking pool lost $50 million worth of validator, a staker's stake. Lastly is what we talked about MEv, which means you become better at block building. You have more mev. There are also some other factors that contribute to different yield profile.
00:29:49.422 - 00:30:26.126, Speaker A: One of them, Jason, just talked about liquid staking. You have different capital efficiency parameters, you can do different things. And in this talk I'm going to focus on the last one is avs, which is introduced by Eigen Layer. What is an avs? Avs stands for actively validated services. Instead of explaining what that is, I'm going to just talk about why that exists. I think that's going to give you a quick mental model on how to think about and reason through about them. So one reason in my view, Ethereum is really, really successful is because all these different decentralized applications we build on top of Ethereum share the same security.
00:30:26.126 - 00:31:11.706, Speaker A: And because we all share the same security, it's very easy for me to call another contract knowing the execution of the other contract is going to be correct. I don't need to think about what is the economic security of the other contract, and I only need to understand what's the code that's trying to do. And because of this trust, it's very easy to have composability and build different building blocks. As you can see from this diagram where Ethereum is a base trust layer and the security sort of inherents upside to the upwards of the stack where you can build apps across different apps. And that's already, we're already seeing a lot these different application innovations happen. However, in the middleware world where you have different bridges, oracle coprocessors, sequencers. In this world, each one of these proof of stake systems have their own trust network.
00:31:11.706 - 00:31:53.210, Speaker A: And for you, if I'm a DAP developer, I want to build DAP on top of a bridge and an oracle. The security is fractured. So I have to care about, okay, what is the security property of these individual systems. And then moreover, my DAP security is the lower of the two. For example, if the bridge has a million stake behind it, the Oracle has 100 billion stake behind it. I build a DAP on top of these two, my economic security will just be 1 million because it's a lower of the two. And so what egenlayer aims to do is the following, where you have the same shared economic security network, Ethereum, and then you build eggelayer as a smart contract where other people can build these different middlewares on top of it.
00:31:53.210 - 00:32:36.962, Speaker A: And these different middlewares right here were bridges, oracle coprocessors, sequencer, and there's many, many different other ideas. And these things are basically what we call ABS. And now if you're application developer, you're tapping into, you want to build on top of this bridge that's dependent on Eggon layer, then your trust assumption is much more secure and you have better composability across the different apps as well. All right, quick understanding on what these things are. And here I want to give a very interesting mental model that I don't think many people have thought about. It's the relationship between PBS and ABS. So on top is PBS, you have some staker, validator, proposer, but we're just going to think about them as a very simple person who contribute capital.
00:32:36.962 - 00:33:40.058, Speaker A: They're staker, the delegates some of their responsibility, such as proposing or building a block to the builder to an external party, and the builder builds the block for an underlying protocol, and in this case, Ethereum. In the ABS world, the following mental model could be applied where you have some staker who delegate their stake to an operator. Now you can see here the operator is a more generalized function than the builder because builder only does one role and the operator runs some kind of underlying protocol to secure some additional services. So one way you could mentally think about ABS and PBS is that ABS is a generalization of PBS. PBS only focus on builder. ABS focus on doing a lot of other things, giving to outside party. Now the question is why PBS for ABS? If we go back to the original point I was trying to make with why we even want to do PBS, is that when we have different yield profile, centralization pressure emerges.
00:33:40.058 - 00:34:23.162, Speaker A: If we think about the block building world, where building block could impact validator yield building, the most profitable block is hard. And lastly, building block ability compounds. That's the current block building world. What does it look like for the ABS world? ABS ability, if you are a solo staker, where you are a state contributor, if you validate all the ABS out there, all the middlewares, presumably you could get higher yield. So that's a check mark. The second part is if you want to validate all the ABS out there, such as for example, these are some very simple example abs with different complexity. If you want to validate all of them as a solo home staker or at home operator, it could be pretty difficult.
00:34:23.162 - 00:35:00.902, Speaker A: The last part I'm not really sure. So I just put a question mark. Maybe it doesn't compound, maybe it compounds. So the point I'm trying to make here is the introduction of abs also changes the yield profile of the underlying protocol. So therefore, because of this is happening, we should think about how can we separate this computational load on the validators outside of Ethereum network. So this is one way that's proposed by Drew and others, which is called PBS for ABS or RPBs. R stands for restaking here.
00:35:00.902 - 00:35:38.638, Speaker A: And the idea is the following, where you have the validator, who will contribute capital, who are Ethereum validators. They have a permissions list, access to a bunch of ABS coprocessors. I'm not going to provide definition for coprocessors because I don't want to offend anyone. But think of coprocessors as just they're doing some sort of computation for a given task. And because the validators, now they're no longer doing the tasks themselves, they can offload to these coprocessors to do these tasks and return the header similar to a block builder. And let's run into example, a little bit complicated. So I'm going to start looking at the screen and use the pointers.
00:35:38.638 - 00:36:06.410, Speaker A: So let's first think about who are the participants. You have Bob we're going to name that as a validator. And you have a market of Jane, Tim, Fred, and Alice, and they're the co processors. Let's say the task I want to do is compute one plus one, right? And that's the only task I want this co processor market to compute. But Bob is like, I'm really lazy. I just do not want to do this today. So what Bob is going to do is say, hey, help me compute this task specific task, which is one plus one.
00:36:06.410 - 00:36:45.478, Speaker A: And then each of them is going to sort of bid on the ability to compute that task for Bob. Let's say Alice ends up submitting the lowest bid, saying, hey, I'm going to help you compute one plus one, and I'm going to only charge you 0.1 eth. Alice wins this auction. To compute one plus one helps compute one plus one, which is equals two, send it to Bob. Bob verifies the response is correct, signs it, send it to the right some verifier. If there's no slashing, meaning the response Bob submitted is correct, Bob and Alice end up splitting the fee.
00:36:45.478 - 00:37:16.846, Speaker A: However, if Bob gets slashed, meaning, for example, Alice responds is three, then what's going to happen is Bob will get slashed. But since Alice is one of the coprocessors, Alice will compensate Bob for his mishaps. This functions very similarly to block building. And here's the analogy. Bob is a validator. These are the builders. And this interaction between Alice and Bob is going to be the relay submitting, propagating the proofs.
00:37:16.846 - 00:38:07.454, Speaker A: And then Bob proposes to Ethereum. If this block is valid, there's no slashing. Then Bob and Alice will split the fee. However, this part currently is missing the current builder world, but with builder collateral we talked about in the morning, it could be implemented very soon. All right, so this is a very general idea of rpps. And after I talk about how abs could be mapped into this model and how building PBS could be marketed into the model, one realization I had is rpbs can be thought of a generalized PBS, or what I call a pcs, just proposer compute separation. What does that mean? So, proposer has ability to tap into a very vast compute market, and we're going to call this compute market coprocessors.
00:38:07.454 - 00:39:22.620, Speaker A: And all the proposer will do is instead of them doing any sort of these difficult computation, whether it's block building or running different abs, it's going to just let the coprocessors do it. But the coprocessor in this way cannot cheat the system through ZK, proof of the compute is done correctly, or some sort of optimistic economic security model. And given this model proposer compute separation, we can extract a lot of the centralization pressure from the proposer and Ethereum validator levels. But on top of it, because we build this competitive coprocessor market, another way to think about this is something I had a lot of discussion with people from Flashbot, is think about what is the proposer actually doing in the current model? In the current model, the proposer is no longer proposing a block, it's actually signing on a block. So maybe the other way to describe proposer compute separation is to think about proposers as only signers. And this external coprocessor market is we're going to call computers because they compute, but rs because rust is really good. So that could be another way of thinking about this market.
00:39:22.620 - 00:40:36.238, Speaker A: And as you can see now, I'm very not sure of what this market is going to look like, how it's going to evolve, and what are the roles we should assign to different people. So that's why I think the open problem become really interesting. So the first open problem I want to challenge everyone in the audience to think about is even the current PBS assumption accurate. So, one of the key assumptions under PBS, where we want to take yield outside from the proposer level, is because one belief that we have, which is staking yield, higher staking yield, pushes more stake to validator pool. Is that true in real life, for example? If so, what is a relationship of stake under management and a validator's yield? If not, what are the other factors that play a role in staking pool? Stickiness give you guys some reason to think about why this may not be the case. Is Yuri have a very interesting stats where for Coinbase staking, the average amount of staker give $600 to Coinbase. For them to switch a staking provider, it will cost them around $10, and that's a huge part of their profit.
00:40:36.238 - 00:42:07.966, Speaker A: So therefore they're not going to switch their provider whatsoever. So that's one interesting open problem, which is examining our assumption on PBS in the real world, does it actually apply? The second one is on this pcs RPBS PBS for avs idea, which is how do we design this general compute platform, a bunch of these different coprocessors for Ethereum validators? What kind of compute can and cannot be offloaded, or should or should not be offloaded? One example is if I want all the Ethereum validators, store my four, a four four blobs. Then maybe we shouldn't offload that proof of custody computation elsewhere. What kind of mechanism can we use to coordinate these coprocessors? It's going to be a very competitive compute platform. How do we allocate tasks? How do we compete? Is it just a simple auction? Who's conducting the auction? Question like this. The last question, which is also interesting from discussion with different folks, is how do we maintain the competitiveness of the coprocessor market through incentive design? One of the problem we see in the builder market is because you're a good builder, you become better and better and better through time because you have more brand easier, talent acquisition things alike. So is it possible for force coprocessors to disclose how they reach their computational steps while being engaging in this market? And the last thing is, what kind of activity are not incentive compatible to integrate? So what does that mean? Is maybe some task should be offloaded, but it's actually not incentive compatible for the coprocessors to offload it.
00:42:07.966 - 00:42:32.120, Speaker A: It's better for them to vertically integrate. So at the end, if any of these problems sounds interesting to you, reach out to me. Let's work on it together. We have a very capable research team, eigenlapse as well. So we'd love to continue engaging in these conversations. I'll keep the presentation short here, but if you have any questions, please feel free to ask me now. Thank you.
00:42:38.810 - 00:42:53.222, Speaker B: Questions. Okay, thanks, Kaido.
00:42:53.366 - 00:42:54.300, Speaker A: Thank you.
00:42:58.030 - 00:43:07.480, Speaker B: So we'll break for 20 minutes and see you back here at 330 for the last session. Grab some coffee. We have two interesting presentations coming up.
