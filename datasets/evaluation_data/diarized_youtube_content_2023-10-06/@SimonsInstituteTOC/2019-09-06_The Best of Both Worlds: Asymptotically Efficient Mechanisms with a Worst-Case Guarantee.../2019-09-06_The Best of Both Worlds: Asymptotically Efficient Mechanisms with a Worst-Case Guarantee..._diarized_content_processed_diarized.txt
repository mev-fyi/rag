00:00:10.920 - 00:00:11.812, Speaker A: Okay, so.
00:00:13.614 - 00:01:00.370, Speaker B: Just had a minute to look at the whole title. It's a fairly long title, so let me just spend the first maybe minute or two, just, you know, say what I mean by this title. So I want to look at maximizing gains on trade in two sided markets. And in the literature, there are essentially two lines of work, two types of guarantees. The first type, I consider them as asymptotic efficient mechanisms in the sense that these mechanisms will say, look at the realized input. If the input satisfies some nice conditions, such as large market condition, the performance is very good. In fact, if the size of the market grows, the performance converges to optimal.
00:01:00.370 - 00:01:49.338, Speaker B: Okay, so that's what I call asymptotic efficient mechanisms. The issue is, of course, what if this large market condition does not hold and there's no guarantee whatsoever there? That's the first type of guarantee in the literature. The second type is a very traditional computer science worst case guarantee that just says no matter what the inputs are, I'll get some fraction of, uh, the performance. Um, but the issue here is, well, maybe your input's actually very nice, it's very easy, maybe actually satisfies the large market condition. And you're being very pessimistic and only getting a constant fraction without hitting, you know, maybe even the optimal. Okay, so uh, in this talk I'm gonna present one mechanism actually gives you both kind of guarantees. Uh, and to the best of my knowledge, that's the first, uh, for this problem.
00:01:49.506 - 00:01:50.334, Speaker A: Okay.
00:01:52.594 - 00:02:33.086, Speaker B: Okay, so uh, so I think for this audience I don't need to motivate like, you know, why two sided markets, very important problem. So let me just, you know, quickly go over the basics. Uh, um, so the very uh, uh, basic setting is bilateral trade. You're uh, you have one item to sell, there's one seller, there's one buyer. And the seller uh, has some private costs for parting with the item, which is draw from distribution. Uh, there's one buyer who has some private value, uh, for uh, getting the item, also draw from a distribution. And so the goal for this talk is I want to find a mechanism that maximize efficiency.
00:02:33.086 - 00:03:09.124, Speaker B: So in this particular case, uh, you should use an allocation that, you know, trades whenever the buyer's value is higher than the cost. All right? So more formally, I would like a mechanism that has the following conditions. I want it to be IR IC budget balance, meaning that the mechanism does not lose money by running. And also I want to use this efficient trade allocation. So that's the basic case. And since we're trying to maximize efficiency, the natural thing to do is, well, let's try to run VCG and see what happens in this case.
00:03:09.504 - 00:03:09.872, Speaker A: Okay?
00:03:09.888 - 00:03:31.826, Speaker B: If you run VCG, so we see the trade happens and the buyer is going to pay $9 because that's the critical value. Whenever the buyer reports higher than nine, trade happens. And similarly, the seller needs to be compensated by $10 because if the seller reports anything less than ten, the trade happens.
00:03:31.920 - 00:03:32.318, Speaker A: Okay?
00:03:32.366 - 00:04:02.334, Speaker B: So you can run VCG, but there's a deficit of one. Okay, so VCG maximizes efficiency, but it's not budget balance, okay? And turns out no mechanism can satisfy all these conditions. There's a quite similar result by Myers, and that's why they show that even in bilateral trade, you cannot have a single mechanism that is interim iron Bayesian IC weekly budget balance and use this efficient trade allocation.
00:04:03.074 - 00:04:03.554, Speaker A: Okay?
00:04:03.594 - 00:04:17.934, Speaker B: So very strong negative result. And there has been a lot of work trying to sort of circumvent this negative result. And the approach is let's try to approximate efficiency while maintaining the other properties.
00:04:18.234 - 00:04:19.050, Speaker A: Okay?
00:04:19.202 - 00:04:24.694, Speaker B: So now I can be a bit more specific about these two types of guarantees that exist in the literature.
00:04:25.214 - 00:04:25.606, Speaker A: Okay?
00:04:25.630 - 00:04:54.788, Speaker B: So the first one I call the exposed asymptotic efficient mechanisms. By expose, I mean that the guarantees on every realization of the type profile, okay? So once you have draw the type profile from the distribution, this mechanism will look at the profile and see if it satisfies this large market condition. If it satisfies, it gives you good guarantee. In fact, you know, asymptotically efficient. Uh, if it does not satisfy, and then, you know, there's no guarantee at all.
00:04:54.876 - 00:04:55.556, Speaker A: Okay.
00:04:55.700 - 00:05:34.742, Speaker B: Uh, in particular, uh, the tray reduction by McAfee is one of, uh, satisfy this type of guarantee. Uh, and I'll explain that mechanism in a minute. Uh, the second type of guarantee is just, uh, worst case guarantee. Here I call it ex ante, uh, worst case approximation guarantee, meaning that I want a mechanism such that in expectation of the realization of the types, its performance is within some fraction of the optimal expected performance. That's a second type of guarantee. So a priority is not clear. You know, these are just incomparable guarantees.
00:05:34.838 - 00:05:35.166, Speaker A: Right?
00:05:35.230 - 00:05:55.882, Speaker B: And the way I would like to think about these two guarantees are. So the first basically saying, like, I will have a very optimistic mechanism that works extremely well if the input's easy, okay? The second one is a more pessimistic type of guarantee that says, I'll have a mechanism that just works reasonably well on average.
00:05:56.018 - 00:05:56.570, Speaker A: Okay?
00:05:56.642 - 00:06:33.174, Speaker B: But maybe it's not doing so well. Even the input's easy. And. Okay, so the plan is I will show you a mechanism of each that satisfy each type of guarantee. And also I'll prove to you that these mechanism, they do not satisfy the other type of guarantee. And I'll show you how you can actually come up with a new one that actually satisfies questions? Okay, so before I describe those mechanisms, there's one more thing I want to talk about. So, we want to approximate efficiency.
00:06:33.174 - 00:06:52.692, Speaker B: So there are two different ways to measure efficiency. One is just a traditional welfare concept. The other one is called a gains from trade. Uh, in fact, I can just think about gains from trade as how much more, uh, welfare you get by running the mechanism. So in this case, once the trade happens, the welfare goes from nine to ten. So the gains from trade is one here.
00:06:52.788 - 00:06:53.544, Speaker A: Okay?
00:06:54.524 - 00:07:15.696, Speaker B: So if you want to maximize welfare, it's just the same as maximize gains from trade. But now we're talking about approximation. The two concepts are actually quite different. If you approximate the welfare, it's very different from approximate against. Look at this example. If I don't trade at all, it's a good approximation for welfare, but it gives you zero gsmt.
00:07:15.840 - 00:07:16.384, Speaker A: Okay?
00:07:16.464 - 00:07:21.928, Speaker B: So. And the goal for this talk is I want to approximate. Guess what?
00:07:22.016 - 00:07:22.464, Speaker A: Okay.
00:07:22.544 - 00:07:26.960, Speaker B: It's a harder task, but that's what we want to compare it to.
00:07:26.992 - 00:07:27.604, Speaker A: Okay?
00:07:28.624 - 00:07:44.042, Speaker B: If you're happy with approximation welfare, there's a lot of nice results, works in quite general settings, but, uh, that's not the focus of the talk. All right, so next I want to introduce, you know, these two mechanisms, each with a different type of guarantee.
00:07:44.098 - 00:07:44.774, Speaker A: Okay?
00:07:46.594 - 00:08:03.184, Speaker B: All right, so, um, so I'm going to be talking about mechanisms that use, uh, mark, large market assumption. So clearly, I cannot be just talking about bilateral trade because, I mean, you only have two agents, okay? So you have to have, uh, at least a setting where, you know, the size of the problem can grow.
00:08:03.724 - 00:08:04.372, Speaker A: Okay?
00:08:04.468 - 00:08:31.744, Speaker B: So I'm going to consider the first one is called the double auction. So you have end buyers and sellers. Each seller has one item. The goods are all homogeneous, okay? They're same type of items, and each seller has a private cost for the item. Draw independently from our own distribution. Every buyer has a private private value. And when I say double auction, what I mean is every buyer can trade with every seller.
00:08:31.744 - 00:09:01.724, Speaker B: That's the selling. And here is the trade reduction mechanism by McAfee. So what you do is the following. You take the profile, you sort them, you sort the buyer's bids in descending order, you sort the solar bits in ascending order. Now you decide Q, which is efficient trace size.
00:09:01.804 - 00:09:02.356, Speaker A: Okay?
00:09:02.460 - 00:09:29.054, Speaker B: The number of pairs you would trade in VCG, say, okay, in this case, Q will be three. And then what you do is you only trade the top q minus one pairs. You only trade these two pairs, and then use the third pair to set the prices. So the winning buyers will pay BQ, which is 60. Sellers will receive 45.
00:09:29.514 - 00:09:30.018, Speaker A: Okay?
00:09:30.066 - 00:09:31.618, Speaker B: So that's the trade reduction mechanism.
00:09:31.746 - 00:09:32.066, Speaker A: Okay.
00:09:32.090 - 00:10:10.940, Speaker B: Very straightforward mechanism. And the guarantee that McAfee provided was that the mechanisms expose ir, expose ic, expose budget balance, and also gives you one minus one over q fraction of the realize gains from trade. So when I say realize, meaning that four, you know, with respect to this particular type profile. All right, uh, the argument is very straightforward, right? So budget balance is because this is also a, you know, possible efficient trade pair. So the buyer value is higher than the solid cost. And, uh, since I'm only dropping the worst pair, I only lose one over q.
00:10:11.092 - 00:10:11.660, Speaker A: All right?
00:10:11.772 - 00:10:35.212, Speaker B: So, and if q goes to infinite, I clearly have something that's almost optimal. The issue is, well, I mean, there's no guarantee if q is one, right? So it's something that does not give you a worst case guarantee. All right, so next, let me show you a mechanism that gives you some worst case guarantee.
00:10:35.308 - 00:10:35.708, Speaker A: Okay?
00:10:35.756 - 00:10:38.784, Speaker B: And I want to first even look at just bilateral tricks.
00:10:39.194 - 00:10:44.854, Speaker C: You mean for the finite market? Sorry, there's no guarantee for any finite market.
00:10:45.474 - 00:11:01.802, Speaker B: It's not going to. I don't understand. You mean for q, it's finite? Yes. Not getting to one. But if you grow the size of the market, it converges to one. That's what I mean by asymptotic efficiency. Why does Q convert to one? So, sorry.
00:11:01.802 - 00:11:16.064, Speaker B: One minus one over q converge. Just one. If I grow the size. So why does Q have to grow with the size of the market? It does not necessarily go with the market. So the size of the market is q. So that's how I'm defining it. The efficient trace size q.
00:11:16.064 - 00:11:24.632, Speaker B: Okay, yeah, if that grows, and of course, if you make some assumptions on the distribution, then you can say when the size of, you know, grows, then q also grows.
00:11:24.688 - 00:11:25.324, Speaker A: All right.
00:11:34.244 - 00:12:03.786, Speaker B: Okay, so let me, uh, give you a mechanism that gives you worst case, uh, guarantee. Um, same off a balance of trade. So if you want to compare to the first best gains from trade, that's just the. The highest gains from trade you can get. Uh, forgetting all the constraints like ir, ic, you know, budget balance, that's the first best gains from trade. If you want to compare to that uh, we only have conditional results, uh, meaning that you have to make assumptions on the distributions.
00:12:03.930 - 00:12:04.282, Speaker A: Okay?
00:12:04.298 - 00:12:45.580, Speaker B: For example, you can get vector two approximation if the buyer's medium value is higher than the medium to seller cost or, you know, uh, some tail condition on, uh, one of the agents distribution. Uh, even to now, we don't have, uh, worst case guarantee, uh, comparing to the first best, uh, without making assumptions on this. So, uh, so what people did is, uh, uh, and find myself. Okay, so, uh, you relaxed benchmark. So instead of looking at the first best, let's look at the second best. Second best is, uh, the highest gains in the trade you can get using a mechanism that's ir, ic and budget balance.
00:12:45.692 - 00:12:45.972, Speaker A: All right?
00:12:45.988 - 00:13:15.100, Speaker B: So that's the second best benchmark. And, you know, turns out if you want the optimal second best, it's something quite complex, even in bilateral tray, if you go to double auction, it's something, it's a monster. So you don't want to look at that. So what we did is we look at an approximation to the second best. So this is a result with my student and postdoc. We show that you can have a quite simple mechanism that gives a half of the second best gains in trade.
00:13:15.252 - 00:13:15.620, Speaker A: Okay?
00:13:15.652 - 00:13:49.104, Speaker B: So let me show you the mechanisms. Quite straightforward. So you just randomly run one of the following two mechanisms. The first one I call seller offering. So what you do is the seller post the take or leave a price. And the trade happens whenever a buyer accepts the price. And how does the seller decide the price? The seller looks at his cost and the buyer's value distribution figure out a price that maximize her expected utility.
00:13:50.444 - 00:13:50.900, Speaker A: Okay?
00:13:50.932 - 00:14:04.264, Speaker B: And you can do the buyer offering, which is just a symmetric version of the seller offering mechanism. So randomly pick one of the two, making sure this gives you a factor two approximation, okay? In the balance of trade case.
00:14:08.184 - 00:14:08.600, Speaker A: Okay?
00:14:08.632 - 00:14:27.284, Speaker B: And, you know, you can generalize the mechanism, too. Scenarios where you have multiple agents. It works for double auction. It also works for a more general case, which we call the matching market case. So the difference is now you have a bipartite graph that specifies who can trade with whom.
00:14:31.344 - 00:14:31.776, Speaker A: Okay?
00:14:31.800 - 00:15:05.014, Speaker B: And, you know, the general setting the mechanism is called random virtual warfare maximizing mechanism. So I'll explain why we gave the mechanism this name. So again, you do, you pick one of the two following mechanisms randomly. So the first one, you can think about this mechanism as you're finding an allocation that maximizes the seller's total virtual surplus. So let me explain what it means. Okay, so you have a bipartite graph, right? So that specifies who can trade with whom. Now, for every edge in the bipartite graph, I'm going to assign a weight.
00:15:05.434 - 00:15:05.842, Speaker A: Okay?
00:15:05.858 - 00:15:23.974, Speaker B: What is this weight? So, for an edge between buyer I and seller J, I'm going to assign this weight here. I have buyer's virtual value function. So, if you're familiar with auction theory, this is exactly Myerson's virtual value for this buyer with respect to his distribution, minus the seller cost.
00:15:24.514 - 00:15:24.946, Speaker A: Okay?
00:15:24.970 - 00:15:26.534, Speaker B: So that's the weight on that edge.
00:15:26.954 - 00:15:27.346, Speaker A: Okay?
00:15:27.370 - 00:15:31.154, Speaker B: You assign all these weights to the edges, find the maximum matching.
00:15:31.894 - 00:15:32.398, Speaker A: Okay?
00:15:32.446 - 00:15:33.230, Speaker B: That's the allocation.
00:15:33.302 - 00:15:33.894, Speaker A: Okay?
00:15:34.014 - 00:15:52.302, Speaker B: It's not hard to say. It's a monotone allocation. And, in fact, you know, if you charge the critical values, you can prove there's also budget balance. All right. Um, so I won't go through that proof. But one thing, uh, that might be, uh, might not be so clear. Is why is this the same as the solid offering mechanism.
00:15:52.302 - 00:16:21.734, Speaker B: I was talking about earlier in the bilateral trade case? So there I'm not talking about anything, about virtual values and so on. So here's why. Okay? So if you only have one pair in the market, one buyer, one seller. Now you're the seller. You want to offer a price. Okay, so what is the allocation you should use? So a little thought of review is that you should trade with the buyer. Whenever the buyer's virtual value is higher than your cost.
00:16:22.904 - 00:16:23.480, Speaker A: Right?
00:16:23.592 - 00:16:50.254, Speaker B: Okay, so that's the allocation, the seller offering mechanism. And that turns out to be exactly the same as here. Here you would trade again as whenever the buyer's version value is higher than seller cost. Okay, so the two mechanisms have the same allocation. And, you know, uh, so you can use payment to back up the the prices. So they're equivalent. And you do you know the symmetric version of the seller offering mechanism? Uh, randomly chose one of the two.
00:16:50.254 - 00:17:11.734, Speaker B: Uh, you get a factor two approximation, uh, in the even the metric market. Okay, so this is a mechanism that gives you worst case guarantee, right? So in expectation over the types, you get half of the optimal gas and trade, uh, but turns out not to be asymptotic efficient. Yeah.
00:17:12.594 - 00:17:14.494, Speaker C: Where what's the worst case?
00:17:15.074 - 00:17:16.232, Speaker B: What's the worst case?
00:17:16.338 - 00:17:19.304, Speaker C: The randomization with u two must have something to do with.
00:17:20.724 - 00:17:34.904, Speaker B: You mean, what's the worst instance? So we don't have a distribution that shows two is tight. So in that sense, I don't know what's the worst case.
00:17:36.084 - 00:17:44.870, Speaker C: Presumably, the idea has something to do with randomizing infinite two. The randomization between two mechanisms has something to do with how you get the guarantee.
00:17:44.982 - 00:18:05.910, Speaker B: Oh, yes. Right. So, uh, so basically I'm, I'm relaxing the optimal gains tray to some benchmark. I can use the sum of the two mechanisms gains tray to cover that. So in particular, it will mean that you can just use one of the two and you can still get factor two. Does that make sense? So I'm randomizing between the two. Just so you know, this is easier to describe.
00:18:05.910 - 00:18:08.466, Speaker B: You could do max. I can do the max of the two.
00:18:08.550 - 00:18:10.042, Speaker A: Yeah, yeah.
00:18:10.058 - 00:18:11.882, Speaker B: I can do the max of two. I don't have.
00:18:11.978 - 00:18:12.266, Speaker A: Okay.
00:18:12.290 - 00:18:13.546, Speaker B: Randomness is not necessary.
00:18:13.610 - 00:18:13.930, Speaker A: Okay.
00:18:13.962 - 00:18:24.294, Speaker B: You can just use, I guess, related question. Do you know that one of them may not work? Like, if you use. Yes, if you just use one, it will not work. You need to take the better of the two.
00:18:24.754 - 00:18:25.106, Speaker A: Yeah.
00:18:25.130 - 00:18:41.864, Speaker B: So there are instances when you only do one side. It's not going to work. Yeah. Do you have an intuition for why it doesn't work? Because what I remember, the welfare proxy approximation mechanisms only use the cellular distribution. Right? They don't. That's right. But no.
00:18:41.864 - 00:18:45.316, Speaker B: So first, welfare approximation is very different because.
00:18:45.460 - 00:18:45.788, Speaker A: Right.
00:18:45.836 - 00:18:59.084, Speaker B: Like, just curious if you have an intuition for why you need it here but not there. I'm not sure I have examples. I'm not sure I have this still, you know, some very easy to communicate intuition out there, but, you know.
00:18:59.124 - 00:18:59.300, Speaker A: Right.
00:18:59.332 - 00:19:08.564, Speaker B: So welfare is very different because no trade very often is a good solution there, and it's a very hard case for us. Other questions?
00:19:11.544 - 00:19:12.404, Speaker A: Okay.
00:19:15.184 - 00:19:34.674, Speaker B: Okay, so, um, this is not asymptotic efficient. And here's one very simple example. So consider a very large double auction with, uh, say, m buyers and n sellers consider m, will, you know, increase, uh, to infinity. Each of this agent has value cost sample uniformly between zero and one.
00:19:34.794 - 00:19:35.554, Speaker A: Okay?
00:19:35.714 - 00:20:05.184, Speaker B: So clearly the efficient trace size will be roughly n minus order root n, right? In this case, and if you increase n, just run tray reduction, you will almost get first best, right. You can get any fraction within first best. Okay, so now if you run the mechanism I just described, the random virtual maximizing mechanism, it does not converge to the first best. In fact, it misses at least even a constant fraction of the second best.
00:20:05.804 - 00:20:06.284, Speaker A: Okay?
00:20:06.324 - 00:20:56.872, Speaker B: And the reason is just because I'm using virtual value to decide whether I'm trading instead of really the value virtual value. Usually there's a gap between virtual value, so I'm missing a big trunk of the trades. So I won't go into, you know, details, but you can show that if the buyers have value between one two and two, three and the sellers have cost between one three and one two. Like no trade will happen, even though it's actually beneficial to trade, because the way the mechanism is set up, like no trade will happen. And that will just make you lose a constant fraction of the gains from trade. So it's not asymptotic efficient. So the goal is I want one mechanism that has both guarantees.
00:20:56.928 - 00:20:57.216, Speaker A: Okay?
00:20:57.240 - 00:21:07.164, Speaker B: So it's exposed asymptotic efficient with respect to the first best, as x anti approximates the gains from tray. Now I'm comparing to the second best.
00:21:10.784 - 00:21:25.710, Speaker A: How fragile. So she did a little perturbation of incentive compatibility. So we wanted incentive compatibility to an epsilon. Would we suddenly get very close to the optimum?
00:21:25.862 - 00:22:01.960, Speaker B: No, I think you would need epsilon to be some, you know, big constant. That's, I mean, some constant is comparable to this fraction. Because the reason is the tray here does not happen because you're looking at a virtual value, and that's the way to maximize utility. So you want them to trade whenever buyers value is higher than the seller cost. So basically, that's not a utility maximizing mechanism. So you basically have to have the epsilon in the IC so large that they're willing to change from the utility maximizing mechanism to a mechanism that always trades. So you will need the epsilon to be fairly big.
00:22:01.960 - 00:22:36.026, Speaker B: It cannot be something that's. Yeah, we can talk about that. So I'll show you one mechanism that, uh, achieves both. Uh, one thing I want to point out is, uh, if we're in algorithm design, this is a trivial task, right? If you have an algorithm, you have two algorithms. One is asymptotic efficient. The other one, you know, gives you some worst case guarantee. Not one algorithm that gets best of both worlds.
00:22:36.026 - 00:22:41.414, Speaker B: That's trivial, right? Take your instance, run both algorithms, take the better result, you're done.
00:22:41.794 - 00:22:42.418, Speaker A: Right.
00:22:42.546 - 00:22:43.490, Speaker B: It's for algorithms.
00:22:43.562 - 00:22:44.226, Speaker A: Okay.
00:22:44.370 - 00:23:03.484, Speaker B: In mechanism. Turns out that's not, okay. We have two mechanisms, and one is asymptotic efficient. The other one has worst case guarantee. You cannot just simply run the two mechanisms and take the better one because it's not going to be incentive compatible. So that's the tricky part. I'll show you one example where this actually happens.
00:23:03.604 - 00:23:03.956, Speaker A: Okay?
00:23:03.980 - 00:23:27.176, Speaker B: So you have to do something more careful. So just remind everyone that the big picture. So the optimal mechanism, quite complex, hard to design. We have worst case guarantee. We also have asymptotic optimal mechanisms. We're looking for something that lies in the intersection.
00:23:27.240 - 00:23:30.088, Speaker A: Okay? Okay.
00:23:30.136 - 00:23:40.444, Speaker B: And for the rest of the talk, 20 minutes. How long? I have 1012 so standard eleven.
00:23:43.024 - 00:23:45.304, Speaker A: All right. Okay.
00:23:45.344 - 00:23:50.484, Speaker B: The rest of talk. So I think I can depth. How long do I have?
00:23:51.164 - 00:23:51.904, Speaker A: 20.
00:23:57.484 - 00:23:58.988, Speaker C: Just a factor to approximate.
00:23:59.076 - 00:23:59.744, Speaker A: Yeah.
00:24:00.684 - 00:24:07.020, Speaker B: Oh, so 20 is good, then. Okay. I don't know if you're minimizing or maximizing, but okay, fine.
00:24:07.212 - 00:24:07.596, Speaker A: All right.
00:24:07.620 - 00:24:33.484, Speaker B: Okay, so I'll show you a mechanism that gives you both guarantees for double auctions, and then I'll talk about matching markets. Um, in fact, uh, McAfee's trade reduction was only defined on double auction, was not defined on metric markets. So we have to first come up with a generalization of that mechanism for metric markets. And now show you how you how you can get, uh, modify the mechanism to get both type of guarantees.
00:24:35.544 - 00:24:36.008, Speaker A: Okay?
00:24:36.056 - 00:24:42.844, Speaker B: Double auction. Okay, so here, uh, is, uh, this very naive approach I was talking about.
00:24:42.984 - 00:24:43.836, Speaker A: Okay?
00:24:44.020 - 00:24:45.260, Speaker B: So let's try to do this.
00:24:45.332 - 00:24:46.044, Speaker A: Okay?
00:24:46.204 - 00:25:12.520, Speaker B: So for the reported profile B's, I'm going to first compute the q, the efficient trace size, okay? If Q is at least two, I'm going to run the trial reduction, because already there you have some guarantee, right? One minus one over q. If q is one, tray reduction gives you nothing. In fact, tray reduction will not even do anything. I'm going to run this random virtual welfare maximizing mechanism.
00:25:12.632 - 00:25:13.080, Speaker A: Okay?
00:25:13.152 - 00:25:14.284, Speaker B: That's what I'm going to do.
00:25:15.504 - 00:25:15.920, Speaker A: All right?
00:25:15.952 - 00:25:45.460, Speaker B: So let's look at one particular example. So I have, let's say, only two buyers, two sellers, okay? And now if I run this particular mechanism and say b two has value 98, q will be two, right? So I run trade reduction. So this edge will be reduced to trade only, uh, the only two pairs are trading. The only two agents are trading are b one and s one.
00:25:45.532 - 00:25:46.264, Speaker A: Okay?
00:25:46.884 - 00:26:35.824, Speaker B: So that's what happens in this mechanism, okay? Now imagine that b two, uh, is 80 instead of 98, okay? Not only have q equal to one, right? Because this edge is no longer an efficient trade. So q is one. So I'm not running a trade reduction. I'm jumping to this step, okay? I will run this random virtual maximizing mechanism. And if you compute the virtual values for the buyer and the two buyers, you will see that the only edge that can trade is actually this edge, okay? So the virtual value of b two is positive. The virtual value of b one is negative. So this is the only edge that can trade.
00:26:35.824 - 00:27:15.364, Speaker B: And so that means if b two reports 80, she actually can trade. So that just gives incentive for the second buyer to lie because there's allocation. It's just not monotone. All right? So the main issue here is when q is one, this solid offering mechanism is trading a pair that's not in first best. So that creates this opportunity for buyer two to lie.
00:27:20.864 - 00:27:21.256, Speaker A: Okay?
00:27:21.280 - 00:27:53.020, Speaker B: So uh, here's what we do to fix, fix the problem. So, uh, instead of running the whole random virtual maximizing mechanism, we're just, we're gonna force, uh, the mechanisms only offer tray on the first best edges. Okay, and why is that a good idea? Uh, I mean, the reason is the only way that an agent can lie and gain is, uh, when this agent can lie to cause a switch between q equals two to q equals one.
00:27:53.172 - 00:27:53.984, Speaker A: Okay?
00:27:54.324 - 00:28:04.704, Speaker B: But if I'm forcing, you know, the mechanism to only trade on first best edges, uh, they should just try to get into the first best edges instead of trying to, you know, lie and go to some other possible edge.
00:28:05.404 - 00:28:05.908, Speaker A: Okay?
00:28:05.956 - 00:28:40.746, Speaker B: So, uh, that's the rationale. And, you know, a trivial way to do it is like I can run just random offering on the first best edge, okay? So, uh, it is ic mechanism now, okay. Uh, but there is another issue. Uh, now it's not clear whether this is a good approximation. The reason being that all we know is the seller offering edge will give you a good approximation. Now you're trading on a different edge, okay? In fact, it's not even clear how often you would trade. You're just running some random offering mechanism there.
00:28:40.746 - 00:29:24.444, Speaker B: The probability that the trade happens depends on the distribution. So it's not even clear how often the trade will happen. Okay, so how do we deal with that? Okay, so here is observation that was very useful for us. In fact, it's the key observation that allows us to design the mechanism, okay? So we know the seller offering mechanisms is taking this edge, okay? So that means this edge at least has some positive gains from trade. So b two is greater than s one. And now if you want buyer one to get into the first pass, the buyer one needs to be at least as big as b two.
00:29:24.784 - 00:29:25.524, Speaker A: Right?
00:29:27.284 - 00:29:36.624, Speaker B: Similarly, for s one to get into this seller offering edge, uh, it better be that, uh, s one is lower than s two.
00:29:37.364 - 00:29:37.844, Speaker A: Okay?
00:29:37.884 - 00:30:35.512, Speaker B: So our approach is still, you do random offering on the first best edge. But now I'm gonna add some restriction on the prices you can use, okay? You're only allowed to use prices between b two and s two, okay? Instead of just letting you pick whatever price that optimize, you know, the buyer or seller's utility, you can only pick prices in this range, okay? And this, uh, turns out to be, uh, enough to guarantee the trade happens with good probability. The reason it's quite simple, uh, because this red edge is there. So uh, b two is greater than s one. Uh, in fact, even the verge value of b two is greater than s one. So buyer one, now say buyer one's going to do offering to the seller, okay? Buyer one's going to offer a price that's at least b two, right? Because my restriction, okay, so if you offer b two, s one will accept it, right? Because b two is greater than s one.
00:30:35.608 - 00:30:36.176, Speaker A: Okay?
00:30:36.280 - 00:31:14.704, Speaker B: So make sure whenever at least the buyer, when the buyer is offering, the trade happens on this edge. So here's the hybrid mechanism. So I first compute efficient trace size. If q is at least two, I run the tray reduction. Also I'm going to run the random offering mechanism on the b one, s one pair. And with probability one half, I let the seller offer by saying you can offer a price that's not higher than s two. And also I tell the seller that, you know, buyer one's value is at least b two.
00:31:14.784 - 00:31:15.288, Speaker A: Okay?
00:31:15.376 - 00:31:49.304, Speaker B: So you should choose the price between b two and s two, okay? And do something similar for the buyer. That's the mechanism. And the guarantee that we can provide is this mechanism is ir, big exposed budget balance, and it gives you one quarter of the expected gains from trade of the second best. I'll explain why this is not one two. And it gives you also this asymptotic efficiency guarantee. You get one minus one over q, because whenever q is greater than two, uh, you're running over chill reduction. So you get the same guarantee as the ch reduction.
00:31:49.304 - 00:32:22.884, Speaker B: Um, and the reason that we're not getting one half is basically because you're comparing to this random virtual welfare maximizing mechanism. And so far we can only show that you, uh, cover one half of that always. And that's a factor two approximation. So you get one quarter, but this is probably not tight. Okay, so let me just quickly talk about matching markets. Just to remind you, matching market, the only difference is not have a bipartite graph that specifies the possible trade.
00:32:24.704 - 00:32:25.564, Speaker A: Okay?
00:32:26.184 - 00:33:24.134, Speaker B: So I think I would just spend a few minutes talk about the trade reduction mechanism in the metric market. Okay, so in double auction, we have convergence to efficiency if the market grows. Now how can we define this large market or efficient trade size in matching markets? So if you just simply add, you know, more trading pairs into the graph, that's not going to help, right? Imagine you're going to add a bunch of isolating edges. That's not going to help. Imagine you have n parallel edges, that's just n bilateral tray cases. The trait reduction is not going to do anything to it. Okay, be more careful about how you define this efficient tray size when you actually have an arbitrary bipartite graph.
00:33:24.134 - 00:34:07.954, Speaker B: Okay, so here's one way that we view the double auction and was useful for our, for us to come up with a generalization. So the way we think about this is in double auction, every seller can replace every other seller in a trade. They're replaceable, right? Because everyone can trade with everybody. And so I'm going to basically put sellers or buyers into equivalence classes based on the set of agents they can trade with. So, one thing I want to emphasize here is, I'm talking about equivalence class. I'm talking about sellers can be irreplaceable, but I'm not making assumptions on their distributions. This is just some property about the graph.
00:34:07.954 - 00:34:44.814, Speaker B: I'm not making IID assumptions on the distribution. Okay, so, uh, so for matching market, we basically want to define, say, the number of trading agents of each class will grow large. And I say every two agents in the same class can trade with exactly the same set of agents. So that's how I'm gonna define equivalence classes. Here's one example. So if you're in this market, these two buyers are in one equivalence class because they can trade with exactly the same set of sellers. And you know, for all agents, you can partition them into four classes.
00:34:45.794 - 00:34:46.186, Speaker A: Okay?
00:34:46.210 - 00:34:49.850, Speaker B: So now for every class, I can define the number of trades.
00:34:49.922 - 00:34:50.266, Speaker A: Okay?
00:34:50.290 - 00:34:55.414, Speaker B: So here in this particular matching, this class has trace size, too.
00:34:56.874 - 00:34:57.306, Speaker A: Okay?
00:34:57.330 - 00:35:38.164, Speaker B: In double auction, you just one class for sellers, one class for buyers. So here, every particular equivalence class has this unassociated trade number, trade size. So if I say a market grows large, I mean that the efficient tray size for every class grows large. So this is roughly the mechanism. So take the profile. The top Qt minus one agents will trade, and then the winner agents needs to pay the value for the top reduced agent. And this is the guarantee that we managed to provide.
00:35:38.164 - 00:36:23.196, Speaker B: Uh, so basically you're going to take the minimum across all the equivalence classes and you get one minus one over Qt, okay? And in particular, you know, if every class has trace size at least two, you get at least a two approximation. If there's one class that has one, only one tray, then you don't get any guarantee. So that's a trade reduction mechanism. All right, so I'm not going to talk about the random offering mechanism. The idea is similar. You basically only do the random offering on the first best edges. But now the difficulty is you're going to come up with some prices.
00:36:23.196 - 00:36:51.854, Speaker B: You want to come up with this restriction on the prices. You can use s in double auction. Okay, what's the analog of this? B two and s two in double auctions. So it turns out they coincide with VCG prices for I and J. So you can have actually a very succinct way of describing this upper bound and lower bounds. I won't go into details. All right, so let me just say the main result.
00:36:51.854 - 00:37:26.542, Speaker B: So we show that. So I'm going to use alpha to denote the minimum value between this one minus one over q quantity. And the mechanism is basically whenever alpha is at least one half, you run the true reduction, otherwise run this random offering mechanism. And again, you have the same guarantee as in double auction. You get one quarter of the second best in the worst case, and you get this alpha fraction of the opt, and this alpha goes to one. If the market size grows for double.
00:37:26.598 - 00:37:28.934, Speaker C: Option, you have to restrict the random.
00:37:28.974 - 00:37:32.006, Speaker A: Offering to the first best edges. Right, right.
00:37:32.070 - 00:37:40.838, Speaker B: I'm doing is two. So here you find the first best matching. I'm now for every edge in that matching, I'm running some random offering only.
00:37:40.886 - 00:37:42.714, Speaker C: For the matching in the first best.
00:37:43.654 - 00:38:30.610, Speaker B: Only the address in the first pass. I'm doing a random offering on every edge, and on every edge I'm computing an upper bound and lower bound on the prices you can use. And those prices depend on VCG prices in some settings. So, yeah, so one nice thing I want to point out is you get a mechanism that's also exposed budget balance, expose IR. So if you want interim IR exposed budget balance or you know it the other way, that's quite easy. But if you go on to get both guarantees in both cases, this is actually the first I know that give you this no proof sketch. Okay, so let me just quickly conclude.
00:38:30.610 - 00:39:11.844, Speaker B: So this mechanism is, achieves both types of guarantee. And again, I would like to think about this as a mechanism that gives you some guarantee on the hard instances and very good performance on the ease instances. So this is easy to do for algorithms, but quite difficult for mechanism because incentives. And I think it's interesting to try to find more mechanisms of this sort that can achieve best of both worlds. About timer, you finished early. Oh, maybe I can go back to the proof.
00:39:13.984 - 00:39:14.724, Speaker A: Really?
00:39:15.144 - 00:40:01.256, Speaker B: Okay, I can say a few words about the Dow parent lower bound. So um, okay, so the mechanisms, you find the first best matching on every edge in that matching. I'm gonna do some random offering mechanism. Uh, but I'm gonna add some restriction on the prices you can use. Okay, here's how I'm gonna compute the restriction. Okay, so for every edge I, j in the first best matching, uh, I have a s bar, which is the minimum bit for buyer I. If buyer I lower.
00:40:01.256 - 00:40:22.276, Speaker B: If buyer I has anything higher than S bar, I will still be in the first pass even if j is not there. Okay, so that's a threshold bit for buyer I to get into the first pass if j is not there. Okay, so this is Vcg price for I if j is not there. Let's think about what this means in the double auction case.
00:40:22.440 - 00:40:22.796, Speaker A: Okay?
00:40:22.820 - 00:40:54.262, Speaker B: In a double option case, you have buyer one and seller one matching. Okay, so now I'm going to compute the s bar. Okay, so that will be the minimum value for buyer one to get into first best when s one is not there. Okay, so that's s two. Exactly. You have to be, be higher than s two to get in there. And b bar is the maximum bid for solid j, such that if j reports anything lower, then j will make it to the first best, even if I is not there.
00:40:54.262 - 00:41:33.924, Speaker B: Okay, in double auction case, this will be b two. Okay, so that's how we define the upper and lower bound on the prices you can use. And then just like take for every edge, compute these two quantities, run the random offering in this range. Unfortunately, I won't be able to say more about why these are the good things. Uh, yeah, so basically the argument in the end is, you know, uh, you, you're gonna cover. You try to use the first best matching to cover, uh, the seller offering, uh, mechanism. So the red edges are the ones in the seller offering mechanism.
00:41:33.924 - 00:42:04.094, Speaker B: The green ones are, are in first best. And you have a bunch of possible, you know, uh, alternating cycles and paths. And you can show basically a large chunk of them are impossible. These are impossible because you're looking at first best. For example, this one is impossible because if the seller offering can match these three edges, first best should take these three edges as well. So there are things you can just rule out. By definition, these are the only two cases you need to deal with.
00:42:04.094 - 00:42:10.384, Speaker B: Either have even pass when both endpoints are buyers, or you have some all paths.
00:42:10.464 - 00:42:11.204, Speaker A: Okay?
00:42:11.504 - 00:42:25.760, Speaker B: And turns out this, uh, these two you can cover, uh, using the, the random offering mechanism because, uh, the upper and lower bounds make sure that in these alternating paths, uh, every edge will trade with probably at least one half.
00:42:25.872 - 00:42:26.136, Speaker A: Okay?
00:42:26.160 - 00:42:28.004, Speaker B: So that's roughly what happens in the end.
00:42:29.184 - 00:42:45.332, Speaker A: Okay, thanks. Yes.
00:42:45.388 - 00:42:53.468, Speaker C: The equivalence class that you define, it would seem like a natural thing, would be to say that as I grow the graph, if the number of perfect.
00:42:53.516 - 00:42:58.820, Speaker B: Matchings grows larger, that should be the maximum matching.
00:42:58.852 - 00:43:01.088, Speaker C: You mean number of maximum matchings?
00:43:01.256 - 00:43:03.444, Speaker B: No, but you can isolate the edges.
00:43:04.104 - 00:43:06.088, Speaker C: But if you have an isolated edge.
00:43:06.256 - 00:43:10.364, Speaker B: I mean the matching size still grows. But those are not going to help.
00:43:12.664 - 00:43:16.684, Speaker C: So if I add a maximum degree requirement, for example, then like.
00:43:19.704 - 00:43:51.794, Speaker B: Yeah, so, okay, so I agree, there might be other reasonable large market assumptions there. I think one nice thing about this result is, I mean, we didn't prove it as a theorem, but if you have a reasonable large market assumption and the trade action there, you can just plug in our random offering mechanism in the second phase to do it. We're not using too much properties about how you do trade reduction. We're only using the fact that you're actually trading on the first best edges. And when you do trade reduction, that's basically what you do.
00:43:52.394 - 00:43:54.138, Speaker C: So you think it would be so.
00:43:54.146 - 00:44:03.934, Speaker B: You can prove some sort of more modular result? We didn't say the result in that way, but I think if you have other types of large market assumptions, you can basically take the second part and still get.
00:44:12.474 - 00:44:12.994, Speaker A: Thanks. Yeah.
