00:00:01.560 - 00:00:52.624, Speaker A: Hello and welcome to my talk about understanding the relative strength of QPF CDCL solvers and QPF resolution, which is a joint work with Olaf Biostorf. As I assume that not everyone might be fully informed about QPF solvers and QPF resolution, I will just start my talk with some basics to this topic and then I will go on with our results. Okay, so maybe we just start with a set problem. Okay, well, this is that problem. We have given a propositional formula, Phi. Let's call it Phi, and we just want to find out if Phi is satisfiable. That means if it has a satisfying assignment.
00:00:52.624 - 00:02:06.384, Speaker A: If it has a satisfying assignment, we want to return such a satisfying assignment. And if not, if it is unsatisfiable, then we want to return kind of a proof of unsatisfiability or refutation. Okay. For technical reasons, we will assume that Phi is in conjunctive, normal form or short CNF. That means CNF is just a conjunction of clauses, and the clause is just a disjunction of literals. Okay? So for example, this is CNF, which is obviously unsatisfiable, okay? And then SAT is just the set or the class of all satisfiable CNF. Okay, this class is known to be pretty hard because it is np complete, but nevertheless, practical SAT solvers are pretty efficient, at least in industrial instances.
00:02:06.384 - 00:03:22.766, Speaker A: So, for example, in examples from artificial intelligence, for example. So there is a natural question, namely, how strong are these sad solvers then? Or can we somehow measure their strength? Or can we say why some problems are hard for such solvers and why some are not? Okay, let's maybe explain some simple starts over. Most of these z solvers are based on the so called Davis Putnam logman laughlin algorithm, or short DPL. So how does it work? We have a CNF as an input, and the trivial case would be that fire just contains an empty clause. Then this whole formula is obviously false, and we can return false, so it means it is unsatisfiable. If Phi, however, is trivially true, that means we do not have any clauses. That means it's a kind of an empty conjunction.
00:03:22.766 - 00:04:22.074, Speaker A: Then it's obviously satisfiable with any assignment. So we can return true, which means satisfiable. Okay? And if this is not the case, then we can do what we call unit propagation. That means we search for unit clauses which only contains one literal. So for example, l, the clause which contains only l. And in order to satisfy this formula, we have to set l to one, okay? And we just do this, we set l to one, and then we go on until we do not have any more unit clauses. Okay, when we do not have any more unit clauses left, we can choose an unassigned literal x, and then we just return in a recursive way, the case where we set x to one and x to zero.
00:04:22.074 - 00:04:54.164, Speaker A: Now, let's say phi was unsatisfiable. Then it is also unsatisfiable under x equals one, and under x equals zero. So we will return zero or zero. So false or false. And if it is satisfiable, then at least one of these two cases where x is one or x is zero has to be satisfiable. So this really returns a correct answer. Okay.
00:04:54.164 - 00:05:57.374, Speaker A: The more interesting and commonly more used solver is, however, the conflict driven clause learning, or short CTCl, which you could say is just an extension of DPLL that additionally makes use of so called clause learning and non chronological backtracking. The clause learning just means when we somehow get a conflict, we will analyze this conflict and learn a new clause. This is explained a little bit more detailed in the paper. I won't do this here. And then non chronological backtracking just means we do not have to backtrack to the last decision. So here, for example, if x equals one doesn't didn't give it gave us a satisfying assignment. Then we backtrack back to x equals zero.
00:05:57.374 - 00:06:51.394, Speaker A: So this is chronological backtracking, and we can do it also non chronological by backtracking to some arbitrary point in the past. Okay, both algorithms rely on the theoretical proof system resolution, which I explain later, but maybe explain how we can formalize such a CDCL proof. Okay, so I haven't explained CDCL here, but it's, it's basically DPL some extras. Okay, so this is the formalization, you could say. So, we have three sequences. The first sequence is some sequence of t's, and these t's are called CtCl trails. I will explain on the next page what these trails are.
00:06:51.394 - 00:07:38.774, Speaker A: And from each trail, we can learn a clause with our clause learning procedure. These are the c's. Okay. And to each c belongs a PI, which is just a sub proof, a resolution subproof of this learned clause. Okay, so we can extract this, the sub proof, directly from the clause learning process. So what are these trails? The trail is just a sequence of literals that represents a CDCl run between two restarts or backtracking steps. Okay, we could say that it looked like the following.
00:07:38.774 - 00:08:34.094, Speaker A: I distinguished between two kinds of literals, namely the p literals and the d literals. So the p literals are just literals. Well, let's say, let's start with d literals. The d literals are just decision literals. So if we go back to the DPL, we have made some decisions, and here our decisions are these d literals in here, okay, and these p's are the literals which are propagated by unit propagation. That means we need to have unit clauses with these p's. Okay, so this basically is a trail and it contains all information we need for such a CDCl run.
00:08:34.094 - 00:09:55.634, Speaker A: So this is one way in formalizing such as CDCl or later also QCDC proof. Okay, let's explain what resolution is. Okay, so resolution is the underlying system of CDCL and it basically contains, consists of only one inference rule, namely this one, okay? Where we can derive C or D from C or x and d or x bar. Okay, so and d are here clauses and x is just a literal. And we can also formulate a resolution proof PI of some CNF phi, which is just a sequence of clauses where each c is either an axiom that means it's just a clause in the original formula or it was derived via this inference rule. Okay, and if cm is the empty clause, then PI is obviously a refutation. Also, if we go back here to this proof, the same is true for here cm is empty.
00:09:55.634 - 00:11:02.936, Speaker A: Then also this one is in the refutation. Okay, so what are the connections between these SAS solvers and these proof systems? So it is well known that we can extract resolution proofs out of the CDCL, and we can also extract tree lag resolution proofs from DPL. We can even say that tree lag resolution is equivalent to DPL, but that's not very important here. Let's concentrate on CDCL because it's a little bit more interesting. So how do we extract a resolution proof from CDCL? Well, we just, we have a proof like this, these three components, we will just stick together the sub proofs PI one to PI M. So for example, in PI M we need the clauses, let's say CM minus one. Then we use the proof PI PI M minus one and so on.
00:11:02.936 - 00:11:45.394, Speaker A: We just have to stick them together and get a big proof or a big reputation of this whole formula. Okay, so we can extract resolution proofs from CDCL. That means resolution simulates cdcl. That means we can analyze the SAT solvers, at least with the aid of proof complexity. Okay, maybe we do an example here. So there's this very popular CNF, which is called the Prismholt principle PHP, and consists of the following clauses. You can see it here.
00:11:45.394 - 00:13:14.724, Speaker A: And basically this whole formula encodes the statement that we can put m pigeons into n holes without putting two pigeons and one in the same hole. And obviously, if m is choosing to be bigger than n, then this whole formula is unsatisfiable. Okay? And it is proven that php with m equals n plus one needs exponential size resolution refutations. Okay? And then obviously also each CCl run of this formula needs exponential time. There's one possibility, and finding hard results for CTCl or QCDCl solvers. Okay, now the question is, what about the other direction? So if we concentrate to on CDCl, can we somehow extract CDCl runs out of a resolution reputation. Okay? And there was this result ten years ago from Pbzerisawat and Davis, and they found out that for each resolution refutation PI of a formula phi, there is in fact a CDCl run of some polynomial size that refutes phi.
00:13:14.724 - 00:14:00.874, Speaker A: Okay? That means these both systems are p equivalent. But there's one point you have to consider, namely this CDCl model in here contains many non deterministic elements. So for example, decision making. We just said that we have to decide some literals. If we go back to DPLL, we had this x, which was just an unassigned literal, and we did not specify how we find this x or what x do we choose. So this is pretty much non deterministic. And in here, this decision making depends on the refutation we have given.
00:14:00.874 - 00:15:20.384, Speaker A: But if we go to practice, the CDCl uses of course, deterministic procedures for things like decision making or clause learning. So we can't really say that choose any decision, we have to specify this. Okay, so here, this results only holds for this partially non deterministic proof system. And two years ago, mark vinyls had this result where he proved that this deterministic CDCl, with some deterministic decision making is in fact weaker than resolution. Okay, so we get this overview here. We can, we can define a partially non deterministic proof system, which is p equivalent to resolution, but the deterministic one is really weaker than a resolution, which is not surprising because resolution itself is more non deterministic proof system. So it's not surprising that deterministic proof systems are weaker.
00:15:20.384 - 00:16:23.224, Speaker A: Okay, so now what we want to do here is we want to lift this whole problem to the quantified level so we know what happens in the such case. And now we want to go to the quantified case. Okay? So maybe let's start to explain what is QBF solving. Okay, so what we do here is we consider quantified CN's or QCNFs, in short, which is basically just a CNF with some prefix. The prefix is just some quantifiers, which I will write as this. So we have extensional or universal literals or variables, and we will assume that also for technical reasons, that variables are fully quantified. That means we do not have any free variables in there.
00:16:23.224 - 00:17:37.414, Speaker A: And we also assume that phi contains no topological clauses, because otherwise, yeah, we will just delete them if we have some of these. Okay? And now because our formula is fully quantified, we can just rewrite our aim to we want to check if Phi is true or false. So it's not even. We do not really want to know if it is unsatisfiable or not, because it doesn't have any free variables. It is either true or false. Okay? And if it is false, we want to return a refutation. Okay? And this QPF problem is even harder than the SAT problem, because the QPF problem is proven to be a p space complete, but the same as in sad solving industrial instances can be solved efficiently nevertheless.
00:17:37.414 - 00:18:59.042, Speaker A: So here we have the same question. Why are some formulas easy, or why are some formulas hard for these QBF solvers? Okay, let's explain the underlying proof system, which is here a Q resolution. The Q resolution is just an extension of resolution, which can handle qcnfs, okay? And it consists of now two insurance rules. The first one is resolution, which is basically the rule from the Sat case. But here now the resolution, the pivot X has to be existential, and we do not have to create tautologies. If we have an l and c, then the negative of l is not allowed to be in D. And then we have a reduction rule where we can handle the universal literals, that we say that if we have a literal u in a clause, and left and right of u is non existential literal, it's not any.
00:18:59.042 - 00:20:04.144, Speaker A: So let's say wave a literal u, and each literal, we're just right of u in this clause is only universal, then we can reduce this u, okay? And we can even more extend this q resolution system to a stronger system, which is called long distance q resolution, where we are now allowed to create tautologies. I will not explain this here, but keep in mind that we can also do this, which was introduced by Schangen Malik 2002. And as resolution also CdCl can be lifted to the QBf level, which is now called QBF cdcl or QcdCl. Okay. And it was proven that we can extract long distance q resolution refutations out of negative QcdCl runs. Okay. As you see here.
00:20:04.144 - 00:21:21.922, Speaker A: Okay. Now the question, can we gain a similar equivalence as in the such case? Well, there was this result from Yanotaha from 2016, which says the deterministic or the practical version of QCTCl is really weaker than Q resolution. But we could ask the question. Okay, I mean, in that case, it's the same because the deterministic version is pretty weak. Can we at least construct partially non deterministic, stronger QCDCl proof system, which can simulate crude resolution refutations? And there we have to say that, well, the original QCDCl and Q resolution are incomparable. Even when we take the non deterministic version of QcDCl or the partially non deterministic version, there are separations in both directions. Okay? So let's make an overview of our results here.
00:21:21.922 - 00:22:04.524, Speaker A: So, in qps, we have a more complex picture. The QcDCL is really incomparable to q resolution. But what we did was we designed a new QCDTL model, which we will call QcDCl searching order, no reduction. We will explain this in the paper a little bit more in detail, which is equivalent to q resolution. Okay? And then we get this over here. So let's make an example of these separations. So I said we can separate.
00:22:04.524 - 00:23:06.690, Speaker A: We can separate q ct cell and q resolution. Okay? And the first direction can be done with the so called cuperity formulas. So the cuperity formula consists of these prefix, and of this clause is here, as you can see. And basically you could say that each of these tis encodes the partial sum of the x from xi one to xi. Okay? And the whole formula then encodes the statement that the whole sum of these x are zero and one, which is obviously not possible. So this is also false. And we can really write down the polynomial sized Qzdcl refutation of q parity, which I will not do here because it's a little bit ugly and bulky.
00:23:06.690 - 00:23:58.294, Speaker A: But you can do this. Okay. But on the other side, one can prove that q parity really needs exponential size, q resolution refutations. Okay, so this is one direction. The other direction can be done with the help of these pitch node principles from the beginning. So then we can construct these formula, which we called trapdoor, which basically consists of a propositionally hard part and an easy part. So the first clauses in here, which are the pigeonhole clauses, are pretty hard to refute, and the rest of this is just some easy stuff.
00:23:58.294 - 00:25:06.224, Speaker A: Okay? And you can prove that this treadle formula needs exponential size QCDCl refutations. But there are constant sized, could also say a polynomial size, q resolution refutations of trapdoor. Okay, and now we want to. Now we have separated these q resolution and QCl, but now we want to design a new system, new procedure of QcdCl that is equivalent to q resolution. So we have to modify this qctl a little bit in order to gain something equivalent. And this modification has to be incomparable because, well, the original systems are incomparable, so it's not enough to just strengthen the system. And what we do is we use so called policies to modify this model.
00:25:06.224 - 00:26:14.934, Speaker A: So we use decision policies, which just tell us what decision we are allowed to make. Okay, so we specify rules and decision making. It is still a little bit non deterministic, so it's not fully deterministic, but yeah, it's still enough. And then we have reduction policies, which tells us how we handle reductions in unit propagations. Okay, so we are in, in the QPF case, also, unit propagations can make use of reduction. And in our new model, we just say that we do not allow any reduction in the process of unit propagation. And we also use the new decision policy asserting order, which I will not explain here, because it's a little bit technical, but basically it's a more liberal system or more liberal policy than we had before.
00:26:14.934 - 00:26:55.874, Speaker A: Okay, and now our result here is just for each q resolution refutation PI, there exists a refutation in our new system. QCDCL is searching order, no reduction of also polynomial size. These both systems are p equivalent. And then we get this whole overview. So I said Dpll is not so important. CDCl is equivalent to resolution. Then QcDCl is incomparable to q resolution.
00:26:55.874 - 00:27:50.914, Speaker A: Then we have the connection between QcDCl and long distance q resolution, where we can at least extract long distance q resolution proofs out of the algorithm. And now we have this new model. So this new QcDCL system, which is really equivalent to q resolution. Okay, so let's summarize what we did so far. So, in the SAT case, we have seen that practical, undeterministic CDCl is in fact weaker than the underlying proof system resolution. But the partially non deterministic model is equivalent. Okay, so we get this overview, and then again, the QPF case, it's a little bit more complex.
00:27:50.914 - 00:28:18.684, Speaker A: QDcl. QCDC is incomparable to q resolution, even in the non henrietta case. And we have to modify this QcDCl model a little bit, and then this new model is really equivalent to q resolution, and we get this. Okay. With this, I will end my talk and. Yeah, thanks for listening.
