00:00:03.800 - 00:00:42.114, Speaker A: Hi everyone. I'm glad to present our work. What can crypto do for decentralized mechanism design? This is a joint work with Elin Xing Haochon from Carnegie Mellon University. So in this work, we focus on transaction fee mechanism. What is a transaction fee mechanism? As we know, real estate on the blockchain is real expensive, so users want to have their transactions confirmed. And often users would have to compete with each other to get their transactions confirmed. We can view this as an auction where the miner is selling the slots in a block to the users.
00:00:42.114 - 00:01:29.394, Speaker A: In this case, we need to run a so called transaction fee mechanism to decide which transactions to confirm how much they pay and how much the miner gets. For example, bitcoin employs a simple first price auction. Let's just assume that the block size is one. The highest bid will be confirmed and it pays its own bid. All the payment go to the miner. As we have learned from classical algorithmic game theory, a first price auction is not good because it incentivizes users to read untruthfully. For example, it may be my best strategy to be barely enough to be the top bid, so I will get confirmed and pay the least possible price.
00:01:29.394 - 00:02:40.344, Speaker A: What's interesting here is that all classical mechanisms we know fail. For example, we know that second price auctions are a golden standard in classical mechanism design because they incentivize the bidders to be truthfully. So why not just implement second price auction? What can go wrong here? For example, in second price auction, the highest bid nine will be confirmed and it pays the second highest bid six, as the price to the miner. However, on blockchain, a strategic miner can inject a fake transaction with bid, let's say eight. Now, the confirmed bid nine has to pay eight to the miner rather than six, so miner can increase its gain by deviating more generally. In classical setting, we typically assume that the miner or the auctioneer is fully trusted, and we care about designing mechanisms that incentivizes the users to be truthfully in decentralized environment. However, the miner may also have incentive to cheat and it may not implement the mechanism faithfully.
00:02:40.344 - 00:03:34.314, Speaker A: That's why the classical mechanisms are not a good fit here. So we want to ask this question, what makes a dream transaction fee mechanism? What properties, or the incentive aspects of transaction fee mechanism? We want to have to design an ideal transaction fee mechanism. Recently, a line of work has looked into this space, and most of these work agree that the following three properties are important. The first one is called user incentive compatibility, abbreviated as UIC. It guarantees that a user does not want to deviate, so a user will bid truthfully. And this is the same notion as in classical mechanism design. In addition to this, we want to make sure that the miner.
00:03:34.314 - 00:04:20.824, Speaker A: We want to make sure that we have minor incentive compatibility. Or equivalently, we want to guarantee that the miner does not have an incentive to deviate. So the miner want to implement the mechanism honestly. Last but not the least, in the blockchain environment, it is easy for players to form binding smart contracts. In particular, they can rely on smart contracts as an enforcement mechanism to split up their joint gains. Therefore, we also want a third property called side contract proofness, or SCP for short. In particular, suppose that a miner forms a coalition with c users and the coalition is aiming to maximize their joint gain.
00:04:20.824 - 00:05:18.460, Speaker A: In this case, the coalition's best response is to follow the protocol honestly. Among these three properties, the last two arises in this new decentralized environment, and these are the new challenges we are facing that makes transaction fee mechanism depart from classical mechanism design. In Tim Roth Gardens, EC 21 work, he asked the question, can we have a dream transaction fee mechanism? So the closest we have come to in terms of a dream transaction fee mechanism is actually Ethereum's EIP 1559. Let me quickly mention how it works. It gracefully switched between two modes of operation when the network is congested, namely when there are a lot of transactions waiting to be confirmed. It approximates the behavior of a first price auction, which is not good. As we mentioned, when the network is uncongested.
00:05:18.460 - 00:06:01.594, Speaker A: However, their mechanism approximates a simple post a price auction. In other words, there is a ticket or leave it offer called the posted price. If you bid higher than posted price, you get confirmed and you pay the posted price. If you bid lower than the posted price, you would not be confirmed. And here all payments are burned rather than paid to the miner. So Team Rothgarden proved that EIP 1559 satisfies all three properties we want if we are willing to assume infinite block size, or equivalently when there is no congestion. So posted price auction is good when we have infinite block size.
00:06:01.594 - 00:06:45.774, Speaker A: In reality, of course, the block size is finite and congestion will happen every now and then. In this case, we still don't know any good transaction fee mechanism. Let's consider a naive idea. Let's suppose the block size is one, so we randomly pick a bit that is at least the posted price to confirm it pays the posted price and all payments are burnt. So is this a good transaction theme mechanism? It actually satisfies UIc and mic. However, it is not one SCP. So basically a collision of a miner and a user can increase their joint gain by DbAT.
00:06:45.774 - 00:07:34.984, Speaker A: To see how they perform the attack, let's imagine the following case. The block size is one and the posted price is five. So all the bids in the mempool is ten. So now instead of randomly choosing a bid to confirm, the miner will just confirm, excluding user friend's bid. So this increased the probability of the cluding user being confirmed from two fifth, from one fifth to one, and this increases the expected joint gain of the coalition. Actually, this example captures the main idea of the impossibility result. In Chong and Qi soda 23 work, they showed that under finite block size, no non trivial transaction fee mechanism satisfies all three properties.
00:07:34.984 - 00:08:35.214, Speaker A: By trivial we mean that no transaction is ever confirmed in the block. So this is quite pessimistic. So in this work, we ask the question, can we use crypto to help circumvent this impossibility? Can we use crypto to force the miner to implement the mechanism faithfully? And we give a positive answer. In this work, we propose a new model called MPC assisted model where MPC stands for multi party computation, a powerful cryptographic primitive. In the MPC assisted model, instead of having a single miner implement the mechanism, we let a group of miners together to implement the mechanism. To do this, we let each user send their bid to all the miners. Then all the miners interact among themselves to run the primitive cod multipart computation based on all the bids they received.
00:08:35.214 - 00:09:17.154, Speaker A: The multiparty computation computes the output of the mechanism and it guarantees the correctness of the output. As long as a majority number of miners are honest. That means the transaction fee mechanism will be honestly implemented. Note that in an honest execution, the users do not need to talk to each other, they only talk to the miners. So basically we can view this whole box as an ideal functionality. It receives users bid as input and gives us the output of the transaction fee mechanism. So this model enforces the correct implementation of the transaction fee mechanism.
00:09:17.154 - 00:10:24.418, Speaker A: In this work, we basically show the following results. First, we show that cryptography in debt helps to circumvent the impossibility result in Chung and Xi's soda 23 work. However, we also show that cryptography does not trivialize transaction fee mechanism, although it guarantee, although it enforces correctly implementation of the transaction fee mechanism and thus brings the design space closer to that of classical mechanism design. But still, it differs a lot from classical mechanism design because first, here we still care about minor user coalition, and second, each users and the miner may still inject fake transactions and users can choose to drop out. These are usually not considered in classical mechanism designs. More specifically, in our paper we give the following results. We call the model without MPC as the plain model.
00:10:24.418 - 00:11:38.994, Speaker A: So previous work ruled out the possibility of a dream transaction fee mechanism in the play model, whereas we showed that in the MPC assisted model we can design a dream transaction fee mechanism. However, the mechanism is only one SCP. It is not incentive compatible against miner colluding with more users, and we actually show that this is inherent. We proved that it is impossible to have a dream transaction fee mechanism if the miner clued with two or more users, even in the MPC assistant model. Therefore, we also consider another dimension of relaxation. What if we allow the collision to gain a little bit, but no more than epsilon war utility in this case? Under this relaxation, we show that the social welfare, the sum of the utility of all users and all miners is unscalable in the plain model and by scalable, meaning that if everyone increase their double their bids, then the social welfare should double. So basically we want the social welfare to grow linearly as the bid grows.
00:11:38.994 - 00:12:40.420, Speaker A: However, in the MPC assisted model we give a mechanism that achieves optimal social welfare. So from this table we can see that indeed crypto helps a lot. It makes what was originally impossible in the play model now possible. So in the rest of the talk I will focus on the feasibility we achieved in the MPC assisted model. We will first see how to build a dream transaction fee mechanism in the MPC assistant model, and we will see why it is not two SCP. So why it is not incentive compatible when the miner include with two users, then we'll show if we relax the notion to approximate incentive compatibility, we will be able to construct a dream transaction fee mechanism satisfying all properties as well as achieving optimal social welfare. So now let's first look at our feasibility.
00:12:40.420 - 00:14:08.714, Speaker A: That is, one SCP in the MPC assisted model satisfies all properties. So a single observation is that now with the MPC assisted model, we are guaranteed that the transaction fee mechanism, as implemented correctly. So the posted price action with random selection we mentioned now becomes a good transaction fee mechanism that satisfies all properties where we randomly choose one bid from the bid that is at least the posted price to confirm it pays the posted price and all payments burned. Now, since by the MPC assistant model we are guaranteed that the MPC guarantees that it will randomly choose a bit to confirm, so the miner cannot help its cluding user friend anymore so now it is one SCP in the MPC assistant model and we have a dream transaction fee because however, this is not to SCP. That means even if the miner clued with only two users, they have a strategy to increase their joint gain. To see why this is the case, let's assume still that the block size is one and post a price is five, and these two users in the orange are the two users in the collision. The big one, the big user has been ten and the small user has been five.
00:14:08.714 - 00:14:59.114, Speaker A: So note that here no matter. So for the small user, since its true value is five, its utility is always zero. So for the collision to increase their join utility, they basically want to increase the utility of the big user. To do this, the small user will choose to drop out to increase the probability of the big user being confirmed. So for example, before a dropout, the probability of the big user being confirmed is one fifth and now it's one quarter. So this captures the idea of our impossibility. Proof we can actually show that even in the MPC assistant model, it is impossible to achieve two SCP, UIC and mic simultaneously.
00:14:59.114 - 00:16:11.864, Speaker A: So to circumvent this impossible result, we consider another dimension of relaxation. What if we allow the miner user coalition to gain a little bit more? Does that gives us any feasibility? And the answer is positive. So if we consider approximate incentive compatibility, we can construct this MPC assisted diluted posted price option. It is UIC mic and approximately to sCP. As a heads up here, I'm only given the example for two cluting users, but this can generalize this to arbitrary c, and the intuition behind is basically that. Sure, a small user can choose to drop out to help its friend, but when the population is large, the increment is very small, so the help so you cannot help too much. Specifically, in MPC assisted diluted posted price, what we do is as follows.
00:16:11.864 - 00:17:30.132, Speaker A: So first we choose all bids, at least the posted price, as candidates. If the number of candidates is too small, say less than a predetermined threshold t, then we pad with enough dummy bids, or say we diluted the candidates pool. Then we randomly choose k bits from the padded pool where this k is the block size. And finally, each confirmed bid pays r. Of course those padded dummy bids will be ignored and all payments are burned before we see why this is to SCP, I want to mention that when there are a lot of large bids, let's say when there are a lot of bids larger than m, and we select the posted price as half of m in this case we achieve optimal social welfare. So now let's see why this is approximate to SAP. Note that if the number of candidates is small, say for example, in this case the posted price is and we only have these three candidates, then we will patch dummy bits to make it tbId.
00:17:30.132 - 00:18:07.204, Speaker A: So ten bits and we randomly choose one bit to confirm out of ten bits. So for the big user, the probability that it is confirmed is just one 10th. Even if the small user dropped out, the probability of it being confirmed is still one 10th. So in this case dropping out does not help. However, if the number of candidates is very large, say in this case all the bids are candidates. So we have far more than ten bids as candidates. In this case for the small user.
00:18:07.204 - 00:19:10.404, Speaker A: If the small user drops out, then it indeed helps. But it cannot help too much because the probability of the big user being confirmed can be at most one 10th, since the number of candidates is definitely larger than the predetermined threshold. So in this case, even if it drops out, it cannot help too much. So this is the core idea of this diluted posted price option. So in our paper we also give the following more results. In our paper we also give a characterization of infinite block size in the MPC assistant model, and also we showed how we can achieve positive minor revenue, although in the talk we only focus on the case where all payments are burnt. And furthermore we also give other ideas of overcoming the impossibility results, which is approximate incentive compatibility.
00:19:10.404 - 00:20:11.814, Speaker A: There are a lot of interesting open questions left by this work. So first, in this work we only consider one shot auction. But we know in reality the auction is running repeatedly, so it is interesting to consider the repeated nature and long scale strategies. Second, in this work we are focusing on the theoretical feasibility of transaction fee mechanism, so we did not try to improve the efficiency or practicality, and it would be nice to figure out a way to make the MPC assist model practical. And finally, there are other interesting problems related to transaction female canceling, for example, in reality the ordering of the transactions in your block actually matters. And of course, let's say in ethereum, each transaction may have different size. We did not address these problems in this work, but it will be interesting to address these in the future.
00:20:11.814 - 00:20:13.234, Speaker A: Thank you so much.
