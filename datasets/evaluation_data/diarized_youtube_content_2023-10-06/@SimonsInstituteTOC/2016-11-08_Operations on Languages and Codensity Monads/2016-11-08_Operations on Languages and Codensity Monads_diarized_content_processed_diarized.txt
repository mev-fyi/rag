00:00:00.520 - 00:00:02.514, Speaker A: Revert to 20th century technology.
00:00:02.934 - 00:00:03.994, Speaker B: I'm sorry.
00:00:05.094 - 00:00:06.874, Speaker A: We're delighted to know.
00:00:07.974 - 00:00:57.374, Speaker B: I prefer that kind of technology. So. Okay. So I speak about operations and languages and codensity monads, and I really hope I will get to the second part of my talk. So, this is joint work with May Guerke and Luca Reggio. And the starting point of this work is the quest to understand what should be identities and how one could obtain identities for varieties of possibly non regular languages. And this is really a little bit of a baby step in that direction.
00:00:57.374 - 00:02:38.908, Speaker B: So we tried to understand this inductively, and the first step was to understand what corresponds to a certain operational language at the level of the recognizer for that language. So the first thing in my talk will be to recall a duality approach for language recognition. So there was a lot of work in this direction, starting with an icult paper from 2008 of May Jean Eric Pon and Sergey Grigoriev. But I'm going to explain to you in slowly and in a way that we have described it in a rather equivalent way in an ical paper for this year in 2016. And then, as an example, I will show you a construction that one has on monoids and also on the notion of recognizer that we have, namely syntactic spaces that corresponds to existentially quantified language. And we call this the unary Schutzenberger production, because it, it really looks like the Schultz and Berger product done for concatenation of languages. And the third bit in my talk will be about trying to understand why this actually works.
00:02:38.908 - 00:03:55.930, Speaker B: And because I like category theory quite a lot, it turned out that I've seen some codensity Monads going on and popping into this, into the picture. And I think that this thing that we did in this ical paper with Meluka can be generalized to understand a wider family of operations on languages in terms of this liftings of monads to some stone spaces with some monoids, that I will. That this will come up in a bit. So, in order to explain .1 I need a short, a very brief preliminary on finite duality. So, this is a very simple theorem that I think, I expect everyone knows, especially those that have attended Mace Lockheed Friday, namely, that the categories of finite Boolean algebras and the category of finite sets are dually equivalent. And if I start with a finite Boolean algebra, I obtain a finite set by taking its atoms, and in the converse direction, I take the power set of a set.
00:03:55.930 - 00:05:08.374, Speaker B: So this gives me an ideality between these two categories. If I start I mean, there is another very simple duality theorem stating that the category of sets is dually equivalent to the category of complete atomic Boolean algebras. So just as before, those Boolean algebras that can be obtained as the power set of a set are precisely those that are complete and atomic, and the functors are described in the same way. So once we know these two results, I can explain very quickly, what is the syntactic monoid of a space in the light of this duality. So if I start with a language in some Alphabet a, I can consider a Boolean algebra which is spanned by the quotients of this language. So I take two words, I mean, I take all of these quotients and I spend a Boolean algebra. If the language happens to be regular, then I know that this Boolean algebra is finite.
00:05:08.374 - 00:06:07.904, Speaker B: So I have a morphism of, well, actually it's a morphism of complete atomic Boolean algebras. So because, and now because we know duality theory, we know that whenever we have such an embedding of complete atomic Boolean algebras, if we flip, if we go to the dual category, namely to the category of sets, we have that the atoms of the power set of a star. From this set of atoms, we have a subjective map to the atoms of this Boolean algebra blend. Hang on, what are the atoms of this power set? They are just the words a star. So this is a morphism in Kaba. Hence I have, and this is an injection. So here I have a subjection in Z.
00:06:07.904 - 00:07:26.280, Speaker B: But moreover, observe that on this Boolean algebra of languages I have an action of the monoid of words, because they are quotients. So I can quotient to the left and to the right. And this morphism here is not just a morphism in complete atomic boolean algebras, but furthermore, it is a morphism that preserves this action of a star on the boolean algebras. And moreover, for each word, if I look at the left action of this word on the Boolean algebra, this is in fact a Boolean algebra morphism. So by dialogy, it turns out that this map, that this projection that I obtained in set is also a morphism of actions of a star, of two sided compatible actions of a star. So this also preserves the actions of a star, respectively, on a star which is monoid, and on the set of atoms. So what we obtain is that this set of atoms.
00:07:26.280 - 00:08:02.140, Speaker B: So it's a very simple lemma that if I have such a subjective map from a monoid. And here I have actions of the monoid on this set that this thing becomes a monoid. And in fact it is the syntactic monoid of the language l. So one can obtain the syntactic syntactic morphism of a language just by duality. So now what happens if I, sorry.
00:08:02.172 - 00:08:05.624, Speaker A: Did atoms of the Boolean algebra become the syntactic monoid?
00:08:06.524 - 00:08:52.030, Speaker B: Well, they have a monoid structure which they get from that action, which they get right from this from a star. And it turns out, I mean, it's a simple computation. It's not like it becomes, it is a simple computation to show that this is indeed the syntactic monoid that one obtains with the usual definition. So if one drops the regularity condition on the language, what happens is that the Boolean algebra here is no longer finite. So the morphism is no longer in complete atomic boolean algebras. So this business with atoms is no longer really useful. So we have to use a fancier duality theorem, which I will write on this side.
00:08:52.030 - 00:09:48.984, Speaker B: So this is the preliminary, maybe, I'm not sure if it's visible if I, it's visible if I write it like down here. So I have the category of. Anyway, it's just the standard stone duality theorem. If you don't know it, I don't have the time to actually explain the factors. But the point is that if you start with a Boolean algebra instead of the atoms, one would have to consider the set of ultrafilters, and then to come up with a topology on this set of ultrafilters, which is compact, Hausdorff, and moreover zero dimensional, so it has a basis of clopins. And conversely, if one has such a topological space and considers the set of its clopins, then this one has a structure of boolean algebras. So roughly, this is the stone duality.
00:09:48.984 - 00:10:48.860, Speaker B: So instead of looking at the atoms, so this is embedding steel holes, here I have a boolean algebra which is not going to be finite. And here what I will do, I will have to look at the dual of the power set of a star, which are the ultra filters here. So it's the stone check on a star. And I will have a quotient to the ultra filters of the boolean algebra generated by l. Let's call this xl. So, and again here, the actions of a star on the boolean algebra blue can be dualized. So I will get left and right compatible actions of a star on the space xl and this map.
00:10:48.860 - 00:12:08.988, Speaker B: So this is a continuous function. This is in stone, but this one also preserves the two sided actions of a star. And one can ask, where is the syntactic monoid in all this business? Well, recall that I have an embedding of a star, the principal ultra filters. So each word here will be mapped to the principal ultrafilter it generates. And if I factor this embedding, I get one set here that also has inherits the two sided actions of the monoid, a star, and therefore it is a monoid, a quotient of a star. And after a few computations, one can verify that m is indeed the syntactic monoid of the language. But using it alone for recognition is not sufficient, because here you need.
00:12:08.988 - 00:13:13.984, Speaker B: So in order to retrieve, of course, this monoamorphism will recognize l. But if you allow to use as a recognizer set any subset of m, you'll get much, much more languages. So, to be able to recognize exactly the Boolean algebra of quotients, one would have to use the clopons, the traces of the clopons in your topology. So this is where the topology on the dual is actually used. So we can, oops, we can define, I mean, from this picture one can distill what would be a right notion of recognizer in the case of a language which is not necessarily regular. And we come up with the following definition. So, Stone space, I mean, I use this with an internal monoid.
00:13:13.984 - 00:14:32.744, Speaker B: It's such a pair where x is a boolean space or a stone space. M included in x is a dense monoid x hash two sided compatible m actions, and such that each component of these actions is continuous. So, I'm sorry, a stone space. So I have read, unfortunately, I have read John Stone's book before meeting May, who insists on calling them Boolean spaces. So, good name. So if I say boolean space is the same as Stone space, I'm sorry for confusing this, but historically speaking, they should be called boolean spaces.
00:14:34.364 - 00:14:36.544, Speaker A: Is it Stone called the Boolean spaces?
00:14:37.864 - 00:15:27.384, Speaker B: No. Well, yes. May is the expert, I think. Yes. So the answer, yeah. So, and then we can say when a language, so a language l in a star is recognized by such a space with an internal monoid, provided that one has a commutative diagram of this shape, where here I have a monoid. So this phi is really the same, and there exists a clopen in x such that the language l is phi minus one of m intersected with that clop.
00:15:27.384 - 00:17:20.254, Speaker B: So this is really the notion of recognition, which appears in a slightly different form in the work of Mei Jeanric and Sergei Grigoriev. And this is a reformulation of it in this is something we came up with in this ical paper. So now it's time to go, maybe very quickly, to the second point, namely, how do we deal with existential quantifiers, and how do we see an action of. So how do we translate the existential quantifier into an operation on this category of stone or boolean spaces with internal models? So the question is the following. Maybe I have some logical formula with one free first order variable, and I have a language in an extended Alphabet that corresponds to this formula phi. And now if I have the language l exists, let's write this as a shortcut for the language that corresponds to the existentially quantified form formula. The question that we try to ask to answer is, if we have a monoid that recognizes l phi, then how can we recognize this l exists? And the answer that we came up with is not the block product, as people usually do in this area, but we say, okay, so let's say that l phi is recognized by this morphism.
00:17:20.254 - 00:18:11.472, Speaker B: Let's take first the regular case to keep it at the monoid, to explain it at the monoid first, and then we lift the argument to spaces. Well, then one can consider, I mean, the way we do it, one can consider really a transformation. It's a transduction, in fact. So, to each word, we associate the set of words which have one marked position. So this notation stands for the same letters in a. But here I can have either a zero and a one. This means that I have exactly one one in my word.
00:18:11.472 - 00:19:35.594, Speaker B: So, for example, just a b will be sent to the set a one, b zero, sorry, a zero, b one. So I mark exactly one letter. So once I have access to the words that have exactly one marking, I can I obtain here a morphism from a star to the power set of m, which recognizes my language. L exists, but it's not a monoid morphism, because this is not a relational morphism. So I have to do something, something tricky here. One option would be to represent this between the words in a star and the words in a times two star in terms of a monoid morphism. Using a representation of this transduction, as, I mean, a realization of this relation using a transducer, which is this thing, this transducer realizes this relation, and from here one obtains that the relation r factors through a monoid morphism.
00:19:35.594 - 00:21:41.494, Speaker B: So I have a monoid morphism, where I'm using matrix, it's a matrix representation of this relation. The two here stands for the fact that I have a two state transducer. This will be generated by a being mapped to this matrix. And if we apply here, the morphism phi, one gets a monoid morphism which exactly recognizes l exists. And what is nice about this story, which becomes a bit technical, is that it lifts very easily to the case of these recognizers involving stone spaces with internal monoids. So one recognizer that one obtains, I mean, we can see here that in fact is these factors through a semi direct product of M and the finite power set of M. So the fact is that L exists, is recognized by a monoidomorphism from a star to a product of M and the finite power set of M.
00:21:41.494 - 00:23:11.820, Speaker B: But now this is, so if L is would be regular, if I'd be in the regular case, that would be fine, but I am not in the regular case necessarily. So what would be a stone space with an internal monoid that recognizes L exists. So if L, if my original language L is recognized by a pair xm, then L exists, will be recognized by a space with an internal monoid that is carried by the following topological space. So, on the topological site, I have a product of x and via toris of x, which is in some sense a generalization of the power set to the category of stone spaces. And this monoid that I have described before briefly, which sits inside the space. So one can expect explain this directly in terms of the relative theory. So one can take the Boolean algebra generated by l exists, compute the left right quotients, and get at some point the dual of this via toris on some Boolean algebras.
00:23:11.820 - 00:24:40.558, Speaker B: So the action of the monoid power set of m times m on this space comes up extremely natural from ideality theoretic computation. But it also seems that we can try to understand this at a more conceptual level. Like where, I mean, okay, this setting works fine for the existential quantifier, but what if I want to understand some other operations? For example, a modular counting quantifier? So I want to define a language. So this is such that the number of positions, if I mark those positions in my word, I get the word in l. So, and this, the number of positions such that the markings is in l should be congruent with two modulo three. So if I have such a definition of an existential quantifier, can I do a similar job? Can I? And of course one can try to redo all the computations from the beginning. But it's also interesting to observe that instead of using the power set here, one can try to replace it with another.
00:24:40.558 - 00:25:28.624, Speaker B: So, instead of using the power set, which I see as a monon, I use another monad corresponding to z three semi modules. So, instead of having this relation from a star to power set of a times two star, I want a relation from a star to all the finitely supported functions from a times two star to z three. And now if I go to, to z three to m, I obtain again amorphism, which recognizes the language l exists. So the picture seems to work fine for monoids. I mean, again, this transduction can be represented as a matrix. I get a monoid Morpheus. This part generalizes nicely.
00:25:28.624 - 00:26:48.676, Speaker B: But what do I do if I want to go beyond the regular case, if I want to lift these operations to stone spaces with internal monoids? And the answer is, what is, for me was on the second board is this codensity monad story, because it turns out that the operation that we had here, this viatoris, is essentially obtained from the power set in the following way. I mean, one way of looking at it is as follows. So, I look at the Eilenberg Moore algebras for the power set, which are finitely carried. So this would be finite joint semi lattices. I forget about the algebra structure, and I see these finite sets as equipped with a discrete topology. So, and this works more generally for any set mod. So this one.
00:26:48.676 - 00:27:10.694, Speaker B: So a finite set is a stone space. Okay, that's correct. That's the embedding and this is the forgetful factor. So these are Eilemberg Moore algebras for t, which are finitely carried. Forgetful functor. So let's call this one, I don't know, j. So if I look.
00:27:14.794 - 00:27:16.546, Speaker C: Are you assuming that t is closed?
00:27:16.570 - 00:27:17.050, Speaker D: I'm fine.
00:27:17.082 - 00:28:13.312, Speaker B: It says no, I mean, it works in general. But there are some aspects of this theory which would work much better if t is closed, if t preserves finite sets. But of course, I mean, the construction that I will use here, this co density monad for this function. So this is obtained as, as a right kind extension of j along j. Of course, this will yield the same thing if I start with the finite power set or with the whole power set. So in a sense, this is the part of the monad, which is interesting. So the point is that every for every, but for this construction works in general, because the right kind of extension is computed point wise, because stone is a very nice category.
00:28:13.408 - 00:28:14.284, Speaker A: Two minutes.
00:28:15.144 - 00:28:50.854, Speaker B: Oh, I'm sorry. Yes, two minutes. I'm done. So we have this extension of the monad t to stone spaces for every monad. And we have also that whenever t is commutative, said Monad. I won't have time to explain what that commutative means, but I can tell you later. Then t has a canonical lifting to the category of monoids.
00:28:50.854 - 00:30:12.164, Speaker B: So let's call this t bar for the power set. It's just saying that the power set of m has the canonical monoid structure given by complex multiplication. So I mean, probably it's best to end with a theorem, which I think is fun. So if t is a commutative set monad, and xm is a stone space with an internal monoid, then t hat of x, where t hat is this extension of t two to stone spaces, and tm is again a stone space with internal monoliths. Well, I'm cheating a bit, because actually one has a map of tm into tx. So you should probably look at the image of that map, but modulo a little bit of sloppiness. This theorem is fine.
00:30:12.164 - 00:31:15.484, Speaker B: If t is the power set or the finite power set, then. So I want to apply this. In this case, I get exactly what I have told you about for the existential quantifier, when one can do this for any commutative semi ring, and for the corresponding free semi module monad. And this gives a kind of a general recipe for obtaining recognizers. For example, for all the languages of this shape given by modulo counting quantifiers. And more generally, one can think of other examples like turning for an arbitrary monad t. I mean, any closely map from a star to b star, for that monad should actually allow one to transform languages on b stars to languages on a star.
00:31:15.484 - 00:31:46.684, Speaker B: But of course there are many more things to be understood in, in this setting, like how one can obtain this computation from a duality theoretic point of view, and finding lots of interesting examples where this is actually useful. And then of course the difficult step, understanding how to obtain ultra filter equations and how to actually put this machinery to use for some more practical purposes. So I should stop on this note. So thanks for the time expression.
00:31:51.944 - 00:31:56.480, Speaker A: We're a bit late, so we'll take a very few questions. Val's obligatory questions.
00:31:56.552 - 00:32:08.124, Speaker D: What happens when m in the PXM is computer? In other words, are there theorems about recognition not of languages of words, but of languages of bags?
00:32:11.584 - 00:32:15.632, Speaker B: Yeah, I think yes, but something interesting happened.
00:32:15.648 - 00:32:18.704, Speaker D: Like for example, is there a Parik.
00:32:18.744 - 00:32:33.288, Speaker B: Style, I'm not familiar with it, but I can imagine. What I can tell you is that the Monad also lifts to commutative monoids. This framework should also work in that setting.
00:32:33.416 - 00:32:35.176, Speaker D: So I cannot ask another question.
00:32:35.280 - 00:32:42.324, Speaker A: You can just give you an example of how powerful this is. Even though she doesn't know Parik's theorem, she can assure you that it works.
00:32:44.174 - 00:32:44.510, Speaker B: Yes.
00:32:44.542 - 00:32:45.554, Speaker A: Ask another question.
00:32:47.054 - 00:32:47.834, Speaker B: Oh.
00:32:51.134 - 00:33:02.114, Speaker D: Some of these classes of languages are closed under complementation. And what does it come to? I mean, can you characterize properties of the stone space in which this works?
00:33:02.974 - 00:33:13.714, Speaker B: For that, I'd have to think. But, yeah, I think that's there's something that can be done, and I'll ask this more. Yeah, yeah, I think it's better to take this offline, because.
00:33:18.774 - 00:33:41.034, Speaker C: I guess my question is really asking for some intuition. In the definition of stone space with internal monoid, the last clause was continuity on each component. So it seems to me that that means you define the monoid action sort of completely independently on all the components. Use the axiom of choice to pick completely random things, and it would still be okay. Is that. How should I understand that?
00:33:41.574 - 00:33:50.470, Speaker B: Well, I mean, first of all, they are not completely independent the way the ones that actually come from the examples are fine.
00:33:50.502 - 00:33:57.114, Speaker C: It's the definition of them. The definition seems to not put as much constraint on it as I would have expected.
00:33:58.834 - 00:34:08.774, Speaker E: Forget one. I mean, you didn't mention one property in the definition, namely that on the internal monoid, it has to actually be monoid multiplication.
00:34:09.914 - 00:34:12.194, Speaker B: Yes. I mean, there's a whole dense monoid.
00:34:12.234 - 00:34:15.034, Speaker E: Inside where it's, where it has to be the multiplication.
00:34:15.154 - 00:34:18.250, Speaker C: The density doesn't seem to help if you're not requiring conservation.
00:34:18.282 - 00:34:20.186, Speaker B: No, but the mono insert beyond the.
00:34:20.210 - 00:34:26.104, Speaker C: One component, beyond the individual components. That's where my intuition is falling apart.
00:34:26.144 - 00:34:38.044, Speaker B: No, no. So I think, yeah, but the monoid is dense inside and inside the space x. So this already gives a little bit of.
00:34:38.944 - 00:34:47.704, Speaker C: Yeah, that's what I don't. It gives a little bit, but it gives only that one. No, I don't see how the density helps if you don't have continuity extending.
00:34:47.784 - 00:34:56.012, Speaker E: I mean, for an element, if you multiply on the part that's inside m itself, you know what it has to be.
00:34:56.108 - 00:34:57.732, Speaker B: Yeah, it's unique.
00:34:57.868 - 00:35:03.384, Speaker E: Then there's only at most one continuation to the whole space.
00:35:05.244 - 00:35:05.604, Speaker B: Right.
00:35:05.644 - 00:35:06.716, Speaker E: Because it sits in there.
00:35:06.780 - 00:35:16.640, Speaker C: I'm saying it's semi topological. On that it's semi topological. The monoid sits in the space and it acts in a semi topological fashion. So each element actually.
00:35:16.732 - 00:35:16.984, Speaker B: Yet.
00:35:17.024 - 00:35:18.224, Speaker C: So maybe we should discuss it.
00:35:18.264 - 00:35:21.904, Speaker A: Okay, so I think we should stop this discussion here. Thanks very much.
