00:00:00.200 - 00:00:34.794, Speaker A: Of slides. But I'm really happy with this discussion. So, in the previous part we talked only about join queries. Now we're going to increase the expressivity a little bit, and the first thing we're going to do is add existential variables, add projections. So let's talk about conjunctive queries and see what happens. Now, what's a conjunctive query? This is a joint query that we saw before. In a conjunctive query, we also allowed to make some of the variables existential.
00:00:34.794 - 00:01:24.368, Speaker A: So here we will just not, when we write the query, we would just not put some of the variables in the head of the query. And this would mean that this variable is supposed to be existential. Now, if you look at the list of answers, the set of answers, it just means that you basically remove this column and then you remove duplicates. Once you remove the column, you might have duplicates. Okay, these are the type of queries we want to answer. Now how can we do that? Of course, we don't want to just produce this big list of answers and remove the duplicates because we'll spend a lot of time on producing all of the answers, time that might not be proportional to the actual output we have. So let's look at this query.
00:01:24.368 - 00:02:14.744, Speaker A: For example, we want to join these relations over here, and then we want to project to only make X existential, right? So this was the list of answers before. Now we make X existential and we have less answers. The algorithm, or a suggestion for an algorithm here, would be to do the same things we did before. Find a joint tree, remove the dangling tuples, and then let's see what happens if we just ignore the parts with the existential variables. So we have this part of the tree that's everything that doesn't contain x. Let's try to join those and simply ignore the relation that has x. On this specific example, you can say that it works, right? If we join the two things we have there, we get exactly the right output.
00:02:14.744 - 00:02:45.792, Speaker A: Now let's look at a different example and you can guess what will happen there. So we have the same query but a different projection. Now, Y is existential instead of X. If we look at the parts, now Z is existential instead of X. We look at the parts that don't contain Z and we just ignore everything else and try to join those. We'll get that. The number of answers like there are six answers.
00:02:45.792 - 00:03:27.140, Speaker A: It's like a cartesian product of the two things we have left, and that's more than what we have here. So what happened is we basically lost some information about what is allowed to go with what. Because before we knew that w one is also allowed to go, only allowed to go with z one and z one is only allowed to go with y one. So we won't get answers where w one goes with these. But now we don't have this information anymore, so we can't do the this algorithm, this trick on this query. Is this query harder than the previous one? Yes. And the way we define it, so we have this sort of extension.
00:03:27.140 - 00:03:42.044, Speaker A: So before we said that extension to definition from, from before, this is an acyclic query, and an acyclic query is also freeconex if we have a connected part of the joint tree that contains exactly the free variables, and then we can do what we did before.
00:03:44.824 - 00:03:47.672, Speaker B: Sorry, when you said do what is before was ignore it.
00:03:47.808 - 00:04:20.670, Speaker A: Ignore everything that's outside of this connected part. And then because it's connected, we don't lose the information on what could go with what. So this is almost the correct definition. If I don't want to lie to you, I need to also tell you that this query is also called free connexion because we are allowed to add nodes that are subsets of other nodes to make the query connected. But we won't go into these details in the few time we have left. The important thing is that you have the intuition we had with. Okay, let's keep this slide.
00:04:20.670 - 00:04:58.950, Speaker A: So, dichotomy if the query is a cyclic free connex, we have an algorithm. If the query is cyclic, the same proof we mentioned before still, still works to prove that it's hard. What happens if the query is a cyclic but not reconnaix? Then it is hard, but for another reason, we can show that it's hard if we assume the hardness of Boolean matrix multiplication. This is an example for like the most basic query. That's a cyclic but not reconnaissance. And let's assume we want to multiply these two Boolean matrices. We encode the two matrices in our two relations.
00:04:58.950 - 00:06:12.830, Speaker A: So we look at the places where we have ones. We look at the row and column indices and put them for the first matrix in the first relation, for the second matrix in the second relation, and then the square by definition computes the positions of the ones in the output. You can see this, for example, because the one in index one two can be explained by the ones and indices one two and two three. So if you can answer this query with linear preprocessing, where the size of your input is at most n squared and constant delay, where the size of the output is at most n squared. Then you solve boolean matrix multiplication in quadratic time. You can see that this captures the idea that the hardness comes from having to remove duplicates, because the ones in the output can be explained sometimes in different ways, but we're not allowed to go over all of the explanations for them, just over the actual output. So whenever we can always do this reduction for any query that's a cyclic but not reconnaissance, because for every query that's a cyclic but not reconnaix, we have something similar to what we have here, where we have this sort of path.
00:06:12.830 - 00:06:36.354, Speaker A: So x, y, z. So x y appear in an atom, yz appear in an atom, but x and z don't appear in an atom. And the endpoints are free, but the middle is not free. And whenever this happens, we can do this reaction. Okay, let's keep this self joint free in this case. Oh, I didn't say that. Yes, self join, free for self joins.
00:06:36.354 - 00:06:41.514, Speaker A: We don't know. We're confused even for joins. We put them aside, and now I assume everything is self joined.
00:06:41.554 - 00:06:43.122, Speaker C: So did I call them used for self?
00:06:43.218 - 00:07:11.754, Speaker A: Yes. Okay, now let's continue to unions of conjunctive queries. What's a union of conjunctive queries? Well, it's a union of conjunctive queries. So we have, let's say two conjunctive queries. It can be more in general, we want the unions of the answers to the individual queries. So some of the answers can be answers to both, some of them can be answers to one, whatever. We want the union of all of those.
00:07:11.754 - 00:07:55.104, Speaker A: What can happen in terms of the complexity? So the first case is that all queries in the union are easy. In this case, it's not very complicated. To show that the union itself will always also be easy, let's keep the details and talk about the more interesting parts. The second part is that some queries in the union are easy, and some queries in the union are hard. And it was actually thought before that if this union is non redundant, then a union that contains a hard query is always hard. But this turned out to be wrong. And this union can sometimes be hard, but sometimes be easy.
00:07:55.104 - 00:08:33.795, Speaker A: This is quite surprising. When we found this out, and at this point, because we like dichotomy, we wanted to prove that everything for which we don't have an algorithm is always hard. And in particular, we wanted to prove that the third case is always, oh, I'm jumping ahead. Okay, so I'll give you the overview and then go back. So we wanted to prove that the third case is always hard. We try to prove it, and our proof only works for most cases, but not for all of them. And then at some point we realized the reason we weren't able to prove it is because what we were trying to prove is wrong.
00:08:33.795 - 00:09:07.314, Speaker A: So even a union that only contains hard queries can sometimes be easy. And this is really nice, because what we did is we're trying to prove conditional lower bounds. And we found algorithms because we failed. Like we found that there were some cases where we can do things more efficiently. So that was awesome. Okay, let's talk about the second case now in a bit more detail. So remember, this was the way we proved hardness for a query that's a cyclic but not frequent using boolean matrix multiplication.
00:09:07.314 - 00:09:53.024, Speaker A: Now, what happens if such a query is part of a union? This is a query that's just a bit more complicated than what we saw before. We can do the same type of reduction work, the same construction here, and in three reals in w, we just put constants. So this still finds us the answers to matrix multiplication. But if this query is part of a union, then if we assume that the query is easy, we don't just get the answers to the first query efficiently, we get the answers to the entire union. Over this construction, q two has a lot of answers, a cubic number of answers. So solving the query efficiently doesn't compute matrix multiplication efficiently. So it doesn't contradict the assumption.
00:09:53.024 - 00:10:49.174, Speaker A: So the hardest results don't hold when the conductive queries are within a union. And the query we saw right now is actually easy. The way we show it's easy is because you can notice that the hard part of q one is exactly what q two computes. Q two computes the join of r1 and two reals. And since we have this body homomorphism, so q two doesn't have extra atoms that don't appear in q one, what q two computes here, this join is not filtered on top of what we want so we don't lose information. And q two is really just exactly the join of r1. So what we can do is after we compute q two, we can look at the list of answers, treat it as another relation, and then extend q one with an extra atom that uses this.
00:10:49.174 - 00:11:27.744, Speaker A: And now this extended query is free connexion. This almost shows us what we want, because what it gives us is, well, first of all, we can have duplicates we can have the same answer twice, and we have this sort of linear preprocessing for answering q one after we already started producing answers. So it's not something you want, but we can very easily go work with that, make it work using something we like to call the cheater's lemma, because it tells us how much we're allowed to cheat without really cheating. Yes.
00:11:28.164 - 00:11:31.744, Speaker C: Is it the case that q one is compelling?
00:11:33.964 - 00:12:01.216, Speaker A: No, because of the free variables. Because y you can see that the free variables are in different positions. Yes, that's a good point. So it's only a body homomorphism. It's not a complete homomorphism, which is exactly the confusion that made people think that the union that contains a hard query is necessarily always hard. Okay, so this was the proof that turned out to be.
00:12:01.280 - 00:12:02.084, Speaker C: Thank you.
00:12:05.664 - 00:12:52.134, Speaker A: Okay, so the cheater dilemma tells how much we're allowed to cheat. We're allowed to have a usually constant delay, but a constant number of linear delay steps and almost no duplicates. But every value will return a constant number of times, and we can sort of save the answers we've seen and not print the same answer twice, and then withhold the answers a bit to regularize the delay. And we get linear reprocessing, constant delay, skipping a slide. And now when we get to the third case, a union of hard queries that can become easy. This can only happen in very limited cases. And the cases are that the queries are basically body isomorphic.
00:12:52.134 - 00:13:36.964, Speaker A: It's basically the same query, but with different projections. So this way both queries can help each other, but the hard parts of the queries are different because of different projections. So only the high level idea. We cannot find all answers to q one efficiently, but we can find some answers to q one efficiently, and we can show that we can find exactly the right answers to compute the hard part of q two. So the join of three reals and four reals bowtie is something that symbolizes joints. So after we find some answers of the q of q one, we have enough information to help q two. And then after we computed q two, we can use that to help q one again.
00:13:37.904 - 00:14:10.020, Speaker D: Yeah, I want to ask you by analogy, suppose I didn't want to enumerate, I just wanted to detect. Then, for example, we know that a graph either has a large enough independence or a large enough clique, any graphic, right. So the order of the two is there, an independent set of size ten or a click of size ten is actually very easy to do in basically linear time. So is this analogous to why this.
00:14:10.052 - 00:14:10.944, Speaker A: Is easy.
00:14:14.804 - 00:14:16.828, Speaker D: Like a Ramsey theoretic sort of.
00:14:16.956 - 00:14:48.264, Speaker A: I think so, because I think that's interesting to think about. But I think the case you described now would be, would hold within the algorithm, we have basically of union extension. So if we have a union, we describe this as a union of two queries. We will have that, the independent set query that's cyclic, but that would have negations right here. Right.
00:14:52.364 - 00:15:02.444, Speaker C: You have to say no, n. But you can create a negated relation, right? Yeah, but then you say something about how they relate to each other.
00:15:02.484 - 00:15:03.064, Speaker A: Right.
00:15:04.484 - 00:15:13.364, Speaker C: I think the union, example, the union, there is a path of length two or there is a path of length three. So you have to enumerate the path of length when you enumerate the password.
00:15:13.404 - 00:15:16.884, Speaker D: So that's for enumeration. I was just wondering about the detection.
00:15:16.964 - 00:15:17.984, Speaker C: Okay, detection.
00:15:18.804 - 00:16:07.414, Speaker A: So for detection, I mean, if you just want. Oh, but if it's a union of two hard things. Okay, we're short of time, so think about it. But I really do want to think about it. So for unions, also open problem, what we do now is for unions of two conjunctive queries and for union of two conjunctive queries, if we have what we call union extensions or algorithms work, it works. If it doesn't work, we managed to show that there's always a reduction, but for this we had to use vertex unbalanced triangle detection. And I say had to use is because we sort of show that it's unavoidable if we want to classify all your cues.
00:16:07.414 - 00:16:59.084, Speaker A: Because what we show is, well, if vertex and balance triangle detection holds, we have a dichotomy. But if it doesn't hold, then we get an algorithm for some UCQ unions of conjunctive query that we don't currently know of an algorithm for. So have an example for why we have to use, or like why we had to use this and couldn't use the previous assumptions. But maybe we'll skip that. Yeah, I think we have to finish. And then for going beyond two conjunctive queries in the union, we don't know and we have a specific open problem. So this query, if you want to try to classify if it's easy or hard later, I can show it to you again and explain to this and see what happens.
00:16:59.084 - 00:17:01.164, Speaker A: And we'll finish here.
00:17:08.883 - 00:17:11.983, Speaker B: A quick question before we go on a 15 minutes break.
00:17:14.083 - 00:17:41.814, Speaker A: So maybe I'll just, I mean, I didn't say a conclusion, but let me just say. So we only went up two unions of conjunctive queries. There are other things we can add, like negation, like disequalities, like aggregates, like things that will come in the next days, like recursion and updates and whatever. We didn't talk about that at all. And also, we didn't talk about what happens when we can't do linear preprocessing, how much preprocessing we need, or if we want to increase the delay. What happens in these cases?
00:17:42.234 - 00:17:56.578, Speaker C: In fact, you mentioned several times, to eliminate the duplicates, which of course, brings the question, even in a secret case with no self joints, what happens if you do bug semantics. We had, in the bootcamp, we had a lot about semi rings. And of course, that's the semi.
00:17:56.626 - 00:18:05.484, Speaker A: Yeah, then. Then it should be easy if it's a cyclic, because it's just like enumerating the join, right, and then not printing some of the variables.
00:18:07.664 - 00:18:09.404, Speaker C: What about the hardness itself?
00:18:09.984 - 00:18:13.088, Speaker A: Well, if it's cyclic, you can't even find the first answer in any time.
00:18:13.136 - 00:18:13.724, Speaker B: So.
00:18:15.464 - 00:18:17.600, Speaker C: So you see, it changes over to the.
00:18:17.712 - 00:18:29.164, Speaker A: Yeah, yeah, yeah. Well, a cyclic non free connects, becomes easy, but because of algorithms we know for joins and the hardness result for cyclic queries carries over to the vaccine.
00:18:31.324 - 00:18:36.584, Speaker B: If I'm understanding correctly, all of the hardness are saying, even for the first answer, you're in trouble.
00:18:37.204 - 00:18:51.944, Speaker A: No, for the boolean, the one that's rely on Boolean matrix multiplication. They say we need everything and we cannot do that. And then. Well, I didn't explain this, but for the cyclic case, there's also an alternative reduction that's based on zero click. And then also you need to talk about the total time.
00:18:53.244 - 00:18:57.264, Speaker B: All right, so let's take a break at 1115 and back from Andrew Lincoln's. It.
