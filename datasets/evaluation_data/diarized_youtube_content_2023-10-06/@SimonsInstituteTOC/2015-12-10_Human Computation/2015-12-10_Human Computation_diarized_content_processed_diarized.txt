00:00:00.160 - 00:00:33.272, Speaker A: Hi. Let's see. I want to talk to you about human computation. Let me just mention that this is joint worker Jeremiah Blocky and Santos bin Pala, and some of our students, Lisa Masarova, Ilan Rosenfeld and Sameera samadhi. So what human computation is about, let's see. So it's about deciding which algorithms are humanly computable. This means that they are computable by a human working without the help of a computer.
00:00:33.272 - 00:01:14.514, Speaker A: I don't quite know how to do this working without the help of a. This means they are computable by a human working without the help of a computer, and in a stated amount of time, seconds, minutes, an hour. But that amount of time is really important. And for algorithms that are humanly computable, it's about getting algorithmic upper bounds and complexity theoretic lower bounds on the human running time, the usual sort of thing. But I want to do it for what humans might be able to do, the kinds of algorithms I'll be talking about. The algorithms in this work have discrete inputs, typically strings of letters and digits. Actions are described by the usual operations of string processing and integer arithmetic.
00:01:14.514 - 00:02:18.980, Speaker A: And my PhD student, former PhD student Jeremiah Blocky's work involves algorithms that in addition have visualized and or auditory inputs. Password creation so as a running example of human computation, I'm going to look at the prototypical problem of password creation and recreation. There are a bunch of problems that I could choose, but this is a nice one because we are confronted with having to generate passwords. So password creation and recreation creation refers to the first time that a new password is generated, and recreation refers to all later times when generating that same password. I don't memorize any of my passwords, I just create one. And that same method is used to recreate it whenever I need it. Passwords are never memorized, but recreated password schema is my name for any human algorithm for creating and recreating passwords.
00:02:18.980 - 00:02:52.742, Speaker A: By the way, this is okay, five out of 40, see, you can, we're doing a countdown here. There are 40 slides altogether. Password schema plus key. So a password schema together with a private key is used to map challenges to passwords. So a typical challenge, you know, you go to a website, what do you get? Maybe it's Amazon, so you can read it. You're logging into Amazon or eBay. So a typical challenge is the name of the website, and the response to such a challenge is a password.
00:02:52.742 - 00:03:18.174, Speaker A: So this is new. I have never seen anywhere in the literature people talking about the fact that passwords are challenge response algorithms, there's a lot that theoreticians can do here. For example, here's a schema which would take eBay to lowercase a capital a $1 sign, satisfying all the requirements. Ebay. Except for the fact that it could be made a little longer by having eBay. Ebay. Ebay.
00:03:18.174 - 00:03:59.314, Speaker A: This is considered a good password. It's a terrible one, of course, because once you see that the response to eBay, you know what the response to Amazon will be, right? So this is bad, because the adversary who sees one challenge response pair knows how to respond to all challenges. Okay, so I have this mnemonic for remembering what I'm doing. Fuss picks. Sort of sounds like toothpicks. Toothpicks, but p. So it's an acronym for publishable, humanly usable, secure password creation schema.
00:03:59.314 - 00:04:25.416, Speaker A: And I'm especially interested in Footspix for what Google X calls the naked person in the desert model of computation. No paper, no pencil. You don't have anything. You got to generate the password. This comes up more often than you would imagine. So p stands for publishable and analyzable. Publishable means everyone knows and can use the same schema.
00:04:25.416 - 00:04:54.324, Speaker A: I'll tell you a schema, you can all use it. In particular, the adversary knows the schema. Oh, the adversary knows what you're doing, too. What makes one person's password different from another's is that the schema makes use of a secret private key, and each person has a different key. Analyzable means the description is sufficiently precise to enable a Turing machine without access to the web. That's really what a Turing machine is. No access to the web to transform, challenge to password.
00:04:54.324 - 00:05:23.568, Speaker A: And let me just make a point about this, that publishable and analyzable seem related, but they're different. You can have either one without the other. Most people don't publish their schemas. Those that are published are unanalyzable because they're not precise enough. Take a sentence and use the first letter of every word. It's a wonderful way to choose your password. They don't tell you how to choose that sentence.
00:05:23.568 - 00:05:52.788, Speaker A: And how do you remember the sentence footpix. So this is important because it's true, not just for password algorithms, but for many others. These algorithms have two parts to them. Preprocessing. Oops. For memorizing the password schema and for generating and memorizing private key pre processing. That's the work you have to do in advance if you want to use the schema.
00:05:52.788 - 00:06:22.138, Speaker A: You've got to learn what the schema is. You've got to generate and memorize a key, and that may take a while processing for generating passwords. You don't want that to take very long. I wouldn't mind taking up to an hour for preprocessing, but if you're going to generate a password, you want to be able to do it in 30 seconds. It should go fast. Humanly usable means pre processing time. Time for initial long term memorization should take at most 2 hours, preferably just half an hour.
00:06:22.138 - 00:07:06.854, Speaker A: This includes the time for rehearsals over the user's lifetime. Paper and pencil ok, for this I would allow that, actually, you want to use paper and pencil because you're going to create a key for yourself and you want to be able to remember that key. So it's nice to have it on paper for a while. Processing time should take at most a minute, preferably 30 seconds, and you should do it without paper and pencil, totally in your head. Secure means that an adversary who has seen a few randomly chosen challenge response pairs has low probability to generate the user's password for a new site. That's what I want. And the password game, which I'm not about to makes this whole notion precise.
00:07:06.854 - 00:07:35.264, Speaker A: You're okay with a 0.1 probability? Yes, I'm okay with 0.1 probability. We can talk about. Hi, yeah, if we can talk about that. So it's interesting, you see, a lot of people, especially in this room, will be interested in the security. My real interest is in the human usability.
00:07:35.264 - 00:07:54.800, Speaker A: You'll see some of these things. You'll have a chance to see why I'm okay with point one. Okay. Anyway, I won't get into the password game. I just want to make a point here. Randomly chosen challenge response pairs. Basically, you shouldn't tell people your password.
00:07:54.800 - 00:08:28.464, Speaker A: Just telling you. Don't give away more than six passwords. Don't give away passwords. Password creation schema is a set of instructions for a human to transform challenges into passwords. Set point one can be changed. We could 0.01, would that be better? Pardon? Are you in the NAS or you want.
00:08:28.464 - 00:08:59.593, Speaker A: Okay, the use of schema has many interesting properties. You don't have to remember your passwords, you just have to remember the public schema and the associated private key. Schemas and keys are easy to remember. See, you use them every time you need a password. They're self rehearsable. That's the nice thing. If you use the schema every time you, when the machine tells you, do you want me to remember the password for you? You should always say no, otherwise you're going to forget your password.
00:08:59.593 - 00:09:34.310, Speaker A: Use the opportunity to reconstruct your passwords. Then the schemas and the keys are self rehearsable. The use of a schema and key at commonly visited sites rehearses their use at other sites. The use of schemas has many interesting properties. One nice thing is you don't need to test any actual passwords. You can test the schema together with your private key on bogus websites and challenges you don't have to give anybody. You don't have to tell Google your actual password.
00:09:34.310 - 00:09:55.914, Speaker A: You just make up a challenge and get a password. And then, well, my favorite test is this. You know, there are all these password checkers you can, they're lousy. All of them. They're lousy. My favorite one is this. Take the schema, use the schema key to produce a password, and then see if Google recognizes it.
00:09:55.914 - 00:10:26.864, Speaker A: If Google doesn't recognize it, you're in good shape. I haven't seen anybody mention that either, but that's the way I do it. So the use of schemas has many interesting properties. Challenges are website names. These names are given to you by the site you want to log into. If you modify the website name. For example, by going from American Express to Amex, the transform challenge is surprisingly easy to remember.
00:10:26.864 - 00:10:51.716, Speaker A: You'll remember that you used Amex nearly effortless, not at all like remembering a weird string of symbols. And if you write down the challenges in your iPhone, I don't anymore even write down the challenges in my iPhone. But I used to write passwords. That's terrible. Somebody gets your iPhone, they got your passwords. Now, for a while, I was writing down the challenges, but I found that I can always remember them. So I haven't even done that.
00:10:51.716 - 00:11:28.234, Speaker A: You write down the challenges in your iPhone, and thieves get your iPhone, they don't get your password, they get something else. Okay, the use of schemas. So this is the last of these. I don't have to remember even if I have a password. So last month, Lenore asked me my password for Rei so I could honestly tell her, I don't know if I'm even registered at Rei, but if I am, here's my password. And later she called on, yeah, you're registered. This happens at least once a month.
00:11:28.234 - 00:12:00.254, Speaker A: Proof that is schema is usable by at least one human. So let me just mention that I've given talks, different kinds of talks. One of them was to Andrew Sleep, a program that Steven Rudish set up for bright high school students. And I asked for challenges. Basically come up with a challenge. Challenge is any word that I can spell, you know, that could possibly be a website name. Take that challenge and I turn it into a password.
00:12:00.254 - 00:12:44.204, Speaker A: Students got to see, oops. How long it takes me to generate a password, which is about 3 seconds per digit, half a minute per password. I asked a volunteer to use my Python program. Since it's analyzable, I can write a program for doing this. I asked a volunteer to use my python program to check my responses to assure them that, first of all, I'm not cheating and because I occasionally do make mistakes. And here's what happened this summer. There were several different students making suggestions, and one of them was very clever and said, brain train, grain drain.
00:12:44.204 - 00:13:18.644, Speaker A: See, he's trying to figure out what, what I'm doing. And then somebody else gave me magic. And so what I did is I actually gave them the response to magic one, magic two, magic three, magic four, etcetera. This is useful, like, if you can, if you need to change your password, you just change the digit at the end. Do you see anything that's going on here? I'll give you a chance to. This is going to be an IQ test. I'm going to put this back up and ask you to figure out what's going on.
00:13:18.644 - 00:13:42.946, Speaker A: Okay. So today. So one of the things I could do is just show you how to generate passwords. One possibility, but I thought that what I would do here with you is I want to show you that you personally can use a schema to create passwords. Okay. And what I'm going to do is I'm going to request two volunteers. Actually, four would be even better.
00:13:42.946 - 00:14:13.990, Speaker A: I'm going to whisper in their ears how to do it. And then two of them are going to stand over there, and two of them will stand here and they will take your challenges and you'll see how they produce the passwords. And of course, that'll be an IQ test, too. You're going to have to figure out what the heck they're doing while I'm getting my volunteer. This is for those of you who want. You can try to see what's going on. I need four volunteers.
00:14:13.990 - 00:14:23.750, Speaker A: Come on up. Come on, come on. Four volunteers, please. Please. Yes. Thank you. Two will do.
00:14:23.750 - 00:14:42.744, Speaker A: But how about two more? Please, please. Yes. Come up. Okay, so I'm gonna. Let me also. So you're going to two for here, two for there, actually. Why don't you all come over here for a second while I whisper in your ears.
00:14:42.744 - 00:17:41.566, Speaker A: Let's close the challenge. We can hear you. I'm gonna tell you, I'm gonna make it's can, so you're going to have to do this. You're going to write the challenge and then the. The password after it. Okay? I need a challenge. A word, short word.
00:17:41.566 - 00:17:49.354, Speaker A: Let's start them off easy. Home. Home. Good. Home. Let's see how you do. Home.
00:17:49.354 - 00:18:01.590, Speaker A: Yeah. Yeah. You don't look at each other. I got to show the audience that you're not in cahoots. Don't look. Yeah, don't look. Don't look.
00:18:01.590 - 00:19:09.670, Speaker A: Just look at the board. The first time doing it, so they started off the same disaster. It helps to have a little practice. I see them covering up their. We're done. Okay. Do they agree? Thank you.
00:19:09.670 - 00:19:37.104, Speaker A: Thank you. Thank you. Thank you. Thank you. Anybody see anything going on here? You said presentation of the fiscal. That's very good. That's the only thing anybody has ever seen.
00:19:37.104 - 00:20:01.148, Speaker A: Notice this first column is a permutation. How about the second column? Third column, permutations. The last one is not. Last one is not. Part of this is just. Because if it wasn't a permutation. Well, it doesn't matter.
00:20:01.148 - 00:20:22.992, Speaker A: I won't get into it. The permutation is purpose. Is there on purpose. Okay. So today I proved to you, you can do it. Now, proof that you personally can use a schema. Next, I'll tell you how to do this for yourself.
00:20:22.992 - 00:20:47.654, Speaker A: So what I told them, I'm going to tell you a good way to do this. What I tell you won't help you break the schema and key, by the way, that I gave them. I have lots of schemas, but one good one is all. All that's needed. So before I do this. Yeah, okay, we've been through this. So here's a way to transform challenges into passwords, okay? And I hope you give it a try.
00:20:47.654 - 00:21:23.186, Speaker A: Generate and memorize a map from letters to words. You know, in the army, we learned something. What was it? Adam Baker, Charlie, David Company. There were words for every single one of the letters, so it's not impossibly difficult. But don't use one of the known words per letter. So make the right way to do this is simply to pick from ten words that begin with a. Pick ten.
00:21:23.186 - 00:21:38.116, Speaker A: I like names. Ten names that begin with a. I got Archie. Ten names that begin with B. There are lots of names that begin with all letters except X and Q. Bren. Take a word that begins with C, Charles.
00:21:38.116 - 00:22:34.314, Speaker A: Respond to a challenge by replacing each letter in the challenge by the letter after it in the word. So C is Charles, that's the h which comes over here. Then a is the letter after a is r, and then the letter after b is r. That would be the response. This particular schema has quality 6.5. What that means is that for most dictionaries, including the top 40 websites, which is a good sample set, an adversary who gets less than seven challenge response pairs will not have enough information to be able to figure out what's going on. But if they have seven, then they have a reasonable chance to find out what's going on.
00:22:34.314 - 00:23:08.294, Speaker A: So you actually computed this? I didn't compute it. Well, you could compute it. I didn't compute it. I just sampled it. You take the first 40 websites, you try ordering it in all possible ways, on the average for the top 40 or for any dictionary. Just take a sample. I didn't tell you the game that I used to determine the queue, but basically, I guess the basic thing is, what I'm promising you just is don't give away more than six passwords, but you're okay until then.
00:23:08.294 - 00:23:50.538, Speaker A: If you want an even better method, then use slightly bigger words like Archibald instead of Archie, and Brendan instead of Bren, and Charlemagne instead of Charles. And then respond to a challenge by replacing the ith letter in the challenge by the I, first letter in the key. So you see, the first a gets turned into little r, the next a gets turned into little c, the next a gets turned into little h, and the b gets turned into D. So you always. I use my fingers. 12345. You keep track of which letter you're on, and then you pick out the corresponding letter, put it in.
00:23:50.538 - 00:24:20.154, Speaker A: This has quality 20.5, so you can give away a lot more. But the truth is, why would you give away anything? Why would you give anybody your password? Well, I give Lenore my passwords. Why would you give away your challenge? You can give away passwords, just don't give away the challenge response pair. If you're going to use eBay, well, you could use eebbaay. You could use. You could use ex by a z.
00:24:20.154 - 00:24:57.634, Speaker A: You don't have to give away your challenge. The method you use to create the challenge from the website, that can be your own method and nobody else needs to know about it, so you don't have to give away 20. I think this is much more complicated than is necessary, but you can have it. See, this is the best by the way that we've been able to get the best, highest quality that we've been able to get. So, security of the schema. Security of all the schemas are based on information theoretic arguments. So as long as you don't give away more than a few challenge response pairs, you can expect to be secure.
00:24:57.634 - 00:25:05.274, Speaker A: What if there's some statistical things of, like, people choose, like, Charlie Four C a lot?
00:25:05.574 - 00:25:05.886, Speaker B: Yeah.
00:25:05.910 - 00:25:32.604, Speaker A: Yeah. So that's why it's really important for, for you to start off with taking four words that begin with C and then picking at random one of them. Try to choose two. You know, you don't want Charles one. Charles two. You don't want Charlie Charlissimo. You know, you want to have words where that letter after C is different in each case, and now pick at random, then you're fine.
00:25:32.604 - 00:25:57.404, Speaker A: That's a very good question. Question. Okay, so about human computability. So different humans are like different models of computer. Some are slower, some faster. We count the steps that human takes. We count the steps a human takes.
00:25:57.404 - 00:26:33.944, Speaker A: Some humans add two digits mod ten twice as fast as others. That's no different than that. Some computers run at twice the speed of others. Okay, human computability. A human calculator is so much slower than a computer that any proof that a computer cannot break a password schema must generally be information theoretic complexity. Theoretic proofs are almost certainly not relevant. And to see why, consider that the world record for multiple multiplying two randomly chosen eight digit primes in one's head is currently three and a half minutes.
00:26:33.944 - 00:26:53.184, Speaker A: Freddy Hernandez. 6th February, 2015. Not that long ago. There are championships on this. This considerably. Three and a half minutes is a lot more time than is acceptable for generating a password. And yet Wolfram alpha can factor the resulting product in a fraction of a second.
00:26:53.184 - 00:27:29.704, Speaker A: So the point is that complexity theory is not what's coming in here. It's information theoretic. Maybe not. What? Okay, about human computability, let me mention the data structures of the brain. I don't know to what extent you may have thought about the fact that the data structures. Did you think about, when you think about memorizing the Alphabet, did you think about how you're going to store it in your brain? What data structure do you use? Well, I tell you, you all use singly linked lists. A, B, C, D, E, f, G.
00:27:29.704 - 00:28:09.094, Speaker A: You can go backwards, but you have to learn a different, a different sing song for it. Cyxw Vutsrqpo and M l K J, I, H, G, F, E, D C B, a. So you can do that. But, you know, even having gotten now this ability to go forward and backward, I still can't, when given P, tell you what comes before and after, that would be like random access, and I don't have that in my head. That's the next job I need to do. Okay. Algorithms for human computation require spelling out details that we normally pay little attention to.
00:28:09.094 - 00:28:32.218, Speaker A: These include how data is stored in the brain. For example, most of us can recite the Alphabet in the forward direction. Few of us can recite it backwards. The Alphabet appears to be stored in our brain as a singly linked list with a few pointers into it. So if I ask you what comes before P? What comes before P? Oh, that's good. That's good. Most people have to go back.
00:28:32.218 - 00:29:01.004, Speaker A: Maybe lmnop. Oh, okay, thank you. That's good. Were you looking? No. Okay. It takes more work to store the Alphabet as a doubly linked list in which the letters before and after any given letter, such as l, are recalled in one step. And so telling people how to store stuff in the brain is important for some of these schemas.
00:29:01.004 - 00:29:55.164, Speaker A: For some of them, you really want to be able to tell them what they need to know so that they can do this quickly. About human computability, algorithms for humans must specify if the human is required to do the computation in their head, or paper and pencil is allowed. Yeah, I want it to be done in your head here, the head home to look at, but I really don't want it in the head. In the case of passwords, paper and pencil are okay for the pre processing, you know, for the memorization stage, but not okay for the processing. Generating the password. About human computability, when we say that a human can do a certain computation in 1 minute, this is because steps have been counted and a reasonable running time per step has been assumed or asserted. So this is an important part of it that we can do for human computation what we do for our ordinary computer.
00:29:55.164 - 00:30:33.746, Speaker A: When we write an algorithm, we can count the number of steps. We should do the same thing for what people are doing. One difference is that constants are important. You know, recognizing that a computation is linear order n is useful, but it's not enough. The specific constants are actually important in this business. Another about so there's the CSP's constraint satisfaction problem solvers, you know, like sat solvers, actually quite powerful. In our experience, if a published password scheme can be broken, and I say here, what it means to be broken.
00:30:33.746 - 00:31:04.904, Speaker A: Then a CSP solver will break it. It just needs to be given enough challenge response pairs. That's why information theoretic is really important. You want to make sure that the information isn't gotten there. So a password schema is broken. If an adversary who knows the schema but not the key, and has seen the response to seven randomly chosen challenges, has a good chance to guess the response. And that's what it means to be broken.
00:31:04.904 - 00:31:27.586, Speaker A: Here's a conjecture about passwords. I don't know if I want this to be true or I want it to be false. I just would like to have the answer. I don't even know. I don't know. Here's what it is. I don't know if a human being can do something in their head, can actually create passwords.
00:31:27.586 - 00:32:11.184, Speaker A: You following a schema that I don't know if a human being can compute a hash function in their head, say a one way computer hash function that somebody who sees the output can't figure out. Somebody with a computer who sees the output can't figure out what came before. So here's a precise passwords conjecture. If in time t one, a human can both learn a humanly usable schema, s, and also generate and memorize a private key for s. That's because you need both, right? You need the schema, and you need the key to be able to get passwords. Takes you a certain amount of time to memorize that. That's time t one.
00:32:11.184 - 00:33:06.500, Speaker A: If he, I use he because the users are he in my terminology, and the adversary is she. So they both come up. If he can then use s of k to transform a random set of n challenges into corresponding responses and responses in his head in expected time, t two n. So of course, t two should be relatively small. I want less than a minute per password. Then a computer program, typically a modern constrained satisfaction problem solver running on a laptop, on input, given the schema and these challenge response pairs will find the key, or an equivalent key, one that generates the same responses to the same challenges in the same total expected amount of time or less. T constant, simple.
00:33:06.500 - 00:33:44.754, Speaker A: I'm not even saying in twice that amount of time. It's not even a constant. I'm telling you that the conjecture is saying that you can't come up with a schema. Yeah, so the conjecture, I'm not sure about this. I could have stated as an open problem. I'm stating as a conjecture that any schema you can come up with, it's possible to have a program break it in that same amount of time. Any questions about that? And you're measuring time in units of time rather than steps? Yeah, yeah.
00:33:44.754 - 00:34:09.684, Speaker A: So my whole goal in this thing is when you have a schema, you count the number of steps. You do that, but each of the steps is small. Like add this, add three plus seven mod ten. Add nine plus six mod ten. They're very small steps. And each one, it's easy to check how long it takes to do them. And then from that you get seconds.
00:34:09.684 - 00:34:24.078, Speaker A: I mean, like, if it takes a human five minutes, then it'll take a computer at most five minutes. Right. My laptop. Okay. Human usability model. So this is perhaps the most interesting part. Do I have time? Yeah.
00:34:24.078 - 00:35:02.014, Speaker A: So the most interesting part is this usability. So, as a graduate student, I had a wonderful mentor named Warren S. McCulloch. He was a neurophysiologist, and we were interested in the brain. And I wondered, what's a good model for the brain? Is it a finite automata? Is it a Turing machine? Or is it something in between? What's the model? Wondering about what might be the right model. Finite automata seems wrong, because that would mean that if you know German, it's because you built in. That's sort of Plato's notion of our brain.
00:35:02.014 - 00:35:39.894, Speaker A: There's something wrong there. Here's the model. A human is a finite state machine, all right, but with access to a long term, relatively permanent memory and a short term working memory. Actually, this is all this is telling us, that this is a bit of computer science that maybe is connected to cognitive science. What you'll see here is that the cognitive scientists know things that are useful for this human computation long term. But this model is mine. It's long term, relatively permanent memory.
00:35:39.894 - 00:36:38.162, Speaker A: What's relatively permanent memory mean? That's very interesting. There's a guy named Wozniak. Not the computer Wozniak. It's a different wozniak. He's a polish psychologist who said, well, if you remember today something that you remembered yesterday, 24 hours ago, then very likely you'll remember it tomorrow 24 hours later. And in fact, there's a good chance you'll learn it, remember it 48 hours later, remember today, something you remembered yesterday, then two days later, you might still remember it, and then if you remember it, then four days after that, you might remember it, and then eight days after that, you might remember it. So Wozniak basically said that there is a doubling schedule, which he recommends for memorizing stuff, and he spent his whole life actually working with this.
00:36:38.162 - 00:37:11.924, Speaker A: One of the many wonderful experiments he has is he took seven computer science students in Poland just by chance. That happens to be computer science. Seven computer science students who wanted to learn Polish, who wanted to learn English in the process. In the next few years, what they did is they built up a vocabulary of 40,000 words. I got 40,000 words. That's bigger vocabulary than I have. And he did it in order to find out what this doubling schedule, what the scheduling is.
00:37:11.924 - 00:37:32.694, Speaker A: He found that in every case, if you remember something from a day from a month ago, that you need to rehearse it two months later, you don't have to rehearse it a month later. Two months later, we'll do, but not too much more. And he found the constant. The constant was not always two. It was between 1.8 and 2.3 on these seven students.
00:37:32.694 - 00:38:05.810, Speaker A: Very close, very close. And he's been doing this for very, very many years in his life. So he keeps careful tabs. He has written programs which basically they wake you up and tell you what to rehearse so that he can check it out. Okay, did they learn English or did they just know 40,000 words? They didn't say anything about that. You just said 40,000 words. I saw some of the words.
00:38:05.810 - 00:38:48.634, Speaker A: They're not as bad as the kind you find in Scrabble, but they are not the obvious words either. And in any case, they did not start out with knowing very much English. Only words didn't tell them how to use. Okay. Long term memory, which stores schema and key, is written in the pre processing stage refresh through use, and used in the processing stage in read only mode. So basically, the model is long term memory, which takes a while to get stuff into it, and then when you need to use it, you are using it. In read only mode, long term memory is unbounded.
00:38:48.634 - 00:39:19.720, Speaker A: Some people think it's finite. No, no, I'm thinking it's infinite, except for the substantial time and effort needed to acquire it. A concentrated hour or so for an acceptable password scheme and key. Right. You're going to learn those maps from letters to words. It'll take you an hour. The relatively small time and effort speed rehearsals required to maintain it measured in minutes over a lifetime and the length of one's mentally healthy life.
00:39:19.720 - 00:39:52.844, Speaker A: Of course, this is not infinite because at a certain point you stops working, your brain stops working. Well, at that point, you're not interested in using passwords anyway, so it doesn't matter. Short term working memory. Short term memory is a tiny read write memory. Why it's so small, I don't know, but tiny means seven plus or minus two chunks. You've heard about this that we store in our head, seven plus or minus two chunks. What's a chunk? Chunk can be.
00:39:52.844 - 00:40:27.084, Speaker A: So if you read the literature, a chunk could be a letter, a digit, a word. I can tell you what it is. A chunk is a pointer, really. It's a pointer you store in that short term memory a pointer to some item in long term memory. That's what a chunk is. It's a pointer to some item in long term memory and what you might be doing. Okay, so a chunker being appointed to a well defined item in memory, and that item could be a digit, a letter, a word, the entire Alphabet, and so on.
00:40:27.084 - 00:41:10.584, Speaker A: Short term memory is a tiny read write memory. For purposes of the password problem, it is used in the processing stage to transform challenge to response. And if you're there trying to transform challenge to response, you're very aware of the fact that you can only store so much in your head. There's a basic fundamental limit there. Short term memory severely bounded seven plus or minus two chunks. In password computations, it typically consists of two characters, two letters, two digits, or one letter in one digit, and a pointer into one or at most two sequences, these being typically the challenge itself, and at most one additional sequence. The people who were doing this up on the board, they had a pointer into a telephone number and a pointer to the word.
00:41:10.584 - 00:41:35.742, Speaker A: Those are the words what they needed. Okay, they needed a pointer into the Alphabet. Short term memory fades quickly. Items in short term memory that are needed but not recalled for more than two or three options, operations must be reconstructed. Okay, so, and then here's c. Six out of seven, look, 34 out of 40. We're getting there.
00:41:35.742 - 00:42:16.388, Speaker A: Okay, short term working memory for letters and digits is a stack of two elements. Accessing an entry, whether top or bottom, has a certain cost. Retrieving a sequence has a certain cost. Here I'm talking about the kinds of operations that you can perform in your head and the cost like you have a pointer to some letter in the Alphabet, what's the next letter that costs one step, provided, of course, you've got the Alphabet in your head. It wasn't always clear that they did have the Alphabet in their head. But anyway, moving the pointer one step to the right has cost one. Resetting the pointer into a sequence, resetting, you have a challenge.
00:42:16.388 - 00:42:39.772, Speaker A: Resetting the pointer to the start of the challenge. Once the we're setting it to the end of the challenge. One step moving forward, one step moving backward. That's very hard for us to do. So there are complexities of kinds of operations we can do in our head. With arithmetic operations, you can do arithmetic mod ten in your head. Even mod eleven is kind of nice.
00:42:39.772 - 00:43:12.104, Speaker A: Mod seven is. I don't know if you can do it. Mod seven, you can do operations of plus minus times in your head, and you can write down what they cost. And so you write down these operations, and you find out how much it costs to do them. And that gives you a very nice way to say how long it will take to perform a schema. And then you can see if your schema really satisfies a condition that it would take at most 1 minute, preferably 30 seconds, to produce a password. This has worked very nicely.
00:43:12.104 - 00:43:58.044, Speaker A: Okay, so I won't go through this. Other problems, lots of other problems to consider. So the password problem, as I said, is prototypical. But can a human do coin flipping over the phone? Me against, you know, the usual Bob and Alice. Me, Bob against Alice, Bob, you're supposed to do it in your head, but Alice, maybe that is a computer and is cheating. Is it possible to do coin flipping in your head, even against a cheating adversary? I've had suggestions for what might work, but in each case, they're not really humanly usable. The answer could conceivably be yes, but I don't know.
00:43:58.044 - 00:44:44.024, Speaker A: Zero knowledge is a fascinating concept, right? An idea that you can convince someone that you know a secret without giving away that secret. With zero knowledge proof, you can, in principle, convince a bank that you know your password without giving it away. Anyone can hear your conversation with the bank, the conversation in which you convince the bank you know your password, but no one can impersonate you, not even the bank. Wouldn't it be wonderful to be able to do zero knowledge proofs in your head? But I don't. I don't believe it can be done. And here I'm giving why? I mean, I don't think a human being can, can compute a one way function. It's sort of very much like a human being can multiply two numbers in their head, but the numbers you can multiply in your head can be easily factored.
00:44:44.024 - 00:45:27.150, Speaker A: I don't believe a human, so I think zero knowledge proofs are out of scope. But again, I don't have proofs. Anyway, that's what human computation is about. And that's it. Three questions at least, please. Yes. I didn't see OPM, how verifiability is possible is there, like the problem we just did up there with the password? Like, without knowing the password and schema, how can a computer verify yet not break? Well, first of all, what I told you in your year, I could certainly write a program for it.
00:45:27.150 - 00:45:50.114, Speaker A: But what you tell the bank, you know, what you tell Chase bank is the password. You don't tell them that you're using chase or any modification of chase as your challenge. You just tell them the password. They get just the password. They certainly don't find out what your key is. You don't tell them the schema or the key. Although the bank could, if this were used by a lot of people, the bank would know what schema you're using.
00:45:50.114 - 00:46:28.054, Speaker A: Another question, the one about turning letters into words and then using. That's a very good one, though. I've got many, but it's taken me years to come to realize that this is one of the best. No, mine transforms like magic one. If you want to, you can ask me what magic three is and we can go back. You'll see, I'll generate it. You can give me chain drain, you can.
00:46:28.054 - 00:46:58.476, Speaker A: 26. 26. Okay, so this is a good point. The point is that, first of all, people do learn it, because all these radio operators know these words. So certainly it can't be too hard. And then secondly, there is a magician named Juan Tamaris. He's italian, so Italian, Emanuele.
00:46:58.476 - 00:47:29.404, Speaker A: And he's wonderful because, you know, when he talks with his hands and he's a magician, and he will teach you how to memorize the random order of the order of a random. You take a deck of cards, 52 cards, and, you know, you. What are they doing? Shuffle them. Shuffle them. You get random order. And then he will teach you how to memorize that random order. He guarantees you will memorize it and remember it permanently in 3 hours.
00:47:29.404 - 00:48:04.594, Speaker A: And it's very interesting because it doesn't go by that doubling schedule. He's telling you, at the end of 3 hours, you will know that order. And if he wakes you up in the middle of the night, asks you, where's the queen of hearts? You know, it's a wonderful video to see. So the point is, a magician can do this with three concentrated hours. Of course I want to do it with much less. I would like just 1 minute. I mean, lenore is unwilling, my wife is unwilling to learn anything in order to use the schema.
00:48:04.594 - 00:48:08.896, Speaker A: That's why I needed to have something I could whisper in their ears.
00:48:09.000 - 00:48:41.364, Speaker B: Russell, have you thought of totally different domains other than security. One where you could apply thinking about human abilities to compute. One thing that comes to mind is emergency response. There's lots of mnemonics people use to decide what to do in certain emergency situations. Can you, like, optimize, use this idea to optimize these mnemonics? Or come up, you know what the.
00:48:41.864 - 00:48:46.936, Speaker A: Give me an example. I live by examples like, so I.
00:48:46.960 - 00:48:48.564, Speaker B: Never learned any of these things.
00:48:49.384 - 00:48:52.248, Speaker A: Or even examples you're supposed to drop.
00:48:52.336 - 00:48:54.936, Speaker B: Roll, and something or other. If there's a fire.
00:48:55.080 - 00:48:59.706, Speaker A: Ah, I see. Don't use the elevator. You would like to have it burned into your brain.
00:48:59.800 - 00:49:13.246, Speaker B: So what do you do if there's a fire in a building and you're like, you're the fire monitor for the building. You have a checklist of things you're supposed to follow. How complicated can that checklist be? Can you have conditionals?
00:49:13.350 - 00:49:37.912, Speaker A: This, again, is getting into the cognitive science. So let me tell you that, first of all, there are some wonderful things that are known. I mentioned one here, the doubling schedule. I mentioned another one, tamarisis thing. What I didn't mention to you is Joshua Foer's book. Do you know Joshua Foer's book? If you haven't read this thing, you got to read it. It's wonderful bedtime reading.
00:49:37.912 - 00:50:07.144, Speaker A: Joshua Foer, he's a journalist. He was assigned to go to New York. There's a memory contest being held in New York. He's supposed to write about it. He went there and he found that these kids, these guys that were there, they were crazy. They were crazy. They came with attache cases.
00:50:07.144 - 00:50:39.640, Speaker A: You know what's in the attache case? Twelve decks of cards. Why? Because part of the memory contest is you shuffle these decks of cards and then you see how many of them you can remember. The world championship for memorizing the order of a deck of cards, 45 seconds. But these are not world champions, so it takes them a minute. Can you imagine? You look at a card, bam, bam. In 1 minute, they know that. Then they go on to the next deck of cards.
00:50:39.640 - 00:51:20.632, Speaker A: How can you do this? So this is, you can read in Joshua Forest's book. It's called moonwalking with Einstein. And it's great, by the way. Let me just mention that when he saw these guys doing these crazy things, he asked them, first of all, gee, have you ever been worried about the fact that maybe somebody with one of these fantastic memories, what's it called? These photographic memories, would come and blow you out of the water? So we used to worry about it, we're sure that such things don't exist. These are people who have simply learned how to do this. They're all normal people. So normal people.
00:51:20.632 - 00:52:28.364, Speaker A: He said, you mean I could learn to do this? I could be the memory champion? He's told, yes, if you follow my instructions, spend real concentrated time in one year, you can be the memory champion. So he took him up on it, worked on it for one year, the next year he was the US memory champion, which is not as good as the european memory champion. So pretty good. That's great bedtime reading, if you want to answer your question, Russell, that's the book to read. Going back to the issue of the one way function, I wonder whether the work of Atobami Shah and Kuchi lebi minimizing the complexity of computing the forward direction of a one way function, is it relevant? Could it be brought down to a level that humans can perform? Yeah, so this is a good point. I'll mention something I have thought about. So Avram suggested for this sort of thing, that one way to do coin flipping over the phone is you use the following one way function.
00:52:28.364 - 00:52:59.934, Speaker A: You take 100 digits, hundred digits, memorize location of ten of them. You can put 100 digits into a picture. You can't put very much more. And you can't remember the locations, except you can remember it's the ear, the nose, everybody picks the nose, the left shoulder, the belly button. You can remember different parts, these cartoons. You put in these digits, you can remember ten locations. Okay? And then what you do is you sum those ten locations mod ten.
00:52:59.934 - 00:53:23.642, Speaker A: You can do that. That should be the function you compute. You want more than one digit, so you do this ten times to get ten digits. So this has a nice property. It's in general, n digits. Square root of n is what you memorize. Nobody knows how to gaussian.
00:53:23.642 - 00:54:17.100, Speaker A: If you have n equations, you can solve, but with less equations it can be impossible to solve. So all you have to do is be able to remember the square root of n locations and add them quickly. I don't know how to do that. It's very hard for a human being to actually do this ten times, to do this additional mod ten, and then do it again and again and do it ten times. You're way over a minute by then. So I don't know, even for something as seemingly possible as coin flipping, whether it really is possible. This was a great suggestion, but I've heard some people say that humans are much more geared towards solving problems presented visually, like graph problems, then numbers and letters.
00:54:17.100 - 00:54:45.584, Speaker A: You said you have some work on that as well. Well, so Jeremiah Blocky, who I mentioned and worked on this with me, has looked at this whole problem of using visual memory. The problem is usually that I don't know how to make good use of it. We learn how to ride a bicycle. We don't know how we ride a bicycle. This is something that we can learn. But you know, it's very funny.
00:54:45.584 - 00:55:09.684, Speaker A: Most people think that when you're on a bicycle, if you want to turn right, you should turn right. No, you turn left, you fall to the right. That's what gets you going to the right. People don't know what it is they do in that case, but I don't know how do you make use of that to actually produce passwords? I would love to. One example would be great. Well, you've been very patient. Thank you very much.
