00:00:00.840 - 00:00:26.990, Speaker A: Well, welcome, everybody. It's a great pleasure to see you here today. So, this is the first of two colloquia on novel fault tolerant quantum architectures. So today, Michelle Devereux will talk about error corrected logical qubits. Oh, no, I guess correcting decoherence errors of a logical qubit, I guess, is what he. What he's calling it. And.
00:00:26.990 - 00:01:12.232, Speaker A: And next week, Patrick Hayden will talk about a simple architecture for a fault tolerant qubit. So, it's great pleasure to have Michelle here today. Michelle is the professor of applied physics at Yale and the director of the applied physics nanofabrication lab there. He did all his schooling in France, and then he did two years. Spent two years in Berkeley doing his postdoctoral work with John Clark in John Clark's lab. He. I guess he has a very distinguished record.
00:01:12.232 - 00:01:39.018, Speaker A: And, you know, he's one of the. One of the creators of this, what's called. What's been called the circuit QEd paradigm. Yeah, a number of honors which I won't. You know, I'll just. I'll just mention the John Bell Prize, which he shared with Robert Schalke in 2013, and the Fritz London Memorial Prize 2014. So, you know, without further ado, let me.
00:01:39.018 - 00:01:46.134, Speaker A: Let me just, you know. Great pleasure to welcome you here, Michelle. I'm looking forward to your talk.
00:01:47.854 - 00:02:45.354, Speaker B: Thank you, Umesh. Thank you also for the kind introduction. And so, yes, today I will be talking about, indeed, a new type of architecture for error correction. Before I begin, I would like to thank the people in the panel today. Daniel Gottesman, Jonathan Holm, Shruti Koi, and Chen Wang. I apologize in advance for the specialist of this field of bosonic error correction that I will be introducing today. So this is, I hope, going to be an introductory doctor ito, so please do not pay attention to the simplifications.
00:02:45.354 - 00:04:11.514, Speaker B: Okay, so, the experiment I am going to discuss today has been recently published in Nature, and I would like to introduce the people who have taken the data that I will be presenting. Alec al K boosh to Stephen Tuza, Philippe campagne. And, of course, I would like to acknowledge the help from our authoritation colleagues, Shruti Puri, Stephen Vervin, Yang Zhang and Leon Glassman. And last but not least, I would like also to acknowledge Rob Scholkopf, with whom I'm sharing a lab and with whom it has been fun over the last 20 years to investigate various aspects of superconducting circuits. So, the outline of my talk is the following. There will be three parts. The first two parts are very introductory, and the last part will be devoted to the experiment that we did and which is still ongoing.
00:04:11.514 - 00:05:52.604, Speaker B: So, to start very simply, you all know that what we call a physical qubit is two levels. Two levels generally, the first two energy levels of quantum system. We represent the state of the system. By your point on the Bloch sphere. The question that we are asking in our experiments is, can we protect the qubit from the three arrow channels labeled x, y and z, which represent, in this effective spin language, three orthogonal random fields that will randomly shake the qubit and make it decoy? And to analyze this question, I want to go not right now in the channel language xyz, but consider the error generators, which are bit flips and face flips. And to understand the principle of error correction, let me introduce the idea of non local wave functions by considering a particle. Sigma is the quantum spread of the particle due to quantum fluctuations.
00:05:52.604 - 00:07:13.824, Speaker B: And I suppose that I have two boxes which are separated by a distance d, which is much larger than the extent of this fluctuations. And what I call a non local wave function is a superposition of the particle being in the left box and the particle being in the right box. And this is a form of protection, not a complete protection, as you perhaps all know. All these three attacks can be decomposed into two generators, the bit flips, which takes this angle theta and adds, or this angle phi and adds PI. That's the face flip. And of course, all these combinations will be equivalent to these three arrow channels. So when you encode the qubit in this non local way with these two boxes, which are far away in real space, I will protect the qubit against bit flips, which would exchange the cos and the sign, and exchange the box.
00:07:13.824 - 00:08:17.574, Speaker B: Of course, you don't protect the qubit against face flip, which correspond to different local potentials here. And so the aim of quantum error correction is to create an encoding which is immune to both the face flip and the bit flips. And there are two types. To introduce the kind of architecture we are interested, I need to distinguish two types of architecture. There is the discrete variable architecture, which is based on a register of n, physical qubit, which provides a redundant Tilbury space with dimension n equals two to the n, little n. And well known examples of these are the short codes, steam codes, surface code, color code, and so on. So this is a register quantum error correction.
00:08:17.574 - 00:09:37.524, Speaker B: The architects we are interested in the so called bosonic error correction. Bosonic codes involves the so called continuous variable approach. But I prefer to talk about the encoding of information in an oscillator in the discrete form state of an oscillator. And as you see, there's a correspondence because if you have, let's say, little n qubits, if your register is composed of little n physical qubits, that's equivalent to taking capital n levels of the oscillator and, and taking the log in days, too. And this kind of code was originally developed by Daniel Gottesman with Kitaev and Presker. And more recently there are CAD codes, binomial codes, cat codes and so on. But today I will actually concentrate on this so called GKP encoding.
00:09:37.524 - 00:10:59.304, Speaker B: In our opinion, from an experimental point of view, there's a huge difference between these two types of encoding. The register approach has the merit that when you go to very large little n, the dimension of Hilbert space increases exponentially. That's good, but there's a huge overhead. Before you can benefit from this exponential regime, you need essentially one Josephson circuit, at least per physical qubit. On the other hand, if you take the continuous viable approach or the oscillator encoding, you have really much more favorable overhead. Typically, only one Josephson circuit is needed per oscillator, but each oscillator can encode the equivalent of many physical qubits. To give you an idea of the problem with the register error correction, let's take the steen encoding, which is based on seven physical qubit and a Hilbert space of 128.
00:10:59.304 - 00:12:13.364, Speaker B: So what you do is you encode the zero logical and the one logical in this entangled state, the register. And here these hexagons are all the seven qubits, and the state is these superpositions, which have deep symmetry properties. I'm not going to comment them, but if you go around the placket in each of these wave functions, you see, you will have an even number of zeros and one in both wave functions. With this kind of symmetries, you can in principle correct all errors. But to give you an idea of the overhead, I have actually drawn the feedback circuit for error correction here. So on the left, all these lines here represent the seven physical qubits. And at the bottom here you have the six ancillary qubits that correspond to the detection of six arrow syndrome.
00:12:13.364 - 00:13:18.612, Speaker B: On the three most left columns, the columns in which you see this, the parity measurements you correct for big flips, and here you collect for big phase flips. So by correcting all the two generators, you collect all errors. On the right here you have the operation, the correction operations, which depend on what error syndromes. You decode here into the yellow box. But the problem is that you see that for one logical qubit, you need at least seven qubits plus six ancillary qubits, 13 physical qubits for one logical qubit. And even then I have not considered the fact that the ancillars could have errors also. And all this hardware is needed to monitor 21 error channel.
00:13:18.612 - 00:14:38.850, Speaker B: I have seven qubits here. They all have three arrow channels. So this is 21 type of errors that you have to monitor by this circuit and correct simultaneously. So this is quite frightening for an experimentalist. And this grid state encoding that was pioneered by GKP in 2001 is fabulous in the sense of limiting the hardware to a minimal amount. Actually, the fact that this is so economical in terms of hardware was not realized until a few years ago, where the primitive operation that is needed in this grid state encoding was not realized very quickly after this prediction. So, to introduce how we in the lab are going to implement this error correction, I need to introduce the representation of quantum states of an oscillator in phase space.
00:14:38.850 - 00:15:42.622, Speaker B: So we represent these quantum states by their signal distribution, which is some quasi probability distribution, the vacuum state. So p and q are the phase space coordinate, q being the position and p being the momentum. Here the units are square root of photon numbers. This disk in the center corresponds to the quantum fluctuation of the vacuum. And if you go to the fork ladder, you will go to the one fog state, which has this white ring of node, the distribution. Then if you have a two photon state, you will get two rings and so on. But this is only one of the few types of states that you can build.
00:15:42.622 - 00:16:28.436, Speaker B: You can build many other states. You can build, for instance, the so called korean state, which is a displaced vacuum here by two units in phase space. You can also squeeze the vacuum here. I have chosen a 45 orientation of the squeezing. The fluctuations have been reduced along one coordinate and increased along the other. And there are many other states, like superposition of Kojan states, which produce cat states, and cad states can themselves encode quantum information. And this can be very useful.
00:16:28.436 - 00:17:43.840, Speaker B: But I won't be talking about this during this week. Webinar, we might discuss this question with the panel. Okay, so now, having introduced this useful representation in face space, which is to be very useful throughout the talk, I just want to for a few minutes tell you about the basic ideas of this GKP code, grid state code. So the idea is that you take the squeeze state. So we are not following the lead of the cat. We are following the lead of the squeeze vacuum here, and we squeeze the vacuum along in order to make essentially piquet fence wave functions in coordinate space. And each of these pkehs is a squeezed state in the coordinate direction.
00:17:43.840 - 00:18:36.028, Speaker B: And I am superposing all these fixed states. This will create zero logical. And it's simply a superposition of translated vacuums, three states. And the one logical can be disused very easily from this zero logical. It's just the same state, but translated by half a period. So with regards to my particle in box scheme, that fits the bill, because you see, the separation in some sense between these wave functions is maximum. The width of each of these piquet is extremely tiny.
00:18:36.028 - 00:19:42.694, Speaker B: So you have a lot of distance related distance between two piquets belonging to these two states. So if you have an error, you can small translation error, you can correct it. But what is wonderful in that code is that you don't correct only bit flips, but also face flip. Because if I look at these wave functions in Fourier space, I also get picket fence type of wave functions. But if I superpose these wave functions to create the minus and plus states which live on the equator of the block sphere, they also, in some sense, maximally separated. So exactly like, I can correct the translations along the q coordinate, I can also correct the translation along the p coordinate. And that corrects both bit flips and phase flips.
00:19:42.694 - 00:21:01.644, Speaker B: And there are also a lot of bonus in this code. So, for instance, the Clifford operations are and can be obtained by combining translation and rotation. So there is also a marvelous property of these codes that became more clear thanks to work in Gavin and John group, which is that not only this code can correct translations, but it can correct also photon losses optimally. And that really is a very strong motivation, because if, as oscillators, you use superconducting cavities, then in these superconductivities that we can make in the lab, the dominant error mechanism is photon losses. So here we have a code that is optimal for photon losses in a cavity. And so it is a very appealing code. There's one problem, which is, well, how do you create these states? And this is where we have to go in phase space again.
00:21:01.644 - 00:22:25.584, Speaker B: So instead of doing the wave functions either along the q or the p coordinate, let's look at them in phase space. And in phase space, I have to introduce this crucial notion of geometry, of translations. So classically, if I make a closed loop in phase space, if I move, let's say, a representative point of the system, let's say along the u vector, then along this v vector, and then I come back. Classically, my system is returns and is absolutely identical. Quantum mechanically, the state of the system receives a phase factor, a phase factor which is actually obtained by the area divided by h bar. So this is actually a wonderful property that actually turns out defines entirely the difference between classical and quantum mechanics. In quantum mechanics, when you do a closed circuit in phase space, you suffer phase factor that is proportional to the area.
00:22:25.584 - 00:24:12.634, Speaker B: Instead of writing a product of translations in this way, and using the vector product to represent the area, I can use complex numbers to represent exactly the same thing. And in terms of displacement function of complex numbers, this, this expression on the right is exactly equivalent to the expression on the left. But I can introduce here the length, the modular square of the length in complex units, and that's a photon number. So the GKP code has two stabilizers which correspond to two translations in the two orthogonal translation in phase space, which have a certain amplitude in this square root of photon number unit. And these two square root of PI is magical in the sense that these two translations, which normally would not commute for arbitrary displacement, do commute, and these two stabilizers will in that space become the identity in the subspace of the code. Now, if you look at this area here, it has the area formed by the stabilizers. It is a four PI h bar, or the equivalent of two action quantum.
00:24:12.634 - 00:25:17.996, Speaker B: Remember, one state in phase space is one action quantum area. So indeed, here we have an area corresponding to two states, which of course leads us to a qubit. But is it really a qubit in the sense of poly operators? Well, if we look at these vectors x, y and z, so the x vector is half the vector of this stabilizer, which is equivalent to I. So x square is indeed I. This z squared is indeed I, if you think of z and x as translation. And y, of course, is also base, the property of y square being I, because you would get here. But now we just do a little bit of nuclear geometry.
00:25:17.996 - 00:26:34.050, Speaker B: If we look at this triangle here, x, z and y, it has an area of exactly this full area divided by eight, which means that it's PI over two h bar, which corresponds to a phase factor I. So we have exactly the algebra of the poly operators here. So this is really wonderful. And this explains how the Clifford operations will be obtained by simply geometric translation and rotation in phase space. Okay, up to now, I have considered the ideal case where the infinite squeezing, in practice, we cannot squeeze the vacuum infinitely. So we have to content ourselves with a state that contains a finite number of photons. So instead of an infinite peak advance for the z and the logical and the plus and minus state, I have a finite peak advance.
00:26:34.050 - 00:27:48.684, Speaker B: Correlatively, the peaks are not going to be infinitely narrow. They're going to have a certain width given by sigma. Here, the envelope, the finite envelope is controlled by delta. And for the code to be optimal, sigma and delta need to be reciprocal with respect to the unit cell translation. So instead of having dots, phase space, red dots, which would be form an infinite grid in phase space. Here I have a finite number of finite dots, but the overlap between two neighboring dots is really so small that the code remains absolutely excellent. What I have plotted here along these ground projections are the states plus and minus z.
00:27:48.684 - 00:28:50.184, Speaker B: And if you do a projection, a marginal distribution along this side here, you will get the plus and minus x states. Now, this phase based representation is very useful to discuss error correction. So our error correction scheme is going to implement the equivalent of two forces, two force fields in phase space. You have the blue force field, which corresponds to these blue arrows. And this force field will have to be, they will sharpen the peak. You see, the photon losses will tend to dilute everything here. And to get us back to the ground state, a big disc in the center.
00:28:50.184 - 00:29:56.766, Speaker B: But by applying an effective force field, this blue field, we will sharpen the peak. Of course, as we sharpen the peak, we make the envelope larger and larger. So we need to implement another force field which corresponds to these purple arrows on the periphery, which will constrain the envelope. So by applying simultaneously these two force fields, these two antagonistic force fields, we will stabilize a finite energy grid state. Actually, we will stabilize a finite energy manifold of two orthonormal. Okay, so that's half of the talk. Now that I have introduced the principle of this encoding, let me now go to the experimental sector.
00:29:56.766 - 00:30:52.244, Speaker B: How do we in practice implement this error correction? So this is done by using a superconducting cavity. So this is the block that we are using in our experiments. The main cavity is cylindrical and corresponds to this red arrow. At the bottom of this cylinder, you have a post here, and you see the post in this kind of perspective view here. So this red cavity is where the logical qubit will reside. It's a high q cavity. It is coupled to a low q cavity here, which corresponds to this blue arrow.
00:30:52.244 - 00:32:01.364, Speaker B: It is low q because this cavity is connected to a, without a circuit by this lung pin here. It's a low q, not because there's internal dissipation. But because this is actually our entropy dump, this low q cavity is going to help us read out the Arrow syndrome in the correction. And this is the, this low q cavity. And this transmission line here will be the way entropy will be evacuated from the I two cavity. And this entropy is essentially processed by the transmon, by a transmon artificial atom, an ancillary cubic, if you want, that will be involved in correcting this IQ cavity. There are a few numbers here that the specialist of circuit QED will recognize.
00:32:01.364 - 00:33:07.604, Speaker B: One photon in the IQ cavity lives for about 250 microseconds. The ancillary qubit is not, these days, is really completely average. It's not really the kind of base qubit that we could make, but it fits the bill here for what we have to do. And there's a coupling between the storage cavity and the ancillar qubit, which is about 20. Then this is the characteristic of the low q cavity. And we can basically read out the information in 1 Î¼s out of this low cube cavity. One very important factor here is the, is the feedback time constant.
00:33:07.604 - 00:34:31.692, Speaker B: We can feedback. So when we read the cavity and we can feedback what we information we get and correct this IQ cavity in a time constant, which is about 300 nanoseconds, a fraction even of the time it takes to read out this transplant. This is absolutely crucial because, as I have explained, quantum error corrections based on the possibility of doing this feedback to explain how we monitor errors and even how we create the state in the first place. I have to explain the fundamental operation, the fundamental gate that made this error correction of the GKP code possible. It's this conditional displacement gate. And without this kind of gate, we could not really create this state. So this is why this gate I call the spiss army knife of this encoding, because with this gate you can do absolutely everything.
00:34:31.692 - 00:35:59.444, Speaker B: You can create those states, you can stabilize them, you can read them out, you do all the going to spend a little bit of time explaining how it works. So in the doubly rotating frame of both the ancillar qubit and the GKP node, the Hamiltonian is just this. So the ancilla qubit is considered as a spin here, hence the sigma z. And here this is the Hamiltonian. We couple the photon number of the cavity to the sigma z of the qubit, and then we drive the cavity. This drive produces a lot of terms, a lot of unwanted terms that we are going to eliminate by eco methods. But there's one surviving term which couples the a and a dagger to actually the field that we create in the cavity with the drive, and which is represented by this alpha term here, which is the coherent state amplitude that we create in the cavity without drive.
00:35:59.444 - 00:36:55.944, Speaker B: So here is how this displacement gate functions. Suppose that I want to take a state in the cavity. And here I have taken a squish state as an example, but I could have taken any state. So real alpha and alpha are the position and the momentum in this cavity. And I'm going to displace this state depending on whether the qubit is in engine. So we begin by driving the cavity and displacing the state. And this coupling here is going to displace and rotate the whether the qubit is in energy.
00:36:55.944 - 00:37:56.674, Speaker B: And you see, we want to get rid of the rotation. So for this clever ecosequence, we can actually get a clean displacement at the end of this sequence. And this is really the key to this conditional displacement gate, a sort of knulling out of all the unwanted turns that is generated by the tribe. And with this gate, we can build superposition of states in the cavity. But we can also, using the gate in reverse, detect a small displacement. We had made a superposition of this quiz state. And now due to some kind of translation error here, this wave function that you create is displaced by a small amount, et cetera.
00:37:56.674 - 00:39:09.204, Speaker B: So with this circuit, using this conditional gate between two PI over two pulses here and weeding out the ancillary qubit at the end, you're going to be able to detect this small displacement. Or more precisely, you're going to actually transform this displacement. You see, you have a sort of interference effect, which makes all the influence of all these peak converge. And we rotate the qubit in the equatorial plane by an angle which is proportional to this displacement. And then reading out the ancilla, we get one bit of information on this displacement. We get, for instance, the sign of this displacement. And just with this sign, we can actually actually, by repeating this measurement over and over, we can actually reposition the state in phase space in the right place.
00:39:09.204 - 00:40:16.314, Speaker B: Of course, in order to be able to do that, you have to calibrate this conditional displacement, this CD gate, very precisely. And this is done by doing basically two opposite rotations in phase space. Depending on the state of the qubit and the interference between these two cycles create a very phase oscillation which we use actually to calibrate the gate. Once we done this calibration, we can actually create, use this protocol where we can actually do four type of feedback loops. That intertwined, and they sharpen the peak along the q direction. They trim the envelope on the q direction. And here we have a mirror sequence, which does the same thing, but in the key direction.
00:40:16.314 - 00:41:28.264, Speaker B: And we repeat this cycle over and over. There's a parameter which is this amount of displacement we do in the feedback loop, which is optimized, which were optimized by simulation when we did the experiment. But now theory allows us to understand exactly how to compute this optimal epsilon. And so here, this result shows the average value of the stabilizers that really increase and attain a plateau. And you see that, you see this period four here in these oscillations toward the ascento. That corresponds to the fact that in order to do a full round of correction, you need to apply these four operations in sequence. And after a few hundred rounds of error correction, you find the mixed logical state.
00:41:28.264 - 00:42:27.654, Speaker B: So it's a random superposition of two logical states, including space. And here I have really given the unit cell of the grid and indicated where the position of the x y m z operator. So here we have a mixed objective state. We have not prepared a state proper, but if we measure at this point here. And by the way, I should say that this is actually a characteristic function. But it's the Fourier transformer, the vignette distribution that I presented before. And if you have a grid in direct space, you have also agreed in reciprocal space.
00:42:27.654 - 00:43:35.714, Speaker B: So this characteristic function contains exactly the same kind of information you would find in a Wigner function. So when we measure at this location x, y and z, we will project the state on the nigga function of the x, y and z operator. And this is what we do here in this expression. So this is the prepared manifold stabilized manifold. And by doing a measurement here on this point, you see, for instance, we find a negative value, which means that we have prepared, actually a minus x logical, and we can repeat the same operation and create x states, y states. And even by teleportation from the ancillar qubit, we can create even the magic state. And this is all done in this original square code that I presented.
00:43:35.714 - 00:44:56.302, Speaker B: There is an interesting variation in this grid state code. You can implement what is called the hexagonal code, in which the direction along x, y and z are actually isotropic. Instead of having two equivalent direction, x and z, and having the diagonal along y, here, the x, y and z directions make an angle of 120 degrees. So this is why, for instance, the x and the y state in this encoding are just essentially the same state, but rotated by 120 degrees. Here I show the difference between the unit cell in the square code and in the hexagonal code. And you can see that now, the three operators corresponding to x, y and z basically have the same length. There's a, there's a certain superiority of the hexagonal encoding.
00:44:56.302 - 00:46:01.048, Speaker B: So these results really are the punchline of the talk. They represent by how much you can correct arrows. And we measure the correction of errors by preparing a certain state, which can be along x, y and z. And then we remeasure sometime later the same operators, x, y and z in the three decay mode where we do not do any correction. And these are the white dots here. And as you can see, with correction, this is what we call step here. You can see a nice separation of the x and z operator measurement, which basically, we essentially double the lifetime of these operators.
00:46:01.048 - 00:47:06.206, Speaker B: We also doubled the lifetime of the y operator. But you see, we start with the severe handicap. And if we go to the hexagonal code, all three operators behave exactly in the same way because of this rotational symmetry. Okay, so I think that I have reached the time. I would like to leave some time for questions and discussion. There's some important point that I want to talk about, and this was realized in Jonathan home group recently. This is the question about what I have presented now is feedback measurement, feedback error correction.
00:47:06.206 - 00:48:39.044, Speaker B: But this code has this wonderful peculiarity, which was discovered independently, Jonathan Holmes Group and in Steve Jobin Group, that actually you can concatenate the operations that I had mentioned, these feedback operations here in the protocol that I have presented, and completely the need for measurement feedback. All you need is to reset periodically the ancilla. More precisely, you can contact an operation which sharpens the peak in tube and the trimming in p. And resetting the ancillary has exactly the same effect as going out of the cryostat and actually applying the correction. So this is an incredible advantage of this code. Not only you can correct all errors and all the possible errors of the many folder, but you can do it autonomously, which, if you think of many, many logic or qubits, saves a lot of values. And on this note, I would like to show my conclusion.
00:48:39.044 - 00:49:32.900, Speaker B: Slider. So, I think that this GKP code has allowed us to simultaneously correct all errors. So it's not just that we collect one or two errors among all the errors, we correct all errors. Of course, all arrows are corrected to first order. So we don't have a qubit that lives forever. We have a qubit that lives longer we longer than if we don't do error correction. That is, there's this question of breakeven, breakeven point, which is whether we can, with this code, do even better than the best encoding in the cavity.
00:49:32.900 - 00:50:30.634, Speaker B: So right now we of course do better than without error correction, keeping the encoding the same. But the question of breakeven is the following. So can you beat with your error correction scheme, which is always going to be more complicated than the simplest physical qubit, can you beat the Cohen's lifetime of the simplest non correctable encoding? And the answer is, up to now, almost. So we have new results in the lab which indicate that we are very close to do it. But I think this is ongoing progress. But it will be nice to have all errors corrected and go beyond the breakeven point. This has never been achieved.
00:50:30.634 - 00:52:00.936, Speaker B: A very interesting direction is of course, the gates between two logicals. And for instance, the CNoT gate is particularly appealing with GKP, because it's a simple gaussian operation, which actually we know how to do in the real knob amplifiers. So we have already built Josephson junction circuits that do this protocol. But of course we have to apply this protocol and hardware to the GKP encoding. And then there is this fabulous direction of error correction feedback, which we also doing right now. So this is going to help tremendously, actually caused breakeven tone. And I don't want to steal from the panel discussion, but maybe a very important point here is that in my opinion, the great advantage, as an experimentalist of the bosonic code, is that they constitute really extremely hardware efficiency.
00:52:00.936 - 00:53:47.844, Speaker B: There's demissing here, first layer of error correction. If you think of a stack of error correction layers, this is a great layer because it doesn't require much overhead. So there are articles, and here I'm quoting the article of Shoti on the advantage of this efficient first layer made of GKP encoding. Probably on the upper layers, you will need something resembling the, the surface code or the color code. But to be able to, in the first stage, to arrive at the level of a very small error rate and high fidelity with the minimal hardware is very, very important. Because if the first layer, you need something like 50 qubits per logical qubit, that is a tremendous barrier, a tremendous experimental barrier to implement multilayer quantum error correction. So on this note, I'd like to thank you for your attention, and I think we can start the discussion.
00:53:48.904 - 00:54:31.554, Speaker A: Great, thank you, Michelle. That was a very thought provoking talk. So let's see if there are any questions. So while people are please post in the in Q and a, or chat if you have a question, but. Okay, so I see that there's a question in q and a by thoth mang. He says you briefly showed the creation of a magic state, but can you say more about how you can perform non clifford gates on this platform to complete a universal gate set?
00:54:33.834 - 00:55:48.120, Speaker B: Yes, I think we answer this question better than I will be able to do, but yes. So this magical state that we created was done by teleporting a state in the Ansella and mapping it into the oscillator. So that doesn't belong to the kind of operation that would be done alternately in this encoding. But there are ways to actually create the magical state which would be better than in the surface code and inside the bosonic codes. There are opportunities for or creating magic states and magic state distillation that is more efficient than with the traditional register encoding. Maybe, Shruti, you would want to answer this question.
00:55:48.312 - 00:56:48.560, Speaker A: Possibly we can get to it once we start the panel. But actually, before we start the panel, can I ask a very basic question, because I think that this may be on people's minds. So right now you were saying how to encode a qubit in the microwave in this cavity mode. So in the excitations in the cavity. But what is the architecture that you would be thinking of when you're storing multiple qubits? Is there a trade off in terms of how accessible the qubits are and how much you can operate on them or get them to talk to each other? So how exactly do you think about organizing this architecture and how do you get there? Get interaction?
00:56:48.592 - 00:58:09.544, Speaker B: Yes. So let me first say that Jonathan Holm is implementing this kind of error correction with trapped ions at UTH, and I'm sure he will have a lot to comment on in the panel discussion. I think this question of architecture will, when you think about multiple logical qubits, will play out quite differently in the ion and the superconducting circuit community. So I don't want to speak too much in general, but I can give you some indication of the way it would be done with the superconducting qubits. With superconducting qubits. In this 3d architecture that I have presented, what you do, what you create is an array, either 2d or 3d array, a partly 3d array of cavities. And this has been shown, for instance, that this possibility has been shown by David Schuster at Chicago.
00:58:09.544 - 00:59:36.754, Speaker B: And in this kind of architecture, you have sufficient room, I would say, between the cavities for the access control wires of the ancillary and without. So there's not, in my mind, there's not, right now implementing, let's say, 100 cavities, let's say ten by ten array of type of cavities I have shown would be rather straightforward. What is difficult is to assemble all the control lines and all the control electronics necessary to service all these signals. This is really, right now, I think, for the groups that deal with these cavities, the part that is the most daunting, the machining of the cavity itself, the arrays of cavities, are not too much of a problem. But in terms of controlling the multiplicity of signals that have to, that have to reach all the cadities, I think is the challenge for academic goods.
00:59:39.814 - 00:59:51.814, Speaker A: Well, thanks. Thanks very much. This is a fascinating subject. So we have a very distinguished panel who represent expertise from various points of view on this subject. So.
