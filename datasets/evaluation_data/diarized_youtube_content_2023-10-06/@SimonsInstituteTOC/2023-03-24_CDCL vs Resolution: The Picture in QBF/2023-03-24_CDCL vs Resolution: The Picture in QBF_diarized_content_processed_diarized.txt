00:00:00.200 - 00:00:09.334, Speaker A: Benjamin Boehm from Friedrich Schiller University of Jena and talking about cDCL versus resolution in QBI.
00:00:09.454 - 00:00:55.434, Speaker B: Yeah, thanks very much. So this is based on joint work with Olaf Beierstorff from EnA in Germany, not to be confused with Vienna and Austria, and Thomas Beidel from Vienna and Austria. We already heard a talk today about QBF, where we have seen what is the connection between QBF and circuit complexity. And now we are interested in QPF solving in terms of QCDCL and QPF proof systems that are based on resolution. Luckily, I don't have to explain too much about QPF because we already heard that. So let's just make a quick reminder for you. So we are dealing with quantified Boolean polymellas.
00:00:55.434 - 00:01:43.634, Speaker B: Each formula consists of a a prefix that are all quantifiers, and matrix that is just a propositional formula in CNF. And we want to find out if our formula is false or true. And if it is false, we want to return a reputation. And if it's true, we want to get the opposite of a reputation, I would say is a verification. Okay, so we also heard about QP approved systems before, but we only, I think we only defined Qu resolution. So let me start with queue resolution, because this is naturally the first one you would define. But first let me say that in our settings, I said here we want reputation or verification.
00:01:43.634 - 00:02:29.384, Speaker B: In our setting, we will only concentrate on false formulas and refutations because verifications work a little bit differently but are a little bit more complicated. So for our setting here, where we want to find separations and lower bounds and so on, it's enough to only consider false formulas. But keep in mind that our formulas might also be true in general. Okay. And for our work here, we consider three refutation proof systems. The first one, Q resolution, or short q res, which was introduced in the nineties by Kleiner, Kapinsky and Flugel, this is, just, as you know, the extension of q of propositional resolution. And you have already seen this resolution rule.
00:02:29.384 - 00:03:10.574, Speaker B: I don't have to explain this here. However, here in Q resolution, we have this slight restriction that the x, our pivot, has to be existential, and CRG should be non tautological. And we have this reduction rule, as you already seen, that we can just get rid of the u if there are no existential literals, right, of u in this clause, C or U. And as you already know this, I would say reputation is just a derivation of the empty clause. So we want to get the empty clause somehow. And there are two more systems, or even three. But we only consider the first two systems.
00:03:10.574 - 00:04:06.234, Speaker B: The first one here is long distance q resolution, or short LDQ resolution, introduced in 2002 by Chang and Malik. Now, I won't explain this in detail how this is defined, because it would take too much time. Just let you know that it is basically like hero resolution, but it allows some certain resolution steps that were forbidden before. But for this talk, it's not crucially important to know what these extra rules are. And yeah, you've already seen Qu resolution introduced by Angela 2012, which is just Q resolution. But we are also allowed to resolve over universal literals. And you can also combine these two systems into this long distance QU resolution, or LDQ plus 40.
00:04:06.234 - 00:04:40.954, Speaker B: Okay, now you've seen how our reputations might look like. Here's the simulation order of these resolution based QPF systems. So the weakest one is this, qRs. Pretty natural to see that this weakest one, and then LDQ, rest and Q URis are. I'm not sure if it's correct to say they are equally strong, but they're incomparable. But they're both stronger than qres. And the strongest one is this LDQu plus res.
00:04:40.954 - 00:05:33.824, Speaker B: Now you know how your reputations might look like on a question. How can we obtain such a reputation? And luckily, in the first talk today, we also heard about CDCL. And we can just lift CDCL to QCDCL, which is the QBF case for CDCL, which is one of the main, not the only one, but one of the main paradigms for QBF solving. And I've created this little picture here. So QCDCL works similar to CDCL, but there are some slight differences. So maybe, let's see, you start up here. You have your Q, QPF or QCNF, QPF and CNF.
00:05:33.824 - 00:06:07.164, Speaker B: You check if at the beginning if it is falsified or satisfied. So you check if your matrix is falsified or satisfied. Naturally, this should not be the case at the beginning, but it will be important in later runs. So let's say it's not falsified and not satisfied. So we check if there are unit clauses or unit terms. So that's now new that you also check for unit terms, because you need terms for qbs. The term is just the opposite of a clause.
00:06:07.164 - 00:06:42.984, Speaker B: And if there are any unit clauses or terms, you do unit provocation. And if not, you make a decision. And then you go up here again and check again. And at some point you will either falsify or satisfy your matrix. If you falsify it, you just learn a clause like you know from CDCL. If it is the empty clause, then you're done, because your QPF is now false. If it's not empty, then you can learn this clause, you can add it to your matrix and backtrack and start over again.
00:06:42.984 - 00:07:59.514, Speaker B: Some crucial difference in QCDC is that if your matrix gets satisfied, and it doesn't mean that the whole formula was true, because might be the case that there is a there are false qbfs where you can satisfy the matrix, but they are false because of the quantifiers. So when we satisfy the matrix, at some point we instead learn a terminal, and only if this term is empty, then it is true. Otherwise we also add this term and do backtracking. But again, we only concentrate on false formulas. So this left side here is a little bit more important for us. Now, what do we know about the connections between QCDCl and resolution based systems so far? So as I think many of you know, that DPL corresponds to tree leg resolution, because here you get these decision trees, and if you flip them, you exactly get tree lag resolution proofs. Then in the SAT case and CDCL from cDCL, you also have seen that you can extract resolution refutations.
00:07:59.514 - 00:08:27.958, Speaker B: But a surprising result from 2011 showed that the other direction is also true. So you can basically extract CDCL runs out of a given resolution proof. That's pretty crazy, I would say. So. Therefore, you could say that CDCL, if you interpret it as a, as a proof system, is equivalent to resolution. And now we simply ask the question for the QPF case. Yeah.
00:08:27.958 - 00:10:00.004, Speaker B: What is the connection between QCDCL Q resolution, or QCDCL and LDQ resolution? The only thing we know so far is that we can extract LDQ rest proofs out of QCDCL, because this was the whole purpose of defining LDQ rest to formalize QCTCL a little bit. Ok, so here you can see at which point in this whole graphic, this whole algorithm, we can extract these proofs. This is exactly here. When we learn a clause, there we can, you already know that in CDCL you can extract resolution proofs, and here you extract LDQ rest derivations of these learned clauses. And at the end you have the empty clause, and therefore you get the derivation of the empty clause, and you can stick together all these derivations and get one big refutation of your complete formula. Now, what can we say about QCTZA versus resolution coming to this question? Now, that was the first result of our paper from 2021, and we've shown that actually QCDCL, the classic QcDCL as we know it, and q resolution are incomparable as proof systems. That means access separations in both directions.
00:10:00.004 - 00:11:00.460, Speaker B: However, we can slightly modify this QcDCl, which I will explain later a bit more in detail. And then this modified version of QcDCl is equivalent to q resolution. Now, if you think about it. So I said that you can extract LDQ rest proofs out of QcDCl, and LDQ rest is a stronger proof system than qrs. But QcDCl cannot even simulate QRs itself, which is the weaker one. So why is this the case? What is the weakness of this classical non modified QCDC? Why does it not work to simulate Q resolution? Now, I won't, I have not the time to explain it in detail, but this was also from 2021. From our sad paper, we have shown that there exists a lower bound technique.
00:11:00.460 - 00:11:58.034, Speaker B: So, not only one lower bound, but a whole technique of classical QCDCl, at least for a particular class of formulas. Like I said, I won't explain this here, but the thing you should, or I should point out, is that this technique exploits the fact that decisions need to follow quantification order. I think this is something I haven't talked about before. So, when you make a decision in classical, in the classical setting, these decision steps have to follow the quantification order. That's what is done in practice. And, well, this gives us this weakness for Q resolution. How can we modify QCDCL to make it equivalent or as strong as q resolution, long distance q resolution, and so on.
00:11:58.034 - 00:12:40.462, Speaker B: So, our purpose is to find out if QCDCL can, theoretically, as a proof system, reach the strength of these proof systems. I have been simplified before. And for this, we apply three kinds of so called policies, which are just these modifications to QCDCL. So these are decision policies, reduction policies and propagation policies. I will go through all these, how they work and where they work. Let's start with decision policies. Now, this happens here, of course, this is the only point where we make decisions.
00:12:40.462 - 00:13:16.892, Speaker B: Right after, uh, not finding any unit clauses, we have to make a decision. And like I said, in the classical setting, we have to quantification order. However, this is not good because of our lower bound technique. So, idea is just to allow arbitrary decisions that do not follow quantification order. It's as easy as that sounds. Now, we have these, these two policies. The first one level, which is just level order decisions, or decisions that follow the quantification order.
00:13:16.892 - 00:14:10.448, Speaker B: And the other one, any, or you can use any order as decisions. And then from our original proof system, QCDCl or algorithm, we get two the first one qCDCLav, or which is just our classical, but we just call it qctcl dev.org. Now to see policy is included and the other one QCTCL anyord. Now, unfortunately, this is not enough to simulate q resolution proofs. What we also have to do is we have to change the way we reduce literals. And we here are looking at reductions during unit propagation. So of course there are other points where reduction can be applied.
00:14:10.448 - 00:15:05.394, Speaker B: For example, here when we learn a clause, and of course when we learn clauses, we also reduce universally. But here we only care for reduction during unit propagation. For this, I should explain how unit propagation and qcdcl works. So you have already seen how it works in cdcl, just classic you have a clause, and if you falsify all literals except for one, then you have to set this one remaining literal to true. And this is the unit propagation. Qcdcl is a little bit different, but similar. So if a clause becomes unit under the current assignment you made in your trail in qctl, and after reduction, universal reduction, then you have to satisfy this clause.
00:15:05.394 - 00:16:10.074, Speaker B: For example, let's consider this clause here, x or u or y, and your prefix is, let's say x is x for u with x is y, and you just have assigned y to zero. Then if we apply this assignment to c, then you get this x or u. This is not particularly a unit clause, but a qcd. It works as a unit clause because you can simply reduce this u because nothing is right of u. So therefore you have to set x to one in the setting here. So this is how unit propagation works in QcdCl compared to CdCL. However, there's a little downside with these reductions during unit propagations, because all these reductions are kind of uncontrollable if you want to simulate q resolution with it, because they all pile up during the clause learning all literals, you reduce your unit propagations.
00:16:10.074 - 00:16:54.924, Speaker B: Come back again when you learn a clause, and they can prevent further resolution steps. That's not good. Therefore, we just forbid reductions at all and define these two policies that affect these reductions during unit propagations. So here, the first one is just a classic one, all red. That means always use reversal reduction in unit propagation. In the next one, no red, just use plain unit propagation s and CDCL. Now we again double the number of our QCDCL variants we have defined, and now we get four of them for each combination.
00:16:54.924 - 00:18:13.844, Speaker B: Once again, the leftmost here is the classic one where we started with and this is the most modified one. Now we can make this interesting result here. If we take this, this one here with any or that means arbitrary decisions and no reductions during unit propagation, we can show that this particular variant of QCDC as a proof system is equivalent to q resolution. So now we have succeeded to reach the strength of q resolution via at least some modified version of QcDCL. Well, that's pretty nice, but we've seen at the beginning the q resolution is the weakest of these systems. So why not go further? Maybe we can extend it to long distance q resolution. So how do we gain the strength of long distance q resolution? For this we have again go back to the reductions, and for LD qrs proofs, we need at least some reductions during unit propagations, but they still need to be controllable.
00:18:13.844 - 00:19:06.894, Speaker B: The idea is that we just choose which literals are to be reduced and which not. That means sometimes we can reduce, sometimes not. This is what this new policy, this new reduction policy, any red means. That means we get two additional systems here with any red reaction policy. And with that, unfortunately, we cannot, it's not enough to modify, to simulate long distance qrs proofs, because we have to modify long distance itself. I cannot explain this here in detail because this would take too much time. But just trust me that you need to modify also these long distance proofs a little bit.
00:19:06.894 - 00:20:09.860, Speaker B: And for this, we define this new model here, this new system, modified LTQrs or MLT qures. And an important result here is that this is not just defined on the fly because we just wanted it, but all previously defined QCDCL variants. That means all of these and including the classical QCDCl, are still p simulated by this MlDQrs. So basically, you know, you do not actually need this lDqrs anymore. You can just take this modified version, which is a slightly restricted version of that, and then we can get to the next result. We take this QCDCL with arbitrary decisions and arbitrary reductions. This model is able to be to simulate these MLDQ resolution proofs.
00:20:09.860 - 00:21:01.074, Speaker B: Therefore it's equivalent as a proof system to this MLDQRs. Okay, are there any questions so far? I don't know how much time I've left. Okay. Okay, so what I, what we have seen so far, we have, yeah, characterized three lag resolution via DPL. We have characterized resolution via CDCL as was already known. We could not characterize Q resolution with the classic QCDCL, but with a modified version of that. And we could even do this for this modified long distance qrs and now the remaining system we want to look at is qures.
00:21:01.074 - 00:21:56.326, Speaker B: And for this we have to look at the last kind of policy of modification policies for QCDCL, which are propagation policy. Now, we also looked, we already looked at propagation, but now we want to change the propagation itself. So our aim is to find a QCDCL model that characterizes qures. So in qures we are not only allowed to resolve over existential variables, but also over universal ones. What we have to do here, we have to allow unit propagations also over of universal literals. This was by the way, inspired by a work by Friedrich Slavowski last year, and he also implemented this. Now we get two more policies.
00:21:56.326 - 00:23:16.964, Speaker B: The first one, which we call xiprop, which means that unit propagations, at least we are clauses, are only allowed for existential variables and all prop, which means that unit propagation can be done for existential and universal variables. We again double the amount of QCDC variance. But I have to say that, okay, we have twelve of them now, but not all of them make sense, and not all of them are interesting. So we can ignore some of them. So for example, it doesn't make sense to combine all reduction and all propagation as all red and all prop, because you cannot propagate universal literals and reduce them at the same time. Okay, so from these twelve systems, we look at this one, and we finally come to the last main result here, which says that this, this variant, with any reduction, with arbitrary decisions, no reductions, and potentially universal propagations is equivalent to Qu resolution. So we've also characterized queue resolution now.
00:23:16.964 - 00:24:03.364, Speaker B: Okay, so on the last slide. So this is another overview of all the, I would say, interesting systems we have looked at. I haven't talked about every connection here, but these are all included in our papers. Just to point out, this one here is the one that characterizes this MLD qrs, this one characterizes qures. This is the classic QCDCL. And what I also want to point out is from all of these, you see many QCDCR variants here, and from all of these variants, only one variant is really used in practice and it's implemented. This is that one.
00:24:03.364 - 00:24:35.484, Speaker B: You see, it's lots of stuff which could be better variants, but yeah, and I want to, therefore, I want to end my talk with a appealing to all the practicians out there who work in QBF and say them that perhaps the most popular algorithm is not always the best one.
00:24:45.844 - 00:24:46.744, Speaker A: Thank you.
00:24:47.044 - 00:24:47.784, Speaker B: Question.
00:24:52.164 - 00:25:18.008, Speaker A: So I have a question. Are there specific? I mean, you mentioned what people have done in actual you know, in implementations, are there particular pieces, you've got three different components and slight variants in each aspect. Are there particular components that you think are going to likely be the most productive in terms of adding to what people have implemented?
00:25:18.096 - 00:26:24.234, Speaker B: Well, what we, at least in an experimental setting, tried to implement. So Thomas did this. Was this any order? And we found out that actually on these formulas for which we use photo separation, it turned out that you really see these separations also in experiments, and there was at least one. So we have a different version of that, but there was at least one variant of this, any order that also was better, even on benchmark formulas than the classic QCTl. So yeah, I would say that at least these arbitrary decision orders might be really a good idea because we really see that otherwise we have this lower bound technique and the other ones are not so clear. So for example, I mean, when we say any reduction, so you can choose when to reduce and when not, it's not clear how you choose that in practice. But yeah, at some point you should think about this because in theory, you know, that's better.
00:26:24.394 - 00:26:32.102, Speaker C: So doesn't the same, there is some non determinism how to choose the next decision.
00:26:32.198 - 00:26:41.886, Speaker B: Yeah. Right. That's why we, we tried different, different versions of any order. So we also tried some restricted versions of any order where it's not really.
00:26:41.950 - 00:26:44.754, Speaker C: Any order, but some heuristic is.
00:26:45.934 - 00:26:53.594, Speaker B: Yeah, yeah. Dictating the order, but it's, it's more liberal. So that's important.
00:26:58.674 - 00:27:07.494, Speaker C: So you said that from this QCDCL runs you can extract LDQ proofs. That's the original. So those runs do not use term learning, right?
00:27:09.674 - 00:27:32.750, Speaker B: No, we only concentrate on, yeah, we only concentrate on clause learning, but, so when you're, when your formula was false, you might have learned some terms, but you can ignore them because if it turned out to be false, you never use these terms in your verification. So they are still there. You have learned them during your algorithm, but during your runs.
00:27:32.782 - 00:27:36.394, Speaker C: But they don't shorten the reputations.
00:27:38.494 - 00:27:55.054, Speaker B: They do, they shorten the trails. Well, learning terms is important. It can also help for, it can be helpful for boss formulas as well, but they don't turn up in the reputation.
00:27:56.714 - 00:28:08.394, Speaker C: So even if the algorithm is running on a false formula and is learning terms along the way, you can still extract an individual, is that. Yes.
