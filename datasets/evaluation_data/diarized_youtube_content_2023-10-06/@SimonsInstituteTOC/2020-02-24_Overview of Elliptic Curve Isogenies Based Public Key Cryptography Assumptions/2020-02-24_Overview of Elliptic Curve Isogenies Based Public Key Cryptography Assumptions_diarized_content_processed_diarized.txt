00:00:00.400 - 00:01:07.760, Speaker A: Session, which will be dedicated to isogenous. And our first speaker is David Malcolm, presenting an overview of isogenous by Lithuania based public assumptions. All right, thanks, Elena. So if you look on the schedule, there are these two isogeny talks in the morning. In principle, I'm supposed to talk about the assumptions and Chloe Martindale is supposed to talk about the attacks, but you can't really talk about the assumptions without also talking about the attacks. And so we've decided to coordinate together and present the material in some way that we see best. So I may not strictly stick just to the assumptions, but I think that isogenies are, despite appearances, rather the perfect talk for this kind of a workshop, because they do involve quantum algorithms, and surprisingly, they do involve lattice algorithms as well.
00:01:07.760 - 00:01:55.388, Speaker A: So you get a little bit of both, even though it's not, strictly speaking, any sort of lattice based cryptosystem, you do need to pull together all of this material and all these ideas from different areas of mathematics and computer science and quantum and all of these things in order to make progress in this subject. And so that's one of the reasons why I like it so much. So without further ado, let's try to get going here. I start with a small presentation about what elliptic curves are. I hope most people know this already. My main reason here is not to teach you about elliptic curves. If you don't already know that, that would be very difficult.
00:01:55.388 - 00:02:29.454, Speaker A: But, you know, just to fix the notation and to emphasize some of the ideas that I'm going to need later. So, for our purposes, an elliptic curve is going to be a curve defined by a short weierstrass equation, something that looks like this. Y squared equals x cubed plus ax plus b. All elliptic curves over the reals look like this kind of blue curve, or something very similar to it. I want to highlight that there's a group law. The group law is usually defined geometrically. You take two points, you draw the secant through them, it intersects the curve and a third point, you flip the curve around the x axis.
00:02:29.454 - 00:03:18.574, Speaker A: That gives you the sum of the two points. This geometry is sometimes useful when trying to define isogenetics, as you need to know sort of how the arithmetic comes from that geometry. There is a pointed infinity, but it is not one of the blue points. The pointed infinity is sort of not drawable in the sort of regular xy plane, but it is the identity element for the curve. So it's rather important from the point of view of understanding the curve as a group to know that the where the identity element is, it's this point at infinity. So what are isogenes? Isogenes are algebraic maps between elliptic curves that preserve the group structure. So we ask for a function from one elliptic curve to another elliptic curve.
00:03:18.574 - 00:03:43.266, Speaker A: We ask for this function to be algebraic. In other words, each coordinate is a rational function. These are two variable rational functions. Because you have x and y, you have two variables on elliptic curve. So you're going to have two variables, rational functions, meaning just quotients of polynomials, but in two variables, and you have two of them, you have two coordinates, right? Because you have the x coordinate and the y coordinate as output. So you need two rational functions. And we ask that it be a group homomorphism.
00:03:43.266 - 00:04:18.746, Speaker A: Okay, so this is, we can take this as a definition of an isogeny. I'll give some examples of these later. I'm not going to go sort of too much into them. Isogeny based cryptography has a reasonable history by now. The first public sort of appearance of cryptosystems based misogynist literature was 2006. We have some papers from 2006. There is a hash function proposed by Charles Gordon and Lauter, and there are public key crypto systems.
00:04:18.746 - 00:05:03.048, Speaker A: There is one by Kovanes, also proposed by Rostovstev and Stobinoff, essentially the same cryptosystem. Those were published in 2006. Although if you look on Kouvanius paper, he has a paragraph of the beginnings stating the origins of his scheme were actually in 1997. He came up with this scheme in 1997, but never published it until 2006. So, CR's, nowadays we call it CR's by the initials of the three authors, is one sort of flavor of isogeny based cryptography. And another flavor of isogeny based public key cryptography is what we nowadays call SidH, which stands for super singular isogeny. Diffie Hellman.
00:05:03.048 - 00:05:58.034, Speaker A: So this is a second scheme that was invented by myself in Luca DeFeo in 2011. And then more recently, we have a third scheme, c side, CSI, DH, invented by castric Lange, Martindale, Penny, where are you? Lorenz? Somewhere over here, Rennes, who I don't think is here. And so I like to use a simple Venn diagram to explain the relationship between these things. So there's these sort of schemes that use complex multiplication. There's the schemes that use super singular curves, and there's c side, which is in the middle, that uses both. And this is not a value judgment, this is just a sort of statement of facts as to where each, where each of these sort of schemes sits. Okay, all right, I'll go through briefly, some examples of isogenes, how to construct them.
00:05:58.034 - 00:06:55.124, Speaker A: I think that for the purposes of this talk, it's enough to understand that isogenes are in fact group homomorphisms, because they are group homomorphisms, they have a kernel. Here it is. That's the standard definition of a kernel in group theory. And one thing you can prove about isogenes using geometry, using the geometry of the curve, is that whenever you have a finite subgroup of an elliptic curve, you can essentially, you can mod out by that finite subgroup, and you can get an isogeny which represents the quotient map. So you can always take, given a starting curve either and a kernel k, you can construct a projection map from e to eMod k. And there is an elliptic curve structure on eMod k like e modulo. Any finite subgroup gives you an elliptic curve, and the projection map can be interpreted as an isogeny and modulo some details.
00:06:55.124 - 00:07:36.154, Speaker A: And by the way, there's lots of simplifying details. There's lots of simplification of details going on in this talk. For example, you know, elliptic curves don't all look like this in characteristic two, right, and so on. But, you know, I hope that you can forgive me for these oversimplifications. So, you know, sweeping a lot of details on the rug. For every such choice of curve and finite subgroup, there is essentially a unique isogeny that has, that starts from that curve and annihilates that kernel. So eMod k is essentially unique, and the isogeny, the projection map is essentially unique.
00:07:36.154 - 00:08:17.068, Speaker A: Isogenes have a degree, which can be, it's defined as the degree of the algebraic map. In the setting of finite subgroups and kernels, that degree can be taken as just the size of the kernel. So however, the cardinality, it's a finite subgroup. So the cardinality of that kernel, whatever it is, that's a finite number, that's your degree. So that's the degree of the isogeny. We have a set of formulas called Veilleux's formulas, invented by Velu, of course, that construct this isogeny for us, that give us equations for this isogeny. So if I have an elliptic curve and I finite subgroup, then I can use velou's formulas to get an equation for this isogeny.
00:08:17.068 - 00:08:32.024, Speaker A: And that doesn't sound too hard. So you can just do it. And here is an example of Velu's formulas. This is not the full formula. This is just like a special case. This is the special case where the kernel has two elements. So you take an elliptic curve, you take a finite subgroup.
00:08:32.024 - 00:08:50.556, Speaker A: Suppose your finite subgroup has two elements. Of course it has to be a group. So p plus p has to be the identity. So there you go. P plus p is the identity if you go back and remember your group law. So p plus p means the secant line through p and p, which means the tangent line through p. And the third point has to be on.
00:08:50.556 - 00:09:19.880, Speaker A: This tangent line has to be the point of infinity, which means the line has to be a vertical line. And your curve is symmetric around the x axis. So this vertical line has to sort of cross the curve at a point where y is zero. So that's where the group law comes into all this. You reason all this out and you realize that, okay? So in order to have a subgroup of size two, you need, of course you need the identity element and you need a point of order two. And a point of order two has a y coordinate equal to zero. And so that's what this equation tells you, is that the y coordinate of the curve is zero.
00:09:19.880 - 00:09:53.140, Speaker A: Okay? And then under these conditions, if you run this sort of expression through Veilleux's formula to get the corresponding isogeny with this kernel, then these are what you get. So this is what pops out of Veilleux's formula. Obviously, this is not like super simplified. You can simplify this more. Like this a, this a, you can simplify this a little more, but this is like the raw, um, expression that you get out of a loose formula. Okay? And it's not too bad, right? You see that? You know, well, there's, there's a, you know, rational function here. There's a rational function here.
00:09:53.140 - 00:10:25.134, Speaker A: You can kind of, you know, xp is the point coming from the kernel, right? So you see all these things here. Everything here is perfectly, you know, sort of elementary. And, you know, understandable, you can do the same thing for larger degrees, right? So let's take, take an arbitrary, let's take an isogeny of degree three, which means a kernel of size three. So you have a group, a subgroup of size three. Of course, the identity has to be there. And then once, in order to have a group of size three, you need like p and minus p. Basically, that's the only way to get a group of size three.
00:10:25.134 - 00:10:55.924, Speaker A: And p plus p plus p is equal to zero. And so here you do some other geometric calculation. You realize that a point of order three has to be like an inflection point on the curve. It has to be a point where the second d y, what is it? D squared y dx squared equals zero. It has to be one of these inflection points for similar reasons as to why the point of order two has to have y coordinate zero. So then you do the differentiation. You find that here's the algebraic condition for being an inflection point.
00:10:55.924 - 00:11:15.652, Speaker A: So here the y coordinate is not zero, but it's just the square root of whatever this cubic is. And you run these numbers through Velu's formula, and here's what you get. And again, it's not super complicated. It's. There's a rational function here. There's a rational function here. There's more terms here than in the previous case.
00:11:15.652 - 00:11:44.934, Speaker A: There are more. Here's. Here you have a couple of terms. Here you have like three terms and fractions and so on. So these things get more and more complicated as you go on. And so the fact that these get more and more complicated is sort of one of the things that you have to work around when you're doing any sort of non trivial computations with isogenes. So when you want to compute with isogenies of large degree, you cannot do it head on.
00:11:44.934 - 00:12:18.054, Speaker A: And sort of, most of computational research in isogenes is sort of about devising ways to get around this problem where you can't compute directly. Isogeny is a very large degree. What's going to happen is that the complexity of the sort of formula blows up roughly according to d cubed, right? Maybe it's d squared. I don't know. It's something like that. It's, in any case, infeasible when d is large. By large, we mean cryptographic size, 100 digit numbers, or something like that.
00:12:18.054 - 00:12:51.774, Speaker A: So you can't do it directly. You have to use either tricks to do it, or you have to design your scheme to take this into account or something along those lines. Here's an example of what I mean. So, in Sidh, which is the scheme that I published with DeFeo in 2011, what we do in Sidh is we use isogenes of large degree. But those large degrees are special. They're not like random numbers. They are powers of two or powers of three or powers of some small prime.
00:12:51.774 - 00:13:31.966, Speaker A: And when you have a group which is a kernel group, a kernel, which is a cyclic group of size two to the e for some power of two, then you can sort of factor the group, not directly as a direct product, but factor in terms of, like, in group theory terms, right. As a sort of extension tower. Right? Everything is abelian. So there's nothing, there's nothing like, you know, hard group theoretically going on here, you just factor it as a tower of sort of extensions of degree two. And then each of these extensions corresponds to an isogeny. And each of these isogenes has degree two. And a degree two isogeny is easy.
00:13:31.966 - 00:14:09.766, Speaker A: It's like two slides ago there, that's an isogeny of degree two. So you can do that, and then you just compose all of these isogenies and you have the overall isogeny of degree two to the e. Now, if you try to write that composition out as a single rational function, it would be very hard. You would get complex, like plugging a degree two expression into another degree two expression, and doing that over and over again rapidly sort of gives you something unmanageable. But you could evaluate it without writing it down as a single rational expression, and it's fine. So then you just evaluate the isogeny that way. So that is how you get isogenies of large degree.
00:14:09.766 - 00:14:35.116, Speaker A: Now, these are special degrees. They're degree two, two to the e. You can't do all of the isogeny this way. Um, this is all you need for Sidh, right? So here is a, um, quick, I guess, very quick overview of Sidh. I described the scheme so that then the assumption makes sense, right? If I'm gonna talk about the assumptions that you use in public key cryptography. No, but I know I'm only gonna talk about SidH, CSI and CR's in this talk. I'm not gonna talk about the hash function.
00:14:35.116 - 00:15:18.828, Speaker A: But the title says public key cryptography, so I'm only doing public key cryptography here. All right? So in Sidh, the scheme is sort of easily summarized in a small diagram that looks like this. Basically, you start with a curve that's like a public parameter, and then your secret is going to be the kernel. So each party, Alice and Bob, it's a key exchange. So Alice and Bob each choose like a kernel as their secret, and then they publish sort of the quotient of the original curve by that kernel as their public key. And when they want to do key exchange, each one sort of mods out by both kernels. So Alice knows a and Alice knows eMod b.
00:15:18.828 - 00:16:01.842, Speaker A: So theoretically, Alice should be able to compute like eMod B mod a or something like that, eMod B mod a, which would give you e modulo both of them, right? And Bob does the same thing with the B's and a's switched. And so that gives you a key exchange which looks, at least at a very zoomed out level, looks a lot like diffie Hellman, right? In the details, it differs by quite a bit, of course. And this is an oversimplification. Again, there are certain things that you have to do in order to actually make this work. For example, in order for. So let's say you're Bob and you have eMod a and you have b, right? Well, it's not enough just to do eMod a and mod b. That doesn't make sense.
00:16:01.842 - 00:16:29.424, Speaker A: B is not a subgroup of eMod a. You need eMod a modulo phi a of b. You need to transport b through Alice's isogeny. But that was supposed to be secret, so you can't literally do that. So what you have to do is Alice has to give extra information. Essentially, she has to give the matrix representing her isogeny on Bob's sort of space, kernel space, the space of possible kernels. So you have to give this extra information.
00:16:29.424 - 00:17:11.292, Speaker A: And there are papers that do exploit this extra information to attack, not Sidh directly, but various versions of S. Well, there's a paper that attacks it with an active attack. There's the Galebraith GPST paper that attacks it directly. So there are some attacks that you can do if you exploit that information. But for lack of time, I'm just gonna cover the very basics. So the basic attack, the sort of the foundational hard problem, the problem that sort of underlies everything that must be secure. That must be hard in order for Sidh to be secure, is the problem that I have listed right here.
00:17:11.292 - 00:17:55.844, Speaker A: Given e and eMod a, find a. So you're given e and you're given the sort of the quotient curve e modulo some secret kernel that you don't know. You want to find that secret kernel. And here, the fastest known algorithm is pretty easy to explain. What you do is so you recall that to get from e to e, mod a is a sequence of two isogenes. And so what you're going to do in order to attack this scheme is you're just going to walk along all the possible two isogeny paths until you get from here to there. Okay? Now if you started from here and tried to get all the way to here, at each stage there are three possible two isogenies.
00:17:55.844 - 00:18:29.624, Speaker A: Again, oversimplifying, but usually there are three possible two isogenies. Um, and so, you know, it's gonna, it's gonna be this. Now, you know, let's, let's say you get from here to here. Now, there are three possible two isotropy's. One of them goes backwards, of course, to where he started with then the other two go forward. And so you're, you're, you get this sort of branching sort of search, right? Where you have to, you have to search e steps. And at each step there are two ways you can go, right? So naively, this is like, you know, degree phi is the number of things you have to try.
00:18:29.624 - 00:19:19.086, Speaker A: But of course, you know, both endpoints, so you don't have to go from e all the way to the end. You can start from each endpoint and meet in the middle. So that makes your sort of attack a little bit faster if you work out the math as to how long this takes. I didn't put it on the slides, but roughly speaking, in a classical attack, this takes square root of the degree, you know, steps in order to get, in order to meet in the middle. And in the quantum setting, you could argue that it takes cube root of the degree. And the reason for the cube root is that it's a well known algorithm. It's like tiny collision search or claw finding search.
00:19:19.086 - 00:20:15.800, Speaker A: Um, what you do is, uh, you have this thing called Grover's algorithm, right, which can quadratically speed up any, uh, sort of quantum search. Uh, you can't, you can't productively use Grover's directly, but what you can do is you can sort of go one third of the way and then use Grover's on the remaining two thirds, right? And so that, that gives you this one third exponent. Now, whether or not the tawny approach actually saves you any time in practice, given our current knowledge of models of quantum computation, is a subject of debate. I think the latest word on this subject is Jacques and Schenck's paper from crypto last year. So it's not clear whether or not you can actually get this number. There are some issues there, but I'm not going to talk about those. You can look at this paper if you want more information on that.
00:20:15.800 - 00:21:07.984, Speaker A: Okay, so that is Sidh. Let's talk about the other thing. So I'm gonna talk about CR's and CSI, and I'm basically gonna talk about them together because from the standpoint of anything that we care about here, they're similar enough. Like the attacks. The same attacks in principle, work on both. Of course, in the details there are differences, but the later talks by Chloe and Chris will focus more on those details. So I'm just going to go very high level conceptual overview of these schemes and what they are and what they do in order to set up, let's say, CR's, which is the easier to talk about.
00:21:07.984 - 00:22:05.264, Speaker A: You want to use the fact that this is a well known fact from theoretical mathematics, arithmetic geometry, that there is a group action corresponding to an elliptic curve if you have an elliptic curve which is ordinary, that is not super singular. So in the ordinary case, you can take an action where the ideal class group of the endomorphism ring of the curve acts on like the set of all elliptic curves with that endomorphism ring. I've denoted that set by the script ell. So the set of all elliptic curves with that endomorphism ring can be acted on by endomorphisms, essentially. But the action is sort of well defined modulo principle ideals. And so it ends up being just an action on the ideal class group, which is fortunate for us because now we have a group. And here's the definition of the action.
00:22:05.264 - 00:22:41.232, Speaker A: It's not that hard as long as you sort of unwind things a little bit. So what you're going to do is you're going to take your, to act by an endomorphism, by an ideal on a curve. What you're going to do is you're going to, essentially you're going to mod out by the intersection of all the kernels of all the elements in the ideal. So that's it right there. So this is, I think, the easiest way to understand it. You have an ideal, so it's a subset of endomorphism. Endomorphisms are isogenes from a curve to itself.
00:22:41.232 - 00:23:02.854, Speaker A: Okay, so they're isogenes, they have kernels. So all of these endomorphisms have kernels. You have a set of endomorphisms. It's an ideal. So it's like an arithmetic, it's like a sub ring. And you're just going to mod out by all of those kernels, but the intersection of all the kernels, not like the union. So you're going to mod out by the points that are annihilated by everything in that idea.
00:23:02.854 - 00:23:38.800, Speaker A: And so that's where your isot, that's, you might look at this slide and wonder where are the isogenies here, the slash here? That's the isogeny you're modding out by a kernel. So that's what we call the complex multiplication action. And using this complex multiplication action, you can devise a cryptosystem. And actually this crypto system works for any group action. You don't need this particular group action. You could instantiate this with any group action you want. It just so happens that of all the group actions that we know.
00:23:38.800 - 00:24:02.112, Speaker A: This is the only one that seems to be both secure and not just group multiplication or something like that. Okay. Um, so it's. It's very easy conceptually, right. You have a group action. So you're just gonna act by a secret a, you're gonna act by a secret b, and then the shared secret will be acting by both of them. Right here, it's very straightforward how to get from, for example, be to Abe, you just multiply by a.
00:24:02.112 - 00:24:24.556, Speaker A: It's a group action. You can do that. Okay. So conceptually, this is, I think, quite simple. There's, there's a whole lot of, you know, devil in the detail stuff about how to implement the group action. This is not straightforward how to implement this group action, because these isogenies could have large degree. And so you have to worry about that a little bit.
00:24:24.556 - 00:24:57.652, Speaker A: But I'm going to let Chloe talk about that, because that's what she's talking about. So I'm just going to treat this action as a black box and say that, hey, we have a group action. We can do a crypto system. Let's understand its security. And so the viewpoint that I'm going to take is sort of to frame this as a hidden subgroup problem. This particular approach was pioneered by Kuberberg, who is here. I hope I don't screw this up.
00:24:57.652 - 00:25:41.344, Speaker A: Too bad, Greg. So we're going to talk about, we're going to reframe this problem as a hidden subgroup problem. And there are, there are sort of more recent papers that just sort of directly talk about hidden shifts and approach the problem from that perspective. But I'm following sort of the older work. I don't want to step on the toes of, like, Chris, who's presenting this afternoon. So I decided it's safer to follow the older stuff. So in order to take this problem and translate it into a hidden subgroup problem, you're just going to define a function on a suitable group that sort of hides a subgroup corresponding to the secret thing that you're looking for.
00:25:41.344 - 00:26:24.778, Speaker A: And so this whole slide starts from the same premise as the previous slide, except that the notation differs. So here my notation is gothic letters for ideals and group elements and things like that. Here I've just got regular old g for group element, for example, but it's the same kind of setup. So we have a group action right here, and we have two elements, and we want to find sort of the group element that translates one to the other. This is the hard problem that you need to solve in order to break Cr's or cside. Cr's and cside both use the same setup, at least in abstract terms. Okay? So here's how you do it.
00:26:24.778 - 00:27:08.824, Speaker A: Um, you define a semi direct product, um, g with, uh, you know, integers mod two, um, this particular semi direct product. Then when you define a semi direct product, I guess you need, you need a sort of function. I don't know what this is called. You need like a tying function that ties the two, um, you know, operands together. And so your, your function here is, boom, that function, okay? And so you tie them together with that function and then you define a semi direct product. And then on this semi direct product you could define a hiding function. It looks like this, okay? And you can check that it is a hiding function, or in other words, that there's this promise that needs to be satisfied that f of a group element equals f of another group element.
00:27:08.824 - 00:27:46.404, Speaker A: If and only if what if and if and only if. Like these two group elements are like in the same coset modulo a certain subgroup. And that subgroup happens to be this subgroup here. And this subgroup has, well, it's a subgroup of size two and one element is the identity. And the other element is sort of the hidden element that you're looking for, like the secret key in the cryptosystem gamma comma one, ignore the one. Gamma is your secret key. So you're looking for this particular subgroup, which is hidden by this hiding function.
00:27:46.404 - 00:28:24.184, Speaker A: So that's the perspective that we're going to take for the rest of this talk. We want to solve this hidden subgroup problem. This is on a dihedral group. It's a semi direct product of abelian group by Z mod two by integers, integers, mod two, and you need to do it exactly this way in order to get a hiding function with a group. Now, this group is not abelian, right? If it were abelian, we would know how to solve hidden subgroup problems. We would use Shor's algorithm on a quantum computer. This group is not abelian.
00:28:24.184 - 00:28:56.304, Speaker A: It's sort of as close to abelian as you can get without being abelian, right? As this large, the class group is abelian, so G is abelian, but the semi direct product makes it not a billion. So it's like sort of almost, but not quite a billion. Right? So all of this. So this sort of approach is from Kuberberg's first paper published in 2003, and it's an algorithm for solving what we call the dihedral hidden subgroup problem, right?
00:28:56.464 - 00:29:01.974, Speaker B: And yes, no credit whatsoever.
00:29:05.834 - 00:29:35.210, Speaker A: That's fine, we understand that we understand that there's the quantum part. And actually. So this talk is. No, there are certain things sort of in this, when speaking to this audience that are a little bit awkward, even for me as a presenter. Maybe all the quantum people who are here know Kuberberg's algorithm very well, but then all the lattice people don't. And so I'm trying sort of my best to just, you know, also, just.
00:29:35.282 - 00:30:01.494, Speaker B: As a point of history, the hydro groups aren't. Are solvable, but they're not nilpotent. And I think the work on nilpotent, non communicative groups, there had already been some. And those. Those really are closer to a billion than this, it turns out. So it's true that they're close to a billion. They're not the very closest.
00:30:01.494 - 00:30:18.994, Speaker B: So it just turned out just different from expected. But anyway, all I was trying to do was to say something new about any case of something problem. And I'm only learning cryptography now.
00:30:21.604 - 00:30:27.504, Speaker A: All right, thank you for that clarification. If I screw this up, please, please, please do correctly.
00:30:29.244 - 00:30:32.564, Speaker B: You pioneered what you're really talking about.
00:30:32.604 - 00:30:58.414, Speaker A: We get some credit. We get some credit. Thank you. And if I mess anything up, please, please do let me know. I'm very happy to receive corrections. Okay, so to describe the algorithm for the half of the audience who isn't very familiar with quantum algorithms, I'm just going to simplify some more and assume that the abelian part, the G part, is cyclic. So z modulo n for x n.
00:30:58.414 - 00:31:20.674, Speaker A: So now we literally have a dihedral group. This is the dihedral group that, you know, from group theory. It's a sort of rotation groups with reflections. So that's the Z modul part, is the reflections. Now we're going to suppose that we have a hidden subgroup, which is one of these sort of reflection groups. So when you reflect, it's order two. So it's one of these reflection things.
00:31:20.674 - 00:31:52.534, Speaker A: And you're going to begin just like you do in Shor's algorithm. You make a superposition of this hiding function over all the possible inputs. Well, not all, but you're going to go over all the dihedral. Yeah, yeah, actually, all the possible inputs. So you're going to make a superposition over all the possible inputs of d and f, of d. And here you're going to measure the second register. So this should be very familiar if, you know, shor's algorithm, measure that second register and then look at what happens to the first register after you measure the second register.
00:31:52.534 - 00:32:19.214, Speaker A: Actually, you're going to throw away the result of the measurement. You don't care about the second register anymore. All you care about is the first register. So that first register, once you measure the second register, the first one, instead of being a superposition over all the group elements, is going to be a superposition over two of the group elements. It has this hiding function, has this guarantee, sort of that. It's this two to one thing. So now you have a superposition over two things.
00:32:19.214 - 00:32:49.674, Speaker A: Okay? And you can generate a lot of these. You can generate as many of these as you want, and you can't really control what you get, but, you know, the structure of what you get. They're all going to be things that look like this. Okay? So you have a whole bunch of things that look like this. And then you apply your favorite tool from quantum algorithm, which is the quantum Fourier transform. And now you get this object, right? And so that's. That's what it looks like after you do the quantum Fourier transform.
00:32:49.674 - 00:33:08.562, Speaker A: It's not a. It's not a sort of, you know, super easy thing to work with, but you can still. There are things you can do with this. Right. And so what are you going to do with this is. Well, let's see. So it's some summation over.
00:33:08.562 - 00:33:46.830, Speaker A: Now, these cyclic part, the first qubit here, the first qubit, the first coordinate is some superposition over the cyclic part of the. Of the dihedral group. Now you're going to measure that, and that will give you an element of the cyclic part. That will give you some element of the cyclic part. And then now you're going to keep the second part over here. So we've gone here from these two registers, the input and the output. We measured the output.
00:33:46.830 - 00:34:01.194, Speaker A: Discard it. Now we have the input, but the input itself is two coordinates. There's the G part and the z mod two part. And so now you're going to quantum Fourier transform this mess, and then you're going to measure the G part and throw that away. Well, not throw it away. Measure the G part. Keep it.
00:34:01.194 - 00:34:19.580, Speaker A: Keep it, like in a database so you know what it is. And then you have. What's left is this part in superposition. And this part is sort of. Well, it's zero and one, and they're sort of offset by this, this phase. Right. This root of unity.
00:34:19.580 - 00:34:38.964, Speaker A: Right. And what that root of unity is depends on two things. One is the secret gamma that you're trying to find. The other is the k, which is the k that you measured in the first part. And so you're gonna keep that k, and you're gonna keep this superposition, and we're gonna call this. I don't know what we're gonna. Okay, we're gonna call this psi K.
00:34:38.964 - 00:34:55.330, Speaker A: There you go. We're gonna call it psi of k. And you could do this many times. So you do this many, many times. Many, many times. You get lots and lots of psi K's you can't control. You can't pick and choose what k you get, but you know which one you got.
00:34:55.330 - 00:35:27.906, Speaker A: Because when you measure the first register, you know the k that you measured. So you get lots of the. Essentially, you have a machine that generates random Psi K's and you know what random output, what random k's you got. But you can't control what the random k's are. If you could control what the random K's were, then you would be done, right? So here's a, you know, quick sort of explanation of why that's the case. And you'll see that, you know, in these, in these kinds of algorithms, it's often very convenient to suppose that your n is a power of two. And so now I'm going to do that.
00:35:27.906 - 00:35:52.114, Speaker A: So we're simplifying even more, right? And you can work around all these problems you don't like. This is not the only case where the algorithm works. You don't have to simplify this way. It just makes it easier to explain. So suppose that n is a power of two now, right? Um, if you can construct Psi k and choose the k, then you're done. Because then you could construct. You could set k equal to n over two, basically.
00:35:52.114 - 00:36:36.030, Speaker A: And then that would give you either zero plus one or zero minus one, depending on whether gamma is even or odd. And so then you just measure with respect to this sort of 45 degree basis. And that will tell you whether gamma is even or odd. So that gives you one bit of gamma, one bit of your secret. But then, as is usual with these kinds of things, if you can compute one bit, then you can, like, you know, engineer it so that you can then successfully determine more and more bits, right? So you just need to. You just need to be able to compute, like, psi k for some k of your choice, right? And then you're done. Okay, so then the last part to understand is that here you can sort of control the k.
00:36:36.030 - 00:36:55.702, Speaker A: Not really, but you can sort of control the k. And the way that you do that is you can sort of. You can, you can, you can. You can combine states you can, like, interpret them or whatever. You can combine them. Tensor product. You can combine them in this way, right? So what you do is you have two of these states, which I've called psi P and Psi Q.
00:36:55.702 - 00:37:41.852, Speaker A: If you just combine them, you know, multiplying them directly, you get this, which is not super useful, but then you can, like, control not. I have to sort of figure out what this is. You flip the second bit if and only if the first bit is one, right? So your standard control, not operation here, that turns this one into zero, this zero into one. And then when you simplify this, you get that mess right here, okay? And then now you're going to measure the second register, and that's going to be either zero or one. If it was zero, then you got p plus q here. If it was one, then you got p minus q here, okay? So you can get either p plus q or p. When you have psi P and psi q, you can't control the p, you can't control the q, but you know what the p is and you know what the q is.
00:37:41.852 - 00:38:15.832, Speaker A: So if you want it p plus q, you could get that half the time. Another half the time, you'll get p minus q. Okay? So you have this sort of. You have this. You have this hobbled, um, you know, way of doing arithmetic, where you. You can. You can add things, but you might not add them half the time, right? So you'll be successful half the time, right? Or if you wanted to subtract them, you could subtract them and you would be successful half the time, right? Um, your saving grace is that you know whether or not you got the plus or the minus, right? Because when you measure the second register, you'll know whether you got the zero or the one.
00:38:15.832 - 00:38:59.830, Speaker A: Okay? So you know which one you got, right? Do you know which one you got? And then now it's just a matter of putting it all together, right? So imagine that, okay? Here's like, the formulation that lattice people might understand better. You have a lot of psi K's for random K. You want a particular psi k, and you can add and subtract the K's that you have, which are random. You can't control them, but you can add and subtract them. Of course, this has a cost. You can't just, like, add and subtract, like, ten to the 100 of these. So what you need is you need, like, a short linear combination, a short integer combination of the Psi K's that you have that lands in the k that you want and this is a lattice problem.
00:38:59.830 - 00:39:30.360, Speaker A: This is exactly sort of a lattice problem. And so this sort of sieve that I have on this slide is, I think in Kuberberg's paper, you describe it as reminiscent of either BKW or aks, one of those things. Right. It's because it's essentially one of these latter. BKW is bloom coliwosterone. I don't remember what aks is in the lattice context. Yeah.
00:39:30.360 - 00:39:49.596, Speaker A: Thank you. All right, so it's one of these things. It's essentially a lattice algorithm, right? It's a little bit harder than the lattice case, because you can't control what operation you get. You can't just always get a plus or always get a minus. You get one or the other half times. So it's just a little harder, but not too much harder. You can work around that.
00:39:49.596 - 00:40:35.120, Speaker A: You can work around that just by essentially doubling at each stage, the number of inputs that you combine, so that when you're successful half the time, you still get the number of successes that you need. So here's what you do. You start with a whole bunch of quantum states for random k's, four to the square root of log n of them, and you group them to buckets according to their last two or log n bits. And you're going to zero out these bits, starting from the least significant bucket, I guess, and then working your way up. So, to zero out all these bits, what you're going to need is. Well, you're going to need to subtract. If they have the same lower square root of log n bits, you have to subtract them to zero out those bits.
00:40:35.120 - 00:40:47.800, Speaker A: That only works half the time. So there you go. It works half the time. If it works, you destroy two states. You don't get to keep the states. After you combine them, they're gone. But then I have a new state.
00:40:47.800 - 00:41:20.134, Speaker A: So if it works, you destroyed the inputs and you have an output. If it doesn't work, you destroyed the inputs and you got nothing out of it. So on average, you destroy four inputs to create one, and that's where that four comes from in the base. And you have to do this whole thing square root of log n times, because there are square root of log n sort of buckets of square root of log n bits each. So you do this whole Thing, square root of log n times, and then you can control the state to be whatever you want at the end, right? Not just zeros, but you can get ANy binary sequence that you want in there. And so that's how you do it. And this gets you sort of one bit.
00:41:20.134 - 00:42:05.746, Speaker A: OkAy, that's my last slide. I think I am done. I will happily take any questions, and for all the rest, I defer to Chloe and Chris, who will talk much more about this stuff. Any questions? This is probably a dumb question, but your shared secret at the end of the protocol is some elliptic curve. Is there a concern that needs some canonical representation of these things? That's a good question. The question is, I don't know if I need to repeat it. Your shared Sig order is an elliptic curve.
00:42:05.746 - 00:42:51.482, Speaker A: Do you need some canonical representation of the elliptic curve in case two people come up with the same curve but represent it differently or something like that? The answer is, in practice, yes, we use a canonical representation. It's called, well, what we described in our original paper for Sidh is to use the j invariant. The j invariant is an isomorphism invariant of the elliptic curve. Any two isomorphic curves have the same Jain variant. And so no matter how you do this, you're gonna get, at the very, very least, you're gonna get isomorphic shared secrets at the end. And so j invariant does the job for you. In practice nowadays, what we do is we use curves in Montgomery form, and for Montgomery form, it's not convenient to use the j invariance, it's more convenient to use the a invariant.
00:42:51.482 - 00:43:16.824, Speaker A: But the same principle applies that you can guarantee that the a invariant will be the same. So your shared secret ends up being just some number that you compute over the curve. Yes. Your shared secret ends up being an element over the field fP. Or for Sidh, the field is actually fp squared. And thank you.
