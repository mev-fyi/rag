00:00:00.960 - 00:01:03.052, Speaker A: Our theoretically speaking seminar and to the talk by Eli Ben Sasson on scaling blockchains with starks, scalable, transparent arguments of knowledge. So, just a few words about diamonds Institute. So I'm Shafi Goldo, I'm the director here. And we are the leading international venue for collaborative research in theoretical computer science. We were established in 2012 with a grant from the Simons foundation, which has been very generous to support us for the last ten years and now for new ten years. And we bring together, really, the world's leading researchers in computer science with emphasis on theoretical computer science and related field, as well as the next generation of outstanding young scholars, fellows. And we explored the use of algorithms and models and laws of computation in science, engineering and society at large.
00:01:03.052 - 00:02:01.034, Speaker A: And today's lecture is especially a proof for the fact that algorithms and complexity from completely theoretical computer science make a difference in the real world. And our speaker is Elie, and Elie is a co founder and president of Starquer, chairman of its board and directors. He's been researching probabilistically checkable proofs from a complexity and a cryptographic perspective since he received his PhD in TCS with Avi Wigderson, where he studied actually logic and proof complexity. So the word proof is in both, but I think they're very different type of investigations. And Nelly's co inventor of the Starc fry Zero cash Protocols, co founder of Zcash company, and he's been postdoc and held positions at Harvard MIT Institute for Advanced Study the Technion. And now he is in Starcore. So please join me in welcoming Elie.
00:02:05.214 - 00:02:55.384, Speaker B: Thank you, Shafi. It's a special honor to be here at the Simons foundation, which is indeed the leading place. The Simons Institute, sorry, the leading place for collaborative research in theoretical computer science. I had the pleasure being here a few times in the past, and generally, I have immense gratitude, of course, for everything that is theoretical computer science and a lot of respect for it, because, well, it's been doing amazing stuff for the world. And I want to share with you one such example that is unfolding as we speak. You know, I think hasn't yet reached its full potential, but it's already extremely exciting. So this is supposed to be some image of.
00:02:55.384 - 00:04:03.564, Speaker B: It's a fusion, fusion of atoms where energy is released, but. And probably a lot of you saw the movie about Oppenheimer, and as mathematicians, you're also aware of the greater context and the amazing story in which very arcane fields of mathematics. So I'm not a physicist, so probably most of them I don't even know. But I know of, for instance, complex numbers that were like these imaginary things that had no utility. And all of a sudden turns out that the world is best explained using these weird objects. And probably there are a few other concepts that made an appearance in quantum mechanics that I can't even recount or explain. So this sort of story where things that come out of deep math have an immense impact on the world, we all know it from physics.
00:04:03.564 - 00:05:08.810, Speaker B: And I want to tell you another such story that is right now unfolding. So we're in the early days and here the math actually comes from these places, from the people that are here and the academic predecessors. And it's also a story of fusion, where on the one side there's theoretical computer science, in particular interactive and zero knowledge proofs, and also techniques, algebraic techniques of pcps. And from the other side there are blockchains that are newer, but also these magnificent, this magnificent and weird technology and very colorful one. And when you combine the two, you get massive boost in scale, which is extremely important for blockchains. And I hope to convince you also that blockchains are very interesting for society at large, can have a great impact on us all, hopefully in a positive way and also for privacy in blockchain. So that's the story.
00:05:08.810 - 00:06:23.746, Speaker B: It's the story of an amazing contribution of theoretical computer science to the world of blockchains that has so far already resulted in very massive boost in scale, which is a very needed problem to solve in the world of blockchains. And I want to just give you a few examples of what's going on today from our own technology at starkware. So using this technology that comes straight from the core of theoretical computer science, we've saved over so far, over $1 billion for customers in things called gas fees over ethereum, or in fees traded over a trillion dollars for our customers and minted a lot of nfts, for those of you who know. And we have, using this technology, that again, all of it relies on theoretical computer science, algebraic coding theory, interactive proofs and cryptography. We are already scaling the amount of computation that blockchains in particular Ethereum can do right now already by a factor of ten x. But it's not going to stop there. It can go a lot more.
00:06:23.746 - 00:06:55.126, Speaker B: And this is already things. This is something that just happened. Like two days ago, we reached a rate so Ethereum can process around ten transactions per second. Bitcoin is the same. So on our system we already witnessed more than 100. And it's the first such blockchain scaling technology of this kind that has reached this, and this is not the end. So the interesting thing is that it all boils down to dealing with integrity.
00:06:55.126 - 00:08:10.368, Speaker B: And there's this really beautiful definition of integrity by the novelist, the author CS Lewis, which is that integrity means doing the right thing even when no one is watching. And actually, I hope to convince you that both what these technologies give, or the way we use them, is we use them in order to assert and enforce integrity, to have everyone know that the right thing was being done, even when you're not watching. And the interesting thing is that also, blockchains offer a new way to deal with integrity, to know that the right thing is being done. In the case of blockchains, it's usually associated with financial transactions or things of value. And it is also done by a very novel approach to integrity, to knowing that the right thing is done. But it's really a story of two different technologies that deal with this notion of integrity, making sure that the right thing is being done even when you're not watching. And I want to start, of course, with the stuff that's related, that comes from our world, which is theoretical computer science science.
00:08:10.368 - 00:08:59.836, Speaker B: So Shafi already mentioned this, but for something like, I'd say 25 years. So I started my PhD studies in, well, my undergrad in 93, and then my PhD in around 96. And up till 2018, I was fully a theoretical computer scientist. So that's 22 years, I think. And since 2018, I've sort of tapered off and became more of an entrepreneur or blockchain person. And as I said, I have. All that I've been doing is taking this math and these tools and basically making it more practical.
00:08:59.836 - 00:09:42.982, Speaker B: And so I have immense gratitude for this beautiful field and its impact on the world. So let me tell you a little bit. The story of starkware and the technology. How it came about, of course, starts way earlier. So think of stark as some technology that delivers integrity. And it does so using math and cryptography, where integrity, again, is knowing that the right thing is being done when no one is watching. And in particular, so to describe what is being done or the way it is being achieved, I want to quote from one of the very important papers from the early days.
00:09:42.982 - 00:10:55.464, Speaker B: So this is the BFLs paper by Fort now Levin and Segedi. And there's just this beautiful prophetic quote that, I mean, I think a lot of us use it all the time. So they said in this setup, so they were talking about checking computations in polylogarithmic time where there's this amazing thing where, I mean, we all know the undecidability of the halting problem. So one way to phrase it or one of its consequences, is that if you're given a computation and you want to know anything about it, like whether it terminated or what was the output, then you really cannot save in the general case at all on just running it, hoping it terminates and then seeing what the output was. And yet, in this weird setup, you can have exponential savings. So, to quote they said, in this setup, in this world of interactive proofs, a single reliable PC, this was the early nineties. So PCs, think of them as some very weak computer, can monitor the operation of a herd of supercomputers with powerful but unreliable software and untested hardware.
00:10:55.464 - 00:12:19.934, Speaker B: So they had this mental image where you have this very weak computational device, but that you trust it, and then it can monitor, well, the integrity, the correct execution, that the right thing is being done over these vastly stronger computers. And if I jump to the end of like what we're doing is we are replacing this reliable PC, or the PC that we trust and rely on is actually going to be a blockchain, which is something that operates at a very low pace, but it is very trusted for other reasons that we'll get to later. And we're using that in order to run this kind of technology and monitor the operation of arbitrarily powerful computers that are then helping scale the operations of blockchain. This is so in this paper from 1990s, it's really already spells out what it is that we want to do. And so here's an example of the kind of things that this technology proves or asserts integrity over. So someone is claiming that they started system was at a certain state whose hash was x. So like a fingerprint, you know, some state of the computation is x.
00:12:19.934 - 00:13:02.456, Speaker B: And after processing 1 million transactions, think of them, you know, maybe this state is like a bunch of bank accounts. And then after 1 million transactions have been processed and everyone knows what the program for processing transactions is. It's some well known program whose, let's say, code is available for everyone to inspect. And we assume that it doesn't have bugs, we reached a new state. Why? Whose hash is y? So this is the kind of computation that actually starcor and many other teams are after proving. And we all need to know the integrity of such statements. Our banks are entrusted with such things.
00:13:02.456 - 00:14:38.434, Speaker B: So what does the technology do? And now I'm going to just give you some statement of the PCP theorem in words that relate to this. So it turns out that the PCP theorem says that you can take any such statement which is specified by a quadruple. In this case, x, the starting state, y, the ending state, the program p, which could be a generic Turing machine, any program, and something that bounds the running time, like the number of transactions or number of steps. And if you have this quadruple, you can generate from it basically a template for a proof, which could be thought of as some like Sudoku like set of constraints. And it's a puzzle that needs to be filled by the party making that claim and claiming that this is indeed the result of the computation. And the way this works is that the prover now submits a solution which is like this, fills in some numbers in this Sudoku like puzzle, and then the verifier tosses some random coins, picks one of many, many constraints that go along all kinds of directions, queries the entries of that particular constraint, checks whether it satisfies the sudoku like challenge. So it's not really Sudoku, it's some other set of constraints, and then decides whether to accept or reject based on this one sample.
00:14:38.434 - 00:15:51.586, Speaker B: So the amazing thing is captured by these three conditions. One is succinctness, which says that in order for this verifier to sample a constraint and to know what is the predicate that needs to be checked, the verifier does not need to run something that corresponds to a million steps just based on the program and the input and the output and logarithm of the running time. You can already run a computation that will say, okay, here's what I expect to see. This is what will satisfy me and won't satisfy me. And this is succinctness. The second amazing thing is completeness, which is that if indeed the statement is correct, and someone has done this processing, then there's an efficient way to generate a correct filling of the puzzle that satisfies all constraint. And the deepest and hardest to prove part is soundness, which says that if the statement is incorrect, no matter which way you fill in these missing numbers, at most 1% of the constraints will be satisfied.
00:15:51.586 - 00:16:59.042, Speaker B: Which then means that if you want a smaller chance of error, you just need to sample a few more times, and you'll get it. So this is some version of the PCP theorem that I assume many of you recognize, and really what a starc is. It's a version of what's called an interactive oracle, proof that works almost like a PCP, but has several rounds. So the way it differs is that after the prover has submitted the solution to the first puzzle, now the verifier samples more randomness and generates a second puzzle, and the prover is asked to fill it. And then this goes on a bunch of times, and at the very end, the verifier comes and samples these sort of three dimensional like constraints that go across several of them. So it's very much like you can think of a PCP as a one round IOP, or it's some generalization of this model. And then I can summarize what I did in hindsight.
00:16:59.042 - 00:17:46.356, Speaker B: I mean, I didn't think of it in those terms as. So these constructions are, initial constructions are what we like to call, or Richard Lipton called galactic algorithms. So these are algorithms that work very well asymptotically. But for any input size that it's, let's say, smaller than the number of atoms in the solar system, it is not efficient, and it's not worth your while. You'll gain no savings. And indeed, I once heard from Mickey Beno that he took, actually a student and asked him, you know, let's find the first input size in which, you know, using these techniques, we actually save something in terms of the ability to verify the correctness of a computation. And it was an immensely huge and impractical number.
00:17:46.356 - 00:18:41.914, Speaker B: So I can, in hindsight, summarize a lot of my research as just striking off two letters from there and making it more practical. And this was done over several papers and works. And certainly when I was doing this work, I was not motivated by any practical application. It was just some example of, here's a cool problem that is really interesting, so let's try to solve it. But in hindsight, what? No, these were like, this benzos on Sudan was just short pcps and then interactive oracle proofs and everything. It was for specific. He was looking at specific.
00:18:41.914 - 00:20:20.464, Speaker B: Yeah. Well, I don't know which computation Benoit was looking at, but probably, well, if you go back to the, let's say, to bfls or almss or these other early constructions, nearly any computation, even if you want to just prove that, let's say, one plus one equals two, you'll probably, or. Sorry. The question that you're interested in answering is, what is the minimal size of computation where the length or the time needed to verify the correctness of the computation using these techniques is, let's say, shorter by one step than the time of just naively just running the computation? And I think the answer to that, using the previous techniques was, well, you need some computation that is more than the number of atoms in the solar system. And, yeah, I think that was the kind of question that they were asking. So now, I told you one part of the story, which is that if you are in a situation where you have one reliable PC which you want, you trust it, and you want to monitor the operation of a herd of supercomputers, then now we have the technology. But the other part of the story is what is the situation in which you really have this one trusted, weak computer that you wanted to monitor a herd of supercomputers.
00:20:20.464 - 00:21:14.654, Speaker B: And that's where blockchains come in and they give you integrity, knowing that the right thing is being done by other means. And these means have to do with game theory and networks. And I want to now tell you about blockchains. Now, I'm sure everyone here knows about blockchains and heard maybe about proof of work and how much electricity they guzzle. And being computer scientists, we get drawn to this aspect of computer science, but I think the right way to think of blockchains is as a technology that solves a very old problem and a very important problem. And that's what I want to try and convince you next. So blockchains are, forget about the protocols and the chain of blocks and the proof of work and the hashes and whatnot.
00:21:14.654 - 00:21:49.184, Speaker B: Here is a different way to describe what blockchains give you. So let's start with this definition of a social function. So I want to define social functions as protocols and databases whose value necessitates broad social consensus about their integrity. Here's an example of something that isn't a social function. If you have ibuprofen, it's not a social function. You don't care what everyone thinks about it. If you have a headache, you take it, it's going to make you feel better.
00:21:49.184 - 00:22:22.730, Speaker B: A car, it's another example. You want to get from one place to the other. We'll take you there. You don't need, you don't care what other people think. But money is a social function because the only reason money has value. Well, I don't know if the only reason, but for money to retain its value, it's all about broad social consensus about the integrity. Now, what exactly is the right thing for money? Well, we have some, you know, some notion of it.
00:22:22.730 - 00:22:57.250, Speaker B: Like, for instance, I can't just make as much of it as I want unless I'm the Federal Reserve and I call it quantitative easing or something. But generally speaking, you're not supposed to be able to create, like, this infinite supply of it, and it's supposed to be something that's scarce. And I. So there are all kinds of things about money, or if you now make it digital, you know, you want certain things to happen, like, with money. Like if I. If I'm paying shafi, so, like, my consent is needed and she can't take it away, and these sorts of things. So that's all part of what.
00:22:57.250 - 00:23:32.874, Speaker B: The integrity of money. What is the right thing that needs to be done? And then the only way money can retain its value if there is somehow broad social consensus about its integrity. Land registries, another example, it's a database that all of its value, it's just some file. But this file is really, really important only because there's broad social consensus about its integrity. And finally, things like social titles, reverend or doctor, professor. Again, these are about. There must be.
00:23:32.874 - 00:24:16.432, Speaker B: Their value is all about broad social consensus about their integrity. Okay, so human societies have been dealing with the problem of how to administer and manage social functions ever since societies existed. If you go to biblical or mythological stories, there'll be, the elders of the town would sit in some place, and there'll be some protocol where you go there and do some ceremony. This is an implementation of a social function. This is the way that everyone knows that whatever this parcel of land moved from Alice to Bob, it's an implementation of a social function. Blockchains. I'm actually going to use blockchains.
00:24:16.432 - 00:24:57.662, Speaker B: We sometimes think of them as this chain of blocks, but some of these systems don't really have chains of blocks. Let me use a different term for them. Let's think of it as an integrity web. We're all familiar with the worldwide web. It's this marvelous peer to peer protocol that gives us a lot of good things. So an integrity web is a different way to implement social functions or to become infrastructure on which you can implement social functions. So what distinguishes an integrity web? It is the way it implements social functions is based on an open peer to peer protocol that, and here's the mysterious part that I don't fully understand.
00:24:57.662 - 00:25:27.982, Speaker B: So the protocol is open to all. Like, you're all invited to join this protocol. And what the protocol will do is part of the protocol is it will distribute value to the operators of the system and somehow tie that value to the integrity of the system. So I want to give an example. And of course, bitcoin, Ethereum, and Starknet are examples of integrity webs. And there are thousands of them out there, right. If you go to coinmarketcap and look at them, many of them have tokens associated, and these tokens are part of the story.
00:25:27.982 - 00:26:35.894, Speaker B: So I'll give an example. Maybe, you know that there's this thing called the 51% attack against bitcoin, which basically means that if so, this does have to do with, like, hashing and you know, cryptography, but it just means that, well, there's some usage of electricity in order to generate new blocks in bitcoin. Now, if more than 51% of the controllers of this electricity or this activity decide to work together, they can basically change the history of bitcoin and do horrible things and basically just make it completely, well, lose its integrity. Because part of this integrity is like finality. And knowing that if Alice paid Bob, then now, then this will remain the same thing forever. And in reality, when you look at the distribution of hash power and things like that, you can see that there were times where two or three parties had vastly more than 50% of this hash power. So they could, from a game theoretic perspective, pick up the phone, say, okay, bitcoin is worth whatever.
00:26:35.894 - 00:27:21.206, Speaker B: Maybe it could be worth now like a trillion dollars. So they could pick the phone and say, okay, there's a trillion dollars to short here or to make money off of. It's a lot of money. Let's do this 51% attack, maybe short the system, or, I don't know, like, and it never happened. So if you ask yourself, like, why is this that it never happened? It. So I don't know of like, the, you know, the proper economic game theoretic analysis for this, but I think it has to do with this, you know, virtuous cycle of tying, like, what would happen if they do this kind of attack? Well, all of their assets, or a lot of their assets are tied to this bitcoin. So now bitcoin's price is going to go down to zero.
00:27:21.206 - 00:28:06.716, Speaker B: And they invested a lot of money and a lot of effort into purchasing all of this electricity or whatnot that led them to this place. And somehow the value that they have been distributed or are being distributed is tied to the integrity of the system. So if you attack it and ruin it, then all of your value will be ruined. Did you want to ask some? I'm curious. When you say to this day it never happened, is that there's been no evidence that it happened or we know for sure that it never happened. We know for sure that it never happened in the sense that because everything is extremely public and people talk about these things called reorgs and deep reorgs. And sometimes they do happen on other blockchains, on bitcoin.
00:28:06.716 - 00:29:01.884, Speaker B: It never happens. It would have been like some things that everyone would have been discussing. There's been really happened. The reorders are very short and the order of things that statistically should happen and make sense. So again, I want you to think of blockchains as this new solution to a very, very old and very important problem, which is, how do we manage social functions, things that are extremely important for society. And if you think about social functions and their impact on our life, on human society, you realize that if blockchains, like, succeed and really being a better infrastructure for managing human societies, then of course they could have immense power and transformative power on our lives. And the jury is still out.
00:29:01.884 - 00:29:52.604, Speaker B: This is a new technology. Certainly, if you look at blockchains right now, they're not there yet. We're not using them, for instance, to record marriages and do all kinds of matchings of doctors to hospitals, or record our stock fox papers and the number of citations and our reputation. But, yeah, it seems sort of weird. Might we go down this route one day? But if you think about it right now, the way we're managing all of these things that have immense value for us, immense social value, immense economic value. Right? Is my paper accepted? How many citations does it have? We're using it. The way we're administering it is basically by some very hierarchical and human centric way, of course.
00:29:52.604 - 00:30:30.054, Speaker B: Things like money and central banks and so on. It wasn't always the case, at least, let's say, with money. For many, many millennia, money was much more of a decentralized, peer to peer thing, precious metals and whatnot, and not decided from the top. So there's immense potential here, and it's something that relates to very old and very important problems. So it's not just a bunch of whatever, nfts and weird cats or whatnot that then people go and speculate on. There's that as well. But there's also immense potential.
00:30:30.054 - 00:31:25.758, Speaker B: So now it's very important for this, for blockchains to have this very broad set of operators that's open, inviting to everyone. And because of that, you know, if you want people in, you know, Africa, India, South America, to be able to participate in this broad network and be the basis of integrity, then now you have this conflict between broadness and. Or what's called decentralization and scale. Because suppose you take one of these systems right now and you want to ten x its throughput. So how are you going to do it? You're going to say, okay, go buy a bigger computer, you know, more Ram space, get a faster Internet connection. And then, okay, so maybe people in Berkeley and San Francisco, or a few of them, certainly if you're a visa or JP Morgan, you'll go and get this computer. But if you're in South America and Argentina, you won't do this.
00:31:25.758 - 00:32:11.118, Speaker B: And blockchains have decided, or these integrity waves always choose, and I think they correctly choose, they choose broadness over scale because they understand if you lose the scale, then very quickly it will sort of devolve into a single operator. You can call it whatever, federal bank or visa or something like that. And then really you're just back to the old system of trusting some big party. And whether blockchains manage to succeed or not, we don't know yet. But the ideology is really that you need to have this broadness. If you don't have this broadness, then you lose everything. And I just want to mention that thinking about this, this way, you could also have like national integrity webs.
00:32:11.118 - 00:32:56.800, Speaker B: Like you could have a world where, let's say, the United States, based on your Social Security number, you get some digital tokens, cryptographic token that lets you participate in some integrity web that deals with the US dollar. And I think we'll see such things. And then you could have like systems that are based on citizens and democracy for managing a lot of stuff. We don't have it yet right now. I mean, there's some projects that tried to solve this thing called the problem of proof of humanity. So world coin is one such example. But we could have many, many different forms of integrity webs that sort of bring in democracy, transparency in these things.
00:32:56.800 - 00:33:49.932, Speaker B: So anyways, blockchains face this tension between broadness and scale. And this is exactly where you have this. So going back to this BFLs quote, where is that single reliable PC where you really, really trust, but you wanted to monitor the operation of a herd of supercomputers. And the answer is that PC is really an integrity web. It's a blockchain, because those are very slow and weak computational devices, but extremely trustworthy and they carry immense value. So why not use them as the thing that will run the verifying technology and check that everything else is being done correctly? So, yeah, because that's not really clear. Okay, scale.
00:33:49.932 - 00:34:30.436, Speaker B: Scale means how many? Think of it like as some computer, actually ethereum, for instance. Really, you can think of it as a computer and look at its clock break, like how many steps can do per second, you know, and you'll get to some number that's very small. Let's suppose, I don't know what exactly it is. Let's say that it's 10 khz, as you know, as you measure cpu. So scale means, well, I want it to be like 1 GHz as opposed to 10, want it to be able to process much more. And then another way to think about it is like these transactions per second. So pick some very important transaction like Alice Pace, bond, ethereum and some ether coins.
00:34:30.436 - 00:34:59.548, Speaker B: This is a very common basic operations. Right? Now, if the only thing that bitcoin does, or ethereum is, and bitcoin actually only allows you those things, there's a certain rate. It's like ten transactions per second, roughly. So you're saying, oh, I want 100 transactions per second. Visa processes thousands of transactions per second and it peaks more. And WeChat Pay and Alipay are probably at a million transactions per second. So scale means you want a ten x.
00:34:59.548 - 00:35:59.434, Speaker B: And just like we do with all things that we care about. Okay, what is broadness? Broadness is how distributed among and how open is the set of operators of this network, right? What is the base of trust? Who has the power and who's controlling it? So blockchains, right now, again, I said, maybe one day the US will offer every citizen with a Social Security number, digital token. And now you'll have networks based on this. Right now it's solved by things like proof of work. You bring electricity and hashing, or by proof of stake, which means somehow you have already a few tokens in that network and then based on that, that's the way that you can operate the system. But importantly, everyone is invited to the table and you want it to be the case that everyone can join in and bring in their laptop and track what's going on and view it. So that's broadness.
00:35:59.434 - 00:37:07.352, Speaker B: Now, of course they contradict each other, because if you're going to increase the scale, then this laptop can't participate. And maybe I don't have the means to get a big computer. So now just sharing my personal story, this realization, though I didn't phrase it in these terms, none of this. So for me, the red pilling moment was in 2013. I was giving talks about, you know, implementing pcps in practice, and I gave them mostly an academic places, like not, well, not at Simons, but like these places. And people didn't understand what I was doing and I couldn't convince, like, I couldn't find good examples for like why would, for instance, a bank want to use a system? And I still don't have good examples. And the reason, like, if you think about this, where do you have a situation where a single reliable PC really, really wants, you know, is willing to pay money or in order to verify some computation done by a supercomputer? So you would say, oh, of course I want to verify what's going on with my bank.
00:37:07.352 - 00:38:04.400, Speaker B: No, but actually you don't need that. You're not, the bank is not willing to give you that and the bank doesn't need to give you that. You're going to trust the bank based on other reasons and you're not going to get it. So if you go like example after example, I to this day don't yet know of a very good example outside of blockchains where you want to deploy proving technology, not theoretically, but like practically, you know, which business cases you have people and institutions saying, we will pay money for having this technology and we are also willing to suffer the degradation in, let's say, compute time, the results from them, because generating and verifying proofs is not as efficient as just running a computer. Now what happened to me was that I chanced upon a conference in San Jose, was the bitcoin conference. Back then there was pretty much only bitcoin. And I gave the same talk there.
00:38:04.400 - 00:38:56.548, Speaker B: And when I got off of the podium, instead of people being groggy eyed and like, oh, very interesting, you know, talking, like in the sense of, you know, not interesting, like, why are you doing this? And, you know, some people came to me in later years and said, everyone was behind your back saying, like, why is he doing this? Craziness of like trying to implement and code these things. And I didn't have very good answers. So going down from the podium at this bitcoin conference, so a lot of the core developers came and didn't ask, what are you going to do with it? So they said, okay, where's the code? And now here are three problems that we want to do with it, like we need to solve with it tomorrow. And I said to them, no, you're just, you're being polite. You don't really want to solve these problems. I said, no, no, these are like burning problems that we need to solve and we're going to use it tomorrow. And it just took me by surprise.
00:38:56.548 - 00:40:06.514, Speaker B: So I felt something I didn't, I couldn't articulate what it was that I felt, but I felt that there's something like very, very interesting here. And that was the point where in hindsight, that was the watershed moment, or the red pilling, if you saw the matrix movie moment. For me, it was just this very decisive moment where I felt that there's some calling here that I couldn't quite put my finger on, like, why is it? Anyway. So now what happened was that my co authors and, and me, so we were anyways implementing such systems in code, and we published this paper called Zero Cache that actually used the privacy angle. So zero knowledge proofs invented by Shafi and Silvio and Charlie Rakoff in 85 to shield the payer, the payee and the amount being paid. And we published this in an academic paper. And then I was one of the founding scientists, along with all the six other co authors of this paper, of Zcash.
00:40:06.514 - 00:40:45.992, Speaker B: That was the first use case of a practical, let's call it product or system that actually uses general purpose, meaning general computation amenable. ZK technology was ZK snarks based on elliptic curves for something. And this was the zcash cryptocurrency that still exists. I was then still working on the more PCP related technology, or PCP inspired. This led to fry and Stark. I'll say a few more words about them later. And in 2018, we published the papers and then we founded Starkware.
00:40:45.992 - 00:41:27.678, Speaker B: And it's the first case of first use case of using these systems for scalability. So when we came out with Starkware, we were saying, you know, there's no way blockchains are going to conquer the world without there being an immense scaling problem. And we have the right technology for it. And then what happened was that a lot of people didn't believe this. They said, first of all, there's no scaling problem. We don't see it right now, and we don't believe that this technology can solve the problem. But we still went at it, and luckily there were enough investors and VC's that believed in this and were willing to fund it.
00:41:27.678 - 00:42:07.758, Speaker B: And actually a lot of that was based on the success of Zcash. So the demonstration of this set of technologies that came from theoretical computer science convinced people that this is a worthy, worthy thing. And now, I don't know if you're following the blockchain space or so on. Well, now everything in computer science is like AI this and AI that. So no one cares about anything else. But still, like ZK proofs as a means to scale, blockchains is a very, very hot topic within blockchains. Everyone recognizes that's the right way to solve the problem.
00:42:07.758 - 00:42:57.724, Speaker B: And like go to the next level. Luckily for us, Stalker was basically the first to say this. We have now over 120 employees and expanding and a bunch of products. I'll say a few things about that, but I want to put this technology in more context. So going back to basically the pedigree where this comes from, I think it all starts with GMR. Many good things like Goldwasser, Michali Rako of the discovery or invention of interactive proofs and zero knowledge proofs as a complexity class, as sorry, as a complexity object and a cryptography object. You know, what can this kind of thing do? And then, so of course there's, I'm not going to survey all of the literature, I just want to highlight some things.
00:42:57.724 - 00:44:12.446, Speaker B: So the sound check protocol and that paper first of all, has this amazing revelation, which is that algebra and low degree polynomials and arithmetization are really a good way to, you know, they're really a good tool to bring to the table if you're dealing with interactive proofs. And everything today in these protocols uses arithmetization. And I'll say a few words about that and it's completely surprising. Well, both the subject protocol and what came out of it. But like you want to deal with interactive proofs and prove certain statements about computation, why on earth should polynomials over low degree be relevant? It's completely non trivial and mysterious. And by now we know that you can take them away and replace them with some things. There's still the most efficient way to solve the problem, practically speaking, and it's very surprising, I already mentioned this polylog verification paper that mentioned, oh, here's some use case that you can use this technology for, like a practical one.
00:44:12.446 - 00:45:16.584, Speaker B: They actually said you could verify these big computations in much smaller time. And of course, the PCP theorem that took this to the very extreme, a case where there's just one long message that you can query only three bits of and just look at that. And an interesting thing is that the PCP theorem for many, many years, well, maybe to this day, because it's such a marvelous theorem and has all these amazing implications, to hardness of approximation. Most of the research, well, at least, well, I'm not following the research today, but like when I was following the research, most of the research was about the implications to inapproximability and the positive applications to polygon logarithmic verification were the path less traveled by. And in hindsight, I was very, very fortunate that when I came to my postdoc and Madhus Sudan suggested the question that led down that path of, oh, you know, let's look at the proof length and make it shorter. Why? Because it's a cool question. So that's how I actually started my path that led all the way to this.
00:45:16.584 - 00:46:19.484, Speaker B: Well, there you go. I mean it wasn't what in the fine grained and like, okay. That wasn't okay. I should have known it back then. You know, we should have now an x batch of papers that I want to mention sort of now look at these protocols with the very concrete complexity kind of angle and say, okay, suppose we want to do practical stuff with them, so can we make things a little bit better? Again, some of this is, in hindsight I can say that the quasi linear pcps, as I said when we thought about it, was we didn't think about practical applications, but it was about making things a bit more efficient in practice. Of course, there's the proofs for Muggles paper that takes the Somtrick protocol and shows how to make it practical. There were, because pcps were viewed as too complicated for concretely inefficient.
00:46:19.484 - 00:47:01.994, Speaker B: There was this very nice realization that you can have these linear pcps and use additive homomorphic encryption to solve the problem and also separately, not for these reasons. Pairing based cryptography was discovered by Bonet, Franklin and Zhou and became really instrumental. And now if we look at it, so this sort of red line is now let's look at implementations, or like much closer to implementations. So there's the fry protocol that I want to tell you about. There's things called inner product arguments that I'm not going to mention too much. And they're quadratic span programs that use elliptic curve pairings. And this is already, all of these things are now being used in practice.
00:47:01.994 - 00:47:57.934, Speaker B: An interesting thing is that even though the GKR and some chick protocols are extremely efficient and in fact actually don't need any cryptography in certain settings, they, till now they aren't yet used in blockchain. But I think this is also going to change. And the common names for some of these things you see out there are called starks and snarks. And I just want to say that there's like, well, this is the important line. There are dozens of projects and hundreds of developers that are working. They call themselves ZK researchers and they are building the code and systems and are getting funded by VC's and trying to use it mostly for scalability but also for privacy. If you heard about the Tornado cash affair, there were just some people arrested for actually using writing code.
00:47:57.934 - 00:48:39.954, Speaker B: Basically a re implementation of the Zcash protocol over Ethereum that the Department of Justice claims was not only used by the north korean Lazarus group, but also be known to some of these developers. So some of them are in custody and being investigated. So it's. I mean, I mentioned, you know, quantum mechanics, and, of course, all know that there's, you know, you can use this technology for all kinds of things. And I'm not aware of any technology that can't use for. Can't be used both for good things and for bad things. And there's that.
00:48:39.954 - 00:49:18.016, Speaker B: So a little bit more about what Starcourt has been up to. Yeah, just. So the first thing we did was just build a settlement engine that just helps projects that deal with cryptocurrencies save money by using this technology. So it's all about, like, taking the technology of a verification that is exponentially faster than running a computation and using that as the way to get integrity. And I mentioned already that we. That's been very successful and beneficial for our customers. The next thing that we did is that we basically wanted to make this technology accessible.
00:49:18.016 - 00:50:10.204, Speaker B: In its first incarnation. It was extremely inaccessible. If you wanted to, you know, you had some system that you wanted to scale, you would have to work with polynomial constraints and write them by hand, do a lot of complicated stuff. So then we came up with a better way, which is to offer a programming language that is very efficient when it comes to proof generation, but also is for fully turing complete and actually is a pretty good programming language. And now there are probably hundreds of full time developers writing code in this language. And then we also have launched a general purpose, sort of integrity web called Starknet that uses it, and it's thriving. So I just want to explain what this, what Starknet is this.
00:50:10.204 - 00:50:44.004, Speaker B: So we mentioned this broadness in scale, tension, and blockchains. Right now, they don't use proofs as part of the way they deal with scaling. So what starknet is, it's an integrity web, L2. So what does L2 mean? It means that you use the basic blockchain. In this case, it's Ethereum, which can. Ethereum can think of it as some slow. It's your trusted PC, runs at a very slow pace, and it's very costly, each operation of it, but it's extremely trusted because it has very good broadness.
00:50:44.004 - 00:51:53.684, Speaker B: So we use that as the layer one, and we run a verifier on this PC, and then it monitors the operation of this herd of supercomputers. In this case, these are the provers and sequencers of this L2 that can deal with much greater scale. And so Starknet is an integrity web on Ethereum that resolves the broadness and scale tension using math in particular, stark validity proofs. And the way it goes is that it invites arbitrarily powerful computation and operators, even ones where you don't necessarily want to assume trust over. You can now assert integrity over them by basically telling you, okay, whenever you want to update the state of your system, you have to supply a proof that the right thing was being done when no one is watching. And now we're going to verify this proof, and we have cryptographic certainty that you didn't, you know, that you only updated the system according to this well known program that everyone has seen and checked. And this is a way to give you a much greater scale.
00:51:53.684 - 00:52:22.740, Speaker B: Just mention that you can also use recursion. So you can now run verifiers on Starknet itself that will verify something called the layer three. And then you have even more scale. And this can go on and on for a while, and probably will. So now in the remaining time. So how much more time do I have? Very good. So seven minutes.
00:52:22.740 - 00:53:27.550, Speaker B: I just want to say a few words about, I mean, being theoretical computer scientist, like, I have to tell you a little bit about the algebra. Luckily, I mean, I have a whole bunch of slides, including some math stuff, but we won't get to that. So. So I just want to tell you about arithmetization and just how magical and strange it is. What is arithmetization? Arithmetization is this reduction from questions about computational integrity, right? Has this program executed correctly to problems about relations between a bunch of polynomials? So you start with something like this computation, you know, have I, is it the case that I have processed correctly a million transactions? So there's no polynomials, there's no algebra here. And then you move to a new statement that looks something like this. You want to convince me that you've done the right thing.
00:53:27.550 - 00:54:18.036, Speaker B: Okay. Well, I come up with these two polynomials, you know, Q and R, and some degree bound. You want to convince me that the right thing was being done. You want me to accept this new state? Well, please provide four polynomials, A, B, C and D, such that the weird relation between q and r holds, you know, and this is just some example of a relation, a relation between polynomials, you know, does this equality hold? So again, just take a step back and see how weird this is. You started with a question about computation, and now you have this question about polynomials and the relation between them. It's very strange. But the nice thing is that if you manage to apply this reduction, then you're in a very good situation.
00:54:18.036 - 00:55:22.604, Speaker B: Because if it is the case that you can't find these polynomials A, B, C and D, because maybe this claim you're making is just false. Well, now we can have a very succinct and efficient way to check this, which is we're going to sample a random element x. Just evaluate the two sides of this equation and see if they're equal. And the nice thing is that when you're dealing with low degree polynomials, if the total degree is, you know, d, you can have at most d values in which two distinct polynomials fool you that they're the same if they're not. So if you sample from a large enough domain, which is what all of these proof systems do, suddenly you get like very good probability of discovering that someone has not been operating with integrity. And it's very mysterious that this works, but this is arithmetic. And now you're faced with a new problem, which is you really.
00:55:22.604 - 00:56:13.666, Speaker B: The core of the problem now becomes, how do we enforce this integrity with respect to low degree polynomials? So all we need to do is find a way to get Bob to commit to these low degree polynomials, the degree D. And then actually, when he's asked about x, evaluate them honestly, that's really the new problem. So if you can solve this problem of getting people to commit to any polynomial of degree D, but not change their answer afterwards and evaluate correctly on it, then you solve the problem. And these things are now called polynomial commitment schemes. So it's a way to commit to a polynomial and then evaluate. So what is the ideal functionality? Suppose you fix a field and a greed bound d. Then what you want is this functionality.
00:56:13.666 - 00:56:55.164, Speaker B: So Bob, who's going to try and convince us of the correctness of the statement, is going to send a polynomial to some trusted party, let's call him Tom. And this is going to be any polynomial of his choice, but of degree at most D. And Alice gets to specify the degree. And now Alice is going to ask Tom what, you know, what is the value of this polynomial at a random point a. And Tom is going to answer the correct answer for that polynomial p, that Bob has deposited within. So this is the problem that all of these different protocols and approaches are ultimately trying to solve without trusted part. Exactly.
00:56:55.164 - 00:57:29.056, Speaker B: So what you want to do is simulate this without a trusted party. So how does it look? Well, Bob is going to send, there's no Tom anymore. So Bob is going to send some cryptographic commitment or some commitment to this polynomial, and then Alice is going to query Bob. There's no more Tom, right? Tom doesn't exist. So Alice needs to query Tom for the value of the polynomial at point a. And Bob is going to answer with some value b. And then they're going to apply some protocol that basically is going to help Alice decide whether this answer was correct or not.
00:57:29.056 - 00:58:07.354, Speaker B: And what we want is completeness, meaning that if indeed the value of the polynomial at point a equals b, then Alice will be happy. Soundness, which means that the probability that Alice is fooled is smaller than some reasonable number. Let's say two to the -128 you want scalability, which means that you want, like, very good proving time and very good verification. Verification time, in particular. Verification time better be polylogarithmic. You want to care about the security. You know, which crypto assumption assumptions are you going to use? Is it going to be post quantum security? You want universality, you know, all finite fields and rings, maybe.
00:58:07.354 - 00:58:41.708, Speaker B: So the fry protocol, it turns out to be a very simple protocol and also very efficient in practice. It's very fast, and its proving time is something like six times the degree. The verification time is something like 20 times the logarithm of the degree. Those are the constants under the O notation. It is post quantum secure, and it actually even works over all finite fields. We didn't know this in the beginning, but now we know how to get it over all finite fields. And I'm not gonna.
00:58:41.708 - 00:58:58.064, Speaker B: I think I'll stop here, but. And answer questions. So there's a bunch of math slides. I can share them, but there's also the papers. And this is not the hour for subjecting you to things like this. Right.
00:58:58.444 - 00:59:11.444, Speaker A: Thank you. Now we open the floor to questions, anything.
00:59:14.584 - 01:00:24.674, Speaker B: So, I have trouble imagining how would an integrity web that is being used for, like, a social function does not transferable? Like, I mean, how would it look like. I don't understand the question. How would an integrity web. Yeah, how would an integrity web that, like, distribute academic degrees work? Like. Okay, so one thing you can do is you could tie the value of academic degrees to the total integrity of that web. So, for instance, maybe my reputation. So suppose I'm now thinking on the fly, but suppose my reputation generally is worth, let's say, economic, then, meaning there's some protocol for, like, proving that I had not been repeated, and there can even be some slashing or some economic punishment if I found to be irreputable.
01:00:24.674 - 01:01:26.774, Speaker B: And so now I could start making statements and say, Shafi won the Turing award. And then if I start making false statements, then at least risk my reputation. So you could. So reputation systems are one way to deal with it. Another is you could ask like, well, if you think about today, like, how does someone come by an academic degree for some hierarchical system, right? You get a PhD. If there's a committee, it's some accredited institution and so on. So you could follow that chain and say, what if this whole process is actually done on an integrity way? So everyone knows that if you got a PDF from Berkeley, Berkeley is an accredited institution, it means something.
01:01:26.774 - 01:02:19.912, Speaker B: And then the fact that someone else made up some institution, you know, Eddie's institution, and gave you a PhD, it will. The world will know how to deal with that. So you said that you're going to use. You're using l to do the verification and l two to basically propose challenges or groups, right. Well, l two operates at a much higher speed. It still has like transactions and everything. But l one, you know, in order to update the state of this L2, you sort of have a safeguard, which is layer ones smart contract that verifies, in our case, start proofs.
01:02:19.912 - 01:02:27.376, Speaker B: So the system can never be updated until layer one has verified the correctness of approval.
01:02:27.560 - 01:02:29.928, Speaker A: What stops L2 from just like.
01:02:29.976 - 01:02:54.138, Speaker B: Sending a lot of, like, transactions? Like, is that a bad thing? That's a good thing. Like, we want more escape. Like, l one has some, like, bound and it's like. Right, computation. Yes. L1 has all kinds of, well, l one has transaction fees and also L2 have transaction fees and then you pay more for congestion. So, like, if everyone's.
01:02:54.138 - 01:03:37.132, Speaker B: There's a fascinating, you know, area of, like, how do you correctly price transactions on various layers? Like l two, you still need to, like, incentivize. Yeah. So L2. Yeah. On Starknet, it's going to be an integrity web, which means there will also be value distributed in the starknet token to operators in the network, and hopefully their integrity will be tied to that value. Yes. So in the startnet system right now, it's still a single entity running the sequencer and the.
01:03:37.132 - 01:03:55.024, Speaker B: But within a year, hopefully we'll reach decentralization, which means that anyone can be a sequencer and prover, and there will be both transaction fees and unting of tokens that go towards those operators, as all integrity webs do.
01:04:02.264 - 01:04:05.576, Speaker A: Everybody just talks about AI and nobody talks about blockchain right this moment.
01:04:05.640 - 01:04:06.072, Speaker B: Yeah.
01:04:06.168 - 01:04:09.124, Speaker A: But on the other hand, people are talking about the value of data.
01:04:21.064 - 01:05:09.374, Speaker B: Yeah. So. Oh, I should say that a very hot topic today is called ZKML or Zkai. And so you could say, like, we all have this tendency of, you know, there's some hot thing and everything is. But, well, data, or how do you deal with data, how do you price it and so on is very, very essential in blockchain. And, yeah, I think that, well, part of the long term vision of what integrity webs could be is that each individual will be the true owner of their data, which isn't the case right now. Right.
01:05:09.374 - 01:05:56.584, Speaker B: Our credit scores are like all of this valuable data that we are generating, extremely important in all our social networks, our credit scores. When have we defaulted or not defaulted on a loan? All of this information, which is worth trillions, is our information. It's in the hands of several very powerful centralized institutions, and they make a lot of money off of it. So part of the vision of these integrity webs is that it will be reversed. So, for instance, you will be the true owner of your credit history and everything. It will actually be under zero knowledge. Only you can access it, and then you can also offer licenses for processing it.
01:05:56.584 - 01:06:34.964, Speaker B: But, you know, for instance, you'll get a cut of the fee and an integrity web, which is transparent and everyone sees it, can enforce this. So you can still have your data. Everyone will see it. But you could say if you're, you know, some license that would say if you're a credit score or if you're an AI agent and you want to use this data. Well, whenever you process and make some prediction about me or about society and use my data, you need to generate the proof that you paid whoever it is that you touch their data from the chain. So of course you need immense scale from that. But I think that's the direction.
01:06:34.964 - 01:07:22.000, Speaker B: If I look ahead 20 years, yes, this could be the situation. So, yes, when AI agents are using our data, we will be compensated or, and they will prove that they, let's say, compensator used fairly according to the licenses that we put will also be on the integrity with. But I will say, I can say everyone can use my data or maybe some parts. Suppose I have some very rare medical condition that I am really incentivized that people work on one of these rare diseases. So probably I'm going to put a license on that part that says just use it. Right? Everyone who has this condition, we all want together don't pay me anything, but maybe my credit rating or things that I know are of immense value. I will say, yeah, you can process this it's out there.
01:07:22.000 - 01:07:30.184, Speaker B: But if you're processing it and pay me whatever, a cent for each time you're using it, and this could be part of the license.
01:07:38.364 - 01:07:58.880, Speaker A: Today maybe. There's this whole issue of governance of, again, ML systems, so they don't get too powerful. And how do you really govern the computations? How much is being computed on, you know, what's been done? Except we put some sort of proof.
01:07:59.032 - 01:07:59.888, Speaker B: You know, I don't know if you.
01:07:59.896 - 01:08:09.404, Speaker A: Need a blockchain for it, but you need some central authority which wants to verify that these big companies are doing what they claim they're doing.
01:08:10.024 - 01:08:19.262, Speaker B: Yeah, but the way I would solve it today was I would send an auditor or an accountant, just like, you know, it's the same situation with banks. What?
01:08:19.328 - 01:08:35.094, Speaker A: No, it's a visual thing. You have a computer, a transformer, I don't know, huge computations. And let's say the government wants to make sure they're doing it on the right data, they're doing the right compute. They're not getting to be too powerful. So there's a small PC who wants to control a huge.
01:08:35.514 - 01:08:57.195, Speaker B: Yeah, like, but the way. So, no, theoretically, I like it. But like, practically, this isn't different from, let's say, a bank. So a bank also runs some huge computation. It's a well known entity. So what, the government, the way the government solves this problem. And of course, you know, bad, very bad things could happen if no one checks what the banks are doing.
01:08:57.195 - 01:09:28.751, Speaker B: So how does the government solve it? It, first of all says, you know, please, Mister CEO of the bank, you know, sign off that you've been operating with integrity. Okay. Once a year, once several, every several months actually asks you for repo, give us a lot of information. We also get to send people to look at what you're doing and look into your computers. And, oh, if you really cheated, then you go to jail or you face something very severe. So you could apply the very same mechanism to AI. You can say, you know, we need you to.
01:09:28.751 - 01:09:44.423, Speaker B: First of all, CEO, please sign off. You're adhering to these guidelines, and we're going to send auditors will pass a law that you must let those auditors view your code and so on.
01:09:45.403 - 01:09:59.955, Speaker A: And the last question was, let's go with hardware, specialized hardware. I remember years ago you gave a talk that there would be this hardware that will do verification rather than computation. It's sort of a basic operation.
01:10:00.019 - 01:10:05.288, Speaker B: Yes, verification is very efficient. Proving.
01:10:05.336 - 01:10:11.152, Speaker A: They would do prove well, you would set your computation up so that it would be easy to verify in the future.
01:10:11.208 - 01:11:20.044, Speaker B: Yes, first of all, so there are by now probably five or more startups that already got funded that are doing ZK hardware. So they're speeding up on FPGA's and rocket with asics, but on GPU's and FPGA's, they're working to speed up the operations of snarks and starks and things like that. And yeah, I think that the big question is there is when will it's like this, you know, when is the market ready? So like what is the right time to start working on it? Because for a hardware thing, you want. Right. Tens of thousands of people to need this hardware and use it. And the question is they want to start working, let's say two years before that. Now two years out, will we have tens of thousands of servers that want to run these very efficient things? I don't know.
01:11:20.044 - 01:12:07.326, Speaker B: I think maybe we're still like, like four years out. So maybe want to start your hardware, ZK hardware thing, let's say in two years time. There are some companies, some companies like four or five that are already working on it. So Tornado cash is like probably the best example of these technologies, kind of of rubbing a nation state the wrong way. How going forward do we position these technologies in a way where they protect kind of privacy for a global, decentralized community? But, you know, government currency concerns and all this stuff aren't necessarily discarded.
01:12:07.350 - 01:12:12.594, Speaker A: Like how can they coexist? Or are they just naturally going to kind of butt heads?
01:12:13.114 - 01:12:58.064, Speaker B: It's going to be a game of cat and mouse. A bit of the both. A bit of both. Meaning if you think about the Internet, right, the Internet's pretty decentralized and pretty free and open, and it's not heavily monitored or regulated in most modern democracies. And we all know that people are using email and the Internet for dealing in drugs, setting up terrorists and assassination attacks, transmitting the child pornography, and a lot of very bad things. Right? So there's that. And we know that these things exist.
01:12:58.064 - 01:14:19.200, Speaker B: Now, it's a really good question, like what is the right answer even for the Internet? Right. Should you monitor all transmissions so that, for instance, you catch the terrorism and drugs and child pornography? Will it actually work? What are you losing by doing? So I'm more of the opinion that the harm of like, too much monitoring is way greater than the benefits. And I think the same thing will apply, I think, to blockchains. One interesting thing is you could bring to bear, it's not a silver bullet, but you could bring to bear the same sort of ZK technology. One way to say it is that whatever society decides is the right policy that must be enforced. If you can write it into an algorithm, you could actually say, prove to me in zero knowledge that you adhere to this algorithm. Now, the reason it's not a silver bullet is that most of the stuff that we want to please and monitor, you can't just write an algorithm that will, that you can't go across.
01:14:19.200 - 01:14:55.720, Speaker B: Think about, like, you know, don't send child pornography. So, okay, well, there are a million ways to overcome that that no algorithm will be able to, to catch. So, yeah, it will be cat. And just like all crime or illegal stuff is cat and mouse forever, and it's not going to be different here. So how much do you steal? We don't know the bands. Like, they must exist, but they're very, very, very. There's what we can scale.
01:14:55.720 - 01:15:42.180, Speaker B: Like, the way scaling works is that at every given point in time, there's a bottleneck. And I can tell you, for us now, it is actually the sequencer. It comes before the proofs at all. It's like this virtual machine that does the sequencing. And in there, there's some things that are the bottleneck. The nice thing is that I don't know of any theoretical limitation to, you know, on ethereum settling a trillion tps as long as, like, well, there's some things related to data. Like if you always change state and you need to report that to ethereum, that's one hard limit.
01:15:42.180 - 01:16:51.814, Speaker B: But if, let's say, just some computation that runs at, you know, one tera Hertz or a thousand terahertz, I don't know of any theoretical limitation. So it exists, but we can probably using current technology. But like, okay, using certainly the current theory and more hardware, you can probably take all of WeChat, pay Alipay, visa, settle it all on ethereum using start proofs, recursive ones and things like that. So what limits the number of transactions that just Ethereum can do in terms of verifying a proof? There's almost no limit. Now the question is, what do you report to Ethereum other than the proofs? In many cases, you want Ethereum to also get the same state diff. And then, like, you know, what has changed in your data set between point a and b? It's called a roll up. If you do that, then that's one limit.
01:16:51.814 - 01:17:45.134, Speaker B: You could also move to something called validium, which is you don't actually report that. And then there's some other, it's called a data availability layer. But then the question is, what is the limit of that data availability layer? So it's not about the computation and the proofs, it's about these other things where proofs don't help you. Like how much data do you want to save? For instance, if you want all the videos of cool cats to be on your system, then the question is, you know, again, this broadness, this laptop, there's only so many cool cat videos that it can save. So you need some other solution for dealing with that. Thanks for. You mentioned early on that you were considering potential application being matching, like for example with hospitals and residents.
01:17:45.134 - 01:18:49.730, Speaker B: So how would you consider being able to manage like the incentive structure in those cases, getting people to trust this integrity web and move to this system? Well, this, this is already something that is today. So today there's a lot of matching going on chain for trading, and there's several approaches to it. Like you could actually, if you have some metric of how good is it matching. Suppose there are like, you know, bids and sells and buy orders, then you can define some metric as to how good is the solution. In some of these systems, they say anyone, everyone can see the order book, everyone can submit a solution. There's a metric that you can, you know, the one that gives you the best metric according to that metric, get something and get some of the transactions. You could have something similar, you know, for matching, let's say with hospitals.
01:18:49.730 - 01:19:34.514, Speaker B: You know, there's either the hospitals or the residents or both of them maybe put some money because they care about this. And then you could just have various parties compete. And then if you can have a scoring, then you can distribute value to the winner of this auction. That's one way. Another way is to have a smart contract like the code that actually solves the matching. If you have like an optimal algorithm, then you can just run that and prove the correct execution of it. So you have this verification protocol, and you suppose you come up with a clever new thing.
01:19:34.514 - 01:20:43.148, Speaker B: What happens? The past is okay, you store the what is clever new thing scheme some other way in the future. Okay, I guess all the transactions and things that happened before using this scheme, you kind of, if it wasn't broken, so you could still say, okay, here's a state that I trust now. I mean, actually, we constantly do it in our system. You know, we, when there's a new version of, let's say, the verifier that has more functionality, we do some sort of upgrade and allows new set of polynomials. And the way we actually, the reason we use it is we keep adding these, we call them built ins. Like these are like sort of dedicated circuits for checking certain operations that are more efficient like a hash function or then you constantly add more functionality. Will your protocol with Ethereum have to change also because of that you upgrade the smart contract.
01:20:43.148 - 01:21:34.894, Speaker B: Yes. You say my verifier, it still runs right now, it still runs the same kind of technology, but well it's set of polynomial constraints has been enlarged and includes something new. Of course if there is a bug in the new version, then like we all cases. So you have a problem and how does the governance on who can update what. So yeah, that's a very, it's a huge topic of how to deal with governance. There are like many questions game theoretic, legal and what approach is called the DAO approach which is the token holders sort of submit stuff and prove and so on. It has pros and cons.
01:21:34.894 - 01:22:31.432, Speaker B: So you could have a smart contract that says in order for this other contract to be upgraded, I need to see that 50% have, you know, voted for it. That's one popular approach. Another is to have called multisigs. We have trusted set of wise elders that are hopefully publicly known and majority of them as the sign. And so for starknet right now we are in transition or we're constantly decentralizing it more. So right now these upgrades are still pretty centralized, but it's part of this decentralization process is making changing that to something. It's a very interesting question like what is the right governance for verifying? Not everybody has the technical expertise to verify that the new verifier is.
01:22:31.432 - 01:23:35.114, Speaker B: Yes, in general governance is. Governance is very tricky. Auditing code security is very very tricky. There's no way to actually have code that you know for sure doesn't and have bugs. Yes, it's very, but I think that what is sort of gives me some comfort is that first of all, yeah, all software has bugs complicated enough. This has been true undecided of the halting problem. This is true for all systems, you know, medical devices, cars, airplanes, somehow human society usually, well there's some really horrible catastrophic failures, but like people know to deal with this problem that there are some bugs.
01:23:35.114 - 01:23:43.274, Speaker B: So it's going to be the same thing. There's no way to completely resolve this.
01:23:49.114 - 01:23:50.234, Speaker A: Thank you very much.
