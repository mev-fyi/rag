00:00:00.200 - 00:00:28.470, Speaker A: Afternoon session, we'll have to talk. The first talk will be by Sheili. He'll be talking about scheduling problems. Okay, thank you, David. Thank you all for coming here. So, I'm going to talk about improved approximation algorithms for non preemptive scheduling problems using time indexed Lp relaxations. So we are going to focus on a bunch of problems, and here is a common set up for all those problems.
00:00:28.470 - 00:01:21.214, Speaker A: So, we are given a set j of jobs and a set m of machines. And each job j has a weight, and our objective is to minimize the sum of weighted combination time over all jobs j. So that is sum j over j sum j in j w j times cj, where cj is the completion time of j. So you can think of job as one interval on a machine in a solution, and the composition time of that job is right endpoint of the interval. So for this schedule, this red job has completion time four, and this orange job has completion time six. And this black job has completion time eleven. And our goal is to minimize the sum.
00:01:21.214 - 00:02:04.286, Speaker A: And before we talk about the specific problems we are trying to solve, let me introduce a very convenient notation introduced by Graham Ital, and it's called alpha beta gamma notation for scheduling problems. So, alpha basically denotes the machine model. So we can have alpha equals p. So for identical machines. So in this model, all the jobs, all the machines are identical. So for each job j, you have a size pj, and the processing time of j on machine I is just a pj. And we also have unrelated machine model here.
00:02:04.286 - 00:02:37.076, Speaker A: For every job j and every machine, you have a pij. That's the process in time of job j on machine I. So this matrix p can be arbitrary, and in between we also have a queue. So it's called a renaissance machine. And in this model, every job has a size, every machine has a speed. So the processing time of job geo machine is just a PGA divided by si, size divided by speed. And so beta will denote additional constraints we have for all those problems.
00:02:37.076 - 00:03:12.832, Speaker A: So in this talk, we are going to focus on three constraints. One is rg, so that says that a job J may have arrival time rj, so you cannot process this job before its arrival time. And we may also have precedence constraints. So we require j to precede j. That means J prime can only start after j completes. So those two constraints will make the problem harder, but the third one will make the problem easier. So it says all jobs are identical.
00:03:12.832 - 00:03:43.306, Speaker A: So without loss of generality, we can assume all jobs have size one. And the gamma will denote the objective function we are trying to optimize. And in this talk we are only going to focus on the weighted composition time. So here are our results, and first consider the identical machine model. So if you don't have precedence constraints, then you can basically get a ptas. So that's easy. So we will have precedence constraints for identical machine model.
00:03:43.306 - 00:04:54.850, Speaker A: So for the basic problem we get a two plus two long two approximation, which improves the previous four approximation due to munier et cell. And for the special case where all jobs are identical, the same paper gave a three approximation and we improved it to one plus root two. And if machine model is related to machine model, then Tudak and chimoise gave order of log m approximation, where m is the number of machines, and we improved this lightly by a log knock m factor. So then we consider the unrelated machine model. So in the problem of minimizing the weighted completion time in the unrelated machine model, the breakthrough result of benzos renewal sand gave a 1.5 minus epsilon approximation, improving the previous one approximation algorithms. But that epsanon is tiny, and we also get 1.5
00:04:54.850 - 00:05:48.764, Speaker A: minus some epsilon approximation. And this is also tiny. But one technical improvement is that our algorithm is based on a very natural lp relaxation for the problem, and which I'm going to define soon. So when jobs have arrival times, and the previous based approximation ratio is two, and we improved it to 1.78. Sorry, 1.8786. And those results are based on two papers, one joint work with Sanjin Im and one by myself. Okay, so a major, so in this talk I'm going to only focus on those two results, and the scheduling of identical machines with precedence constraints, and the scheduling on unrelated machines when jobs have arrival times.
00:05:48.764 - 00:06:39.438, Speaker A: And the major theme of all the results we have is the use of time indexed LP relaxations. So those are really natural IOP relaxations for those problems. But surprisingly they are not considered before explicitly in the literature, I think partly because of two reasons. One is all those previous results, they don't need these strong LP's. So the results can be obtained using some weaker LP relaxations. And the second, in practice, if you have those time indexed variables, the LLP size is going to be huge, but we use the time index LLP relaxations to improve all those results. So what is the general framework for this ArP relaxation? Well, it's very simple.
00:06:39.438 - 00:07:50.864, Speaker A: So remember, for every job j, we need to choose a machine I, and we need to choose a starting time s. So we will use xijs to denote whether job j is scheduled on machine I with starting time s or not. So it's convenient to think of this x I g variable is associated with a rectangle of height x ij for 8th to s plus p I g. Then you can see we require that the total height of all rectangles on machine I covering one time point should be at most one. So that means I can only have one job being processed at any time and across different machines for the same job, the total height should be exactly one. And also the composition time is just we take all the right points of the rectangles for job j and take the average where average is with respect to the heights of rectangles. And also we can capture the precedence constraints.
00:07:50.864 - 00:08:31.344, Speaker A: So there is a stronger set of constraints for this constraint. But in this talk we only use this. So this is sufficient. So we just require the completion time of j prime to be at least the completion time of j plus pj prime. Okay, so this is a constraint we are going to use. Okay, now we move to the two results we have. And you can see once we have this time indexed LP relaxation, and we know the previous results, and it's not hard to derive those results using the LP relaxations.
00:08:31.344 - 00:09:32.090, Speaker A: So first I'll talk about the unrelated machine scheduling when jobs have arrival times. So remember, in this problem we have unrelated machine model. Every job j has a pij on every machine I. So we have a arrival time rj for each job j. And so in the LP relaxation you can think of we have a rectangle for each machine and the total height of rectangles covering each time point. On every machine I is at most one, and across different machines for the same job you have total height one of rectangles. Okay, so our algorithm is actually based on the previous two approximation algorithms, and then identifying the loose part of the analysis and improve that by our time indexed LP relaxation.
00:09:32.090 - 00:10:24.250, Speaker A: So what is the two approximation algorithm using our LLP? So we first solve the LP to get a set of rectangles. Then for each job j, we will independently do the following. So remember, for every job j, we have a total height one of rectangles, and each rectangle is indexed by machine I and starting time a. So I'm going to randomly choose one according to this distribution. So let ij sj to be the index of the rectangle for job j. And then conditioned on this rectangle, I'm going to choose the offset tau j, which is uniformly distributed between the starting point and ending point of this rectangle. So this is my tau j, and after I selected ijsj and the tauj.
00:10:24.250 - 00:11:06.212, Speaker A: I can just schedule the jobs machine by machine. So for each machine I, I will schedule all jobs with ij I on this machine I. So the schedule is as follow. So I just pretend this taoji is just arrival time, and then I do this greedy scheduling in this order. So when a job comes, I will schedule it as early as possible. So that means this job j either starts at time tao jpeg when the previous job companies. So for example, here I schedule red job here, taoji is here.
00:11:06.212 - 00:11:29.676, Speaker A: Black job I scheduled here, Taoji is here. So I schedule immediately after the red job completes and the orange job I scheduled here. And this job I scheduled here. So this is greedy schedule. Question. Are you going to say something about how you solve the time index? Healthy relaxation. Okay, for now, let's just assume the t is polynomially bounded.
00:11:29.676 - 00:11:43.628, Speaker A: So by losing a log one plus epsilon factor, you can reduce the number of different time points to polynomial to linear. Yes. People did use this combination before. Yeah, not for this particular problem.
00:11:43.716 - 00:11:45.316, Speaker B: This particular problem holds.
00:11:45.380 - 00:11:54.442, Speaker A: Not for this particular 1999 or something like that. Yeah, not for this particular problem. Really? Do they have improved results?
00:11:54.538 - 00:11:56.574, Speaker B: No, it's worse. The bounds are worse.
00:11:57.114 - 00:11:58.210, Speaker A: It's two, right?
00:11:58.322 - 00:12:02.374, Speaker B: It was. No, it's worse than two. This was the first constant was.
00:12:02.794 - 00:12:25.606, Speaker A: Oh really? I thought they use the non preemptive version of it. It's not preemptive version. Maybe. Okay, I will check that. Okay, so this is the algorithm. And so what is the two, what's analysis for the two approximation ratio. So, we are going to analyze job by job.
00:12:25.606 - 00:13:17.908, Speaker A: Focus on each job j. I will analyze the expected composition time of job j, and I will bound it by two times the fractional composition time. And so, how can I do this? Well, I first fix this rectangle and the offset for job j, and I'm conditioned on those three parameters. So, the completion time cj will be the sum of three parts. So, first part is actually the total length of jobs j prime that are scheduled on machine I, but scheduled before j. So that means with tau value smaller than tau j, the second part is the total length of idle times before tau j. So that will contribute to the completion time of Cj.
00:13:17.908 - 00:13:51.674, Speaker A: And finally, it's just p I j, the length of j on machine I. So it's not hard to bound the first term by tau j. So you just consider the contribution for each rectangle, and each rectangle contribution is the total area of the rectangle or the part before tau j. So at each time, the total height is one. So we get a tau j bound. And the second term, we can also bound it by tau j. That's the total length of idle time before tau g, of course, is most tau j.
00:13:51.674 - 00:14:34.306, Speaker A: So if you can see the two pounds, then the expected cj under this condition, that most two tau j plus pij, and the expected value of tau j conditioned on sg and ij, is this sg plus pij over two. So it's a middle point. So sj here, sj plus p I j here, middle point. So if you replace tau j with this, you will get two sj plus pig, which is what we needed. Well, what we need. So finally we have the answer. Okay, to improve this bound, let's just check what we can improve for the second term term.
00:14:34.306 - 00:15:08.496, Speaker A: So let's just assume this machine I is fully packed. So at every time you have exactly total height one of intervals. Otherwise you can just add some dummy rectangles. So maybe this bound just by tau j is too pessimistic. That basically says that all the time points before tau j are idle. And you can see, suppose this is tao j here, the rectangles are something like this. Then you hope to see many busy time snorts before tau j.
00:15:08.496 - 00:15:37.944, Speaker A: So if the rectangle lengths are very small, with some probability, you are going to see next to this rectangle and the tau j will be here. So you can see with reasonable probability, you will have a reasonable length of busy snorts before tauji. So that's okay. And it's not hard to see. The only bad case is this. So j is here, tau j is here. But all the rectangles are very long, starting at time zero.
00:15:37.944 - 00:16:07.088, Speaker A: Ending time is very big compared to tau j. Then with high probability, all those rectangles, the tau value will be after tau j. So the total length will be either length will be tau j because the tauj is here. All those jobs are scheduled after j. So this is bad. And so that will give us the idea for improvement. So you can see this job j must have small length.
00:16:07.088 - 00:17:08.660, Speaker A: All those job j have a big length. So what we are doing right now is I'm trying to increase the probability of giving scheduled before those jobs by shifting the mass of the distribution from the left to the center. If you shift some mass from the left to the center, j will be more likely to be scheduled before those jobs. But on the other hand, I need to not increase the expected value of tau j conditioned on Ig and Sga. Remember, originally sj plus pij over two I still need to make this bound not increase. So it's not hard to prove that if I just have this distribution. So I cut the left side and cut the right side, I randomly choose tau j between.
00:17:08.660 - 00:17:58.806, Speaker A: Then it will improve this fact of two. But to do a better bound, what we do is we parameterize this by a distribution. So we choose a theta j from some distribution, and the net tau j be s j plus theta j times pij. Then we express this, either the two terms here, we bound the two terms here by this form. So the sum over all rectangles are the contribution of r. Then it suffices to just bound the expected contribution of r to the integral solution divided by the area of r before tau j. So the total here over all r will be tau j.
00:17:58.806 - 00:18:40.614, Speaker A: The total here overall will be the first two terms. Okay, so this will depend on theta, and we discretize this distribution theta and using Lp to find the best theta. But eventually we will find a good fit for this distribution. So, we will get analytical proof for the approximation ratio without using the program. So, here is what the distribution looks like. So, from zero to this point is increasing function. So it's almost linear, but it's a quadratic with very small quadratic term.
00:18:40.614 - 00:19:07.652, Speaker A: And when theta is after, this is zero. So that coincides with our idea that we should shift mass from the left to the center, from right to the center. So to sum up, we have 1.83 approximation algorithm for unredated scheduling when job have arrival times. So, question for this part, do you.
00:19:07.668 - 00:19:10.104, Speaker B: Know anything about lower bounds on the integrality gap?
00:19:11.164 - 00:19:26.864, Speaker A: Integrated gap? No, we don't know. So the problem is APX hard, and so it should be at least the hardness. But other than that, we did not try.
00:19:28.494 - 00:19:31.126, Speaker B: And what kind of constants come out of the APX hardness?
00:19:31.310 - 00:19:32.034, Speaker A: What.
00:19:32.494 - 00:19:37.046, Speaker B: And, you know, what absolute, what is the value?
00:19:37.150 - 00:19:44.154, Speaker A: I don't know. I think it's very small. When you say APX hard, you don't expect to be very hard. The very large is a constant.
00:19:46.574 - 00:19:59.734, Speaker B: Okay, if there are no weights, but there is still preemption, what is something better known? I'm just asking if there are no weights but preemption.
00:20:01.554 - 00:20:25.788, Speaker A: No waits, there are no weights, but there are still release times, released times. I think if you think about it, may still be hard. Yeah, that's for different problems. You have weights, but you don't have arrival times.
00:20:25.876 - 00:20:33.340, Speaker B: So you're asking without release dates and without weights. No, no, no, with release dates, with.
00:20:33.412 - 00:20:59.964, Speaker A: Release dates, but non preemptive. I don't think it's trivial. I think it's still np hard, but I don't know what's the best ratio. This is just the first pile. Okay, what is 1.5? Yes. No, no, no.
00:20:59.964 - 00:21:34.380, Speaker A: If you have arrival times two, yeah, but. Okay, I think I need to be quick for the second part. Two plus two non two approximation for identical machine scheduling. But we have precedence constraints. So this is difference from the previous problem. So we have identical machines and we have precedence constraints. We may or may not have arrival times.
00:21:34.380 - 00:22:15.228, Speaker A: For this it doesn't matter, but for synchronicity, we just assume we don't have arrival times. So since we are in the identical machine model, we can just remove the index I. So we just need xgas right now. So each xjt. So each xgs is just a rectangle from ace to 8th plus p I j with height xgas. And across each time point we have a total height of m. And for all jobs, for each job, the total height of rectangles is exactly one.
00:22:15.228 - 00:22:54.584, Speaker A: So this is the picture you should have in mind. And so first we recover the four approximation due to munia, and then we try to see what's not tied in the analysis and we will improve it. So we solve the Lp, and then for every job j in non decreasing order of this quantity. So Cj minus Pj over two. So cj is a fractional composition time of j. In the LP solution, pj is the length of job j. So we have identical machines, so there's only one Pj.
00:22:54.584 - 00:23:32.226, Speaker A: And then we schedule this job j in a greedy manner. So we schedule j as early as possible, subject to two constraints. Firstly, machine capacity constraint. So that means at any time, the total number of intervals should not exceed m, and the second one is precedence constraints. You should start, you should respect those constraints. So, for example, those jobs are scheduled. I need to schedule this red job, but I need to schedule after this orange job.
00:23:32.226 - 00:24:04.294, Speaker A: So I can only start it here. But m equals three, I should find the first times, not where. If I add this interval, the congestion remains three. So this is the time I schedule this red job. Okay, this is the simple algorithm and it gives you a full approximation. So what's the analysis? So, let's use Tl Cj to be the composition time of j in the integral solution. So then we break Tl Cj into two parts.
00:24:04.294 - 00:24:29.896, Speaker A: The I is the total length of idle times naught before Tl Cj, b is a busy times naught. So when I say busy, I mean all machines are busy. When I say idle, so that means at least one machine is idle. That's the definition. So idle times naughts, I can bound it by two cg, so that's known. And Bz, I can also bound by two cg. So that gives you a full approximation.
00:24:29.896 - 00:25:11.732, Speaker A: But I'm going to show this proof for Bz times naughts. So it's actually very straightforward. You have this picture of rectangles in mind. So what's this? CJ minus PG over two is the horizontal coordinate of the mass, center of rectangles for j. So Cj is completion time, CJ minus PJ is starting time, CJ minus PJ over two is center. And consider all jobs scheduled before j. Those jobs should have center of mass before this, CJ minus PJ over two.
00:25:11.732 - 00:25:46.432, Speaker A: So if we can consider all those rectangles, the horizontal mass center should be before CJ minus PJ over two. But at each time point we have a total height of m. So you can see the total area is at most two times this times m. Just the center of mass is here. Every time point you have height m, so you cannot start before time zero. So that's the total area. And by the definition of bz times naught.
00:25:46.432 - 00:26:16.814, Speaker A: So this divided by m is the total length of bzn before TLD Cj, which is at most two cj. Okay, so here comes our modification of the algorithm. So what we do is we will choose a theta randomly between zero and one. Two. And I schedule jobs in this order. So, Cj minus PJ plus theta pj. So that's theta fraction from the beginning of the starting time for j.
00:26:16.814 - 00:26:47.682, Speaker A: So again, we will try to break into two parts for idle time. Snot we can show the upper bound one over one minus theta times Cj. So this improves over one over two. And but for busy time, we can only get one over theta times CJ. So if you want to take the base, theta is half and you will only get four. So let's try to see why we can only get one over theta times Cj. So here is the simple example.
00:26:47.682 - 00:27:16.834, Speaker A: We think of this job. J pj is very small. So Cj minus one minus theta pj is roughly Cj. But for all the other jobs, and roughly theta fraction of the job is before this cj. One minus theta is after CJ. So this job will start at time zero and ends here. So you can see the total length is one over one minus theta pj.
00:27:16.834 - 00:28:09.124, Speaker A: But you can see the crucial observation is that this cannot be bad for every theta. So indeed, what we will show is that even if we randomly choose theta between zero and a half, b will be at most two cg instead of integral of one over theta, which is infinity. So combining this, we get two for the busy time, but for idle time is the integral of one over one minus theta. So it's two norm two. So that improves the four approximation. So to sum up, we have a two plus two norm two approximation for scheduling identical machines with precedence constraints. So this is the algorithm, so there are few open problems.
00:28:09.124 - 00:29:02.904, Speaker A: So first, can we get a better approximation for the two problems we studied? So for the unrelated machine scheduling, we have Apx heart, and for this identical machine scheduling with precedence constraints, we have a ugc two hardness. And also can we improve the unrelated machine scheduling if we don't have arrival times? Right now we have 1.5 minus c, where c is very small. Can you get an approximation with reasonable c? Also, can you improve the re enacted machine scheduling when jobs have precedence constraints? Currently it's log m over log log m. Okay, thank you. That's the end of the talk. Would you take a quick question? Okay.
00:29:04.204 - 00:29:10.250, Speaker B: For the first open problem you mentioned, if I allow free, what's the best constant? Or is your.
00:29:10.322 - 00:29:20.826, Speaker A: Oh, that's also in our paper, preemption. Actually the ratio is even worse. We get 1.9991. So previous result is two completion time.
00:29:20.890 - 00:29:25.074, Speaker B: If there are release times in totally problem becomes easier than harder.
00:29:25.234 - 00:29:51.044, Speaker A: So we make preemption with. It's because the LP we are using? No, because of the LP. It's easy for our solution, but it's also easy for the optimum. So our LLP only works for the non preemptive version. If you have a preemption, you don't have rectangles. Other questions.
00:29:53.664 - 00:29:54.964, Speaker B: There. I think the.
00:29:56.864 - 00:30:23.204, Speaker A: Easier problem is the completion as well. Oh, sorry. Yeah, yeah. But they're equivalent up to a constant factor. Yeah, there's a recent hardness result. Assuming some hardness of some k partite graph problem, you can get a super constant, but it's a very small super constant. Okay, thank you very much.
