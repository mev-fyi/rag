00:00:00.080 - 00:00:01.276, Speaker A: Daniela Kaufman.
00:00:02.254 - 00:00:49.674, Speaker B: Thank you. So, I will present today two projects that we have at T Oween, and it's joint work together here with Nikolaj, who is in the audience, and I will talk about MC Sat based approaches for solving nonlinear modular arithmetic. So, what is a typical problem that we want to solve? So, we have given a set of polynomial equations and also disequalities. They are nonlinear. So we see that here we have an x squared, we have monomials with x times y, and we want to solve the solution system over a finite domain. So, in this case, in this example, I want to solve it over the finite field f five. So we take the solutions modulus five.
00:00:49.674 - 00:01:19.230, Speaker B: And I want to solve this polynomial system now with you, because I will use it throughout the talk. So this will be kind of our running example. So I really want to familiarize you with that. Yeah. Since we are talking about modulo five, it's actually, we can write down the multiplication table so that we can really work with that. So how would I solve that? So, the first polynomial is univariate. We have only one variable in it, x squared.
00:01:19.230 - 00:01:52.588, Speaker B: And then we check our multiplication table for which cases x squared is equal to one. And we see we have here two cases. The first one is for one, and the second is one for the value is for the value of four. And let's take the first one. Let's say we fix x is equal to one, and then we plug that into the second polynomial, and we see that we actually get. Now. So this second polynomial evaluates now to y minus y minus one is equal to zero, which actually gives us minus one is equal to zero.
00:01:52.588 - 00:02:21.520, Speaker B: So we have a conflict there. We kind of move back. We see our choice for x was wrong. So let's maybe try, then the other one. Let's set x is equal to four. We plugged it again into the second solution, and this is the second constraint. And then we get, we can solve that, and we see that, indeed, we have to set y is equal to two, and with both of these values, can then be plugged into the third constraint, and even that is fulfilled.
00:02:21.520 - 00:02:57.274, Speaker B: So we see we have a solution for our polynomial system, which is x equal to four, and y is equal to. Yes. In general, solving polynomial equations is one of the oldest and hardest problems in mathematics. And there's been quite a lot of work by mathematicians, really, for a long period of time to solve these questions efficiently. And in the case, the domain that we consider for our polynomial equations is an algebraic closed field. Then this problem is actually decidable. And we can do that by using Grignard basis for that.
00:02:57.274 - 00:03:44.262, Speaker B: But unfortunately, finite domains are not algebraically closed. We cannot throw grammar bases directly on it. Yeah. So today I talk about really finite domains. And the reason why we are currently interested is because nonlinear polynomial reasoning over these finite domains is currently of interest in formally verifying reptosystems, especially when we talk about finite fields. So, the one example that we had, this is, for example, used to model zero knowledge proofs or elliptic cryptography. And the second domain that I also will consider in the talk is actually over when we take modal load two to the power of k, since actually we have bit vector solving.
00:03:44.262 - 00:04:12.178, Speaker B: That's for example. Yeah. So, as I said, a lot of work has been done on solving polynomial constraints. And until recently, like, this was really the domain of mathematicians. And more precisely, this was the domain of computer algebra, and a lot of. So there have been algorithms devolved, like, as I said, grammar basis. So they are really powerful tools and algorithms.
00:04:12.178 - 00:05:07.114, Speaker B: They are implemented in powerful tools, and they compute algebra systems like mathematica, singular Saige and so on. These algorithms are powerful in finding all solutions of a polynomial equation system, but they have a downside. So usually these algorithms have a high computational overhead. So, for example, grammar basis algorithms are actually double exponential to compute. And in general, we, for our use case, we are typically not interested in finding all solutions of the system. Actually, we want to find only one solution, or we want to know whether there is no solution at all. This is why we take a look why we kind of use the concept of model constructing cytos viability, or MCSAT for short.
00:05:07.114 - 00:05:50.964, Speaker B: This was invented around ten years ago, and this approach allows me to find satisfiable instances of polynomial arithmetic by combining a CDCL search with some theory knowledge, with some theory propagation. In our case, this will be algebraic decompositions. Today, I already hinted it a little bit. I will talk about two domains. So the first part of the talk, I will focus on constraints over finite fields. As already hinted, it's not algebraically closed, so we cannot applied grimoire basis directly. The constraints we consider in this case are actually equality and disequality.
00:05:50.964 - 00:06:32.538, Speaker B: The reason is that infinite fields that you cannot totally order the elements, so it doesn't make sense to write down inequalities. This is the project, we call it FF Sat. And the tool that we have there is kind of a, we have just a prototype. And the second part will be the constraints over two to the power of k. So the split vector reasoning, actually, this domain is not even a field, so it's a finite commutative ring. And I will explain later why this actually makes things more complicated. But here we can consider more constraints.
00:06:32.538 - 00:07:33.454, Speaker B: We also now will talk about inequalities. In addition, and also we manually introduce now the overflows of defined domain. And here our project is called Polisat, and polisat is invited implemented as a theory solver in set three. So the question is, what is an inequality model or two to the power of k? So actually we restrict here really the solutions to the power of k. Do not consider the overflow. So we say we have a finite domain, we compare our numbers one to two to the k, and when we have an overflow, we additionally add constraints. But before I go into the domains, let me briefly introduce the concept of the framework of McSAT to you.
00:07:33.454 - 00:08:30.316, Speaker B: As I already said, this is an abstract CDCL decision procedure. We have heard about CDCL a couple of times already this week, and in addition to the Boolean search engine, we integrate reasoning over the theory behind it. So in our case of definite domains, and this framework allows us to incrementally construct the models while searching and the propagated literals, all our decisions are justified by model assignments. And so far, so there have been a couple of theories already have implemented in this MC Sat framework. So, for example, for nonlinear arithmetic constraints of the reals, or also for linear integer constraints. And also there has already been a little bit of some work on bit vectors. And the idea, the basic idea is that from a given set of clauses, we generate a trail with the decided and propagated literals.
00:08:30.316 - 00:09:18.244, Speaker B: In addition to the theory, variable assignments then leads to one of the two terminal states answered or subtract. And just as a note here, when we consider our input as a polynomial system, so as a system of polynomial equations, then actually this equation, each equation can actually be seen as a unit closer. The main components then of this framework are of course the trail where we record all the assignments and reasons. And for each variable in our polynomial system, we keep track of the variable values. So these are the values that can be assigned. Then at some point we might reach conflict. So this is a set of constraints that will contradict our train.
00:09:18.244 - 00:10:28.904, Speaker B: And then we do some conflict analysis where we learn a new constraint with respect to our theory to avoid the same that we avoid, to avoid that we reach the same conflict in the future. For us, our trail has a kind of a special shape. So what we do is we, when we talk about variables x one to xn we consider them ordered, so x one is smaller to xn, and then also our trail kind of will be ordered, namely in such a way that when a literal f one g one hl enters the trail, that actually all variables in this literal or in this constraint have been assigned except for the largest one. So this means that first we have kind of the univariate polynomial constraints over x one. Then we make the variable assignment for x one and then the second one. These constraints can then talk over x one and x two, and continuing like that. And this guarantees us that all of these are kind of then univariate polynomials.
00:10:28.904 - 00:11:17.636, Speaker B: Yeah. We can put literals on a trail first with kind of regular Boolean propagation. Then we have a clause, for example, c one, and we see that the first two literals are already in our trail in the negated form. Then of course, we know that we have to put third on the trail, and then this clause will also be our justification why we put edge on the train. And in addition to that, McSAT allows us to propagate the theory from the theories from all the previous variable assignments. We know that a certain literal edge cannot hold on the trail. Then we know that we can put not the negation of the constraint on the trail and the per.
00:11:17.636 - 00:11:53.814, Speaker B: And what we now have to do is to generate an explanation clause that justifies this decision. Yeah, I will deny an example for you. This was our example of the, of the first slide. So it's here again, but I've now considered only the first two constraints because the one didn't have inference. So we see the first constraint is univariate. So I put it on the trail. As we have already seen, possible values are x equal to one or x four.
00:11:53.814 - 00:12:40.574, Speaker B: Let's make the assumption, I do the same decision as before, that I now set as x is equal to one. Then our second constraints becomes univariate. With respect to this partial assignment, I put it on the trail, and then I reach the conflict. And so from this conflict, then I do the backtracking, and then I generate an explanation clause. I've written it down here, just, just throw it at you. This explanation actually says that we shouldn't set x equal to one. And so, to satisfy the second constraint, we now resolve using the stand explanation clause in backtrack to assign a different value of x.
00:12:40.574 - 00:13:22.812, Speaker B: So. And that's actually the key ingredient that we have that we need to have in our McSAT framework, namely, how do we generate this explanation clause for our theory. Yeah, and now. So let's go into the theory part. So first I will talk about the finite field case. Yes, it's usually a field is set of elements that is closed under addition, subtraction, multiplication. And for each element we have an inverse.
00:13:22.812 - 00:14:13.854, Speaker B: And finite field means simply we have only a finite amount of elements in our field. And now we want to generate an explanation, explanation function for that. So the general idea of this is when we have now a train, we have some very variable assignments up to k minus one. Then we have some literals on it. This talk now over variables x one to xk, and up to that point we are fine. This means we have still the possibility to assign a value to x k such that all these literals are true. But now we want to add another constraint, g on the train.
00:14:13.854 - 00:15:13.464, Speaker B: And now such an alpha case or such an assignment to the variable XK doesn't exist anymore. Now we have the conflict, and we need to resolve this conflict. We need to learn that we have, need to take a different assignment for variables x one to xk minus one. And the idea that we have is we take all the constraints that we have on the trailer, speak over xk plus the one that gives us the conflict. And in all these constraints, we eliminate now the variable XK. So we generate a polynomial set over the variables x one to xk minus one. And we put it in such a way on our trail that in the future, all the assignments for this generated set of polynomials gives us false, because this ensures that we do not run into the same conflict again.
00:15:13.464 - 00:16:07.238, Speaker B: And this will then be how we generate our elimination process. So we include this generated set of polynomials together, clue it together with the other constraints to get our explanation. Yeah, so I speak here about let's do some variable elimination. And this actually means that from a polynomial system, we kind of need to project the solutions over the variables x one to x k into the, into a different field where we have only variable x one to x k minus one. And I always like to represent this actually graphically. So think of that like our original polynomial space would be talk about variables like in the three dimensions. So x, y and z.
00:16:07.238 - 00:16:42.204, Speaker B: And we want to now get rid of the set variable. This means we project the solutions of the curve here down into the dimension where set is equal to zero. So down into the plane here, so the xy plane. And this would actually mean that kind of, you put a piece of paper in the xy plane, we use a flashlight, shine from it on the path, and then kind of the shadow will be our protection. This is a projection. This is in our case the unit circle. And that's what we want to do with this variable elimination.
00:16:42.204 - 00:17:28.652, Speaker B: And now we have two kind of two possibilities. So the first one is we have a tray, and then already the first, or like a single new constraints, is already incompatible. So we get already a conflict from a single constraint. You see, this is again our example that we've seen now multiple times. Because we have the first constraint, we set x to one, and then we have the new constraints, and we saw that this is incompatible. And what we then do is we take a look at this polynomial here. So the first part, the left side of the equation, and we write it down a little bit differently.
00:17:28.652 - 00:18:14.902, Speaker B: Namely, we write it down now as a uni variate polynomial in Y. So our coefficient of y is now x minus one. And what we do is for the future, we want to exclude all assignments with the same coefficient evaluation. So in our case, for our current assignment, x minus one evaluates to zero. So we want to exclude all future coefficients where x minus one minus zero should be unequal to zero. This is now a little bit too much for the small example, but in general, this would look like that. So we have a new constraint, we write it down in terms of the variable that we want to eliminate.
00:18:14.902 - 00:19:14.614, Speaker B: Then we evaluate all the coefficients, so these polynomials in x one to x k minus one, and we exclude these polynomials minus different assignment from our in the future. And this actually ensures that we exclude the current assignment of a single polynomial constraints. So it's fine, but it's not really doing much. So it includes everything. It excludes at least the current assignment that violates a single constraint. But actually when we have more constraints, what do we do then? So we do not want to check kind of iteratively do this coefficient based exclusion overall single constraints. We want to find a more general approach.
00:19:14.614 - 00:20:06.044, Speaker B: One way to do it would be to use the theory of Grubner basis, because when you have a grobler basis with a lexicographical term ordering, then this has the projection property. What we could do, introduce fresh variables to get rid of all the inequalities. Then we have only the set of equalities, because grammar bases only talk about equalities. But as I said in the beginning, grammar basis require an algebraically closed field. What we do not have. This means that usually when the grammar bases algorithm would solve this polynomial system, we kind of need to tell it which solutions are interesting for us. And we do this by adding so called field polynomials.
00:20:06.044 - 00:21:00.872, Speaker B: And then we generate the k minus one elimination idea. In theory, this would sound nice, but I already said in the beginning, also said in the beginning, the grammar bases are double exponential. And especially these field polynomials, they cause a lot of overhead during this reduction, especially when certain assignments are already excluded, because then suddenly you do not have here this nice structure, but you really expand it and it gets messy. So that's one way that we do not want to do it. Instead, what we want to do is we have a look at the polynomials and we exclude common factors of these polynomials. And especially when we have this conflict, all these polynomials are univariate. So we do not have to talk about this whole elimination ideal.
00:21:00.872 - 00:21:44.864, Speaker B: Instead, we can deal with univariate polynomials and we want to exclude common irreducible factors of that. And now I'm throwing another algebraic concept onto you. It's called sub resultant regular subgenres. I'm not going into the details here, so don't worry. But in general, what it does is it allows me to compute the GCD of two polynomials when I have already a partial assignment and I take into account this partial assignment. You can think of it really right here in quotation mark, because it's somehow related, but not really. But if you're familiar, if you know euclidean division algorithm, that's kind of the same procedure that we do here in euclidean division algorithm with respect to our current assignment.
00:21:44.864 - 00:22:34.414, Speaker B: And I will show you an example to at least show you what's happening. So assume now we have two polynomial constraints, f and g, so the one is equal to zero, the second one is inequal to zero constraints. We have our current assignment on the trailer, x is equal to three, y is equal to one. And we see, so when we plug this in and solve it, that f and g are incompatible with our current trail, because for f to be true, set should be equal to two. If we set z equal to two in t, then the constraint is one. So what we do now is we compute. Now this is sub resultant regular subchain of f and g.
00:22:34.414 - 00:23:21.324, Speaker B: Magically this gives us this polynomial. And what we see actually here is that the second polynomial doesn't contain z anymore. It only talks about x and y, and that's what we want, because this is not our projected polynomial. So we learn now that we should falsify this polynomial. And when we plug in solutions, we see that in addition to the current assignment that we have to trade, we can even exclude now more assignments on the tree. So that's actually how our tool, or our Python prototype is currently implemented. We iteratively put, we put the literals on the trail.
00:23:21.324 - 00:24:19.052, Speaker B: If we find this a conflict with one polynomial then we do this coefficient based projection. If we have more polynomials that causes a conflict then we should do this reduction with this projection of the sub, resultant regular sub chains. We compared our approach so far with really discriminant basis algorithm. And so the grafted benchmarks here are crafted in such a way that they have a lot of solutions. All of them are satisfiable for the random, we really take random variables. So q is the number of is the field size, n is the number of variables, c is the number of constraints. And we see that especially for this random benchmarks we are comparable with, we can compare with grimoire basis algorithms but actually now the workforce is really to make this scalable.
00:24:19.052 - 00:24:43.774, Speaker B: So especially here in Minvin we have a field size of 211, we can only do kind of a few variables and then a few constraints yet. So that's now our current task to really optimize it to make this scalable. Yes, this was the first part of my talk. Are there any questions for this part?
00:24:52.294 - 00:24:54.394, Speaker A: Thanks. Hi.
00:24:54.814 - 00:25:21.226, Speaker C: In the explanation function what is specific to the fact that you are in a prime field? I mean in the previous slides a lot of what you presented looked like it could be applied to wherever you can apply those drop down bases or the variants that you have. If you're not algebraically closed, where is the moment in that explanation where you actually doing the module or the overflow?
00:25:21.330 - 00:25:50.870, Speaker B: So in kind of in german basis. So here this would be the field polynomials. So there we restrict to this module and also here this is kind of hidden here. So I didn't include it. But also here in the sub result and regular sub chains that the modulo is included in this, in this computation of the, of the SRS that I did not show you. How, how difficult is it does the.
00:25:50.902 - 00:25:52.594, Speaker C: Computation of the SRS?
00:25:53.654 - 00:26:17.598, Speaker B: So for the problems that we consider so far it's, it's, it's not that hard. So we use sage as an underlying system to compute it. So there we are, we are, we're pretty efficient. But I have actually, I have no idea about kind of proof complexity wise. What, what would be the class?
00:26:17.646 - 00:26:22.742, Speaker C: Yeah, I mean how does it grow, how does the difficulty grow with, so.
00:26:22.798 - 00:26:35.674, Speaker B: The polynomials, you mean these are these days they small? So this day and now we really see kind of no real explosion of the polynomials in our probe.
00:26:39.114 - 00:26:44.994, Speaker A: So the first one, which was the most simplest one making the coefficient equals zero.
00:26:45.114 - 00:26:45.814, Speaker B: Yes.
00:26:47.234 - 00:26:52.294, Speaker A: Is it removing just one point or more than one point.
00:26:53.154 - 00:26:55.018, Speaker B: Most of the time, just one.
00:26:55.186 - 00:26:55.586, Speaker A: Okay.
00:26:55.610 - 00:27:15.436, Speaker B: So, I mean, maybe I show you this example. This is really an easy example. No, actually it can remove more when, when our polynomials, this constraint is more complex and this polynomial. So here the coefficient has more than one solution in the finite field. Then it, then it can remove more too. Yes.
00:27:15.540 - 00:27:27.988, Speaker A: Right. So the other part is like, to make it more practical, we need to have tricks of checking which values we can pick.
00:27:28.156 - 00:27:38.022, Speaker B: Yes. So I think what I would really now like to investigate is variable ordering. Okay.
00:27:38.198 - 00:28:04.184, Speaker A: No, I meant the values, not the, which variables to assign. Like if you have a variable x. And what are the feasible values? Because let's say you removed one point, how do you, like, make it compact? You don't want to store it like in a list that these values are not suitable.
00:28:04.264 - 00:28:11.444, Speaker B: So that's actually what we kind of do in our, in the second part, in our second projects and polisat. Yeah. We store it as intervals.
00:28:11.944 - 00:28:12.804, Speaker A: Okay.
00:28:18.264 - 00:28:42.424, Speaker D: So a question actually on slide 15, which is, I think, too ahead. You made some comment really quick, and I think I missed it, which is saying that these field polynomials, in the context where some values have already been excluded, have a much less tractable representation. Do I remember that comment? Right. And could you elaborate on it?
00:28:42.764 - 00:29:01.314, Speaker B: Yes. So what I meant with that is, so this would tell us, like, x is equal, for example, in x, when we, the final field model, u five, this polynomial then tells us, I can take values 01234. But what's the case when I already knew that I cannot assign four?
00:29:01.654 - 00:29:05.914, Speaker D: So your thought is, in that situation, you would actually build a different so called field polynomial.
00:29:07.374 - 00:29:21.024, Speaker B: Then I would divide this polynomial by x minus four, for example. And then kind of, I need to expand this x times x minus one, times x minus two, times x minus three. This would then be my new field polynomial.
00:29:21.104 - 00:29:25.800, Speaker D: Gotcha. And your thought is to do that explicitly, or you're saying that's what happens implicitly inside the grubner basis engine.
00:29:25.872 - 00:29:38.984, Speaker B: So we saw, like, so when, you know, our previous works and previously we worked with this gramular basis, and there we actually saw that what's happening inside our solver is that this expansion happened, and then it got stuck.
00:29:39.064 - 00:29:47.114, Speaker D: Got you. And then, actually, I had a question about the table that you showed us as well. I was just trying to understand what the columns are. I think I get ff stat. That's what you just told us.
00:29:47.154 - 00:30:17.868, Speaker B: Sorry. So that's ours. This is Grimer basis with respect to lexicographically variable ordering. And this is grammar basis with respect to a degree, reverse lexicographic ordering. And what you see here is that kind of, with degree based grammar bases are actually better than the lexicographically, but from the lexicographic, they have the projection properties. So this is kind of the case where we can read off the solutions from the grammar basis. You usually cannot do this with a degree based gotcha.
00:30:17.916 - 00:30:22.184, Speaker D: So those are like pure garner basis. That's not MCSAT with a coronary basis.
00:30:22.644 - 00:30:27.340, Speaker B: So this is really very. Throw the whole polynomial system to the polynomial base.
00:30:27.372 - 00:30:28.504, Speaker D: Got you. Thank you.
00:30:31.324 - 00:30:39.824, Speaker A: In your example, q is prime, but what if q is like 64? How do you represent the values of the field?
00:30:40.914 - 00:30:52.954, Speaker B: I mean, q is 64. So then we are not talking about a finite field. Then we have this kind of bit vector reasoning. So this would be the second part of my talk. And there we, there is a field.
00:30:53.034 - 00:30:57.934, Speaker A: I mean, q is a prime power in a finite field, right.
00:30:59.514 - 00:31:18.514, Speaker B: Then we represent that. So in the, in the intervals. So, as I already set to Ahmed. So then we have this intervals of the possible values, and this is. So we use Saige, as in our implementation, sage is dealing with.
00:31:22.974 - 00:31:43.264, Speaker D: I have one more question, actually. Can you restart? I mean, it's just a trail with a bunch of decisions, and you have recent closes of why something happened. You can ostensibly keep on the recent closes and just, you know, restart and. Right. And pick different polarities. Pick different variables.
00:31:43.424 - 00:32:42.330, Speaker B: Yes. In FF, we currently do not have this restraint, but I think polyth we do. We'll talk, move on now to the second part. So, where we now have the reasoning over the bit vectors, and our tool is now called the polysat. I will skip over some parts, and we already heard this week. So kind of the reason why we're interested in that is that the need that we want to reason about large bit vectors, or for example, 265 bit vectors. So why can't we use our stuff that I just showed you and throw it now into polycythemia? The reason is because we do not have a field anymore, because now we are talking about the finite commutative ring.
00:32:42.330 - 00:33:23.880, Speaker B: So a lot of the computations that work in a finite field do not work for bit vectors. One case would be, for example, we cannot conclude from x and y greater equal to zero, that x times y is also greater than x. The reason is because now we have this overflow constraint, or also kind of, now our field has zero divisors. So from x y, both are equal to zero. We cannot conclude that the product is also not equal to zero and also kind of the usual inequality normalization. So what you would do from x small equal to y, you bring both to one side. This also fails.
00:33:23.880 - 00:34:20.924, Speaker B: This is actually an example when we have for example x plus three is small or equal to x plus y modular two to the power three. If you would bring it to one side, this would give us then a constraint three less or equal to y. So then we get y can take the solution 34567. But if we for example have already x is equal to two on the trail set, then we see that this constraint can only work anymore for y is equal to three, four, five. So we really need to be careful what we are doing. Yes, so far solving approaches for bit vectors have been a bit fasting or in passing, but already there has also been some work on MC SaT based approaches and polisat goes into direction. So where we search really for assignment to bit vector variables.
00:34:20.924 - 00:34:58.470, Speaker B: Yeah, so polysat receives this contraction of the bit vector constraints. And also as before, we want to have the output sat or unsat. And so we want to search for modeling this input constraints by incrementally assigning the speed vector variables. And this has been already asked in the question. So we need to keep track of the variable values and then also generate. This adds limits on demand. Yeah, so far these are kind of the bit vector constraints that we allow in polysat.
00:34:58.470 - 00:36:04.078, Speaker B: So we have the inequalities with overflows, some bitwise constraints, for example like bitwise and then shifts and clauses, or this function of constraint literals. And by re reduction we can generate a bunch of other constraints like equations, inequalities, bitwise negation, bitwise or, and also talk about quotient. So the question is what's, what's actually this, this omega notation says so here it's with the asterisk. This means that the multiplication between p and q can overflow. So we really say that we consider that this is larger than two to the power of k so that it kind of wraps around. Again, I'm speeding up a little bit. So as also in polysat is kind of McSat based approach where we have the Boolean values and we also assign integer values to the big vector variables with the same components.
00:36:04.078 - 00:37:13.814, Speaker B: I am jumping over this example. The only thing that I want to mention here is that now we have different ways to talk about conflicts that we did not have before. So for example here, now we run into the conflict with our previous partial assignment that twelve times y plus seven should be equal to zero. And now we have nowhere that we have a conflict due to the parity because there's no variable that we can assign to y, such that kind of constraint recovers. And so we can already at this point conclude that we are answered this one and the question was how to choose the values. And so I will talk briefly about how we represent now this values in Polyzat. For each variable we try to keep track of the viable values, and from all these variable values that we still have, we can choose a value for new decision.
00:37:13.814 - 00:38:03.738, Speaker B: In case our viable set is only a singleton set, so we have only one choice left, then of course we can propagate it. If it's the empty set, then we know we have conflict. And whenever constraints become simple enough, then we reuse it to restrict our viable set. And as I already said, currently our variable set is represented as a set of intervals. And when a variable x appears only linearly in a constraint, then we extract a so called forbidden interval. So we keep track of the variables that we are not allowed to take and add this at constraint in our knowledge base. Additionally, since we also have some bitwise constraints, we keep track of some of the fixed bits of x so that we can also can reason about that.
00:38:03.738 - 00:39:26.950, Speaker B: For example, talking about like x, it needs to be even or odd. For the representation we use half open intervals and wrap around if the smaller part is greater than the the upper part. So for example, if we have the interval between two and five, then Alphabet, you cannot take values 34234 if we talk about like 13 to two, then 13 1415 and we wrap around and also exclude one or zero if both are at the values I have the same values and actually it's an empty interval. And we can add the information about the intervals as inequality constraints into our knowledge base. Let me also jump over that, because what I want to show you is how we actually kind of get to our forbidden interval. So what's actually the purpose that we have? So assume we have now several clauses give us information about the forbidden interval for the variable x. And with the partial assignment we get some concrete intervals that will cover our domain.
00:39:26.950 - 00:40:28.650, Speaker B: So for example, assume that we have here one forbidden interval, kind of the red interval. This tells us we shouldn't take, or we are not allowed to take a variable between those two parts. Then we have a blue one that's a little bit overlapping and then also a third one, the green one that's also overlapping. And you see what's happening now is that with several intervals we have covered the whole domain and we encode that with symbolic intervals. And what this tells us then if you have such a case, then we have run into a conflict and we need to backtrack. The question is now how do we get to this forbidden intervals from the inequalities? We only do that when a certain variable for which we want to extract the interval becomes linearly. There are some easy cases for when the coefficients of the equalities can only be zero and one.
00:40:28.650 - 00:41:20.098, Speaker B: But what we are actually doing is we make that more general. So we talk about when both. So p and Q can take the same values when they can be disequal to generalize this extraction of the forbidden device. But I think I will jump over that. So how we actually do this, define this forbidden intervals for this quality coefficients and. Yeah, quickly tell you like this is not our sole conflict resolution strategy that we have with the forbidden intervals. So we have a bunch of other like techniques that we use sort of to detect and also resolve the conflicts.
00:41:20.098 - 00:41:51.964, Speaker B: Maybe we also do some kind of superposition variable elimination. So as I already talked in my first part, kind of when we know that we have a bound on a variable, then we do some bound propagation on some other variables. Yeah. And so on and so forth. And you see here now this dot, dot, dot. So these dot, dot dots is actually where we are currently are. So we expressing try to extract more of this conflict resolution plugins to really be able to reason about the benchmarks.
00:41:51.964 - 00:42:00.764, Speaker B: And with that, I'm now at the end of my talk, so thank you very much.
00:42:16.594 - 00:42:52.914, Speaker C: It's really interesting, the last slide, you have several conflicts explanation plugins. It's as if the bit vector theory was kind of a union of theories, except it's not really disjoint like you have collaborations between several explanation mechanisms that interact within this MC sat mechanism. Have you ever thought of seeing bit vectors as a union of sub theories, like bit vectors seen as arithmetic things, bit vectors seen as bitwise operations.
00:43:00.504 - 00:43:02.484, Speaker B: Maybe. Nicola, do you have a comment?
00:43:05.744 - 00:43:08.544, Speaker E: I don't mean that. I don't think we are acting on it.
00:43:08.664 - 00:43:09.444, Speaker D: Okay.
00:43:11.464 - 00:43:12.284, Speaker B: All right.
00:43:14.624 - 00:43:28.254, Speaker E: And so what one say, one issue we're struggling with here is, but there's not, say a methodology for when are we done with lemmas?
00:43:44.234 - 00:44:12.280, Speaker B: So it's very interesting. Can you sort of describe how far have you been able to get past bit blasting at this point? It depends. As usual, it's not really also always the bit width that causes us the problems. So for some parts we really, we are there yet with the 265 bits. But for some constraints, when you have a certain shape, then we are still down.
00:44:12.422 - 00:44:12.796, Speaker E: Yeah.
00:44:12.860 - 00:44:30.664, Speaker B: I just wonder, because vector reasoning has been kind of stuck with bit blasting for a long time and it's been hard to get past it. I was wondering just how far you feel like. Obviously that's a qualitative answer, but how far you feel like you're getting. I think Nikola is a comment.
00:44:32.444 - 00:45:01.202, Speaker E: I want to make one qualifying comment, which is. So the motivation is smart contracts. We have 256 bits. Bit blasting just doesn't work. There's no way. And so the current alternatives are to translate to integer arithmetic or some custom solver here. And so in these cases, either the integer arithmetic or the custom solver can do things that bit blasting has no chance of ever achieving.
00:45:01.202 - 00:45:26.384, Speaker E: So. And you can also see it as somewhat reaction to should bit vector solving necessarily be translated to sat and then solved. And I think that's a losing proposition in the long term. But for 32 bit, 64 bits, Sat works much better than.
00:45:36.624 - 00:45:48.896, Speaker A: In slides. You had, like, put a variable ordering. It's not a, like, theoretical restriction to give assignments.
00:45:49.080 - 00:45:53.448, Speaker B: No, that's not a theoretical. So that was our choice to do that.
00:45:53.576 - 00:45:58.164, Speaker A: Right. So you fix in the beginning and then you stick with it.
00:45:58.204 - 00:45:58.684, Speaker B: Yes.
00:45:58.804 - 00:46:29.404, Speaker A: Okay. Because in, yikes. We have, like, to mate's point resets to bump variable ordering and do frequent restarts. It's like a sat solver. It behaves like that. Hey, in that case, let's conclude. Thank you, Dana, for the talk.
00:46:34.384 - 00:46:34.824, Speaker B: We made.
