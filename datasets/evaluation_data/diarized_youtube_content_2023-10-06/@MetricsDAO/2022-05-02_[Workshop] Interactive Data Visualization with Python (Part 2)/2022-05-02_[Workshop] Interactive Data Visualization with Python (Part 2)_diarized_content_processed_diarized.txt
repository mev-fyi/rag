00:00:00.720 - 00:00:10.570, Speaker A: So welcome everyone. This is another session of Lee's workshop and personally I'm really excited to learn more python. So Lee, go for it.
00:00:12.150 - 00:01:15.844, Speaker B: And yeah, so this is the second week where we're going through this UW data visualization workshop with focusing on Altair. Today we'll get started with a data transformation notebook. So I found the two notebooks this week have a lot of like a lot of content that I feel like I'll refer back to in the future, like if I want to figure out how to do things like related to transforming data or like grouping or aggregating things. So I found that really useful to like have an example and some explanation and then they also link all the docs. Like this data transformation documentation page seems really useful and something I'll refer to as well. Yeah, that's generally, I find that I'm still wrapping my head around writing altair, but slowly making more sense. And then their documentation is really good.
00:01:15.844 - 00:02:17.440, Speaker B: And if you google something, for the most part, you'll find a good answer on stack overflow or GitHub on how to do things. And they have a pretty good gallery of example images, sorry, example graphs that you can at least use as a starting point to change around to get your exact figure that you want. So we'll start by just loading in the movie data set that. Yeah, it's one of these Vega data sets that they have released and we'll just load it in. Looks like it's a 32, about 3200 movies with some columns about information like the gross, the sales, the director. And then we're mostly focusing on IMDb rating and Rotten Tomatoes rating. And it's kind of like some real world data where you have a lot of missing information.
00:02:17.440 - 00:03:35.420, Speaker B: Like for example, there's a lot of nans or nuns for the director and Rotten Tomato rating. So yeah, that's one of the, one of the things you'll always run into in real world data is some data wrangling you have to do or missing data that you have to somehow make sure you're not messing up your analysis while doing that. And a simple, simple basic analysis would be binning our data into discrete groups, like making a histogram. So first we're just going to run the, create a simple scatter plot where we're plotting the rotten Tomatoes ratings against the IMDb ratings. And just in case you're not familiar, IMDb is basically people rate a movie between one and ten. So it's a, I guess the rating is a float between one and ten. And Rotten Tomatoes is kind of an aggregation of reviews where people give a movie a thumbs up or thumbs down, and then the rating is a percentage that gives a thumbs up.
00:03:35.420 - 00:04:21.682, Speaker B: So it's from 0% to 1%. And here's just a simple scatter plot between the two. And the first thing to do if we want to bin this and to basically see what binst of Rotten Tomatoes scores get, what range of IMDb ratings. All you have to do is add this bin equals true to the column that you want to, or the channel, I guess, that you want to bin, and we can do that. And then that's instead of bin equals true. You can use these alt bin params to change the number of bins you want. So now it's in, it's creating 20 bins.
00:04:21.682 - 00:05:29.546, Speaker B: So every, I guess, every five points of a rotten tomato score has its own bin. You can see. And to get more of a traditional histogram, we're just looking at the, instead of comparing the Rotten Tomatoes scores with the IMDb rating in bins, we're just looking at the count of rotten Tomatoes scores as the y axis. And this is basically a histogram if you switch it to a bar. So you just see the count of, you can see kind of the distribution of the scores of unrotten tomatoes. And we can see it's kind of, it's relatively, I guess, close to uniform across the board, except some more in the higher range and less in the lower range. If we look at the same for IMDb, it looks a little bit more, I guess, normally distributed, but it's skewed, I guess, higher.
00:05:29.546 - 00:06:12.572, Speaker B: So on average, people rate things slightly higher than, I guess, the middle, which would be five. So now you can bend the two, sorry. You can plot the two against each other. And without any additional information, it looks, it's hard to see anything. Basically, all the points are overlapping. So we can do a third channel, which is you can use size to show the count. So here you can see the count of records is a size, and the points are not just completely overlapping.
00:06:12.572 - 00:06:57.366, Speaker B: You can actually get some information. So for example, a score of something between 95 and 100 on rotten tomatoes, there's some range where most of them are about 7.5 or eight on the IMDb rating. And this can be switched to using the alt color. And this is basically just a heat map. And that's something used traditionally for, you know, comparing two different variables. And the third dimension, I guess, is the count, which we can see by the color.
00:06:57.366 - 00:07:35.050, Speaker B: And just comparing these two to me, it seems like the heat map is generally easier to see what's going on and you can see a more clear trend. The size is a little bit harder to, to tell what's going on like just by glancing. It's a little bit difficult to compare the size really quickly. All the color you can see right here, basically in the 100 row you can see this one is really strong signal for around eight. And it's probably a bit better visualization if you want to do.
00:07:37.440 - 00:07:37.888, Speaker A: A heat.
00:07:37.904 - 00:08:34.550, Speaker B: Map instead of size. Okay, any questions so far about this histogram type process? Okay, so we're basically using this count aggregator or data transformer data transformer to turn our data into a single number. So there now we're talking about other types of aggregation functions. And once again you can see there's a link to all the available functions. And yeah, this is a good reference. It has some, some good examples on how to do different things. So now we're going to just look at Ryan tomatoes ratings by the genre.
00:08:34.550 - 00:09:20.062, Speaker B: So the x axis. Oh, and we're going to look at the average score. So now in the x channel we're encoding the average of this rotten tomatoes channel and the y axis is just the genre of the movie. And once again with the real world data, a lot of the movies don't have a genre listed so they're all thrown into the null category. And that's kind of a bit hard to figure out what's going on. It'd be nice if we can order the genres instead of just an alphabetical. We can now use a sort parameter.
00:09:20.062 - 00:10:19.234, Speaker B: So we're using this encodingsort field to order them by the average rating in the category. So documentaries have the highest rating, so they're on top. And generally horror movies have a really low rotten tomatoes score around average of around 40. So this works by taking the operation, which is the aggregate function or method that we're using the field we want to use it on. So it's taking the average of, it's going to sort by the average score of rotten tomatoes rating and then we can order it by descending or ascending. So right now we see it descending. So the highest is top and instead of average we can use median, which may be slightly, slightly nicer.
00:10:19.234 - 00:11:08.732, Speaker B: So basically average is more affected by outliers. So a really, really high movie or a really low movie could greatly change the score of a category by median. The outliers have less effect. It's just looking at the, basically where a median score is the score where half the values are above and half the values are below. One really high or low movie won't throw off the category, change the score too much. And if we compare the two documentary, musical, concerts, westerns are usually the highest, which we can see here. And also horror, romantic comedies, thrillers are really low.
00:11:08.732 - 00:12:05.372, Speaker B: So it doesn't really have too much of an effect. But it's more robust in general to use median for if you want to not be sensitive to outliers. And another thing is, we might not just want one number. We want, whoops, sorry, we want to see the, I guess the range of scores. So we can look at the interior quartile range, which is basically the middle 50% of the scores of. And Altair or Vega has this q one, q three aggregator. So q one is like the score that 25% of the 25% of the movies score that score or lower.
00:12:05.372 - 00:13:10.490, Speaker B: And q three is 75% of the these score that so far are lower. So we can see that not just an average, we can see that documentaries, all the movies, or the interquartile range, between 25 and 50% of the data, they all do really well, like all around 75% to 90%. And if we look at horror, there's a wider range, but they all do not great, even though the average is around 40. So this is basically the start of a box plot, which is a great way to basically look at the median and the interquartile range and then also look at the whiskers, which would be 1.5 times the interquartile range. So you can get a good idea of the whole range of data. So this is an extra thing I just added in because I was curious how you do it.
00:13:10.490 - 00:13:48.432, Speaker B: Altair also includes this mark boxplot function or methods, which plots the same thing here, the q one, q three. It also plots the line for the median. And then it shows also the. The bar for, sorry, a line showing the whole interquartile range, sorry, 1.5 times the interquartile range. And then any outliers are less than that. So this is kind of convenience function.
00:13:48.432 - 00:15:00.156, Speaker B: And you could probably make this manually by adding a few different lines and circles and all that sort of thing to it, to this previous plot to turn it into this. But markboxplot does it all for you. And it also includes this tooltip, which is kind of nice, where you can see the q one, median, q three, and the minimum score, which is pretty nice. The one annoying thing is that Altair doesn't allow you to sort the encoding like we did previously. There's, there's some other ways to get around it but it's not, not as nice, but it does give us this nice plot to display the whole range of the data. Any questions so far? Cool. Yeah.
00:15:00.156 - 00:16:08.170, Speaker B: So continuing on we'll start looking at time data. There's some nice, once again a list of time units that I found really useful when I started playing around with price information that's listed by time. We have this month aggregator which we can use to group the release dates of the movies by month. And then we're plotting the gross box office profit or revenue I guess for each month. And we can see that there's peaks in the summertime and around the holiday season. And we can also look at worldwide growth, not just the US and it looks pretty similar trends. So just the median where aggregate the data by the month and looking at the median gross profit or gross box office sales.
00:16:08.170 - 00:17:48.462, Speaker B: So now we can start doing some more advanced transformation of the data where we use these transform features of Altair. And the first one we're going to do is transform calculate and that's creating this new column of data which we define as worldwide gross minus us gross. And then we're going to plot again the month of the release date and then the median of this new column that we just created called non us gross. We can do it here and we can see the all the, once again a good link, all the different expression strings that we can use. So one, that's the fairly common one is this using this datum, worldwide gross is datum is like, this is basically selecting this column from your data set and doing a calculation on it. Um, and that's just the way the expression string is set up. You can also do instead of um, the dot if you're think, if your column has spaces in it, you can do uh, uh, the square brackets and the name of the column in uh, as a string and then that hopefully works.
00:17:48.462 - 00:18:49.122, Speaker B: Yes. Okay good. Um, so that's useful. Uh, if you want you could also do this um, this transformation in your data frame itself, like create a new column in your data frame called non us gross. But sometimes it might be useful to have all the encoding directly in your, the output of your Vega, Vega lite plot which is what this is actually created as. And then it will show this transformation in the, if you remember from last time, you can export the plot as JSON and then you'll see that this calculation is included in the JSON output. We can also use filters.
00:18:49.122 - 00:19:32.646, Speaker B: So say if we just want to look at one category of the one genre of our movie data. We can see that with this transform filter equals romantic comedy. We can do the same thing. We can also combine our aggregation so we can say year of the release date and then less than 1970. And we can use that as a transform filter. And we can see that it looks like for some reason older movies have higher ratings than usual. Moving on.
00:19:32.646 - 00:20:37.144, Speaker B: We can do some group by and aggregate transformations pretty simply with these transform aggregate methods. So we group by the major genre and then we can get the average rating. Um, and then this uh uh, creates um. Uh, your, this kind of creates a new table, I guess, with the group by and uh, the group by columns that you listed and then the average, uh, the other column that you listed. So right now it would have a major genre, an average rating. And then we're plotting that, um, uh, with the average rating here and the uh, major genre as a y. And this is similar to what we did um uh, before um, with showing our average ratings by genre.
00:20:37.144 - 00:21:27.640, Speaker B: But now we're just showing how you, how you would use a transform aggregate to do that. And maybe for more complex things you'd want to use this instead of just showing the average. And one thing to note for this encoding or this sort encoding sort field. So basically we're using Max because for each of the genres there's only one value because we're just getting the average score for each of the genres. So we can also use min and it'll give the same result. Yeah. So now we're going to get into some, a bit more advanced transformations.
00:21:27.640 - 00:22:34.994, Speaker B: We're looking at the gross of different directors, basically the gross of their box office ticket sales. And we're going to do a, so first we're going to transform and get rid of all the directors that don't have all the movies that don't have a director field. We're aggregating the sum of their movie sales and grouping it by the director's name. And then we're using this new transform window aggregator where there's several, several different operations like rank, row number, lead lag, which are all explained in the, that's great. Once again, great document, pretty good documentation. And so window is useful for making basically like top ten top 20 lists such as that. So when we use rank, it gives their, I guess, number based on the field that you use.
00:22:34.994 - 00:23:32.978, Speaker B: So we have this gross of some worldwide gross. Gross is a sum of the worldwide gross for each director. We're getting the, we're ranking them from one to however many directors are by this field gross, which we just defined, and then inserting it descending. Then we're also using a transform filter because if there's probably, I don't know, hundreds of directors, I'm not exactly sure. It'd be very confusing if they were all in the same plot. So we just want the top 20 and you can see they're ranking by total sales. We can, if we are, if we're curious, we can also look at the average and see how they differ, where some directors may not have the highest total growth because either they're newer or have fewer films, but they might have a really high average.
00:23:32.978 - 00:24:53.290, Speaker B: David Yates has, his average gross is nearly a billion dollars, which is quite high. And I think this is the last section we're going through. And then we can maybe take a break, just another aggregation of using the cumulative, instead of showing the probability distribution, sorry, probability density function, which is kind of what histograms show, which show you kind of the spread of data, the cumulative distribution shows you the total count of data up to that point. So we can run it here and we can see the, this is breaking down the cumulative count of films with different run times. So we can see there's not very few movies less than about 80 minutes. Then it starts going up and a large number of the movies are in this range of between 80 and 140 minutes. So about a little less than an hour and a half to about two and a half hours.
00:24:53.290 - 00:25:52.700, Speaker B: And then we can see that there's very few above 3 hours and they're probably all Lord of the ring. And that's pretty much it. So to do this, we're using the aggregate function count, and then we're using the window function of the sum of the count, and we're sorting it by the running time in ascending order. So now the movies are ordered by their runtime and we can just keep adding how many movies are in that bin? And it keeps on going up until we reach the end of our data. And that's it for this first notebook. Sorry, I've been talking a lot. Again, any questions, comments, concerns related to this one?
00:25:56.640 - 00:26:04.500, Speaker A: I don't see any questions in the workshop channel, but I guess this is a good time for poap. So. Yeah, you want to go ahead?
00:26:04.920 - 00:26:39.942, Speaker B: Perfect. Yeah. So now we'll move on to this. Some information on scaling data and axes and legends. I'll start by reading in this antibiotics data set, which is basically showing the. Let me make sure I loaded it in. It's showing a bunch of different bacteria names.
00:26:39.942 - 00:28:02.730, Speaker B: And as the rows and the column headers are, this number is the mic, basically the amount of the different antibiotic that is needed to basically kill the bacteria. And the lower the number, the more effective the antibiotic is against that bacteria. Then this gram negative staining is a way basically scientists use to group different bacteria on how, basically how they take up a dye when you look at them under the micro, when you stain them and look at them under a microscope. So we'll start simply with this, make it a little bigger because these plots are smaller. Just looking at the range of the neomycin and how much is needed to the mic values for all the different bacteria. So by default we're using a linear scale. We can use this alt scale or scale equals alt scale and then we can choose a type.
00:28:02.730 - 00:28:53.120, Speaker B: Right now their first example is square root, which you probably don't really ever, maybe you don't ever really want to use. In general, if you're ever going to change the scale, you probably just want to use log. This scale equals alt scale, type equals log is quite common for things. And now your data is differentiated and the skew is a lot less. So it's kind of spread out across a whole range, which is we can also style the axis. So kind of the mic score is maybe a little unintuitive. It's kind of backwards from what you think.
00:28:53.120 - 00:29:30.180, Speaker B: So a lower score, a lower mic value is actually more effective or I guess better or higher if you want to think about it that way. So scaling it, switching the scale so it goes descending instead of ascending. It's a little more intuitive if you look at the plot. So now like the ones that around 0.001, that's the high, looks like it's farthest to the right. So that, that's the one that where neomycin has the most effect. And then using you can change the title of all your, basically any channel that you're using.
00:29:30.180 - 00:30:08.776, Speaker B: Title equals whatever want. You can make a, use a string to put in any human readable name. So that's used all the time because a lot of times your column names aren't something, aren't pretty. So you want to include more information or at least like, you know, change the capitalizations. And again, we can move where the access is instead of on top or bottom. This or ant equals top. And then you can basically do the same thing for the y axis.
00:30:08.776 - 00:30:59.976, Speaker B: Wanted to do that instead of. Yeah, all these fields are the same for a lot of the different channels. And yeah, usually I just kind of refer to the docs if I want to figure out how to do these things. A lot of the times I don't remember the exact keyword, but I know that, you know, you can look at alt access, figure out where you need, you need this, orient equals top, that sort of thing. So now we'll do a bit more of a complex chart where we're comparing two of the different antibiotics. We're basically just doing the same thing we did before for the alt y but also x of Neo. And we're also adding a alt y of streptomycin.
00:30:59.976 - 00:31:51.760, Speaker B: And we can see they're quite well correlated that they all, if neomycin does good streptomycin. So we'll look at something that's a little bit less correlated, which is neomycin and penicillin. We can see that the data is kind of, there's no clear pattern between the two. So some are highly effective with penicillin, these ones in the high top right, top left. And then some are highly affected with neomycin. And that plot isn't the best because the scales are different. This goes from 100 to zero, zero one, and this goes 1000 to 0.001.
00:31:51.760 - 00:32:29.360, Speaker B: And so the widths are also different. So we can kind of force Altair to do the same, have the same scale and same size and make it into a square. So we can use this domain parameter for alt scale. So this is saying go from 0.001 to 1000. And then we're also adding this properties of the chart in general, where we'll set the width to a square of 250 by 250 pixels. So now it's kind of more intuitive, everything.
00:32:29.360 - 00:33:23.620, Speaker B: Both axes are the same width and height, and they go from the same range. And as it says, less prone to misinterpretations, which is important. And now we're just starting to clean up some of the, this has a lot of ticks in it. We'll use this tick count alt axis tickcount equals five. Now we just have five, five ticks per axis. And it's a lot cleaner to look at. We can also change the size of the circles by using this size parameter within Marc circle so we can get something a little bit nicer visually.
00:33:23.620 - 00:34:50.491, Speaker B: So next we'll move on to. Any questions so far? Yeah, these are all just kind of more cosmetic features so far, although also log transforming your data or log display of your data. Okay, so now we can add, now we're adding a color channel by using this gram staining column in the data by default it just uses the default categorical colors which are start with blue and orange. And it has the name of the column as a legend title. So we can change the colors to match what they look like when you actually stain them, which is apparently negative is pink and positive is purple. So we use this alt scale for the color where we have the two value, the possible values, um, and then the, as a domain and then the range as the value, uh, the color values you want to use for it. Um, and these are, uh, I guess, I think they're um, css color names.
00:34:50.491 - 00:35:52.716, Speaker B: Um, and I think in the Vega docs you can look at um, all the different color names, um, if you want, if you're curious, you can also give the, uh, what's it called? Hex values of colors as well instead of the names. Again, we can change the orientation of the legend so we can to the left instead. And then we can also just get rid of the legend itself entirely if we don't actually really care about it. And that's just with legend equals none. And that's sometimes more useful if you, if there's a lot of stuff going on, you don't need a huge legend. So now instead of the gram staining we can color it by the bacteria. So this is using a categorical color palette, I guess.
00:35:52.716 - 00:36:45.384, Speaker B: And the default one only has something like ten values so the colors repeat. So it's not super informative and it's hard to tell what's going on. We can start to fix that by using this different color scheme. So instead of doing the, like we did here, we did alt scale the domain and range to give like to match the values with a color we can use. Where is it? Oh yes, we can do a scheme which link in the documentation. We use this one with 20 different colors and now at least there repeating different colors. But it's still not great.
00:36:45.384 - 00:37:47.500, Speaker B: The colors aren't really meaningful. And the, the one, for example, the species in the same genus are like completely different colors and there's no, there's basically no meaning listed to the colors. The first start to getting around that is changing the bacteria to an ordinal value instead of nominal. Now the, I guess rank of the bacteria means something. So at least now the, um, the, since it's sorted in alphabetical order, the ones that are close to each other in alphabetical order are similar in color. Um, and that helps. So at least the streptococcus, um, uh, strains for example, are all close, close in the same color but still hard to distinguish things at the border look similar, and that could have no meaning.
00:37:47.500 - 00:38:37.306, Speaker B: And instead of using just the blues, you can use a different color scheme. There's some nice uniform color schemes, like viridis is a good one, and now at least they're more easy to distinguish as you go down. So to start getting around. So now we, instead of looking at just the bacteria name, we want to look at the genus, which is the first part of the species name. We're going to use what we learned from the previous notebook. So we'll use a transform calculate to split the genus name. Sorry, split the bacteria name and then take the first part of it.
00:38:37.306 - 00:39:17.934, Speaker B: And that's what this, this little code snippet is doing. It's splitting it on the space that's in the bacteria name and then selecting first value. So now we're encoding the color scheme based on the genus instead of bacteria. So it's a little bit, at least all these streptococcus are in colors, so it starts getting a little nicer. And now the next one. So it's still a lot of different bacteria species or genus. So now one thing you might only care about, subset of the species.
00:39:17.934 - 00:39:57.712, Speaker B: So we're only going to look at the salmonella, staph, and strep, and then the rest are all one color. And this is using another transform calculate. So we split them into, um, the genus name already. And then it's saying if it's in. If the words, uh, uh. If one of these words is in the genus name, um, that will show the, uh. Sorry, if one of these words is in the split bacteria name, will show the, uh, will include that word, or else we'll make it other.
00:39:57.712 - 00:40:57.960, Speaker B: Um, so now we're defining our scale specifically based on the values we defined here. So we make our range, these domain, the three different bacteria genus here, and then also other, and then we can specify exactly what colors we want to show them. And so now we're just showing the different, very specific, different genus, and the rest are all kind of grouped together. And I. And then last, we're going to look at the. Any questions so far? That was kind of a little bit rushed. I think it's something that, as you go through and need to go back and refer to things, I think it makes more sense when you have your example that you have in mind.
00:40:57.960 - 00:42:14.970, Speaker B: Okay, now we're going through the, looking at some antibiotic resistance of certain bacteria to the antibiotics. So we're starting just with sorting the penicillin field and then displaying the value by the color. It's a little bit uninformative by default. So the first thing, we're going to use a different color scheme of mag plasma, so at least looks a little more uniform. And then we're doing some specific, we're changing the take count to five so it's not so many, it's not so jumpy like here. And then there's some specific changes to the axe, the y axis that you might want to tweak for your plot, like moving the setting, the orientation of where the title is located and make sure line left and not rotated. And that sort of.
00:42:14.970 - 00:43:27.970, Speaker B: And this nice equals true makes it so that the values here are all nice numbers. Instead of. If we get rid of this, it might be still pretty good, but it's not as nice. And now instead of showing this bacteria as a title, we could give our chart itself a title, which would be kind of goes above all features of the chart. Then we'll get rid of the Yx Y channel title. And it looks a bit nicer here. Okay, so that's kind of just a brief run through of everything so far for scale mappings, legends, axis, and these are things you'll probably, when you're actually using it in practice, you'll probably go back and refer to the docs and maybe make a lot of customizations, that sort of thing, specific to what you want to show.
00:43:27.970 - 00:44:20.506, Speaker B: And some of it like these, you know, these title, title X, title Y, those sorts of things, you might have to tweak them individually based on, like, how you want the plot to look. And it's not like, it might not just be. Yeah. So those are more customizable features that you can do in Altair that let you make your plot look like how you. Any questions so far? Okay, so I guess I added this little bonus assignment. So we actually look at crypto data just as maybe as an example of what we actually want to do in practice. So the first thing I did was load it in.
00:44:20.506 - 00:44:53.270, Speaker B: And this is if we take a look at what the data set is, it's very simple. The, the date and the average UST price and the average lunar price for that, for that day. And we can just first look at lunar price. We'll see, we'll plot the date versus price. We can see as an error chart. Maybe using that nicer gradient color will make it look a lot better. But here's the default.
00:44:53.270 - 00:45:59.620, Speaker B: And going through what we learned previously, we could change the scale to log, but that might just actually make it more confusing and depending on what you want to show, if you cared about these very low values as well as a very high value, that would be useful. But I think that generally is a better plot and using some of the features of Altair that come with it out of the box. So we can use this date transform. So year, month, date of the date, time. So it shows up October 1, year 2021. Instead of just the month that we can see in the previous chart, we can add a tooltip so that when you hover over a point, we date and the average price. And then we can, we use this interactive zoom in and if you're really curious about around here, you can zoom in a lot and move in price information.
00:45:59.620 - 00:46:48.960, Speaker B: And then we can do the same thing with ust price. Whoops. So by default, it kind of makes it look a little bit, it's usually, it's supposed to be all around one, or that's what it is. So we get this whole portion of the y axis that we don't really care about. So we can make it a bit nicer by changing this domain to. I just basically looked at the data and chose some values. So now we can see it nicely fits in and we can see more of the daily patterns with your tooltip.
00:46:48.960 - 00:47:32.434, Speaker B: When you specify something, you can also use a format string. So you can see that now the price shows up as one with three decimal points. If we get rid of this, it would be, you know, a lot of decimal points that you don't care about. So this format is, I think it's explained in the Vega docs as well. And it's kind of similar to how you would format strings python. And just a last little example showing a transform calculate, we can make a price difference. We can calculate the price difference.
00:47:32.434 - 00:49:06.370, Speaker B: So if we just want to see how far away from the $1 Pega that the US UST price is, we can make this price diff column, which is datum uscprice minus one, and then plot that. And now we can also hover over it and see our values and how close they are to one. You can do a lot more complicated things with this, but I example. And we can also add some horizontal lines to kind of get, get an idea of how close to the threshold it is. So we're making a horizontal line at the points of basically a half cent above and half cent below the $1 pega, or we're using the difference from the $1 peg so we can see that there's a good portion, basically just a way to see how much of the time is spent with these ranges look like recently? Pretty much all the time. It's within the half cent range. And we have to go quite far back to August of last year before the daily average is outside of the $0.01.
00:49:06.370 - 00:49:46.240, Speaker B: Yeah, so this is just a few simple examples with that data that I just kind of wanted to play around with. If you have any, if you did any yourself and want to share it or have questions or want to customize this further to make it look, if you send a message in the workshop channel, I can get to it, take a look, and I think that's all. Any final thoughts? And we're on exactly 1 hour, so I think it's a good time to end anyways.
00:49:47.140 - 00:50:03.060, Speaker A: Cool. All right, well, thank you everyone, for attending. And like Lee said, if you have any questions, feel free to drop them on the workshop channel. And thank you, Lee, for leading this workshop so belief. We'll see you next week again.
00:50:03.520 - 00:50:22.710, Speaker B: Yep. And next week there is a date change. We'll be meeting on the Wednesday Pacific time. I guess it's updated on the git book page, but I'll definitely make sure to remind people. But yeah, so slightly less than one week and see you then.
00:50:25.290 - 00:50:28.830, Speaker A: All right, thank you, everyone. Have a good rest of your day.
00:50:29.530 - 00:50:30.290, Speaker B: Thank you. Thanks.
