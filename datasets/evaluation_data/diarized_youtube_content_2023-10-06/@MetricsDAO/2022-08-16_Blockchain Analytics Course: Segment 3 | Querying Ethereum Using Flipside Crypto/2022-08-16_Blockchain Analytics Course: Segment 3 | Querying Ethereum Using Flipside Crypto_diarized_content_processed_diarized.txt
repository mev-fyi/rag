00:00:00.200 - 00:01:23.418, Speaker A: To really get into kind of the nitty gritty of, you know, what is SQL? Why is this the tool that we're going to be using and how can we use it to actually get crypto focused data and actually start to build some basic analysis on top of that? So where we left off last week was actually starting to use some aggregations. We learned what group by was, how to actually use our aggregation functions over time and across different groups. We learned about what common table expressions are and joins to bring in data from other sections and other tables and other different sources like that. So today is going to be a little bit different. Let's start to dive in and actually use this stuff to build up an analysis. And it's going to be largely a refresher of what we've gone through so far, as well as building on top of that and moving beyond the easy tables into, you know, actually looking at transactions and how do we pull insights out of, out of those transaction objects and what does that really mean? But first, we're going to stay within easy just for about the first 1520 minutes here to go through a refresher of what we've done and how we could actually start to apply these concepts in a real use case. So that being said, let's pop over to Metricsdao.
00:01:23.418 - 00:01:55.818, Speaker A: Another thing that we do here is run bounty programs. So I'm just on the metrics website scrolling down so we can see the open analytics requests. And I picked one in advance, Uniswap. Why not start with number one here? Active amm users. So using what we've done so far, this is a question that we can answer. And if this were a live bounty, we could actually go in and put something together. So this question is, show the number of active users wallets on Uniswap and sushiswap over the past year.
00:01:55.818 - 00:02:54.840, Speaker A: Describe how they compare using at least two metrics, such as unique users a month, transactions per user per month, or anything you find interesting. Give insights on the differences or changes between the two platforms. Choose either polygon, Ethereum, or both for your analysis. So in general, analytical bounties like this are going to have a fairly open ended component to it where there is a lot that is up to the analysts themselves. You know what these two metrics may be kind of are up to. What's interesting to you as you go through your work? I'm not going to go too deeply into this question to the point where it would be a bounty that actually could be fully submitted, but we're going to use this as a jumping off point to start taking a look. Let's use these metrics and the techniques we've gone through over the past week to answer at the very basic comparing uniswap and sushiswap over the past year with a couple metrics there.
00:02:54.840 - 00:04:00.758, Speaker A: So I'm going to continue to use flip side for now with the easy table. So let's open up a new query and we are going to be using Ethereum core deck swaps again. If you don't recall what that data looks like, hit the preview button and that will bring up about, I think, ten records from that table. And then I'm just going to hide the sidebar so that it's a little bit easier for everyone to see what I'm doing here. So what's in this easy deck swaps table? Can we use this for our analysis? Let's first go to documentation just to remind ourselves. Ethereum core easy deck swaps table currently contains swap events from the fact event logs for Uniswap v two and Sushiswap, along with other helpful columns indicating amount, USD where possible. Other Dex is coming soon, so it's helpful, but it kind of says right there in the documentation it is somewhat limited, but that doesn't mean we can't use it.
00:04:00.758 - 00:04:44.544, Speaker A: So this just to remind ourselves of the question was looking for users over the past year. So platform we can kind of double check to confirm like what's in here, select distinction and that will return. Uniswap v two and Sushiswap are the two options that we have in the easy deck swaps table. So that seems like a great starting point to do some analysis on comparative between Uniswap V two and sushiswap. So what they're looking for is users. Let's go back to the preview here so we can remind ourselves what's in here. We have a timestamp.
00:04:44.544 - 00:05:11.538, Speaker A: That's great. We're gonna want to look at this over time. Origin from address. That is most likely what we're gonna be looking at. How do we know that? Well, we can recall that transactions are a counterparty type system where someone initiates it and they interact with something. Perhaps this contract address here. And in this case, if I were to go initiate a swap on uniswap, which we will go look at a little bit deeper later, my address would be the origin from address.
00:05:11.538 - 00:06:00.552, Speaker A: So I can kind of infer, okay, this is probably the user or bot or protocol that is starting the swap. And then we have all this other information in here about the different pools, the amounts, but for this particular question, that's not what we're looking at. We are interested in the people that are actually, or wallets rather, that are actually behind the scenes here. And in this case, we also have a sender. Just keep taking a look through in addition to an origin from, so we can go back, check the docs and remind ourselves, what does this mean? The router is the sender in the swap function versus the origin from address. The from address at the transaction level. Router is the sender in the swap function.
00:06:00.552 - 00:06:43.506, Speaker A: So that looks like that's going to be whoever's routing it. So we can see origin from is EB seven. So that's who's initially initiating the transaction. It just said the address from the transaction level, whereas the sender is the router, which actually looks like that's matching origin two address seven c o x seven c. Just kind of looking through some of these with manual inspection just to get a feel for information that we have here. So based on that, just quickly thinking, yes, I think origin from address is what I should be counting up. That is the original from, from the transaction, despite the events that happened in between.
00:06:43.506 - 00:07:43.150, Speaker A: So if we were to answer this question, we want to use a couple of the techniques that we've remembered from last week, which are right, we want count of users over time and across platform. So if you crawl, recall, if we want to categorize it into a couple different groups like that, we're going to need to use something like group by. And if we're dealing with dates, we'll use date trunk. Now, I could use a daily level, which we get very granular, but the question asked for let's look at it over a year. So maybe I don't want to look at 365 different instances for Uniswap. Let's start with maybe monthly active users, and then we can change this maybe to look at weekly. But as we're going through and seeing what's in here, it makes sense to start less granular and kind of burrow it down from there as we go.
00:07:43.150 - 00:08:17.490, Speaker A: Maybe we determine that weekly is correct, so we change it from month to week. But it's for all intents purposes, let's start with the casting a wider net and seeing how we should change it from there. So we want the date because we're looking at it over time. And then we are also being asked to compare Uniswap to sushiswap. So platform is going to be an important column in here. And then we're looking at user metrics. We decided we're going to use origin from address.
00:08:17.490 - 00:09:06.540, Speaker A: So let's count how many of those we have total from addresses. Now maybe you're thinking, all right, what if I wanted to go through and see how many transactions that there are, might think for a second and realize that this is also counting that for every one transaction there is an origin from address. Every transaction is initiated by someone. So this could also be aliased as total transactions. But we are also looking for actual individual users or individual wallets. So another thing that we might want to look at here is distinct from addresses. One user can have a number of transactions within a day, but they are still just one individual wallet initiating those.
00:09:06.540 - 00:09:53.320, Speaker A: So like we did in some examples last week, we can count distinct from addresses. And let's keep it kind of simple for now. Easy deck swaps. Our two groups are going to be date and platform, one, two. And then I like to order it just so you can see it in the table here before going into a chart. Order by date. Let that run.
00:09:53.320 - 00:10:53.700, Speaker A: That might happen sometimes. Let's just refresh. Okay, so it looks like it did run. Look, we've got 2020, may 1 and onwards, so clearly forgot to do something in here in that there's no date filter, the question only asked for over the past year. So that's easy enough to go back and just add a quick where. -365 so that will take today fact 365 from it and it will bring me everything that has a block timestamp greater than the past year. So August 1, we are in August.
00:10:53.700 - 00:11:29.130, Speaker A: So that makes sense. And we are truncating on a month level. So we have August, September, October, and then we can start to see here. The total from addresses is also the total number of records that are occurring within that group relative to the unique froms, which is pretty significantly less. So we can either look at the numbers or recall that. Another great way to explore the data that we're looking at is by actually charting it. So let's just take a look at total from addresses relative to unique from addresses.
00:11:29.130 - 00:12:11.230, Speaker A: And let's put the color column which will basically kind of group by and that'll as the platform so we can see instead of none. This is just going to sum it up and show us the total everything. But we want to compare platform, so. Hmm. Fortunately it's only seeming to do that on the bar chart, not on the line chart. So maybe trying to throw all this information into one individual chart is not how we should be doing this. Maybe we should split out sushiswap and Uniswap and look at them on, you know, separate axes or even separate charts in general, where we have just one Uniswap chart and just one sushiswap chart.
00:12:11.230 - 00:13:04.566, Speaker A: And that's one way that we can get some better presentation level visualizations is by being very clear and intentional about what's actually going on the chart. We don't necessarily always want to just dump everything that we just calculated into a single chart and say, great, I have all the answers here. We've got two and a half million total from addresses. So that sort of transactions, but only 500,000 of them were unique in the month of September. And that's, that doesn't really tell the user all that much. So maybe a better way to do this is to, instead of, instead of putting it all into one chart, is to actually start to split these out. And I think with the flip side editor, the best way that we're going to do that is by actually segmenting out.
00:13:04.566 - 00:14:01.910, Speaker A: So Uniswap v two, I think is what it was. Let's just comment that out for now. So we don't actually fully delete it because maybe we will change our mind and want to do it again the other way after the fact, and then we'll do it via filter. So now we just have Uniswap go on our bar and we've got, our x axis is going to be date from with our uniques kind of there. And then we can see, you know, just the Uniswap data in front of us where October had, you know, 3 million transactions, aka total from addresses where you only 630,000 of them were unique and maybe an entirely separate query. We do that for sushiswap. There's a lot of ways that we can slice and dice these easy tables using some of the metrics that we've put together and some of the techniques that we've learned.
00:14:01.910 - 00:15:17.446, Speaker A: And for the most part, for a very high level basic use of the SQL that we've learned so far, we could say that we're done. We could put this on a chart, we could calculate the same for sushiswap and put those next to each other. Like I said, I'm not going to go too deep. We could start to look at some metrics where we say, all right, instead of 627,000 over 3 million, what percentage of these transactions are by unique users? Or what's the average number of transactions per user? But one thing that I'm going to hone in on, instead of calculating a bunch of dish of additional metrics, is actually the fact that in this easy swap table, we're dealing with uniswap v two, where sushiswap is just sushiswap. So that makes you think, are there other versions of Uniswap? Why is this one specifically v two? And are we capturing everything? So that's a question I should ask myself in going through this. The answer may not always be in the table right in front of me. Yes, I have some numbers, but is this appropriately modeling out what's happening on Uniswap? So for that, you know, makes the most sense.
00:15:17.446 - 00:15:42.638, Speaker A: Just let's first and foremost go to uniswap and see what we've got here. Let's actually take a look at what we're being asked to analyze. Trillion dollars in trade volume. 106 million all time trades. Scrolling down. Just let's see what it actually looks like. Uniswap.
00:15:42.638 - 00:16:02.686, Speaker A: Pretty straightforward interface here. Charts, maybe I want to take a look at. All right. If I'm modeling out some information, maybe the charts where they're actually showing me, that is a good place to go. We've got four and a half billion in TVL, 1.3 billion in 24 hours volume. That's a lot.
00:16:02.686 - 00:16:33.890, Speaker A: There's a lot of trades going through. We can see what their top pools are. Over the past 24 hours, ether has over a billion dollars volume. USDC is not that far behind at 988 million, driving almost all of it. And if you're looking at this saying, well, those two together total up way more than 1.28. There is some overlap there within the individual USDC. The third largest one is the USDC ETH pool, and there's a couple of those.
00:16:33.890 - 00:17:09.899, Speaker A: So, you know, you can't just sum up that column, say, like, this is what the 24 hours TVL is, sorry, volume is. Because within this, there are USDC ether trades that individually account for their own 24 hours volume. But in going through this, I kind of noticed something up here that in the top right, we have v two analytics. So that's telling me something like, oh, there are, at one point was a v two, and if I look down here, v one analytics. So there are different iterations of Uniswap. If I want to find out or about that, let's just search. What is Uniswap v three.
00:17:09.899 - 00:17:32.543, Speaker A: And top result is a blog post on Uniswap from March of last year. Okay. It's been around for a while. Give this a little background. V one launched in 2018, May of 2022. V two launched mainet on May 5, 2021. So they've done some upgrades.
00:17:32.543 - 00:18:32.624, Speaker A: I won't go through the actual details in here. You can search for it and kind of read through, but there are some significant changes in how V two and v three operate. But now I'm thinking, all right, how do I get this information? It's not in that easy fact table yet. It said in the docs here other Dex is coming soon, but the bounding question is posed now, right. We need to go actually get that information. How do we pull it in, and how do we extract information about v three outside of this? Easy dex swaps table. So let's, if we were going through, sorry, the uniswap v three, maybe the first place to start would be like, how, how important is that really? You know, is it that significant? Well, on V three, we've got 1.3
00:18:32.624 - 00:19:10.478, Speaker A: billion 24 hours volume. V two info page. We have 100 million in 24 hours volume. So, yeah, that's a pretty significant difference. We're not capturing almost all of the overall uniswap volume, but my thing, like, that's kind of weird. I wonder why there is still even 100 million in volume here. So, continuing to dig, maybe we find this faq page where they, you know, one of the most commonly asked questions is, can we still access it? So the contracts will live indefinitely as immutable set of smart contracts on Ethereum.
00:19:10.478 - 00:20:01.890, Speaker A: We can go look at those in a second and actually see what that means and the traffic that's flowing through them. You can still swap through the v two contracts on their front end here, but for the most, volume is now going through v three. But there also may be other, you know, Dexs or routers that are set up to use the, the v two contracts and go through them. So it's, you know, it's not something we should just totally get rid of. We want to see that 100 mil in volume. But to answer this question, we have to move beyond easy. And in order to do that, we have to kind of understand a little bit about where is this information coming from? Where do we actually get this transaction data from? And these from addresses and all that other stuff that populated this table, like the amounts and the pools and the platform.
00:20:01.890 - 00:21:03.910, Speaker A: So if, say, I'd never touched uniswap before, and I have no idea what their data looks like, I would probably want to go and actually, you know, see what can you do on Uniswap, you can obviously swap how a transaction looks on chain. That might be a little confusing. Like you open up either scan, where do you even start? There is a very common technique and that's to actually go make a test transaction. So let's say I'm on uniswap and I have wrapped ETH and I want to swap it into Dai. So that's about $50 in Dai, kind of depending on what time of day it is and what the markets are doing. So I have not swapped from wrapped eth to Dai before. So I have to do this thing where I can actually allow, let's pull this more front and center so it's easier to see, actually allow the protocol to use the asset that I have in my own wallet.
00:21:03.910 - 00:22:01.962, Speaker A: There's a transaction fee associated with that and basically just signing it. I'm not going to get too into the weeds as to what this function is saying other than I am letting uniswap use the wrapped eth that I have in my wallet up here. And it's a, you know, they can't swap and they can't interact with my wallet without me doing this. And if I were to go then and try to swap USDC into Dai, then I would have to approve that token as well. So let's confirm. Pending takes a second and then once this is approved I will actually be able to swap. So basically what's happening now is, can I open this up on the block explorer as we're talking about in that first session? My transaction that I want to actually do has been sent out into the mempool and right now it's just waiting for node to actually pick this up to validate it and to actually write it to the chain.
00:22:01.962 - 00:22:28.130, Speaker A: Etherscan has this great little pending transaction queue where you can see more or less about how far along you are in the queue. Pretty close to 100. Not too much traffic right now. Shouldn't typically take all that long. We get a little pop up if you can see down here, can't actually move that notification that the transaction was confirmed. And then I could go back here, whichever one was actually uniswap. Now instead of a proof it's swap.
00:22:28.130 - 00:23:10.378, Speaker A: I'm not going to do that because I did this earlier, but let's say hit swap and then actually went to my address, an etherscan. So let's copy it from up here, my address into Etherscan explorer. And what we're looking at is my address on Etherscan. You can see the most recent one right here 1 minute ago was an approved for wrapped ether. So that was me actually saying, yes, Uniswap, you can use wrapped eth that is in my wallet. But I did a couple test transactions earlier, just so I can kind of be prepared for this, where. Let's take the other side of that, where I was swapping 50 die.
00:23:10.378 - 00:23:30.330, Speaker A: For wrapped eth, this transaction would have been wrapped eth back into 50 die. And we can say, like, all right, these are the types of transactions in this. I am a unique user. That should be in the table somewhere. I made, what is this? Three transactions, four trans. No, that's an approval. Three transactions today on Etherscan.
00:23:30.330 - 00:24:00.670, Speaker A: So there should be. Sorry. On uniswap. So there should be three instances wherever this wallet address is the origin from address in some swap table. Right. If we were to have an easy deck swaps that include v three, but we don't. So how do we get this information into, into our code? How do we actually pull this out and extract insight on it, where, you know, the action that's happening is we swap 50 die for uniswap or for ETH.
00:24:00.670 - 00:24:29.956, Speaker A: On uniswap, we can start to look at the. Let me zoom in, just in case that's a little bit small. We can look at the logs, and this is, you know, the receipts of what happened in each event. They're a little cryptic, but we can recall from some of the stuff that was going on. Let's see, it was 50 die for 0.0261, etcetera, eth. And we start to see some of those numbers.
00:24:29.956 - 00:24:52.508, Speaker A: 26150, etcetera, 50 maybe with a bunch of zeros behind it, a bunch of hexadecimal here. That's kind of confusing. Might not be able to figure out what that is. But in here, we do see that. Okay, this was a transfer, and that looks like the ETH number. And this is transfer. That looks like it could be the die number.
00:24:52.508 - 00:25:49.496, Speaker A: So somehow, somewhere in this transaction is that swap information. So let's take this instead of going to the easy deck swaps table this time, let's go to the transactions table. Dex, hash is just this one. And maybe actually show this guy again. All right, is that large enough to see? So we've got, earlier today, block number, block hash, transaction hash, kind of that regular boilerplate transaction info from address was the one I pasted in earlier this to address. Let's see if we can start to match some of this stuff up. That's just etherscan.
00:25:49.496 - 00:26:12.758, Speaker A: That's the approval. Here it is. All right. Kind of tough when it splits screen like this. If it's too small to see anything, just let me know in the chat and I will zoom in. But just looking for where this information is. All right, so we've got the from on Etherscan, the sending party of the transaction.
00:26:12.758 - 00:26:34.688, Speaker A: I have an Ens, but if I hover over it, it'll show me that zero x zero four. Okay, that matches. There's two. Address is a contract ox 68 b, uniswap v three router. Hey, that's maybe something that we're looking for. The transaction fee, which we can see down here, gas price was 20 kw. That's great.
00:26:34.688 - 00:27:12.720, Speaker A: And all important to have that transaction metadata. But where do we actually get the information telling us about swaps? Well, on Etherscan, we went to logs and that seemed like it was pretty rich in data. So let's scroll all the way over past the transaction input, and we have this JSON. It has basically all of the transaction information which we kind of started to look at last time. So let me paste that in here. And I think it's control Alt J to format JSON and atom. And we can start to see, okay, block hash and block number.
00:27:12.720 - 00:27:34.250, Speaker A: Here's the transaction hash that we can see on Etherscan here. And it's all represented in this JSON object that is basically the raw data that we're looking at. That's cleaned up and shown nicely here. And that's what we want to do is clean it up and show it nicely. So we found the logs on Etherscan. Let's just look for the word logs in here. And here we go.
00:27:34.250 - 00:28:30.980, Speaker A: So how do we even get to this? Like, what is this doing in here? And how would we start representing the logs in our SQL editor? Let's go back to this on the side where we have this TX JSON column with this information in it, but we want to actually get to, in case that's too small. Let's keep zooming in. Get to this logs object. So this whole thing, this TX JSON is what we call a dictionary, and that's indicated by these curly cube races, which I'm highlighting the top left screen here. And inside of this there are comma delineated key value pairs. So condition is the key, null is the value from is the key here, my address is the value, and it goes on and on. And we could get to any one of these simply by indexing in.
00:28:30.980 - 00:29:05.824, Speaker A: So I'm just going to delete the star for now because let's say we only want what we're actually about to pull out. So Txdem JSON is the column and this TX JSON is an object. It is this dictionary that we're looking at on the left. And we can get to any of these key value pairs with a semicolon. And actually by putting in the key, it will return to us the value. So in here I put from, and in return we are actually getting this value here. And I can put in anything over here that is actually a key.
00:29:05.824 - 00:29:59.600, Speaker A: So let's say we wanted to get the gas, even though that's already a column in the, in this table, and then we get that. But that's not what we want here. We want logs. So logs is, can we just put in logs here? Anyone have an idea on how we can actually get into that and returns nothing? But it's here. Maybe it's because of now this is a square bracket, not a curly brace. No, no. Anyone know how to, how we might get the logs? Well, each of these can be an object in and of itself.
00:29:59.600 - 00:30:42.314, Speaker A: So while from, the value for from is a string, that is an ethereum address. If we take a look down here, all these are indented, which should tell us something, that they are actually nested within receipt. So the key for receipt, or the key receipt, its value is actually another dictionary in and of itself. So if we type in receipt here, then we'll actually get this equally ugly unformatted giant JSON here. But we can look into like all right, the first thing listed when it's formatted nicely over here is block hash. I see that. Then I see block number and cumulative guest used.
00:30:42.314 - 00:31:28.460, Speaker A: So ok, now we've got this object here is now represented in the column, but we just want logs. So let's go one more. And now we can actually get to this logs data which we saw started with this, you know, square bracket instead of a curly bracket. So this is how we can actually start to look into JSON data and start to extract different pieces of it. We have, you know, block hash and block number and all this other stuff that exists in TX JSON. Uh, it's useful, but we don't need it right now. We're just looking for the logs because we want to see if there's anything interesting in here that could point us to the direct into the direction of actually getting some of that information with regard to how to find a swap.
00:31:28.460 - 00:32:10.490, Speaker A: So now we just have the logs. One thing that's great about text editor like this is that if I click here right next to the start of a dictionary where these little dots will show up and that will tell me kind of the extent of how deep this one is. So if I could hide it and I could see all right, it goes from 25 to 49. If I click here, these little red dots appear. There are now a pair of little red dots over here on line 49. So that's telling me this whole thing is one log. And I know it's one log because it exists in this comma separated type structure.
00:32:10.490 - 00:32:53.074, Speaker A: So each one of these is a dictionary and that exists in an array. So that might be a little confusing for now. So let's take logs, goes. If I hide it right here, it goes from line 24 to line 28. So let's just take logs, leave the rest of the TX JSON behind. And now we have this key where the value is something between scrolling all the way down a bunch of, you know, a set of square brackets, and that denotes an array. An array is just a list where you can actually, you have a bunch of different objects in a row that are not necessarily joined together by a key value pair where.
00:32:53.074 - 00:33:41.616, Speaker A: So in a list, this is the first log, this is the second log, and they are all comma denoted, just like each, sorry, each record in a dictionary was. And you know that this is the first and last one because we've got the little red dots denoting underneath the curlicue here. And just like logs is within receipts in here, we can have further nested dictionaries where decoded. The value for decoded is a dictionary in and of itself. And then within decoded, we have inputs where we have another dictionary with, from, to and value. So this is starting to look like a place where we might find some good information. We like the word decoded.
00:33:41.616 - 00:34:23.160, Speaker A: We can actually read things that are decoded as a person. And we see event name transfer that's familiar to what we were looking at before. If I pull up here, I believe this was, here's one that says transfer. Another transfer in number two, swap. That seems like something that we would want, and that's, this looks like the last one as I can't scroll any further. So this hex encoded log right here, if we go to the decoded data in the transaction table, we can see is a swap. And that's, you know, that's what we're looking for.
00:34:23.160 - 00:34:49.760, Speaker A: This is swap on uniswap. And this is pretty rich with the information we're looking for. We've got amount zero. We've got amount one liquidity recipient sender. So that's great. We want to hone in on logs clearly. So let's using, you know, this notation where we're, you know, selecting into different parts of the JSON is one way we can start parsing through this.
00:34:49.760 - 00:35:54.598, Speaker A: We can start building out, okay, let's take out the address and the decoded and the event name and all the inputs that are within each log and, and build out different columns like that so that we can actually parse through this and find out wherever event name equals swap. Or we can take a look and see has someone done that for me? So let's go back to full screen. Logs are pretty important. So the answer is yes, we have a fact event logs table, which basically does a lot of what we just did, where it takes hones in within the transaction JSON and actually pulls out each log. So let's go back to selecting all. But instead of fact transactions, we're going to go to event logs. So for just this transaction hash, and as that's running, we can just kind of see the information on it.
00:35:54.598 - 00:36:18.524, Speaker A: So this table flattens. Event contains flattened event logs from transactions. On the Ethereum blockchain. Transactions may have multiple events which we saw in that example, I think it have four, which are denoted by the event index for transaction hash. Therefore, this table is unique on the combination of TX hash and eventhe index. Event names are decoded in this table where possible. That's important to note.
00:36:18.524 - 00:36:53.636, Speaker A: So that's where we had swap and transfer and approve event inputs. Column will contain the log details in JSON format. Great. We kind of know how to use that a little bit now. So now we've got this same transaction where we're just looking at the logs. We do still have all this boilerplate transaction hash block timestamp from address and to address. But as we keep scrolling over, we start to see a much cleaner representation of those logs that we were just looking at where we saw that approval transfer.
00:36:53.636 - 00:37:25.798, Speaker A: Transfer swap is now an event name and we have the inputs there. So mount zero, mount one. This should all be familiar from these inputs within decoded. And that's where you can actually start to do some stuff. So, all right, we did a uniswap swap. We're looking at it and we can kind of tell so very clearly we want to know where event name equals swap. There is a bunch of other information in approval and transfer, but what we're really looking for is completed swaps.
00:37:25.798 - 00:38:20.706, Speaker A: So if we were to, you know, look at other event logs in ethereum, we'd probably start with that name equals swap. Now that's presumably not just going to give us Uniswap. There are a lot of different dexs out there. How do we start to take a look at just Uniswap based swaps? If we go back to Etherscan, one of these is either scan that I was just looking at. Well, let's go back to my address, and I believe we are looking at this 150 dive for 0.026 ether on Uniswap. So there's something in here that is telling Etherscan that this is Uniswap.
00:38:20.706 - 00:39:02.644, Speaker A: One thing that ether stand scan does a great job of is labeling contracts. So instead of just seeing, you know, token transferred from zero x 65 nine four, we see that it's Uniswap v three Dai two. Instead of seeing like the contract address for Dai, we actually see that. And similarly, they are labeling the two in our transaction is the contract where it's Ox 68. They're telling us that's Uniswap v three router two. So maybe we want to take a look at that and see, you know, every swap where it's interacting with a Uniswap V three contract might be a pretty good place to start here. So let's say.
00:39:02.644 - 00:39:41.786, Speaker A: And origin to address is Ox 68 B. We can go back if we wanted to confirm Ox 68 B. We're being told here that Steven, swap router two is, whoops, that was the JSON from before is this. And then let's hide that because we don't necessarily want just that transaction anymore. Let's see if we can get 100 of these other events where it's a swap interacting with the Uniswap v three router. And we do, which is great. So we have a bunch of different from addresses here.
00:39:41.786 - 00:40:13.200, Speaker A: All the two addresses are going to be this Uniswap v three contract address. Probably going to want to know something about that, right? Like what? That's. What does that mean? What contract? I thought this was the contract it was interacting with. If you recall from the docs up here, the origin to address origin should be kind of a hint. There is transaction level, whereas this is event level. And we have a hint here. Here's one of the named ones where contract name is uniswap v two pair of.
00:40:13.200 - 00:40:51.080, Speaker A: We have any others? A lot of unlabeled ones. Here's another one where it's the same one across a couple of different transactions where it's Uniswap v three pool unlabeled again. So maybe that's something that would be interesting and important to look at is, well, we've got some that are uniswap v three pools. We got some that are uniswap v two pairs. But we're just looking for v three right now. See, a contract address is the pool address. Ordering to address is the router, I believe.
00:40:51.080 - 00:41:25.668, Speaker A: Yes. So that's what it looks like based on the ether scan transaction where they enact with two, is that uniswap router with this contract address. Looks like a pool. We've got a swap of some amount here and here where the contract name is pool. So let's just use some aggregations to, you know, to figure out what's in here. So let's go contract name out one. You know, what's common? What do we got in here? Group by one.
00:41:25.668 - 00:42:02.684, Speaker A: And let's not do it all the way back to 2020. Let's just do past 30 days for now, just as a sample of what activity has been happening. Okay, so we have four items. Uniswap v. Three pool. Uniswap v. Three pool verified by ng a v two pair, and a lot of unlabeled ones.
00:42:02.684 - 00:42:22.930, Speaker A: There are a lot of pools within Uniswap. This is just a transaction count level recall, or actually even an event count level. So this isn't saying that there's a million unlabeled pools out there. This is saying there are a million instances where the pool is unlabeled. But that seems like a good place to start. Is all right. We don't want it to be the v two pair.
00:42:22.930 - 00:43:18.040, Speaker A: So maybe we should take another look. Let's go back to select all, but in this case, contract name not equal Uniswap w v two pair, not grouping. Take a look at some of these transactions, excluding that. So now we've got a lot of swaps in here. Looks like 88 e 68 is a very common one. How do we actually start to figure out what is this pool? But is that what we're looking for now? Because we are looking for users. And how do we know the ones that were null? There are actual uniswap pools? Maybe there are other origin two addresses in here.
00:43:18.040 - 00:44:22.772, Speaker A: Let's actually flip the script and say, all right, we're not going to look at where it's just this router and we're just exploring data right now in the form of transactions. So origin two addressed count one. And we're going to need that group buyback I should probably put so I can tell what I want it to group by. So we have almost 2000 independent origin, two addresses by two descending. Let's see if any of these are overwhelmingly common, 200,000 of them. Of the actual individual events are this one, which is familiar. We recognize that as the Uniswap V three router.
00:44:22.772 - 00:44:55.142, Speaker A: But then there's a bunch that are not that. So let's see if we can label these. I actually put a little bit of, you know, information behind it. So let's go for, you know, maybe it's contract, maybe it's a label. Labels for addresses on the Ethereum blockchain. That seems like a good place to start. Let's use another concept we learned last week is a left join and that is Ethereum dim labels we're going to call alias.
00:44:55.142 - 00:45:35.980, Speaker A: That is l so I don't have to type out too much, but this one's logs. So maybe we do lo and LA as the aliases. So it's kind of clear which one's logs and which one's labels on lo origin to address, because that's what we want to figure out. What know what it actually says in there and we are taking from the actual labels. Let's see what's in here. Address address name blockchain creator label label subtype label type. Welladdress is the one that we would most likely be joining this on LA address.
00:45:35.980 - 00:46:52.820, Speaker A: And now if we do this, we're not going to get any new helpful information. Well, we're also going to misspell the word address there because we didn't actually change what we're selecting now. So now that we're joining these on top of each other, we can actually grab address name from dimlabels instead of origin to address because that is where we are actually overlapping it with a left join. If you call left join is telling us take everything that is in the left side of the join in this case is the fact event logs our existing result set and add in basically the tables and the columns rather from, from the labels table. So in this case, address name is what I'm going to want here, where I can actually put in a friendly readable name instead of the contract address. So I can just continue to start to see what's in here, what's using the swap event name mostly uniswap v three router, two one inch v four router, mevbot lots of metamask swap routers. Let's do lots of mbots still.
00:46:52.820 - 00:47:21.592, Speaker A: So now let's take another look. Let's explicitly declare so uniswap v. Three pool. But I remember there's another one that said Uniswap v. Three pool approved, something like that. I don't remember exactly what it was. So let's add an I like back from when we were investigating how to find string comparisons, but we didn't know the full name for it.
00:47:21.592 - 00:47:42.576, Speaker A: So now contract name will be either Uniswap v. Three or that uniswap v. Three approved pool. So now we know, based on labeled contracts that we have in there, we're only looking at the Uniswap v. Three pools, and we still have a significant 200,000 of them. Of them being the origin. Two addresses are the Uniswap v.
00:47:42.576 - 00:48:12.876, Speaker A: Three router. 150,000 is fairly significant that are unlabeled. So we're getting null. Then we're getting mav bots, we are getting metamask swap router, one inch v four router. So we probably don't want to actually exclude those, because that is still flowing through uniswap labeled pools, as we see here. So just, you know, what does that mean? So if I were in metamask, I could initiate a swap. Metamask doesn't actually have a dex of its own.
00:48:12.876 - 00:48:46.650, Speaker A: So it goes out and it will use dexs like sushi and like Uniswap on the backend, and it will route it through those pools. So that's what the router part means here. So I could, if I wanted to swap from Ethan to USDC, and it would actually. Okay. It doesn't show it to me right away, but if I hit review swap, it's going to actually go fetch quotes and it's going to look at. Can I actually see the five quotes and it'll tell me what the best, you know, what I. What my.
00:48:46.650 - 00:49:35.390, Speaker A: Where I'm going to receive the most, basically. So 187. 187.9 quote source. Will it actually show me that? It doesn't look like they'll show me the actual place that it got it from. One inch is similarly a Dex aggregator, where you put in your swap, and it will, you know, go out and ping a bunch of different dexs out there and it'll come back with, you know, the best price and the least slippage for you, or like, the most efficient route. So if we're looking at Uniswap users, if we only want to look at the router, then, yeah, we should filter on just the router here, which I commented out, but didn't delete, where it's Ox 68 B, but if we're interested in what's flowing through the Uniswap pools, that's a different analytical question, and let's remind ourselves of what it was asking about.
00:49:35.390 - 00:50:12.400, Speaker A: Show the number of active users on Uniswap and sushiswap over the past year. The way this is written, as a beginner bounty to me, sounds like using the Uniswap front end. So this was really nice investigation to do. We learned a bunch of stuff, but it turns out, maybe at the end of the day, we just used the Uniswap v three router, and we keep this on, and we're only looking at the origin two address here. We're not going to need that anymore. We maybe don't need. We could still join, but maybe we don't need to do that.
00:50:12.400 - 00:50:51.878, Speaker A: So then we're the go back up. Take a sample of 100 transactions. Here. You want a space between Uniswap and V, but also, how do we know that those null values aren't also uniswap? So I'll take that in two parts. That's the tough part about doing things with memory. Did you say here so? I don't think so. Based on the contract name, it doesn't look like they have a pool, unless you're saying the other one.
00:50:51.878 - 00:51:30.462, Speaker A: That was like the Uniswap V three approved pool. We have both of them here we are. So pool verified by Ng, so we don't need a space there. And your second part of your question is very, very on point. How do you know those null values also aren't uniswap? We don't. Without looking into them further. So I could kind of go back to where we were here.
00:51:30.462 - 00:52:11.360, Speaker A: In this case, we are saying where origin two address is the OX 68, which we know is the Uniswap v three router. I could continue with this left join, say, all right, let's label these so that I can also add a filter where the label is null and take a look at what those transactions are. That would be. That is proper analytical process, and that is something that you should do. If you see something that's null and not labeled, don't just pass it off. That's an opportunity to dig further and to see if you're missing something, if it's unlabeled for a reason. And you know what the overall volume in there is with the time that we have left.
00:52:11.360 - 00:52:45.290, Speaker A: I'm not going to do that quite yet, but that is that, like, very good thought process to have there, you know, when you see something that isn't clean and doesn't quite fit. Yes, definitely take that opportunity to dive in and figure out, all right, what's. What's behind this null value. So, yeah, that's a great thought there. So. Well, what we had before was looking at unique types of users based on the easy deck swaps table we set out to look at. All right, let's just figure out uniswap v three.
00:52:45.290 - 00:53:32.660, Speaker A: In this instance, we are only filtering to where the contract is, like the v three or the v three verified pool that we have as labeled. And we've decided, based on what we're looking for here, let's only look at the uniswap v three router. If we wanted to dive deeper into those null values and just look at all the uniswap v three pool volume in general, then, yes, we should not. We should comment that out and take a look at that. But for now, let's just look at this, and we have a pretty good idea that. Okay, I'm confident that I think this is a pretty good representation of what's happening on Uniswap. We're cutting out the v two pools, but similarly, there were some pools that the contract name was null.
00:53:32.660 - 00:54:17.556, Speaker A: So that's another area that we should figure out and dive deeper into. To answer the question, we could go through and kind of calculate a lot of those same, you know, let's, you know, distinct origin from address, start calculating user metrics and label that ourselves, kind of as the v three type work. Um, but let's say we wanted to hone in on, you know, some of the more, uh, of what people are actually doing. Um, so that's what we'll do next. Uh, we are running out of time here, uh, but so I kind of want to give more of a preview of what's going to happen next, is that, uh, we might want to know how much volume is passing through uniswap v three instead of just the users. User numbers are great, and it's one metric. Uh, but volume and TVL are very important.
00:54:17.556 - 00:55:07.020, Speaker A: As we saw in the Uniswap info page, they're processing 1.28 bill a day, and that's actually a bit on the lower end compared to earlier in the year. As we scroll back and look at their very busy December, a spike here back in May, if we all remember what happened in May, people were trying to swap out of certain assets. So we would want to get into here. So using the technique that we learned earlier, we could get that number just by calling its key. So we have an inputs zero. Maybe it's not event inputs amount one.
00:55:07.020 - 00:55:49.722, Speaker A: We run that, we haven't changed anything else. We're still selecting all of them, and then we end up with at the very end here. There we go. Finally, event inputs amount zero and amount one as a number itself, negative and positive. So next steps would be, all right, looks like there's always one negative and one positive. Maybe that indicates one's entering or leaving my wallet or maybe entering or leaving the pool. And how do we determine which one's amount zero and which one's amount one? Uh, based on, you know, the pool information, uh, you know, what are the two assets that are actually being traded here? Uh, and that would, you know, preview for next time.
00:55:49.722 - 00:56:49.044, Speaker A: Uh, would most likely require looking at the actual liquidity pools. Um, and looking at contract address here we know is the uniswap v three pool. Perhaps the Dex liquidity pool table has something like a pool name, token zero and token one. So we also got swap v two and sushiswap in here. So that would be kind of the next step is let's join that into here and let's bring more information about what's going on with the pool so we can start to calculate those types of metrics. But this, you know, this is how we start to move past the easy tables, and this is how we actually get into, you know, the broader analysis sphere and be able to use tools like dune and the fact transaction tables by understanding a little bit of how they're structured, but most importantly, how the protocol itself actually operates. I didn't spend too much time on that outside of showing what a swap might look like.
00:56:49.044 - 00:57:26.222, Speaker A: But if you're interested in liquidity pools, then let's maybe open up a small position and see what that looks like. Or find their contracts on Etherscan and click through. Excuse me. Yeah, some of the transactions here, like we were doing earlier in this session. And, you know, that's really where the analysis part gets kicked off, is when you can move beyond the easy tables. Data is unfortunately never as clean as it is in these easy tables. It's great that the work was done to build these out, and I think they're awesome for teaching SQL, so that's why we spent so much time in them for the first couple of weeks.
00:57:26.222 - 00:58:23.858, Speaker A: But to truly get into what's happening, there's going to be a lot of cleaning that you're going to have to do on your own. Figuring out what's happening in the logs what information do I need to pull out from this transaction? What's relevant and how do we actually determine that? So that's where a lot of focus is going to be from here on out. So hopefully this was a not too cumbersome introduction into getting into the fact tables and looking at transactions and logs. We will continue with this, um, probably in about two weeks. Uh, so update on next week. We are going to be doing it a little bit later than usual, still on Monday, uh, but it is going to be a dune focused session led by Dunewizard Shushin eth, who works for optimism. Uh, so she's going to come in and take a look at, you know, a lot of the stuff that we've been doing, but using that platform instead of flipside, how the tables differ, and how you would similarly go through an analysis and build up a dashboard using Dune.
00:58:23.858 - 00:59:12.332, Speaker A: And then we'll come back and we'll continue with really getting into the transactions, whether it be flipside or dune, and how to start to pull out those inferences and putting together a professional overview and professional dashboard. So I will say that's it for the content for now. We are at the top of the hour, but I do want to leave a couple minutes for Q and A. So excuse me while I read back a little bit. What are those events input querying. So let's hide that so we can just see the results here. So we're still in fact event logs.
00:59:12.332 - 00:59:57.790, Speaker A: And in here we have a table, or a column rather, event inputs. Before I just answer the question, I will say best practice is always to go to documentation. We are using the Ethereum core tables, and now we are, instead of an easy table, we are in event logs. So the decoded inputs for a given event, understandably that's a little lacking in detail. So we'll go back to where we were earlier in the session, where we started to see some of this information where we honed in on. Okay, amount, zero amount, one event type swap. That's probably what we want.
00:59:57.790 - 01:00:22.584, Speaker A: So if you recall, I copied that original TX JSON from the transactions table into here. Let's go full screen so it's a little bit easier to see. And then within here, within the receipt, we have our logs that we are looking at on Etherscan. So this tab is just those logs. Sorry for scrolling up fast there. I know it gets blurry. So then here we have inputs.
01:00:22.584 - 01:00:46.358, Speaker A: So contract event name. That is that column. I think it's just event, underscore name, it's approval. And we have some inputs here just so it's consistent with what we've been looking at. Let me scroll down to the swap one. So now we have these decoded logs where the event name is swap input and amount zero. We know from looking at it on either scan and from what the type of transaction was.
01:00:46.358 - 01:01:26.120, Speaker A: This is the 50 die and this is the 0.026 wrapped ETH recipient sender. All sorts of metadata in here that should match up with amount zero. Amount one liquidity recipient sender. So that is coming from the decoded logs within the transaction. JSON specifically for the where the event name right here is swap. Alright.
01:01:26.120 - 01:02:52.862, Speaker A: Anything else? If not, we do have our regular weekly office hours. It will be this Friday at six and you may be wondering why. So we are going to have our regular assessment, but I've also gone through and I've looked at, you know, some bounty questions that we've run in the past and thought, all right, what, what could we run that would be kind of similar? So we are going to actually run a educational bounty this week that's going to be open for students to use, for anyone really to actually go through. If you complete it and you submit something, you'll be awarded 100 xmetric. There's not going to be a standard review process because we don't know how many people are going to go through and actually answer these. But we are moving to office hours to Friday at 06:00 p.m. so just real quick, if you do not recall how to get to the bounty page on Metricsdao XYZ, if we scroll down to our process under analytics, we can view open requests and there will be a card dropping here shortly this afternoon for the bounty program, for the, for the blockchain analytics course specifically and I am looking to see if I can find the link rapidly and it will look like this once you open it up in full screen where you can practice what you've learned and earn x metric, it is by no means a, you know, required bounty to do.
01:02:52.862 - 01:04:02.650, Speaker A: This is for those that want to go above and beyond and the questions are framed to be similar to what we did today where there is a portion that you can go through and just use some of the easy tables. But for each one of these there is an option opportunity to go beyond and go into the fact transactions or fact event logs or even into a, you know, a different, different blockchains table. So in these dexs, if I were to go back to Uniswap, I could change network here to Polygon polygon is a L2 on Ethereum and I can actually use Uniswap on polygon. And part of the reason one would do that is the insanely low fees that happen over there. But Polygon doesn't have an easy deck swap, so if you wanted to look at any uniswap metrics on polygon, you'd have to go back to those transactions and event logs table so wrote these up just to be practice. We will be there to help you through any questions that you might have in office hours. These, like I said, will be dropped on this bounty page, hopefully by tonight.
01:04:02.650 - 01:04:40.852, Speaker A: I don't know exactly the ETA on that, but it will be soon. Cool. So it looks like we have no more questions. Hope to see everybody in the chat as the assessment comes out and as people work through some of these optional assessments. Once again, you get 100 x metric for that. And office hours is on Friday. If you have any questions about those educational bounties or need some help with it or just want to see, all right, I did this part, but I can't go into the polygon tables.
01:04:40.852 - 01:04:50.500, Speaker A: I get lost. Help me out here. We will be there and hopefully lead you on your way. Thanks all. Bye.
