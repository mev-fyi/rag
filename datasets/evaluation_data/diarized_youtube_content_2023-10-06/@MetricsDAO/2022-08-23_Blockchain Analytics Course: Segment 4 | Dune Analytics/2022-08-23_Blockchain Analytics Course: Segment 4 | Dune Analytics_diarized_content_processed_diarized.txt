00:00:15.200 - 00:02:11.508, Speaker A: Hello. We're just waiting for more people to come in before we get started. Today it all right, so I'm Trishin and today I'm going to lead the blockchain data 101 workshop segment four. And today we'll be covering doing analytics as well as focusing mostly on like writing SQL queries in doing V two query engine. So if you've never used doing analytics before, it is one of the popular kind of like blockchain analytics data tools that a lot of people use and share on Twitter. And there's right now two versions running on Dune at the moment. So V one and V two.
00:02:11.508 - 00:03:01.252, Speaker A: And I'm going to explain the difference between V one and V two. And in today's workshop we're going to focus mostly on querying in V two. So I prepared this kind of dune dashboard for everyone to have a look at after the workshop. But we'll go through each of them as well as doing live demo as well. So it's not just about staring at the screen and looking at the written SQL queries. But first of all, what are the differences between Doom V one and V two? The first difference is they're using different SQL language. In V one it's mostly using postgres SQL, and right now in V two it's using the databricks SQL.
00:03:01.252 - 00:04:00.492, Speaker A: So there's a few difference, like some minimal differences between the SQL syntax which we will demonstrate, not all of them, but some of them in the demo. But here is a very good summary in the doing docs about the SQL differences so you can use them to have a reference. And this will keep updating when other contributors come in and kind of specify these are the differences. A few things that I come across from time to time is basically, I think in Doom V one you do. So addresses like the wallet addresses or transaction hashes are in the byte, it's kind of in the byte code. So the data type is byte t and it's usually like a slash so it replacing zero with the rest of the string. Sorry, not the string but the by t.
00:04:00.492 - 00:04:43.726, Speaker A: However, in V two it's actually a string. So you can just copy and paste it from etherscan. But since everything is in lowercase, so you have to do like lower the wallet address or anything, any other hashes. So we're going to kind of like talk through that later on. And then yes, it's like a very nice kind of summary in terms of how you're going to translate your V one query into V two. So that's one of the differences. The other difference is, so since there are two different databases, the V two version is actually more colon oriented instead of role oriented.
00:04:43.726 - 00:05:28.040, Speaker A: And I'll explain that very quickly back to the doc. So there's a very long kind of paragraph about what is role oriented and what is column oriented. And what I get my takeaway from this is that, so imagine your database is like a book, and whenever you want to, whenever you want to query the data, you have, whenever you want to query the data, you have to. Oh yeah, sure. Oh, looks clear now. Yep. So yeah, basically imagine this is a book and then whenever you want to query it, you are flipping, flipping to a page.
00:05:28.040 - 00:06:15.234, Speaker A: And normally they store the data as in terms of maybe hundreds or thousands of rows together in one page and you use that as your page header. So every time when you query, say row 500 to 600, you flip to that page and then here it is. So that's more role oriented. And if you query roles like continuous roles, it will be much faster. But if you want to query discrete roles, for example like page five, page 99, and then page, I don't know, 1000 1 million, then it's going to be slower. So that's the drawback of this like row oriented database. And the new V two engine is column oriented.
00:06:15.234 - 00:07:08.396, Speaker A: So that means you're going to have columns as one of the page header and then you also have different roles stored. So that means it's very good for computing aggregation stuff. For example, you want to do, I don't know, sum or group sum some columns and then group by. It's actually much faster compared to the V one version. We will go through some examples of that to see the differences as well. But yeah, that's basically what is a role oriented versus a column oriented. And when you do queries, you have to kind of keep that in mind, especially in v two, because normally what I see people doing is that whenever they come to doing data analysis or exploratory analysis, the first thing they would do is find out the table and do select star from.
00:07:08.396 - 00:07:59.240, Speaker A: And if you do that in v two, sometimes it's going to take really long, depending on what, depending on what table you are querying from. For example, if you do ethereum transactions, we do select select stuff from limit 100. It's going to take ages and there's ways that you can make it run faster. So we're going to jump into the demo now by doing a very simple select star and then we'll see how it goes. So I have two tabs right now the first one, so this is a dune, this is a dune interface where you can switch from different chains. And then here specifically this one is v two. So right now I'm in v one ethereum and they actually look exactly the same.
00:07:59.240 - 00:09:14.320, Speaker A: So this is v one and then this is just v two that switch to it. But yeah, we're going to do a very simple query right now and the one I'm going to use is, so let's quickly inspect a transaction on easelscan. So here is a example transaction hash that I've got, and this is a very simple one which is just transferring from Coinbase centralized exchange to a wallet with like 102 asx. So that's the axie infinity token and that's a very simple transaction. So what we're going to do here is first we want to pull this out from, from doom and all you need to do is just, so this is v one right now I'm going to take a note and just to make sure I also remember, so all you need to do is just select from ethereum transactions wherever the hash equals this. And remember, because it's in v one right now we have to change this to the slash. So I guess this is kind of turning this into a by t data type.
00:09:14.320 - 00:10:09.602, Speaker A: And then you just do select stuff from, which is easy and we hit run, boom, it's out. So it takes 0 second and we get everything we want about this transaction. And I'm just going to do the same in v two progress from here. So the first thing that I mentioned is that because this one turns into a string now and everything is in lowercase, so what we need to do is yet hash equals lower. And let's see how long it's going to take here. So first of all, it's taking more than 0 second, which is not ideal because I think people have been talking about why is it so slow? Yes it is. That's because it's not role oriented and also it's not indexed, it's not indexed on transaction hashes.
00:10:09.602 - 00:10:58.900, Speaker A: So what we want to do here is actually providing more conditions we want to, so I guess what we know, what we know here is that we have block number, which is so block number is actually ordered, it has min and Max. Same applies to block timestamp. We know that is like on, I don't know, like 296 days ago. But the block number as well as the block time because they are ordered and we have min and max number. So it's kind of similar to a binary search where you know, the smallest number and the biggest number. And then if you provide, say, the block time, I sort of can do the search. So it's in between min and max.
00:10:58.900 - 00:11:33.374, Speaker A: Let's start from 50, and then we go from, I don't know, between zero and 50 and then in between that. So that's sort of how it works. So here, I'm gonna just quickly provide this block number here to make it run faster because it's ready after a minute. Let's cancel this and we hit run again. Ideally it should be faster, but let's see. Oh, why is this still taking. Yeah, I think I do.
00:11:33.374 - 00:12:00.704, Speaker A: Yeah. Okay. So I think last time when I ran this, it actually took 3 seconds. But 10 seconds is still much better than, um. Yeah, more than 1 minute. So as you can see, if you're doing queries in, in doing v two, especially looking at those like big tables, remember, you probably want to provide either time filter or whatever filter that applies to a column that has order. Yeah.
00:12:00.704 - 00:12:45.260, Speaker A: So when you do select stuff from this ethereum transactions, you probably want to kind of specify or maybe block number greater I than something. And then, and then, and then you, you do limit 100. Otherwise it's going to take forever and probably get timed out. So yeah, this is a very quick demo of, yeah, like the query time. But now we want to go a little bit deeper. So we, I guess, I guess what we want to do is we want to kind of pull out the information from a theorem transaction. Oh, yes.
00:12:45.260 - 00:13:24.598, Speaker A: I'm surprised that it doesn't just zooming everywhere. But yeah, this is the Ethereum transaction we're talking about. And we want to pull out, say for example, we want to get the front, we want to get the, to address, we want to also get the YARC 20 token transferred as well from Ethereum transaction table. And this is how we're going to do it. So I'm going to demo that in v one first and then we do that in v two. So we'll kind of do like switching between the tabs, but after that we'll be mostly focusing on v two, just not to confuse people. So yeah, there's a few differences.
00:13:24.598 - 00:14:22.810, Speaker A: So if you are actually querying something that is also using the same syntax as the SQL language, mostly what you want to do is you have this like quotation mark in v one. Excuse me. So what we want to get is, yeah, just nicely block time from to ah two. I forgot you don't have to use the quotation thing all the time. It's mostly just for uppercase columns and also any kind of, any kind of colonnade that is similar to the syntax, uh, similar to the syntax of the SQL language, for example, like from, um, so we get these columns as well as value. So the value here is actually the eth value. And in this transaction it actually has no eth value is zero.
00:14:22.810 - 00:15:11.838, Speaker A: Um, and then we also want to get the gas used. So the gas used is, sorry, not the gas use, but the gas price. So gas price is on layer one is just gas use times the gas price divided by one to the power of 18. So this is, yeah, one to the power of 18 as gas price east. What else do we want? So I'm going to quickly introduce a yemenite function, but what we want to get is, so let's quickly look at the data here. So this is the, so this is the data from this transaction. And normally for the first, I think for the first eight byte here.
00:15:11.838 - 00:15:53.434, Speaker A: So other than the slash x. So this part is actually called the method id or maybe the function signature. And usually you can use that to, to actually map to another table to understand what this method or function signature is. And I guess if you look at it here, that's exactly the same as what we see in the data part. So this is the method id and if you are familiar with it. So this is just a transfer, it's a transfer function call basically. And we want to get that from the data as well as the ERC 20.
00:15:53.434 - 00:16:45.370, Speaker A: So as well as the amount of the axie AsX token amount which is also like embedded in the inner data here. So as you can see, this is a transfer. This is to address. So we're going to transfer to this address basically. Yeah, so we transfer to this address and this hash is the value. And if you click decode input data, normally it will just show that if your contract is actually decoded. So how are we going to do it here? We're going to use this substring, I guess before we use the substring, I think we have to encode the data into, encode the data first.
00:16:45.370 - 00:17:09.209, Speaker A: So this, yeah, because this data is by t. Right now we can't do substring. Substring only applies to a string and it's not the string right now. So we're going to do encode data and then hex. So this will basically turn the whole thing into string. And then we do substring. So substring.
00:17:09.209 - 00:17:40.320, Speaker A: And we want to get the first eight. So I think when it turns into so we do the encode, it will leave out the slash x thing. And what we want is actually just the first. 1234-5678 so yeah, basically you get the first eight of the string. So this is substring and you take starting from one and you get eight up to position eight. Yeah. And this will be as the method id.
00:17:40.320 - 00:18:11.830, Speaker A: And now we also want to get the amount of token transferred. So it's very similar to what we did above. I'm just going to quickly copy and paste. But now the tricky thing is I want to know where do I start and where do I end. So normally how it works is that I think each of the hashes, let me quickly see it switch back. I didn't count it but I just know it. Not that I just know it but just, yeah, learned it from the experience.
00:18:11.830 - 00:18:44.000, Speaker A: But basically this is around 64 characters. So what we do here is, I know the ERC 20 thing. So this amount is the very last bit and that's 60. 64 and this one is also 64. So a little bit of math here. But basically what we have is. So that's going to be eight plus 68 plus 64.
00:18:44.000 - 00:19:11.016, Speaker A: So I'm just going to quickly throw that. So eight plus 64. So eight is the first 1st method id, the other 64 is the address. And we're going to start from here. So that's what, 72. But because normally we start from position one so it's going to be 72 plus another one and that's going to be 73 and, and then we get 64 characters. Let's see how it works.
00:19:11.016 - 00:19:54.828, Speaker A: I think it should be working. And that will, so this is going to grab I think the last bits of the 64 um, characters and we want to turn it into a number. So the really nice function created by the doom team. So it's called, I think it's by t two numeric. And we're going to turn this into an actual number and I guess. Oh, but we have to, yeah, this is a little bit complicated but yeah, before we, before we do by t numeric, we still have to decode it back. I think there's a, there's actually a function that helps you to do all this stuff I'm doing right now.
00:19:54.828 - 00:20:34.220, Speaker A: But yeah, I guess. Let me quickly recap. So what we've been doing here is we first kind of convert this into a string convert this data thing and then we get the last 64 characters from here. And then we have to sort of decode it back into a bytee again. And then we do by t two numeric. So we turn this into an actual numeric and let's see how it goes. I'm gonna just divide that by one to the power of, like to the power, sorry, ten to the power of 18 again.
00:20:34.220 - 00:21:19.554, Speaker A: And we call this, I don't know. Yeah, I'll say 20 amount, I guess. Token amount. Oh, yay. Sure, give me a second, I'll just quickly hit run. And so the purpose of doing this is, first of all, assume that you actually don't have an ERC 20 transfer table and you actually want to decode certain blockchain data in terms of what's happening in this transaction. So yeah, as you can see from the result here, we get the basic ones that we don't have to do anything complex.
00:21:19.554 - 00:22:02.110, Speaker A: We get the gas price, we also get a method id. So we know this is a transfer function signature and this is the token amount that actually got transferred in this transaction, at least. So it doesn't show up. It doesn't directly show up here because there's no eth transferred in the value. So that's why you have to do all this like complex kind of decode encode thing to actually get the token amount. So yeah, like the reason I kind of demonstrated here is because I think it's useful when it comes to, sometimes when it comes to like just querying the data from raw blockchain kind of. Yeah, transactions.
00:22:02.110 - 00:23:09.008, Speaker A: So, yeah. Does that answer the question? I mean, there's definitely an easier way of doing things, but kind of like start the hard way. So basically we, I know that here is just transferring ERC 20 data and there's actually a way of, in doing that you can do it easily instead of doing, doing this encode decode thing. So what you can do is actually, I think there's a table called ERC 20 transfer. Something, I always don't remember the name of this. And then, so, and then all you have to do is just get the same hash. Oh, why is it not showing up? I think it is this.
00:23:09.008 - 00:24:04.280, Speaker A: So this is, this has all, everything that is related to ERC 20 transfer and we are just using the same hash. And this is what the table is about. So contract address, block number from true and a value. And if we hit run, oh, it's not txhash, it's evtxhash event. And we hit run and that's going to show up the same thing. And this is the value that we get out of here. Uh, yes, yes, that's what we're trying to do.
00:24:04.280 - 00:24:35.180, Speaker A: But yeah, this you don't have to do it all the time. It's just a way of showing it. And I think sometimes it's useful. Um, if, if I guess your contract is not like properly decoded or, or there's more information to get out of, say, logs or traces. But I think now, because there's this such table exists, you can actually just use them. But I'm gonna quickly how to calculate the amount. Oh, yes.
00:24:35.180 - 00:25:11.798, Speaker A: Um, so let's get back to this quickly. Um, so I think for each of this. So, for example, this transfer function for all the method id is going to be zero, x plus another eight characters. So we know this is. Yeah, eight of them. And then once this thing finishes, the rest will start with lots of zeros. But then this, this, this thing is 64 characters as well as this.
00:25:11.798 - 00:25:53.080, Speaker A: So if you have a very complex function and you have, I don't know, multiple different inputs here, it's all going to be like, for each of them, it's all going to be like 64 characters in the data. And that's this. So this input data here is the same as the data in this transaction. So what we do is. So I know I want to get the last bit and that's 64 characters. So I want to, but I want to know where do I start from? So where do I start from is first method id is about. Yeah, so that's, that's eight of them.
00:25:53.080 - 00:26:30.280, Speaker A: So I start with eight, but I'm not starting from eight because if I start from eight and get 64, that is, that is actually kind of getting this part. So I want to skip this, which is also 64 characters. So that's going to be eight plus 64. And we'll start from one. So that's going to be one plus eight plus 64. So that's how we get 73, which is here. And so when, when it does the substring, it's going to start from the 73rd character and we'll go for.
00:26:30.280 - 00:27:07.450, Speaker A: And it's going to end at 74 plus. Sorry, 73 plus 64. Yeah, I hope that explains. So I'm gonna. Okay, cool. So I'm now going to quickly copy this thing and then we do this again in v two and see what the differences are in terms of syntax. So first of all, you have to change all this into a slightly different.
00:27:07.450 - 00:27:40.680, Speaker A: This is. How do we call this? But yeah, something different is not a quotation mark anymore. But yet normally you don't have to do it all the time. I'm just, this is just for demonstration purposes, which makes it look very tedious, but you don't have to do it all the time. So let me just quickly change a few things here. So hash, let's do lower and then we change it to zero. Another thing we do is.
00:27:40.680 - 00:28:27.190, Speaker A: Yeah, remember, it's going to take a long time. So I'm going to set block number as well. That's one of the differences. And now let's see. So these are all the same, which is simple. You don't even have to change this, which is nice, I guess one thing we have to do is, so we no longer have to do this encode decoding anymore, because the data now in ethereum transactions in v two is actually just a string. So yeah, like previously, the whole point I was doing all this encode decode thing is because it's not a string and we have to sort of turn this into a string so that I can do substring.
00:28:27.190 - 00:29:14.966, Speaker A: And if you see it now, the type, so you can see the data type here, which is just a string. So remove, so this, this can all be removed. Um, but one thing to note here is that because it's a string, so the Zero X is also part of, part of the whole string. So instead of doing eight characters, we have to add the 20 X as well. So it's going to be turn into ten. But I think you can also remove them if you don't want the Zero X because it's not, it's the same everywhere. But I, here, I'm just gonna keep it and then what else? This thing can also be removed.
00:29:14.966 - 00:29:48.976, Speaker A: Now I'm gonna quickly. So I'm gonna remove this bit. This is no longer needed. This is also no longer needed. Doing lots of delete change and. Yeah, so if you got what I was talking about previously about how I arrived at 73 now because of the Zero X as well, just, just add two here. Sorry.
00:29:48.976 - 00:30:24.610, Speaker A: So that's going to be 73 plus the Zero X to two characters. So it's going to be start from 75 instead. And yeah, so as you can see, we remove everything about the encode decode of hexes and we just do a substring and then also in v two. So if you see the doc. Right. Previously when I was doing this demo, I was thinking, oh, so where's this by tuner numeric function equivalent in v two? And they have this. I tried it, it doesn't work.
00:30:24.610 - 00:30:58.390, Speaker A: So I searched on the dune discord and they actually have a bytey two numeric v two. And you don't have to, don't have to worry about this at all. I think I'm going to submit a pr to update the doc here. But what you do is just change this to v two as well. And then I think it should work with the same thing. I got queued. Um, but yeah, I think normally it should run and oh, and this is v two.
00:30:58.390 - 00:31:46.374, Speaker A: So as you can see here are certain syntax differences in terms of using this quotation mark thing. And then also in terms of how you get the method id, you're going to use a different bytee to numeric lead to, um, but then after that, and also set more where conditions here. And then after that you're gonna get the same result as what we did in v one. Yeah. Having no idea why I got queued. Maybe just too many people doing the query. Oh, why do I get queued? Oh yeah, the reason that v two is organized so differently.
00:31:46.374 - 00:32:27.780, Speaker A: So yeah, I think fundamentally is the database different? As I mentioned before, one is postgres SQL, the other one is databricks SQL. So it's just like slightly different SQL kind of syntax thing. And if you use flipside crypto quite a lot, they are using Snowflake. So that's also different. But I think fundamentally you still select stuff from and doing all the SQL stuff, it's just the syntax. If that's what you're asking for, like in terms of why it's organized so differently, or maybe there's something else. Yeah, but if that's what you're asking, then that's my answer.
00:32:27.780 - 00:33:08.394, Speaker A: But if you want to know more or maybe that's, oh, okay, cool. Yeah, actually I don't know why I get queued, which is bad. So while I'm getting queued, let's just keep going. So in the dashboard I'm going to share later here is actually what I was doing just now. And this is just like a side by side comparison of what the difference is and you get the query. So now the second bit is, uh, we want to kind of utilize what doing has compromised for. So basically is column oriented.
00:33:08.394 - 00:33:59.622, Speaker A: And what does that even mean? Like, so if, if when we do select stuff from a hash is taking slightly longer than v one, why do we even bother moving to a v two? And this is what v two is actually better at doing. So what we're going to do is we're going to do some aggregation here, looking at Ethereum transactions and users as well as basically calculating a lot of things. The amount of gas use, median average, and then the gas price as well. And we want to aggregate it across maybe since from 2020 May. So that's what I did for v two at least. And then we also do the same in v one and see how much slower and also how much longer it's going to take. And apparently this one got timed out already.
00:33:59.622 - 00:34:44.629, Speaker A: So this is why I didn't v one. And that's the same, like underlying data is all the same and this is why didn't v two, it still got run. So yeah, let's, let's do it. I'm going to cancel this quickly. If it doesn't run, I'll try it again. So I'm, I'm um, since we're doing v two, right, so maybe let's do the query first in v two and then, and then we do in v one and c and see how long it is going to take. Or is it just my Internet? It's actually slow everywhere.
00:34:44.629 - 00:35:43.232, Speaker A: Cool. So yeah, basically we want to have a high level summary of Ethereum transactions since 2020 May and we are using v two right now. So I'm not going to use any of those quotation marks anymore just because I'm lazy. But yeah, first thing is we want to get it maybe on what time interval. So I'm going to quickly introduce something nice. So for example, right now I can't decide what kind of time interval I want to do. So let's use something called parameter and that will solve the problem.
00:35:43.232 - 00:36:25.948, Speaker A: So basically I'll let other people or the end user to decide what kind of date truncation they want. So I'm just call this tiny table and I'm going to do block time as big time. So here is very nice that you can just specify. So I'm going to create a list just to make people's life easier. Week, month, year, I'll set day as default or maybe week as default. Yeah. So if I hit run, this will compile the, this bit here into week.
00:36:25.948 - 00:37:05.332, Speaker A: And if you switch it from something else, it will be month, year, whatever. It just makes the end user experience nice. And sometimes as like a data person, you also have to think about who's actually looking at the dashboard or who's using it. How can we make people's life easier as well? So, yeah, and now what we do is a few things. We want to get the number of transactions, which is actually quite easy. So you just need to count the hash as number of transactions and then count. I also want to count how many active addresses there are.
00:37:05.332 - 00:37:47.340, Speaker A: So let's count distinct from as number of addresses and then we want to know the total amount of gas used. So that's the sum of gas use as well as the average gas used. So yeah, let's do a lot of computation and aggregation here. Average gas used, what else we want? Maybe not the median. I'm not, don't want to bother the median anymore. And also the average gas price. Average gas price.
00:37:47.340 - 00:38:40.440, Speaker A: Is that all? Yeah, yeah, let's, let's try it first. And then if we want to add additional things, then we add and then group by one. Another thing is where I want to set it to block. So I think what I did in, in my example is I set the block number to greater than a million. I'm just going to quickly copy this. So it's going to be greater than all these blocks and then group by. And I guess I also want to add, I will quickly explain that later.
00:38:40.440 - 00:39:33.342, Speaker A: So yeah, I think in, so if you look at Ethereum transactions there is success, which is a boolean. So I just want to get the transactions that didn't fail. So I put a success here and also I set block time just to make sure things is actually running. Otherwise it's going to take ages. If we, if I query this amount of data that we have and now we're just going to hit run, it's going to be bad. If I, if everything I have is oh, it's not cute anymore. So yeah, while it's running we're going to do the same in v one just to kind of compare, like compared the query time and I think the rest is actually the same.
00:39:33.342 - 00:40:12.840, Speaker A: Oh, this is bad. But. So I'm just going to comment everything out and let's see if I need to change anything. I don't think so other than this. And I also need to get the same value. Gonna copy and paste right here, change it to week save and then I think I hit run. Yeah.
00:40:12.840 - 00:41:12.580, Speaker A: So while we are waiting, lock number doesn't exist. Oh, I'm kind of switching between different tabs right now. So while we're waiting for this two aggregation queries to run, let me quickly fix what's happening here. The block number, is it not called block number? It is. Did I do anything wrong here? Hmm. Block number doesn't exist. What is there? Actually? Let me just try again here.
00:41:12.580 - 00:41:43.660, Speaker A: Oh, did I spell it wrongly? Oh yes. Thank you. Thank you. Couldn't tell the difference but yeah, so yeah, they're all running at the moment. This one is probably going to take longer. This one probably will finish around five to five to six minutes. But yeah, we basically querying the data of Ethereum from, from 2020 May and.
00:41:43.660 - 00:42:12.562, Speaker A: Yeah, that's going to take a while. So maybe let's take a quick question. Yeah. If anyone has any questions or we can kind of continue while all the queries are running. Nice. So if there's no questions, let's. So, well, after the query finishes.
00:42:12.562 - 00:42:47.760, Speaker A: Oh, there's a question. What's the difference between average and medium? Yeah, so average is kind of like. Oh, yeah, I was like, average is just getting average across all the numbers, but I will probably start from medium first. So medium is getting. So if you have, I don't know, a list of numbers from one to 100, you have like 1234 up to 100 and you want to get the medium. So medium is, as we can see here, medium is 50. So medium is just getting the, like the 50.
00:42:47.760 - 00:43:18.598, Speaker A: So basically just getting. I was, if you have a number of, like, from zero to 100, you're pretty much getting the middle number out of this ordered list. That's going to be 50. So that's the median. And if you have more, more of the numbers, say like to one to 1 million, then the median is going to be 500, 500k. But the average is going to be like an average across all those numbers. So if you have, you want to know the average between one to 100, you add often up.
00:43:18.598 - 00:44:01.414, Speaker A: So one plus everything up to 100 and divide it by 100 and you probably won't have get 50. Yeah. And I hope that explains. Is it asking the difference between average and median or how. Yeah, I hope I'm getting the questions right. And so, yeah, and while we're waiting, so once the query finishes running, we can actually do some charts to make things look nicer and see how we do visualization in doing as well. Next question.
00:44:01.414 - 00:44:51.210, Speaker A: How can we find the correct table for analysis? For example, we have prepared tables for platform. How can we trust each one? How to get. Yeah, I guess the way I do it is, first of all, you have to think about. So if you actually know what the, what the platform or the protocol or the Dapp that you're looking for, normally you can check whether those, those protocols have been decoded. So, yeah, there's a lot of things here, as you can, can see. And what I normally do is either, for example, I want to look at something about Aave. I just like search for Aave and see what's coming out here.
00:44:51.210 - 00:45:16.678, Speaker A: So, for example, I think here is. Yeah, we have Aave on ethereum and optimism. Aave Gochi is not what I'm looking for. And also like Aave, v one and v two. And these are actually all the decoded contracts of Aave. So, for example, these are like the different, I don't know, functions and events, like all this landing pool and stuff. And then depends on what you're looking for.
00:45:16.678 - 00:45:55.388, Speaker A: For example, maybe this landing pool is about like getting the borrowing and supplying thing. So for example, you want to look at. Oh, I want to know, like, all these historical records of Aave borrowings. And you probably can check what's in this table. So it's a little bit of like trial and error sometimes, unless you are super familiar with the protocol by itself. And then here, for example, this is my first time looking to them. But I guess I'm guessing that this borrow event thing has all the records of the borrower records.
00:45:55.388 - 00:46:58.730, Speaker A: And what I normally do is I'll just select start from limit by 100, but also remember to limit by whatever block time or block number. And then I'll just inspect the transaction hash and see what's happening here exactly on ether scan, just to try to understand, is that something that I'm looking for? And I think that applies to all the other different protocols as well. So I think, yeah, as a data person doing like on chain analytics, you. Yeah, sometimes you also have to like, yeah, understand the analysis that you're doing, the protocols that you're looking to just familiarize yourself with that sometimes even spent doing a few transactions to understand what kind of event or what kind of function get called, and then you can start kind of doing it. But so that's one way of doing that if nobody has done the analysis before. And also the, the other way of doing it is. Yeah, you search on existing dashboard that exists on doom and see how other people do it.
00:46:58.730 - 00:47:31.410, Speaker A: Not necessary all the time, that the way other people do things is going to be 100% correct. But that also helps you to kind of. Yeah, find out the right table, kind of looking at the queries that people do. Maybe the logic as well. I hope that answers the question. I think there was another question that I didn't see. Okay, since, um.
00:47:31.410 - 00:48:02.886, Speaker A: Okay, this one finishes. I'll just quickly wrap this one up. But basically this is the v two of querying the same transaction hashes. And we have the method id, we have the token amount, and this zero x can also be truncated if you want to. But yeah, that's how it works. Now back to this aggregation. So this is the v two aggregation that we just did, and it finishes around four minutes while the other one is still running.
00:48:02.886 - 00:48:44.378, Speaker A: So let's quickly do some charts. And this is the data that we pulled out just now. So we have the daytime starting from block number a million and then block time, sorry, the time is 2020 in May. And we have all this like nicely aggregated summarized data about transactions, addresses, gas use, etcetera. So I'm going to quickly do two visualizations, I guess. So one is, I guess we do one that is gas related, have a bar chart. So yeah, this is actually transactions, but I want to change it to gas use.
00:48:44.378 - 00:49:11.182, Speaker A: So this is the total amount of unit, whatever unit that gas is. So this is, yeah, this is the total gas use. And we want to also plot something side by side. We want to have the average gas use as I think we would just. Yeah, maybe average gas use, let's have it. So average gas use. And because the average gas use is much smaller than the total gas, so they are on completely different scales.
00:49:11.182 - 00:50:04.524, Speaker A: And we want to change that because nobody is going to understand what's happening here. So what we do is first of all, I want to change it to a line chart, and then also I want to enable the right axis. Yeah, enable the right axis and then change this to the right axis as well. So it's going to look like this left axis is the total guess and then the right is the average gas. And we also want to kind of make the label format looks nicer because previously is lots of decimals. And we change it into something like this to make it look much more human readable. And then I think right now I know left is total and then write is average, but I think the end user probably wouldn't know.
00:50:04.524 - 00:50:45.670, Speaker A: So in order to just be more user friendly, I'll just total guess. And the other one is average guessdehenite and looks much nicer now. And you can also title it, I don't know, ethereum gas use or something like that. And then you can save it and add to your dashboard. So normally what you do is. Yeah, because I haven't saved it, but you save it and then you can add it to whatever dashboard that you're looking for. So this is how you kind of like do a quick chart here.
00:50:45.670 - 00:51:19.048, Speaker A: Yeah. So do I want to do another one? Probably not. They're the same. So yeah, you can also just add number of transactions and addresses in a similar way as well. And I'll quickly go back to what I've done here. So this is what I did. So that's transactions and users and you can also change how the legend is looking like as well because normally the legend would just reflect the column name and sometimes the column name is like something, something underscore which doesn't look nice.
00:51:19.048 - 00:52:40.068, Speaker A: But yeah, it's all these are just decorated things, but it will actually set you apart from a lot of other data visualizations already. But yeah, so this is what I been talking about. Like why is it much faster in terms of doing all these aggregations and took five minutes and this one is still running in v one because first of all, a lot of data and then also v one is not optimized for this tell the advantage of being a dune wizard. I wouldn't say, I probably wouldn't say there's advantage of either using doing a flip side or anything. Normally I got to start using Dune just because I started a course last year and I got introduced to doom first. But I think normally you should try not to constrain yourself in terms of, oh, I'm only going to use dune, I'm only going to use flip side or something else, but more just whatever tools that provide you with the data you want and helps you with your analysis. Then you just going to use that? Yeah, like from time to time I also use different other tools as well.
00:52:40.068 - 00:53:55.942, Speaker A: Just because sometimes, for example, you've all querying like, I don't know, harmony or near, like those data doesn't exist on doom and you want to do that. So you go to flip side and yeah, like if you want to do something else that only exists in certain platforms or maybe even do analysis that is not available on dune or flip side, or maybe you want to do some, I don't know, like Python or R, then you probably just have to set up your local instance and do things like either locally on the cloud. So yeah, I think it really depends, but I think it would be nice that when you first get started, if you're not familiar with all this like data toolings or blockchain stuff, just stick with one and join one community. So here, trying to be pretty much like platform neutral so you can choose whichever you prefer and I'm pretty sure if you're doing a great job, you will thrive anywhere. So yeah, that would be my, that would be my answer to the questions. So yeah, I'll probably nothing. Not going to keep running this to waste the resources, but this is going to take ages.
00:53:55.942 - 00:55:00.994, Speaker A: I'm going to quickly cancel that and we move on to, I guess I'll go to the last bit of using, doing abstractions and there's actually another thing towards the end, but we probably don't have time to go through it. So I'm going to share the link to the dashboard later on. So anyone can actually come back and see what I've done here and then also play around, um, by forking it or whatever. But yeah, last bit I'm going to talk about today is actually using, doing abstractions. So previously all the examples we've done is actually just using either raw blockchain data or maybe sometimes decoded contracts, which I actually haven't done there. But you might wonder what is abstractions or abstraction is, yeah, table basically, but it's customed table that a lot of other doom wizards curate them. So it's very similar to all this fact table dimtable in flip side as well, that you don't have to worry about doing all this hash encoding decoding.
00:55:00.994 - 00:55:52.110, Speaker A: You don't have to do all this stuff in order to get the number you want. And usually doing abstractions is organized in two different ways. So one is sector related. For example, there is abstractions that is like NFT trades, Dex trades, lending stable coins. So all these tables are representing a sector and you don't. So for example, traditionally if you want to do, oh, I want to get the entire NFT market and see how the market share is across opensea, across Luxray. And even looking at Solana, you probably have to go through all of them and aggregate them together manually by yourself in your SQL query, which is very tedious and also going to take a long time and repetitive as well.
00:55:52.110 - 00:56:31.408, Speaker A: So imagine every single person doing that. That's just lots of work. So what NFT trace does is having this like nicely aggregated summary of different marketplaces. And you don't have to worry about how do I combine them, how do I find a contract, et cetera. So right now I don't think NFT trades exist in V two, but these are on V one. And I think the dune team has been working on getting those nicely, nicely curated abstractions into V two. But there's also something that exists, for example, this opensea seaport contract that I'm going to talk about.
00:56:31.408 - 00:57:25.760, Speaker A: So we will get, so what we want to get, the end result is basically we want to know the top NFT collections by volume in the last seven days. And then we're going to use this contract, this abstraction, to get those which is much more similar to the traditional way we do query the data table rather than decoding contracts. Um, maybe I'll just close, I'll just use reuse this. So let's have a look at the, the abstraction first. So it's actually broken down into like wall table decoded projects abstractions. So I'm going to have a look at the people. And they have, excuse me, they have one table which is called view transactions.
00:57:25.760 - 00:58:14.890, Speaker A: And as you can see from here, they have the traditional like block number, block time, the buyer, the category, contracts, whatever Yasi standard and exchange addresses, the fee they received. What is the NFT project all about? So yeah, as you can see, you won't be able to get this kind of nicely curated data directly from the blockchain. But with the help from the community and also other people, you can actually get them very easily. And that's going to make all of our life much more simpler. So I'm going to quickly have a look. So what we want to get achieved for the end goal is to get the top collections by volume. So let's get started.
00:58:14.890 - 00:59:02.740, Speaker A: Select from, if you are lazy, typing out the name, you can just click here as well. And then what's here last seven days. So I'm gonna do some filter first where the, where the block time is greater than now minus interval seven days. So this is going to specify it's only the last seven days. What else do I need? Maybe so we're going to use USD amount. And there's a column called USD amount here. USD, not the fee, where I can't see the USD amount.
00:59:02.740 - 00:59:29.170, Speaker A: Oh, here, just do a little bit of USD amount is not none. Sorry. It's greater than zero. And also I think additional thing I want is this project name is not null. Cool. And what else we need? So we want to know that by collection. So we probably need something like NFT project name.
00:59:29.170 - 01:00:28.080, Speaker A: Project name, what else? Oh, maybe also know the number of transactions as well. So that's going to be, I think it's the TX hash. TX hash. Get the number of transactions as number of transactions and also sum the USD amount as, as volume. So yeah, that's pretty easy. So you can just get them very easily. If you, if there's like always going to be this nicely curated table, then you can also also ordered by three, which is volume, USD and just hit run.
01:00:28.080 - 01:01:33.590, Speaker A: So yeah, what this table is going to create is an NFT project ordered by volume from. Oh, I forgot to do descending. Yeah, but it's going to give me that in descending order to see which one is the and which one is the smallest. Actually, in my example in the dashboard, I also create like a hyperlink for the project name. So when you click the name, there's going to show you the contract of the NFT project on Etherscan as well. But I'm not going to go through here just because we are almost running out of time. But I also want to quickly demonstrate something else that is kind of like showing the power of doing queries in v two as well, which is you can actually do some kind of, I would say cross chain analysis.
01:01:33.590 - 01:02:15.920, Speaker A: But so here is actually an example of comparing the daily fees across magic Eden looks rare and opensea. So instead of writing everything out, I'm just going to quickly walk through what I've done here. So click that. So as you can see, I actually utilize, so I take advantage of two of the abstractions that people created. So one is called magiceden fees. And if you see from here abstractions you can actually I'm just going to search. So here magic Eden is a project.
01:02:15.920 - 01:03:14.792, Speaker A: They actually have a fee table which shows you aggregator address, the name, the block number, blah blah blah, everything as well as the platform fee, I think in USD as well. So what I got is just get the day, get the project which is magic Eden and then the fee. And I limit the time to greater than June 15 just because I think that's when OpenSEA launched the seaport new contract and then I'll do the same for seaport as well. So that's the OpenSea one and it's very nice and easy. You also just do daytime project and sum and I union them together. So I created this CTE like comment table expression called OpenSea Magic Eden and I just union them together. When you do, when you do union, just remember everything should be the same in terms of column name and also the order of the columns as well.
01:03:14.792 - 01:04:01.244, Speaker A: So once that's unioned, now I need to do the same for looksrare. But looks rare actually doesn't have any abstractions. So nobody has helped me to prepare this kind of like looks rare fees or whatever looks rare view transaction nicely. Then what am I going to do? So the thing I did was actually find out the transaction on looksrare, for example, this one. So yeah, that's what I mentioned. Like oh, how do we do stuff when nobody has curated the tables for us. For example, this is a luxray transaction that I found, which is transfer ens from this wallet to the other wallet of the token.
01:04:01.244 - 01:04:26.130, Speaker A: So there's only one token got transferred for 0.038 with. And then what we want is actually find out what the fees look through as a platform get. So as you can see here, the total amount. And this is what the seller is going to get. 0.0372. And this is actually the feed that Luxray as a platform get.
01:04:26.130 - 01:05:01.672, Speaker A: So basically what we want to do here is we want to get this number. And I was trying to look at luxray decoded contracts to find out the fees, but I couldn't find it. So if that's the case now I have to come back to. Yeah, pretty much decoding. Decoding, not this, but basically decoding some of the logs to get this number. And if you click the logs right. So there's a few things happening here, but yeah, because so not.
01:05:01.672 - 01:05:42.130, Speaker A: Don't worry about this deposit right now because I know I'm going to find out the transfer because I want to know what, what is the, what is the fee that actually got transferred from, from. Yeah, actually got transferred to looksrare account. So here, if I transfer, there's a few transfers happening here. So one transfer is this, which is, this is actually the fee that we want to get. And then there's also another transfer. This is transferring whatever amount deducted by the fee to the seller. And there's also another transfer.
01:05:42.130 - 01:06:17.522, Speaker A: I think it doesn't really emit anything. So what we want to get is out of ethereum logs. We want to get this transfer with this amount. So that is actually the transfer fee and that will apply to all the rest of the luxray transactions unless they upgrade the contract. Um, but I think the transfer is always going to remain the same unless they, they change the address or something. So, um, here is the transfer topic. I think so, yeah.
01:06:17.522 - 01:06:48.290, Speaker A: As you can see, the transfer also having the same topic. And so this is topic one address and the. So from the dress to address and the raw amount. So this is what we're trying to do. Let me go back to it. So once we understand what's happening in the Ethereum logs, what I've been doing here is Ethereum deluxe. We want to get.
01:06:48.290 - 01:07:44.130, Speaker A: So actually, before we get into this. So what I did previously is before you even try to query the whole kind of transaction records, because we have this example, transaction hash. So what I did was let's just look at what's happening in this transaction hash in the ethereum log and see if I'm actually getting the data that I want. So what I did is just having set this and get this transaction, which we can probably quickly show it here. So instead of having all this thing here right now, let's quickly run that and see what it does. Even comment this out as well. So yeah, let's have a look.
01:07:44.130 - 01:08:28.058, Speaker A: Oh, another cued, but yeah, so I think basically this is going to pull out all the five logs that we are seeing here. But as I mentioned previously, we just need the transfer. So we have to specify a few things, basically saying, oh, this topic is going to be this hash and then we also want to know. So this is the wallet that they transfer the fee to. So I'm going to specify this as well. So that's what I've done here. Topic one equals the hashes that I highlighted just now.
01:08:28.058 - 01:09:12.070, Speaker A: And then I also want to get the address that got transferred to. Oh, oh, oh, yeah, I know what's happening because I didn't do alias. Um, so let me quickly have a look. Oh yeah. Um, so this is the address that is going to transfer to. As for the, for the Luxray platform fees and then also want to specify the contract address, which is the weth contract address. Um, and that's how you kind of grab all the fees from Luxray.
01:09:12.070 - 01:10:18.250, Speaker A: So once this finishes we can have a look, but once that's done, you can get the fee original number and then we get the prices. So we want to convert into USD because for OpenSea and Magic Eden, someone else has already done that for us. So what we do is we want to get the with fees from this prices USD. Once you get the USD prices, you just need to join price table and this fee table together to convert that into USD. And this is what I was doing here. So you join them based on daytime and then get the price in USD and union everything together. So this is the luxray thing that we did just now in Ethereum logs and then just union that with the Opensea and Magic Eden number and then we will get the bar chart, like the stacked bar chart that I showed you previously.
01:10:18.250 - 01:11:14.998, Speaker A: And that's it. Yeah. So let me just quickly pause and for any questions. Um, no, I think at the moment you won't be able to do them just because first of all, they're using completely different databases and also there are two. Oh, are you saying you want to combine a query that you're running during a query that you run in flip side together? Yes, the answer is still no, just because first of all, the tables are named differently and probably the structure are different as well. So yeah, I don't think there's any way of doing them you can sort of like translate. So, for example, if you're querying the Ethereum transactions on flip side.
01:11:14.998 - 01:12:06.042, Speaker A: And you want to copy and paste that into doom, you can, but you probably have to change first the table name and then maybe the column name and. Yeah, and other stuff. Yeah, I think the underlying data will be the same, for example, for ethereum transactions and logs and everything. But just how, just the way they are curated or formatted as in terms of columns, is different. So you can't really do that. Any other questions? I'm going to comment this one out. Okay, cool.
01:12:06.042 - 01:12:34.448, Speaker A: I'm just gonna quickly revert this back and then, because right now nothing is showing up here anymore. But yeah, what I did previously is, yeah, this is a transaction that I just looked at on luxray with the ENS token sale. And these are the locks. So as you can see, there's multiple different locks from different contract addresses. This is, I think this is the weth. This is the weth address. Yes.
01:12:34.448 - 01:13:15.880, Speaker A: So what I did is, yeah, let's grab the west contract address. Grab the topic one that is related to a transfer and then also topic three, which is the address that it transferred to, which is this address that I want, that is going to a looksrare, whatever treasury address, I suppose. And then once you get them, you also have to decode this data here, apparently. So that's what I was talking about, like previously about the decoding. And then you get the fee. So waiting for someone to nicely organize that for looks red in b two. So we don't have to do that anymore.
01:13:15.880 - 01:13:50.496, Speaker A: But yeah, I think that's, that's, I guess we will probably wrap up here. And there's also a nice, before we finish this live stream, there's also. So we pretty much gone through everything that I want to cover for today. And that is also like a very nice thing about extra cross chain analysis that you want to do. So this is a simplified version of like, how much fee you could save on optimism. Fee calculator. And this will kind of like demonstrate you what the l one and l two fee differences are.
01:13:50.496 - 01:14:24.780, Speaker A: And this will also combine everything that we learned today. And feel free to play around, fork those queries. And yeah, we also, we also host an office hour on Friday eastern time as well. So, yeah, if you have any more questions, feel free to come to the office hour and I'll be there. I guess that's, that's all for today. Oh, thank you.
