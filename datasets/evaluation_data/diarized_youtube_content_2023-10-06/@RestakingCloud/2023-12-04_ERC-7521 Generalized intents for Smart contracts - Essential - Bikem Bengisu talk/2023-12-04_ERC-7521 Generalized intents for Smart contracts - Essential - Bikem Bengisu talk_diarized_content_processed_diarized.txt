00:00:00.840 - 00:01:07.174, Speaker A: Hello everyone, I'm dikem and I'm an engineer at essential, and we're building intent based infrastructure and tooling to accelerate the transition from value extraction to intent satisfaction. And today I'm going to be talking about ERC 7521 generalized intents for smart contract wallets. The aim of this ERC is to introduce a single common interface for intent based projects in the Ethereum ecosystem. Now we'll go over some definitions, give an overview of the contracts in the ERC, look at the lifecycle of an intent in the context of this ERC, and walk through an example scenario, and lastly, just introduce an alternative, more modular spec. So in the context of this ERC, we define a user intent as a set of operations and expectations set by a user similar to ERC 4330. Seven's user operations intents in this ERC are signed messages that are gossiped around in an alternative mempool. We're going to come to the mempool later.
00:01:07.174 - 00:02:25.204, Speaker A: This spec doesn't really specify the off chain components in very much detail and is more on the on chain side. So a user intent in this ERC consists of a standard id, and we will dive into the standards shortly as well. The sender address, the nonce to prevent AAA tags, timestamp of when the intent was created, and the intent data and sender verified signature. The intent data is an array of segments that defines what the set of operations and expectations set by the user are. And now to define a solution. A solution is a combination of on chain operations that satisfies one or more intents. So this is a comparison with the ERC 4337 flow in the ERC 4033 seven account abstraction ERC let's say there is an alternative endpoint for user ops and bundlers pick up user ops from this alternative mempool and forwards them to the public mempool for the builder to pick up and pass it to the validator to be included in the next block.
00:02:25.204 - 00:03:15.034, Speaker A: And in this ERC there is an alternative manpool for user intents. And there is an actor called the solver, which is like a searcher and specialized solvers. We hope that there are specialized solvers that work on competing on solutions and they compete with each other using dutch auction or other auction mechanisms to include their solutions in the next block. So in the CRC, solvers are akin to bundlers and they also act as pain masters in the four, three, seven. Now let's go over the contracts. So the first one is an intent standard. Intent standards define the behavior of intents, and each intent standard specifies the way to validate and execute an intent.
00:03:15.034 - 00:04:07.854, Speaker A: Validation typically consists of formatting of an intent, and execution is performing the actual operations that an intent specifies. Next is the entry point contract. Entry point contract the entry point contract is responsible from keeping track of intent standards and handling intents. Keeping track of intent standards is important here because intent standards can be created permissionlessly and registered into the entry point contract permissionlessly. So the user opts into the standards to different standards during the sign time of the intent. So smart contract accounts should trust the entry point but not the individual intent standards. So this allows for seamless and permissionless upgrading and code expansion process as new use cases for intents come up.
00:04:07.854 - 00:05:22.044, Speaker A: Yeah, so we can go through the lifecycle of an intent now. So as I said earlier, the users submit intents to the intent mempool, which are then gossiped around as the mempool can be spammed and nodes may keep intents to themselves. The mempool should be designed carefully, but the spec doesn't exactly define how intents should be managed off chain. Rather, the aim of this ERC is to create an intent based framework for smart contract wallets to integrate with. In any case, solvers pick up intents from the mempool and create solutions that consists of one or more intents that may also include their own intents that they use to satisfy the user intents, and then they submit a solution to the entry point contract. So as you can see, the on chain part starts when the solution is actually submitted to the entry point to be handled, and the entry point contract first validates the intent. Firstly, it validates the signature of all the intents that a solution includes with the smart contract accounts that support ERC 6900.
00:05:22.044 - 00:06:42.394, Speaker A: So similar to 4337. And one important thing to note here is that the user can plug in any signature scheme that they would like to use, and since the validation of that is on the account, they're flexible to use whatever scheme they like. Once the validation with the account is passed, the entry point then goes through the intents in the order that the solver specifies. If the solver hasn't specified an order, then there's a default ordering, and then once that formatting check, the second validation that mainly includes the formatting is done, the entry point contract passes off the logic to the respective intent standards that the intents specify, and the standard validates the formatting and also asks the account to execute the operations. So the smart contract account should be ready to execute operations that are requested by the intent standard. But as I said earlier, they don't have to trust each and every intent standard that the entry point may delegate. They just need to trust the entry point and the user needs to opt into the standards during sign time rather than whitelisting each and every standard.
00:06:42.394 - 00:07:39.894, Speaker A: Now let's walk through an example scenario. So in this scenario, a user wants to buy an NFT that only accepts payments in ETH, but they want to pay for the NFT using DAI. So they create an intent, which is the blue intent that consists of two segments. And the first segment is it's releasing DAi to the next segment sender, which is going to be the solver once they insert their own intent, and they also record their current ETH balance. And then the solver includes in the solution their own intent that has just one segment. That is the missing piece here that satisfies the user, that trades iforeth and transfers the ETH to the user. And the second segment of the user intent is expecting more ETH and buying the NFT with ETH.
00:07:39.894 - 00:08:40.332, Speaker A: So the order has, the order is specified in the solution. So this is why this plays out this way. There's actually another possibility here. Maybe the solver. If the user didn't expect more ETH in the second segment, but instead expected the NFT, then the solver would have come up with another solution in which they trade the die for ETH and then buy the NFT and then forward that to the user. So here in this example, each intent has a standard, as I said earlier, and this example uses the asset based intent standard that we introduced, but it isn't a part of the spec. The standards are going to be a community work, we're hoping, and, but we still have an example asset based intent standard that covers most of the use cases, in our opinion, that deals with ERC 20, ERC 71, ERC 1155.
00:08:40.332 - 00:10:12.792, Speaker A: So the specifics of the asset based intent standard are not a part of the spec. So I'm not going to go deeper into that, but I just want to introduce a more modular and more composable spec that we're working on. So in everything that I've described so far, each intent has a standard, but we can also make it so that standards are specified per segment. So that makes standards even more modular and composable. For example, instead of having an asset based intent standard that deals with releasing any kind of assets or requiring any kind of assets, and then deals with keeping track of the balances of all of these assets, we can also create very simple standards. For example, an ETH release standard, that would be a standard that only has a standard id and just a release parameter that can be a constant equation or a linear equation or an exponential equation, depending on what the standard specifies, that will be evaluated during the time stamp that the solution has, and then we'll release the ETH that the user wants to release. So yeah, instead of having this approach where a big intense standard is dealing with everything, we can go even more modular.
00:10:12.792 - 00:11:13.974, Speaker A: So in this case, as you can see, the standard is in the segment, and this is just an example segment, but in the original spec, the standard belongs to the user intent. I think these are both doable, but yeah, for the more modular spec that I just described, we can mix and match segments, and we think they are very interesting use cases for that. And we can talk about these if you'd like, after the talk. And I just want to point out that this is a community effort and we want this to be a constantly evolving discussion so that we as a community agree upon some standards that will cover most of the use cases. So you can join the discussion, you can reach our GitHub access, our blog and essential builders. Thanks for listening and I'm open to any questions. Hey, hey.
00:11:15.594 - 00:12:01.316, Speaker B: Could you sort of give an example of how a standard like this would be used? You had sort of the segment, the interweaving segment with the solver going into it. I want to see an example where, let's say you take uniswap X, and Uniswap X was using the standard on the execution side, and you could say like a cross chain environment, what would they need to change in the way that their design works to be able to map onto something like this that allows the fillers to sort of insert whatever the price that they want to actually fill source of liquidity at whatever it is as a component of this, maybe. Yeah. If you can just say, what would be the challenge in sort of moving a design like Uniswap X to using standard like this?
00:12:01.460 - 00:13:00.254, Speaker A: Yeah, so all of the intent standards that can be defined define the validation and execution, the means of validation and execution for the standard. So like one example of a standard was, for example, this segment is an ETH release standard, and it just has an ETH curve that specifies the release parameters. But since segments are encoded and they are found in the user intent as a blob of data, just bytes, implementing a standard that I don't have a specific use case or an example standard that I can come up with right now, but basically you can just define your own standard that does what you want to do. But in my understanding is your question about this standard definition or did I misunderstand you?
00:13:00.754 - 00:13:27.874, Speaker B: The question is just more about how would you apply sort of an existing user flow which is doing a cross chain swap expecting some specific price to say you have a min out as part of the swap request on the target chain. Is there something about the standard that makes implementing that kind of stuff complicated or does it what goes into actually deploying that into the standard or adding this interface to that user flow?
00:13:27.954 - 00:14:03.974, Speaker A: Yeah, I would probably define an Oracle standard or some kind of Oracle's bridges, various interesting nonce schemes. They can be implemented using this model in my opinion. So I hope that answers your question. I would go for like an Oracle standard and then I would have to dive into the details of that so I don't have an example like Oracle implementation at the top of my head. Okay, thanks for listening.
