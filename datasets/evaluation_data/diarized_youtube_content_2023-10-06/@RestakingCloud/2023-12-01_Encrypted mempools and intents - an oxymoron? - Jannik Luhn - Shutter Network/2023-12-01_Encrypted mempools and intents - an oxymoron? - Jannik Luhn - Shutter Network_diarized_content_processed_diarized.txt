00:00:00.440 - 00:00:51.068, Speaker A: Hi everyone. My name is Janik, I work at Shutter network. And what we do is we build encrypted mempools. Now, some time ago, everyone started talking about intents, and everyone was very excited because you can do many cool things with them. And I guess that's the reason why many of you are here. And we were very excited as well, and we were trying to figure out how this thing that we built, encrypted mempools, fit together with intents, and if they fit together at all, if they maybe clash, and how they can be combined, potentially. And this is basically what I want to discuss now, to start, I think it makes sense to start with the mev supply chain, this model that flashbots came up with to describe how basically blocks are built and mev is extracted.
00:00:51.068 - 00:01:46.504, Speaker A: It starts with the user who has the intent to do something, and it tells it to the wallet. And the wallet transforms this fuzzy intent into a concrete transaction still locally on the user's machine. Usually then this transaction will be sent, either in public or in private to a searcher. The searcher will try to earn money, extract Mev by back running it, front running it, whatever they can then build a bundle out of this transaction, maybe others they combined it with, send it to the builder, who will assemble a block that the validator will then sign. And then after all these steps, it will finally end up in the chain. Now, an encrypted mempool basically tries to be a shortcut. It tries to cut off all these middlemen, the searcher, the builder and the validator, and tries to get the transaction directly into the chain.
00:01:46.504 - 00:02:18.832, Speaker A: Why? Because in many cases, in particular, what the searcher does is not in the interest of the user. Users don't like to be front run. So if we can kind of circumvent the searcher on this way, the user benefits. One way to implement this. There are many ways. I think two talks ago, we saw you can implement something like this with time lock puzzles. And the way we do it is using threshold encryption.
00:02:18.832 - 00:02:51.404, Speaker A: So we have a committee of nodes. This committee produces keys, encryption keys. Users can take these keys and use them to encrypt their transactions. The chain then has to accept these encrypted transactions into their block, so that they are ordered and sequenced in one particular order. And once this order is final, this virtual community can collectively produce the decryption keys. Using these keys. Now, the chain can decrypt the transactions and finally execute them.
00:02:51.404 - 00:03:32.870, Speaker A: This means that since the transaction is encrypted, even if the searcher gets access to it, it doesn't know what it does. It doesn't know if it buys a token. If it sells a token, which token it is, maybe it's doing something completely different. So it's very difficult for them to extract me from it. And as a nice side effect, it also increases censorship resistance, because in particular, the proposer might not like certain types of transactions, maybe transactions that use a particular contract. But if the proposal doesn't see which contract this transaction is interacting with, they can't effectively sense of it. Right.
00:03:32.870 - 00:04:16.866, Speaker A: This was about encrypted mempools. Now, intense in this MEV supply chain. Now, the traditional model we discussed earlier, the intent of the user was translated by the wallet into a transaction. On this new, more fancy, more powerful maybe model, it will be done at a later step by something like the searcher or a builder or a solver. The idea there is that the searcher has access to more information. They can collect multiple intents by multiple users and can combine them and build more efficient blocks using this way. Now, we can already see where there might be a problem.
00:04:16.866 - 00:05:22.864, Speaker A: So if the point of encrypted mempools is to circumvent the searcher and other entities, but for intent matching, we need the searcher, then these obviously don't go well with each other. So, yeah, that's basically what worried us a little bit. And then we started thinking, are there ways to resolve this conflict? And we're not done with that analysis yet, but where we are right now is we came up with basically three potential solutions. The first one is not really a solution at all, but it's kind of a, we realized it's not necessarily a problem at all. If we can have maybe both of these technologies living side by side, and they could coexist, potentially this would make sense if there are. So there's probably two groups of people, one users, that benefit from encrypted mempools, another one that benefits from intent matching. And they might, or they probably overlap, but there's also some of these users which are only one of these circles.
00:05:22.864 - 00:06:06.416, Speaker A: For example, there might be users who want to use protocols that are being censored, and they might benefit from encrypted mempools, but they might not benefit from intent matching at all. So they might only use, they are very happy with using encrypted mempools if the technology exists. And then there's maybe other users, like certain type of types of traders, who benefit a lot from intent matching, but they don't care about encrypted mempools. They don't need them. And then in these cases, we could see that these will technologies could coexist. And I think that's true. But I don't think that the overlap or that it's going to be a lot of users.
00:06:06.416 - 00:06:38.394, Speaker A: I think the overlap between and the benefits or users benefiting from both technologies at the same time. It's actually quite big because it's mostly like most of the intent matching system we've seen so far is about trading and exchanges. And that's also the main use case of encrypted mempools. Like we want to protect users from front running. This is mostly affecting traders. So not a complete solution, but something I think to keep in mind. The second thing is what we call post inclusion ordering.
00:06:38.394 - 00:07:47.684, Speaker A: It's very similar to if maybe you've heard of that in the cosmos ecosystem protocol owned builders. The idea is that we could do the intense matching on chain. This means that instead of having this intent matching step kind of in this fuzzy peer to peer world where there's no commitments yet, we could do it later. We could first write these intents directly to the chain, similar to how we write transactions today to the chain, and only then match them afterwards, either using some sort of hard coded algorithm in a smart contract, or using some auction model, or a combination of those, maybe an algorithm that constrains an auction. For example, you could make. Make sure in this auction that all intents that have been committed to the chain are considered at this no censorship can happen anymore. Or that all intents have to be treated equally, that they, for example, in exchange type application, that they have to get the same price.
00:07:47.684 - 00:08:29.214, Speaker A: And if we do that, if one would build such a system, then this would mean that you can send the intent in encrypted form. So you could use an encrypted mempool to get your intent on chain. And then you would get kind of benefits of both worlds. In particular, you would get sensory resistance, which you probably don't get at the moment. Of course, this has some drawbacks as well. Mostly it's less efficient, because if there's intents that you can't match for some reason, maybe they ask for a price, but it's unreasonable. They would still end on chain, and you would probably have to pay a transaction fee for that which you don't like.
00:08:29.214 - 00:09:37.764, Speaker A: And it might also reduce the user experience a little bit, because at the moment you can do intents. For example, you don't have to pay a transaction fee in many intent systems for this you would, or at least someone would have to pay a fee, of course, yes. And the last way that we came up with how encrypted manpools and intent systems can be combined is this basically at some point, the search or the solver. So basically we can use it to not protect the user from front running, but we can protect the search of the solver. We can allow the searcher to use an encrypted member to get the solution that they found into the chain. And arguably they are much more interested in this than a typical user because there's usually a lot of value in these solutions, because it's their job for a solver to match the intents in a very good way. And if now someone else would see the solution and they could just copy it, could just steal it, then they would not make any money out of it.
00:09:37.764 - 00:10:21.494, Speaker A: So in a way, they have to be protected very strongly. And an encrypted mempool might be a good solution to do that. Yeah, that's basically all I have. Maybe to summarize a little bit, it seems that encrypted mempools and intent matching systems are fundamentally adults because of, if you remember the picture that I showed. But it seems also likely that the two will coexist because there's different groups of users who benefit differently from these two technologies. And there's also ways to combine them in one system, actually using either post inclusion ordering and or. Yeah, allowing searchers and solvers to use them.
00:10:21.494 - 00:10:29.834, Speaker A: That's all from me. I'm not sure if we have time for questions. Probably not because we're behind schedule, but if not, just find me afterwards.
