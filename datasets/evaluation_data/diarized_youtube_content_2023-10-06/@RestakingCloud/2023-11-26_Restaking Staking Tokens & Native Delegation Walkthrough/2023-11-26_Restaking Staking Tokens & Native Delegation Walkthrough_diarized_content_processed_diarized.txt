00:00:00.600 - 00:00:52.126, Speaker A: Hey everyone, happy Thanksgiving. We are back from Devconnect and we have more news for everyone today we're going to walk you through two features. One is the native delegation and showing how the native delegation can be done on Mainnet and Testnet, right? So that's one thing, the biggest thing is the RST. RST stands for restaking, staking tokens. So the k two will enable anyone to have their own staking tokens out of the box. And you can start experiment, all kind of stuff, all the tokenomics, you can go for partial decentralization to a full decentralized in a state manner. You can operate your canary network like, you know, other blockchains have done.
00:00:52.126 - 00:01:01.254, Speaker A: But this, this is not just limited to l one or l two s, but you can actually use these tokens for any protocols, right? Anything that you want to.
00:01:04.114 - 00:01:04.498, Speaker B: You want.
00:01:04.506 - 00:01:51.628, Speaker A: To test it out, it could be used for protocols, it could be used for daos, it could be used for the voting governance, any kind of schemes that you want to do it, but it is just tethered to the SVP. So you open an SVP when you're in k two, it stands for stake, borrow position. You go for million ETH backed SVP will be open for you, that's a restake position. But you don't pay million ETH, but you just pay only the usage fee, maybe 5% or 6%, something like that, depends on the pool rate. And that will allow you to get that SVP for a year. And now you can mint one 1 million ETH back with the RST, because that ETH is reserved for you. It will never go to anyone.
00:01:51.628 - 00:02:16.740, Speaker A: And this is the characteristics of the k two that we explained in our earlier presentation was like no double stake, no nothing at stake, and all this kind of stuff, this will enable it. But we're going to walk you through all the details of how this thing work and what is in RFC, how it can be done, how easy it is, how it could be useful. Let's go into it.
00:02:16.892 - 00:02:31.092, Speaker B: One of the most common things people are asking us about is like what's the difference between global security versus local security, right? And I think that's quite important to understand with K two, right, both are possible, right? But, but default is global, right?
00:02:31.268 - 00:02:51.024, Speaker A: Right. Because it is, it is based on a network theory, right? So you are taking NSPP for a network, but if you want to, let's say you have ethereum, the question here is, have you ever waited for more than a day? Because a couple of attestation missed in Ethereum.
00:02:53.644 - 00:03:04.132, Speaker B: Like, you mean like waiting for finality, like my next transaction, like if I'm trading, yeah, no, I just, I just do it as often as I want the transactions.
00:03:04.228 - 00:04:03.694, Speaker A: So the decentralized networks by default are allowed to fail, right? That's how it work. And if you, if you think from a perspective like, oh, the decentralized network should not fail, then it is not decentralized, decentralized. So the effort of decentralization is like you can come back and the network will just go on, right? So the network will have a network level, full tolerance, but then the actors have, each and every actor is enabled in this kind of staking mechanism, and they will get the rewards based on what they doing. And that rewards will also get you slashing. So it keeps a book of your activities. The software can track the off chain competition. So if you are a node runner and then you're running it, you may not have 100% uptime for whatever the reason, you may lose some money, but that doesn't mean the network is less.
00:04:03.694 - 00:05:46.324, Speaker A: But if that's the case for 20% to 30% of the node runners, then network has a liveness problem, right? And you know, same, same with HTC and same, same software run not, etc. Like Ethereum, classic and difference between theory. All right, so in a way that, and how do you, how can you make things much more, right? So how can you make things more granular at the local level? So the local level is the node runners, right? How can you get this kind of thing also be replicated, right, if you, if you want to have like 100 node runners to run, and it could be node runners from anyone, from your preferred node, runners from existing node, runners that, who are in the marketplace of k two, or from outside, you need a token that actually tells you what happens where. And then you can put that into slashing or staking economics at the local level, and then you can actually take the network coverage, slashing coverage from the k two and the total security is also there. This all very interesting experiment, but the k two by default will allow you to secure any kind of networks, any kind of service logic and slashing. Now the, with the RST you will be able to do much more to economics around it. How do you want to do this kind of early experiment? You know, I have a lot of questions in this one.
00:05:47.024 - 00:06:07.726, Speaker B: Yeah, the design space is, the design space is quite open, right? But clearly every, every or almost restricting applications or networks, you know, need they have, they will have their own native token, but that requires bootstrapping, incubation, you know, and the RXT will bridge that, that chasm. Right.
00:06:07.870 - 00:06:22.662, Speaker A: Yeah. It really opened the design space wide. Like it's very flexible. Right. When you have a token and you want to onboard the community, you want to give them a role. Like someone is no runner, someone has other things. You can actually simulate a market for that.
00:06:22.662 - 00:06:52.150, Speaker A: You know, people can buy it from open market if you have an RF, Tony. Right. And it could be trader index. It could be even given to other networks. We have people who want to, you know, dock other networks with a k two so they can actually have like, you know, eat back security and the liveness for, you know, attracting more things could be anything. It could be for web two service layers. Like, oh, okay, now we have some decentralized services that we're launching.
00:06:52.150 - 00:07:10.630, Speaker A: Like for example, this kind of feedb layer that guys are talking now. We need a token that people need to stake for that specific service. So we will slash each of them and if the service is degraded, then we also, the network will also get slashed. So it's kind of local and global. It's pretty cool.
00:07:10.822 - 00:07:35.934, Speaker B: Absolutely. I really like this idea of decentralized experiments. So the ability to, you know, sometimes experience, you know, might last a month and you know, the output of that, you know, is obviously down to the application. But this really allows more innovation to happen quite rapidly in the space through the use of this, through the use of the RST.
00:07:37.714 - 00:07:52.334, Speaker A: The cost was, is very less. Right. Because you're getting a, an RST with the EId back. And so there is a, there's some sort of a base. What is your economic security that tokens are worth of? Because there's, there's a token sitting there.
00:07:53.474 - 00:08:07.442, Speaker B: Right, right. But it's not mandatory. Right. So if you're, if your restarting application doesn't need it, obviously you don't have to mint the token, but it's there. It's a way of, you know, tokenizing your purely optim. Yeah. Right.
00:08:07.442 - 00:08:42.795, Speaker B: So wait, so how does, so I think we need to talk about the SBP, the state borrower position. So, and you know, and how they are the base for, you know, how that's the base for the restake tokens. So the, so ETH security is being pulled together in a lending pool for others. For others to borrow. Right. So they can make, they can make like, and they, so when you borrow, you define your risk profile of your application. Right.
00:08:42.795 - 00:09:26.582, Speaker B: So you, and you define that in terms of your liveness and how like, well, okay, so you have two types of main, of events, sorry, two types of events that can happen in any decentralized network. So they can broadly categorize into two categories, liveness and corruption. So liveness is what you were saying about, you know, that the network is just not available, uh, for the, for the end user, and then corruption is a violation of the protocol. Right. So different, uh, uh, when these events happen, it will impact different applications differently. So the, the risk profile is the stake, what do you call it? Stake. Risk profile is different amongst those, right.
00:09:26.718 - 00:09:55.354, Speaker A: And you're just repeating micro network, right. Within that, the k two. So you can have hundreds of networks, SVP 12345. And every network is different. Every network has their own characteristics. Every network could be an l one, or could be just an oracle, could be some sort of services, but they have their own requirement why and how they're going to use this.
00:09:56.054 - 00:10:02.168, Speaker B: Is there inter, is there internetwork contagion, like spread from one network to another?
00:10:02.286 - 00:10:35.640, Speaker A: That's what we're showing. It's compartmentalized. So an SVP is an SVP. It will never get to the stakes. Oh, this is, this is very interesting because in k two, the deposits are fungible. So how can you use it so you can in deposit and withdraw? It doesn't really matter. You know, when you withdraw and deposit like you will, your yield will get adjust, but when it gets react assign that staking for SVP or every SVP is unique and non fungible each other.
00:10:35.640 - 00:11:12.854, Speaker A: You cannot just swap one SVP for another SVP, right? You can terminate your SVP and open a new SVP, that's fine. But the two svps are not fungible. But the underlying backing of all eats are fungible. And that's the cool thing you're just abstracting away from. You know, you have ETH. None of the validators in the ETH are fungible. You know, you have the same thing, but every stake weight is fungible, right? Within, you know, when you do this, the rewards and everything, and then you can calculate how much they will get it, because it's ETH at the base, right?
00:11:13.594 - 00:11:44.610, Speaker B: And every, so every RST is mapped to that SVP, which is non fungible. But the RST will, you know, so each piece of an RST maps to unique SVP. So in the network that fungibly tradable. Yeah, no problem. Right. Okay, so what you were saying as well is so you can have local level slashing. So these RSTs could support any kinds of new applications and the RSTs could be staked to run additional software for a network.
00:11:44.610 - 00:12:15.122, Speaker B: And you can have local level slashing if you wanted to. You can also use this to bootstrap an application. And this could be the token that gets converted into some kind of a native token later potentially, or it can sit side by side. So we can get into that. But right here we need to really talk about native delegation. So that is making the ETH at stake. So the ETH at stake is what's fitting in the consensus layer.
00:12:15.122 - 00:12:19.794, Speaker B: So in the consensus layer you have, you can actually go check the ethereum deposit contract. The never gets burned.
00:12:19.834 - 00:12:20.414, Speaker A: Right.
00:12:21.654 - 00:12:51.116, Speaker B: And that is used to register validates on the consensus layer. We'll get into the mechanics in a bit. But that's staked ETH. That, then that staked balance can be replicated into the k two pool to make it available for restaking in other applications. And the beauty of the k two protocol is you can do this without any changes to your existing withdrawal credentials. So we are solo staker friendly and you can support the entire network, but.
00:12:51.180 - 00:12:56.028, Speaker A: You know, everyone is treated equally, right?
00:12:56.076 - 00:13:04.404, Speaker B: Even if you're a DVT operator. Big, you could be a big DVT operator. You could be a solo staker. You know, everybody has got equal participation here.
00:13:04.564 - 00:13:05.304, Speaker A: Yeah.
00:13:06.964 - 00:13:48.824, Speaker B: So that, you know, I mean, the number is going up, but you know, that's, you know, $51 billion of e security, you know, ready to deploy to other networks. And we're actually going to show, in this conversation, we're going to actually show the sidecar ecosystem software that you install on your node. It's compatible with every client combination. It sits alongside boost and everything. And you can natively delegate and your validators will interact with the Ethereum smart contracts, which is incredible. Um, so it's really wide open, right? Yeah, really, really wide open.
00:13:48.984 - 00:14:18.532, Speaker A: It just basically make the evacuation staking available for everyone everywhere. You can start having staking networks backed with ease, like matter of minutes. Right. It's like, it's so easy as it would be. And you could do all kind of experiments with this. You could use this for DeFi protocols. If you use it for certain things you want to do with the Dow, you get a year for this one.
00:14:18.532 - 00:14:39.870, Speaker A: The tenor is at the beginning. The k two is giving on a yearly basis. So yeah, there's a question, right, the least tenor. What happens if you, if you don't renew it? What happens if you don't? You know, we need to discuss this like we need to give. What is this? What happens?
00:14:39.942 - 00:15:23.034, Speaker B: Yeah, yeah, so we, yeah, so here we give the, the key points really for that and we can just expand a bit about them. So, so the ETH, the restaked ETH can be borrowed from period a year. You can, you can increase your. So your lease position, you can increase that if you want. So you can start today $100 worth of ETH and you can scale up to a million. As your application grows, you can grow as well and increase the amount of restate e that you need for your application through the SBP. So the SBP was that position for your application, but it's a year long lease that will auto expire.
00:15:23.034 - 00:16:04.138, Speaker B: Once it expires, it goes. That restate deep in the pool can be borrowed by another protocol. So before you need to decide, before it rolls over, you need to decide whether you want to renew again for another year. You need to be quick because once that is gone, there's many applications that want to use it. Like you were saying, there's all kinds of people wanting to dock chains into docking cosmos and there's all kind of stuff that's happening. So there will be demand for this and the RST will be mapped one to one to the, to the SBP. Because every SVP has a unique index.
00:16:04.138 - 00:16:44.744, Speaker B: So, you know, this means like, so when the year is up, a new. If you're going to extend and create a new SVP, either for the same size or more, that RST will be in the protocol will be automatically remapped to the new SBP. So at any point. So this is what we're saying here in the RST side of the slide. So a holder of an RST can check the actual token and see if there is an SBP backing. There is a simple function that anybody can call. It's just the function name is active.
00:16:44.744 - 00:17:17.613, Speaker B: You can call it on etherscan. You don't have to be technical. So you can check if the RFC has an SBP backing. Otherwise, you know, if, if the SBP is expired or there are some other scenarios where the SVP can, can get liquidated. So, you know, if there is excessive slashing and the SVP is not fopped up, eventually that can lead to the, you know, the liquidation of that and that will make the state ETH available for, um.
00:17:19.513 - 00:17:55.344, Speaker A: How do you know that there's an, the RST, RST doesn't have a backing in, you know, for the, from the SVP. The SVP has been terminated or liquidated in this case. I know. Is it possible to see somewhere that you track this RST tickers and RST are ERC 20 tokens. But can you can get this from a graph or anywhere that other lease is expired through the status of the RST token active or orphan or lease is going to expire in. Within this date.
00:17:56.484 - 00:18:39.292, Speaker B: Ah, right. So kind of like. So, um. Yeah, so in Polkadot, um, obviously the leases, there are two years, and they do have a dashboard where they, they. You can see who's leased the dots and when that expiry is going to take place. So it's pretty simple for anyone to actually track this information and spin up a similar dashboard because it's like, you can do it from the graph if you want to do it at a global level and list all of the RST deployments. So with the graph, you can use templates to basically track all the RST deployments from the factory.
00:18:39.292 - 00:19:14.272, Speaker B: And every RST has this function is active, and you can just call it and it will just tell you true or false. False means that there is no backing, it's orphaned, there's no SVP there. So you can do it at an ether scan, you can do it from the graph, you can query the contracts directly from an OGS script. It's actually super, super easy to find out. And it's all on chain. Um, there is no, you know, you can find out instantly when the. When the SVP is about to expire, when it's.
00:19:14.272 - 00:19:25.448, Speaker B: When it's been liquidated, when it's, you know, not got into packing. It's all there on chain. So that's the. Yeah, I'd like to see a dashboard community spin up a dashboard for tracking that. That would be really cool.
00:19:25.496 - 00:19:28.584, Speaker A: But you're saying that this is available from the contract itself if you want to.
00:19:28.624 - 00:19:31.088, Speaker B: Yeah, yeah, yeah. There's no special tooling.
00:19:31.216 - 00:19:33.978, Speaker A: Yeah, it's all available on chain, right?
00:19:34.136 - 00:19:57.342, Speaker B: Yeah. Which means even non technical people will, you know, will use it. Because, like, if at a minimum, you can go to Etherscan, then it's just a simple. You can check in a UI. Yeah. You just go, you know, in your wallet on Etherscan, you check the rst that you hold and then you can click read contract, and it will show you, you know, that it's not active. So, you know, that'll be, that'll, that'll makes everybody smart.
00:19:57.398 - 00:19:58.834, Speaker A: Right, right.
00:19:59.814 - 00:20:26.718, Speaker B: But maybe we should talk about as well, like, so that takes care of the, you know, what. What am I holding? Is, is it, is it, you know, is the underlying FPP active and stuff? But so what about the supply dynamics here? So we're talking here on the slide about incentives. So some of the. So when you open the SVP, let's say you. You have a million dollars worth of ETH security. So, you know, you will. You can.
00:20:26.718 - 00:20:44.790, Speaker B: You can. You can mint. In ETH terms, you can mint a one for one rst up to the max supply of your SVP coverage, and 10% of that will go to an incentive pool to incentivize the restaking, to stay in the lending pool.
00:20:44.822 - 00:20:45.302, Speaker A: Right.
00:20:45.438 - 00:20:57.320, Speaker B: So that will keep the restaked ETH in the pool, which is important for the svPs, because you don't want the nothing at stake problem, you know?
00:20:57.352 - 00:20:57.544, Speaker A: Right.
00:20:57.584 - 00:21:02.376, Speaker B: You don't want to. And then that is that. That reinforces the RSTs as well. So this.
00:21:02.400 - 00:21:05.240, Speaker A: This thing is like, if there is no stake, you will.
00:21:05.312 - 00:21:05.568, Speaker B: The.
00:21:05.616 - 00:21:27.908, Speaker A: The SBP owner will not get charged, the money will go back to them. The pool is not going to take you. So whenever you open an SVP, you have to pay usage fee upfront, which is like, a small percentage of whatever the security is for. You get a million e. Maybe you pay, like, 5% of that. But if there is no stake, that money comes back to you. Right.
00:21:27.908 - 00:21:28.796, Speaker A: That. That's the pool.
00:21:28.860 - 00:21:29.748, Speaker B: Which is fair.
00:21:29.916 - 00:21:30.196, Speaker A: Yeah.
00:21:30.220 - 00:21:30.908, Speaker B: Which is fair.
00:21:31.036 - 00:21:33.424, Speaker A: But RSTs can still operate.
00:21:35.964 - 00:21:47.210, Speaker B: Yeah, that's true. That's true. Yeah, yeah, yeah. I mean, normally when you launch, like, a new chain, you have an at token, you know, it's kind of like, you know, mincing, minting those kind of, you know. But here you're backed by the security, but you can.
00:21:47.372 - 00:21:59.750, Speaker A: What do you want to redock it? What do you want to react to it and ask the RSP. Sorry, the SVP, and say that, oh, no, no, we need the ETH backing. It's got liquidated. But can we go back? Second chances?
00:21:59.902 - 00:22:15.750, Speaker B: You can, absolutely. If there's. If there's. If there's e for borrowing from the k two protocol, then you can it. You just borrow the Ethan, it'll get automatically remapped to your. So the original rst that was deployed, and then it will have, like, a zombie restored.
00:22:15.822 - 00:22:23.464, Speaker A: I'm coming back. I'm here. I'm dead. I'm not dead.
00:22:25.844 - 00:22:31.264, Speaker B: Yeah, exactly. So how do you think this can help daos, Matt?
00:22:32.004 - 00:23:14.680, Speaker A: Well, the Daos normally gets funner for Annette's perimen, and the DAO is the. You know, we saw this shit show in OpenAI and all this kind of stuff. Right. But you can actually have a DAO to set up and say that some of the governance actions or even the treasuries, they can change the rule, but then you get like a very independent token that is backed by ETH. And then you can keep this kind of a dual governance, or, you know, tri level governance or whatever it is. You can get the, the representation based on what they were interested in, that the Dow holders will actually go on that. And if it's not working, then do another one, and then you can have another, another token.
00:23:14.680 - 00:23:58.080, Speaker A: But it doesn't really give a lot of pressure to you. Like you have like a full network level token, but this could be like 20% of your network. But once you have oxford yourself, like your dao structure, then you can have like, okay, now the RSTs can be converted into a Dao tokens, like a worry, different tokens, but it can happen. The daos can immediately get a governance token at a low price with the e backing. But then new people can join the DAO governance by buying this token from outside, you know what I'm saying? Because it's tradable. But then initially, you can also incentivize existing DAO in a holder, whatever the DAO is doing through token supplies. It's just like any other tokens.
00:23:58.080 - 00:24:54.934, Speaker A: So you can have your mark, certain percentage for the users and certain percentage for the outsiders to come in and they really interested for nfts or you name it, any kind of any other daos. But then you can experiment things much more faster and your tokens are eat backed. So all kind of experiments, the surface is super wide open and the tokens will bring all kind of actions here. And the Daos could be just for service operating that you are say, oh, I'm just setting up an Adao, just want to do a bunch of guys are doing some service for my product, and this is not the entire product lineup, but this is a specific part. And I need you to stake this token, run a machine and tell it in a software and tell the world how we're doing it. Or, you know, this is kind of called crowdsource, intelligence, cartoon experiments, whatever you want to call. But at like iterative, it's kind of a loop.
00:24:54.934 - 00:25:44.424, Speaker A: It can, you can start over, you can refresh it, you can go from like very naive idea to a very ossified in an idea market fit, to a product market fit much more faster without having much capital at play. But it will give you that security because the decentralized networks need the security. So you don't pay for the entire security, but you can actually experiment with that with the RST, that's more important. And if your network is performing very good, your rsts could be traded on a bow. What is the backing value? Because if people are seeing that, it's very hard to get in. You know, I mean, that's, that's the dynamics, but that's how, that's how the companies are. Like, you know, someone you raise, you know, I don't know, 100, 300 million doesn't mean that your market cap will be 300 million.
00:25:45.404 - 00:25:46.744, Speaker B: True, true.
00:25:47.884 - 00:26:15.664, Speaker A: Yeah. So the equity is an endogenous value and the external markets are looking after to get into it. So, you know, you can, you can do anything with this. The cool thing here is not only on Ethereum, you can do on any networks, any blockchains, anywhere with ETH backing. So ETH is becoming the base for decentralized experiments, a decentralized future, a stepping stone.
00:26:16.364 - 00:26:46.504, Speaker B: Yeah. All the technology, sports ed curve and all that kind of stuff. And yeah, you can be, yeah, you can do all kind of stuff. So the, I would also add, like what you said about crowdsource, intelligence, stuff like, but you also have like community operations. So, you know, you, your, your Dow network can run reporters. You know, this, some people are calling it something like, so for the litigation, whatever, whatever they want to call it, but you know, so the, these reporters are just, you know, working for the network. Working for the network.
00:26:46.504 - 00:27:11.334, Speaker B: And they'll get paid in ETH for doing that job. So rather than running crazy operations, everything yourself and, you know, supporting and struggling to scale, you know, you can basically say there are certain operations that need to be taken place by community and you can run a reporter to make sure the system is running okay. Tell us if something isn't running okay. And you get paid for that.
00:27:12.314 - 00:27:36.572, Speaker A: Yes, yes, yes. You can actually use reporter package to create your own reporting functionality. And then you can give them these tokens and then that's their, that's their revenue. Oh, that's, that's pretty interesting because we saw that, like any kind of RPCs or any kind of things, you want to do certain tasks now you have it. If you want to watch out for liquidations in your protocol, you give these tokens and they run for that. If you want to have a solos. Boom.
00:27:36.572 - 00:27:42.784, Speaker A: Oh, I never thought about this. Like, you can use it for any kind of arbitrary operations. That's great.
00:27:43.604 - 00:27:49.246, Speaker B: Yeah, yeah. It helps protocols grow sustainably. It's all about sustainable growth with.
00:27:49.310 - 00:27:50.662, Speaker A: Yeah, yeah, yeah.
00:27:50.798 - 00:28:01.814, Speaker B: You know, because, you know, running some operations are, you know, have high burn rate, but you know, that's not sustainable. You know, and it really makes the barrier to entry really high, but it's bringing about those barriers to entry low. Yeah.
00:28:01.894 - 00:28:22.174, Speaker A: The RSTs will actually reduce order of magnitude your cumulative bond rate if you want, like in a near entire lifespan. This is gonna shrink it, but it is gonna expand and exponentially increase your accumulated value accrual at a very, very, in a flexible manner. Yeah. Okay.
00:28:23.834 - 00:28:57.442, Speaker B: These diagrams here on the screen just, just reinforce what we, what we've been talking about. There is, you know, there's obviously ETH that is restaked by a native delegation into the inter lending pool that's here. LSTs can also come in and offer, because they represent some validator somewhere in some protocol. So they can also, those pooled, those are pooled. LSTs are pooled security models. So they come in here as well. And SBPs are the non fungible positions for each application.
00:28:57.442 - 00:29:38.954, Speaker B: And you can mint the RSTs on top of these. The available to borrow is any capacity in the protocol that's not there. So this needs to be incentivized correctly in order to offer the restate d for other applications. And here on the, you know, this is covering the minting. 10% is for the incentives. There is a take rate for the service of the protocol, but other than that, it's used for the incentivization of the native delegation in the indicator lending protocol. But what if, you know the usage fee, right, Matt?
00:29:39.374 - 00:29:39.846, Speaker A: Yeah.
00:29:39.910 - 00:29:43.856, Speaker B: What do you have normally? Right. Yeah.
00:29:43.880 - 00:30:14.784, Speaker A: The usage fee, you have to pay upfront. Oh, this is, this is the take rate, the, the usage fee for the SBP, which is basically like, you know, you go and you specify how much eat that you need. It will, it will give you some ETH pay. But when you minted RST, we are only talking about RST here. The minting has a minimum take rate for the k two pool. Lp's. Maybe explain a little bit why that incentive is very much required.
00:30:17.684 - 00:30:34.200, Speaker B: Yeah. So this, this, so these will get, these will get dripped to the, to the entities that are providing, you know, e for restaking to the k two lending protocol. So they, you know, the longer that they stay in, they get, they get dripped rsts.
00:30:34.372 - 00:30:55.864, Speaker A: It's a, it's a mechanism that will prevent nothing at stake problem. Right. Because if you don't have Eid at the base, then your RST will actually going to get orphaned. So we don't want that. So it's better that you give a certain amount of the supply to, you know, the kids who pool.
00:30:55.984 - 00:31:06.442, Speaker B: But what about the opening of an SBP? Right? You got to pay, you, you got to pay a utilization fee for the, for the, to use that. Restate, Ethan. But what if you could, like, this.
00:31:06.458 - 00:32:02.396, Speaker A: Is like someone is ready to lend you that money. So when and why do you pay yourself as an SPP owner if someone can pay you for it? So when you can borrow that money, and now we have an RST to return it for them. And if they're interested in your, if they're interested in your network, if they're interested in your experiment, they can fund that. Right? It could be a NLP pool, just simple LP pool that's applying that 1 million RSI could be minted if they, let's say it's 5%, 50, 50,000 worth of ETH, and that's the cost that you need to pay upfront. And again, if it's get liquidated, it's going to come back, but the, the loan can become from them. And you earmark certain amount of rsts, go back to them immediately. And it could be, it could be done from a contract, it could be done manually, like each is borrow and if someone just give you, and then you give them manually, but it could also be done from a contract.
00:32:02.396 - 00:32:20.940, Speaker A: So if you approve that loan. And then he called SPP, when they, whenever the RST is minting, the pool will get immediately and whatever that you agreed beforehand. Right. That's what we showing. Yeah, yeah. For spinning up your SBP and rst.
00:32:21.012 - 00:32:30.284, Speaker B: Yeah. Correct. And anything green is outside of the pay too. Right. This is standard crowdfunding contracts. Just, there's plenty available, just deploy it and, you know.
00:32:30.444 - 00:32:34.784, Speaker A: Yeah, it's purely anon friendly. Like anyone can do anything.
00:32:37.084 - 00:33:16.684, Speaker B: Yeah. Shadow coding friendly. So, yeah, this is just reinforcing what we were talking about, you know, SPB, sorry, rStot, they will start backed by an SVP, but, you know, in time they can, they can get orphaned or the backing can, can disappear. So it's important to keep an eye on that. But, you know, ETH security can be increased at any time to reinforce the network. It is just a matter of going to the contracts. You can reset the duration, you make the duration, if, you know, six months in, you can extend another, you know, another twelve months.
00:33:16.684 - 00:33:58.992, Speaker B: You can make the SPB position bigger to get more security. It's really flexible in that respect. At a protocol level. This is a nice way to understand the platform. You have the Ethereum validators that are natively delegating to k two users are creating the spps on top of that. And then you have, the RSC is minted from the sbps, and you can then create your applications, your middlewares and stuff like that. And maybe if you're spinning up a chain, your? RST will be your nation token that maybe gets converted or it sits alongside your native token.
00:33:58.992 - 00:34:31.294, Speaker B: It's an incubation for your protocol, really, and it's really up to you how you want to use this. All kind of things are possible, really. We've had like, we had so many people swarming us, like, oh, can I do this? Can I do that? Can I, you know, how do I use this? You know, can I see the docs? And so the design space is really interesting here. Right, just. Sorry, 1 second. Matt, can you take this? This one I just need to mute.
00:34:31.594 - 00:35:08.122, Speaker A: Yeah, no problem. So, right, if you look at that on the openr, this is basically how high level overview the flow diagram. So if Alice comes and opening an SVP, let's assume this SVP has a slashing coverage included. So that's like we're going to discuss this. This is two partitions. One is the utilization rate and one is the slashing coverage rate. So the SVP is ensuring there's a network backed security has been given, and the first service is the network backed slashing coverage has been given.
00:35:08.122 - 00:35:50.452, Speaker A: So SVP with slashing coverage. So you open a slashing, you set this maximum slashing for lifeliness and corruption. You can have up to 0.5 and five for lifeness and the corruption. Now you said whatever, that is the maximum that you need, and I'd say 0.34 per event for the liveness and for, you know, corruption, you could have any, any number of events under the lifeness, under the slashing, but it cannot breach this maximum per event. So you can have hundreds of them, could be same three or 0.20.1
00:35:50.452 - 00:36:42.764, Speaker A: doesn't matter, right? So the important factor here is you cannot, you cannot give more than what has been taken as a maximum coverage. So, so that you said, now you, okay, I want to mint the RST still. I want to have this kind of the community experiment as well. So what happens when you click that button when you have slashing? It will, it will, when the minting of RST happens, it will atomically do three operations. It gives you the Rst as an SVP owner, right? It gives min the tokens and comes to you. It will pay that 10% minimum. But if you set like 15%, then the 15% will go to the k two pool and the minting rate to the cloud as well.
00:36:42.764 - 00:37:27.884, Speaker A: But then it will also set the slashing coverage. So you have the RST tokens mind that you have a slashing coverage setup. The partition interest rate is one, one payment that you're giving again, everything. You will get it back if you want to, if you just, you know, terminate it. That's, that's, that's pure and simple and that's the terminate 24/7 so if you look at the RSVP as a slashing and a stake borrow position, what it has, after this minting, you have a complete and rst based staking. You can do it. So we have, let's say if you take a million, you have a million RST tokens, you can inject local based staking rules like oh, I want to run certain operations to be required staking tokens.
00:37:27.884 - 00:37:58.786, Speaker A: The RSTs, you can provide this as in a handed directly from a faucet, or they could take it from one of the dexs. If you have a liquidity pool trading pool there. So the staking is open permissionless, you can have that permission. Or permissionless staking is available because you have a tokens you want to do any way that you want. You could also inject now local slashing logic that oh, how this operation should be. Each and every actor can be slashed in such and such way. And now that's one thing.
00:37:58.786 - 00:38:56.084, Speaker A: So you have like agentwise slashing can be injected with the RSTs. The network slashing is also given to you taken by the SBP card. So let's say if your network is not really performing very well, people can actually see and they only look at the network level coverage, right? Because that's what I said. Oh, is the ethereum confirmation rule is to epoch and ethereum classic confirmation rule is two days, right? Because it's two different networks and network liveness and corruption will be tracked by the reporters and they will do that. You don't really have to do anything that's automated, that's been provided by the K two. But the local things you can have any way you want, right? You only pay usage fee to do all of this out of the box. And that's like you can run a million ETH or 10 million ETH worth of experiment at a super low cost.
00:39:01.144 - 00:39:04.552, Speaker B: So this is, this is kind of like a how do you do it? Right?
00:39:04.728 - 00:39:09.040, Speaker A: Yeah, click it right.
00:39:09.192 - 00:39:53.260, Speaker B: So we have, we have a DAP, you know, it's going to be available soon. It's working on Testnet been working on Guerrelli for a while now, and this is opening an SPV position. So it's just worth getting you familiar with the UI here. So you have the ETH, the restaked ETH that it's available to borrow at the top here. This is an example rate, since this is a screenshot, but this is based on utilization. So that will be the rate if there was high, high utilization, but this is just an example. This is not really the rate that will be there.
00:39:53.260 - 00:40:35.444, Speaker B: And there will be lots of native delegation coming in to find some kind of equilibrium on the, on the rate, really. So you know, you specify your borrower based on how much there is to borrow your designated verifier when you're creating these positions. So the designated verifier is when you, when you take on a slashing security, right. When you're specifying that you require a slashing coverage, then basically you're going to specify here the liveness and corruption and you're going to. This is the designated verifier that you assign. A middleware that you assign that either you run yourself or somebody else is running that will verify liveness and corruption events and authorize slashing. It's a predefined package available.
00:40:35.444 - 00:41:03.194, Speaker B: I think the GitHub is restaking dash cloud. I think it is, but you inject your slashing logic there. But here you can opt into the RST token. When you're creating the SB team, you specify your ticker, it's up to six characters and the incentives that are being allocated to keep the, the coverage in the indicator lending pool. And you will have some kind of a interest payment. What is it called? Not an interest payment. Utilization fee.
00:41:03.194 - 00:41:25.574, Speaker B: Yeah. And that's pretty much it. It's super, super straightforward. This can be programmatically done. We have a K two SDK and we've got a plus sidecar ecosystem and more. So there's really, it's kind of how you want to do this, really. So.
00:41:27.874 - 00:41:37.534, Speaker A: The guy who is minting the RST only need to do this, right. He doesn't really have any kind of logistics associated with it. Just click the button and he will receive the tokens.
00:41:38.514 - 00:41:39.506, Speaker B: Yeah, absolutely.
00:41:39.570 - 00:41:39.866, Speaker C: Absolutely.
00:41:39.890 - 00:41:56.300, Speaker B: It will come, you know, the borrowing amount will be your supply of your RST, your initial supply of your RST, minus the incentives that you've allocated to the, you know, pay to protocol to keep the. Yeah, that will come to your wallet.
00:41:56.492 - 00:41:57.100, Speaker A: Cool.
00:41:57.212 - 00:42:37.294, Speaker B: So we always like, we always like this meme, you know, and. Yeah, you know, from the, from the supply side. So when you know from the ETH that you hold as whether you're a solo staker or you know, a big entity, the ETH, you hold, you know, staying in your drawer credentials, right? And you can, you can participate in the K two protocol, you know, simply proving your basically to do the native delegation. You prove your ownership and you delegate to the KT protocol. You keep your security, keep your operations the same and you earn more ETH. You know, it's, it's like quite straightforward really.
00:42:38.914 - 00:42:44.054, Speaker A: Right. So you don't really give your vitro credentials to anyone. You don't change anything in your operations.
00:42:44.754 - 00:42:46.010, Speaker B: No, no, no.
00:42:46.122 - 00:42:52.024, Speaker A: Allowing people to reuse your ethnic. But you should get paid whenever they use that one for.
00:42:52.764 - 00:43:29.194, Speaker B: Yeah, absolutely. So, so this is the, this is, this is powered by our technology, right? The validator state replication technology, right, on the execution layer. So here we have. So, okay, what we want to do is talk to talk about something familiar. Everybody understands the, everybody should, well, should understand elements of what we're talking about on the left side of this diagram. So we have, so we have an ethereum chain that under the hood is composed of two chains. So we have a consensus layer and an execution layer.
00:43:29.194 - 00:44:11.616, Speaker B: Execution layer is documented consensus layer in order to. So consensus layer is obviously offering the consensus for the execution layer and that's the only purpose of it. And that is run by consensus layer validators. They all have BLS credentials because the consensus layer is operating on the BLs cryptography. So that specific curve is the twelve 381 curve. And the reason I mentioned that is because natively in the ethereum execution layer, there is no support or curve verification. So that means normally this is really challenging.
00:44:11.616 - 00:45:00.518, Speaker B: But what's interesting is that the Ethereum consensus layer cannot activate or append any validators to its registry of validators without the Ethereum deposit contract, which is set on the execution layer. So on the execution layer you have a contract. You can go to Etherscan and you can type into Etherscan deposit contract ETH. Somebody amazingly mapped that ens to the Ethereum deposit contract and burned access to it. You can easily access the deposit contract. You can see all the ETH is there, all the security. Now in order to register a validator, you need to send to this contract, you can see the source code.
00:45:00.518 - 00:45:39.616, Speaker B: You have to send a minimum of one ETH into this contract as a spam protection mechanism. To register a validator credentials on the consensus layer. So when you send that transaction to Ethereum deposit contract, your registration transaction, normally people send 32 e but we're illustrating the point here that you can register any credentials with one ETH. It doesn't mean you're going to get activated. You need 32 to be activated, but you can fire the transaction to deposit contract. Say hey, I want to register some, I want to register some credit credentials for the Ethereum consensus layer. This is the BLS key I'm registering.
00:45:39.616 - 00:46:31.308, Speaker B: I'm going to prove my ownership to you. Ethereum deposit contract. I'm going to sign a message and give you a message that will allow you to show you that I own a BLS credential and I want it registered on the census layer. And I want you to add one ETH of balance to that BLS public key and then it will go through a cycle. If you add another 31 ETH, you will then go through an activation cycle. You have different induction balances, effective balance slash balance, and you can manage your different states, but you will specify when you do that registration and withdrawal credentials that you control. So in a similar fashion, we do the reverse with k two, but we're leveraging the proposal registry.
00:46:31.308 - 00:47:00.544, Speaker B: So the proposal registry is a smart contract on the Ethereum execution layer that tracks active consensus layer validators with a minimum 32 e effective balance. You can basically prove ownership of an active validator on consensus layer. And you can say, hey, propose a registry. I want to perform a single sign on. It's just like a Google thing or a, you know, this. And this single sign on can be used anywhere. Hey, I own this validator.
00:47:00.544 - 00:47:41.644, Speaker B: Here is a message proving that, and I want my want. It's registered on the chain. And if your active status, if your minimum balance drops or your kick from the consent label can get reflected on the execution layer as well through that. And k two is just an application on top of this proposal registry. The only thing it requires you to do, it doesn't require your credentials, but it just says when you earn money, where should we pay the earnings? And that's the fee recipient part at the bottom. So am I missing any kind of details here about the lifecycle flow of the registration?
00:47:41.984 - 00:48:17.834, Speaker A: The one thing here is a pure and proposal registry has a rule which kind of validator minimum eats to effective balance means it will not take any kind of exited validators or anything like that. It only takes the active validator in the consensus it. So it does a lot of checks. It's really replicating the state from consensus layer to execution layer on a smart contract. And it makes sure the registry only keep an active validator with the minimum 32 e. Once you register, that doesn't mean that you will be there forever. You will get kicked out.
00:48:17.834 - 00:48:35.164, Speaker A: So that's all part of the proposed registry. Proposed registry. Make sure you can just outsource your, you know, onboarding validators from consensus layer to execution layer for your smart contract. Just call the proposed registry, it will do the job for you free. It's already on.
00:48:35.984 - 00:48:40.684, Speaker B: Yeah, yeah, yeah, yeah. It's already there on Mainnet. Thanks. Thanks to runtime for helping us.
00:48:42.024 - 00:49:16.184, Speaker A: This is the part of the pon proof of neutrality, like the platform for any kind of experiment in a docking consensus layer into execution layer. And you can build anything more. You can do a maybe supply chain, you can do restaking supply chain, you can do other stuff. But this is something that we worked like last ten to eleven months. Just make sure bringing auditability and verifiability on. How do you negotiate with the validators? And it's purely a public good. And we just, we are deploying our applications on top of it too.
00:49:17.664 - 00:49:50.844, Speaker B: Yeah, absolutely, absolutely. That's the peon.net work that forms a basis for this. Couple of things to mention about the management of the balances on the consensus layer. So typically you have two balances, you have an active balance and an effective balance. All your voting and your earnings are done on your effective balance. So that it's not Ponzi and stuff like that, but your active balance is, you know, where your penalties are reflected on your bls.
00:49:50.844 - 00:50:33.984, Speaker B: On your BLS key. So as you mentioned at the start of this, at the start of this discussion, we, Ethereum as a network is very resilient. One validator being offline or inactive is not going to affect the entire network. But, but if you had 30% of the, or 33% of the, you know, the validates offline, then you've got a serious liveness problem at the global level, but not at a local level. And those validators will incur penalties if you, if you do a double signing, you'll incur some more severe penalties. So Ethereum only has this like 16 e auto kick threshold. So when you reach the 16 you'll get kicked out of the network.
00:50:33.984 - 00:51:27.744, Speaker B: And so in order to avoid excessive management of state and stuff like that, the stake weight inside of the k two lending pool is 24 ETH for a native delegator. So when you're natively delegating your consensus like balance to cater lending pool, your weight is 24. And that accounts for more than enough buffer for things being offline. It creates a level of resilience in the protocol. What would be great to do is to bring Andreas into the. Into the room and talk about the configuration of your SBP position and what is behind the utilization fee that you're paying to open a SPB.
00:51:28.604 - 00:52:25.790, Speaker D: All right, so when you open a SBP position, you pay. You pay interest amount upfront. And this equation we have here on the screen is the formula for the interest rate. So what you do when you borrow, say ten ETH, you say you want to borrow ten ETH or ten k ETH, and then you will pay an interest amount corresponding to what is required by this interest rate on the screen. And the interest rate is partitioned into two positions. First we have the b position, and then to the right, we have the other part. And the b is based on the current utilization.
00:52:25.790 - 00:52:31.074, Speaker D: That is a part of the partition of the interest rate, which is.
00:52:32.794 - 00:52:33.306, Speaker B: Becoming.
00:52:33.370 - 00:53:01.918, Speaker D: Higher when the utilization of the k two pool is high. That means when there is a lot of borrowers and a few lenders, then the utilization rate will be high. And conversely, when there are a lot of lenders and a few borrowers, then utilization will be lower. That is one part of the interest rate. The other part of the interest rate is.
00:53:01.966 - 00:53:21.674, Speaker B: Sorry, Andreas, go ahead. So even. Even in that, right, there are a number of parameters that are predefined upfront on deployment. In terms of the maximum, the utilization rate can be the breakpoints and all that kind of stuff. It's quite familiar territory for some people that understand.
00:53:23.614 - 00:53:59.724, Speaker D: Right? So, yes, the way that it looks, it's like a function which first typically will be based on the utilization at some point. Well, in the beginning, the utilization. The utilization partition will increase slowly until we reach some utilization percent. And at that point, it will start to increase faster. That is typically how it looks like. It doesn't have to be like that, but that is typically is.
00:54:02.424 - 00:54:03.080, Speaker B: So that.
00:54:03.112 - 00:54:10.400, Speaker D: It is to incentivize new lenders into.
00:54:10.432 - 00:54:11.296, Speaker B: The k two pool.
00:54:11.320 - 00:54:14.124, Speaker D: So it starts to increase faster and there's a lot of utilization.
00:54:17.064 - 00:54:44.074, Speaker A: So yeah, what is this interest rate? You take the money, but if they terminate, it will go back. So the interest rate is not consumed immediately, right? It will be consumed during the tenure of SVP and it will be consumed by, you know, the pool will get consumed by all of this. An aggregate yield will derived from this interest rate for each SVP. Each SBP will have its own interest rate, right? Based on the parents.
00:54:47.134 - 00:55:02.114, Speaker D: Yes. So based on. Yes, the interest rate is calculated with this formula we have here on the screen. So it's based on, in part based on the current utilization and then also the slashing parameters that are being provided.
00:55:03.334 - 00:55:59.726, Speaker B: So there could be two different svps. Like, so because this slashing partition is kind of like optional, right. People might not need that slashing, right? So you might say, I don't char, there's no slashing penalty for liveness or corruption and then you're just paying utilization for that security. But like I could have a ten e SPP position and you could have a ten e, but like you could be, you could be five days behind me and like, so I could, you say, obviously on the utilization side you have like a base utilization rate. And then I could take it, I could take it on day zero, but by day five there might be a, like a large amount of utilization. So you're going to pay higher usage fee than me even if we're borrowing the same amount. So, you know, but then, but then the slashing is different, right? Because obviously there's like some like negative like covariance here with like the amount of coverage, right.
00:55:59.726 - 00:56:18.184, Speaker B: You take. So it's like it will reduce like the amount you pay on the slashing because you got more, more e security at your disposal. So basically when events take place, you've got more buffer to deal with it, right? I don't know if I'm butchering this. I don't want to butcher the partition in the intraday model.
00:56:19.204 - 00:56:50.382, Speaker D: Nothing. It was fair. So another thing I want to add to what you're saying. If you borrow first and then at day zero and then I day five borrow, then if there are no new lenders, definitely my utilization rate will be higher. But it could be like, there will be a lot of new, new lemnas coming in. And actually my utilization rate will actually be better than yours. It depends on the market.
00:56:50.438 - 00:56:50.654, Speaker B: Yeah.
00:56:50.694 - 00:57:05.194, Speaker A: So early SDPs will have extremely low usage free because the utilization rate is very low and they will enjoy it for that year. That's cool.
00:57:05.794 - 00:57:06.534, Speaker C: Yes.
00:57:06.874 - 00:57:10.734, Speaker D: So, yeah, that also incentivizes early adoption.
00:57:13.914 - 00:57:14.346, Speaker A: Right?
00:57:14.410 - 00:58:06.298, Speaker D: So let's get to the part with the slashing, which is perhaps the more interesting part. It is based on this lowercase L and the lowercase C. The lowercase L is the lightness slashing amount. That is the maximum slash amount that is allowed per Leibniz slashing event. And the lowercase C is the corruption slashing amount, the maximum amount that could be slashed on the corruption event. These two both have an upper bound. The upper bound for the, for the lowercase L is uppercase L and the and that is based on the way that the upper bound is not a constant.
00:58:06.298 - 00:59:07.078, Speaker D: It is calculated based on the utilization rate and also based on the amount that is being, the amount that is being borrowed, the principal amount. And this, what we're doing with the lowercase, the uppercase is that we want to ensure that we can support at least a certain number of liveness slashing events. I think that currently we want at least five liveness slashing events. That is a constant currently, but we can change that constant. Maybe it's not exactly five at the moment, I can't quite remember, but let's say it's five. And then that means that initially the initial interest rate will support at least five Leibniz slashing events. So to have some buffer so we can, we can have, there will be some time to top up if the SPP is slashed.
00:59:07.078 - 00:59:44.046, Speaker D: And similarly with the corruption, I think currently we want to have the upper case K is the upper bound for low KC, and that is ensuring that we have, let's say, at least two corruption slashing events. What the slashing position ensures with the low case C and lowercase L that can be chosen is that we support at least five live slashing events and at least two corruption slashing events based on these maximums, maximum values for loudness and corruption.
00:59:44.230 - 01:00:03.214, Speaker B: It's when you say support, like, so this is like to allow enough time to react, right? So basically you can top up your SPP and recover the losses, right? So otherwise you will get. Otherwise the SPP will be automatically terminated and liquidated.
01:00:03.374 - 01:00:51.006, Speaker D: Yes, that is, yes. So that is five alignment slashing events and two corruption slashing events is supported. But if more than that happens, then maybe it will be, it may be get liquidated if, I mean, but this is only if you choose like L to be the maximum and c to be the maximum. So, yeah, so these are upwards, uppercase L is upper bound for the choice. So these L and C are parameters to the interest rate. And they can be, they need to be chosen such that l, lowercase L is less than equal to uppercase L and C must be less than equal to uppercase K. And it makes the interest rate higher because there is more risk involved.
01:00:51.006 - 01:01:22.074, Speaker D: So when there is liveness slashing and corruption slashing involved, then there is then that actually the slashing happens on the actual interest rate, which is affecting the lenders. So that is actually, they will actually. So when a slashing happens, the interest rate, the interest payment for the lenders will actually be lower, that will be decreased. So that is why the interest rate is higher when there is slashing involved.
01:01:22.974 - 01:02:02.628, Speaker B: Got it. The threshold here at the protocol level is if 30% of the outstanding, outstanding interest is outstanding. Could be. So, you know, obviously if you have a SPB that's got a year's coverage, 30% of the outs. So the utilization fee that you're paying obviously gets stripped over the course of the year. So what is outstanding is relative to time. And so 30% of outstanding interest at t zero is going to be very different to later on down the line.
01:02:02.628 - 01:02:47.364, Speaker B: But when it reaches that threshold, so that means that they're at the application level. So that network is experiencing some, the network that is taking the SVP for the restaking application, there is some problem spilling into the global coverage that is causing excessive slashing. And it's not helpful to the global coverage. So that application needs to fix obviously the software and the issue associated with that. And that means that the SBP will get it ejected and it needs to be adjusted and then it can come back at any time. That's not a problem. But it's about offering this global security, really.
01:02:47.364 - 01:02:58.830, Speaker B: We can support different, every application will have a base utilization plus some kind of partition. So slashing application has a slashing partition. Additional partitions can be supported as well.
01:02:58.862 - 01:03:15.174, Speaker A: Right. That's very modular how it is. And it's also limited contagion, like if the slashing is going down and how it's going to affect the utilization at the entire lifecycle, it will just get reconciled. But it also, you know, helps to be buffer sometimes, right?
01:03:15.674 - 01:03:26.322, Speaker B: Always. So if we don't have any further things on that side, we can, we can jump into sort of native delegation with, with me.
01:03:26.378 - 01:03:26.562, Speaker A: Yeah.
01:03:26.578 - 01:03:43.794, Speaker B: So we talked about aggregated, you know, we talked about these network level things. So yeah, let's, let's see how things work because we have the slide from Istanbul. But maybe if I can hand over to Ronnie.
01:03:46.214 - 01:04:40.314, Speaker C: Okay. So having gone through k two and how you could possibly delegate your staked position to earn further revenue in the k two pool to more or less join this pool. Of course you can join by means of the Dapp, but more securely. We try to create an environment, especially around our new software mv, to onboard these more or less sidecar applications, to node runners, to be able to from your node enter some of these applications on these pools for your greater benefit or for your revenue directly from your own local instance. So just share your screen.
01:04:41.134 - 01:04:43.114, Speaker B: Yeah, sure. Feel free to take over.
01:04:44.454 - 01:04:45.234, Speaker A: Yeah.
01:04:45.974 - 01:06:02.254, Speaker C: Okay. Yeah. So the idea is with the k two delegation module, um, you greatly benefit from the securities as a validator having to join um, the, the pool and then um offer your stake position as a possible revenue stream. Um, as as mentioned it will be um locally run, locally managed. You have the the full overview of what the module is doing and have the flexibility to to set what actions you want to take whilst being a member of the lending pool and then allow for further restaking or to customize the staking outputs. So if I would go through the concept, it's no longer a concept, it's a working solution of MeV for validators. The idea is as a initial proxy software to the validator 1 second.
01:06:07.594 - 01:06:07.906, Speaker A: So.
01:06:07.930 - 01:08:13.414, Speaker C: As an initial proxy software to the validator you have the possibility with your consensus operations and activities to connect with other decentralized applications or other let's say private manpos and other further business logic, one of them being the k two native delegation module, which will give you access to the k two lending protocol. So by means of this module, you can think of MeV as a network of puzzle pieces of different allowable pieces, all of which eventually connects to a core. So you can build modules that work for your typical PBS order flow operations, but you can have additional modules that attach to these operations or attach directly to your node by means of the MV core, one being the k two native delegation module. So with the K two native delegation module, we aim to securely allow validators to automatically and securely authenticate with the pool, assuming you have been registered on the proposal registry and then delegate your current stake having been identified on the proposal registry to the lending pool. So I will give like a deeper dive into the workings of this module. So for this module specifically, without going through too much code, the concept is every validator essentially would have a beacon or consensus client software. These consensus clients softwares have been built to obey a spec and leveraging this common spec across all clients.
01:08:13.414 - 01:09:55.489, Speaker C: So with full client diversity support by means of this builder API spec and beacon API spec, we can leverage different data points within the node for external applications, even on the execution layer from a consensus node. So one possible use of the builder API aside, your operational PBS stream is to leverage the registration events or the registration endpoints by the builder API to further register your validator, not just with relays and other blockbusters building services, but further register your validator, for instance in the proposal registry or in k two quite effectively. And so by means of the builder API. So just to briefly touch on what the builder APIs as a consensus node, you have the option to expose external block building to that get blocked by means of a relayer or external builders. With this builder API and validator clients configured on your node, there are these events of registrations that emit roughly every epoch by the node to this configured external body. And these events pass. For instance, if you're using a different validator proxy software, they pass through this proxy software which will then emit these events to relays to register your, let's say your gas limit preferences with the relay and so effectively running your PBS operations.
01:09:55.489 - 01:10:55.868, Speaker C: But with these broadcasted messages, the node more or less is making known to whatever proxy layer is built on top of it what validators are available on the node, a signed registration of this validators availability on the node to confirm its existence and ownership of the node. And so by means of these registrations, you can also prove the ownership of those validators on the execution layer as well. It's not pretty conventional that you could go straight from consensus activity, basically like your consensus events activities, even like your change of keys on your node can almost instantaneously reflect on execution layer by means of like the k two module through MEV. So with this, let's say, registration event that fires to the builder API, there.
01:10:55.916 - 01:11:28.624, Speaker B: Is, yeah, sorry, sorry, just to just touch on a point. So that means, because I know, I know there's like obviously a problem in the PBS space where basically relayers are replaying registration messages to other relayers to have like to sync all of the databases. But basically if you have like a single on chain registration, then everybody can sync that contract and use it for whatever application, whether it's PBS, whether it's restaking and so on and so forth.
01:11:28.664 - 01:12:38.220, Speaker C: Right, correct, correct, correct. That's correct. And so you kind of have of course the single sign on. So having that central point of truth, especially on the blockchain that is known and is not offline, that can be mutated, is a truth point for more registrations across different services, even off chain services, like if you have multiple relays in strictly PBS you want to contract with, they could use the proposal registry we've gone through as a point of truth as opposed to trying to relay or emit these registration messages across different service providers. That's correct. And yes, and so with me plus, I'll just briefly touch on the great granular and flexible nature of the MV plus architecture and the kind of ecosystem it enables. So with these registration messages aside, your header and payload requests that come for your note.
01:12:38.220 - 01:13:55.528, Speaker C: For your typical PBS operations, these registration messages are handled by the builder API module. So I would just briefly touch that. Everything in MV I would minimize these. Everything in MeV is very lean and modular. So the entire validator proxy software is simply these sets of folders and the ones of preference or the ones of use to anybody build on top of this is the modules folder and the modules list. In a modules folder you can build any sort of application or software you want to provision for node runners directly through their node by means of the beacon API or by means of the builder API or any other validator key management API that may be available on the node. You can build solutions or projects around that within your own contained folder library, quote unquote module and then load it into the software by means of defining the service here and defining any custom commands that need to be passed into that particular service.
01:13:55.528 - 01:15:46.230, Speaker C: So in this case, we have done so for the k two module that would enable these registrations on chain through these consensus layer activity. And so returning back to what the builder API essentially does is we have as a, as a proxy software, when the registration messages come, there is a module called the block aggregator which essentially would handle the aggregation of either blocks, headers, payloads and even registration messages across different modules that want to be a more or less like a blog source or a block provider. However, this particular module which is within this folder also acts as a hub to broadcast to notify other modules of certain validator validator activities. So as a external app, as a module like k two, we can latch on to these registration events even though the registration event is not fired directly at us, the module. So and k two being able to handle, since it's like passing a passing of events and messaging and data types across. By the way, this is contained securely within the software, it doesn't get exposed outside data can be passed securely across different modules without the need to actually understand the types or the logic of that module. You can get the data, the registration data from the builder API through the block aggregator and perform other logic based off of that validators activity for that given epoch.
01:15:46.230 - 01:17:23.934, Speaker C: And so, delving a little bit deeper into how k two manages this, I'll just quickly show you the essential things to note. So for the k two module, you can configure the module to handle registrations on the execution layout within the proposal registry on its own and also opt to delegate your stake to the k two lending pool for of course further income and by means of this, the things to make the setup pretty easy and lean, the things required. And I'll point out here are a wallet private key, a beacon node URL, and an execution node URL. These can be set to your node directly. So in this case for your on chain activity, you can even privatize it in your own isolated ecosystem by having a custom RPC URL or node specifically configured for your module. So any transactions you even take don't need to show up on the global mempool if you'd wish. And then the beacon node of course, is to latch on to your beacon node activity and confirm and validate against the builder API messaging activity that's occurring now.
01:17:23.934 - 01:18:37.338, Speaker C: Of course on on chain every every wallet execution needs. So on chain every every transaction execution like would need an executing address to perform this activity on the contract. You can configure this to any any wallet like if you have a wallet abstraction, anything any address that can act on your behalf. But I must note that this address provided here when registered in the proposal registry, would represent your ownership of that registration and so is by means of this address. If owned by you or any other entity, can you make further actions on your registered think of it as we're kind of like taking almost like web two's login architecture onto web3. So you basically have the password to then later go into your accounts to, let's say change your phone number, things like that. This is the address that would more or less be your ownership or representative address for the registry and native delegation.
01:18:37.338 - 01:19:46.044, Speaker C: So ensuring that you do have access to this address or hold this address is essential to run this module. With these provided keys, Mvplus out of the box can be configured with just the k two module enabled, and we can latch onto this builder API messaging even without having to replace your existing via data proxy software, or even without having to commit to to a PBS operation. So you don't necessarily have to be running or building blocks externally. You just need this module enabled as a sidecar ecosystem to perform these on chain executions for you, the node runner. So delving much more deeper into what exactly the module does. These are, if you'd get into more into MV, you'd quite easily be able to pick up get up to speed on to how to configure your modules. And it's pretty lean being able to connect to the communication.
01:19:46.124 - 01:20:03.160, Speaker B: Everybody writes a service file. Then let's say if I look at native delegation module as inspiration for creating my own module in MeV. So the basic structure is you're saying I need a service file with implementing the interface, correct?
01:20:03.232 - 01:21:08.736, Speaker C: Yes, correct. So everybody kind of to use MV so let's say the k two module, every module or every project here essentially meets a service file spec. So this is the spec, it's kept really lean. So you have just the name a start function to define any microservices you intend to start, whether it's a server, anything defining these function scopes would be fired by MeV plus during configuration, during connection, and to start your module and stop it effectively and manage your own resources. Of course the name is the identifier for that particular module or package. Yes, the K two module does follow the spec, and in connecting you can follow a few of these modules to see how to write these functions. These are the only required functions to attach as a module to MeV.
01:21:08.736 - 01:21:56.124, Speaker C: So you define your service file. It can be any data structure, any service data structure, but it must have the wrapper commands to be able to identify your module, start any um, services you intend to run, and of course configure your module if you have any custom flags. And so that's the actually the entry points. Thanks Vincent for leading to that. That's the entry point after knowing what flags are available, um, on the k two on your left. So in the entry point you're basically configuring you are passing all like your necessary flags, private only, to the k two module. So if I must know that if you pass wallet keys here, they don't get exposed to, let's say the relay module or the builder API module, you don't get that leak of private data you are passing to your module.
01:21:56.124 - 01:23:25.560, Speaker C: Once that's passed, you can configure your module and the module is written, such as to check quite thoroughly. Configuring things correctly because we are dealing with users funds, your funds, the use of your transactions, we securely ensure that all contracts are available, validated and have the right methods available, and identify you on all the supported chains, both your beacon node execution layer node and any sign as you attach to the module. That's essentially what the configuration of this module walks through and identifies the k two contract address to configure for and the proposal registry address to configure for, depending on what chain id you're connected to. So you don't have to, more or less, you don't have to figure out whether you're running for mainnet or running for Gourlay. Spin up MeV with a k two module and based on the node spec you're running, we can identify which chain id you're running for the current sync and status of your node performance of your node and connect and configure the module accordingly when it's of, let's say a write sync status and of course a write chain as well. And so this is simply the configuration of this module. Now, I would just, I know I mentioned what these are about.
01:23:25.560 - 01:24:58.150, Speaker C: And of course in like the, just a few minutes ago when we spoke about how the deposit contract, and then you have your withdrawal credentials for like execution layer for, for the Ethereum network. Similarly for proposal registries, you have of course a way to redraw your funds and by means of a payout recipient flag, payout recipient address. And so this address, if configured within the module, it doesn't necessarily have to be the address of your, of your represent, it doesn't have to be your representative address or the address that has ownership. Because considering you have an entity that is running this entire infrastructure and you want to pool all your rewards to a specific, let's say, syndicate, you can specify the payout recipient address to which payouts from lending into this pool or from registering. And the proposal registry would go towards if you are using the registry for ponytail or anything else. And so once this is effectively configured, you can more or less start, and this will start up with your node. And then on every registration message from the builder API, we would have a sequential check, a sequential check of this registration message to perform on chain registrations and checks for your configured validators.
01:24:58.150 - 01:26:21.530, Speaker C: So just briefly going through the code, the idea is to obtain all the validator keys that are emitted by this message and then run these validator keys through the proposal registry to identify which validators are registered already and which validators you would wish to register. So this proposal registry check is on the contract level. So this proposal registry check batches all available validator keys and checks. It's on the proposal registry contract for the proposals registration. On the contract level we can, considering that nodes have tons and tons of keys, this only goes as a slight overhead to the execution of the size of the call to the contract when you are later registering. By in calling the contract, we can batch all of these key checks by we are leveraging the multicore contract to batch all of these key checks at a go to optimize speed instead of doing a single call at a time. And we also can effectively batch call to the execution layer node as well.
01:26:21.530 - 01:27:31.144, Speaker C: Different transaction executions at the same time. And so in checking the proposal registry results, you basically have a status defined in the registry. The status varies from you being active, unregistered, kicked, I could just pull that up quite quickly. So status varies from you being active pending an exit, being kicked, or you're active outside the pool. The status identifies in the registry effects of current activity or current actions you've taken as a node runner within the proposal registry. This status can then further inform, and this is what of course the k two contract and other application level, other layered applications on the registry can use to identify valid validators for setting activities in the different applications. And so using this status as well, of course that's what's so beautiful about the proposal registry contractors.
01:27:31.144 - 01:28:45.750, Speaker C: You would get this broad information without necessarily have to go node by node off chain. And then using this status you can identify registrations needed to be processed and registrations which are already processed. Now the node emits these registration messages and so there will be a pre signed message with its signature and, and valid public key to which we can then use to execute the on chain registrations. Now as a node runner, you have the option to change the nature of this message. So in the case that you want to change the fee recipients. So as a node runner, let's say in performing PBS operations, you have a fee recipient that's specific for your MEV rewards or your block proposal rewards, you can manually change this within the K two module, hinging on the fact that you have a signing service that can resign this message with that validator key. Again for the registration.
01:28:45.750 - 01:30:07.358, Speaker C: We are strong on ownership, so no one can spoof anything, um, and, and ensure that airtight security. And so like you need to show proof that you have the um, the, the ownership of that, that given validator to mutate this message and then the, the module. And of course the registry can use this message appropriately. And so one means of doing that is not required, but to allow that flexibility for all sorts of different parties or different use cases is to include a web3 signup. So web3 signup is a small package like Java based service, depending on what variation you get, that will allow you to, on your own node without moving your keys anywhere to any external party, target your, whether it's lighthouse or prism, whatever, target your, your key directory and then just load those keys for signing off a limited number of messages. So you can sign registration messages, attestation messages. And these are not things we are introducing, these are, these are solutions and tooling that already exists, that are already plugged into many of these consensus layer clients.
01:30:07.358 - 01:32:24.656, Speaker C: So your consensus layer clients can actually, out of the box, use a web3 signer URL for your key signing instead of loading the keys directly. This is beneficial for some parties who have a centralized signing service much more securely authenticated, where either the keys are more distributed in a way to sign over the proposals that are running the node. But this is available within this module to allow node runners to change the fee recipients of these messages to vary from the fee recipient that is configured on the node for maybe a different wallet that you want to collect rewards and balance check later away from your PBS operations so you can separate your funds or separate your revenue streams for like a better overview of your operations. By this means, and so having identified the signable keys that are configured for that particular node, assuming you don't require that, it's not necessary and so it won't go through that step, but it would process the registrations that are required to be processed by identifying if there's a need to change the payout recipient. So even if you have a pair recipient that is configured the same as your node, we would bypass this step and have no need to change the registration messages that come out of the node. But if there is a different PR recipient from what's configured on the node, then the web3 signer is employed to sign this new registration message with this new payout recipient instead of the registration messages payout recipient that you've seen here. And so once that step is pretty much complete for a conventional node runner who has no need to, let's say, change this recipient and have the same recipient, this is skipped over and then there's a need to have a signature that is understandable by the contract.
01:32:24.656 - 01:33:57.264, Speaker C: So this is where the signature swapper comes into play. So the signature swapper is basically a, a small attached service to the, the registration workflow where a ECDSA signature is provided that can of course the ECDSA signature is much verifiable on chain as compared to the BLS signature passed the contract, which is still stored and verified against your proposal public key. But the ECDSA signature provided by means of a signature swapper service can be used as verifiable proof against your BLS signature by the proposer for the contracts. So I will just show you what essentially this signature does. So in this, with this signature you have, you may be familiar with this payload that's emitted by your node, let's say every epoch by the means of the builder API where you've configured like a few recipients, you have like a 3 million gas cap, sorry, a 3 million gas cap at a given timestamp. This payload with as I've mentioned your representative address is the address that you would more or less like. Delegate ownership of your activity on these registries to.
01:33:57.264 - 01:35:11.212, Speaker C: This payload can be verified for ownership and then sign and return a execution layer verifiable signature for the contracts as well. So this is kind of akin to the same signature here. It's just a swapping of the signature scheme for the contract's sake. So depending on which network you're connected to for testing, this is gorely. For instance, there would be a signature swap, a microservice to provision this swapping of signatures that you can also check against. And so back to the back to essentially what the contract is doing is in provisioning these signatures, you can identify validator keys that require, that are really fresh babies that haven't been in the registry before. And on top of that you can also leverage the k two lending pool as a water like a sequential operation to you registering on the proposal registry.
01:35:11.212 - 01:35:23.544, Speaker C: So you may configure, you may not configure the k two module contract address and that can be bypassed as to whether it's on mainnet or, and its availability.
01:35:24.924 - 01:35:30.172, Speaker B: So let's, shall we see this in action? We see this in action then, yeah.
01:35:30.308 - 01:36:51.134, Speaker C: Yeah. Okay, so once, once the registrations are prepared, you can check the k two module as well and then for whether those registrations are available. And then the registrations can then go ahead to batch register your validators on the proposal registry and then of course badge register your validators on the k two module as well to, to natively delegate. And so to run mvp you can build, of course you can build me. We have gone through how to use mv, but to check mvplus is running, you could run if you're not sure what to do or how to configure me, you have other modules pre built with it. And then you have the k two module where you can pass your beacon node, your ETH, one private key, your execution layer, clients, et cetera. And so considering that these events happen every epoch, and that's just for demonstration, what we don't want to necessarily wait for every epoch you can mock these registration messages as sends to the signature swapper for an ECDSA address would be mocked from the node just to show the operational use case of of this module.
01:36:51.134 - 01:38:35.840, Speaker C: Okay, so MEB is up and running now should be about five to 10 seconds for the mocked builder API registration event to happen. Okay, I took one of the keys out that we are mocking and so we have seven to process with one new key. I've just introduced for proposal registrations. So it has sent the transaction to the proposal registry contract for registration. And of course this is just waiting for the transaction to be mined to be sure you are registered on the contract, but this happens async, so you can do running your validator operations without this blocking anything whilst it's in the process. And so the contract was executed on the k two, sorry, on the proposal registry contract transaction was completed, and so now it's going ahead to register you on the k two contract. Similarly, you get a log when that completes on the execution layer.
01:38:35.840 - 01:39:07.584, Speaker C: But I could show you that's given transaction hash of the success 23 seconds ago on chain. And I believe when we, when we add this should, when we add k two, this should increase. And so the k two registration transaction has been sent. We're just waiting for it to execute as well.
01:39:10.084 - 01:39:19.900, Speaker B: So we should see available to borrow for restate detail. To borrow will go up in the contract for people creating spv positions, correct?
01:39:19.972 - 01:39:22.380, Speaker C: Yeah, right, right.
01:39:22.492 - 01:40:13.234, Speaker B: So it's pretty resilient as we've seen. It does all the checks and we'll ensure that, you know, all the invalid keys are filtered out and only the keys that can register. So one thing to bear in mind here is obviously if you, if you're already in the registry, you cannot register again, you cannot double register, and if you leave the registries, then you cannot come back in with the same BLS keys. You have to basically create a new BLS credentials and rejoin the consensus layer so it gives strong civil resistance. And at some point, so obviously in maybe some future videos we can show how to deregister. Right. This k two module, Ronnie, if you could touch upon it, will have the features for claiming the earnings from the k two protocol.
01:40:13.234 - 01:40:17.130, Speaker B: And if you can undelegate, you can do all those kind of things, right?
01:40:17.282 - 01:41:50.702, Speaker C: Yeah, that's correct. So once registration is complete and without representative address configured in the module, the k two module would eventually expose a secured API. By means of which you can think of it, you can perform web3 contract interactions over your typical HTTP requests, and the module would handle that effectively using the right keys and the right registration messages configured on the contracts. And so this is typically how like the flow would be. We would have like your proposal registrations after all the checks running, the safety checks are quite thorough, even before the next set of registrations on the k two contract. So if anything goes wrong, it fails through and doesn't, causes funds being moved, is assets being secured, so it fills through and doesn't ensure any erroneous activity goes on within the module by means of faulty messaging, which if you. Of course, we had like the similar case where you passed, if you pass like, a wrong BLS key or something was proved or wasn't correct, it validates this and its fall through nature would not allow your registered funds or your validator keys to be moved either to the registry or the k two landing pool if there's something wrong with your node or with your node messaging.
01:41:50.702 - 01:41:53.230, Speaker C: And so let's say, can we go to the depth.
01:41:53.382 - 01:41:58.382, Speaker B: Yeah, and see, like, that the available tomorrow should have gone up.
01:41:58.478 - 01:42:12.314, Speaker C: So this is the k two contract execution going through. And then the Dap was 30 to nine. Just connect the wallet. And then I was much as much higher. Now.
01:42:16.604 - 01:42:21.236, Speaker B: So more spvs can be created. That's, that's super awesome.
01:42:21.340 - 01:42:21.740, Speaker C: Yeah.
01:42:21.812 - 01:42:25.144, Speaker A: So you can, you can add hundreds of validators in one go.
01:42:25.924 - 01:42:35.988, Speaker C: Yeah, you can add tons of validators. So for any node runner that has thousands and thousands of keys, it would batch all of them. So in as much as we just did, a few seven.
01:42:36.156 - 01:42:42.394, Speaker A: What's the gas limit? Is there any kind of numbers that you want to use, like, at one given.
01:42:44.294 - 01:43:06.052, Speaker C: I would say for like, the, the effective use, we could come out with a effective number, ideally after that. But there's no actual restraint at the moment to the number of keys. But of course, with a larger size, more computational cost. And so, like.
01:43:06.238 - 01:43:21.176, Speaker A: Yeah, because a lot of big node runners have like 10,000 keys and 20,000 keys. Right? So if you go to Lido, you know, this kind of large staking pools have a large number of keys, and if there is, like, all of them are coming in, then.
01:43:21.280 - 01:43:35.068, Speaker B: So the module will automatically manage that. It'll automatically manage, like doing it in like, you know, over, you know, more than one transaction so they don't have to think about it from their side. Okay.
01:43:35.116 - 01:43:41.424, Speaker A: Okay, that was, that was my question. Do you really need to understand transactions? Because there's always a gap.
01:43:41.964 - 01:44:09.744, Speaker B: So the whole, it's a whole new paradigm. Registering your validator credentials on chain and, you know, from a node operator perspective, you know, it's, you know, there's a big learning curve here. So the idea with the K two native delegation module and mev plus in general, this sidecar ecosystem will take care of smart contract execution for you and manage all those things regardless how many keys you're managing.
01:44:10.684 - 01:44:54.010, Speaker A: It's pretty different from how you register with them and maybe relay, because you're just doing it like an off chain, but this is like do all the checks and off chain and in your secure enclave computer, whatever it is, and then you are communicating to the blockchain and it's just going to replicate all the state and it does all the validations and then it also takes care of how many of them actually going to be parsed to them because you cannot just put like 10,000 things in a block. Right. Because there's obviously, there's a gas limit, there's other transactions are going through, we don't know which builder is going to pick it up and then, you know, but it will automatically manage all of that payload. Transaction payload, that's right.
01:44:54.082 - 01:45:43.094, Speaker B: And existing relayers can actually, you know, they can, they can delete the registration databases that they have, you know, because obviously running a relay is very costly and has huge overhead from a data perspective. So that can be completely deleted because the. So in the builder spec, in the builder API spec, there is an SSE container validator registration v one that's, you know, as being propagated on chain. And all the realists can sync the proposal registry so they can completely delete that and they can just use the on chain source of true. And if the validates kick from consensus layer, it'll get kicked from the execution layer as well. So there's no management updates needed to take place and you don't have to replicate it amongst multiple relayers. It's all taken care of here, compliant with the theorem specifications.
01:45:43.714 - 01:46:26.474, Speaker A: All right, so that's, that's about the k two native delegations. And now you can delegate a billion dollar worth of Eve in one go and then someone can borrow, you know, 1 billion worth of eve at a fraction of cost and tokens, I mean, the tokens, and start experimenting. That is delegating is a few seconds or a few minutes, depends on the Ethereum blockchains and yeah, minting and starting up your own RST network is also same. Few seconds or minutes until your transaction getting confirmed and you're good to go.
01:46:29.494 - 01:46:30.274, Speaker C: Yep.
01:46:31.614 - 01:46:38.074, Speaker A: I think we're still sticking with a 62nd rule, but, you know, block confirmations need to come through, so. That's.
01:46:41.164 - 01:46:42.264, Speaker B: Right, exactly.
01:46:44.284 - 01:46:59.424, Speaker A: All right, thanks. Thanks for, you know, walking through and we'll see where it goes. We're going to open the testnet pretty soon. You can do the native delegation to the main net or you can just do the proposal registration today, right?
01:47:01.884 - 01:47:13.644, Speaker B: Yes, the proposal. The proposal registration can be done on Ethereum. So that's the pre registration step for native delegations. So yeah, that will be doable soon.
01:47:14.584 - 01:47:51.514, Speaker A: And you just run the same module and look at the docs and it will have information how to do the preregistrations. If you want to get into the cases and the, the testnets finish and maintenance is coming up, you can be there because there will be a queue to get into delegation on the k two because it will only allow certain limits of the validators. Even though you're there, there are ceilings just to make sure that, you know, the diversity of the nodes can be enabled for the native delegation. All right, cool. Thank you.
01:47:53.254 - 01:47:59.382, Speaker B: Thanks, guys. Let's see your SPPs, your rsts, and let's see. Let's do it.
01:47:59.558 - 01:48:00.054, Speaker A: All right, cool.
