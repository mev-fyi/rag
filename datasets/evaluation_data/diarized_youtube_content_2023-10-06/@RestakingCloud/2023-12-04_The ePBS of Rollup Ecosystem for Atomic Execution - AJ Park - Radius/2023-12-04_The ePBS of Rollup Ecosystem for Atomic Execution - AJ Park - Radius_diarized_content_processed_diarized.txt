00:00:00.440 - 00:00:30.400, Speaker A: Hi, this is AJ from Radius. I'm co founder of Radius. Radius is building shared sequencing layer for rollups. Shared sequencing layer is kind of a new infrastructure in modular blockchain to help developers. Developers deploy their roll ups kind of easily and also to operate them efficiently. So you might not familiar with the sequencer. Sequencer is kind of validators for ethereum.
00:00:30.400 - 00:01:56.034, Speaker A: So right now, many roll ups have really centralized sequences. So I think that a shared sequence layer can help them decentralize to operate them better. So yeah, so sequencer has kind of many roles, especially receive transitions from end users and aggregate them and execute them and post the results and also prove to layer one. So if you want to build your own roll up network, you need somehow decentralized sequences because centralized sequences have really a big issue like liveness and censorship and also mev stuff as well. So decentralization is different meaning in rollups compared to layer one, because in layer one decentralization is essential because their security. But in roll up space they need to operate them more transparently because it's going to decide, for example, how much and the user in rollup is going to pay or something. So there are two ways to decentralize sequences.
00:01:56.034 - 00:03:10.136, Speaker A: First, we can take this monolithic approach by having multiple sequences doing the same thing, the every functions that I just mentioned. But it's really difficult because there are going to be many, many roll ups, which means that we need much more sequences for these multiple roll ups. So radius like to take this module approach, which means that we are going to specialize these functions, especially like a builders network, to build block a proposal to execute them and propose the block, and also prover for generation proof for rollups. So this module approach I think will take care of this whole overload that many roll ups are bringing to the space. So and then probably a restaking stuff can be applied for these sequences. So I will explain later. So we do really care about this MEV actually happening in L2 space.
00:03:10.136 - 00:04:08.664, Speaker A: So radius use encrypted mapple to prevent this bad MEV happening on user side in L2. I know that there is some controversial in MEV stuff, but we define bad MeV, which would lead to financial losses on user side, like a front running and sandwich attack. You might lose your funds to me, such as. But you know, MEV is all about how to order transitions. So we basically use encryption to hide your contents of your transactions from these MEV searches, so no one can see your contents. And then also if we encrypt the whole transactions, it also help this roll of network sensors resistance as well. So that's why we use encrypted mapple.
00:04:08.664 - 00:05:09.992, Speaker A: And then also another important one is that the reason why we are going to use this roll up network is that we can get a fast pre conformation from this roll up network if you want to. Finally, from Ethereum, you should wait on at least 12 seconds. But if you use encrypted manpower in the roll up, you can get a really fast pre conformation thing saying that your transactions will be included in a specific index of next block or something so you can get a better user experience from it. So that's why we decided to use encrypted manpool. So let me go deep into how it works. So basically we use a time log encryption thing, which means that if end user wants to create transitions, he needs to encrypt them. But the encryption key is from the time load puzzle.
00:05:09.992 - 00:05:51.882, Speaker A: A timelock puzzle is kind of the number of sequential computation which make this sequencer solve this timer puzzle for a couple of seconds. So that's. So end user needs to generate this terminal puzzle. The solution to this terminal puzzle will be decryption key. So this solution is kept only on end user side. And then if sequencer wants to decrypt these encrypted transactions, he needs to solve this time of puzzle. So this is where a delay comes in.
00:05:51.882 - 00:06:49.564, Speaker A: So during this delay, a sequencer needs to respond to user end user without order commitment. It's kind of a pre conformation thing. So that's how we can get MeV registered stuff with this encryption stuff. But the problem is that this sequencer cannot, since this sequencer cannot see the contents of the transitions, some malicious end user can attack against sequences like. And some malicious end user can generate invalid encrypted transitions with a gibberish transition and then deliver it to sequencer. Sequencer cannot distinguish if this encrypted transition is valid or not. Which means that sequencer is going to waste on their computing resources to solve this terminal portal to find the decryption key.
00:06:49.564 - 00:07:44.044, Speaker A: And also if a sequencer included this block into a next block, it's going to waste a block space as well. So these two wasting thing would lead to network instability. So it's really bad one. So that's why we use radius uses Gkp stuff to prove that this encrypted transactions is valid without decrypting it. So yeah, so when end user creates transitions, it also needs to generate this GK proof to prove that this whole encryption process is done correctly. So which guaranteed on sequence side that this encrypted transactions is valid. So that's the protection for sequence side as well.
00:07:44.044 - 00:08:45.358, Speaker A: And also I said that sequencer needs to respond to user with the order commitments. What if a sequencer break this order commitment? So how we can enforce this sequencer to keep this order commitment? So it's kind of simple. We can take a slashing mechanism here because a sequencer publish confirmed block to layer one in smart contract. Layer one is going to store a list of transactions hashes that he has committed to so far. So and then an end user can find out this blog published on layer one. He can find out if this order commitment is kept or broken. If he finds out that it's broken, it can claim to the smart contract on layer one.
00:08:45.358 - 00:09:37.036, Speaker A: So it works trustlessly because it verify this claim in a smart contract. So there's nothing that a sequencer can do with it. So if this claim is success, this sequencer is going to be slashed. So another one is that sequencing layer is really care about the liveness. Liveness is really important for this sequences because um, you know, so whole roller network is kind of a scaling solution. So we take this leader based sequencing network, so this user can send encrypted transitions and CK proof to sequencing sets. And sequencing sets can, can generate this order commands by this leader.
00:09:37.036 - 00:10:31.552, Speaker A: And then you can make sure that consensus also happening during among these sequencer sets. So there were multiple sequences set multiple sequences in this set. So we can make sure that if broken or leaders stop working, another sequencer can take over. So in our system, we randomly selected this sequence of sets from the bigger sets. So right now we are using a VRF verifiable random function to make sure that there's a sequence set is selected randomly. So in this case also rest taking stuff can be used because it's really difficult to set up new sequencer sets from out of nowhere. But there's validated sets already stacked on ethereum and then restaking would be helped.
00:10:31.552 - 00:11:34.984, Speaker A: Set up a good quality of sequence sets. So another one, that sequencing layer can help this roll up network. Is that interoperability? Many people criticize this roll up centric approach. Is that because there will be fragmentation happening between multiple roll ups? But I think that sequencing layer is really well positioned to solve this interoperability between rollups because these sequences that have a full control of building a block for multiple roll ups. So for example, flashlauns, it has multiple transactions that should go to multiple roll ups. When sequencer received flash loans transactions. It can make sure that each transactions, each transaction in flash loan transition will go to directly included in block for each roll ups.
00:11:34.984 - 00:12:40.424, Speaker A: So which means that this sequencer layer can guarantee this atomic inclusion. But problem is with this atomic inclusion that even though we make sure this all transactions are included each roll up, we cannot guarantee these transactions are going to be not reverted. It can be reverted somehow. So that's where atomic execution comes in. So now as I said before, order commitment pre confirmation can enforce this sequencing a sequencer to keep this order commitment because there will be a slashing condition happening if he doesn't. So this order commitment order validated for order validation concepts can make sure that this atomic inclusion leads to atomic execution. But it's really difficult one because we are still researching it if it works or not.
00:12:40.424 - 00:13:29.714, Speaker A: But in quite near future we can publish if it works or not. So anyway. And then also this sequencing layout track all the states of this interacting roll ups. It can also. It tracks all the states of cross roll up like a flashlawn transitions. When this atomic execution is failed, this sequencing layer can point out the exact point where each roll up should roll back. So that's how the security also makes sure with this sequence layer concept.
00:13:29.714 - 00:14:15.224, Speaker A: So yeah, probably this is my last page. So we all know that there will be many many roll ups comes in probably tsunami of roll ups will happening in this space. Which means that we need really many sequencer sets for this. Make sure this all roll ups into Ethereum can be realized. So with this modular approach and also restricting stuff we can make sure we can support this millions of roll ups better than without them. Okay, that's the end of my poke. Thank you very much.
