00:00:00.880 - 00:00:46.158, Speaker A: Okay. Hope Devconnect's going well for you guys. I am going to deliver a talk in 20 minutes. So one of our colleagues that's been working on this couldn't be with us today, but. So I'm here in his place delivering this talk on MEV plus. So this is something that we spoke about in ECC. We said that we've got this idea for a new validator proxy software, and we're going to go ahead and implement it within the next few weeks.
00:00:46.158 - 00:01:51.048, Speaker A: And that's what we went away and what we did. So those talks are up and available for ecclesiastes. But let me just, let me just actually give some background, really, first, before we explain what MEV plus is. So what we want to do is really redefine what people commonly know, the definition for it, and we want to take a different perspective on it and define it as expressible value and expressible really from the perspective of proposers. So what that means is really giving proposers and validators programmability that they've not seen before. So if you are familiar with the MEV supply chain, you will be familiar with the validator proxy software, Mevboost. So, Mevboost is a software connected to a validator client, and it works with all validator clients.
00:01:51.048 - 00:02:45.034, Speaker A: And it serves one application, and that is an off chain application that deals with proposal builder separation and outsources a validator's block space to a marketplace of builders and relayers. That is one application for Mevboost. And what we want to do is we want to, so that application is there and needed, and we want to expand upon this with MeV. So MeV is built from the ground up to support that use case, but as well all kinds of new on chain, programmable use cases for proposers. So what we need is we need an on chain representation for a validator. So just remember that consensus layer. Validators on Ethereum have a BLS representation.
00:02:45.034 - 00:03:57.354, Speaker A: So they have a BLS signing key and a BLS public key, which is incompatible with Ethereum virtual machine, which treats the ECDSA curve and eoas as first class citizens. So if you want to interact with any smart contract, you need an EOA account. Even if you have a nosa smart wallet, you need an eoa to interact with it. So MEB, this is the modular architecture for that. So this is how we can actually support the existing flagship proposal builder application, which is our total senior block space, and actually allow anybody to add additional modules to the system. So we have the diagram on the right and you'll recognize most of the components in the system here. The consensus layer, execution layer plus is in there supporting the off chain applications and on chain applications, whether it be l one execution layer on Ethereum, or even l two s, you have, you basically open a portal for on chain programmability into any smart contract based platform.
00:03:57.354 - 00:04:49.906, Speaker A: And you might say, well, why do you need to do that? Well, a clear use case for this is restaking, where validators want to natively delegate their consensus layer balance to a smart contract so that ETH can be reused for restaking security. So how is it working under the hood? Like I said, it's modular. You have firstly a core that just facilitates communication. The core understands and implements the Beacon API spec, the builder specifically. And we have some additional modules that are bundled with that as standard. Like I said, you still support the PBS out of the box, but you can extend this and add your own modules. And the modules are isolated from each other.
00:04:49.906 - 00:05:35.204, Speaker A: The core is just used for communication between them and it is using standardized secure RPC communication between the different modules. So it's fast and it's secure. And also one of the core goals here with MEV is to ensure that we have good fault tolerance. So basically you can imagine a community member writing a module and plugging it into MEV. That should not affect the core or any other operations of the other connected modules. You will also be able to configure the modules that you need. If you want to run MEV and you don't need the PBS application, you don't need to outsource your block space for whatever reason, you can switch that off.
00:05:35.204 - 00:06:52.752, Speaker A: So here, what we're trying to do here is actually reduce the network overload. A big issue or a big topic of discussion in the Ethereum consensus layer at the moment is messaging overhead. Ethereum is approaching a million validators, active validators, and in an epoch, you know, you only have 32 slots, and in that time you're still dividing the active validator set and asking them to perform attestations and you have all of the messages associated with that aggregation. And you know, so we have a lot of messaging overhead and there are ways in which we don't make this an n squared problem. So, so the upside from this is basically if a validator has programmability and they can basically connect with potentially different revenue streams for them. Obviously on the consensus layer, the more validators that are joining, the less there is going to be in attestation rewards, block proposal rewards and the rest of it actually you get obviously less probability of block production. And validators have outsourced their block space to try and boost their revenue.
00:06:52.752 - 00:07:43.016, Speaker A: And they can then now with me and adding additional native delegation modules, they'll be able to, in the comfort of an air gap machine, they'll be able to register and restake on the Ethereum execution layer. And we have many talks about that. There is a lot of freedom here, it's go lang based. But what we want to do is actually we want to build MeviewPlus and put out specifications in the same way that the current Ethereum consensus layer clients and execution layer clients are. You have an open specification and multiple implementations. We can provide one that is a Golang implementation. It's all mitigated license, so do whatever you want with it really.
00:07:43.016 - 00:08:38.384, Speaker A: It's provided as is and you can expand by writing additional Golang modules, you just install them and away you go. But it allows you to do development in isolation, really. So trying to keep this as simple and as straightforward as possible so you don't have to worry too much about the implementation of MEV or what it's doing. You're just going to spin up a module, define its name, how it starts and how it listens to events that are communicated by the core. You can have inter module communication, you can add logging modules. There are actually a lot of things that you can do with this. You know, it's really just, it's up to you guys as the developers.
00:08:38.384 - 00:09:19.774, Speaker A: So this is an example really of how at the moment a module will just all get injected. So we have MEV comes with a set of core modules. Like I said, you can configure how they run and whether you need them at all. But your additional module can be installed into this, into this module for folder with a simple shell script. And it's the same as if you wanted to manually do it. You can manually import the module, add it to the service list and on booting up it's going to register the module and then communication starts. So really trying to make this as simple as possible.
00:09:19.774 - 00:10:24.700, Speaker A: So yeah, so let's talk native delegation. So you have nodes that are configured with their validator clients and potentially web3 signers. So some setups will use a web3 signer as well. And that is keeping, those keys are kept securely on a machine, maybe even on a DVT machine, sorry, DVT cluster. And you know, however those things are set up, you can plug Mev into that and you can actually ask the validator client to sign a validator registration message that they are already doing when they are interacting with the PBS applications. And that is a message that can get converted into something that a smart contract can understand. And it is your, what you are doing is you are consenting to your stakeholder being restaked on the execution layer.
00:10:24.700 - 00:11:01.964, Speaker A: It is a proof of ownership message that you are in position on the signing key and you consent to restaking taking place. The module will also allow you to claim any rewards associated with restaking. It will go to the configured fee recipient, which may be. Obviously we had dapp node here talking about their smoothing pool. It could be another protocol, it could be. So however the fee recipient is configured, the payouts will get taken care of. But equally, if a validator no longer wants to participate in restaking, that's fine.
00:11:01.964 - 00:11:44.804, Speaker A: They can exit their stake from the execution layer and potentially just leave it as that or connect to something else. So it's really, really extensible and really straightforward. Yeah, so we're trying to do this in an open source fashion. We have MEV, actually, we've got a public open source repo for that. If you go to GitHub.com restaking dash cloud, we have the MeV there. We are going to push the first module which will offer on chain communication and programmability for validators.
00:11:44.804 - 00:12:37.404, Speaker A: But because it's modular and extensible, anyone with any idea can extend this in the way that they wish and write their own modules that can be private, public. It's up to you. I think the use cases that are coming out are pretty interesting and we're going to look at different toolings to stress test this, things like kurtosis. And there are many other toolings that you can use to spin up this in a sandbox environment for your development, to make your development as straightforward as possible. So you just focus on writing your modules and the tooling will take care of the rest. Really. So it might take some time to figure out how to use this, but I think it's a very powerful primitive for validators.
00:12:38.704 - 00:12:39.304, Speaker B: So.
00:12:39.424 - 00:12:57.844, Speaker A: Oh yeah, this is a QR to the GitHub repo. If you want to take a look at that, any feedback is very much welcome. We are quite excited to see what developers will do with it. We have various ideas. Throw it out and see what happens really. But yeah. Any questions?
00:12:58.184 - 00:13:26.296, Speaker B: Thank you. Just to get some clarity on when you say MeV can have additional module by outside, so you might be very aware about the inclusion list of proposal commitment that he can want to do with some sort of commitment. Right. He can implement an inclusion list from this and to propose to builder and if they satisfy it and you can slash them with summary staking, right?
00:13:26.400 - 00:13:27.976, Speaker A: Yeah, yeah, absolutely.
00:13:28.080 - 00:13:43.986, Speaker B: So you have the native delegation here that she's showed before, which is the proposal already have delegations and then he's earning money and then he just proposed it. And if the builder is also having in builder registry, this can be done, right?
00:13:44.170 - 00:14:06.708, Speaker A: They can just be composed. I mean, when you have access to the execution layer, then you have all these possibilities in place. You basically what you're doing is you're creating an EOA representative for your validator that can then act on all validators, plural, that can act on your behalf on the execution layer and replicate that.
00:14:06.876 - 00:14:12.948, Speaker B: And that era could be a signer, Seip signer.
00:14:13.036 - 00:14:24.916, Speaker A: It could be, yeah. So there are all kinds of NPC based approaches that you can take here. It can get quite interesting in that respect. For sure.
00:14:24.980 - 00:14:27.346, Speaker B: It's kind of a side market and it can happen.
00:14:27.450 - 00:14:38.754, Speaker A: Yep. You can think of it like it's just like a platform or an App Store for proposers. Okay, cool. Thank you very much, guys.
