00:00:00.440 - 00:00:48.306, Speaker A: Hey, everyone, myself, Matt, joined by wins. We're gonna take you through K two, a deep dive, which means we're gonna talk about a little bit detail about how K two as an application works that is dedicated for taking ETH from ETH stakers and making it available for everyone. Like the person who said he want to put decentralized army boots on the ground for just to make the community finance better. Great. So let's dive in. Cool. So the K two, the basic idea of the K two is how do we make the staked ETH the base layer for the modular future? Right.
00:00:48.306 - 00:01:46.406, Speaker A: We have all this kind of modular blockchains and everything is getting like more and more fragmented. You need to have a very unified security layer that can support all of these innovations at scale. Right? So we need a new kind of pool security model available. So what is restaking at the high level in a very basic way to think is like, other networks will get staked ETH from consensus layer for their, you know, to reinforce the security, but it's an opportunity for existing validators to get additional yield. And this will get a programmable security layer for, you know, to build all kind of other applications. We're going to talk about one application, the slashing logic, but it's not going to stop there. So it's kind of a new cloud is forming.
00:01:46.406 - 00:02:26.718, Speaker A: Right. So what we need to understand here is the K two. Let's take a step back, right. E to staked on Ethereum for one network, and this is how the proof of stake work. You basically go normally just one network rule and you give your asset, there are a few other chains with parachains and things like that, but still you have like one rule. But how do we make sure that the ETH that has been staked in the consensus layer is protecting the execution layer when we reuse it for other networks, how do we basically make that profiles? Correct. Now you're going for one to n.
00:02:26.718 - 00:03:01.598, Speaker A: So since we are only talking about the slashing security delivery, so we take about a compartment like slashing security. So every e that has been restaked will be utilized in multiple networks. But ETH is a homogeneous asset sitting in consensus layer. So one asset, every validator, has the same ETH and more or less the eid balance, but it isn't going to be get pooled and it's going to be reused. So now the pooled balance is like a fungible, but that's the, if you're given to someone else, their network is very different. Right. So you need to have a unique profile for that matter.
00:03:01.598 - 00:03:34.264, Speaker A: For example, if you're giving for l one and that is dedicated for gaming, that's a very different, you know, very different profile. L two has a very mission critical things. They need to have some sort of aliveness and security assumptions. They want to reinforce that security for that. So everything, every network, every Dapp, every decentralized network, every services that is taking the security is a unique profile, right. But everyone is getting Eid from the same big pool. Now we need to monitor all of this.
00:03:34.264 - 00:04:17.114, Speaker A: Otherwise you have problem. It's, you know, the pool security's gone everywhere. And then this is like a huge network overhead right now. Not only to track the networks that has sourced the ETH, you also need to track staked ETH at consensus layer. You have leakage, you have slashing, you have withdrawals, you have sweep, you have, everything is coming, right. So we're talking about like a very complex, so what we did is like we created k two is an adaptive restaking pool. Staking pool designs are very, very hard and it's like, it's still like a very hard, you know, deep research topics in many ways.
00:04:17.114 - 00:04:58.246, Speaker A: We don't have a staking pool in Ethereum, right. We have LSD pools, but we don't have a staking pool. Right. Staking pool in a sense that at the network level that takes care of all the network configurations. So when you create a staking pool that delivered the security directly to those network for slashing, you need to take the basic fundamentals at place that you should not have any kind of double stake. What that means you cannot give the same ETH that's been staked to one network to other. So if you have like a 10 million ETH at the pool, 1 million has been given for a year to one network has been taken.
00:04:58.246 - 00:05:14.502, Speaker A: You cannot just kick them out and somebody says, I will pay you more. That's not possible. That's been given to that. That's it. So double stake is not possible. Nothing at stake is not possible. You cannot give, you cannot take a yield from a network when there is no stake is delegated to that network.
00:05:14.502 - 00:05:51.150, Speaker A: So everything that we're talking here is at a network level. Delve deep about this, things that we're talking about here in the next slides as we go. But, and also like the stake eligibility for the rewards. Not every ETH is eligible for rewards, right? If you have an ETH at your wallet, same asset, but it's not staked in consensus. So you're not eligible for rewards from the restrict. But not every validators are not eligible for rewards, right? Your validator gets slashed, you're not doing a validation duty in Ethereum. So that is also very important.
00:05:51.150 - 00:06:18.698, Speaker A: Who can restake, which is the validator, how they've been tracked, when they will get kicked out, who can register and all this kind of stuff. And the distribution is temporal, which means that you get rewards after some time or you get terminated. There will be some delay. But here it is like that has to be dealt at the pool level, not at the user level. The user should be able to withdraw and deposit anytime freely. So this has to be done at the protocol level. Since we're talking about the slashing.
00:06:18.698 - 00:07:00.594, Speaker A: Slashing has to happen in real time and it should be automatic, right? Otherwise you have all kind of cheating will happen. Like, you know, people take the security and say that oh my network is great, but the reason that you took the slashing is to show the world that you're accountable for the things that you're doing. That's all the decentralized network is all about. And the more accountable that you are, the more people will trust you and the more you grow, right? The slashing is a good thing happens in decentralized network because that's how the networks heals. Networks can come to a halt to protect the user deposit and that can restart it. That's how the decent license networks. So we have programmable slashing and continuous security has been done.
00:07:00.594 - 00:07:47.094, Speaker A: And adaptive redelegation, that's one of the biggest part of the k two is like what if the source network is going down? If it's a malicious actor, there's a long range attack. How do you track the health and hygiene of people who has borrowed? Because there's only a certain amount of ETH is available to borrow to delegate. When I say the borrow to delegate for your network. So you need to have an optimal utilization. Who is providing the ETH? And a lot of people actually want to get it. You need to remove from the network, you need to have the space for the new people, you need to serve the existing one, right? So let's look at a very high level, how the existing validator on Ethereum can benefit from this. We call this as a native delegation mechanism.
00:07:47.094 - 00:08:27.352, Speaker A: It just like in how you signing a testation or in a proposal for Ethereum network. So native delegation will allow you to delegate your Ethereum validator balance and allow other networks to get security use that ledger balance and give you in return the k two will give you the yield. So the k two is the intermediary party that is connecting you to the many networks. You don't really have to go around and do this marketing for you. So that's how it's working. Native delegation allow any validator, every validator to access restaking opportunity by default. Right.
00:08:27.352 - 00:08:56.818, Speaker A: And this is, there's no withdrawal credentials changes, there's no operational changes, there's nothing there. We can just make it happen as of today. So it's very inclusive. Right. So how do we do this? Let's look at how we stake with Ethereum. So restaking, staking, it's the same thing that getting replicated, as I said before, there is not much difference. You're talking about validators in Ethereum.
00:08:56.818 - 00:09:36.840, Speaker A: When you start a validator, you have, you can register a BlS key with a validator with a minimum one ETH balance, but then you, you know, you become a validator when you have 32 e and then you'll get activated. There's a queue, but that's, that's something, the temporal thing that I mentioned before and there's an activation here, everyone want to join then that's like net row ahead, that's the queue will, you know, bigger and smaller. But now once you're active, yes. Consensyslayer is a single application chain. It produce consensus. But not every validator are eligible to do the validation duty. Only the active validators are eligible to do the validation duty and they are the one who is getting rewards.
00:09:36.840 - 00:10:08.658, Speaker A: And then once you exit, you're out. The same Bls key cannot be reused. There are few ways you can be out of the consensus layer. Good way voluntary exit, the worst way getting slashed, whatever the reason and or don't do anything. Leak, leak, leak, click and you'll be get out falling below 16 ETH. So then you're removed, you cannot come back, you have to register a new BLS key. So we only care about the life cycle status of being a validator in Ethereum.
00:10:08.658 - 00:10:40.306, Speaker A: Consensus layer. That's the validators eligibility criteria to restake. If you're not an active validator, we don't really care about you. If you exit from consensus layer, we don't care about you because you're not part of consensus layer. Right, cool. Now if you look at the state of Ethereum, I think it's more than this now anyway, you know, it's about close to 900k validators are available. That's a lot of validators, right? And that's a lot of ethics.
00:10:40.306 - 00:11:23.046, Speaker A: All of this can come and being accessible for any other blockchains, any other l, one, l, two s or centralized services, just to make sure they can have a decentralized path forward. Right. Better in a capital. What are we talking here in USD, we put the ETH in numbers, about $51 billion. And if all these guys can natively delegate, just give a consent that they are ready to give their security to others. There's a $51 billion worth of things has to be dealt in a smart contract. And all of that complexity that I mentioned before has to be taken care.
00:11:23.046 - 00:11:57.962, Speaker A: This has not been attempted before. So this is the very first time that such an ETH liquidity manager, we're talking about ETH liquidity here, right. And this is a very, very, very complex thing to do, right. Especially when you care about like, you know, different, different profiles, right? So how do we do this at a scale? We lean back how ethereum has done, right. How ethereum taken care of the Ethereum validator lifecycle. We want to replicate the same. So you don't really have much problems here.
00:11:57.962 - 00:12:18.982, Speaker A: So give us a context. The labs is working on consensus life for more than three and a half to four years. We do this day in, day out, so we know how these things work. So we created the registry model about two years. That's the one thing that is making is this smart contract model. So this smart contract is a unique smart contract. You can call it this data feed smart contract.
00:12:18.982 - 00:12:48.568, Speaker A: So it's not like your normal smart contract. So this has been in production and taking care of Ethereum validator application for more than a year and a half. So this is a new application. So as you can see in the consensus layer, ETH deposit contract is the one who is registering new validators. That's actually in execution layer. And it register, register with one e, you become part of the consensus layer ledger, a different state DB. Now the stake management takes in care of the three sections induction.
00:12:48.568 - 00:13:17.146, Speaker A: You've been added to the validator validation duties. That's called induction balance. And then in effective balance is there, that's where how you track the stake weight in the network. So at any given point of time, ethereum takes the stake weight. How much to do the consensus, not the total amount of e that the consensus total balance. And then you have always, there's a slashed amount which is taking the corruption. If there is some problem, any theorem is always that's been tracked by the slashing amount, right.
00:13:17.146 - 00:13:47.466, Speaker A: It could be leaked by liveness. If there's a correlated penalty that is also taken by amount of slashing from a, from a protocol violation. That's why you have some sort of delay. So we take the same approach restaking p on registry, proposed registry already in Mainnet. It's been working. So you need 32 effective balance because you should be a fully active full effective balance of 32 maximum stake wide then only can get entry. So but few, I think few validators doesn't have it.
00:13:47.466 - 00:14:19.500, Speaker A: But most of them, 99% of the validators have 32 effective balance. Then you can get entry to the negative delegation and restake management has the same induction. And if there is an if you have effective and slash, you'll be get kicked. One thing to understand, even though you register with the Ethereum deposit contract, Ethereum consensus layer, money comes back to withdrawal credentials. It doesn't really go back to the Ethereum. So it doesn't really deal with deposit and withdraw the same way. So deposit is tracked.
00:14:19.500 - 00:14:44.826, Speaker A: The ETH has never burned from the supply. You can go and see that contract and you can see the ETH balance on the Ethereum deposit contract. As of today, the withdrawal credentials receive the money, new money comes in. So it's like a very adaptive management. So similar way the peon registry tracks who can come in, but the yield that you're getting from the k two yield. So now we replicated a staking ledger on Ethereum execution layer, smart contracts. Right now it's in smart contracts.
00:14:44.826 - 00:15:07.978, Speaker A: Now you can get the rewards. Similar to staking rewards, you get your fee rewards to air address that you are giving. It could be a smart contract, it could be a gnosis wallet, could be eoA. Whatever the fee recipe address that you're giving, it's, it should be an ECDC address. So it's the same way that is getting replicated. Right, cool. We do this with the peon login.
00:15:07.978 - 00:15:18.854, Speaker A: I want my colleague Vincent to come up and walk you through the rest of the nitty gritty details and show the amazing world of how the mechanisms work. Vincent.
00:15:22.434 - 00:16:30.394, Speaker B: Hi guys. Yeah, so there's a lot to unpack there, but we're going to get even more technical and detailed here. But this is a nice, this is a nice segue into what we're about to discuss next. What Matt touched upon is really important. The registration of BLS credentials in the consensus layer is triggered by a transaction to the Ethereum deposit contract that will append a validator to the consensus layer. And one of the problems is now actually whilst the validator is active, or even if it's inactive, is actually having a representation for that validator on the Ethereum execution layer and maybe even beyond that other executions environments as well. And it starts with the basic problem, which is eoas are first class citizens in the Ethereum execution layer virtual machine.
00:16:30.394 - 00:17:47.257, Speaker B: And ethereum validators use BLS, BLS cryptography. So there are a whole host of reasons for that, including aggregation and many other things. But the two chains are not compatible at a cryptography level. So that potentially poses a problem. How do you have representation of validators on, on the Ethereum execution layer, especially without a precompile, right? So if you want to get technical, the BLS cryptography is on the, you know, the twelve 381 curve. And Ethereum up to this point doesn't support that. But we, with the proposal registry that's pictured here in this slide here, we have the ability to register validators into a smart contract and then we can, with that representation, create applications on top of that, this login with PN, this concept here is, if you think about one of the things that has evolved over time with online applications is the ability to share your credentials amongst many applications.
00:17:47.257 - 00:18:12.964, Speaker B: So think Google single sign on. You can sign into many applications with your Google credentials without having to create credentials for every single application. So that's what we want to achieve really. First with the proof of neutrality stack is get your validator registered and represented on the Ethereum execution layer. And this is what we can do here. So we have multiple approaches to do that. You can have a user interface if you want, but you can also do this at a node level.
00:18:12.964 - 00:18:45.364, Speaker B: And if you're familiar with the builder spec validators today that are participating in Mevboost and propose a builder separation, today they're already signing validator registration messages. We just make those validator registration messages compatible with smart contracts. And actually what we do is we have this pon component part, the registry part reusable for other applications. So basically other applications don't have to build this piece again and again and again. Again. It's a single sign on. So that's what we are achieving here.
00:18:45.364 - 00:19:47.898, Speaker B: In Matt's last slide he mentioned a few key, um, a, a few key values really. Um, so uh, minimum registration balances and active balances. So um, from a consensus layer perspective, consensus layer, uh, for its staking application doesn't care about active balances more than 32 ETH, anything more than that. It will just sweep to the withdrawal credentials, um, and um, but inside of a restake application, um, we cannot have 32 ethics, our balance representation. So the reason is simple. Validators are so ethereum consensus layer is very fault tolerant and can handle a high degree of validators being offline. When you're offline you're going to accrue penalties and that's going to bring your balance below 32 and potentially all the way down to 16 before you kicked off the network.
00:19:47.898 - 00:20:40.446, Speaker B: So to have like a buffer for restaking the stake weight that goes into the system in k two will be 24 ETH. That's more than the 16 ETH kickback for the consensus layer, but it's less than the 32. So that you don't have to do this active state management and have to report and managing anything above 24. So it gives enough buffer for validates operations to be restored and rectified. But it does not forgive any slashing violations that would kick you from the consensus layer. So we use that. That's how we are able to use the proof of neutrality, the proposed registry piece as a single sign on for your validator representation to represent all the state of the validators on the Ethereum consensus layer.
00:20:40.446 - 00:21:51.054, Speaker B: You just take the infrastructure stack and you build your restaking application on top of that, we're abstracting away that for you. And if you actually look into, if you're familiar with how Ethereum is functioning under the hood, so you have these, they were independent chains, consensus execution layer. How they're interacting with each other via the engine API is pretty complex. You know, it's really, really complicated to dock an execution layer into the consensus layer. For those of you familiar with the roadmap of Ethereum and that have been following along for some time, Ethereum had a dream of execution shards, you know, 64 execution shards, they would be offset by 1 second and you would have 1 second block times because you would be able to jump to the shard that you needed to include your transaction. But the reality of, and that's actually why the consensus layer is a standalone chain only serving one application, which is consensus. And we want to bring this to obviously other restaging applications now.
00:21:51.054 - 00:22:39.664, Speaker B: But the reality of delivering something at scale, but that is decentralized and that's the thing that Ethereum will never compromise on is decentralization. The goal is always to run the network on the the lowest power device possible. But this is working, but it's complex. We cannot expect anything that's requiring the economic security of Ethereum to go through all this, build clients. It's not really feasible and practical, so it needs to be packaged in a different way. And this slide is just emphasizing really the stack that we're talking about. So you have the Ethereum consensus layer.
00:22:39.664 - 00:22:59.920, Speaker B: The proposal registry is sitting on the execution layer. That is your single sign on for all of the applications. And then you have the application layer on top. So that'll be k two. We have PN and Mehfriend and the other applications on top of that. It's really extensible. So let's talk about k two.
00:22:59.920 - 00:24:10.728, Speaker B: Let's talk about the architecture of the protocol. This is giving you an insight into how it's working at a high level. So we have a contract in the center that is using the single sign on proposal registry to be able to offer ETH for restaking with the consent of the node operator that's running that validator and has natively delegated to the k two lending protocol. Outside of that, at the top you have the middleware and reporting side of things. So this is the top part is really the part that the restaking applications need to really think about deploying and running your own middleware. Deploying and running your own middleware is really all about injecting your own slashing logic for your k two is offering slash security. If the network is not running as expected, the income of the native delegators, et cetera, can be slashed.
00:24:10.728 - 00:25:20.234, Speaker B: But every application is different. Every application defines what is a liveness issue and a corruption issue in different ways. And the reporter is going to work for you and many other middlewares to scan your networks and check for any of these liveness and corruption rules that you've injected and ensure that the network's running optimally. Otherwise it will report any issues to the smart contracts and get an ETH payout for doing so. So this gets pretty interesting as we go along, but one thing that is worth making a note of is we want stability in the system. And so if you're running a validator, you can natively delegate obviously your consensus layer balance to the k two protocol, and that can be offered as a slashing security, but with the, and with the ability to exit any time so you can earn whilst you are natively delegated. But if you exit, you have to bear in mind that you cannot come back under the same BLS credentials.
00:25:20.234 - 00:25:52.764, Speaker B: This is no different to the Ethereum consensus layer. If you register a validator, you voluntarily exit. You cannot rejoin the consensus layer with the same BLS credentials. You just need to spin up a new credential. So you need to spin up a new BLS credential. You need to go and do a minimum one ETH deposit in the deposit contract register on the single sign on registry. And these then make the k two protocol quite civil resistant like any good consensus layer.
00:25:52.764 - 00:26:20.404, Speaker B: Sorry. Like any good proof of stake system there is delayed entry and delayed exit. You cannot have because otherwise you have all kinds of attacks and all kind of problems. So that's taken care of here. With k two this is in line with the correct approach. So you are a rest taking application. Let's say you're an oracle and.
00:26:22.584 - 00:26:22.896, Speaker A: You.
00:26:22.920 - 00:26:55.338, Speaker B: Want restakers to run the network. Now you want slash security for that restaking application. With k two you're paying an upfront cost. It's a utilization fee and you need to pay a cost based on some parameters. Now what we do is we use a partition linear interest rate model to calculate what your usage fee is. So the k two protocol is offering slashing security. That's one kind of application.
00:26:55.338 - 00:27:23.000, Speaker B: And so different models would exist for different kinds of applications. This is just the first one. So with every approach there's always a base partition which is the utilization partition. Think of this like you go to Aave. You're borrowing some tokens. Your fee is going to be based on supply and demand. So this is no different here.
00:27:23.000 - 00:27:55.100, Speaker B: So if the. The utilization of the ETH for restaking if the utilization is at 100%, obviously nobody else can borrow any more security but the utilization rate would be at 100%. The parameters, it's just configurable what 100% means in terms of what you're paying. But there is a maximum amount of interest you're going to pay at a utilization level. That's the first partition. Then you have a slashing partition. Now this is more related to your restaking application.
00:27:55.100 - 00:28:54.660, Speaker B: So your restaking application is going to your restaking application you're going to be aware of how much coverage you need in the event of a liveness event. How severe is. You got to think how severe is your liveness events and how severe are your corruption events. If you're offering an oracle, that is a prize feedback for maybe bitcoin, a corruption event on the price of bitcoin could be catastrophic. So your position might state that any deviation of the price x percentage is going to incur some slashing from a corruption perspective. And that is injected at the contract level when you're opening a slashable position, we call it slashable borrow position. So you take out a borrow position and you say per liveness event.
00:28:54.660 - 00:29:38.104, Speaker B: This amount of ETH is required for slashing and per corruption event. This amount of ETH is required. So the slashing partition is computed, the utilization is computed, and you then produce a utilization, sorry, a fee for your ETH security. And it's designed to be scalable scaling as you grow. So if you want to start with $100, that's fine. It's all down to how much slashing security that you require is based on how much you're going to pay. But in the early days of a protocol with smaller number of users, you're not going to need as much security as a bigger protocol.
00:29:38.104 - 00:30:37.062, Speaker B: But that scales, and like I said, there can be further applications that come down the line. We have the slashing application first, but each, you can think of this like concentrated liquidity positions that you're paying for, really. You're paying the ability to use that, you're not paying for the full security, so you can get $100 million security, but you're paying a small usage fee for that. And it's important to emphasize really that we're dealing with network level security. So the Ethereum consensus layer doesn't continues to work and continues to finalize the chain. If one node goes down, if one or two validators are getting slashed, it's not going to affect the operation of the Ethereum consensus layer. And we're rapidly approaching a million active validators at this point.
00:30:37.062 - 00:31:26.000, Speaker B: And that is per epoch, that is a huge number of aggregations, a huge number of nodes securing the network. And in order to corrupt the network, you need to coordinate, and corruption is always correlated together. And this is why in the consensus layer you have a correlation penalty, which is you will get slashed. If you perform any violation of the specification of the protocol, you will get slashed immediately, one ETH, roughly speaking. And then there will be, when you're doing a coordinated attack on the network, there's going to be a correlation penalty later. But you're not relying on any specific node to power your restaking application. That's the key point.
00:31:26.000 - 00:32:03.284, Speaker B: I want to, want to communicate here. It's network level security. So your restaking application, like I said when I was talking through the architectural diagram, your rest taking application is really going to think about the middleware mostly. You're not going to worry about the reporters, you're not going to worry about the smart contracts. That's all going to be abstracted away from you. The reason you want to focus on the middleware, so the middleware is something that a piece of software provided off the shelf that you host. And the reason you want to focus on this is because this is where you're going to inject your logic.
00:32:03.284 - 00:32:56.716, Speaker B: That defines a corruption event and it defines a liveness event. So there are three main components that you need to think about, like I said, the liveness and corruption. But also there is this triage element. So for example, let's say ethereum consensus layer. You have ten validators running and some of them are going offline. Now, when you look at these validators, they're going to incur, the ones that are offline are going to incur an inactivity penalty because they are supposed to be online attesting in the committee that they were allocated to. But the penalty, the inactivity penalty that is being applied to the BLS balance is not constant.
00:32:56.716 - 00:34:02.164, Speaker B: It's not going to drain the account in a second. It's every few minutes there's an inactivity penalty of some small amount, and there is time for the validator to recover, to come back online to recover the balance. What I'm trying to say here is when you have a liveness event or you have a corruption event, it's not something that you're going to. These are events that you need to categorize to specific periods of time, and they need to be reported once rather than over and over again, basically avoiding duplicate reports. So reporters are working to inform restaking applications that there's a problem in the network, but they're not, once that particular event is reported taken care of, we need to move on. So there's a one time, if you're doing slot based tracking, you might only report a liveness event once per slot, once per epoch, something like that. So you need to have that bit in mind, really.
00:34:02.164 - 00:35:07.228, Speaker B: And there's a few approaches to that. So specifically zooming in on the middleware, like I said, the middleware and the reporting software, there'll be off the shelf software that you take on the middleware, you'll host it yourself. But the middleware understands how the K two protocol works, how the contracts work, so that basically reporters can, when they encounter any problem in your restaging application, that they will have their reports verified with a ZK gadget and they'll be able to submit that to the contractor. All that tooling is there, but what you as a restacking application need to do is define what your liveness and your corruption is. It's very specific to your application, very subjective. So the middleware, it needs to be able to interface with your application in a standardized way, so you take care of these liveness and corruption APIs. Now what I've done is I've just illustrated a really dumb example here on the slide.
00:35:07.228 - 00:35:44.768, Speaker B: But your application is going to understand and know what these rules are. But you need to distill this down into a severity score between zero and one. You need to say how severe this liveness and corruption event is. And, and in the identification parts you have the reports ID API. So that API, that is the triage, that's where you are basically assigning a unique identification for the event that a report is taking place. You can have 1000 reporters all spotting a liveness issue at slot number five. But only one's going to report that once to the smart contracts.
00:35:44.768 - 00:36:12.490, Speaker B: So smart contracts are taking care of that. That something is not reported more than once. Like the middleware will verify all thousand reports but ultimately only one report is going to submit that to contract and walk away with that. So on the triage side of things, there are many approaches to take here. You can have an off chain, you can have an off chain approach to generating your events. You can also have an on chain approach. So k two contracts are going to come with support for hooks.
00:36:12.490 - 00:37:14.224, Speaker B: So you will be notified when a slashing event is taking place on your restaking application on chain. And you can use that for many things, including nonce management. So you can basically, for example for a liveness event that's just been reported, you can assign unique noncers that are coming from on chain and you can rate limit, you can say basically, yeah, you can tell me about a liveness event, but tell me about it every 15 minutes because I don't want to just, we need time to fix the issue. So you can use hooks and all kind of other things to approach this. The K two reporter is using ZK Gadget to report these issues and ensure that their report is not tampered with anywhere in the supply chain. So you can subscribe to the head events, look for issues, scrape the middlewares and submit that to the contract and you can build your own reporter as well. So the templating here, we want this to be like an industry standard.
00:37:14.224 - 00:38:11.212, Speaker B: At the moment the industry is very much focused on for getting outside information to the contract. Its oracle, Oracle, Oracle, which is fine, there is use and a need for that. But there are also alternative approaches where you can have people, basically, you basically have people working and watching out, you have observability and monitoring here with a reporter. So it is a different paradigm and these reporters can get paid for the work that they are doing in ethics and what we're trying to do is basically ensure that when we do that, we take care of the data integrity problem, because you need the data coming into the contract to be correct and not tampered with at any point in the supply. We have this ZK solution is audited by ABDK and some other companies. So we have this working and in production. So yeah, we're excited to see how people use this and go forward.
00:38:11.212 - 00:38:52.742, Speaker B: So this is so, yeah, so in terms of native delegation. So you get into k two, but it doesn't mean that you can do whatever you want on consensus layer and not have any consequences on the execution layer. So this is the state syncing that we're talking about. And if you your balance falls below 32, you get kicked from consensus layer, you get kicked from k two as well. So yeah, this is a wild diagram. You can see it on our k two walkthrough. There are many opportunities for helping out the protocol, running a reporter natively delegating.
00:38:52.742 - 00:39:08.234, Speaker B: There are many ways that ETH can flow into those working on the restaking applications. So yeah, that maybe was quite fast, but we're definitely going to record this and share this publicly. So thanks.
