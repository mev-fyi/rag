00:00:00.400 - 00:00:40.054, Speaker A: Well, welcome everyone. Thank you for being here today. I'm going to talk about the buzzword of the day, cause intents and specifically the rise of smart contract orders. So I'm Alex Vinas, I'm the product marketing manager at Causewa and I've broken down the agenda into four topics. First, a little bit of a brief history of cow, then what is the problem with smart contract trading. Then what we thought was the solution and why we think there is a rise of the smart orders. And then what we're proposing as a solution, as a service, which is the error of programmatic cow orders.
00:00:40.054 - 00:01:39.676, Speaker A: But first, let's begin with a bit of brief history of couchop for those who don't know, which hopefully no one, because you should all know cowshop and use cowshop. But to begin, what is cow protocol? Calprotocol is the underlying mechanism that is powering the cushob UI, which again hopefully you're using. Calprotocol also serves different uis that for example balancer or other projects are also routing orders to the calprotocol itself. And calprotocol is similar than an AMM and an aggregator. But instead of treating orders individually, we add basically a thin batching layer on top of them so that we can obtain certain benefits that can be found if you treat orders individually. And basically this is because we leverages batch auction as the price finding mechanism for the protocol. And this allows us to get better prices through cows, which stand for coincidence of ones which are peer to peer swaps.
00:01:39.676 - 00:02:50.860, Speaker A: So instead of having users go to an amm, if the liquidity of the two users completely overlap, then they are matched together in a peer to peer fashion. Then it also allows us to do our own flavor of account abstraction because instead of using the ERC 4437, actually we use a delegating trading model where the solvers are the one executing the transactions on behalf of the users. And this way the user is abstracted from all the complexities of setting up your own transaction or even having to know where the best price is. It also allows us to become the metadex aggregator, which the most common example or the web two example is sort of the skyscanner of crypto because with cowswap the worst price you get of cowswap is the best price you're going to get elsewhere. Because we tap, in order to quote you, we tap into all the mms and aggregators and from there the solvers have to improve the price that is shown to actually win the right to settle the transaction. We also offer mev protection, because when there are cows found in the batch itself, the trade itself becomes a transfer. So there's no possibility to actually attack the settlement itself.
00:02:50.860 - 00:04:14.764, Speaker A: Then in the event that we actually have to go on chain to Amms, we enforce uniform clearing prices, meaning that all the trades trading in the same token pair are going to be clear at the same price, and therefore breaking the order dependency of the settlement, and therefore also breaking the incentive to try to reorder the transactions to extract value from them. And lastly, which is tied to also account destruction, because we use the delegated trading model, the user is able to pay for the gas fees with the cell token that they're using. So they don't even need to have ETH in their wallet. And especially now, because last month we launched gasless approvals, now you can completely, like with an entire fresh account, perform a swap without any ETH on it. Cow, even though it's mainly used from EOAS, was actually thought for three different type of users. The first one was retail, right? Because the whole point of cow sub was that Ethereum and the DeFi ecosystem has gotten so complex that most of the users don't know what they're doing, or don't even know what the correct gas price is, what is the correct base fee, or even where is actually the best liquidity source that I should be tapping into. But with the delegated model where the solvers are the one in charge of executing the transactions, they are the ones that are professional parties and have a lot of experience doing so.
00:04:14.764 - 00:05:07.474, Speaker A: Then the other type of users is smart contracts or smart contract accounts. Because the way smart contracts accounts used to trade in the past, or the de facto standard was that when you went to an aggregator on an AMm, actually the first signer had to commit to a specific execution path. This is a quite horrible idea, because by the time that you actually gather all the other signatures, it most likely means that the path that you actually committed in the first signature is probably outdated. So there is not a possibility to actually get the best price or get the current market price. But with cowswap, the optimal path is found at the moment that the order is placed. So at the moment that the last signature is collected, the first signature is only committing to what is the minimum amount that they are willing to get, but they're not committing to. I want to tap into this specific route.
00:05:07.474 - 00:05:53.740, Speaker A: And lastly, for daos, daos have been sitting in a lot of money, in a lot of cash and treasury, but no one has really unleashed their powers. And this is because trading with smart contracts is quite hard. And the only way around it is basically if you find the treasury management team and then you create a separate core unit to actually handle the treasury. But in essence, this skips the idea of that daos are for governance and everyone should have an opinion on all the swaps. And particularly today, I'm actually going to focus on these two sets of users, the smart contracts and the daos, and see how we can enable the rise of these two users. So what is the problem? Right. If you're a smart contract or if you're a DAO, how do you actually hit the swap bottom? There is not easy way like an EoA to just connect to your wallet and go to the UI.
00:05:53.740 - 00:06:56.986, Speaker A: In the case of the safe, maybe. But if you're just a smart contract that doesn't have a normal UI, right, how do you actually execute the swap? And not only there are execution problems, but there are also technical problems. But what are the execution issues? The first one is MeV. Mev is on the rise. And this is a problem because if you're a smart contract and you're committing to a path, you're actually committing to a minimum amount, meaning that you're revealing your lower bound amount of tokens that you're willing to receive. And in taking into consideration that it's going to take you a bit of time to gather all the signatures that can expose your trade to a lot of MeV, then you have the problem of signing the transaction, right? If you had to commit to a specific path, then by the time that other signers had gone into their UI or had actually performed the signing of the transaction, probably that path is outdated. And lastly, if you have a good way to actually trade, most likely it's just going to be sort of limit order, but you have no on chain guarantees of updating that limit order.
00:06:56.986 - 00:07:32.798, Speaker A: But with Kalswap, we found a solution to actually make these limit orders upgradable based on the current latest prices. And then all these three get actually exaggerated, like way worse if you're a Dao. Because if you're using a governance process, it's going to take you at least three to seven days to get the support of the DAO, or not the support, but if. If you get the support. So that means that those three problems that we saw are even worse. But then you also have technical issues. Cowswap works for eoas and allowed eoas to use intents in the get go.
00:07:32.798 - 00:08:42.053, Speaker A: But this is because eoas have private keys. Therefore it's easy for EOA to actually sign a message saying, hey, I authorize this third party to trade on my behalf. But when it comes to smart contracts, since smart contracts don't have private keys, there is no way for the smart contract itself to create this type of signature, authorizing this third party to execute the trades, which means that then the smart contract has to go the on chain ride to set the parameters of the order, which is kind of cumbersome and then defeats the whole point of the intent based trading mechanism. Because if you have to go on chain, then what's the point of like even having an intent based system, but when there's a problem, there's a will to solve it. And actually we, we think that we found a solution with ERC 1271 orders, which are conditional orders specific for smart contracts. So with ERC 1271, we actually see the rise of smart orders because Ethereum had this idea since the beginning of this dream of becoming the programmable machine. But the programmability that we've actually achieved, it's still quite low compared to what we can actually achieve, because if you think about it, we've only scratched the surface.
00:08:42.053 - 00:09:26.212, Speaker A: You can do some sort of programmability, but it always requires some manual input of someone having to actually even place the transaction, execute the transaction, or hitting a bottom. So this dream of programmability and automating action has not been achieved yet. And I guess the contracts are still not smart. But with ERC 1271, we can actually make the smart contracts smart again because we can allow them to trade via intents. So if you're trading with an EOA, regular orders are basically signed with your private key. And in order to validate, you use this easy recovery mechanism. But in the case of smart contracts, as we said before, because they don't have a private key, you need to actually find a way around it.
00:09:26.212 - 00:10:37.804, Speaker A: And this is via an interactive signature verification, which is valid signature that basically allows the smart contract to have someone else place the trade on their behalf. And at the moment of execution, basically the smart contract can give the approve or the deny to the trade that is being proposed on their behalf. What is also cool is that you can add on chain guarantees to the trade itself as the smart contract to kind of limit what this third party can do on your behalf. You can actually condition the trade that hey, unless this block time is achieved, don't execute this, or unless whatever this oracle price is saying that the price of ETH is, the trade can go through or even like, if you're thinking of a safe or a normal contract that holds a balance, don't trade unless the balance, unless the threshold of the balance has gone above or has gone below whatever parameter you have done. And this allows the smart contracts to trade behind ten, the ERC 1271. So the first case of smart orders that Couchwap deploy was what we call the native ETH flow. Because if you think about it, ETH is not an ERC 20 token, right? So programming the executability of this type of token, it's way harder than an ERC 20 token.
00:10:37.804 - 00:12:01.442, Speaker A: But we had a lot of complaints that people wanted to trade ETH directly because you could do that in other venues. But what people don't actually know is that there is actually a wrapping happening in the backend and they thought that they were trading ETH, but in reality it's just wrapped underneath without them knowing. So with cowswap we use this ERC 1271 contract that basically gathers the ETH from the user and does all the wrapping and the order placement on behalf of the user. Basically, once the user deposits the funds in the intermediary contract, the contract wraps the ETH and places the order on the order book, and then it gets included into a batch, and then from there the solvers compete to settle such order. The second use case was what we call Milkman, which was a product developed with yearn in collaboration with them and via the coggerrance program. And basically what Milkman allows for daos or for any smart contract is that instead of specifying a minimum amount via your slippage, you actually specify an on chain data source from which the prices can be pulled from. And this comes very handy for Daos because if you want to propose a swap for your Dao and actually have it voted, instead of creating the entire transaction and then have it voted, and then seven days later have the trade executed, which is going to be very attacked via Mev because they already know all the details of your transaction.
00:12:01.442 - 00:13:12.114, Speaker A: What you can say is basically, hey, I want to make this swap. I want to sell 10,000 ETH, but I want you to sell it seven days in advance, and I want you to pull the price from this oracle or from this price checker, which can be any liquidity pool. So for example any unib three, and then the bot what we'll do, which is the milkman bottom at the time of execution, will basically check with the Chainlink Oracle and say, hey, this is a smart contract, authorized me to trade this 10,000 ETH within 1% price deviation of what Chainlink says. And once the order is created, it's posted on the cow order book. And then at the time of settlement, the contract asks the DAO itself, like, hey, is this amount the one that you agreed with? And if it's in the case, within the parameters that you specify, right, if those 10,000 ETH are trading within 1% of what Chainlink says, then the order will become executable. But one of the issues we found is that treating single ERC 1271 orders has certain drawbacks. The first one is that there's a high gas fee cost because you need to deploy actually each order, and you need to do a lot of intermediate steps to actually have the order work.
00:13:12.114 - 00:14:03.694, Speaker A: The second one is trust, because it requires for ERC 1271 to work, it requires the, the actual orders to custody the funds. So you first need to transfer this order into the intermediary contracts. And while the contracts can be secured, this is an aspect that a lot of people take, you know, pride and actually care a lot about. So this is a big issue if you don't want to actually put deposit the funds in this intermediate contract, no matter how short the time might be. And the last one is that actually you have to sign each order each time, right? You can't just deploy 100 orders at once. You, you have to individually deploy each order and sign them each time. Meaning that if you're looking to automate some sort of strategy or swap, it becomes quite cumbersome because you need someone behind the computer signing the orders.
00:14:03.694 - 00:15:00.238, Speaker A: But this is where the programmatic order framework comes in to actually automate all these sort of transactions. So what is the programmatic order framework? It's basically a conditional smart order framework that allows a smart contract to autonomously indicate it's intent to trade because it's based on his valid signature. It's the way we found to allow smart contracts to trade via intents. But the cool thing is that you don't have to trade without any. You can actually trade without any trust assumptions, because as we saw before, you can parameterize certain on chain guarantees that only if the conditions that you have parameterized in the contract are met, then this third party is able to place the order on the calprotocol order book. And this is because you actually specify the entire order structure on chain. So what does the programmatic order framework enable? Well, it enables you to automate any order type that you're capable of coding.
00:15:00.238 - 00:15:45.384, Speaker A: Basically, the idea is that you have to only focus on the order logic of the contract and all the rest is provided by the framework. You don't need to know how anything about backend or you don't need to know anything about how the protocol order book interacts. You just simply need to know the logic that you want to deploy. It also allows to execute unlimited smart ordinance in parallel, which for example, if you have a save, this comes quite handy because you don't depend on nonces. Basically, if you now have a transaction stock that, let's say you have nonce 95 but 96, the conditions for executing on chain are met until the nonce 95 is clear. Then the other one isn't going to be executed. But with the smart order framework, it doesn't matter because orders are not dependent on the nonce.
00:15:45.384 - 00:16:47.600, Speaker A: It also allows you to have extreme gas efficiency because you can deploy unconditional orders via a Merkel route. Meaning that for example, if you want to do a yearly salary swap programmatic, you can just deploy a Merkle route with all the twelve different swaps for the month. And this is going to cost you the same as if you deploy that times ten if you deploy 120 orders. And lastly, is that your safe or your smart contract actually is the one that gets to keep the assets at all time? Your assets only leave the wallet at the moment of settlement and at the moment of order execution. So what is the architecture of the programmatic or the framework? So basically, if we can see the mouse, if we have in here the safe or the smart contract, the part in here is that where you're creating the order via the logic or the contract that you have deployed. And then from there you actually have the I missed one arrow, actually. But you have the option to basically upload the mercat three into a decentralized storage network, whichever you want.
00:16:47.600 - 00:18:20.274, Speaker A: But this is not necessary because in the end, the watchtower is the one that's going to be looking at the contract or the network to actually pull or call the contract each time when it's time for executing the order. And then once it's time to execute the order, what the watchtower will basically do will validate that the order is in within the parameters that the contract is specified, will actually validate that the signature qualifies in order to be posted on the order book. And then from there, the Watchtower posts the order on the calprotocol order book on behalf of the contract. And from there is the similar settlement that if you use an EOA, the solvers get pinged to actually settle the order. And then the settlement contract is the one that calls again to double recheck if the smart contract is happy with this order placed on behalf of by the watchtower. And what are the programmatic or the framework use case? Well, the first one, if you are a DAO, for example, and you're trying to do fee or crop recollection, you could actually automate a weekly or a monthly swap for your protocol once the balance of a contract hits a certain threshold. So if right now most of the teams are the ones in charge of actually executing these sort of swaps, but with the programmatic order framework, you could actually just say like we're going to create twelve swaps for the year, or n swaps that the moment that our save holds more than $5,000, automatically swap them into ETH or to whatever token and get them out of the contract to be placed in another contract.
00:18:20.274 - 00:19:15.958, Speaker A: If you're a DAO and you have to do payroll, you could actually also automate all the DAO payroll by creating monthly recurring swaps to pay your contributors. Basically this would be like good after time orders that each month the watchtower would just call your contract and say, hey, it's time to pay. Convert the ETH or whatever token into whatever other token you instructed and from there pay the contributors. And the cool thing about all these cases is that instead of having to create twelve individual orders or any individual orders for each swap, you only create one merkel root with all the conditional orders. Sign at once and then you completely forget about it. It will automatically execute. Another cool thing that is more, I guess more tratfi related is if you do portfolio rebalancing via weight distribution, say that for example, you have a save with five different assets that you want to have 20% of the weight of the portfolio.
00:19:15.958 - 00:20:14.620, Speaker A: So you could actually automate that. Hey, as soon as one of the assets goes below 90% or above 20%, actually create a swap so that the weight distribution stays equal to 20% among all the assets. And the cool thing is that again, you only create the conditional orders at once, sign them only once, and then you don't have to worry anything about it. Similarly to this one, you could also do collateral position manager. And basically the idea behind this is that right now I'm here, but if I have a CDP open and maybe ETH is crashing, I will actually get liquidated. But if I place this collateral position management order, what I can do is, hey, if the risk factor reaches this certain level, actually use this asset, convert them into the collateral that I need to add and add them into the CDP so I don't get liquidated and this way I can enjoy totally being in Istanbul without worrying about my positions. Another use case that you can do that this one is already live today in Couchwap is actually twap or DCA.
00:20:14.620 - 00:21:12.396, Speaker A: So dollar cost average which is based on creating like one big order but divided into n good after time orders. And this the idea is that hey, I want to enter in a position or I want to exit a position and I want to get the weighted average price. And what it does is it divides the big order into the end time parts that you have decided to import in the UI and whenever they become tradable, the watchtower picks it up and then puts the order on the order book. Another cool thing is that you could do a private conditional stop loss. So if you run the watchtower privacy yourself, you can actually don't reveal to the market what the position for your stop loss is. Another one that of course this one is very native to cow is wait for cows. So if you're doing a stable to stable swaps and it doesn't matter for you to wait, then you can actually always get more than one to $1 because cow swap always gives you surplus on your order.
00:21:12.396 - 00:21:43.254, Speaker A: In the case of stable to stable tables, you're always going to get more because you're matched to a counterparty instead of an amm so you don't have to pay the LP fees. So concluding the programmatic order framework allows to basically turn your smart contract into your personal autonomous butler. But most importantly, it allows you to place simultaneous conditional orders at the same time for the numerable use case that you can imagine. So if you're interested in integrating or in building, please reach out and thank you very much for listening.
