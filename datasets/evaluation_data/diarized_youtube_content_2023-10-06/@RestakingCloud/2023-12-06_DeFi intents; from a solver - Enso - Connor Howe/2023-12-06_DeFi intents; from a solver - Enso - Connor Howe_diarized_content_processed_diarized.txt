00:00:01.240 - 00:00:54.568, Speaker A: Cool. So today's topic is the future of defi intent. From a solver bit of background, I'm Connor, one of the co founders of Inso. We're a solver for cowswap, and we offer one unified API to interact with DeFi, ranging from lending, borrowing, vaults, staking, LP's, swapping, and so forth. This also includes state transitions for DeFi actions that cannot be delegated, and we support smart accounts and also eoas. Today's Topics quick overview of intents the different layers of intents I think we should be looking at a lot more different types of intents and what the future of DeFi intents could look like. What are intents for me explicitly declaring I want X outcome and I don't care how to get to that end destination, whether that's on the same chain, whether that's on a different chain.
00:00:54.568 - 00:01:53.988, Speaker A: All of the logic is abstracted for the users themselves, and I truly do not believe that we've even scratched the surface of what intents could and will be. What intents currently are right now is purely token based. I have a token and I want to go to b token. You go to an intent interface like cow one inch Uniswap X, I submit my order, solvers pick this up, and then we basically have our own solutions for winning inside of the auction. This could be arbitrage routing, Dex routing, defi routing using your own flow, and it could be whatever the solver wants to do, as long as they get to the end destination. Once the solver has found their most optimal algorithm for getting to the end destination, they will submit this into the auction and we'll all compete. Whoever has the best scoring, the best gas, and the best amount out this call data will then get simulated on cowswap is that they're actually using our open source simulator that you can use in production.
00:01:53.988 - 00:02:43.144, Speaker A: It's called Tempur Avidao done a similar trade on cowswap a couple of months ago. For DeFi positions on this small part of what intents could be, there's still some benefits on the user experience. If I want to go to a beefy position, I would first need to swap my tokens into Uniswap, go to balancer, get the LP, go to aura, stick my LP, and then finally go to my destination that I already knew where I wanted to get to. With intents, you can abstract this all the way. Now I can do one transaction, one UI, instead of four different uis and eight different transactions. The future of intents I see different intent types. What we've done so far is more token a to token b.
00:02:43.144 - 00:03:23.820, Speaker A: That's the extent of it. I think we can expand this into three different categories. The explicit is still defining conditions. That is, if it drops to 5% on AaVE, then move my position into x protocol. So you're also defining the protocol. Semi explicit is defining some boundaries, but leaving some flexibility of what will be chosen underneath as an end destination. So for example, the difference between semi explicit and explicit here is the protocol has not been defined, but the characteristics of what type of protocol you want to interact with is used within the intent.
00:03:23.820 - 00:04:26.104, Speaker A: Not explicit could be an autonomous agent based upon your prior behavioral and characteristics of your intents, and on chain data that can act upon your behalf. There are many different types of intents that are coming out now. So cow, for example, are still more focused on the tokenized positions where you can do fee collection, managing your portfolio and so forth. And then the other side of intents is also the interface layer, how to surface, what intents are and what language you're using with the user in relation to how they interact with the intent protocol underneath. So different layers. I think a lot of people talk about the execution and not enough people talk about the interface. So how are people going to present to the user for selecting what they would like to do? Is it going to be the uniswap style of dropping down? Is that what we're going to continue to build? Or are we going to build a recommendation engine based upon your prior interactions, text to action, speech to action and so forth? There's many different layers.
00:04:26.104 - 00:05:38.190, Speaker A: One area of metadata, since intents, you're explicitly defining what you would like. At the end, the metadata layer itself needs to become more decentralized. So if a user is basing an intent creation of APY, TVL metrics and so forth, then this will need to be decentralized over time. Because if a user is explicitly saying my position goes down to 5% APY, and somebody can hijack that provider's backend or even that backend's other service, then these autonomous agents of intents are not sustainable and the users are being tricked into creating an intent. One other area that I think we need to, let's say, focus on a little bit more is the industry is the blockchain is not just all about tokens, it's also about state tokenization. You can imagine in the defi context is if I have USDC and I deposit my USDC on three curve, I get an LP pool token I can transfer this to other wallets, other people, and they can redeem this three curve to get the underlying position. State interactions do not tokenize your position.
00:05:38.190 - 00:06:30.650, Speaker A: So if I, for example, borrow on AAVE or I lend on liquite, the state, and the interaction is associated with the address that done that. So the solver networks right now are not able to do these more complex defi interactions. You, in theory could if you gave solvers your private key for your Eos, which I don't think is a good idea. So we need to transition more into smart accounts. These smart accounts would give, let's say solver networks or solvers, certain permissions to be able to interact and protocols on their behalf. And then we can have an off chain validation network that's validating maybe malicious call data that's been passed in, such as approvals, delegate calls, state overrides, and also transfers and deployments of new contracts. This could be done today already.
00:06:30.650 - 00:06:52.934, Speaker A: You can use tenderly, or you can also use our open source simulator. It's built in rust on top of foundry. This is currently being used by cowswap in production. So if anybody is building an intense interface or intense infrastructure, you feel free to just use this. You can spin it up next to a local rest node or your archive node.
00:06:54.954 - 00:06:55.426, Speaker B: Yep.
00:06:55.490 - 00:07:24.194, Speaker A: So we already do state transition. We saw this coming. You can do many different actions. So you would call our API and say, I want to lend, I want to borrow, I want to hedge my position on an ipor, I want to enter 20 pools, and I want to stake these and the gauges and so forth. And this is all possible. This is actually possible through delegate calls. So we currently support biconomy, safe Zerodev and all four TTC seven compatible smart wallets.
00:07:24.194 - 00:07:42.714, Speaker A: The benefit of doing this with delegate calls is all the states stays inside of the original smart wallet. This is already in production project building on top of Enso called ipor. Done exactly this. Thank you so much. If there's any questions, let me know.
00:07:44.294 - 00:07:50.126, Speaker C: What does the Tempus simulator do that just the baseline Reth, can't do temper.
00:07:50.310 - 00:08:10.764, Speaker A: So I mean, you could actually embed it inside of rest as a module. It's more parsing it and giving it to you in a nice format. Of all the state transitions, all of the external calls are being made, the amount out, the amount in. So it's more like a layer on top of rest. You could actually plug this directly inside of rest.
00:08:12.944 - 00:08:15.084, Speaker C: Is it an EVM implementation then?
00:08:15.424 - 00:08:37.632, Speaker A: It's like a. Yes. So it's plugging into rest underneath. And it's for every single EVM chain on top. It's just a layer on top for convenience of pasting in your transactions. So you paste in your call data, you can specify like a block number, even a block number forward as well, just to make your life easier for simulations. Okay.
00:08:37.648 - 00:08:43.004, Speaker C: But it still requires a node behind the scenes for the state access. The EM.
00:08:44.344 - 00:08:51.044, Speaker A: Okay, you need to use Aragon or rest for state overrides. You can't use the other nodes.
00:08:52.344 - 00:09:25.544, Speaker C: Maybe a separate question. So just more theoretically on the intent side, we talked about how the intents could be very explicit, semi explicit, or sort of non explicit. Risk is a big part of using any of like on chain products, right, counterparty risk, volatility risk, like Oracle risk, all these different things. How do you foresee those being managed? When making decisions on behalf of users?
00:09:28.344 - 00:10:15.664, Speaker A: I think the user will set their boundaries to a certain extent and there should not be one source that will validate if a protocol got hacked or there's volatility that needs to be multiple different nodes verifying. That's correct. So yeah, before we can even get to that autonomous part, we need an off chain validation network. It can't be on chain, it needs to be off chain to still give the flexibility. Then I can kind of see modules being plugged into this off chain validation network for state overrides, for approvals, contract deployments similar to fortado for their alerts. But this would be purely for state transitions and also token transfers.
00:10:16.124 - 00:11:24.746, Speaker B: So applications and dapps like gnosis safe, or it's just called safe now, but have spent a lot of time and effort and I've gone through various pain and in trying to give a user experience that makes understanding contract interactions as straightforward as possible. And obviously it is a challenge because it's a moving target. To try and cope with every contract that's being deployed is a real challenge, but they have tried to simplify and so is like ether scan, and when you go to a transaction, you see the transaction actions and you can see boom, tokens are moving here, here, here. So the simulator that you were talking about, obviously that's running on a local get, but my question is really how do we. So I guess you need to get that in a form that's really, really simple for users to understand in order to kind of make an informed decision about that. So how do we do that in the most effective way, really that's going to scale and not have to implement every single contract in the world. Yeah.
00:11:24.770 - 00:11:58.386, Speaker A: Have you seen what Zapper and Ogtav have done recently. So their users now for their own transactions and other users can specify if this is uniswap or if it is a swap or what type of action it is, and then people can vote if that's correct or not. So then we could all share this instead of people creating their own isolated ones. And then you could combine this with ether scan labels, all these other labeling systems from Forta and so forth. But everyone's created all these isolated walls right now, so it'd be nice to combine them all.
00:11:58.530 - 00:11:58.954, Speaker B: For sure.
00:11:58.994 - 00:11:59.226, Speaker A: For sure.
00:11:59.250 - 00:12:00.450, Speaker B: Is that Zappa, did you say?
00:12:00.522 - 00:12:06.018, Speaker A: Yeah, Zapper done that. I think octave done it first, and then Zapper took some inspiration.
00:12:06.186 - 00:12:07.138, Speaker B: Cool, thanks.
00:12:07.306 - 00:12:11.954, Speaker A: There's no more questions. I'll be standing outside. Feel free to come and ask me. Thank you so much.
