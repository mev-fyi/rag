00:00:00.600 - 00:00:57.556, Speaker A: So we are starting intent computer. We're going to discuss about something related to how you can compose transactions by talking to blockchains. But before that, I'm going to give you a little bit highlight about how this is going to work and then let Andrea and Vincent to take over. So if you look at the transactions happen to the blockchain, this is single domain. When we refer the domain in the presentation, it's just related to one single blockchain. A metamask transaction get fired and it goes through not a straight line, it just goes through multiple hoops. And there's a bunch of things that happens before it get final and say you get this kind of transaction in your hand, right? So if that is the thing that you saw in one blockchain, what would be the case of multiple blockchains, right.
00:00:57.556 - 00:02:29.158, Speaker A: How when thousands or hundreds of thousands of users are talking at the same time with the different block times, different validators, different states, different blocks, how this is going to work, multiple protocols, liquidity, all kind of problems we're talking here, right? So it's kind of listening to as many people at the same time and as many languages, right? So if you just look at to the multi chain perspective, let's say someone who want to swap or move a token, the supply chain, very nice way that say that this is the ordering of liquidity positions as water bottles. If there's one bottle bottle has been getting made, there's a once LP positions like, you know, you have traders or specialist actors who doing this kind of liquidity aggregations and things like that, their position will change entirely, right, to satisfy because they will see multiple things there. So like for example, against an average sample, you know, you just want intent when it finish. You see the LP position is completely reverse order, right? The thing it is, there's a lot of things can happen. So 1234 now it's 4321, right? So that's how the intent, like when you say, hey, I want to get a token from Polygon, from Ethereum, but you don't know what to do. So is taking your intent and executing it. There's a lot of things goes in between.
00:02:29.158 - 00:03:07.174, Speaker A: What we're going to talk through is how this is going to get executed in parallel in a unified environment, so you can have multi chain transactions atomically. So this is a little bit of a history. This started like about a year and a half ago. We put together the first implementation in a very naive mvp present in Bogota. And then we put together first mainstream application of a simple token transfer without any liquidity. As a bridges use case in Denver. Now we have a fully generalized EVM capability.
00:03:07.174 - 00:03:51.978, Speaker A: So you can do anything that you can do with EVM. So if you have an additional precompile in avalanche or polygon, if you have an additional pre compile in any other environment, you can have full capabilities, can be combined each other. So any kind of smart contract operations can be combined between the chains and can execute it. So you can launch a protocol multi chain day one, without having liquidities on multiple chains, but you can share it all kind of possibilities here. MEV supply chains will get redefined because, you know, you don't really have any ordering problem because you just only routing the indents between the chains and you're facilitating. It's really getting to a resolver centric, intent centric world.
00:03:52.146 - 00:03:52.854, Speaker B: So.
00:03:55.114 - 00:04:12.034, Speaker A: How this is going to done? We're stuck talking about multi chains. We already stuck transaction will not go through. So what we do, ladies and gentlemen, let's call the guy Andreas. Come in. Thank you.
00:04:12.814 - 00:04:50.134, Speaker C: Okay. Hello everyone. Can you hear me? Is this okay? Okay. Yes. Okay. So yeah, Matt, you gave a little background and this project working with the intents and defining what you will later see what we call the intent kernel that started out as a multi chain ERC 20 transfer contract for doing this, transferring ERC 20 tokens from one blockchain to another. And this evolves slowly because we wanted to actually verify that our implementation was correct.
00:04:50.134 - 00:05:25.004, Speaker C: So it was quite complex, the implementation of it. So we generalized it quite a lot. At this point, I think we started realizing that we were building something that looked like very generalized version of intents. And then we wanted to make this precise. So this is what I want to talk to you about here first, and then I'll go into the gateway kernel afterwards and some stuff you can use the gateway kernel for. Sorry, the intent kernel is called godown. Okay, so first let me, let me start with the basics here.
00:05:25.004 - 00:06:13.274, Speaker C: We can think of the evm as a state machine. So we have the state, for example, a state s, and then a transaction, a we can use to transition from s to state s prime. I think you are familiar with this, where a state transition is a transaction that consists of, for example, you know, a maximum gas amount, some input data, a sender address, block header and so on. So this is all pretty simple, and I think you are mostly aware of this already. So then we have, what we have done here is that we have generalized this to a deterministic intent state machine. So this is a generalization of a deterministic state machine. So instead of transactions, the transitions are called incense.
00:06:13.274 - 00:06:51.574, Speaker C: But the difference between intents and transactions is that intents have a predefined ordering on them. And what I mean by this predefined ordering will become more clear later. But that is a difference that they come with this predefined ordering, which transactions do not have any ordering at all. Incents have an ordering, and the ordering is defining what is, or say that I have to perform an incentive, the incent a. Then the ordering is specifying that we can perform after intent a. It has made a state transition. We can perform this intent b, which is only possible because intent a exists.
00:06:51.574 - 00:07:25.964, Speaker C: So this is what I mean by the ordering. There can be many, many different intents that are possible after intent a. This is just one of the possible scenarios. Or we can perform intent b after intent a. So yeah, so what the ordering is, what we want to achieve with this ordering is that we want to enforce desirable outcomes of the, of the execution of after I have committed an incent. We want to force the ordering of. We want to force that only the valid state transitions, only we can only perform valid state transition that satisfies my intent.
00:07:25.964 - 00:08:14.460, Speaker C: And so this is very, I'm talking about this in a very high level manner here, but it has been made precise. And you can use this QR code, or go to the website here if you want to look at a more rigorous definition of what an intent is and what a deterministic intent statement is. All right, so coming back to this ordering here, so here, I have an example of a, well, perhaps a canonical example with the swap intent. Well, we have, for example, we have two swap intents existing here. One swap intent says that Alice wants to swap 1.1 ETH for 2000 USDC, and Bob wants to swap 2100 USDC for one ETH. So the intent ordering here, let's go back to Alice's intent.
00:08:14.460 - 00:08:58.264, Speaker C: The intent ordering on that is specifying some execution paths or some transitions that can happen afterwards. This is the ordering. So the ordering here of the intent that Alice has committed is given by these arrows that is pointing to other intents that can be performed, that can be performed. And what an example of what this would be is that, for example, if I'm in position of 2000 USDC, I can actually execute Alice's sorbent by giving her 2000 USDC and then receiving 1.1 ETH from Alice. That is one way. So this is the execute swap for Alice.
00:08:58.264 - 00:09:40.654, Speaker C: That is the intent, the orange intent down here that says that is one path of execution. Another path of execution is that if there is a timeout of a Schwabington, that is another way. But this path is only possible if it is only valid if there is a timeout, of course, but it is a path. Additionally, we can also, we can also combine the two intents. So we can combine Bob and Alice's intent. For example, this could be a solver that combines the two, performs the swap of the two, and then obtains a profit afterwards after the swap. So, but the thing here, the key takeaway of this is that there is an ordering.
00:09:40.654 - 00:10:11.074, Speaker C: Each intent has a, once an intent has been committed, there is an ordering of it. It can even be longer the ordering. There could even be intents that execute the other intents. You can have longer chains. It's not necessarily only two layers to this. Okay, so the intent kernel. So I will get into more detail about this in later slides, but essentially the intent kernel is adding this intent state machine capabilities to EVM.
00:10:11.074 - 00:10:40.994, Speaker C: Concretely, what the kernel does is that it's keeping track of all the committed intents. And then it also ensures that when you try to execute an intent, all the predecessor intents are there. So it ensures that the intent ordering is respected. So what did. So this is the intent kernel is very generic. It's used for implementing, we can say, domain specific intents. So you can go and take the intent kernel and implement your own intents using the intent kernel.
00:10:40.994 - 00:11:25.520, Speaker C: And the way you would do this is to, first of all, you would define what intents you want the kernel to support. Afterwards you would define the intent ordering to enforce the ordering of the intents execution. And then you would also define the semantics of the intent. What are the state transitions that are actually being performed when intent is performed? So for example here, this is a multi chain ESG 20 example, and here the Nintendo ordering. I've just given an example here of the Nintendo ordering. What it is, it says it would be, for example, that Alice wants to send 1000 USDC from Ethereum to bob on optimism. There are two ways to execute this.
00:11:25.520 - 00:12:37.534, Speaker C: There's either there's a timeout, in this case Alice will receive her 1000 USDC, or there is also the possibility that Bob can execute her intent and receive the 1000 USDC on optimism. So what you would do here is that you would define this function for. So I have an example down here how it is implemented. The semantics of the send intent, the green intent here in the top. So what it does here concretely is that it will pass the intent to get the, the owner, that will be Alice in our case, and their amount, that will be 1000 USDC in our case. And then it will mark, increase the amount of, the amount of extended tokens, you can say with the amount of tokens that has been transferred, and then the tokens will be transferred to the intent kernel itself. So actually the 1000 USDC are being locked up in the frozen in the cent kernel.
00:12:37.534 - 00:13:25.134, Speaker C: That is what this 1000 USDC will do. On the other side, what would happen when Bob wants to receive 1000 USDC from. Well, if Bob executes the intent from Alice on optimism, then 1000 USDC, well, not quite USDC, Ethereum USDC will be minted for. Alice will be minted for power on optimism. Sorry. Yeah, so on top of the intent kernel, the intent kernel is very, it doesn't handle much, it just handles the, in reality, it just handles the internal ordering that you have defined. So we want to have a higher level abstraction, which is why we have this intent types library we have working on.
00:13:25.134 - 00:14:10.644, Speaker C: And yes. So what we can do with this intent types library is that we can define, we can define intent types using what we call segments. And in the example I have here is that, so you can think of the segments as being the building blocks of intent types. What we have in this example here is that what a swap commit intent type might look like, that we have an array of, sorry, we have an array of segments. And then we also have, yeah, so, and then we have functionalities to obtain. Given a segment index, we can return the segment tower index and we can also ask how many segments are in this intent type. So this is very, very concrete example of what you can do, how you can implement swap intent using the intent types library.
00:14:10.644 - 00:14:49.058, Speaker C: Yeah. And we also, we have a playground available. So if anybody is, is interested in playing around with this, you come and talk to us and we may be able to give you access to try it out. But it's very early still, so it's not production ready at all. Yeah. So this is an example of how maybe a function that will be defined by a solver to actually perform the swap, how that would look like when you have. So this particular example, it supports having two swap intents.
00:14:49.058 - 00:15:22.072, Speaker C: Very simple. There can be two swap intents and we can execute those with this particular function here. So what the solver would do is that he submits a intent to execute two swap intents, and then he provides this function together with it. So the solver can provide any function he wants. This is an example of a function that can be provided, and what it does is it transfers the tokens between the two. It transfers the. It just performs the transfer of the tokens between the two swabbingtons.
00:15:22.072 - 00:15:34.244, Speaker C: And if there is any profit that can be made, then the solver will receive that profit. The receiver will obtain the profit down here. Yep. And I think that was all for me. And that will bring in Vince, I think.
00:15:38.084 - 00:16:32.642, Speaker B: Right, thanks, Andreas. So as a good introduction to how to sort of frame your thinking in how we're defining intent computers and how they are application agnostic and can handle any state, but you can also inject your own business logic. Really, one of the things that we want to ensure with intents is that the users are in control, really. So that means that when you're thinking about intents, depending on your application, you can implement if you need a timeouts and you can implement optional auto execution. So a user may be required to finally sign off on an intent that is executed. You can build any kind of system that already exists out there. You can build rfqs on top of this.
00:16:32.642 - 00:17:31.886, Speaker B: You can build any kind of similar system like that. But it's not one of those systems, it's an infrastructure piece. One thing I want to go into and actually starts with this tweet from Vitalik, if you remember it. So Vitalik talked about how cross chains are a problem and his belief that the future was going to be multi chain, because in a cross chain world, we've got problems where users are going to move money between chains, chains are going to go down, people are going to permanently lose funds that they can't recover. And it just seems like a bit of a mess. We don't have a solution for this, obviously, with bridges and having hacks and similar. We, you know, he was, he was right at the time.
00:17:31.886 - 00:18:23.472, Speaker B: You know, we didn't have a better solution. We didn't have anything that we could use to build, build these, shall we say, you know, asset moving devices until now. So what the kernel does is it, you know, it allows you to use your state in a multi chain context, but with recovery features enabled. So you can actually move assets in a multi chain context with the ability to recover them as well. And the kernel will give you, and the intent computer will give you that feature. So that's something that's worth bearing in mind. One thing we wanted to also talk about was how when you're talking about data, different ecosystems, they're all implementing different evms.
00:18:23.472 - 00:19:36.350, Speaker B: So if you look at arbitrum optimism. They're all running different evms with slight modifications. So it can be what opcodes they support, or how the opcodes behave, or you can have alt layer ones that have a base as geth, and they've made the various changes that they need to support their chain. The original EVM specification was done in the yellow paper, and that's what Ethereum is implementing and obviously has changed throughout the years with all the eips and the hard forks that have taken place. But when we're sort of as users using various applications in a multi chain context, we are having to break the states to go from one chain to another. So we're having to give up states on one chain and create new states on another chain that is completely isolated, separated. And you have fragmentation and associated problems with that.
00:19:36.350 - 00:20:35.478, Speaker B: You have problems with capital efficiency. And the more roll ups that we spin up, the more that we're going to have this problem. And we've got one of the next rooms, we've got a conference on roll ups as a service. More of these are coming, and so it's going to become a headache to manage all this. But we want to change that here with the intent computer, and allow people to use their assets, the value of the assets, in a multi domain context, but without moving the assets, which is key. So the thing about this though is the intent computer doesn't care for any particular consensus algorithm running on a chain or a roll up. It only cares about the security of the underlying chain.
00:20:35.478 - 00:21:31.478, Speaker B: Liveness isn't really an issue because the intended computer doesn't work or build upon chain level state or chain level constructions. So it's not running any lite clients. There's no relaying of block headers or anything like that. So what we have under the hood is what we're calling a credible commitment gadget. So this is, we feel, a really important part to any protocol, and it is in the context of the intents and intense computer. It's the ability to verify that your intent was executed as constructed. So you issue, if we use Andreas as an example, we issue an intent that says, I want to transfer x amount of tokens from one chain to another.
00:21:31.478 - 00:22:38.074, Speaker B: You can obviously check the balances, but in a more complex intent that's, you know, composed of more than just a transfer and complex protocols. You don't know fully whether it was executed as committed. So the your intent is first, before anybody can use your state, and before anybody can do anything with your assets, or more generally any kind of state, you can think of your intent has to be committed into the chain. And we don't have to worry about excessive storage costs because we're using a sparse storage here. So what that means is that with the help of the sparse storage and you combine that with Cancun, we can really put any amount of call data here. And the execution of the intent will verify against your commitment that the outcome was what the user expected. So we like to think of this analogy.
00:22:38.074 - 00:23:18.156, Speaker B: It's like running a website in different devices, but with the credible commitment guarantees. Like I was saying, you can support any state, any ip here. You just have to write what we're calling an ingester module. So we have this construction on the far left and the right is really where you want to look on the ingesters and the dispensers. That's the only thing that you need to worry about to support your protocol. In this example, it's consuming and dispensing ERC 20 assets, but it can consume and dispense ERC 721. Or it can work for specific protocols.
00:23:18.156 - 00:24:05.854, Speaker B: Really you just need to worry about writing those modules and it will be handled in the intent computer, something that you know. So the intent computer will work today with existing tooling. So you will need to worry about block inclusion. You'll need to submit a transaction that is normal to Mempool and it get included in the chain. But we want to move away from this mandatory transaction inclusion in order to execute protocols so that it'll be like 4337, no protocol changes required, and it works out of the box. So there's this video of Steve Ballman sweating on the stage and talking about the need for developers here. We want to.
00:24:05.854 - 00:24:38.950, Speaker B: This is a platform that people build on top of. We're going to share really easy to use tooling, fully compatible foundry, out of the box. All your favorite tooling will simply just work. And no, we don't want to play that. So it'll follow a similar pattern to scaffold ETH. You're just going to clone the repo, check out the branch that you want, and there'll be various examples that you can execute and run yourself. We'll try and make it available via an API and all kind of other packages will be available so you can play with it, really.
00:24:38.950 - 00:24:57.686, Speaker B: And you don't have to worry about the low level details because as you saw with some of Andreas slide, it does get down into the bytes, but we have abstractions and libraries on top so you can interact with your protocols no problem. So yeah, I mean, this is one of the multi chain gateways that you can build. But yeah. Any questions?
00:24:57.790 - 00:25:02.542, Speaker D: What are the trust assumptions of the kernel? Who am I trusting for the validity of the execution?
00:25:02.678 - 00:25:47.064, Speaker B: Well, you can. So what we have done is decoupled the transportation layer from the actual on chain workings. So, so we are going to work with a number of, we're going to have a number of options for people. So if you want to stick a ZK proof on top of the intent kernel in order to communicate in a multi chain context, you'll be able to do that, but it just really depends on your application. So this is siloed application level execution. So your protocol is isolated from other ones. Depending on your application and your trust assumptions and the level of security you require, you just choose the appropriate transportation layer for that.
00:25:49.964 - 00:25:54.660, Speaker D: Do the application deploy on top of this? Can they interact with applications that are not deployed on top of it?
00:25:54.772 - 00:25:59.984, Speaker B: Correct. Yes, that's what the ingestion dispenser modules are. That's just the interface in and out of the kernel.
00:26:01.644 - 00:26:04.784, Speaker D: How do you lock the state of external applications?
00:26:05.664 - 00:26:34.404, Speaker B: Well, you give away write access. So you basically, on any. So you, there are accounts that have, right, access to certain states on the chain. So whether that be a token or any other associated state, you need to mute that write access on domain a in order to move that state and extend the state to another chain and make it available in a replicated fashion on that chain.
00:26:34.744 - 00:26:36.840, Speaker D: So how does that mute?
00:26:37.032 - 00:26:50.404, Speaker C: It's implementation specific. So what I mean by this is that if you want to interact with other protocols, you define how to do that yourself. Well, if it's possible to do it. I don't know. That depends on the protocol, I would say.
00:26:53.184 - 00:27:01.548, Speaker D: Okay, so let's say it's just like a simple ERC 20. Do they need to then transfer the tokens into some contract that blocks the state?
00:27:01.636 - 00:27:01.836, Speaker B: Yeah.
00:27:01.860 - 00:27:28.664, Speaker C: So for ESC 20 transfer, the example is that if I want to commit intent to transfer from ethereum to optimism, then I would need to. So what happens is that I would need to give allowance. So that is our example. Implementation of this is that I give allowance to the kernel to spend my tokens that I want to transfer, and then the kernel will actually take the tokens and transfer them to itself. So it will mute the tokens, right, right.
00:27:28.704 - 00:27:33.168, Speaker D: So it actually takes custody over the tokens and escrows it until it gets either timed out or unlocked.
00:27:33.216 - 00:27:39.792, Speaker C: Okay, yeah, exactly. Yeah. But it's an implementation detail. There are probably other ways to implement it as well. We don't say that. It's just one way to implement this stuff.
00:27:39.888 - 00:27:40.644, Speaker D: I understand.
00:27:41.384 - 00:27:41.984, Speaker C: Hi.
00:27:42.104 - 00:27:52.964, Speaker B: Does the credible commitment gadget merely determine if an intent is satisfied in a boolean sense, or does it also, like, determine the degree of satisfaction? And if not, how do you choose between competing solutions?
00:27:55.704 - 00:28:39.792, Speaker C: About. So let me start with the last thing first. The competing solutions, that is, that is, again, that is a problem for the solvers, which is not related to the kernel itself. So the solver would need to choose what solutions they want to interact with. And the first question was that was related to how we ensure. Well, whether it's just a boolean flag, whether it's satisfied or not, the intent. Well, sort of, yeah, because it's defined partially by the existing state of the existing state on the blockchain.
00:28:39.792 - 00:28:59.004, Speaker C: But then also if the intent is committed, there are certain paths that can be, that can execute it. And if the state is correct on the blockchain, then the intent is satisfied. But there's nothing. It's implementation specific whether it's satisfied or not. The intent. And also. Yeah, so that's implementation specific again.
00:28:59.004 - 00:29:14.892, Speaker C: Yeah. So it's certainly possible to implement a buggy swap that allows somebody to steal tokens. That's possible. So we don't have those kinds of guarantees in the kernel itself. We have those for the particular domain specific intents they need to ensure that they are bug free.
00:29:15.068 - 00:29:15.784, Speaker B: Thanks.
00:29:16.244 - 00:29:26.904, Speaker E: In the case of an ERC 20 transfer, for example, what form does the token take on the destination chain? Is it your protocols wrapped version? Or do you use the canonical bridge.
00:29:28.164 - 00:30:00.394, Speaker C: Right on the other side? The token will be a just a new. We can just have a new ERC 20 contract on optimism that mints tokens. We can call this an ethereum. If there's USDC, for example, we can call this an ethereum USDC on optimism, which means just if I transfer 1000 USDC to optimism, it will mint 1000 USDC on optimism there. And the value of this is backed by the fact that we can go the other direction. It will burn the tokens and then it will transfer the tokens back to me on the other side.
00:30:01.094 - 00:30:07.870, Speaker E: And then the idea is like, the value of that token on the destination chain would more or less be pegged because of that ability to withdraw.
00:30:07.902 - 00:30:08.214, Speaker C: Exactly.
00:30:08.254 - 00:30:09.542, Speaker E: Yeah. Cool.
00:30:09.718 - 00:30:51.954, Speaker B: I just want to talk about the difference between peg and redemption. Pegs normally associated with a synthetic asset. But if you can redeem a token, you don't worry about a peg, because at any time you can burn the token on the destination chain and go back to the origin and claim the underlying asset there. And we're not deploying any of these kernels. It's application specific. So circle can deploy. There can be thousands of gateways, so circle can deploy their own intent kernel and they can allow users to go from ethereum to optimism.
00:30:51.954 - 00:31:17.686, Speaker B: You have, think of it like an LP token. It's more like an LP token. It's not any kind of new asset. Um, it's not any kind of. And so by burning a token on the destination chain, you can redeem the underlying token on Ethereum. Uh, which means that it's not a custody because, um, it's, it's more of an LP management. You, if you burn on one side, you redeem on the other side.
00:31:17.686 - 00:31:20.514, Speaker B: So we don't have to worry about pegs here. There's no peg.
00:31:22.174 - 00:31:45.264, Speaker A: Also the, the gate, whenever you free the mute, the state, you're not giving the tokens to anyone. It's actually muting yourself and you can revoke it. The freezing the tokens, you could also give to another party to minutes, that's another consent that you have to inject it. So it's not a concept of escrow.
