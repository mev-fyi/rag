00:00:00.960 - 00:00:18.634, Speaker A: Today I'm going to be talking about developing and testing at the protocol layer of Ethereum. I'm Derek from kurtosis and yeah, let's just get started. So I think it's quite obvious this is not a hot take at all. Building the Ethereum ecosystem and the protocol is difficult.
00:00:19.494 - 00:00:20.582, Speaker B: We saw a lot of great talks.
00:00:20.598 - 00:00:23.982, Speaker A: Today from various teams, projects and individuals.
00:00:24.038 - 00:00:26.202, Speaker B: Actually all throughout the week about all.
00:00:26.218 - 00:00:37.374, Speaker A: The innovations and technologies that people are investing in. But we at Kurtosis believe it shouldn't be this hard. Please appreciate and clap for this high effort meme.
00:00:40.394 - 00:00:40.706, Speaker B: Cool.
00:00:40.730 - 00:00:42.034, Speaker A: So I'm actually going to start high level.
00:00:42.114 - 00:00:43.334, Speaker B: What is kurtosis?
00:00:43.914 - 00:00:51.934, Speaker A: So our team is building a developer tool that makes it far easier to build and instantiate your system for development and testing.
00:00:53.014 - 00:00:55.822, Speaker B: Developers use things called kurtosis packages to.
00:00:55.838 - 00:01:50.014, Speaker A: Define their environment and spin it up where they need it, when they need it, at the scales they need as well. And very relevant for this group is the use case of spinning up private devnets and testnets for testing of infrastructure beyond the execution layer. So this is things that are below or outside of the applications of dapps and smart contracts. One such package is the Ethereum package. This is a customizable private Ethereum devnet in a box that can be deployed using one line. And a few examples of some of the use cases that people can use this for are testing middleware like oracles, relayers, MEV infrastructure, DVT sequencers, reporters, and literally anything that can be shipped as a container. And I do want to call out that packages can be written by anyone for any type of system as they're all open source.
00:01:50.014 - 00:02:23.484, Speaker A: And before I jump into the demo, I just want to call out some teams that are building and using the Ethereum package. We have client teams building reth for paradigm Nethermind, building their execution layer client, the Ethereum foundation, using this for testing in the past the merge and now EIP 4844. And we have some security firms as well. And so with that, let me just do a demo. I promise this will be quick so everyone can see this terminal. I'm literally just going to write one line, kurtosis run. I'm going to point to GitHub.
00:02:25.864 - 00:02:26.520, Speaker B: Kurtosis.
00:02:26.552 - 00:02:34.992, Speaker A: Run, GitHub.com comma kurtosis tech ethereum package. And this is also completely public as well, so people can take a look.
00:02:35.008 - 00:02:35.916, Speaker B: What that looks like.
00:02:36.040 - 00:02:59.064, Speaker A: So as I press enter, what's happening is that kurtosis is taking those environment definitions and spinning up an enclave. It's called spooky rainforest. This enclave is like an isolated box on my machine over docker that will then contain my private testnet. And while that's spinning up, I'm going to open Docker to prove to you that things are actually spinning up. Let me go.
00:03:00.164 - 00:03:01.964, Speaker B: Cool. Sweet. So we see all of these prior.
00:03:02.004 - 00:03:32.634, Speaker A: Images and we're just going to do this. Give it a second here. Perhaps this hotel wifi is letting me down, but I'll give it 1 minute. Awesome. So now it's printing out and telling us exactly what's happening. It's generating genesis data, generating my validator keys, instantiating the El and the CL client pair, bootstrapping the network together and then attaching observability tools alongside of it.
00:03:43.214 - 00:03:43.998, Speaker B: Perfect.
00:03:44.166 - 00:04:18.704, Speaker A: So at the end kurtosis will print out what my private devnet looks like. We see all these files relevant for a network, as well as all these services that are running in containers over Docker on my machine. You'll notice that they're mapped to local ports on my laptop that I can click on. I'll highlight a few of these services just like the consensus layer client, the validator, and the execution layer client. Down here we use the Geth and lighthouse pair. For this example. I can go on and click on this light beacon chain explorer called Dora to prove to you that this is a real network.
00:04:18.704 - 00:04:27.016, Speaker A: Genesis is set to happen in approximately 1 minute, but when that does happen, folks can click on the epochs, the.
00:04:27.040 - 00:04:28.552, Speaker B: Blocks, the slots, as well as the.
00:04:28.568 - 00:04:40.576, Speaker A: Validators that are in this private proof of stake Ethereum devnet. I'm going to jump back to this at the end of the slides. So what was happening is that the Ethereum package actually bundles up a bunch.
00:04:40.600 - 00:04:44.552, Speaker B: Of essentially scripts that generate genesis data.
00:04:44.648 - 00:06:00.496, Speaker A: That generates validator keys, bootstraps the El and CL client together, adds on transaction spammers, Grafana and Prometheus, and a beacon chain explorer that we saw. We pass that into the kurtosis engine and what you get out the other end is a test environment over Docker or kubernetes, and very relevant to today's presentations. This package is completely composable, meaning you can add your validator middleware prototypes for eips like the last presentation, knowledge compressors and load balancers for RPC endpoints. And just to really wrap it up, developers can use kurtosis to build environments that represent a full real life network to simulate and test changes between validators and restaking middleware. The intent here is to help developers spend less time on infrastructure and more time building to unlock with the full potential of restaking awesome and I'm just going to recap before I jump back to the demo. Today we learned about kertosis, the Ethereum package, which is a private devnet in a box, and you are now all inspired to use kurtosis to develop restaking innovations for Ethereum. You can grab your phone and scan this QR code to start the repo.
00:06:00.496 - 00:06:04.014, Speaker A: It's completely open and community owned and maintained.
00:06:04.184 - 00:06:05.618, Speaker B: We also have a discord for help.
00:06:05.706 - 00:06:09.074, Speaker A: And if you're curious to learn how other folks are using kurtosis, we have.
00:06:09.114 - 00:06:12.842, Speaker B: Linked a YouTube video for how the.
00:06:12.858 - 00:06:29.582, Speaker A: Ethereum foundation is using kurtosis to test tenkun, which is hopefully Q 120 24. Awesome. And I'm actually going to go back to this explorer to see if Genesis happened already.
00:06:29.738 - 00:06:31.074, Speaker B: Let's check it out.
00:06:33.734 - 00:06:39.398, Speaker A: Awesome. Looks like it did. So we see the consensus layer has already proposed blocks.
00:06:39.566 - 00:06:40.474, Speaker B: We have.
00:06:42.654 - 00:07:08.904, Speaker A: These blocks, attestations, et cetera, et cetera, block hash, all this stuff. What I'm trying to prove to you is that this is a real working proof of stake Ethereum devnet on my machine, and I chose to spin up lighthouse and geth. But I can pick any and all the client pairs, we support all of them and at any scale you need. So this works on kubernetes as well? Yeah, that's pretty much it. I welcome any and all questions.
00:07:10.244 - 00:07:33.464, Speaker C: How straightforward is it to incorporate other packages in the script? Do you have a baseline? Right, so you have a baseline script that you showed in your slide will deploy the chain, the block explorer. How easy is it to extend it to add additional software? Like, let's say I want to run a boost or a similar software to that.
00:07:34.244 - 00:07:35.460, Speaker B: Okay, right, cool.
00:07:35.572 - 00:07:37.036, Speaker A: So you're talking about this slide, correct?
00:07:37.140 - 00:07:37.612, Speaker C: Yeah.
00:07:37.708 - 00:08:08.124, Speaker A: Awesome. Okay, I will show you exactly how to do that. And it's great that you mentioned Mevboost, because we also include that in the packages right now. So this is main star file, which is kind of the parent script that if you could consider it like that. And you can see here that, for example, on line 17, we have just a line importing a script called the Blobspammer star. And this is instantiating a blob spammer. To test blobs for EIP 444.
00:08:10.104 - 00:08:10.392, Speaker B: We.
00:08:10.408 - 00:08:24.804, Speaker A: Have MeV flood, which floods the network with MeV rich transactions, as well as Mevboost, which allows you to simulate the entire MeV infrastructure with a builder, a relayer nav boost.
00:08:31.864 - 00:08:34.764, Speaker D: In Dangoon, three blobs right at a time.
00:08:36.224 - 00:08:39.696, Speaker A: So you're asking about the overlap between the blob spammer and Mev flood.
00:08:39.760 - 00:08:40.120, Speaker D: Yeah.
00:08:40.192 - 00:08:40.728, Speaker B: Cool.
00:08:40.856 - 00:09:20.744, Speaker A: So, I'm happy to answer this offline, because it's actually quite complicated, but, yes, I'll come find you afterwards. Thanks. Yes, but Vincent, to answer your question, this is written in starlark, which is pythonic DSL. You just describe how your container gets configured and how it should be instantiated with the dependencies that you need, and you can just import it in. And I'll show you one last thing, just very relevant to your question. This is a full list of all of the services that you can enable and disable at your leisure, completely configurable. So what I showed was just one node with no MeV infrastructure, but you can flip that switch using a Yaml file.
00:09:23.404 - 00:09:26.380, Speaker D: All right, you have a MeV custom flow. What does that do?
00:09:26.452 - 00:09:28.052, Speaker A: Yes, this gentleman right in front of.
00:09:28.068 - 00:09:28.932, Speaker B: You, he wrote it.
00:09:29.028 - 00:09:30.464, Speaker A: He should be able to tell you.
00:09:33.804 - 00:09:45.014, Speaker E: So, it's a very simple python script that takes in two addresses and floods the second address with some coins from the first address, and the second address is the Coinbase address, so it always goes up.
00:09:48.634 - 00:09:54.674, Speaker A: Awesome. I think we're already over time, so please come find me if you have more questions, and I'll leave it for the next speaker. Thank you so much, guys.
