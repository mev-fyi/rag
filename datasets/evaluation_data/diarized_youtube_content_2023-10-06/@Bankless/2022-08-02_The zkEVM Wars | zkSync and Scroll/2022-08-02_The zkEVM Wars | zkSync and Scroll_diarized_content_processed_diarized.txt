00:00:09.790 - 00:00:32.314, Speaker A: Hey, bankless nation. Welcome to another live edition of State of the Nation. Today we're going to talk about the zero knowledge EVM, the ZK EVM. David, guide us through this is going to be formatted a little bit differently in that after the intro, I am actually stepping out. So who do we have on the show? How are we formatting this, and who is helping us out today?
00:00:32.392 - 00:01:08.654, Speaker B: Oh, we got my good friend Ben Jones from optimism. And Ben is going to be our technical co moderator here to help us unpack the ZKe EvM. Ryan, you and I, I think we're pretty smart, but there's way smarter people in this industry, and there's way more technical things in this industry that we just kind of need some help unpacking. And so we're bringing in some extra help from the optimistic roll up world to help us unpack the ZK side of things. So, coming in, in the second half of the show, once we get there, we'll have Alex from ZkSync and ye from scroll, and Ben is going to help us, guide us through this conversation.
00:01:08.702 - 00:01:12.558, Speaker C: To understand a little bit more about the world of the ZKVM.
00:01:12.734 - 00:01:39.422, Speaker A: It's a world that's heating up. I think the title of this episode is the ZK EvM wars. And I think, you know, appropriately was like, three weeks ago. All three ZK EVMs announced something big the exact same week. So the ZK wars are heating up. David also, got to tell them a little bit about our friends at Forda. And I think this is really important that we talk about tools like Forda right now, because since.
00:01:39.422 - 00:02:07.286, Speaker A: Did you know, since 2021, 138 web3 projects have been hacked, and that's cost victims a total of $2.3 billion. And of course, yesterday, David, we just saw the latest bridge hack, $190,000,000 out of the Nomad bridge. And so we reset the clock. Now, it's been zero days since the last incident. Tell us a little bit about how Forda is trying to fix this.
00:02:07.388 - 00:02:43.198, Speaker B: Yeah, we can all do our best with smart contract audits and formal verification and blah, blah, blah, blah, blah, and everyone should be doing that. But you can also do an additional layer of protection, which is real time mem pool monitoring. And so the way I like to explain this is there's that game in the 90s where asteroids were coming in, and you would shoot the asteroids before they hit the earth. This is like that, but for smart contract exploits. So you zap the malicious transactions before they actually execute. And this is what Forda provides for the world real time monitoring of your DeFi app, your NFT project, your dao, your treasury. Anything that's at risk, that's in the world of Ethereum.
00:02:43.198 - 00:02:47.230, Speaker B: This is a missile defense system for your smart contract.
00:02:47.390 - 00:03:04.434, Speaker A: That's a cool analogy, David, look who they're protecting here. $36 billion compound balancer, liquidity, instap maker Lido. All of these folks use Forda. So if you want to learn more, go check it out. The Forda network@forda.org. There's a link in the show notes. Bankless cc Forda.
00:03:04.562 - 00:03:06.438, Speaker C: All right, I'm going to ask you.
00:03:06.444 - 00:03:09.042, Speaker A: The question I ask before every state of the nation.
00:03:09.106 - 00:03:24.906, Speaker B: Wait, before we get there, Ryan, I want to talk about a little bit about just some intro stuff, because we got Ben here, and so there's going to be a bunch of questions that I think we don't actually necessarily have to ask every single participant here in this dream. So we're going to get some beginner.
00:03:24.938 - 00:03:26.986, Speaker C: Questions out of the way, and Ben's.
00:03:27.018 - 00:03:29.422, Speaker B: Going to help us with that here. So, Ben, I want to start with.
00:03:29.476 - 00:03:31.986, Speaker C: This very first question, which is, what.
00:03:32.008 - 00:03:36.926, Speaker B: Is the EVM, and why is it important? And then we'll get to what does it mean to zero knowledge?
00:03:37.038 - 00:03:37.806, Speaker C: EVM.
00:03:37.918 - 00:03:40.910, Speaker D: Oh, good question, and thanks for having me on, y'all.
00:03:41.070 - 00:03:43.090, Speaker C: Okay, what is the EVM?
00:03:47.530 - 00:04:05.370, Speaker D: What the heck does that mean? Okay, basically, it is a way to interpret Ethereum programs or Ethereum smart contracts. So basically, a virtual machine is this notion that you map a bunch of, basically, numbers, right? Everything in a computer is expressed as a number, and you map certain numbers to certain instructions.
00:04:05.870 - 00:04:09.214, Speaker C: Instruction like add or like divide or.
00:04:09.252 - 00:04:12.670, Speaker D: Like call when you want to go and call. Another smart contract.
00:04:13.170 - 00:04:18.446, Speaker C: This is the basis for how you construct smart contracts on Ethereum Virtual world.
00:04:18.628 - 00:04:21.438, Speaker D: Write some solidity code. What happens behind the scenes is that's.
00:04:21.454 - 00:04:24.066, Speaker C: Taken from text, goes through something called.
00:04:24.088 - 00:04:25.838, Speaker D: The compiler, that turns into a bunch.
00:04:25.854 - 00:04:32.840, Speaker C: Of numbers, which is all the instructions that implement the program that you write. That's the EVM. Very important.
00:04:34.090 - 00:04:35.302, Speaker B: I would say, crucially important.
00:04:35.356 - 00:04:37.090, Speaker D: It is one of the things that makes Ethereum.
00:04:37.170 - 00:04:38.694, Speaker C: Ethereum, okay?
00:04:38.732 - 00:04:45.366, Speaker B: And so we have that. That's what the Ethereum layer one is. What does it mean to have a Zke EVM?
00:04:45.478 - 00:04:47.930, Speaker C: Why are so many people hyped on a Zke?
00:04:48.830 - 00:04:54.746, Speaker D: Yes. So I think they're hyped for scalability. It's very interesting because Zke. EVM, right. What is the ZK there?
00:04:54.768 - 00:04:56.538, Speaker C: It's zero knowledge, right.
00:04:56.624 - 00:05:00.570, Speaker D: And interestingly, it does use these things called zero knowledge proofs.
00:05:00.650 - 00:05:03.422, Speaker C: Arguably, ZK isn't the most important part.
00:05:03.476 - 00:05:06.682, Speaker D: Of the zero knowledge proof, right? So when you think of ZK, snark.
00:05:06.746 - 00:05:09.686, Speaker C: Right, might be this zero knowledge succinct.
00:05:09.738 - 00:05:11.614, Speaker D: Non interactive argument of knowledge.
00:05:11.742 - 00:05:16.674, Speaker C: A really key letter in that acronym is the s is the succinct, because.
00:05:16.712 - 00:05:18.226, Speaker D: The point of these proofs is that.
00:05:18.248 - 00:05:21.390, Speaker C: You can basically prove something in a very short manner.
00:05:21.550 - 00:05:28.534, Speaker D: So a ZKe EVM is about taking the EVM and converting it or running it inside a zero knowledge environment that.
00:05:28.572 - 00:05:31.014, Speaker C: Lets you prove things succinctly. So what does that mean?
00:05:31.052 - 00:05:37.002, Speaker D: Basically, it means you can take the EVM and you can write a proof that says the result of these ten.
00:05:37.056 - 00:05:48.394, Speaker C: Transactions is state x. State y, right. You prove the results of the Ethereum virtual machine. But what's interesting about this is you could make that not ten transactions, but.
00:05:48.432 - 00:05:50.746, Speaker D: 100 or 1000, and still the proof.
00:05:50.778 - 00:05:51.806, Speaker C: Size stays the same.
00:05:51.908 - 00:05:52.878, Speaker D: So you can see why this might.
00:05:52.884 - 00:05:54.110, Speaker C: Be a very compelling.
00:05:55.650 - 00:06:27.740, Speaker A: Can I just bake this down into kind of layman's language here? So the EVM thing, that's the thing that turns Ethereum from a calculator into a computer. And the EVM thing is the thing that bitcoin does not have. And the reason it functions more like a calculator, you can't run programs on top of it, right. And then the ZK part makes the EVM thing, the computer part of Ethereum, much more scalable because it compresses it into this very tiny size.
00:06:28.430 - 00:06:29.626, Speaker C: Yeah, I think that's a good way.
00:06:29.648 - 00:06:38.666, Speaker D: Of thinking about it. There's a little more nuance in terms of like, for example, if you're posting ten transactions versus 1000 transactions, and you're still rolling those up, right?
00:06:38.688 - 00:06:40.654, Speaker C: If we're talking about a roll up.
00:06:40.692 - 00:06:44.782, Speaker D: Right, then there's still some costs there that fundamentally can't be compressed in quite the same way.
00:06:44.836 - 00:06:52.866, Speaker C: You compress quite a bit, but it doesn't disappear. There's more nuance. But that's absolutely the. What would you say?
00:06:52.968 - 00:06:55.566, Speaker B: Why are people so stoked on a Zke EVM?
00:06:55.678 - 00:07:02.562, Speaker C: Why is this such an important thing to fight over? And why are there so many teams like racing to mainnet? Right?
00:07:02.616 - 00:07:08.486, Speaker D: Yeah, I mean, so there's a few reasons. The core of it, though, is that the EVM is what powers Ethereum, and.
00:07:08.508 - 00:07:10.018, Speaker C: It'S what has all the network.
00:07:10.194 - 00:07:15.942, Speaker D: So I'm a co founder of optimism, which is optimistic roll up protocol. We spent a lot of time making.
00:07:15.996 - 00:07:19.146, Speaker C: The optimistic roll ups work with the EVM. Why did we do that?
00:07:19.168 - 00:07:20.886, Speaker D: It's because that's where all the applications.
00:07:20.918 - 00:07:22.874, Speaker C: And all the developers live, right?
00:07:22.992 - 00:07:27.614, Speaker D: So to build a good scaling solution, we want to do that. And it's definitely been a limitation of.
00:07:27.652 - 00:07:31.920, Speaker C: ZK scaling solutions so far that they can't go ahead and take advantage of this.
00:07:32.690 - 00:07:34.346, Speaker D: I think people are excited because there's.
00:07:34.378 - 00:07:49.860, Speaker C: Potential with a ZKVM build on that network. One last question before we get to panelists that are Ben, what are you hoping to get out of this conversation? What should listeners pay attention to listening to this? What are you also hoping learn?
00:07:50.390 - 00:07:51.380, Speaker D: Good question.
00:07:53.270 - 00:07:55.334, Speaker C: It depends on who the listener is, right.
00:07:55.372 - 00:07:56.694, Speaker D: I think that one of the things.
00:07:56.812 - 00:07:59.698, Speaker C: Obvious listeners would be like a user.
00:07:59.714 - 00:08:03.974, Speaker D: Of these protocols, right? So I think you want to listen to what are the security properties like.
00:08:04.012 - 00:08:08.634, Speaker C: That you're interacting with? What is the roadmap of this thing that interacting with?
00:08:08.832 - 00:08:11.354, Speaker D: I think if you're a developer, then really what you want to be thinking.
00:08:11.392 - 00:08:14.780, Speaker C: About is what does it actually mean? Practice my application.
00:08:17.470 - 00:08:19.786, Speaker D: There's different ways that you can go about implementing.
00:08:19.818 - 00:08:24.878, Speaker C: There's different levels of support for different and aspects of that you'll have access to.
00:08:25.044 - 00:08:35.474, Speaker D: And so I think that's two bits of framing as for what I want personally. Oh man, everything under the sun, really, I feel like. But including those questions, I'm secretly most.
00:08:35.512 - 00:08:40.050, Speaker C: Excited to hear how we can create it into. That's a whole nother conversation.
00:08:40.710 - 00:09:22.260, Speaker A: Can you guys also go over? So I'm going to be grabbing the popcorn here and just watching as a bystander, but just throwing my one question in is, can you guys talk a little bit about bridges? I know that's not typically exclusive to ZK, but it's kind of like a roll up type technology. And I think a lot of people listening are probably increasingly concerned about the security of bridges from one chain to another or from the main net to roll up from main net to an Alt L one. So I'd love to hear a bit more about that. And guys, we are going to get right to the episode. We're talking all about ZK evms, but before we do, we want to thank the sponsors that made this episode possible.
00:09:23.030 - 00:10:04.474, Speaker E: Rocket pool is your decentralized Ethereum staking protocol. You can stake your eth in rocket pool and get our eth in return, allowing you to stake your eth and use it in DFI at the same time. You can get 4% on your eth by staking it with rocket pool, but you can get even more by running a node rocket pool is the only staking provider that allows anyone to permissionlessly join their network of validating Ethereum nodes. Setting up your rocket pool node is easier than running a node solo, and you only need 16 ETH to get started. You get an extra 15% staking commission on the pooled eth that uses your node to stake. You also get RPL token rewards on top. So if you're bullish ETH staking, you can boost your yield by adding your node to the decentralized rocket pool network, which currently has over 1000 independent node operators.
00:10:04.474 - 00:10:11.966, Speaker E: It's yield farming, but with Ethereum nodes you can get started@rocketpool.net and you can also join the rocket pool community in their discord. You can find me hanging out there.
00:10:11.988 - 00:10:13.570, Speaker B: Sometimes in the chat, so I'll see you there.
00:10:13.640 - 00:10:54.346, Speaker E: Arbitrum is an ethereum layer two scaling solution that is going to completely change how we use DFI and nfts. Some of the coolest new NFT collections have chosen arbitrum as their home, while DFI protocols continue to see increased liquidity and usage. You can now bridge straight into arbitram from more than ten different exchanges, including finance, FTX, Huobi and crypto.com. Once on Arbitrum, you'll enjoy fast transactions with cheap fees, allowing you to explore new frontiers of the crypto universe. New to Arbitrum for a limited time, you can get arbitrum nfts, designed by the famous artists Ratwell and Sugoy for joining the Arbitrum Odyssey. The Odyssey is an eight week long event where you complete on chain activities and receive a free NFT as a reward. Find out more by visiting the discord at Discord GG Arbitrum.
00:10:54.346 - 00:11:50.358, Speaker E: You can also bridge your assets to arbitrum at Bridge Arbitrum IO and access all of Arbitrum's apps at Portal Arbitrum one in order to experience defi and NFTs the way it was always meant to be, fast, cheap, secure, and fiction free. Makerdao is the OG Defi protocol, the first defi protocol to ever exist, even before we called it Defi, Makerdao produces Dai, the industry's most battle tested and resilient stablecoin using Maker. You don't need to sell your collateral if you need liquidity. Instead, you can spin up a maker vault and use your collateral to mint dai directly. With Maker, the power to mint new money is in your hands, and there's something new in the Makerdao ecosystem. Every time a new makerdao is opened, the owner can claim a pOAP which contributes funds to one tree planted, an organization with ongoing global reforestation efforts, creating a world where digital participation and the health of our environment can live side by side. Soon, Maker will be present on all chains and layer twos, bringing the biggest and best DFI credit facility to everywhere there is DFI.
00:11:50.358 - 00:11:55.250, Speaker E: So follow Maker on Twitter at makerdao and learn from the oldest and most resilient Dao in existence.
00:11:56.550 - 00:12:06.994, Speaker B: And we are back. I believe we fixed the audio issues, so chat. Make sure. Let me know if we have not. In the top right corner, we're talking to Alex Glokowski from the ZK sync protocol.
00:12:07.042 - 00:12:11.922, Speaker C: Alex, welcome to the show. Cheers.
00:12:11.986 - 00:12:15.342, Speaker B: And then in the bottom half, in the middle, we got yay from scroll.
00:12:15.426 - 00:12:21.018, Speaker C: Yay. Welcome to the show. So beautiful.
00:12:21.104 - 00:12:29.418, Speaker B: Before we get into some of the technical details of the project, I just want to kind of go through the context or the background, the genesis of each of your respective teams.
00:12:29.514 - 00:12:30.686, Speaker F: Alex, could you kind of just walk.
00:12:30.708 - 00:12:32.426, Speaker B: Us through the history of ZK sync?
00:12:32.458 - 00:12:33.680, Speaker C: Where did it come from?
00:12:52.820 - 00:12:55.196, Speaker G: Bitcoin, ethereum, and all the schools.
00:12:55.228 - 00:13:08.150, Speaker B: Hang on. Okay, I know this is not audio issues. I just had you guys muted. So we're going to start over again. Okay. In the top right corner, we got Alex Kulkowski from Zksync. Alex, welcome to the show.
00:13:09.320 - 00:13:11.604, Speaker G: Hello, everyone. Very excited to be here.
00:13:11.722 - 00:13:14.336, Speaker B: And then in the bottom half, we got yay. From scroll.
00:13:14.448 - 00:13:14.784, Speaker C: Yay.
00:13:14.832 - 00:13:15.860, Speaker B: Welcome to bankless.
00:13:16.280 - 00:13:17.892, Speaker F: Hi. Thanks for having me.
00:13:17.946 - 00:13:34.270, Speaker B: Okay, third time's the charm. Before we get into some of the technical details, I just want to go around into the background of each of your respective teams just to get a little bit context about where each one came from. So, Alex, we'll start with you. Where did DK sync come from? Like, what's the Genesis story? What's the background? Can you kind of walk us through that?
00:13:35.280 - 00:14:07.320, Speaker G: Absolutely. Very happy to. So I'll start with my personal background. You might know that I was born in Soviet Ukraine, and I grew up kind of, like, after the collapse of Soviet Union. And I was very impacted by the economic and social collapse and all the things that were going there. And it brought me to conclusion that there is nothing more impactful you can do in this world today than increase freedom, increase freedom of societies, increase individual freedom. And that is what brought me to crypto.
00:14:07.320 - 00:14:44.480, Speaker G: Part of that is the potential of crypto to enhance world's freedom, which I think is unparalleled with anything else. And the second part of my motivation was the technological challenges. And I have software background I have a CTO for last couple of years before moving into the space, and I just was looking at, it was three and a half years ago. Ethereum was just getting started. All the protocols were just being built. There were a lot of issues around usability and security and everything was missing. I looked into kind of what's going to be the end game.
00:14:44.480 - 00:15:35.232, Speaker G: I was always interested in the end game, like, how do we get this thing in the hands of everyone in the world? And it was clear that all the problems that are very apparent are going to be solved very soon by some teams, except scalability. That seemed like a really big black box. So I looked into what's going on in scalability space, and there was plasma. And I know you are working on plasma. My co founder Alex Plasa was also working on that. So I met him at Defcon three, I guess in Prague, and we both encountered the idea of zero knowledge proofs, of 160 knowledge proofs. And we both had an immediate thought that, oh, you can apply that to plasma and solve most of its issues and actually get something that will work and bring us to mass adoption.
00:15:35.232 - 00:16:06.984, Speaker G: Back then, crypto protocols were not like ZK protocols were not as mature as they are today. But it was pretty clear that over the course of next two, three, five years, we will get something that is workable in production. But we actually got there a lot sooner. A year later, Sonic appeared and two years later we got plunged. And that was something very usable. And starks appeared around the same time. And all the protocols are now getting converged towards very everything is going in the same direction.
00:16:06.984 - 00:16:21.410, Speaker G: And we will have incredibly fast protocols provers, all the mature tooling around that to get us to scale Ethereum with ZK in no time.
00:16:21.780 - 00:16:38.890, Speaker B: And before I hand it over to yay from Scroll, Alex, ZK sync has been around Ethereum for a while. I remember using ZK sync to pay for Gitcoin grants in 2020 or something. Can you just speed run us through how ZK sync has integrated itself into Ethereum over the last few years?
00:16:40.060 - 00:17:32.324, Speaker G: Sure. So when we started out the project, we built the very first working ZK roll up on Ethereum. It was like we called it back then Ignis, but we had to rename ZK sync short afterwards because of conflict. And it took us two more years to build the fully productive mainet version for simple payments and swaps. It's live on Mainet. It took us one year and it's now live for two years. And after that it was very clear that most people will need smart contracts and simple application specific ZK roll ups or roll ups or scalability systems are going to be very niche and you really need this generic programmability during complete programs.
00:17:32.324 - 00:18:12.676, Speaker G: So we set out to build what is now known as AVM, the generic EVM compatible framework that is scalable under SDK conditions. We launched the internal testnet over a year ago. We opened it to the public with Unisync work of uniswap demo last fall. And the testnet is open to everyone since over half a year. And we just announced a few weeks ago that we will be live on Mainet 100 days and it's now day 87 days for me.
00:18:12.778 - 00:18:17.028, Speaker B: I'm sure Alex, that you wake up every single morning and be like there's 87 days left.
00:18:17.114 - 00:18:19.128, Speaker G: We have a huge counter and it.
00:18:19.134 - 00:18:23.604, Speaker B: Just goes, all right, let's turn the conversation to yay from scroll.
00:18:23.652 - 00:18:23.876, Speaker C: Yay.
00:18:23.908 - 00:18:35.150, Speaker B: Can you explain a little bit about the background behind scroll? Scroll is newer on the scene and so this is something that's new for a lot of listeners, including myself. Can you just explain a little bit about the background of scroll? Where'd Scroll come?
00:18:35.680 - 00:18:56.704, Speaker F: Yeah, yeah, sure. Happy to. So scroll started one and a half a year ago. We have three co founders, including me, Hai chun and Sandy. We were actually introduced by our mutual friend in the east community. So before that I was doing Ziki research. It's pure about crypto and Ziki stuff about math and crypto not directly related to cryptocurrency.
00:18:56.704 - 00:19:39.580, Speaker F: And I was working on the proving algorithms and hardware acceleration for the proof, because years ago the proving is the biggest bottleneck for using the proof in practice. So that's the problem I work on, like how to make proverb more practical and faster and how to support a larger circuit. And Hai Chen is an expert in building robot systems. He got his phd from University of Washington. He has years of experience working Amazon, building very complicated systems based on compilers, programming language and gpus. So he has tons of experience of how to make a system more practical and run in real world. And Sandy is more because three of us diverse a lot in our background.
00:19:39.580 - 00:20:41.108, Speaker F: Sandy has been in the broader crypto space for many years. She has been doing investment in crypto since 2017. She has incubated many application level projects and also institutional facing products. She was attracted to Ethereum more strongly due to the rapidly growing community, the esource of Ethereum, and also like innovations from dev developers. And when we met, it was instantly clear that we shared the same vision on what was important and there was nothing more exciting than us to scaling the base layer Ethereum and onboard the next billion of users for Ethereum, because for a long time it wasn't very clear that whether the key vam would even be technically possible. And previously the keywap can only support like payment swap very simple applications using some fake circuit. But recent innovations, because we are working in this area, we know that recent innovations have make that finally possible.
00:20:41.108 - 00:21:27.476, Speaker F: And we all want to build something which is truly impactful for the whole Ethereum community. And also we were joined by our common vision to use this combining with Vicky research advanced technology to really solve the scalability issue of Ethereum. So that's basically the genesis of grow. And although we are new, but we have grown really fast, we have 40 people in our team now and 30 are engineers and researchers. So most are just strongly technical focused. And we have an incredibly strong technical team with most of the people, has a strong math and crucial background. And this background is immensely useful for understanding the backbone of Vicky VM, which highly relies on zero proof, basically on mass and crypto stuff.
00:21:27.476 - 00:22:28.170, Speaker F: And many a member of our team had years of blockchain development experience and has been active contributor to a lot of open source repos like foundry and stuff like that. And because our vision is aligned with Ethereum of being decentralized, many members of our team are also quite global and decentralized. We work remotely. We have people across Asia, US and Europe, including China, Singapore, New York, Bay Area, Poland, Ukraine, Australia, a lot of other places. So I'm very proud of our current team and we are super focused on building, although we are installed previously, and we want to build the best user and developer friendly the QM solution. And we work well together as a remote team. And also we have been very careful in how we grow this team by bringing on the colleagues who are highly value aligned with high integrity, and also the right motivation to work with us in this space.
00:22:29.900 - 00:22:30.456, Speaker D: Nice.
00:22:30.558 - 00:22:31.480, Speaker B: Yeah, beautiful.
00:22:31.630 - 00:22:34.056, Speaker D: All right, David, I want to ask some questions. Can I get into it?
00:22:34.078 - 00:22:34.810, Speaker B: Go for.
00:22:37.420 - 00:22:37.896, Speaker C: All right.
00:22:37.918 - 00:23:12.196, Speaker D: I think the first question that I would like to ask the both of you is, it's very clear that ZKVM, to your point, in your intro questions, to me, David, it's been a problem on the horizon that we've been thinking about for a very long time. And when we first started the ZK scaling stuff, we did not start with the EVM. Right, because it's a very, very hard problem. So obviously there's been huge strides made. To your point earlier, Alex and I have a suspicion that there are different approaches being taken to solve this problem. Right. Usually when there's a hard problem, you get a few different strategies or ways.
00:23:12.196 - 00:23:36.252, Speaker D: Yeah. So what I'm really curious to hear from the folks on this panel are, what do you think are the unique things about the approach that you take, and what are the things that are shared between the different approaches? And notably. Right, we have two panelists here. There are a few other teams building zkevms as well. So I'm really curious to hear from you guys what you think the lay of the landscape is and what your strategy in particular is to tackle this in some unique way.
00:23:36.386 - 00:23:38.110, Speaker B: And Alex, we'll start with you.
00:23:39.360 - 00:24:27.608, Speaker G: Sure. So the approach we are taking goes back to how we think about the strategy of building ZK sync, and that goes back to the mission. Our mission is to accelerate the mass adoption of crypto for personal sovereignty. And accelerate means move faster. We believe that it's coming no matter what, but we want it to arrive not in ten years, but in two years. And to move faster, you need to be very pragmatic. So what we learned from building the first version is that you're much better off launching something that works and then gradually iterating over it than waiting for a perfect solution, trying to construct this abstract beauty in vacuum.
00:24:27.608 - 00:25:32.944, Speaker G: So I have this picture, which you might know, this is how we operate with building gradually and not trying to get perfection. And how we started, actually, initially there was no real way from the limitations of provers, from the protocols themselves, to build a Turing complete version of EVM. So we tried to build a non Turing complete version of smart contracts, and we had to construct a new language called Zinc. So we had to build a compiler team, and we took rust as a base, not the solidity, because we thought if you have to learn a new language, which is going to have a lot of these internal limitations, doesn't really matter, you need to learn from scratch. So let's take something that is more familiar to broader audience. We quickly learned that it's going to be very problematic to force people to relearn the language and to adopt the developer tools. Everything that's just going to be a mass for adoption.
00:25:32.944 - 00:27:24.928, Speaker G: That's not what engineers want, on the one hand. On the other hand, there were some breakthroughs in the cryptography, in plunk, recursive plonk, in improved efficiency for certain gadgets, for certain cryptographic functions that are required to build something like EVM that we thought, okay, we're going to take on the challenge and actually build a full ZKVM, something fully compatible with Ethereum, where you can take existing smart contracts written in native solidity or Viper and just take them and launch them on this thing. And we looked again like what's going to be the fastest way to get there? So our head of engineering, Anthony Rose, is actually coming from SpaceX, used to be in charge of satellite factory there, and we borrowed this concept of the critical path from SpaceX, like what's the shortest possible way for us to get to the goal? And it turned out that we can reuse our compiler skills and build something very similar to what we now know stock was doing with Cairo, namely to create a virtual machine that is optimized for probability under zero knowledge, specifically optimized to be very efficient under snarks, and then create this virtual machine with all the conventions of solidity and EVM, so that all the calls, all the interactions, all the interfaces are exactly the same as EVM, but you just have a different set of codes underneath. And then we can use the compiler to take the code written for EVM and bring it over here. And this is the approach we're taking. As far as I know, no other ZKE EVM team is working in this direction. Stack we're doing this for Cairo, but you have to relearn it like the Cairo language.
00:27:24.928 - 00:28:02.556, Speaker G: They have some tool to transpile code from solidity to Cairo codewarp, but you actually have to maintain the code in Cairo. Then there is no way for you to keep solidity as a source of truth as your basic code. And it would be very hard to keep the same code base between layer one and layer two, or between different layer twos. That was something that was not acceptable to us. We wanted the code base to be exactly the same, executable as well in manned, in anywhere. That's our approach. I'll pass over to you, Ben.
00:28:02.588 - 00:28:05.330, Speaker B: Does that generate any follow up questions, or should we throw it to.
00:28:06.020 - 00:28:38.350, Speaker D: Let me just. Okay, so let me just make sure I'm following right, Alex. So basically what we said is, we talked about in the intro of the show that we have this thing called the Ethereum virtual machine. It's how you interpret smart contracts. In Ethereum mainnet, basically what you've written is a virtual machine that's very similar, that's meant to be very mappable and close and related, that is optimized for ZK proving. And then you can basically relatively easily take solidity code that is meant to go to the EVM target and compile it instead to this other target. Is that right?
00:28:39.120 - 00:29:18.404, Speaker G: That is correct. So we are actually not just, we don't have a native compiler from solidity. We are using the solidity compiler to produce the intermediate U representation of the code. Exactly. And then we're going from Yule to our virtual machine, which is a lot easier to make that step. And in between we're using LLVM as our compiler framework, which is a very mature, very well tested, bottle tested framework with a lot of tooling, a lot of optimization. So our code is actually a lot more optimal than what solidity compiler natively produces for ABM.
00:29:18.404 - 00:29:55.612, Speaker G: We have three times less opcodes in the final result. And yeah, so this approach is the fastest to, to production. And yeah, we started working on this since two years. So we have something that is very mature in compiler. We're covering all the tests from Ethereum test suits and it's running in a very stable way on our testnet, just public. A lot of teams are deploying there. We have hundreds of teams already working on Testnet.
00:29:55.612 - 00:30:57.064, Speaker G: Everything works really well. But the most important thing is it will produce the resulting virtual machine bytecodes that are very optimal. The execution, the proof generation for the ZKVM, for optimized ZKVM is going to be orders of magnitude less than approaches that try to mimic EVM at bytecode level. So we are talking about very low cost per transactions, which we can scale to both support the high load of defi nfts, but also very broad use cases such as gaming and all the new things that are coming to blockchain. Once we can actually support the scale of tens, hundreds of thousands TPS. And in those cases, it really matters if your transaction costs like $0.10 or 0.1
00:30:57.064 - 00:31:10.220, Speaker G: cents, it matters a lot. You cannot just like this is the quantitative step that unlocks qualitative difference in what you can actually build and execute and run in these networks.
00:31:10.640 - 00:31:23.090, Speaker B: Beautiful. All right, let's turn to yay from scroll. Yay. Can you talk about the competitive difference that scroll is bringing to the table? How is the approach to the Zkevm from scroll side of things unique from the others that you would find in the same.
00:31:24.180 - 00:32:12.444, Speaker F: Yeah, yeah, sure. I think technology wise there are two differences. One is on the ZikvM side and the other is on the infrastructure side. Firstly on the Zikiwam side. So our goal is that we want to have the deepest level of compatibility with Ethereum down to the client implementation. So by saying that we are not only being compatible with the solidity at a language level like either you are you or any error, we will be compatible with EVM itself at the bytecode level, which means anything as far as you can use the existing compiler to compile down to the EVM bytecode, and we can prove that it's correct. And also by saying client implementation, we are reusing the existing Ethereum node implementation called gas to generate our layer two blocks.
00:32:12.444 - 00:33:01.680, Speaker F: So this is pretty similar to what optimism is doing. Just try to reuse the implementation from Ethereum to inhale the performance, the security. And also in the long upgrade we will be more aligned with Ethereum. So there is no compiling, there is no interpreting in between. So it brings us another level of compatibility, more than just the RPC interfaces, but it's a deeper level of compatibility on the implementation side. And for users it means they can do whatever they can on Ethereum using the same UI and UX. And for developers they can reuse all the Ethereum toolings, even include some debug toolings like where you definitely need to down to the barcode level, like for example, you need to look up some stack information and things like that, and they can migrate their code to scroll without any modification.
00:33:01.680 - 00:33:58.064, Speaker F: And also this brings us another benefit where our implementation will be the most closest to the end goal of Ethereum, where Ziki EVM can eventually be used to prove for layer one net blocks. So in that sense, we are not only building for ourselves, we are not building just for layer two purpose, but we are actually cobbling this for the future of the Ethereum, because it's very beneficial for Ethereum in the long term. So that's from the compatibility and the Zikvam side. And another thing I want to mention is that on the infrastructure side, we have designed a decentralized proverb network. So there is both a technical difference like innovation there, and also a strategic difference. Because a big problem we're mentioning by maybe optimist, degrap or other teams is that the proving cost is large, because generating proof is usually slow and considered to have very high costs. It's very expensive.
00:33:58.064 - 00:34:51.110, Speaker F: But we can actually solve this problem by allowing many people to generate a proof in parallel. And also this can drive the efficiency of proving hardware to the extreme, and eventually even have the ASICs to support this proof generation. Like anyone can just use this type of hardware or use general proper GPU or whatever they can to generate proof for us, for our platform. And we are prioritizing this because this is also not only the technical advantage, but also strategic differences, because more immediately, especially with the east merge, miners could potentially just be our provers. They can reuse their GPU machines to join provers and join our ecosystem if they don't want to switch to another. That's both technical innovation and also a strategic move for us.
00:34:51.880 - 00:35:18.350, Speaker D: Let me ask. Okay, so I want to do the same thing and make sure that following. So basically what yes said, I think, correct me if I'm wrong, is that you effectively have a program that is written, I would assume, that's running in some sort of lower level ZKVM, that is this Turing complete machine, and then you're running an EVM interpreter on top of that, basically. Is that right?
00:35:18.960 - 00:35:54.440, Speaker F: So we are not even having this middle layer, we are directly. So for example, if you receive a transaction, you execute it on gas, and then you output some information like the execution trace, like which opcode you are executing. And then you use this trace as a witness to fit into this circuit and prove that it's a valid trace using a very certain proof. And then this proof, like as far as you have this proof, it means, oh, this trace is valid. So this transaction is correct. So there is no middle step. You just reuse every information from the existing client.
00:35:55.020 - 00:36:17.504, Speaker D: Yeah, got it. And that circuit, I guess what I'm getting at is that circuit. Okay, so it makes sense to me that you run the transaction on Geth like vanilla thing, and Geth has a wonderful thing called a transaction trace, which will give you sort of a step by step set of these instructions of the Ethereum virtual machine that we talked about. Right. Geth will break that down instruction by instruction. It went here and then it went there and then it went there. So that all makes sense.
00:36:17.504 - 00:36:35.780, Speaker D: But then what is actually running when that information is transferred to the prover? What is the circuit running? Is there some sort of Turing complete thing that is then running the EVM on top of it? Have you actually written an EVM circuit for all of this? What is that, part of the stack?
00:36:36.280 - 00:37:03.112, Speaker F: Yeah. So basically what we are doing to handle this is that for each opcode we will implement some subsurface to prove it's correct. For example, if you are add opcode and we prove that this number adds to this number equal to this number. So we have a specialized subsurface for each opcode. It's a one to one mapping. Got it. And then in EVM circuit we compose those subsurcates together and then open some selectors.
00:37:03.112 - 00:37:17.120, Speaker F: We call that selector in circuit. But basically, if you meet with this opcode, you open this certain constraint, and if you meet with the other opcode, you open the next, and then you prove that this is the crack. And by constraining each opcode.
00:37:17.560 - 00:37:36.808, Speaker D: I'm really interested to hear from you, Alex, on this. It's interesting. I know I've been on a panel with you, and you love paralyzed proof generation as well. I think all the zkrs do it. I totally do as well. But it also seemed like earlier you said you had a bit of a different approach for performance reasons. So I'm just curious to hear what each other's perspective is on these things.
00:37:36.808 - 00:37:41.950, Speaker D: Is the performance of ZK proofs an issue or not? I feel like I get conflating answers sometimes.
00:37:42.640 - 00:38:11.380, Speaker G: That's a great question. Yeah, that's a really great question. So I don't see that we have different strategies here. Like all ZK teams will eventually work towards decentralizing the prover. We are working on this definitely from this is very important to us. We don't want to be any single point of failure. We don't want to run any operator that controls the validation of the transactions going in layer two or the proof generation, so it will be decentralized.
00:38:11.380 - 00:38:58.880, Speaker G: We can reuse Ethereum miners. Indeed. We've been working on the GPU prover hardware for the last two years as well, and we have some pretty amazing results. Like the GPU prover that we have that runs on ordinary consumer gpus is something like 50 times faster than, 50 times cheaper than the proofs produced on cpus. And for the broader concept, it's really important to understand that whenever we talk about the prover efficiency, we always are talking about the amortized cost per transaction. Prover is always distributed like it's always done in parallel. No one is running a proverb on a single machine.
00:38:58.880 - 00:39:56.388, Speaker G: If they do, it will take them hours to generate a single proof. What we are doing, what probably other teams are doing as well, is we run it on as many machines as we need in parallel. And since the structure of the circuit is that we kind of regressively combine many circuits together, our latency to generate proofs with gpus is going to be like less than a minute. So we will be able to get the blocks really fast. So what really matters at the end is what is the cost of this proof generation divided by the number of transactions? What is the cost per transaction? And that is where the differences will materialize very significantly with our approach. Or like what starquist building versus what scroll? Like this very ambitious goal of scroll to make EVM circuit level compatibility. That is going to be like several orders of making it higher.
00:39:56.388 - 00:40:30.540, Speaker G: I'm very curious to see what the numbers actually are, but that is very complex, and that is very complex also to maintain so huge respect to the team who are trying to make this. We didn't trust ourselves. We went for much simpler approach because we know that the more complexity you add, really it grows nonlinearly with the number of systems you add and with the number of layers you add to each system, it just explodes at the end. This is with regard to gpus.
00:40:30.620 - 00:40:30.912, Speaker C: Sorry.
00:40:30.966 - 00:40:32.930, Speaker B: Now finish up, Alex. And Alex, my next question.
00:40:35.140 - 00:41:19.520, Speaker G: So this is with regard to decentralizing the proverb and gpus. And you just want to add that we decided explicitly not to reuse Gaeth, not to rely on standard nodes for a transaction, for the block building, for deciding what goes into transactions, because Gat is known to have very strong limitations on throughput that it will bring with itself. And we decided, like, if we're building a system that should be capable of running tens of thousands of transactions per second, we should redesign the node from scratch. And we're writing it in rust. It's highly optimized. We also have very strong engineering team working on optimization of the node, because we don't want the node to be the boss.
00:41:21.220 - 00:41:45.288, Speaker B: I think. Alex, you just opened up the conversation to the EVM compatibility versus EVM equivalence conversation. But before, I wanted to go back and just make sure we really knock down the decentralizing the prover for the layman, because that part of the conversation made me feel like a dog driving a car. Ben, can you walk us through, what does it mean to decentralize the prover? Why is that significant for just like the average user to pay attention to.
00:41:45.374 - 00:42:22.480, Speaker D: Sure. So I'll talk about this. I'm not the ZK experts like these folks, but I have a rough sense. So basically, when you construct these zero knowledge proofs, right, that is an operation called proving, right? Unlike the operation called verifying, which is like in a ZK role, what the smart contract on chain does, what all the nodes do, then downstream of that. So in general, what you have to do, basically, when you produce a zero knowledge proof, is a bunch of extra cryptographic moon mathy computation that will give you some fancy numbers that allow the verifier, in this succinct manner, in this short, constant or logarithmic sized manner, to check whether or not the proof is valid.
00:42:22.560 - 00:42:22.852, Speaker C: Right?
00:42:22.906 - 00:42:48.920, Speaker D: And so this is a computationally intensive operation to do it in the zero knowledge succinct manner that we're talking about. Basically, if you want to prove something, it's kind of like you don't just run the computation because that's not a proof, that's just you doing it. You have to run the computation in some sort of circuit zero knowledge math context that gives you some cryptographic steps along the way that you can sort of combine and aggregate and get this succinct proof.
00:42:49.000 - 00:42:49.388, Speaker F: Okay.
00:42:49.474 - 00:42:55.404, Speaker B: I'm guessing that doing the ZK stuff is like adding, like, an order of magnitude of difficulty upon the computation.
00:42:55.452 - 00:43:01.388, Speaker D: Yeah, these guys can talk about those numbers much better than I can, but it adds overhead for sure. Adds overhead.
00:43:01.564 - 00:43:10.432, Speaker B: And is that like the cost for when a transaction fee happens on a ZK roll up? Is that the cost of this thing? Is that related? Are these related?
00:43:10.576 - 00:43:27.736, Speaker D: So it will be related, right. I haven't looked into the details of either these folks fee markets, but that is, I think, what would be a very reasonable thing for a fee market to do. I think probably a requirement. There's additional costs. Right. Because even in a ZK roll up, you're still rolling up that data, which means you're posting it to Ethereum or whatever.
00:43:27.838 - 00:43:28.104, Speaker C: Right.
00:43:28.142 - 00:43:35.436, Speaker D: I know. At least Alex has other more plasma type things that don't require that, so it's going to be a chunk of the cost. Absolutely.
00:43:35.538 - 00:43:41.890, Speaker B: Okay, cool. Is there anything that Ben and I just said stand out to you guys that you guys want to add on a comment to?
00:43:43.780 - 00:43:44.880, Speaker G: Sounds good to me.
00:43:44.950 - 00:43:45.376, Speaker B: Cool.
00:43:45.478 - 00:43:46.130, Speaker F: Yeah.
00:43:46.580 - 00:44:16.932, Speaker B: All right, so we definitely got to talk about EVM compatibility and EVM equivalents, because I think that's really. Alex, you said that Geth is really just not optimized for some of this parallel proving magic, but yay. From what I've gathered, scroll is really going after what Alex called the very ambitious task of figuring out how to make Geth and AZK rollup work together. So I think that's where we want to take this conversation next. But before we do that, we got to talk about some of these fantastic sponsors that make the show possible. There is a brand new staking feature.
00:44:16.996 - 00:44:20.236, Speaker E: In the Ledger Live app today. We all like staking the assets that.
00:44:20.258 - 00:44:21.596, Speaker B: We'Re bullish on, and now you can.
00:44:21.618 - 00:44:24.508, Speaker E: Stake seven different coins inside the Ledger live app.
00:44:24.594 - 00:44:31.404, Speaker B: Cosmos, Polkadot, Tron, Algorand, Pezos, Solana, and of course, Ethereum. With Ledger Live, you can take money.
00:44:31.442 - 00:44:33.244, Speaker E: From your bank account, buy your most.
00:44:33.282 - 00:44:37.404, Speaker B: Bullish crypto asset, and stake that asset to its network all inside the Ledger.
00:44:37.452 - 00:44:53.572, Speaker E: Live app through a partnership with Figment, Ledger also lets you choose which validator you want to stake your assets with, and Ledger is running its own validating nodes, offering a convenient way to participate in network validation, and it even comes with slashing insurance. Ledger Live is truly becoming the battlestation for the bankless world.
00:44:53.626 - 00:44:54.964, Speaker B: So go download ledger live.
00:44:55.002 - 00:45:26.732, Speaker E: If you have a ledger already, you probably already have it and get started securely staking your crypto assets. The brave browser is the user first browser for the web3 Internet with over 60 million monthly active users. And inside the brave browser you'll find the brave wallet, the secure, multitrain crypto wallet built right into the browser. Web three is freedom from big tech and Wall street, more control and better privacy. But there's a weak point in web3. Your crypto wallet and most crypto wallets are browser extensions which can easily be spoofed. But the brave wallet is different, no extensions are required, which gives brave browser an extra level of security versus other wallets.
00:45:26.732 - 00:45:53.464, Speaker E: Brave wallet is your secure passport for the possibilities of web3 and supports multiple chains including Ethereum and Salana. You can even buy crypto directly inside the wallet with ramp. And of course you can store, send and swap your crypto assets, manage your nfts, and connect to other wallets and DFi apps. So whether you're new to crypto or you're a seasoned pro, it's time to ditch those risky extensions and it's time to switch to the brave wallet. Download Brave@brave.com bankless and click the wallet icon to get started. The layer two era is upon us.
00:45:53.464 - 00:46:28.720, Speaker E: Ethereum's layer two ecosystem is growing every day and we need layer two bridges to be fast and efficient in order to live a layer two life. Across is the fastest, cheapest and most secure crosschain bridge. With across. You don't have to worry about high fees or long wait times. Assets are bridged and available for use almost instantaneously. Across's bridges are powered by UMA's optimistic oracle to securely transfer tokens between layer two s and Ethereum across its critical ecosystem infrastructure and across v two has just launched. Their new version focuses on higher capital efficiency, layer two to layer two transfers, and a brand new chain with Polygon, all while prioritizing high security and low fees.
00:46:28.720 - 00:46:42.200, Speaker E: You can be a part of across this story by joining their discord and using across for all of your layer two transferring needs. So go to across to quickly and securely bridge your assets. Between Ethereum, optimism, Polygon, Arbitrum or Boba networks.
00:46:43.820 - 00:47:14.720, Speaker D: Okay, welcome back, y'all. We're back in action. So, okay, we just had a really interesting discussion on some of the differences in these approaches. And one thing to your point, David, that came up just before the break is understanding the role of, I think the. So I take some guilt for creating this term, which could be very confusing. But EVM equivalence is like a wonderful term that we use at optimism to describe how we kind of try to move towards using geth as much as possible. And this has been a matter of debate and there are differences between our two panelists here and what they do.
00:47:14.720 - 00:47:50.830, Speaker D: So I'm really curious to hear from you guys how you think about the developer experience. We talked a lot about the approaches, sort of from an proving architectural cost, GPU type of a perspective, but there's also the side of developers and what they're going to experience. So I'm curious to hear from you guys, from the panelists, what your different approaches to this developer experience are. What does it really look like for a developer to be implementing on one or the other, and how do you think about that long term? Is the other question. Are you at a place where you're comfortable? Are you trying to move in a specific direction? What's the take? So maybe we'll start with yeah.
00:47:56.860 - 00:47:57.224, Speaker C: And.
00:47:57.262 - 00:48:51.812, Speaker F: Developer experience, which means we will provide exactly the same execution environment as ethereum layer one. So developers can pretty much reuse all the developer toolings around, including the debugging toolings. If you want to go into the stack and look up some information, you can still use that. And because as far as know, many gas developers, many even application level developers, they are very familiar with the gas implementation, so that it's easier for them to debug and have some index security analysis. So I think we have some advantage on that because we are using a fork of gas to generate our blocks and also because you are compatible with all the developer toolings. So developers are very comfortable with every toolings they use on layer one. They don't need even any actual plugins or to link to any external compilers.
00:48:51.812 - 00:49:50.276, Speaker F: They can just reuse whatever is there. So in the long term I think it's more secure way, because firstly, EVM has due test of time. The design philosophy of each upcode, this stack based virtual machine, its security has due test of time. If we just reuse everything from EBM, it's very easy to audit our code because our execution environment will make sure that the circuit will behave exactly the same as EBM. If you make mistakes there, then you can make mistakes here, but if it's cracked there then because they behave exactly the same. So I think that's important in the long term why remaining this UVM equivalency is important. And also secondly, as I mentioned, if you are more aligned with this implementation for the further ethereum upgrade, people are doing experiments over gas for eips for different improvements.
00:49:50.276 - 00:50:25.240, Speaker F: You can directly use the same code base to improve your layer two design and also even sometimes give back. I think that's part of the motivations why optimism is going into that approach. So that's why our design philosophy for this part, and again because we are actually standing on top of the giant, because when we appear the bricks will already happen. We know the overhead is already affordable. So that's why we directly go into this bytecode level compatible approach instead of building some other virtual machines to make the proving overhead more manageable.
00:50:27.580 - 00:50:30.120, Speaker D: What makes sense? Yeah, let's hear from you Alex.
00:50:31.740 - 00:51:21.160, Speaker G: Sure. So we are also on the mission to make the developer experience as easy and pleasant for developers as we possibly can have. The absolute top and it's important to see what is the actual developer experience is what you expect as a developer from the environment. What you expect is that you don't have to modify your code and you can use the existing tooling. So you take whatever you have written in contracts and front end and test tubes, et cetera, and you port it and it just works, just work like one click stripe like experience where you don't have to do any movements. That is exactly what we're going to bring. We're not going to bring it at the opcode level, but we're going to bring it at all the interfaces.
00:51:21.160 - 00:51:56.288, Speaker G: The code does not need to change, you do not need to do any re audits. Your web3 API works out of the box. All the coding conventions work, all the toolings on chain work. We have the graph chain link. A lot of other projects already integrating, already running on our testnet ready to provide this experience. So things that will not work because the opcodes are different are like low level debuggers, but those tools can just integrate, we can work with them. There are not many of them.
00:51:56.288 - 00:52:50.484, Speaker G: We can work and make them be as compatible. And then you use the same, you have your tenderly experience, you have your remix, you have your common line based debuggers and they provide the same output, the same experience to you. You as a developer do not need to do anything and the surface of changes is really minimal but what is ultimately important to you as a developer is that your code works smoothly because everything is fast. So the one way to think about Zke EVM equivalence versus EVM compatibility is like what would be the analog of these things in the real world in the normal computing? Imagine you have some piece of software written for one operating system for a specific architecture. I don't know, like a Photoshop running on Windows. Now you want to run this photoshop on Mac. With m one processor you have two options.
00:52:50.484 - 00:53:29.970, Speaker G: Either you recompile the code for M one and it runs super fast and you like the experience, or you run a Windows simulator on your Mac and then you run this photoshop in the simulator. You can already sense like if you run just some programs written for the older version of Mac, and then you try to run them on m one without optimizations, you already feel the difference, right? It's huge, but if you run it in an emulator, it's going to be a lot slower. So your developer experience is tightly coupled with your user experience as well. That is what matters at the.
00:53:32.500 - 00:53:33.856, Speaker C: Very very very interesting.
00:53:33.958 - 00:54:04.172, Speaker D: Yeah, I want to take a careful spot here, David, to be your co host because I'm very opinionated as the folks coined the term EVM equivalents. Like I feel like I'm at an interesting position here. I'll just say I'm very curious to see how it plays out. I definitely very much vibe with many of the things that you said there, Alex. Some of them I became less of a fan of once I had to run a non EVM equivalent system practice. You guys are also building in a different space, right? You've got these ZK requirements. It's a little bit of a different world.
00:54:04.172 - 00:54:13.410, Speaker D: So yeah, it'll be very interesting, David, to see how this plays out. I'm a huge fan of developer experience and I think that EVM equivalents is the way to go there, but we'll see.
00:54:14.100 - 00:54:17.810, Speaker B: Alex, any comments on that or not?
00:54:19.860 - 00:54:36.440, Speaker G: I'm really happy that we have multiple approaches competing. We have our bet based on our analysis what's going to be the optimal for developers at the end. But it's really great that we have this race and let the thousand flowers blossom.
00:54:37.500 - 00:54:37.960, Speaker C: Yeah.
00:54:38.030 - 00:54:41.210, Speaker B: Any comment you want to add before I turn the conversation to something else?
00:54:41.900 - 00:55:27.210, Speaker F: Yeah, I think it will be just win win eventually. All good for Ethereum, like different tries and EVM equivalent environment or this compiler based one. But I think in the long term if you have actual need for compiler, you have to also upgrade your compiler and both your compiler and your circuit at the same time, which actually adds the overall complexity because those two parts are coupled together and you need to upgrade with each upgrade. But for ZTN circuits, all the compiler stuff, those can be reused and those have been tested years of time. So that's why we want to handle this more complex stuff on the circuit side. But we don't need to handle anything besides that.
00:55:29.660 - 00:55:32.250, Speaker D: I want to hear from Alex on that. Yeah, that's a really interesting.
00:55:33.180 - 00:56:37.256, Speaker G: I wanted to add that indeed what we're building here is the future. And let's imagine is EVM going to be ossified and be this standard that will be there forever and will not undergo any modifications. Imagine that we have the very first version of PC with like 80 86 architecture. Is this thing going to be immutable and never change? That is hardly imaginable, right? So we will have some evolution in my opinion. You feel free to disagree, but with the compiler. One thing that gives you that a separate compiler, specifically LLVM based compiler, gives you is an option to have developer experience beyond your CVM. You can port in any code written in all the modern languages that support LLVM, like Python with C, whatever, you take that, you compile it, even JavaScript, you compile it to LVM, and then you can use it as libraries.
00:56:37.256 - 00:57:07.600, Speaker G: Or we can also define some contract interfaces and you eventually can write smart contracts in those languages. And I think that is going to be incredibly powerful because it just opens this massive code bases already written in these very expressive languages with generics, with all the cool stuff that is not yet possible in solidity and that have stood the test of time for many more years before solidity was even created. So I find that really fascinating.
00:57:07.760 - 00:57:39.104, Speaker D: Okay, wait, Alex, I've got to dive into this more. I. Okay, first of all, totally agree. If the reader has not heard of LLVM, it is one of the modern marvels of computer engineering. Absolutely fascinating. Go check it out. With that being said, there's a key question here that I don't know if I heard an answer to, which I want to dive into, Alex, which is since you have developed a VM that is the ZKVM, that is related to the EVM and maybe has some of the same semantics, but is different, how do you deal with upgrades? Right, so I totally agree.
00:57:39.104 - 00:58:02.632, Speaker D: We're going to have upgrades to the l, two vms is implicitly there a commitment to this particular ZKVM, your current compiler outputs, and is it your goal to maintain that going forward and just build more solid circuits around that? Or do you have the ability to improve that VM in the same capacity? Is that a question?
00:58:02.686 - 00:58:29.010, Speaker G: That is a great question, yeah, I think we will have iterations in the initial versions of older roll ups. We'll have to work a lot on upgrades and do changes. It will be important to work with the source code and not with bytecode. I don't think we will have like an ossified bytecode in any near time. So eventually we will have a newer version. And yes, you will need to redeploy your contracts there.
00:58:29.700 - 00:58:42.470, Speaker D: Okay, I see. So you're basically going to enforce a requirement that you have source code accessible so that if you upgrade the underlying ZKVM that is not EVM, you can recompile and regenerate the bytecode for it.
00:58:43.800 - 00:59:27.424, Speaker G: That would not be a hard requirement. So whatever you launch, once we have a stable mainet, we will guarantee that this main net will run for a long time, and then most likely you will have a. Well, we need to see. I don't know exactly how this process will work, but yes, I believe that there will be progress in both the EVM world and zkvms. And eventually we will converge more and more with the world of generic computing. We'll reuse the tools like OVM static analysis, all the debuggers that the traditional systems can bring. And I just think this process should be gradual and smooth.
00:59:27.424 - 01:00:04.160, Speaker G: Should not be like a breaking change for you. You have to stop immediately and you cannot support your previous code. You can always emulate. It's quite easy for us to add bytecode compatibility in ZK sync, because now imagine we have the LVM compiler. We can write code in solidity and rust, and it compiles to this very very efficient low level virtual machine. We can just write a contract that executes native EVM bytecode, we write it in solidity. Or maybe we just compile our rust implementation and we put it on ZkVM.
01:00:04.160 - 01:00:37.400, Speaker G: That will give you the same overhead, or maybe even slightly lower overhead than what scroll or hermass are building. But it's a gradual process. You don't have to wait for this final step. You can already start using porting your contracts to Zk sync written in solidity, because you recompile them. And the moment we have this contract live, you can just start porting your bytecode if you're willing to take this massive overhead into account. If you want full efficiency, you just compile natively to zkv.
01:00:39.100 - 01:00:40.280, Speaker D: Fascinating.
01:00:42.300 - 01:00:43.610, Speaker G: That was big also.
01:00:43.980 - 01:01:32.252, Speaker F: Yeah. Can I add more comments on this? I think there are two points. Firstly that I agree that EVM may not be the end of goal in maybe like 100 years. We are not always stick to EVM model. But the reason why we firstly go into this EVM equivalent approach is that because we know that the urgency for Ethereum is scaling, right? It's not for finding some new computational model as extension, but it's more for migrating all the existing apps securely to a layer two, so that the congested problem can be solved. So that's why we want to provide the EVM equivalency environment in the first place, because you have to handle with those problems, and then you can think of the further problem of a new VM or NA features. So that's one thing, that's just our starting point.
01:01:32.252 - 01:02:23.048, Speaker F: And we will also definitely consider more developer friendly VM or something like that. And the second thing is that to build this. So there are some arguments around EVM versus VM, but the problem is that I think the conclusion is mostly likely that either you build a totally new virtual machine or you just reuse this EVM and achieve equivalency. Because if you modify part of that, it's nearly a new VM, but you can't just benefit from a totally new design from this virtual machine. So that's why we are thinking of two approaches. One is that adding more features to this EVM, for example, we can upgrade according to our community desire, like some new pre compiles specifically to our layer two, and using the existing EVM structure securely. And secondly, that we are in parallel, we can explore some more efficient Ziki VM to open this design space for more developers.
01:02:23.048 - 01:03:09.630, Speaker F: So that's something like we are also exploring. But we believe that that's also driven by the developers needs, instead of just reusing the compiler and just reusing the same virtual machine, because it's fundamentally different. I think the last point is that reusing the LVM is very ideal to support all the programming language. But if you dive deeper into the LVM for very high level language like rust, Python, those touring complete language with many features, you will find that the LVM IR in the middle layer is very complicated. It's even much more complicated than building a dicky EVM, like adding support for all those opcodes, because they have very complicated types, they have very advanced features. If you want to support all of them, you need to support a very complicated IR layer. It's not just the solidity or anything.
01:03:09.630 - 01:03:35.270, Speaker F: So I think even if you have this Levr port, it still take a very long way to go to support all the features of rust. But if you only support the semantic of ROS, then I think it's still less useful for developers because they still need to change a lot of code. And so that's maybe three points from our perspective. So we are also. But that's why we win this as our first step.
01:03:35.880 - 01:03:39.600, Speaker G: I'll take that challenge. Let's see how fast we can support Ross.
01:03:39.760 - 01:03:40.470, Speaker F: Yeah.
01:03:43.000 - 01:04:17.888, Speaker B: Awesome guys. Well, like I said earlier, I really like this metaphor. I feel like a dog trying to drive a car. So I'm going to zoom out this conversation and get something I think the users can understand, I think a little bit better. And every single layer two team has their sort of vibe, if you will. It's their culture, it's their branding. And that's often really how users ultimately come to determine whether they feel comfortable with a particular ecosystem or not is like what are the values or the ethos that each team appears to exude, even though they can't really comprehend some of the very technical words that are being said.
01:04:17.888 - 01:04:40.490, Speaker B: So I'd just like to get each of your guys'perspective as to do you guys think about values or culture or vibes within your guys'internal just like communication as to how to build something? And maybe you can share that perspective with the broader world. What is the vibe of your particular project? Do you guys have an ethos that you stand on and yay. I'll start with you.
01:04:41.740 - 01:05:11.728, Speaker F: Sure. Yeah, that's actually a very important aspect of scroll and you can check out more. We have posted articles talking about our vision value, our technical principles. We want to upcode when we are designing our whole architecture. But from the esos and the vision side, we are more open. We have been building in the open source way from day one. Totally open source, sick event circuits where anyone can run, anyone can just even pr some code.
01:05:11.728 - 01:06:31.832, Speaker F: And most parts of the ZKVM circuits are actually co built in collaboration with the privacy and scaling exploration team at ECM foundation under permission based license. So we are actually co units together. A lot of actually credit also come from this community and because we have this permission based license, which means anyone can use this repo and build things on top of that. And also we encourage the broader community to do so because we firmly believe that building in this open source way leads to more secure and resilient code and help us to foster a broader community of developers and they can check our progress in a very transparent way because there are some overclaims, right? They can just directly fact check our claims, for example, like whether we have proofs or not. And in that perspective we hold ourselves very to a very high standard that with all our claims we made, for example, we actually have live leaky proofs in our testnet now can be checked. And we are focusing on building and shipping new features on our testnet. And we are not doing endless prs, but instead we are writing articles explaining what we are building and what our architecture look like and output more educational articles which is beneficial for the whole space.
01:06:31.832 - 01:07:08.436, Speaker F: It's not directly fighting against each other, but more like for educating people why this is important and what we are building. And I'm glad that even if we are still in a relatively stealth model, there is still a circle of east and Vicky researchers who have recognized our work and given us credit where it's due. And we are actually finally ready to welcome a much broader community. And I'm happy to see that we have received over 25k sign ups within two days of our pre alpha testnet announcement. And if you want to be the first batch of user, just sign up at signup grow IO.
01:07:08.548 - 01:07:15.560, Speaker B: Yeah, beautiful. Thanks. Ye and Alex, I'll say the same question to you. What's the overall value or vibe of Zksync?
01:07:16.620 - 01:08:08.820, Speaker G: So Zksync is deeply mission driven project. So this mission that I mentioned in the beginning to accelerate the adoption of crypto for self sovereignty is hugely important. We've written a lot about this. We have a team handbook that walks the new team members through the values. We are extremely aligned with Ethereum on the approach towards those goals. And every technical decision we make is matched, is balanced against the principles of freedom, resilience, inclusivity, from escape hatches, to the way we decentralize the proverb, to the way we approach decentralization of the sequencer, to the way we approach the standardization of code bases. We firmly believe in open source.
01:08:08.820 - 01:09:03.740, Speaker G: Everything we do is going to be released under permissionless software license, just like we did for version one. With version one we made some interesting experience that made us reconsider the approach to complete openness. We were leading the protocol development completely in the open, and then there were people who just forked the code, made modifications that they did not understand, took part like they copied some, they forked off some bugs, and they also changed things that led to more problems and they tried to front run us with regard to the token. So there are powerful incentives for people to just rush with some unready code and try to publish it. That's why we're taking a more conservative approach now. So we're opening everything to independent researchers. Next week we will announce some people we opened it with who are highly credible in the space.
01:09:03.740 - 01:09:18.210, Speaker G: And then we're going to gradually open it to more and more and more until we have all the audits and all the testimonials from the white hats where we feel comfortable that the call is safe. Then we're going to open source to everyone.
01:09:18.820 - 01:09:19.280, Speaker B: Beautiful.
01:09:19.350 - 01:09:19.632, Speaker D: Nice.
01:09:19.686 - 01:09:20.144, Speaker E: Thank you, too.
01:09:20.182 - 01:09:20.432, Speaker B: Yeah.
01:09:20.486 - 01:09:52.840, Speaker D: Kumboy cryptoculture baby. Okay, Alex, you did just raise something that I really do want to get in before the end of this panel, which is a question for both of you. Okay. All of the ZK, I mean, realistically, almost all, pretty much all of the layer two teams out there right now have upgrade keys. Right? There's some set of small number of people that own a multi sig that can be used to upgrade the system. And that includes upgrading it to something that is malicious and takes all of the money from the system. This is obviously not ideal.
01:09:52.840 - 01:10:37.160, Speaker D: I don't want to rehash why that's necessary, because I think we all agree that it is and we understand that it needs to happen. But my question is, at what point can we cast those upgrade keys into the fires of Mount Doom? Like, from both of your perspectives, what is the point in time in which obviously it makes sense that now for you to launch something, you can have some level of trust that it's at some level of productionization. But it's a big shift to say, okay, we're throwing away our upgrade keys. If someone comes to us with a bug in the future, we cannot solve that bug. So I'm really curious, from your guys perspective, what is the timeline and what is the concretely the criteria that you think has to be fulfilled to be able to turn off your upgrade keys?
01:10:37.840 - 01:10:39.870, Speaker B: And Alex, we'll start with you again.
01:10:41.120 - 01:11:21.560, Speaker G: Sure. This is a huge problem we're thinking a lot about. I published a tweet where we offered a bounty for the best design solution that can help solve this problem and for the broader context. The problem here is very different in l two space compared to l one, because if you have a problem with l one, you can always fork away. The decision to fork is ultimately with the people who run the nodes. So you never depend on the honest majority. And that is the superpower of public blockchains, like truly decentralized blockchains like bitcoin and ethereum, and I can't really think of any other ones that fall in this category.
01:11:21.560 - 01:12:30.072, Speaker G: But you don't get this at layer twos, because at layer twos you have all the funds are locked into this one contract on layer one that someone needs to control, someone needs to. This contract must objectively know what code is now canonical. What shall we execute? The solution we came up with was we have a team multisig that can initiate upgrades, and those upgrades are subject to a timelog period of multiple weeks. And then all the users who are disagreeing with those upgrades can exit. And we have permissionless mechanisms for exit, like scape hatches, like forced block proving, et cetera. But if there is a bug and we really need to accelerate, we need to act now and just fix an immediate problem, we must go and reach out to an external number of people who we call a security council. Those are highly prominent people from the Ethereum community, very rich and famous.
01:12:30.072 - 01:13:55.400, Speaker G: So it's very unlikely that they will all collude to try to steal these funds and they must approve an immediate upgrade. Now this is not a perfect world because we don't want to expose those people to some political struggles, to some non monetary incentives that might force them to do things. Ultimately, what we can do is have multiple layers of protection in our systems that all of the checks must be made before something happens. So a simple example would be if we just have a second factor and we have a roll up running like a Ziki roll up, and then we have number of validators appointed by the users who have to approve transactions. And then you would have to break both the consensus of these validators, or corrupt the stake and find a problem in the ZK circuits to try to exploit it. But that could compromise the liveness of the system if the proof of stake is, or like this value data set is compromised. So another option would be to have multiple implementations of roll ups, like maybe a few ZK roll ups, or maybe optimistic plus ZK roll up.
01:13:55.400 - 01:15:15.030, Speaker G: We combine those together and we put them on chain, and then we use governance only if they disagree. This is something that Vitalik posted last weekend on Twitter, which is a very interesting idea, but ultimately we just need to wait for those systems to become mature. Like if something is running for a few years with billions of dollars worth at stake and nothing has happened, and those funds were not stolen, and you had honey pots running in the open with much lower barrier, much lower threshold of capability, and those are also safe, and those have millions of dollars stake in them that the attacker could just grab if they found much easier to penetrate, then I think then we can say okay, those systems are plausibly secure and we can rely on them and we can remove the admin key. This is roughly how I think about it. Maybe there are some ways where we could rely on the governance of layer one. Maybe we could declare some roll ups as really important, systematically important for Ethereum. And we can say if something goes wrong in those systems, then we would just rely on the votes of the general Ethereum community.
01:15:15.030 - 01:15:29.640, Speaker G: And we don't need to declare them anything special, we just need governance mechanism that can rely on this external voting power of broader Ethereum. Maybe something like this. So all the ideas are really appreciated.
01:15:31.340 - 01:15:31.656, Speaker C: Yeah.
01:15:31.678 - 01:15:37.548, Speaker B: You want to take the same question, just the overall security of scroll and your guys'thoughts, and plans around it?
01:15:37.714 - 01:16:37.020, Speaker F: Yeah, sure. I think we do have security plans and security definitely the first priority for scroll because stakes are locked in smart contract and for us we do have security plans and there is no antidotes for repeated and more throughout auditing. But besides that, we are going to have an in house security team and the team will keep an eye on our code all the time and also collaborate with external auditors for safety as well. And also it's fixed for now because all the transactions will be executed using this existing client implementation. We don't even implement a new ZK executor to execute our transaction, so it's very hard for any attacker to attack our system since they can't run this sequencer themselves. That's the first place. Secondly, that is existing implementation, and also they have no chance to generate fake proof for this fake trace.
01:16:37.020 - 01:17:39.324, Speaker F: That's one aspect. And secondly, that as mentioned, there are definitely trade offs between open source very early or very late. But scroll is built on an entirely open source foundation, even including the proving stack of Halo two, which is many eyes on that, including the zcash. And for example like community developer from Zeropark and even Fellcoin want to reuse the same pooling stack and even sometimes reuse code base. So more broadly, we believe that using this community standard will be the most robust way to write security code and secure our whole code base and secure the security of our oral system. And for the upgrade case, I think we will implement a sufficiently robust system before the sequencer is decentralized using some time delay, which makes sure that users will have enough time before this smart contract upgrading. And in the long run we will progressively add this decentralization and become more permissionless.
01:17:39.324 - 01:17:47.410, Speaker F: But it's in the long run because decentralization is at different levels. Like first we decentralize approver and then we consider the overall system.
01:17:48.660 - 01:17:54.720, Speaker B: Well, gentlemen, thank you so much for all of your time. I know we've gone a little bit over Ben, do you feel like you've got all of your questions answered?
01:17:54.800 - 01:18:01.384, Speaker D: Oh my goodness. I had all the questions answered. They spawn more as they always do, David, but I feel like a good place to pause as any.
01:18:01.502 - 01:18:23.730, Speaker B: Well, I think the story of the ZKevms is going. We're just at the very, very beginning, so there will be plenty of Zke EVM content as the story progresses. So Alex, yay, thank you so much for joining me and also Ben, my technical co moderator, here to helping us unpack at the very start of this very long story of the CKE EvM. So thank you to.
01:18:24.820 - 01:18:28.304, Speaker G: Thank you, David, Ben, and yeah, thanks for hosting us.
01:18:28.342 - 01:18:29.036, Speaker F: Thanks Alex.
01:18:29.148 - 01:18:32.080, Speaker B: Of course, go for it, Alex.
01:18:32.500 - 01:18:35.668, Speaker G: Just want to say see you guys on minute in 87 days.
01:18:35.754 - 01:18:48.330, Speaker B: Oh yeah, absolutely. Well, actually, before I sign off, can we do a speed run through the roadmap for each of you? Alex, main net in 87 days. Is there anything else about your guys'roadmap that you want to talk about?
01:18:49.900 - 01:19:15.984, Speaker G: We're now completely focused on launching mainet. Testnet is up. If you want to be one of the first projects launching main net and we're going to follow the fair launch policy, you should get on our testnet now and start building. And for the next features that are coming, there are some really interesting things and can talk about them yet, but I will just say that layer three is a lot closer than many people think.
01:19:16.102 - 01:19:21.068, Speaker B: Well, I can see that very slight smile on your face, so that's getting me excited there. Alex.
01:19:21.164 - 01:19:21.436, Speaker F: Yay.
01:19:21.468 - 01:19:25.764, Speaker B: What about you and scroll? What's the scroll team's high level roadmap? Can you speed run us through?
01:19:25.962 - 01:20:15.100, Speaker F: Yeah, sure. I think for our release philosophy, we are progressively releasing more functionality to test so we can fix any bugs and any Ux difficulties early and often towards a more robust infrastructure test of time. So currently we are at the stage of pre Alpha testnet. It's running internally right now with real live decay proofs. And we pre deploy some applications like swap for user to interact with. They can see their transactions being processed on layer two and then finalized on layer one with a proof through Explorer. And if you want to be the first batch of users again, like sign up our testnet at signup scroll IO and the next step will be a more permissionless alpha testnet where developers can deploy their smart contract and anyone can interact with applications on scroll.
01:20:15.100 - 01:20:37.290, Speaker F: It doesn't need any sign up. You can directly use your metamask to interact with scroll using any interface you like and you are familiar with. And we are testing our functionalities for now and it will be released soon. And also in further release, anyone will be able to run the progress at home to provide computation power for us. So that's roughly our plan.
01:20:38.060 - 01:20:41.020, Speaker B: Yeah. Will there be a scroll token?
01:20:41.760 - 01:21:07.396, Speaker F: Yeah, that's a good question. So we are focused on building and we are thinking on long term scale and want to be extremely thoughtful about how to foster a sustainable community of user and developers. And I think we can learn a lot of license from optimism and polygon, which is only two layer, you know, already launched their tokens, but currently we are still focused on building the best solution. Technically. Yeah.
01:21:07.498 - 01:21:11.220, Speaker B: Okay. And then Alex, same question to you. Is there going to be a ZK sync token?
01:21:11.960 - 01:21:14.512, Speaker G: There might be a ZK sync token, indeed.
01:21:14.576 - 01:21:25.316, Speaker B: I had an idea. Awesome. Thank you guys so much for joining me. Risk and disclaimers, of course. Crypto is risky, ETH is risky. Bitcoin is risky. Layer twos are risky.
01:21:25.316 - 01:21:40.940, Speaker B: We didn't get to the conversation of bridges, but bridges are also risky. But they're less risky if you go to a cryptographic bridge rather than a cross chain bridge. But you can still lose what you put in. We are heading west. We're on the frontier. It's not for everyone. But we are glad you are with us on the bankless journey.
01:21:40.940 - 01:21:42.540, Speaker B: Thanks a lot. Bye.
