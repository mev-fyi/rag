00:00:00.250 - 00:00:33.666, Speaker A: My friend Citadel, who I have this custom relationship with, and I'm just going to fill all of these priority orders with them. They're going to sit at a higher priority of packet than any normal person coming from the source chain. It doesn't matter what order they submitted. It doesn't matter that they were later in the queue. I'm going to fill them on the destination side because I'm more economically incentivized to do. I think you're going to end up with a world that potentially is a worse financial system than the world that we have today because of a lot of this. And so I think if you're going to go down that route, you should care deeply, deeply, deeply about the properties of the underlying messaging layer.
00:00:33.666 - 00:00:35.350, Speaker A: And I don't think enough people do right now.
00:00:35.420 - 00:00:56.654, Speaker B: Hey everyone, this episode is brought to you by, say, the blazing fast parallelized blockchain which is unlocking Salana like performance for the vast ocean of Eth devs out there. Now you're going to be hearing all about, say, and their new v two upgrade. But if you take away one thing, the EVM is here to stay. There are some problems with it which we're going to get into later in the episode. But say, and especially their v two upgrade is helping solve that.
00:00:56.692 - 00:00:57.998, Speaker C: So thank you very much, say, for.
00:00:58.004 - 00:01:28.086, Speaker B: Making this episode possible. Hey everyone, this episode is brought to you by uniswap, delivering the best on chain trading experience in crypto, period, bar none. One thing I want to call out is the uniswap extension, so say goodbye. These days of these annoying sort of pop up wallet extensions, you lose your place trading, you have to open it back up. Uniswap now has a nice, sleek sidebar that persists no matter where you are on the web. It's much easier to use if you click the link at the bottom of this episode. You can join the waiting list and I'll see what I can do to get you moved up that waiting list.
00:01:28.086 - 00:01:29.974, Speaker B: But definitely go click the link, check it out.
00:01:30.012 - 00:01:31.426, Speaker C: All right, everyone, welcome back to another.
00:01:31.468 - 00:01:32.646, Speaker A: Episode of Bell Curve.
00:01:32.678 - 00:01:34.294, Speaker C: Before we jump in, quick disclaimer.
00:01:34.342 - 00:01:36.054, Speaker D: The views expressed by my co host.
00:01:36.102 - 00:01:38.474, Speaker B: Today are their personal views, and they.
00:01:38.512 - 00:01:46.222, Speaker D: Do not represent the views of any organization with which the co hosts are associated with. Nothing in the episode is construed or.
00:01:46.276 - 00:01:51.402, Speaker C: Relied upon as financial, technical, tax, legal, or other advice.
00:01:51.466 - 00:01:54.270, Speaker D: You know the deal. Now let's jump into the episode.
00:01:56.130 - 00:02:10.438, Speaker C: All right, everyone, welcome back to another episode of Bell Curve. This is a very special episode which has been in the works for a long time. Very excited to introduce my co host for this season, Hart. And today we are joined by Brian Pellegrino of Layer Zero. Brian, welcome to show.
00:02:10.604 - 00:02:12.600, Speaker A: Thanks so much. Happy to be here.
00:02:13.370 - 00:02:17.640, Speaker D: This is going to be great. Yeah, thanks for setting us up, Mike. It's going to be great.
00:02:18.970 - 00:02:42.842, Speaker C: Hey, this is my pleasure. And frankly, I'm just going to do my best to almost stay out of your guys way. I think, in terms of. This is the interoperability episode, guys. So if you've been following along with us for this entire season, this is of course, the multichain Endgame season. And what we've been asking ourselves is trying to update our mental model in terms of how these many different blockchains are going to speak to one another. And obviously the core concept there is interop.
00:02:42.842 - 00:03:31.920, Speaker C: So basically, for listeners, in terms of an agenda here, what I want to do is kind of tease out from a high level, Brian, your perspective on what this multi chain endgame is going to look like. How are all these different hundreds or thousands or millions of chains going to ultimately end up speaking with another heart? Going to ask the same of you. And we're going to try to tease apart the parts that I think where you guys agree on, which, despite some of the spirited interactions on Twitter, I think there's a lot of agreement actually in both of your worldviews. And then I also want to get into the parts where you disagree and maybe dive in a little bit deeper there. So, Brian, why don't we give the floor to you first here, just to start off, can you sort of starting at a high mean? Where do you think we ultimately end up in terms of this world of hundreds or thousands of millions of chains? And how are those chains ultimately going to end up speaking to one another?
00:03:32.370 - 00:04:31.860, Speaker A: Yeah, again, we try to stay pretty unimpininated in terms of what the end outcome will look like for us. It doesn't matter if it's literally 1000 completely orthogonal layer ones, or like ethereum, only as a settlement layer and a ton of layer twos. I think the goal for layer zero is to build the lowest level possible primitive of the highest possible utility. Right? Like, that's the function, that's the framing we use when we think about the world. And I think when you think about that, you think about how should that thing actually be built? So if these things, you have a bunch of random state machines or like, execution environments that exist, how should they talk to each other? What should that look like? What properties does that transport layer need to have. I think those are the things we care and focus on. I'm very strongly opinionated in terms of what properties that layer needs to have in order to achieve kind of the end state that I think all of us want.
00:04:31.860 - 00:04:41.960, Speaker A: So I don't think it matters what that is, whether it's 1000 or a million or literally just ten. I think you need the co communication no matter what.
00:04:42.650 - 00:04:52.262, Speaker C: Yeah, you have this really great analogy, Brennan, I've heard you describe sort of the birth of the Internet and comparing it to the development of crypto as it is today.
00:04:52.316 - 00:04:52.486, Speaker D: Right?
00:04:52.508 - 00:05:29.022, Speaker C: There was kind of like in the beginning, there's kind of little computer clusters, whether that's at UC Berkeley, and then there was ARpANEt, and those things didn't really talk to one another. And even in the early days of the Internet, you had these sort of competing corporate intranets where these corporations are trying to put everyone on their same structure. And I've heard you compare layer zero, the protocol almost to sort of the most open, sort of permissionless thing that ended up winning, which was TCP IP. So can we get into that a little bit, talk a little bit about that? Kind of like early days of the Internet. How is that similar to where we are today? And then where would layer zero sort of fit within the sort of analog Internet context?
00:05:29.086 - 00:06:13.358, Speaker A: Yeah, sure. So, yeah, early days we had a bunch of intranets, right, which are just distributed execution environments. You had DARPA, you had Stanford, you had all of these different clusters, right? And if you wanted to take some data and process it, you want to do some computation, you'd literally take your floppy disk and you would fly to Stanford and you'd pop it in and run it, and then you'd have your results back, right? And then eventually we invented this very nice stack, the Internet stack, and allowed these things to talk to each other. And that basically became the Internet. And the primitive of the Internet is effectively a packet. It's just like do some compute on chain a, take those bytes that are generated from that compute, move the bytes and then do something with those bytes on the other side. Layer zero is arbitrary contract invocation with the bytes array.
00:06:13.358 - 00:06:53.854, Speaker A: It's invoke a contract here and generate some bytes, move the bytes and invoke a contract on the destination chain with the bytes. And so I think that is effectively a transport layer. And so when you walk down, what properties do you want that to have? That's where I think it actually becomes very interesting because I think a lot of the space was built on immutable permissionless, censorship resistant. Right. Those are the three primary properties that I think most things in the space were built around. And I think when you talk about how you actually build that layer and what it means, and we can walk through this throughout the episode because I think it's going to come up quite a bit. There's so many problematic structures that you get into if you lose any of those three properties.
00:06:53.854 - 00:07:18.754, Speaker A: And I think for us, the goal is, again, that primitive is all that we want. Layer zero, it's not trying to be. CCIP is a dumb protocol. It's incredibly powerful. Layer zero is meant to be reasonably dumb in the sense that it doesn't add a lot into an individual packet. Right. Anything that you can do on any blockchain, any amount of bytes that you can generate, that can be processed by another blockchain.
00:07:18.754 - 00:08:10.310, Speaker A: So, like, the two blockchains are compatible in terms of size of payload, you can do over layer zero, there's nothing added, there's no restrictions. All of that is there? And then I think it's really about that, how you build those systems that matter so much. And I think for us, and again, I think we should get into this, but we really try to focus on pure infrastructure. And I think a lot of other people are focusing on becoming a service provider. And like you talk about early Internet, Microsoft, everybody had their own version, the information superhighway. There are all these different privatized versions of trying to basically make this. And the thing that won was the thing that was both most open and least like a service provider, let's say least like a privatized Internet.
00:08:10.890 - 00:08:25.390, Speaker C: I want to turn it over to you in a second here, but Brian, could you say just a couple more words about that for folks in the audience? When you say the difference between layer zero trying to provide infrastructure versus others that are trying to be a service provider, do you dive into what that means a little bit more?
00:08:25.460 - 00:08:46.710, Speaker A: 100%. When we built layer zero, there were those three main tenets. Immutable sensors are persistent, permissionless. Right. And so what that means is when layer zero deploys an endpoint, that code is entirely immutable. We can never change it, and most importantly, we can never remove it. Once it lives on a system, it will be there in perpetuity or until the chain itself makes breaking changes.
00:08:46.710 - 00:09:05.802, Speaker A: Right. So when ETh moves, like, to vertical trees, and we're using the original proofing, there might be a new endpoint there. Everything else will be forever. Anybody can come in. So permissionless side, anybody can come in and run the infrastructure. So when you think about like. And this gets into.
00:09:05.802 - 00:09:33.682, Speaker A: And again, we can go down this road. In the modular thesis, when you talk about a world of thousands or tens of thousands of chains or millions of chains, every chain is beholden. If you take a system. So other systems, wormhole, Axelar, all these other systems that exist, what they're selling is a validator set. They're selling trust, right? And so here's a validator set. Our 19 validators, our 75 validators, or stake whatever it is, here is a set of trust that is willing to be priced. And then here's a transport layer on top of that.
00:09:33.682 - 00:10:11.034, Speaker A: The problem with that hub and spoke model is that all of the work falls on them basically to do in the deployments and to continue to support. And at any point in time, whether it's them, whether it's chainlink, wherever it is, they have the ability to say, we will no longer support this chain. It's not economically worth it for us to support this anymore, and there's nothing that chain can do about it. The power always relies on the economic viability for the central system. With layer zero, when there is an endpoint, anybody can run that infrastructure forever. There's one app, who cares? That application can go and run it itself. If the chain itself wants to run it, it will always be available, and anybody can run any piece of the stack.
00:10:11.034 - 00:10:36.306, Speaker A: And that is like a hugely different. So we say this really nicely in the white paper. Layerser is the only system that allows the applications, by proxy, the chains, to reason long term about both the security and liveness properties of the protocol. Everything else is basically up to date. So all of these other systems are effectively, they're providing something very similar. If you take it at face value. They're moving bytes.
00:10:36.306 - 00:11:15.006, Speaker A: Everybody's trying to move bytes. The difference is, are you a service provider? Are you reliant on that third party to do things? And is there any case where you don't need to be reliant on that third party? And layer zero lab still does a bunch. We run an executor, we're active within the network, but you're not reliant on us. Anybody can run that infrastructure. If we disappeared from the face of the earth today, if the government came and effectively issued an order that says, you cannot run this anymore, we got censored in one way or another. We cannot affect an application who chooses to basically be separate from that. The protocol will live forever, and it is truly meant to be immutable.
00:11:15.006 - 00:11:18.050, Speaker A: Rails, immutable infrastructure in perpetuity.
00:11:20.550 - 00:11:41.100, Speaker C: Yeah, I think that's a really critical thing to point out. And I think one of the things that people misunderstand about layer zero is they maybe see layer zero competing directly with like CCTP or axilar or something like that. Whereas you just my understanding, right brand, correct me if I'm wrong, is you belong in a very different place in the stack and in this.
00:11:43.470 - 00:12:21.706, Speaker A: Very easy to confuse, because people like to, they want to create a similar mental model. They are selling the model of trust. That is a problem they're trying to solve, is creating, let's say trust minimized, the most trust minimized validation set, right, that everyone is trying to solve the verification layer, and we're agnostic to the verification layer. We actually think over time, it becomes extremely commoditized down. We think, one, we did not think it's practical to be opinionated early on. The model has already changed drastically. You see people shifting from what was considered optimistic messaging was like a very big thing for a while.
00:12:21.706 - 00:12:44.414, Speaker A: There's all these different paths of nomads, salv optimistic messaging. There's a very different path of going down this route. And so we've always been extremely unappinioned. We're not solving, we don't have a validator set that we're telling you is the right one. You can fit any validator set in. Any of those people I name Axelar, warml, et cetera, can be used within layer zero. Layer zero is focused on the transport layer only.
00:12:44.414 - 00:12:46.180, Speaker A: That is the thing that we care about.
00:12:47.590 - 00:13:22.186, Speaker C: Cool. Yeah. And I think actually, for folks following along at home, maybe one analogy, Brian, and you can push back if this isn't necessarily correct, but there was a discussion a little while ago about almost like Uniswap labs, the front end and the back end protocol and the backend is this kind of like immutable, censorship resistant protocol. And then there were different service providing entities, in this case, Uniswap labs, which built a front end on top. So in this case, layer zero is aspiring to build the sort of back end, immutable part. And I love the fact that you really honed in on those sorts of characteristics about what makes blockchain special. So if I could maybe try to sum up.
00:13:22.186 - 00:13:52.822, Speaker C: And then, Hart, I want to turn it over to you to get your sort of vision of the future here. But basically, Brian, what I heard you say, know, going back to this analogy of the Internet, what we ultimately had at one point was this kind of discrete sets of different computing networks. And we needed a way to unify all of them. Because where we're ultimately going to drive to here is the user doesn't really care. They don't care if they're sending work to be done by a computing set at Berkeley or this other computing set. It just needs to feel like this integrated, holistic experience. Right.
00:13:52.876 - 00:13:53.798, Speaker B: But we want to find a way.
00:13:53.804 - 00:14:05.130, Speaker C: To do that while preserving, like in blockchain land, these really desirable properties of immutability, censorship, resistance, et cetera. Is that about the right way to describe?
00:14:06.030 - 00:14:20.526, Speaker A: Yes, only that I don't think in the early days the focus wasn't on this needs to feel amazing, this needs to feel, et cetera. Right. All of those things came down like economic incentive. Right. The goal was that it was actually useful. There was some net utility for being able to do that. Right.
00:14:20.526 - 00:14:40.086, Speaker A: It made the world, the systems, et cetera, more useful, brought higher utility. So I think that kind of is the early focus and everything else. Like, even these days, most web developers don't care about the Internet stack. They don't care about the lowest level stuff. Everything just gets abstracted away up once you have a sufficient amount of utility for worthwhile systems to be built.
00:14:40.268 - 00:14:42.120, Speaker C: Absolutely. That's a great point.
00:14:42.570 - 00:15:01.834, Speaker D: Yeah. Well, I was just going to joke for a second, but the idea of the era of the information superhighway with, I think that was Al Gore's phrase, and floppy disks, those all happened before most of our listeners were born, I think. So Ux was not the major consideration. Mike, go ahead.
00:15:02.032 - 00:15:28.942, Speaker C: No, I was just going to say I completely agree with that. There's a great. You can actually go back in time and find some really awesome Time magazine cover articles about the information superhighway and some of the visuals that just turned out to not actually make all that much sense, but maybe felt intuitive at the time. Hart, I want to ask you the same question we asked Brian. So we got sort of Brian's vision about being relatively agnostic about how some of this stuff plays out by providing this sort of low level transportation layer.
00:15:29.086 - 00:15:29.906, Speaker D: Hart, walk us through.
00:15:29.928 - 00:15:39.960, Speaker C: I've asked you this question on the season before, but maybe for the audience that hasn't heard this at this point, where are we headed in terms of tens, hundreds, thousands of chains? And ultimately, how are those chains going to speak to each other?
00:15:40.590 - 00:16:25.960, Speaker D: Yeah, so one thing I think Brian and I definitely do agree on is like, okay, there's going to be many chains, but whether there's like ten or a million or like 10 million seems very hard to predict and how exactly they play out. Although I do think, Brian, we should spend some time trying to predict it. I think it's an interesting conversation. So we're going to have these chains, we don't exactly know the market structure. The one thing that I think is interesting to push on, and I'll keep it at a high level, and then maybe, Brian, we can get more into how this all works. But this TCIP analogy, I've been thinking about this a little bit more recently, and I like it, and I like the idea. And there's definitely this need to connect blockchains at a low level.
00:16:25.960 - 00:17:31.806, Speaker D: But we aren't just moving bytes, or at least not most of the time. We're also kind of moving money or moving value. And so one of the things I sometimes wonder is if the better analogy is more like connecting banks, like corresponding banking systems that need to be connected versus connecting intranets. And my reasoning, or my idea here is, if you think of remittance payments like western unions, you're trying to send money from the US to the Philippines in a remittance sense. It's not like every time someone in the US sends money to the Philippines, there's an international wire that gets sent in the banking system. Like Western Union batches together. These payments, they make the payments in real time, and they send like the international wire equivalent once a day or once a week, probably, but they don't send a floppy disk, although we're talking a very old school way here, too.
00:17:31.806 - 00:18:02.738, Speaker D: But I'm just using the example of, generally speaking, you have something fungible, which is money that can be fronted on the destination chain. And maybe because of this property, you actually want to front things, kind of make loans on the destination chain. This is going to lead into kind of my views on intents. Maybe we want to actually front things on the destination chain and batch them together and verify that settlement more slowly.
00:18:02.914 - 00:18:26.334, Speaker A: Yeah, it's functionally just a question of how many messages get sent. And all of these models, like there needs to be state basically being moved. And so you say there's a difference of moving money and moving data. To me, it's the same thing. When we got into the space originally, there were just bridges. There wasn't like universal message, it didn't exist. And our basic thesis early on was, it's the exact same thing.
00:18:26.334 - 00:19:08.282, Speaker A: Like moving assets is basically just a subset of that. That was basically the foundation of the oft was like, why are there third party bridges that are doing this when the token itself can literally be the bridge internally you can move 100 million rather than paying 6810, twelve bips to an external bridging provider. The token itself effectively can provide $100 million for the cost of gas. You're moving hundreds of millions of dollars for subscent. And then that layer of efficiency is such a world of difference, of needing to rely on any of this other stuff. So I think fundamentally they are the same thing. It's just like whether you're batching or creating this external social contract or all of this stuff, you all need a way to move state to be able to do that.
00:19:08.282 - 00:19:10.750, Speaker A: That's the fundamental problem that's being solved.
00:19:11.730 - 00:19:56.460, Speaker D: Well, I think that's exactly the conversation I want to have with you, which is predicting how many messages are getting sent. Because I think that really does really color what the end game is for this multichain world here. And so I fully agree you are sending messages in some way, shape or form, but this question of how many is very different. And maybe that's where we can lean into this intense thing, which is not something I've actually heard you talk about. So I'm actually very curious to get your views on this. And so to back up for a second my mental model of how you connect to blockchains. We have blockchain a and b, and I want to send value between a and b.
00:19:56.460 - 00:20:24.418, Speaker D: And one way to do that is you send a message. And this is sort of the layer zero approach. Although you can push me on this, but send a message from a to b, and you want to do that quickly, cheaply and securely. And then as I understand your worldview as this transport layer, you let the application specify their security properties, but it's still difficult to send that message quickly, cheaply and securely, this is a hard thing to do all at once.
00:20:24.584 - 00:21:21.320, Speaker A: So functionally what you're actually doing, like, you can describe it as a message, but really what's happening is some state is written to chain a and its intent is on chain b. You need to prove that state, right? Like if you're going to mutate state on chain b based on something that has happened on chain a, you need to have a couple of things. You need to be reasonably certain that chain a is in a final state or has reached an economic position and probabilistic finality such that it would cost more to basically unwind. Everything is basically based in that. So if you are issuing credit in a lending protocol and somebody has deposited x here and they want to remove $50 million on the other side because they deposited $100 million here, you have to be pretty certain that the deposit actually went through and that that's not going to get reorbed out. Because once you give the money on the destination chain, unlike a layer one, which has the ability to roll it back, you have no ability to roll back this state. Right.
00:21:21.320 - 00:22:09.782, Speaker A: And so really what you're trying to do is prove state to the best possible degree for a destination mutation based on some state of source. And so whether you want to do that by somebody just optimistically doing a bunch of x on this chain and then saying, hey, we're going to roll back, and if I did it right, I can prove it in the opposite direction. Or if you want to batch it a ton to reduce the sort of friction or cost of moving that. All of those are like viable methods to basically reducing the number of times you do that because there is latency and finality on a given source chain, and there is cost because you're buying block space to basically write the transaction. Right. Both of those things are very batchable or avoidable. Everything with async systems, it's basically a property of the source chain itself.
00:22:09.782 - 00:22:27.420, Speaker A: The source chain was 100 milliseconds and one 1000th of a penny. Then you would have zero reason to ever do that. You just send messages immediately. Right. The property that you describe is a property with the underlying source chain, not with the system as an intermediate system.
00:22:27.790 - 00:23:03.320, Speaker D: Yeah, I think that's right. So it's like your source chain does not have instant finality. It has some times of finality and some maybe probabilistic decay around how that finality looks. And there is also some cost to sending a message, right? So this is the environments you're constrained by. So the path that I'm super bowled up on is this intent based model where you introduce this third party. And so this third party, we call them a relayer, call it a filler, call it a solver. It doesn't really matter what it is.
00:23:03.320 - 00:24:00.826, Speaker D: And the thing that makes this so interesting, and you can't do this in the TCP IP world, but because we're moving value at least most of the time, and we can also talk about whether messaging is going to be moving value or moving information in the future. And there is use cases for both. But because you're moving value most of the time, you can actually have this third party, this relayer, go and front the user out of their own balance sheet, their fill on the destination chain. And you can have this happen in this intent model where the user is filled quickly, and I want to go into why I think this is cheap and secure users filled quickly, and then what the protocol is doing is escrowing their user funds and releasing them back to the user only if that intent is verified as fulfilled. And so go a little bit deeper. But I think we can talk about how this gets around some of your finality constraints. And I think what layer zero is doing.
00:24:00.826 - 00:24:35.830, Speaker D: You have interesting ideas here too, but I think this sidesteps your finality constraints and can also make things really cheap too. While maximizing security, it does not avoid messaging. You still need the ability to message, but at the extreme case, I think the amount of messaging you do might be like three or four orders of magnitude lower than if you send a message per transaction. So, yeah, I don't know. I can kind of want to go deeper in this, but what have you guys been thinking at layer zero around this intent like framework?
00:24:36.410 - 00:24:58.730, Speaker A: I think the way that we view it is an intense system can be built on any messaging layer, functionally. Like, functionally, intents can't solve interrupt. Intents need interrupt. Right? So intense is an optimization on top of it. Yeah, it's like atomic swap plus. Plus, basically. Right? Like you're basically saying here is this function for somebody optimistically settling something.
00:24:58.730 - 00:25:42.742, Speaker A: And then on the back end, we need to prove that state and lps are basically taking the risk. Lps, like the relayers providers, the time value of capital, that's basically what they're pricing. They're pricing needing to keep inventory on these chains, or having inventory on chains, and the time value of capital in terms of the settlement period to get it back in terms of when the message comes back. But the difference is that interop, so if you believe in that world and that that's going to be like a dominant function, it means that there will not be a significant amount of messages that are state. You'll never have applications that develop to have state across multiple blockchains. You'll never have things that progress in terms of actual general message passing. And I think that's a thesis that we believe in very strongly.
00:25:42.742 - 00:26:21.186, Speaker A: So I think intense systems can live on top of a great interoperability protocol, but intents can't solve the interop piece. And so, intents, as we view it, are like an optimization, a way that you can try to create an optimization in liquidity on top of a system, but you still need the underlying system. And again, the underlying system is like what we're trying to solve for intents are just a way to batch or to optimistically settle this stuff. But it doesn't solve the underlying problem of the transport or of the transport layer at all. And so the best intense system can't do interop. So we just view it as a layer that sits above. It's effectively a bridging layer.
00:26:21.186 - 00:26:49.310, Speaker A: And you can build any number of bridging layers on top of layers or on top of a messaging protocol. You still need to solve the messaging protocol piece itself, because you need a way to basically prove the state, hey, all this stuff happens. I want to unlock the money for the person who optimistically settled over there on source, and you're still trusting that system to basically report back directly. Otherwise the relayers are all getting rubbed. Right. Functionally, you still need to be able to prove state on chain b back on chain a, which relies on interop solution.
00:26:49.890 - 00:27:30.934, Speaker D: Yeah, I guess where I'd push on is I'm not sure I agree with the statement it doesn't solve interop. I agree with you that it still has the requirement that there is some underlying messaging system that exists and has to get used in certain cases. But I think in this intent framework, we can have a user, obviously bridge value, and we can have them bridge value and execute action. So it's like this sort of a chain abstraction concept where I want my intent is go. And one example I like to use actually is poker chain. This doesn't relate to your past. This is just something I bring up where I want to have poker chain.
00:27:30.934 - 00:27:53.300, Speaker D: It's my application where I'm betting poker. And I want to control it from my home wallet. And so I sign an intent that's like bet $5 on this hand, and I have quick interop that goes and executes that. It moves value and executes an action. You could have intents bridge user ops in an account abstraction sense to go sign something.
00:27:53.750 - 00:28:26.974, Speaker A: The easy counterexample is like I'm a lending protocol that lives on chain. I live on some long tail chain, right? I don't have deep liquidity. I don't actually know the global states in the market. I want to go fetch the current price of something and process a liquidation based on that. I'm now splitting across my storage, right? My storage lives in some other layer and I want to go fetch something like that. Can't be. So you can't have an application that actually needs or relies on state or through an action mutates state or does any of those things.
00:28:26.974 - 00:29:15.914, Speaker A: In an intent based system. You need a way to prove something has happened on chain a to be able to trigger it on chain b. And again, even on the intent system, like in all these things, you sign a message that does x, you need somebody, some way to say that that thing that you signed is a canonical block on the source chain. Otherwise you can just basically rug endlessly if you're affecting, if you're mutating any other part of the system. So like an account abstraction, yes, you can sign a message for yourself doing your own thing on the other chain, which you could just go and sign it yourself. But if I'm signing a message that is going to mutate an overall system, executing a trade, I'm doing something in state, something needs to move that, improve that. And again, with the across model, everybody is front loading these transactions where the users want to do a swap or bridge.
00:29:15.914 - 00:29:37.294, Speaker A: Like we're giving it over here, we're giving it over here. A bunch of money has been locked over on the source chain. I need some way to say I fulfilled my duty over here. Please unlock the money on the source chain. Right. And if you don't have where that is corrupted, the entire system is broken. It relies on that functionally, like you need that piece for it to be able to exist.
00:29:37.294 - 00:29:39.814, Speaker A: If you can't prove that, you can never have the system.
00:29:40.012 - 00:30:40.154, Speaker D: Yes, I agree with that. And I guess there's actually two things I want to push on. So one, I also fully agree with the, like, if you want to do a cross chain lending protocol, I think I could probably design a weird way where you have people front capital and do this kind of like intent thing, but it would be really capital inefficient and wouldn't really work. I do agree with you that for those types of applications where you really need to observe state on other chains in almost real time, or basically real time, you have to lock state between chains to do things like in a cross chain lending market, you will need to be sending messages between chains. One point that I think we can come back to a little bit later when we talk about the structure of this multichain endgame is how many applications look like that. This is an open question I have that I'd be just genuinely curious to get your thoughts on versus how many applications are kind of like more roll up specific. So it's kind of one point that I'd like to come back to.
00:30:40.154 - 00:32:04.530, Speaker D: And then I think the other thing that's worth sharing with our listeners is, let's say we agree that this intense system is an optimization for types of transactions like bridging or bridging and swapping or whatever else, I think it is worth thinking through what the advantages of this optimization are. Again, in the vein of what does the end state look like? Is this optimization important enough that it's actually a very important layer in of itself that still requires the messaging layer below it? And one way that I think is kind of clarifying to do this concretely, this has been examples I've been using, is we talk about bridging or bridging and swapping $30 million. So this is something like Stargate does pretty regularly across does, too. And what are the overall costs of bridging and swapping? $30 million. And right now, if you're going to bridge and swap $30 million over, let's say there's like 10,000 transactions, there's 10,000 bridges that add up to the $30 million. You are going to have 10,000 deposit transactions on your origin chain and 10,000 fill transactions on your destination chain. That is, like, unavoidable.
00:32:05.910 - 00:32:47.214, Speaker A: That's only in the current method. Right? So this is like, functionally, it's kind of the nature of building immutable systems, right? All of these comments that everyone has gone on the bridging side is based on a version of Stargate that's like two full years old, right? Immutable can never be changed across, just was upgraded. Like, there's all of these upgrade paths along the way to try to improve it. Stargate doesn't have that. Immutable from day one has never changed. The only real optimization that you're describing is batching, right? Functionally, you're saying, here's a system for taking the underlying base messages and saying, the cost, the large bulk of Stargate costs right now comes from doing messaging. It comes from like, oh, you have to write an ETh transaction and write this transaction.
00:32:47.214 - 00:33:09.634, Speaker A: So if you're sending 50 messages, you're writing 50 ETh transactions, and that's very expensive. And if you can batch that into a single transaction, it will be cheaper. I 100% agree. And I think most systems are moving to this. You see batching becoming much more commonplace in general. But again, that's a bridging layer, right? That's a Stargate thing. It's a thing that lives above for us layers.
00:33:09.634 - 00:33:16.886, Speaker A: We're very focused on the transport layer itself, not the bridging layer. We think bridging is just a special case of generic messaging.
00:33:17.078 - 00:33:56.658, Speaker D: Well, that might be something that we talk about more over the episode, too, but just go back for a second. So first of all, across, also until this past week, it was 18 months old. Our code on chain hadn't changed either. All the optimizations were on the off chain fills that have happened, like all purely just relayers competing to fill users. But what I was actually talking about that I think you do agree with in the bridging or swapping use case. And users want to move value between chains in any way. Like baseline of any system, there is going to be a transaction a user has to make to deposit their assets on the origin chain.
00:33:56.658 - 00:34:09.482, Speaker D: And there's going to be a transaction that the protocol or a relayer or somebody has to make to fill the user on the destination chain. That is like unavoidable gas costs. You can't actually move value between chains without them. You agree with that?
00:34:09.616 - 00:34:11.878, Speaker A: Yes, there's a transfer on both sides.
00:34:11.974 - 00:34:32.786, Speaker D: There's a transfer on both sides, right? So you agree with that. So then the question is, okay, well, if we're moving $30 million over the course of the day through 10,000 transactions, and it sounds like you also generally agree, what is the most effective, cheapest way to move that $30 million over 10,000 transactions, what's the most effective way to do that?
00:34:32.888 - 00:34:39.138, Speaker A: Is the most effective, or is it the safest? Right. What are we optimizing for as like an overall system?
00:34:39.224 - 00:35:04.414, Speaker B: Hi, everyone. Wanted to give a big shout out to today's title sponsor. Say, now I want to talk to you guys a little bit about why I think Sei is cool from a design standpoint. A big problem that it solves for e devs out there and then some cool stuff that say, has coming up. The reason I like say from an architecture perspective is, again, it's a very fast blockchain, parallelization, all of that stuff. But Sei has essentially been custom building block space, which is for consumer apps and dexes. Now, they have some very cool features which enable that.
00:35:04.414 - 00:35:28.598, Speaker B: So twin turbo, consensus, optimistic parallelization, SADB, all of this stuff allows you to reduce the time to finality, make for very, very fast transactions. So if you're building a consumer app or a Dex, this is basically the blockchain for you. If you've been building in the EVM, you love the EVM, but there are some restrictions about it that don't support your app. So maybe you can't do fast enough transactions or it's not parallel lies, whatever it is. You can now take all that stuff that you built, you don't have to.
00:35:28.604 - 00:35:29.734, Speaker C: Start from scratch, and you can build.
00:35:29.772 - 00:35:38.178, Speaker B: It on, say, now, recently, they've launched v two, but also public Devnet. So the way that you can follow that and keep up to date is go and follow, say, network on Twitter.
00:35:38.274 - 00:36:21.910, Speaker C: All right, thanks, guys. I was actually going to say that's where I'm sort of shaking out as someone who's less in the weeds, the two of you, maybe. To try to sum up, what I think we're describing here is I actually think we're describing a pretty holistic system where we need to move value and data across multiple different chains. And there's ultimately at the end state, even though, like Hart, you and I have talked quite a bit about this intense sort of framework where maybe sort of, I don't want to say middlemen, but like kind of facilitators, right, can front capital and make things a lot sort of cheaper and more efficient. Ultimately, these things still need to be reconciled on chain. And that's, I think, what the sort of lower layer of the stack that Brian is describing. And I guess, honestly, just hearing about it, I hadn't really thought about this in these terms.
00:36:21.910 - 00:37:11.638, Speaker C: So. Always dangerous to think out loud. I could be wrong, but it seems like there's a little bit of a spectrum here where it actually might be safer to do, like a purely on chain type system where we're not relying on these intermediaries to front capital. But what we might be sacrificing there is it's not the most efficient thing to do, especially if a lot of these transactions want to get originated on Ethereum. There's obviously a lot of gas costs there. And so we want to figure out how much responsibility do we want to give to this optimization layer where maybe they could make things a little bit more user friendly, a little bit cheaper. But like heart, something you and I have also talked about is, do we ultimately, we're going to at some point talk about this during this episode, but is that a desirable end state for crypto, right, that we have a couple of large market makers sitting in the middle, facilitating a whole bunch of these transactions? And I think that's a conversation, to be honest.
00:37:11.804 - 00:37:40.190, Speaker A: Functionally, what you're sacrificing is liveness, right. When Stargate was built, and again, the goal should be to talk about layers are an interop, not like Stargate versus cross site. And I think bridging is interesting, but I think it's like an application on top of messaging, which is less interesting than the messaging layer itself. But when Stargate was built, there was this beauty in uniswap. Right? Uniswap has been deployed in a piece of immutable code that is never going to change. Everything was on chain. You knew how to reason about everything.
00:37:40.190 - 00:38:01.650, Speaker A: Nobody could kill the system. There was no external party. There was no, like, a government cannot come down and shut it down. There can't be like a cease and desist. It was, hey, this was this really cyberpunk thing that is going to exist and will be free markets forever. And that in itself is extremely elegant. When Stargate was built, the goal of Stargate was like, these are pools of liquidity that will exist.
00:38:01.650 - 00:38:31.086, Speaker A: Anybody can freely execute a trade. There is no reliance outside of that. Basically, it's meant to be like a closed, immutable system that has pools of liquidity. It's very simple. Just like add here and subtract there. And I think what we've seen over the last couple of years is the market for certain types of transactions, whether there's a bridging, whether there's swapping, whatever it is the market is saying. And maybe the market will go back because it usually says this and then gets hacked and security issues come up, or liveness issues come up and they say, oh, actually those things mattered, or those things didn't matter, right.
00:38:31.086 - 00:39:12.702, Speaker A: Over time, it just depends on the frequency of these events. But I think what the market has shown is if they're not sacrificing security, they're willing to sacrifice liveness guarantees for a cheaper cost. And I think that, functionally, is where the overall market has moved. I think it is. We will take some set of decreasing liveness guarantees in order to have a more efficient execution on a per transaction basis. And I think you see a lot of things moving that way, whether it's RFQ systems, there's Unix, a lot of things have moved down. And that's just like philosophically, whether I agree with that or not, or whether or not I think it is like the right thing, or we're just reinventing another slightly different version of existing financial system.
00:39:12.702 - 00:39:25.778, Speaker A: It doesn't matter right now. That's what the market is voting for, is that we will sacrifice degrees of liveness for this type of transaction if cost is cheaper. And that just is what it is.
00:39:25.944 - 00:40:18.962, Speaker D: And Brian, I agree with that. And I think the narrative arc here is super interesting. And I think even looking at Uniswap here as just the example, Uniswap's done this itself, right? It went from purely on chain in a single chain version to Uniswap X. And their know, my, my mental model for why this has happened is because of this multi chain world where now that you have multiple chains that are asynchronous, it's actually like you don't have the same liveness and execution guarantees, because you have these asynchronous systems that you're trying to unite, and it's messy. And what I think will happen is what you're saying where we're going to have a bunch of off chain actors that are the unifying force of these different chains, and then that's going to evolve five years from now into something else.
00:40:19.096 - 00:41:13.426, Speaker A: So this is where I think it gets extremely dangerous. And this is why I care so much about censorship resistance in a protocol. So one of the biggest problems I have with most other messaging protocols today is that there's no form of censorship resistance. We have this hub and smoke model, and there's no one to one relationship between a transaction on source and a transaction on destination. And what that means is like, packets can be dropped, which is you can see as important in like a vote going through, right? You have a government election or any vote happening. There is no guarantee with any message that is written on source, with any existing system, that those packets will be delivered on destination chain. Like with the layer zero model, everything is non sorter enforced directly in this basically transfer layer, which means that you cannot deliver packet 17 until packet 15 has been verified and is ready to be delivered, which means if you're censoring a single message, you stop the wheel of time for the entire pathway, all of it.
00:41:13.426 - 00:41:58.206, Speaker A: And so it's like you deliver everything, and there's one person that exists in the world who's willing to deliver these, or you do not deliver anything. There is no intermediary of like, hey, we were told because of this we're going to start dropping packets. Like, these people are no longer allowed to transact across this. We don't want their messages to go through every other system that can be allowed. But I think the scarier part for me, the much scarier part is like you think about HFT in the current world. HFT at least is reasonably meritocratic, if you can even say that in the sense that is like, the fastest actor gets to the exchange and front runs the transaction, and it's a cost that's borne by the consumer. You think about it kind of like mev, but there's a wide sort of spread of actors who are trying to race for this, and so they're economically incentivized just doing the first at the transport layer.
00:41:58.206 - 00:42:47.406, Speaker A: If you don't have censorship resistance, you have the ability to reorder every single transaction, which means every transaction going through a line. Now, if I had 100 transactions going through and they each have an mev of one, and I have an extractable surface of 100, I can reorder those transactions to create like an extractable surface of like 250. I can say, hey, actually I have more external incentive by filling my friend Citadel, who I have this custom relationship with, and I'm just going to fill all of these priority orders with them. They're going to sit at a higher priority of packet than any normal person coming from the source chain. It doesn't matter what order they submitted to, doesn't matter that they were later in the queue. I'm going to fill them on the destination side because I'm more economically incentivized to do. I think you're going to end up with a world that potentially is a worse financial system than the world that we have today because of a lot of this.
00:42:47.406 - 00:42:55.826, Speaker A: And so I think if you're going to go down that route, you should care deeply, deeply, deeply about the properties of the underlying messaging layer, and I don't think enough people do right now.
00:42:55.928 - 00:43:36.882, Speaker D: So Brian, I think there's a lot to unpack there, and we should talk about all our tradeoffs here. I want to go back, though, on the censorship resistance point for a second here too, because I care a lot about this as well. However, I think it's a nuanced question, and even in how I understand the layer zero design, in my opinion, and you might find this a spicy take, but the point of censorship resistance moves off of the layer zero protocol to the application itself, because the application, as I understand it, in layer zero, sets their own security stack, and depending on how they upgrade or change that, that can be a point where they could get messed with.
00:43:37.016 - 00:43:37.474, Speaker C: Hey everyone.
00:43:37.512 - 00:44:11.782, Speaker B: This episode is brought to you by Uniswap, delivering the best on chain trading experience, period, bar none, in all of crypto. Here's how I would divide the protocol today. There's a web part, a mobile part, and an extension part. You can say goodbye to the pop up wallet extension, which is just not great from a UX perspective. Now, what they've delivered is this nice, clean sidebar where you can just very easily track swaps, sign transactions, send or receive crypto anywhere. Just a huge UX improvement on the web part of it, huge improvements here you can buy and sell 700 plus tokens at your price on your terms, and they've got limit orders which are powered by Uniswap X. And there's gasless.
00:44:11.782 - 00:44:30.226, Speaker B: They've also got real time charts, transaction logs, pool data, project information, all this cool stuff that just really improves your UX trading on the web. And again, all this is powered by the smartest protocol in terms of Uniswap or Uniswap X. Click the link at the bottom. Uniswap extension is in Alpha right now, and we'll see what you can do about getting you moved up that list. Thank you very much.
00:44:30.248 - 00:45:00.934, Speaker A: Uniswap so is like the way that I view it is Ethereum is meant to be censorship resistant. USDC contract on top of Ethereum can do whatever it wants. It can have a blacklist, it can do whatever it wants internally. That should live at the application layer. I actually like very much the protocol. If you have censorship enabled at the transport layer, it will get censored over a long enough period of time, whether it's through nation states, whether it's through regulation, whatever. That can live at the application layer and applications should comply with regulation.
00:45:00.934 - 00:45:07.178, Speaker A: That should be a thing that naturally happens over time. You should not have it at the technology layer in the same way it's.
00:45:07.194 - 00:45:24.178, Speaker D: Yeah, but I guess this is just the point that I want to push on. I find like saying layer zero solves censorship resistance here. I find it a little bit too much. It pushes it to the application and solving censorship resistance at that layer is extremely difficult depending on what you are and how you do.
00:45:24.264 - 00:45:36.360, Speaker A: I mean, that's like saying Ethereum isn't censorship resistant because circle can censor transactions or addresses like the base level protocol can still be censorship resistant with the application being able to do whatever it wants.
00:45:36.730 - 00:46:36.646, Speaker C: If I could jump in here and maybe just try to sum this up for the listeners, I think there's philosophically, this is going to be a challenge that crypto ultimately ends up running into. It's actually something that I've thought quite a bit about, which is when crypto becomes undeniable from the standpoint of governments, where do governments ultimately fit into these systems that we're building? Right, because you could have this total like, yeah, bitcoin sticks it to the man and the governments are going to crumble and we're going to rise in our. I've never viewed it like that. I've always viewed it as like, ultimately, governments are important stakeholders and they're going to need to fit in. These systems need to conform to laws. And I think what we're asking ourselves here is at what layer of the stack do we need to conform to laws? And I think there's an interesting debate to be had about whether or not that should happen at the very base layer that layer zero operates on, versus maybe the application layer, where people can decide based on their sort of jurisdiction, which is, I feel like what we're getting at. I want to do my moderator duties a little bit here and give you guys a little bit of time to kind of wrap this up.
00:46:36.646 - 00:47:31.290, Speaker C: And then I want to push us into some other areas of the conversation, which is just the amount of the applications that you see in the future. How much do they need interoperability across these many different layers? And are we heading to this world of. We just spoke with Ilya Polishkin of near the last episode. He described this world of unbridging, right where in his sense, he was sort of building a stack that allowed canonical assets to exist on the chain where they were issued and actually minimize the amount of bridging. Whereas I don't know, Brian, in your view, if actually we're heading towards a world where we're mostly going to be interacting with non canonical or wrapped versions of assets, we want to make sure that those are delivered and are structured as safely as they possibly can be. Sorry, I just front ran the next part of this conversation, but so I want to give you guys a chance to wrap up the censorship resistant part here, and then I'm going to push us into the next part of the conversation.
00:47:31.370 - 00:47:44.430, Speaker D: Well, I think your part on the censorship resistance was well said. And I think actually Brian and I might actually agree on know, like, layer zero not being censorship resistance. Fine. Applications still have a job to figure out. Fine. It's complicated. Cool.
00:47:44.430 - 00:47:52.466, Speaker D: Like, I think that's fair. I do think we should talk about the HFT points that Brian brought up too, if that's cool.
00:47:52.648 - 00:48:00.390, Speaker C: Yeah, I'm going to be a hard nose here and say, let's try to get through those in the next sort of minute and a half or so, and then we can get into the.
00:48:00.540 - 00:48:21.866, Speaker D: Okay, going real fast. So here's my high level. There are some trade offs here, and this might be hard to get through. In a minute, we'll try $30 million. I want to bridge a day over 10,000 transactions. One approach, I send a message for every one of those transactions that has a cost, I have to send that at least 10,000 times. Brian rightfully says, hey, if we can batch that together, great.
00:48:21.866 - 00:49:01.958, Speaker D: But if you batch it together, you have a slower user fill experience. So the intent system, what we do, what the idea is, I think, is you have off chain liquidity. So this is the HFT analogy. You have off chain liquidity that is going to fill those users on a per transaction basis. And those off chain actors can compete on speed or on price or on both. And those off chain actors fill the user quickly. They can actually choose to take finality risk, which is part of the reason why across is able to fill users much, much faster than chain finality, which is pretty cool, but it's fully borne by these off chain actors.
00:49:01.958 - 00:50:18.446, Speaker D: They can fill users quickly, and then we can batch together their repayments and repay them in batches every hour, which means we could support those 10,000 transactions by sending a total of like 100 messages over the system over the course of a day. What are our trade offs here? Our trade offs here is that we have off chain actors that have to get paid for the loan they're making to extend to users. The advantage is we send way fewer messages. The other disadvantage to Brian's point is that there is an off chain component here, and if that off chain component doesn't show up, users don't get filled. So to put numbers around this, if there's $30 million of 1 hour loans, that costs you $300 if you have a 10% assumed interest rate. So I'm spending $300 a day on my interest component of my loans, and I'm saving from going from 10,000 messages to 150 messages a day. You can also secure those messages, like slowly, which maybe makes it safer and cheaper.
00:50:18.446 - 00:50:48.326, Speaker D: And that's kind of what across does. And you kind of have this trade off here. So this trade off space where I'm able to very quickly fill users with off chain liquidity cheaply and quickly and securely, and I get to send way fewer messages. I think that's a pretty good trade off, but I think it is worth highlighting Brian's points here around, like, wait, is this going to be like a worse version of Citadel? And jump just front running users?
00:50:48.518 - 00:51:01.534, Speaker A: Again, that's purely at the bridging layer, which is separate. So there's a couple of things. One, you said layer zero is not censorship resistant, but the application is. Layer zero is censorship resistant, but the application basically can add layers of censorship to it if it wants.
00:51:01.572 - 00:51:04.720, Speaker D: Did I just misspeak, though? Sorry.
00:51:06.870 - 00:52:37.646, Speaker A: You're basically shifting messaging to, say, rather than starting with the user and ending over there, you do it and off chain entity fills, and then you basically message back, which, again, is a fine optimization to make what it relies on is that the component coming back still meets all of those things. If the component coming back, which in your case is Uma, doesn't fulfill its needs or something happens, then basically the relayers all get rugged. They bear all risk of the messaging system and of the source chain finality, right? Then they're just going to price that accordingly and that's fine. I think you can again walk down the censorship resistant route. If there were avenues for censorship within Uma, and Uma was mandated in one way or another to do x or not process orders from these people, a lot less people will be able to. The amount that that system can withhold external pressures strictly determines the longevity of the system, right? Should it be a world or a system that says people from Nigeria are not able to basically interact with this at all? People like X, people like y, right? Where does that actually live? And if across was saying fine, we actually want these things to happen, but the underlying transport layer was now being censored or corrupted, then that would be like a very big problem for the application on top, right? And in this case you guys are both of them. So you have some levers of control or let's say like a mirrored, probably set of regulatory jurisdictions or restrictions based on where you are.
00:52:37.646 - 00:53:30.218, Speaker A: But for every other application building on top of these systems, they should care. The whole point should be decoupling the transport layer and the constraints from the transport layer, really minimizing the underlying constraints so that the application can do those. And I think Ethereum again does this extremely, extremely well, right? Like maybe Vitalik is going to fill you for your whatever, tornado cash transaction, or maybe some of these validators are not processing sanctioned addresses, but others are going to, as long as there is a part of the system who's willing to fulfill it and feels that they're meeting their sort of regulatory needs, then the system as a whole processes. And that's not what you're getting with most other transport layers. And I think you and other people should very much care about that. And I don't think people do. And I think that is very likely to play out in a very negative sense on a long time horizon.
00:53:30.394 - 00:53:50.840, Speaker D: So look, I very much agree with this. Hey, if you can get censored at some level, if you can get censored, you're screwed, right? It's not good. And I fully agree with you. I think that there's like a longer debate that we don't have here about whether Uma can be censored or not which I don't want to do now. And Mike, you look like you're about to cut us.
00:53:52.170 - 00:54:26.178, Speaker C: Push us, us. I want to push us into the next statement here. Everyone should go back and listen to that. I actually feel really lucky to be on this. It was so much like there are very interesting trade offs of just sort of risk, security, cost like, very interesting conversation. But I want to move on to this question where when we think about the end state for applications, what are going to be the requirements for interop? And this is a really difficult part of the conversation because it's so critical. Ultimately, the underlying infrastructure needs to support the application.
00:54:26.178 - 00:55:11.502, Speaker C: One of the challenges with crypto as it exists today is that we don't have many applications with traditional definition of product market. Your maybe to pick up on something that you brought up with why censorship resistance is so important is you could imagine. Let's just. I'm picking an app out of like Aave, which is deployed across multiple different you. If you have a very important vote that's happening on ETh main chain, and votes are getting passed from different chains, what you wouldn't want somebody to be able to do is hold that up. I guess the counter to that might be in the future. Maybe we imagine that most we don't think about deployments across different chains in the same way that we do today.
00:55:11.502 - 00:55:33.750, Speaker C: And maybe Aave exists primarily in this Ethereum sort of trust zone, which has largely solved interoperability within one another. Do you see what I'm saying? I would be very curious to get a sense from the two of you about how you think about the needs for interoperability from the application layer in a fully mature environment for blockchains.
00:55:34.890 - 00:55:37.606, Speaker A: Who do you want to start with and where do you want to start with that?
00:55:37.628 - 00:55:39.660, Speaker C: Whoever feels the bravest. Whoever feels the.
00:55:40.190 - 00:56:14.260, Speaker D: So, okay, like the Aave example is pretty interesting because I think Aave is an example where what can't you do on Aave? And Brian brought this up. Like, what can't you do that I want to do? I want to deposit eth on Ave on Ethereum and borrow op tokens on Ave on optimism. Like this crosschain thing here. So cool. There's a need for, I think, messaging to make that happen. This would be like a cross chain lending market. What I really don't know is how many applications there are like that.
00:56:14.260 - 00:56:50.590, Speaker D: And I think the alternative world, and I think it's almost clearest to think about this with like games or something like that, where if I'm running on chain game, I probably want to have my own blockchain, my own roll up that I'm just controlling to. I control the performance functions and I'm just doing stuff within my world like, I don't really need to talk to other blockchains to progress my game, at least the vast, vast majority of the time. What I do need to do is have people be able to move gas and move assets onto my chain. And I need that to be cheap and smooth and seamless.
00:56:51.730 - 00:57:15.746, Speaker A: I spent a bunch of time talking to almost every large gaming studio on this space. It's something we're pretty active in. Yeah, most like they want their own execution environment that's extremely low fee. And they basically have control over block space. Effectively, that's what they want. But the other thing that they very much want, every single one of them, is access to liquidity across all of the broader markets. So they want to be able to take their assets and access ethereum liquidity.
00:57:15.746 - 00:58:00.994, Speaker A: They want to be able to list on blur, on Opensea. They want to be able to have people buy and sell from other markets. These NFTs themselves, most of them, want to be able to come out in game assets, want to be able to go where they are the highest source of liquidity, or have a process for dealing between them. And so I think on the gaming side, it's a very clear example where the majority of execution happens on a single chain. I actually argue with this a lot. My co founder, his argument, my argument is usually like, what more can we do in sort of single chain atomic environments? How can we verticalize? And his argument is that 99.99% of all the world's compute today still happens on single machines, but the Internet is still the Internet.
00:58:00.994 - 00:58:19.420, Speaker A: Right? Like, functionally, you can argue as much as you want that this chain or the majority of execution is going to happen in a single chain. And I will very much agree with you. There still needs to be this layer of the Internet for anything of any measure of complexity to be built.
00:58:20.190 - 00:58:55.190, Speaker D: Yeah, but it still gets interesting and nuanced. Right, okay, so we agree that you're going to have the vast majority of compute or execution happening on a single chain, and you're going to have some number of single chains and they exist. And that number could be ten, it could be 10 million. Don't know. Right. And we also agree that there are some applications that require locking state between these chains. And this would be like your cross chain lending market or something like that, where I really can't do my thing on this other chain until I verify that something happened on my origin chain.
00:58:55.190 - 00:59:42.198, Speaker D: So then going to the gaming example, so we have then this concept of there's something of value that we want to be able to trade on other chains. And I guess really two forms, fungible value and non fungible value, right? And so then the difference here is that's not like a synchronous thing, that's like an asynchronous thing. As long as I can trade my asset, I'm happy. And I think this is where I get open minded about what does that end state look like? How much messaging is there involved in that kind of end state? And where I look at, from at least the fungible perspective, I think the intent perspective works very well. I'm much less clear on the non fungible side.
00:59:42.364 - 01:00:32.150, Speaker A: I mean, basically every application that exists on the Internet is effectively async, right? So if you look at any early application built was just like this monolithic structure. It sat in a single server. You would host the server, you'd put the server in a data center, whatever, and everything would run on this one machine. But as applications get more and more complex, as user needs change, as single environments or not, look at any modern application being built today. You have all of these web services, you have all of these microservices you're using, whether it's different databases, whether it's things for compute, whether it's things for all of these different structures, storage, all this doesn't matter. Everything moves out to the bounds of basically optimizing the specific thing. Because using that for the thing that it's good at is much better than using a generic system, right? For almost everything, every web app is built this way today.
01:00:32.150 - 01:01:43.146, Speaker A: Every major application you ever use is built this way today. And so if the thesis is that this application will live on Ethereum, and Ethereum will be able to do everything it needs to do extremely well, then that's a thesis that you could have, or I guess it's a belief that you could have. I think the most likely scenario is that you have applications that increase in orders of magnitude of complexity, and that you have storage, live in rweave or ipfest or filecoin or wherever it is, and they take that storage, whatever it is, data from that, bundle it up, do a really complex computation on Solana, and roll the end state of value, whatever the result of that is, to Ethereum, and it lives there, right? You can see this world evolving in a bunch of. We separate data and settlement and execution and all of these things start to basically bifurcate. And I think as you have applications move down that route, we're going to move from a model that is like a single, very naive structure that exists today to something that is measures of complexity. I think if you believe that what we're doing, blockchains themselves will scale real financial applications on chain that can service billions of people, that will have to happen. It will just have to.
01:01:43.146 - 01:02:15.430, Speaker A: There is no way you have a single monolithic structure that deals with all this. There's not any chance that happens. And so it really is a bet on. Do you think applications will stay at the same level of complexity they are now? Or do you think that they will be forced, like bridging is moving towards, to search for optimizations within the application execution? Will you be able to pay $30 or $100 for a trade or a loan or everything forever for every single one? Or will logic and execution, all these things be shifted elsewhere?
01:02:16.330 - 01:02:42.058, Speaker D: I think, Brian, that is the core question here. So we're saying that we are going to connect blockchains and there is some latency and cost to connecting blockchains for sending messages. We agree if though we are primarily moving value, then there is an approach here where you actually fill users with off chain liquidity.
01:02:42.234 - 01:02:45.038, Speaker A: I don't think we'll only be using moving value, though.
01:02:45.124 - 01:02:57.714, Speaker D: But I agree with you. I agree with you that we won't only be moving value, but it's kind of like one of those questions, where is it like 80% of messaging? Or is it like 10% of messaging? Right? Or 80% of, I guess, what is.
01:02:57.752 - 01:03:17.850, Speaker A: The result of the question? Right? Let's say it's 80% or 10%. What does the end state look like? You still need a messenger layer that maintains the properties that you want, or else the layer above just gets corrupted. So in either bound of that answer, what changes in the world? I'm saying in either bound of the answer, what changes with the messaging layer underneath?
01:03:18.270 - 01:03:20.006, Speaker D: Oh, sure, you have a messaging layer.
01:03:20.038 - 01:03:25.930, Speaker A: Underneath, but properties of the messaging layer change is the desired.
01:03:26.610 - 01:03:31.280, Speaker D: Brian, the point of this is like, what does Interop look like? Right? So I think Interop looks very different.
01:03:32.530 - 01:03:35.666, Speaker A: What does bridging look like? Or what does messaging look like?
01:03:35.848 - 01:04:25.940, Speaker C: Can I hop in here? One thing that I actually find myself asking, and maybe the user is thinking as well, is there's also a question here about, I think maybe something that we haven't directly asked, but ultimately, are most of the use cases of blockchains going to be primarily financial. And if that is the case, is moving value and all of the complicated abstractions and entities that move that value ultimately going to be where a lot of the value ends up getting extracted from these systems? Or is it this sort of message passing system which we're agreeing? I think everyone agrees here that we're going to need these general message passing systems. But where I sense a little bit of debate is, like, where that ultimately gets abstract, or maybe to skip ahead, like who gets to extract that value.
01:04:26.390 - 01:05:20.194, Speaker A: Even if it's entirely financial, though, the question is, will the financial applications that live and exist be only on a single chain? Or will they leverage sort of the orthogonal benefits or trade offs or optimizations of many chains? Like, that's the ultimate structure. If they're all going to be monolithic and it's all going to be value transfer, then you have one world. But again, I view these things as like optimizations down a path, right? You're reducing the cost for the end consumer is like Robin Hood shifting zero from $10 trades to free trades. But you get front run, like net good. Does the majority of the world's volume, like, route through Robin Hood, or why doesn't, why isn't that like the end thing? Right. You can shift this around a lot of different ways. And I think there are totally fine trade offs at the bridging layer, at the swapping layer, all of that.
01:05:20.194 - 01:05:31.750, Speaker A: You can make an abundant set of trade offs for where cost lives, where value is extracted, how to drive down the end cost to the consumer. But that's all reliant on having the underlying.
01:05:34.090 - 01:05:57.626, Speaker D: Brian, I want to agree with you. I just want to frame this as what's the most interesting conversation we can have here. There is going to be a messaging layer. Layer zero is going to build a valuable business. I agree with you. Right? But I think it's really interesting to try to hypothesize how big that business is. And I guess my question here is like, okay, so you guys are doing generalized messaging.
01:05:57.626 - 01:06:39.946, Speaker D: It's going to happen. Great. And when I talk about this optimization layer, I'm like, well, the business that I'm trying to build with across, is this what you want to call an optimization layer that's trying to very efficiently move value between blockchains? And I want to know how big this business is. I want to know how much value is running through this business that's optimized to move value and where there is potential tension is if my business of optimizing moving value between blockchains captures a lot of value and then doesn't produce that many messages. It ultimately makes the layer zero business less big. Doesn't mean it's not huge. And that's where we're maybe getting tense here.
01:06:39.946 - 01:06:43.962, Speaker D: But I want to understand what this NC looks like.
01:06:44.096 - 01:07:06.158, Speaker A: I don't care about that. It's not even me saying, like, layer zero has to be the end transport layer. It's that we're talking about two different layers. Like, you're, like, you want to espouse why across is great. And at the layer above, I'm saying across is just, like, a thing that can be built on top of layer zero. Like, how that layer is defined, I think, is much more overall. And so they're, like, down the path.
01:07:06.158 - 01:07:42.430, Speaker A: If you go down the path of, okay, bridging is, like the number one use case, and moving value is the number one use case. The question is, will you need external liquidity to basically move that? Right? And that's functionally what it is. If we're going and we say everything is value transfer, then all of the assets are just going to go to native issues anyways, right? Like Circle, CCDP, layer zero oft all this says you don't need a bridge at all. Now you can move again, $100 million, a billion dollars, whatever you want for just the cost of gas, and that's it. And you can batch that as much as you want. You can add any amount of latency. You can have circle fill on the other side and then batch it back into a single message.
01:07:42.430 - 01:07:50.542, Speaker A: All of these things can be done, and there is no need for any external fill abridging layer if it's all done, the native asset layer anyways.
01:07:50.686 - 01:07:57.854, Speaker D: Well, hold on. Actually, that's not true. Like, across is cheaper and faster than circle cc.
01:07:57.902 - 01:08:03.014, Speaker A: A circle has its own constraints that it's built in. It could fill on the other side, no problem.
01:08:03.132 - 01:08:25.326, Speaker C: All right, I want to try to structure this here, because for the audience here, right. One of my favorite movies of all time is thank you for not smoking. And there's a guy who blank on the word. He's one of those people that goes to. He's a lobbyist, and he has this debate with his son, know it's chocolate or vanilla ice cream, better. And he's like, oh, you didn't convince me. He's like, I'm not trying to convince you.
01:08:25.326 - 01:09:03.114, Speaker C: I'm trying to convince them. So, Hart and Brian, I want to give you guys each a couple of minutes here, make your pitch to the audience. I think part of the reason why there's so much like, I'm going to call friendly competition between the two of you is like both of you guys are building monster businesses. Both of you guys sit at sort of a different layer in the stack and there's this sort of natural competition, right? But hey, I think my layer is super important and creating a ton of you here. So I want to give you guys a chance to, instead of going over some of the technical specifics, kind of make the pitch to the audience for why you guys sit is valuable and going to do a good job of kind of capturing some of the value that you're creating. And then I've still got two important questions that I want to get to here. So if we could just do.
01:09:03.114 - 01:09:10.266, Speaker C: Brian, if you want to take the lead here, Hart, you can go. And then I've got two more questions and we can wrap mean.
01:09:10.288 - 01:09:19.198, Speaker A: Sure. So again, I'm not actually trying to convince you or anybody that what we're building will be like the most valuable. Again, Brian, you'd never make it.
01:09:19.204 - 01:09:20.640, Speaker C: As a lobbyist, my friend.
01:09:22.290 - 01:10:24.318, Speaker A: That is the game is how do you build the thing that has the highest maximum utility? And if I build my piece of the stack right, pieces like across can exist again, across intents, all of it cannot solve the actual messaging layer. And you need that layer back. And so if we want to move up the stack and say, here's how bridging will look, here's how crosschain Dexes will look, here's how crosschain lending protocols can look like we can talk the application layer, but I actually think it's like there's a huge amount of indecision around what the messaging layer looks like. And if that's done wrong, everything else is broken and corrupted anyways, right? And you never scale, if that's done wrong, you never scale to a million blockchains, and you never have censorship rails and immutable rails and all of those things that matter. My point is, if you don't get that right, you can't get any of the other stuff right anyways because it can all be corrupted. It can all be basically exploited where five plus billion dollars of hacks in, like, all of this stuff happens. And it happens not actually because of the validation layer.
01:10:24.318 - 01:10:41.466, Speaker A: There's not a single of the last 15 hacks. Not one of them has been because of a malicious validator set. Not one. Every single one of them has been because of contract upgrades for the large bar wormhole, $350,000,000 hack contract upgrade. $1.8 billion critical bug contract upgrade. Another $1.8
01:10:41.466 - 01:11:08.926, Speaker A: billion critical bug contract upgrade. Nomads hack, contract upgrade. Sockets hack, contract upgrade, and let. Half of the people in the industry are still like, these are the systems we should review. People just don't care. I hear Hart has spent a lot of time criticizing layer zero for many different things, but I've never once heard any criticism around that, which has been historically the biggest vector by far for every other protocol. And so as we walk down, I think it's a much more interesting debate.
01:11:08.926 - 01:12:11.494, Speaker A: And naturally, it's because of the thing that I work on and actually talking about that layer and why it matters, because if that layer is wrong, nothing else matters. Like, if we all move, there was this. I don't pick on BNB chain too much, but there was a joke in the early days of BSC. There was like, the cap show, with all nine of the validators being CZ, right? And it was just like every face with CZ, right? And it's like, are we okay with a world that is a chain that looks like that versus a chain that looks like Ethereum or like many of these others? Do we care about bitcoin? Do we care about the underlying layer? Do we care about the application? So are we here to talk about how the application layer gets built? Are we here to talk about how the actual interop system gets built underneath? How does that actually work? And I think those rails, if that's not the conversation, we just want to talk about what is the best way to have a bridge that lives on top of that. We can have that conversation, but I actually think it has not been decided at all. And I would be much more interested in hearing across or heart in general, say, here's why this is the underlying layer. Here's why I think application should build on this or that.
01:12:11.494 - 01:12:37.646, Speaker A: Here is why we support X ERC 20 as, like, a standard, and X and Y and Z. Right here is why we're trying to move to those things. I think that's a far more impactful conversation on, like, a two year time horizon. And everything else gets solved on, like, a five year time horizon. Because if you get that part wrong, you end up with a very different world. You end up with not ethereum, you end up with insert long tail chain here that has six validators and people, you know, it's. It's doing what we want.
01:12:37.646 - 01:12:38.640, Speaker A: It's doing the.
01:12:41.250 - 01:13:26.350, Speaker D: All right, so, yeah, so I'll try to be a lobbyist here. I am trying to convince you that this layer is important because I actually don't think, Brian, people think this way. That's my difference here. I actually think most of our ecosystem is thinking that the transport layer where you're working is the thing that we've all got to figure out and spend our time thinking about, which is true, I agree. But I think this layer of how we send value between blockchains is going to be where 70, 80 90% of all the messaging happens or all the interop happens. I shouldn't use the word messaging. And so I am trying to make the point that the way we are going to connect blockchains, 80 90% of that is going to be moving value.
01:13:26.350 - 01:14:00.542, Speaker D: And figuring out how to move value, the most efficient, cheapest, secure way, fastest way possible, is a big deal. And I don't think people are thinking this way. And I'm very convinced that this intent framework that we've been working on for a while is the answer to how you are going to move value cheaply and quickly and efficiently between blockchains. And I agree that it does require underlying some messaging layers to exist, and that's where we're at. So yeah, that's my summary.
01:14:00.706 - 01:14:30.034, Speaker C: No, I really appreciate it from both you guys. The passion just comes across from both of you, and that's exactly who we want building these systems. So I just really appreciate both your guys'perspectives. One, I've got two. Maybe we can end on these two questions, which is one, maybe a slightly related question. And frankly, we could have done a whole episode on kind of like monolithic and modular. And ultimately, even those two words for me are starting to blend a little bit.
01:14:30.034 - 01:15:41.546, Speaker C: And I'm sort of thinking about it from the perspective of how tightly are distinct systems sort of coupled. But one thing that I would love to get your take on, Brian, because we've been talking about this a good amount this season, is what is your view, know, when we zoom out into this end state where applications have some, right, some amount, we might disagree on some of the particulars, but of demand to interoperate a lot of what people want in terms of interoperability today is like, I want to trade these assets, right? Like I want to trade ethereum, but I want to trade it on optimism where it's cheap, for instance. And so as soon as you kind of move into that world, you're dealing with mostly bridged versions of assets and wanted to get your perspective here on when you think about the future, if there's ten chains or 100 or 1000, it sounds like, you have a very modular vision of the future, where even more so than today, we're decoupling the traditional constructions of blockchain. So in this world, are we mostly dealing with wrapped versions of assets, or are we mostly going to try to minimize the amount of bridging and deal with assets on their source chains that I guess improve the capabilities of the underlying protocols. Does that make sense?
01:15:41.728 - 01:16:17.806, Speaker A: I think one of the earliest articles that I wrote is like, why wrapped assets suck, right? Wrapped assets basically shift the risk from a user. Basically says, we're taking the risk from the lps, right? You swap in Uniswap, lps bear the risk of the Uniswap protocol. A user executes a swap, they get their asset on the other side, they never think about it again. A wrapped asset basically says, we're shifting risk from lps to the end user, and the end user is holding that asset carries risk and perpetuity. As long as the asset exists, the underlying is broken, everything's rugged, the asset is now worth zero. And this has happened like many, many times. So I think it's a purely worse model of the underlying asset.
01:16:17.806 - 01:17:06.850, Speaker A: I don't think native assets have proliferated nearly as quickly as I thought, because it is a risk for circle to extend to some untrusted state machine that it doesn't know they can have some issue in tether and all these others and have that basically impact the overall liquidity. And so I have always been a huge proponent of native assets. I think it's why oft is so compelling. I think that has been why a lot of these other things have been. I think naturally you will not deal with wrapped assets. You will have a single issuer or protocol who sort of owns where its token goes and owns how that token is moved and takes away the cost of moving those assets, such that you don't need to rely on sort of third party bridging solutions. You don't have to inherit other risk, you don't have to have wrapped assets, or you have this other sort of structure that lives under and is carrying risk.
01:17:07.510 - 01:17:44.334, Speaker D: Brian, this is actually something I wanted to ask you, because one of the things we very much agreed on, like the first time we met, is that wrapped assets are bad. And I'm like a canonical asset maximalist here. But this is where I want to understand better why you think ofts are not like a version of wrapped assets. Because within the oft protocol, if you control the bridge, the verification logic, you can mint unrestricted assets. Go ahead.
01:17:44.452 - 01:18:10.226, Speaker A: Yeah, that's just a parameter that the token sets, right? The token can basically rate limit and do. You can do anything that you want. It's just saying existing structure is, I have a token on chain a, it's going to get moved to chain b. You have two options, right? You can use a third party who basically wraps it, bridges it. So you have your transport layer and you have another bridging structure built on top of it. And typically you don't even own that contract. On the destination side, it's a wrapped asset.
01:18:10.226 - 01:18:37.854, Speaker A: It's like vanilla ERC 20 that's coming out on the other side. You don't have any controls over what it is. And you're basically reliant on this external system, and they're charging you rent, they're charging you 6810 twelve bips. Typically, those have been like historic bridging rates. Right now you have the ability to say you're going between two chains. There's some element of messaging, and there's going to be some risk within that messaging. There's some security property there that you're inheriting, but the difference is you get to own it.
01:18:37.854 - 01:18:57.720, Speaker A: You get to set it yourself entirely. You own the end contract. You can set any of the rate limits you want. You can set any parameter that you want with that, and you pay zero rent to anybody else. Now, the cost of moving the asset goes from 6810, twelve bips on $30 million a day, like you're saying, down to zero bips for unlimited amounts, or for whatever you said is a ray limited amount.
01:18:59.550 - 01:19:24.314, Speaker C: I've got a follow up question. Sorry. I've got a follow up question for you, Brian, which is the implications, though, of being a canonical asset, maxi or bridge minimalism, is that if you want to interact with an asset that has network effects, like Ethereum, you are now subject to the constraints of Ethereum, the protocol as it exists today, namely paying high gas costs, native assets.
01:19:24.362 - 01:19:49.586, Speaker A: You will always, always have to have wrapped assets. You don't have a single entity who can issue it. That's totally different from most other assets that exist, whether it be stablecoins, whether it be any protocol that's, look at any decks, anything that has a token that exists and has its chain moving around, even like Lido, rapstake, Deeth, there's all these different versions have ways to move these things to different chains.
01:19:49.778 - 01:20:45.002, Speaker C: Got it. Final question, Brian. I'm going to ask it to you. I'm going to ask it to you as well, because we've talked about this before, but I want to get your three episodes in a sort of updated view? Brian, can you give us, one of the things that Hart and I have been asking this season is as we move forward into this sort of more multichain endgame, it's sort of apparent that we're going to have to make compromises in some way, shape or form, right? I think that's just like kind of pragmatic, realistic approach. Maybe you could even look at the example of Uniswap, the uniswap sort of v one was this cipher punk sort of dream where the whole logic existed on chain and there was like. Well, actually, as we need to scale, ultimately we have to make some tough decisions about which are the important parts of the logic to live on chain or components of the protocol to keep the underlying core premise. But if we want to scale this to being able to support however many millions of trades, then we have to move some stuff off chain or whatever that is.
01:20:45.002 - 01:20:58.720, Speaker C: So I guess one of the questions that Hart and I have been asking ourselves this season is where does the line kind of end? What would we define as a successful end to this whole crypto experiment? Curious to get your closing thoughts there.
01:21:00.050 - 01:21:41.034, Speaker A: What does the end state look like? That's like good. What is a good outcome is basically the question. I mean, a good outcome is immutable rails that can be used by anybody effectively. I think that's why anybody who got into the space like a decade plus ago, we all got in for this very strong ethos driven right. It should be money that cannot be censored and controlled by some central actor, whether it be government, whether anybody else, it should be you should own right. This concept of self sovereignty and the ability of actually having control of real ownership of the asset and these permissionless structures, anybody can run, anybody can be a part of true decentralization. Like, all of these things matter a lot.
01:21:41.034 - 01:22:09.906, Speaker A: And I think you're right that likely more and more and more compromises are going to get taken. And I think we're seeing a huge shift towards higher and higher degrees of centralization. I think liveness is being traded off very consistently. And I think there's a different view. And this is the problem that I have. There's two views. There's one, which is the current topology, and then there's two, what is the actual architecture? And this is like in the very early days of bitcoin or ethereum.
01:22:09.906 - 01:23:32.430, Speaker A: Anyone else? Like reasonably small validator set, like heavily, not greatly decentralized. Yet early on, many times, like known actors who are running these, all of these, and they develop into what it is today. And the difference is how it was actually built. It was built, and you could criticize current topology for how it exists right now, but architecture, you couldn't criticize because the architecture was actually built to be able to scale into something that is, and this is like the evolution. I think the problem is that people are taking things that have similar topology right now and equating them and saying these are the same, where this one's even better, because current topology is better when the underlying architecture is infinitely more corruptible and way worse for end state. And I think those compromises that we're taking along the way, that many people, and it's not just in messaging, all systems are that higher and higher degrees of centralization in ways that actually matter, and being treated as equivalent to a system that is secure but sacrifices like liveness, right? So let's say equally centralized systems, one is secure but has risks of liveness, I would say like across falls into this, right, is like it's sacrificing some element of liveness, but it basically has the same measure of security as the underlying messaging system. So in this case, Uma, it matches Uma's security, sacrifices some liveness issues, if any of these things were.
01:23:32.430 - 01:24:04.762, Speaker A: And so that's the design decision. I think more and more things are going down that path, but they're being equated to systems that are like equally, or let's say two separate centralized systems. One is secure and sacrifices liveness, the one is equally centralized, but is not secure at all. And I think people are treating those as the exact same system. And I think that is like the fundamental broken part. And this is why I argue against intellectual dishonesty and bad faith arguing. A lot of times I think those things are being treated as completely equal in a way when they're just not.
01:24:04.762 - 01:24:33.940, Speaker A: And I think it's happening sort of across the whole industry, and I think it's leading us and people will care more, again, post more hacks, post more bad things. Like you can only sacrifice security for a certain period of time until that comes back to haunt you. And I think we've seen that just many times in the space over the last eleven years. So, yeah, to me that is the biggest thing that is like an issue right now. And I wish we could talk another hour on, because I think it matters a lot.
01:24:34.950 - 01:24:35.794, Speaker D: Awesome, thanks.
01:24:35.832 - 01:24:37.666, Speaker C: Brian Hart, what do you think?
01:24:37.848 - 01:25:34.690, Speaker D: Yeah, I mean, first of all, I love Brian's passion around that point. Like truly man and I actually think we probably agree more than you might think around all that stuff around the centralization risks. I do think the debates here, though are pretty nuanced. One of the things I worry about from Layer Zero's perspective is by pushing these decisions to the application layer, you're going to have some applications that make what are going to be, in my opinion, really bad security trade offs. And you as an unappinionated layer, you can't actually have an opinion about their security trade offs, but you're going to see people using your stack in shitty ways. And that brings up another really interesting debate, is like should you almost be paternalistic about what you can and can't do with your stack? I don't know. And that's a whole other conversation.
01:25:34.770 - 01:26:11.970, Speaker A: Right, but I think it's an important conversation though. I think we've taken the stance of Ethereum side. Do you think Vitalik loved IcO season or dogcoins or any of these other things? Being like the primary driver of Ethereum for a very long time, right? Is it his place to say, what is a good application, what is a bad application? What is like a good use of blockspace? And what I mean, maybe blockspace you can have an opinion on. But I think the point is if you build something that's a low enough level, primitive and expressive enough, it will be used in bad ways. But that's actually a feature, not a bug. That's a good thing. That's a good property of a system man.
01:26:12.040 - 01:26:47.226, Speaker D: I guess. I very much agree with that. But I think Vitalik is super special this way, where he does offer an opinion in a very measured way. Right? He sort of does shepherd. It's like this benevolent dictator type stuff that he does kind of shepherd the space in a certain direction without being controlling. And yeah, I think that is a very interesting thing that I think you're going to face as layer zero grows, where there's going to be use cases and you might be in a position where you have to sort of offer your personal opinion about how shitty or not shitty they are. But let's leave that aside.
01:26:47.258 - 01:26:57.220, Speaker A: I have personal opinions on all of it. The protocol should not be opinionated, right. The design of the protocol and the way you architect it and the way of what you allow and disallow should not be opinionated at all.
01:26:57.830 - 01:27:42.926, Speaker D: Look, I respect you for making that decision. There are like some of your competitors at the messaging layer. The ones that I think this model of CCIP and Axelart like shipping their validator set or selling their validator set is a kind of interesting model, but they're actually making in that decision or in their whole strategy, they're making a different decision where they are opinionated about what security should be, and that's literally what they're selling. And so I think that's just truly a very interesting strategic decision that these projects are taking, like you versus them. And I don't necessarily think there's a right answer, but, Mike, I want to answer your question, because you're like, hey, what's. Well, you should think that. That's very clear.
01:27:42.926 - 01:28:07.890, Speaker D: Back to you being a lobbyist. You should absolutely think that being on the opinion, it is the right answer. Yeah, I can see the argument on other side, Mike, back to your question, though. End state for interop. I just think we want fast, cheap, and secure interoperability. That's it. A lot of Brian's concerns around censorship, resistance, I think loop into security, you're ultimately not secure.
01:28:07.890 - 01:28:35.460, Speaker D: If you can be. Yeah, that will break you in the end. Fast, cheap, and secure interop is what we want. Again, the thing that I still want to keep using the rest of our season of the podcast to dig into is how much of interop is going to be value transfer versus messaging, because I think it does influence or kind of like color what the end state looks like.
01:28:37.030 - 01:29:18.654, Speaker C: Yeah. And you know what, guys? I almost wish we're getting to something really interesting right at the end there, which I think is ultimately coming for all protocols. Like Brian, I also really love the ideals of the protocol. I have opinions, but the protocol necessarily shouldn't. And I think if you look around, one of the big takeaways, at least from my perspective, and the deck season that I did with Dan Robinson, he described Uniswap as having a very similar approach. Actually, they sort of viewed themselves as a platform since day one, but probably at some point, it is difficult to escape an opinion as well. I'm like, maybe instead of interjecting my own opinion, it would be really interesting and informative for everyone to look at the evolution of something like Google.
01:29:18.654 - 01:30:03.674, Speaker C: Right, where Google, the original sort of value proposition of Google is to like Brian, exactly what you just described. It's like, how can we just. We don't want to have an opinion. We're going to index our data in such a way that it's really easily to be accessible to anyone over time. Not to make political commentary, but we've all seen the search results from Gemini, which they've clearly deviated from their mission, and we could have a debate about whether or not that's a pro or a con, but it's probably worth it for all protocol designers. I think part of the reason why we're in crypto today is that we agree with that idea that, hey, we don't actually like this. And there are certain things that, be it financial rails or passage for communication, that they should just be these kind of neutral systems that are not opinionated.
01:30:03.674 - 01:30:11.706, Speaker C: So it's a worthwhile question to ask, maybe for the rest of the season, about how can we maintain those values with increasing external pressure.
01:30:11.898 - 01:31:04.766, Speaker A: I completely agree, and I think from day one, like Ryan and I, are extremely adversarial in terms of how we think about design. From day one, every decision is through the lens of, if we laser labs are maximally malicious or disappear for whatever reason, one reason or another, how does a protocol withstand those things? And I think you have to, and I think you're absolutely right down the trajectory of Google. Like, if there was this immutable version of Google that everybody could return to and use, immutable version, whatever AI system early on that everybody could return to and use, then that will exist forever. And there's no way to basically change and corrupt that. I think that should be the goal for everybody. If you're building something within there, you want to give people using it and building on top an ability to reason about security and liveness. Again, you can make trade offs on either of those sections, but you need to give them the ability to reason about that.
01:31:04.766 - 01:31:47.854, Speaker A: If they cannot reason about the long term security and liveness of a protocol, it's going to end very badly. One way or another, protocols are going to go out of business. And these centralized systems that are there now, these service providers are going to go down, and every application built on top will just be dead. And if they built their contracts immutable, they will have no way to change that or do anything or basically modify complete redeploy. If the security property can be changed, you see it with every one of these contract upgrades, they will suffer. And so ultimately, I think everybody should focus on, if you're building infrastructure at all, through that lens at least of that, nobody should need to rely on us one way or another. You don't need to rely on the Uniswap team.
01:31:47.854 - 01:31:57.902, Speaker A: You rely on their front end. Right. Uniswap Labs does something, it builds something around the protocol that is accretive to the protocol, but the protocol itself doesn't care. It's agnostic.
01:31:58.046 - 01:32:43.546, Speaker D: Brian, I want to pay you a compliment. In the sense that I agree with you that the way the layer zero architecture is designed, this Google problem that Mike's describing I don't think is possible. It's unappinionated and can't be captured. I do think, though, that what is really fascinating and what's been clarifying on this conversation for me is now it really is up to the application. So, unlike your Uniswap example, where in uniswap v one, v two, v three deployed to Ethereum, blockchain can't be changed. And it just works here. The application sets their security concerns for interop, and in any reasonable application, there needs to be a way to change them because the interop landscape isn't settled.
01:32:43.546 - 01:32:55.054, Speaker D: And so we now have a lot of trust we're putting in the application, which is a reasonable trade off to make, but also kind of sucks because there's going to be some shitty decisions.
01:32:55.102 - 01:33:44.980, Speaker C: Made, maybe just because I know we got to wind down here. What we're describing is we did a season of the show on Cosmos and the appchain stack, and it is a pronounced difference in between how the cosmos ecosystem approaches decision making versus how Ethereum approaches decision making, in that Ethereum views itself as this immutable protocol which tries to push complexity away to the edges, whereas cosmos will just have an opinion, like, this type of mev is good or bad. And you can look at many different examples of this from osmosis saying, front running is bad, back running is good. We are going to internalize back running revenue for the protocol, or Ethereum will kind of debate. There's this debate around issuance on the Ethereum protocol. Is it good? Should we cap it? Whatever. And in stride, you had the liquid staking module where they were like, yes, 25% feels good.
01:33:44.980 - 01:34:11.434, Speaker C: Ultimately, someone is going to have to make decisions, right? So I think that's a good question to keep asking about the rest of the team, about where does the decision making sit in the stack. So I think, guys, I know we got to wrap up here. I really appreciate both of you doing this. This was a ton of fun. Brian, thank you so much, man, for coming on the show. If folks want to find out more about you, the work that you're doing at layer zero, what's the best way for that to happen?
01:34:11.632 - 01:34:22.094, Speaker A: Twitter, for sure. I think the majority of the space lives on Twitter. We live on Twitter pretty frequently, I think. Yeah, definitely. Definitely the best space to follow anything new happening.
01:34:22.292 - 01:34:31.406, Speaker C: Awesome. All right, guys, appreciate you both. Brian, this was a ton of fun. Heart and I will see you next week for our next episode. Cheers, guys.
01:34:31.588 - 01:34:32.718, Speaker D: Hey, thank you both.
01:34:32.804 - 01:34:33.342, Speaker C: Hey, everyone.
01:34:33.396 - 01:34:51.858, Speaker B: Want to give a final shout out to this episode's title sponsor? Say now. There are a whole bunch of really exciting reasons to be building on, say, v two outside of just parallelization. I want you to head over to say IO to looking into building on their public Devnet again. Click the link at the bottom of this episode and head over to say IO.
01:34:51.954 - 01:34:58.450, Speaker C: Start building something today's.
