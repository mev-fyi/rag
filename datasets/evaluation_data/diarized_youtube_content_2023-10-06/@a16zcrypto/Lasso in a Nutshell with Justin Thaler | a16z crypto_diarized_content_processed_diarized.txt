00:00:10.230 - 00:00:51.080, Speaker A: All right, so just like a one slide recap of yesterday. So a lookup argument lets approver commit to a vector of value and then prove that all entries of that vector reside in some Predetermined Table. So Lasso is a new family of lookup arguments, high level. I think the prover is about an order magnitude faster than prior works. And this is sort of coming from two different factors. One is the proverbs committing to fewer field elements in Lasso than in prior lookup arguments. And the other factor, which is actually more significant is that all of the field elements being committed are small.
00:00:51.080 - 00:01:42.040, Speaker A: And exactly how important that is depends heavily on what commitment scheme you use. But in general, in snarks and lookup arguments the bottleneck for the prover is cryptographically committing to values. And for some really important commitment schemes, if you're committing to small values, even if those small values reside in a very big field, the commitment is really really fast to compute. Okay? Also in Lasso sort of inherited from the fact that under the hood it uses multivariate polynomials and not univariate ones, and we'll see details about that today. For many tables there's no need for the prover to commit to the table. So in all prior lookup arguments, the prover always had to not the prover. Some honest party in preprocessing always had to commit to the table and the prover would have to kind of process that commitment on the fly as well.
00:01:42.040 - 00:02:32.360, Speaker A: And finally, kind of a distinguishing feature of the Lasso family of lookups is that they can support gigantic tables. So think of size maybe two to the 128 as long as the tables have some structure to them. And we build jolt, which is kind of a new ZK VM technique out of Lasso which uses a property called decomposability of the table. And actually prior lookup arguments also could handle decomposable tables, but probably with more overheads. And then something really unique to the Lasso family is that there's a varying called generalized Lasso which exploits a weaker structural property in the tables. And I don't think you can achieve something like this. Certainly it's not known using univary polynomials rather than multivariate ones.
00:02:32.360 - 00:03:09.390, Speaker A: Okay? And then jolt is a new zkvm technique which has lower commitment costs for the prover than prior works. And the one sentence version of the main idea is every time the virtual machine goes to execute a primitive instruction, the jolt prover will sort of prove that that instruction was executed correctly just by doing one lookup into a giant table. That table contains actually the entire evaluation table of the instruction. So action takes 264 bit inputs. The table actually has size two to the 128 because there are two to the 128 possible inputs to the instruction.
