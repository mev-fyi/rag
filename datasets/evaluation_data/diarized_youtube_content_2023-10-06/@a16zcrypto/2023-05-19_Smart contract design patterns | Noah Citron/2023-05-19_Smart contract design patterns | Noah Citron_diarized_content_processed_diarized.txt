00:00:10.170 - 00:00:43.030, Speaker A: Today I want to talk a little bit about design patterns and architecture for smart contracts. So we're just going to jump right on into it. So why are we here? Well, start for those who don't know, design patterns are these generalized solutions to common problems when designing systems. But why do we want to talk about smart contract design patterns? Well, you might recognize this guy. His name is Bob Martin, affectionately referred to as Uncle Bob by software engineers around the world. And he talks a whole lot about how to build software. He writes a lot of books.
00:00:43.030 - 00:01:27.602, Speaker A: His most famous one is called Clean Code and it's sort of the bible of design patterns. But if you haven't read Clean Code, you've probably still learned a ton about design patterns from blog posts, work classes or just years of experience as engineers. Why are we here? Why are we rehashing this if design patterns already permeate sort of the tech industry? And I think that's because web two design patterns differ pretty significantly from web3. To start with, we don't use back ends, mostly because we have sort of some centralization concerns as they are centralized chokepoints. And instead we use smart contracts. And smart contracts have these entirely different goals and constraints. Some people have tried to compare them with other technologies like databases or APIs.
00:01:27.602 - 00:02:10.150, Speaker A: But really the design patterns we have from databases APIs don't fit in the context of smart contracts. So because of this, we don't have a book, we don't have Uncle Bob writing about all the design patterns we can use. Instead though, we have some protocols to look at. So here we have sort of an image of MakerDAO's protocol design. We can look at those protocols and start to understand what the design patterns are and maybe eventually when we do, that enough. We've only been doing that for seven or eight years now we'll have enough to write a book, but for now I think we have enough to do a talk. So we're going to frame the design patterns we talk about with two main metrics and those are upgradability and composability.
00:02:10.150 - 00:02:56.020, Speaker A: So upgradability is how a protocol can change over time and what guarantees does it make for the future. Meanwhile, composability is sort of how protocols ensure that it's easy for you to build on top of that. And there's other metrics we might want to talk about such as gas efficiency and organizational complexity. And we will discuss those when a particular pattern really calls for it. However, we're really going to stick to these two metrics, upgradability and composability. And the reason for this is because this week we're talking about infrastructure. And I think that protocols that use patterns that allow for limited reasonable upgradability and maximal composability are most likely to become these critical pieces of infrastructure on the chains that they're deployed on.
00:02:56.020 - 00:03:43.570, Speaker A: So we're going to jump straight in into sort of this first metric upgradability and talk a whole lot about that. So upgradability is often considered to be a frightening thing. And why is that? Well, it's because if you have an upgradable smart contract system, then someone, some entity can do the upgrading. And that means that entity can, in theory, do a malicious upgrade and steal funds. So that's not all that true though, because we're going to split upgradability into sort of two poles that lie on the spectrum. We're going to do unconstrained and constrained upgradability and then there's this large design space that we're going to focus a lot on that lies in the middle. So with unconstrained upgradability, upgrades can create arbitrary changes to the system's behavior.
00:03:43.570 - 00:04:24.030, Speaker A: Any rules enforced by the contracts can be overridden by an upgrade. And some examples of this are proxy systems and this is what gets demonized a lot. But I will say it's not all that bad. They are used pretty pervasively throughout our industry and they can be super useful because it allows you to squash bugs quickly. If your original contract has a critical bug in it, a quick upgrade from the team can alleviate those concerns. But one of the big downsides you have is you can't make a pact with the user about that the system is going to behave the same forever and into the future. And this is particularly bad for systems that deal with high value assets.
00:04:24.030 - 00:05:19.570, Speaker A: But fortunately, we can sort of address some of these concerns even with fully unconstrained systems using things like Dow governance and long time locks, which helps to some extent. But on the other side of the spectrum, we have constrained upgradability. And with this, upgrades can make limited changes to the system's behavior and the system can encode rules as to what parts can be upgraded and what components and invariants must remain constant. And some examples of this are module patterns and configurable parameters. Now this is a lot less scary because users have some degree, depending on how constrained you are, of ability to understand the system behavior into the future. And yet if you allow a little bit of unconstrained, then you can support limited upgrades. And this is useful because it is incredibly hard to design protocols that work from day one and into perpetuity.
00:05:19.570 - 00:06:09.130, Speaker A: So we're going to start sort of with our first example of a bunch of patterns that allow for unconstrained upgradability and talk about proxies. So here we have a picture of Ralph and he's a proxy user and he's realizing he might be in danger because he's interacting with a proxy, which we're going to use as a metaphor, have a shogif of a smiling face, but a potentially dangerous and scary inner workings. So let's start with a quick example of how proxies work. So we have Ralph here and he calls a proxy contract, which is sort of the head of our Shagif. And the proxy is this immutable contract. At first it sort of looks to be somewhat safe. Meanwhile, what the proxy then does is it delegate calls whatever Ralph did and forwards the call off to the implementation.
00:06:09.130 - 00:06:58.650, Speaker A: So what does this mean? How does delegate call work? Well, when the proxy delegate calls the implementation, what's happening here is that the proxy is handing all control off to the implementation. So when the invitation then goes ahead and makes some external calls, those calls are going to look like they're coming from the proxy. And when the implementation updates its own storage, it's actually going to be updating and reading from the storage of the proxy contract instead. So in other words, now when you do that delegate call, you're handing over the keys and the entire time that call happens, the implementation sort of has the keys to the castle. So why is this frightening? Why is this scary? Why are we using a Shogif as our example? Well, this is why. Because the implementation could be upgraded. So the old implementation may have been innocuous, but a new one could be malicious.
00:06:58.650 - 00:07:36.630, Speaker A: On a counterpoint, though, the old implementation could be incredibly scary. It could have a critical bug allowing hackers to drain the protocol. So it can be useful. Proxies are useful, but when you use them, you do lose out on one of the core benefits of smart contracts, which is the ability to reason about its behavior, or in other words, its immutability. So we're going to go a little bit deeper and actually understand how proxies work and different ways one might construct a proxy. And our first example is a really, really simple proxy system. It's actually based on the first ever proxy deployed on Ethereum designed by Nick from ENS.
00:07:36.630 - 00:08:08.126, Speaker A: And we'll start by looking at that first contract, the head of the Shogif, the proxy. So it's a really, really simple contract. It's got one variable, which is the implementation address or the address of the body of our shagath, and then a single function called fallback. Now, the fallback is a special function in solidity. If you make a call to a smart contract, you generally are calling some function. But if that call you make is for a function that the smart contract doesn't recognize, it goes to the fallback. So in this example, fallback is the only function here.
00:08:08.126 - 00:08:54.190, Speaker A: So it means that whenever this smart contract receives a call, it's going to execute the fallback. Now, the fallback is really simple. All it does is it delegate calls the implementation and sort of forwards off the transaction data to the implementation and again hands the keys to the castle to the implementation. Now, on the right, this is our implementation contract. And we can see it looks for the most part like a normal contract. The one weird thing about it is we have this first storage variable which is completely unused and it's exactly the same as that storage variable we had in our proxy and it's the address of the implementation, which in this context, it doesn't really make sense. Right, you are of the implementation, why do you need your own address? And we certainly don't use it, and we're going to talk about that on the next slide, so bear with me.
00:08:54.190 - 00:09:49.710, Speaker A: But other than that, this looks like a very normal smart contract. It's got two storage variables, A and B function called Setvars, which updates those variables. Right, very simple. What's cool about these systems, though, is that those variables A and B, when we're setting A and B in our Set VARs function, it's actually, since it's a delegate call, it's going to be updating the storage of that proxy contract. This means we could, in theory, swap out that invitation for a new one and those stored variables A and B are still going to be there for the next contract. And that's what really makes this powerful, because you get the continuity of the state of the contract stays the same between upgrades. Okay, now let's understand we need to really look under the hood of how storage works in Ethereum to properly understand why we needed to have this random implementation address inside of our implementation contract and how not to make a whole class of critical mistakes that people have been making forever with proxies.
00:09:49.710 - 00:10:12.422, Speaker A: So let's talk about storage or storage slots. A smart contract, when it stores things, it's not just storing them in a variable, but rather under the hood. It stores them in slots. And slots are sort of can be thought of as these little slots. Each one holds 32 bytes of data and they're numbered. The first slot is 0123 in increments all the way up to two to the power of 256 minus one. There's a whole bunch of them.
00:10:12.422 - 00:10:53.060, Speaker A: You can use as many as you want. However, storage and Ethereum is quite expensive, so you might want to not so because of delegate call, though, our proxy contract and our implementation contract are going to share these slots. So if we look on sort of the top right, we'll see what our original implementation looks like and we're going to see how those mapped slots within our proxy. So we have again, our three storage variables, implementation A and B. Implementation is going to be slot zero, a is going to be slot one and B is going to be slot two. This is because slot numbers are assigned in order. The implementation variable is first, so it gets slot zero and B is last, so it gets slot two.
00:10:53.060 - 00:11:38.450, Speaker A: When you look at this, it's mapped. Remember, since we're doing a delicate call, we're mapping it to the proxy. This means, well, let's think about what the storage of the proxy looks like. Well, the proxy has one variable and that's the implementation address and it goes in slot zero. So you might be able to understand why we did this because we need to make sure that we don't accidentally overwrite the implementation address that the proxy expects to be in slot zero. You can imagine a bad implementation, sort of the naive implementation you might make would just have two variables, a and B. But then because A is the first variable, it gets slot zero, which means whenever you call set VARs and you set A to something, you're accidentally, you're going to be writing what the implementation does think is A, but you're going to be overriding what your proxy thinks is the implementation address.
00:11:38.450 - 00:12:41.814, Speaker A: In other words, if you were to do that, you would lose control of your proxy system and you would never be able to upgrade it again and it would never work again. And this is a pretty common theme that we're going to run into when we talk about proxies is that there are a lot of foot guns along the ways and you really need to constantly be looking under the hood and understanding how the proxy system works in order to use it safely and effectively. And if you don't, you could very easily break your entire contract system. And if you look at some of the largest mistakes that have happened in DeFi, some of the largest hacks or just breaking protocols, a lot of them have to do with people not fully understanding the implications of their proxy systems when they're working on it. Okay, so now we're going to talk about, we're going to show you like a modern proxy, like what they really look like. And this is based off of EIP 1967, which like I said is, is sort of what most modern proxies base themselves off of. And it's almost the same, but it's got sort of one kind of difference, that is that we've removed our first storage variable, the implementation address.
00:12:41.814 - 00:13:22.738, Speaker A: Instead we've put in a constant variable. Now, constant variables don't take up storage slots, they're hard coded in our contract code, so we don't need to worry about using that storage slot zero. When we declare this variable implementation slot, then we make this variable and it's set to one constant and that's the Ketchick hash of some string here minus one. In other words, there's a reason why we do this. But what this does is it gives us a very random slot value. Now implementation slot is going to be equal to like ten gazillion and five or something like that. Now we modify our fallback function just slightly and we use a little bit of inline assembly and we directly load from that slot number and we load it and we expect the implementation to be there.
00:13:22.738 - 00:14:03.154, Speaker A: And then finally we act the same and we sort of delegate call the implementation and everything goes the same from there. But let's look at our implementation contract and you'll notice it looks a lot simpler. It's got just those two variables, your set VAR, but no implementation address. And we don't even need to think about where it is. The reason for this is that it's at this really big random number that we're never going to hit, where you can't accidentally create a smart contract. That storage layout is ever going to map some variable to the value of implementation slot. Because of this, we just get to use this almost as if it were a normal smart contract and not worry too much.
00:14:03.154 - 00:14:33.766, Speaker A: And that's awesome. And that's why most sort of modern proxies look a little bit like this. There are still ways to make mistakes here. You can imagine doing an upgrade and making a new implementation, but in that upgrade you may have swapped the locations of variables A and B. And when you do that now, you've messed up that slot mapping and now whenever you look inside B, you're looking at what was previously A in the previous version. So you still need to be very careful. You need to make sure that when you set your variables, you only append new variables.
00:14:33.766 - 00:15:04.642, Speaker A: You never delete them and you never transpose them. But if you stick to those simple rules, you for the most part can't make a mistake. And that's why people really like these kinds of proxies. But there's one last piece of complexity we do need to discuss to fully sort of understand all of the weird edges of proxies. And that's where the upgrade logic is. So what the upgrade logic is the actual function that allows some owner to call upgrade and swap out the implementation for a new one on the proxy. So there's two ways you could do this.
00:15:04.642 - 00:15:50.610, Speaker A: There's sort of the obvious approach based off of our simple proxy, right, would be to just put it inside the implementation. That's where all the code goes anyway. We already know where the implementation is stored and just have a function called upgrade that swaps it out. And this makes a lot of sense, but it does have one pretty catastrophic risk and that is that you could accidentally, during an upgrade, lose control of your proxy. The way this would happen is that you may upgrade your proxy or upgrade your implementation. In the process of that, you can accidentally modify in potentially subtle ways how that upgrade function works. If you do that just once, incorrectly, that upgrade function will stop working and you no longer have sort of a way to save yourself by upgrading because the upgrade function won't work anymore.
00:15:50.610 - 00:16:53.906, Speaker A: Now, because of this, modern proxy systems put the upgrade logic inside of the proxy and this prevents bad upgrades from bricking your upgradability logic because it lives in the proxy. The proxy is immutable anyway. It always knows where the implementation goes and you can always have that function swapping it out. It's also pretty nice organizationally. It gives you a very clear separation of concerns between the proxy, which sort of handles all of this delegate calling and storing the implementation address and the implementation which for the most part handles business logic that's where everyone really lives and spends their time is working on the implementations. But I do want to spend 1 second to go over one last proxy pattern and this is called the diamond pattern and diamond pattern gives you sort of this dynamic function dispatch to different implementations. So in our example here again we still have our proxy but rather than having a single mutation we have multiple and here we have three and they're called facets in this pattern and the proxy maps certain functions to certain facets.
00:16:53.906 - 00:17:48.060, Speaker A: So here we have function for A and other function for A, map to facet A we have function for B maps to facet B and function for C maps to facet C. And this is an incredibly powerful pattern because it means it's great for organization. You can sort of keep things segmented between different facets. You can build these really big systems, you can even get around the limit on how big smart contracts are allowed to be in ethereum which is not that big using this. But for alt power there are huge drawbacks using it. The main one is that all the facets since they're being delegate called share storage all of your storage is the proxy storage. This means when facet A updates storage it's updating the storage that facet B is using in facet C and this means it's very difficult to understand which facets own what piece of state and it's incredibly easy for one facet to overwrite storage that it shouldn't have and break your system.
00:17:48.060 - 00:18:43.850, Speaker A: Fortunately there are sort of patterns to make this better. It's called the diamond storage pattern but when you use this diamond storage pattern you need to constantly now be remembering that you're using the diamond pattern. You can't just for a moment even just consider that you're using a normal smart contract like you could in EIP 1967 style proxies. So because of this big drawback most people are pretty strongly against the diamond pattern and I tend to agree with them. I have been told that there are proponents of it but I haven't actually met one yet. So wrapping up on proxies proxies support unconstrained upgradability for the most part it's almost impossible to put limits on what an upgrade can do and it can make composability somewhat difficult. The reason why composability can be difficult is because systems that are integrating yours don't know how it will behave into the future.
00:18:43.850 - 00:19:40.598, Speaker A: So if they make your system invariance part of their core invariance they now have to extend their trust onto the team that can do the upgrading which you potentially might not want to do. Proxies also have this one big drawback that they can be difficult to reason about and this leads to very subtle bugs. So we're going to take a quick detour and talk about a set of patterns that don't really fit into our original metrics of composability of upgradability, but are still really important because they are used in a lot of the patterns we're going to talk about later to build up these more complex systems. This is authorization and it answers a very simple problem, which is how do we manage who can do what? So we're going to look at two examples of authorization patterns. The first one is incredibly simple. It's called roles based authorization. And it's probably exactly how you would do it.
00:19:40.598 - 00:20:17.420, Speaker A: You probably didn't even give this a name because it's so simple. And in our example here, we have an address that is the owner and then a mapping of address to booleans called Cool Guys. And if that entry for your address is true, then you're a cool guy. If it's false, which is the default, then you're not a cool guy. And we have two modifiers only owner which just makes sure that the sender is in fact the owner and only cool guys which makes sure that the sender is inside this Cool guys mapping. It's really simple but really powerful because it means now you could have different groups and different admins of the protocol of different powers. It allows you to sort of constrain these actors in really nice ways.
00:20:17.420 - 00:21:03.000, Speaker A: But on the other side of authorization, we're talking about a pattern that allows for a lot more complexity and can be a lot powerful. It's called DSO auth It's actually used by MakerDAO to manage its sort of very complex authorization patterns. It might not be worth using it unless you have a very complex protocol because it is sort of hard to use and harder to reason about. But it actually does look somewhat simple. We have just one address called the Authority. And whenever we want to figure out someone is allowed to do something, we simply say hey Authority. Like is this person authorized to do that? So you can see we have is authorized message sender the caller or messages SIG, which is sort of the function, a unique identity to the function they're trying to call.
00:21:03.000 - 00:22:04.090, Speaker A: In more simpler terms, what this pattern lets you do is it lets your contract say hey Authority, is Noah allowed to call Mint on my contract? Is Bob allowed to call upgrade? And the Authority is its own contract and can have sort of its own rules for making the decision. And those rules can be very complex and have sort of a lot of different subtleties. So it also means that you can allow this Authority to be upgraded. It can be reconfigured, you can sort of go crazy with it and you could have it so that things can only happen on weekdays if you really wanted to. It lets you build these really powerful complicated setups and it so now that we understand how you would do authorization, there's sort of this important facet we haven't discussed, which is how do you change authorities, like, how do you say, upgrade the owner, for example, in a safe and reliable way. And there's sort of two ways to do it. There's the obvious way, which is called unchecked receive and a more interesting way called checked receive.
00:22:04.090 - 00:22:26.750, Speaker A: So an unchecked receive, it's exactly how you would think. You got one function called set owner. Only the owner is allowed to call it. And when it's called, it passes in a new owner and it overwrites. It really, really simple and it just works. There is a risk here though, you can in a rare case, maybe set the wrong owner. And that would be really bad, particularly if it's like the ownership of your entire protocol.
00:22:26.750 - 00:23:06.766, Speaker A: Well, goodbye to your protocol. So how do you fix this? Well, there's been this pattern called checked receive, which makes sure that we are actually properly setting the new owner. And it makes a slight modification to the previous one. We looked at where our set owner function doesn't just immediately set the owner, but rather sets a new variable called the pending owner. And then we have another function called receive owner. And it simply just checks like oh, is the caller the pending owner? And if it is, then the owner is set to the pending owner. In other words, what this does is like unchecked receive was just sort of throwing the ownership into the ether and hoping an address was there to catch it.
00:23:06.766 - 00:23:57.600, Speaker A: With checked receive, we're sort of very delicately handing ownership over and we're making sure that the recipient is actually there and is real and can make a transaction. Now, this is slightly more gas expensive from a gas perspective, so you might not want to do it for everything. However, if you're dealing with a high value role like the ownership of your protocol, it's worthwhile. And in fact, compound governance, for example, the ownership of the entire protocol is owned by this thing called the time lock. And the Governance contract owns a time lock. And it turns out from time to time they upgrade the Governance contract to do new things. And each time they've done it, they've upgraded it twice now because there's been three versions of the Governance contract and each time they do it, they've used this checked receive pattern to do the upgrade because it's so, so important that they do not make the mistake when handing over the governance of the entire compound system.
00:23:57.600 - 00:24:43.600, Speaker A: Okay, so now we're going to go back into some patterns that fit in our framing and talk about modularity. This is the set of patterns I think to be incredibly exciting because it lets us do constrained upgradability. So what modularity does is it breaks the system down into several modules. And generally each module has a particular job, which is quite nice from an organizational perspective. But modules will interact with each other to form complex systems. So here we have, in our example, we have Module B and it's calling Module A and Module C and it's telling it to do some stuff but they can even have these complex authorization patterns between them. So this is actually why we just talked about authorization because modules might want to decide what other modules have permissions to do what within the system.
00:24:43.600 - 00:25:14.870, Speaker A: And this permissioning can be based on arbitrary rule sets. So DS off, for example, could be very useful here. And in our example we have module C who's approving Module B but denying module A from doing whatever it was it wanted to do. And we can also finally swap out modules for new ones. So here we have module C 2.0 which is new and improved because it is purple. And this is really useful because some modules are going to be immutable and unupgradable and some modules can be swapped out for new ones or could even be a proxy.
00:25:14.870 - 00:25:55.238, Speaker A: And this is a really, really great way to achieve constrained upgradability because what you can do is you can have these immutable modules basically gatekeep what the mutable ones are allowed to do. All right, so we're going to dive into an actual sort of example of a simple modularity pattern. I'm going to call it Simple Composition and we're going to motivate this by an example of NFT project. It's called verbsdao. It's an imaginary NFT project not inspired by any other grammatically themed NFT project. And the Verbsdao has a couple of rules they really want to maintain. One of them is that only one verb NFT can be minted per day.
00:25:55.238 - 00:26:28.574, Speaker A: One is maybe that some reserve price must be met and go back to the Verbs dao as well as it needs to be minted by some authorized auction module who has some auction system because they may want to play with different mechanisms to auction off these NFTs. So in our example, we sort of instantiate this quite simply. We have Mr. Burns here who has lots of money and wants to buy a Verbs NFT and he bids on the auction module. The auction module has some arbitrary auction mechanics to decide who the winner is. And Mr. Burns of course wins because he's got that big thing of money.
00:26:28.574 - 00:26:56.326, Speaker A: So when Mr. Burns wins, the auction module is then going to call mint on the Verbs NFT. Now what's cool here is that the auction module is going to say, okay, I swear Mr. Burns won and you should mint him an NFT. But the Verbs NFT is still since the auction module might be mutable. The Verbs NFT, however, is immutable and is going to make sure that these key constraints are maintained. So it's going to check, it's going to say, when was the last time we minted an NFT? Because if it was less than a day ago, I'm not going to let you mint another one, let's say, and what are you paying me if it's less.
00:26:56.326 - 00:27:48.438, Speaker A: Than the reserve price, I'm not going to let you mint it. And finally I'm going to check, like, are you a real auction module? Right? And what's really cool about this pattern is it gives us this constrained upgradability because these two main invariants are always going to be maintained. However, there's one invariant that isn't going to be maintained, right? The auction module is mutable. You can swap it out for a new auction module and that is really powerful because, well, you might want to change how you do your auction design, right? We just learned all about auctions from Michael and Scott. So you now know about all the different ways you can do auctions. And you may change your mind at some point to a new auction mechanism and you can simply use this little bit of upgradability to make a new auction module, but you can still guarantee to the verbsdao that the core invariant that that community really cares about will be maintained. So now we're going to look at another pattern called the invoker pattern.
00:27:48.438 - 00:28:29.954, Speaker A: Now, this is a little bit more flexible, but it can be harder to constrain. So in this example, we have some core contract. We call it the vault here, and it's got only one function on it called invoke, and it takes a two and a call data. So basically what invoke does is when it receives an invoke call, it goes ahead and makes a call. So in our example here, it's being invoked and being told to call uniswap and to perform a swap on it, right? But it can be told to call any arbitrary contract and with any arbitrary call it could be uniswap swap. It can be to mint some NFT or what have you. Meanwhile, we have these modules.
00:28:29.954 - 00:29:14.082, Speaker A: So the vault will only allow sort of modules that are registered in its system to call invoke on it. So in our example here, we have a trade module and you might guess it's going to invoke the vault to perform trades. So, like in our example, we told the vault to call unit swap and to call swap on it, right? But these trade modules are pretty unconstrained in what they can do in theory. You can, for example, have the trade module call the vault, which maybe holds a bunch of tokens, and tell it to transfer its tokens to me. And that would obviously be bad. But fortunately, we can provide a little bit of constraint on the system. So, for example, we can maybe say to the trade module or have the vault say, well, I'll let anyone it or any valid module can call invoke.
00:29:14.082 - 00:30:10.962, Speaker A: However, we're going to make sure that the call data is not the call data for transfer from or approve. And by doing just that, we've now made it so the trade module can go ahead and do whatever it can make arbitrary trades through arbitrary DEXes with weird mechanisms but fundamentally, the vault is never going to allow a module to just transfer tokens out of its own wallet. So this is quite nice. It allows us to constrain this to a certain degree, not as well as we did in the last time, but it does allow us to create new modules that we never would have thought about when we were originally instantiating it. So you remember in our last pattern, you need to think about the constraints and you need to think about the possibilities of what your system might want to do from the get go. But in this system, you can just have modules that make weird other calls. So, for example, we might make a new module called Governance Module and it might invoke the vault and tell it, hey, like you have some governance tokens in your contract, please go vote yes on this governance proposal.
00:30:10.962 - 00:30:39.802, Speaker A: And you may have never thought about this possibility, but because we've used this more flexible but yet still somewhat constrained pattern, we're able to do it. Now we're going to talk about one last sort of pattern for modularity. And this is sort of a delegate call based module pattern. And this for the most part supports unconstrained upgradability. We can constrain it just a little bit, but not really. So in our setup here we have again two contracts. And the main one is Governance.
00:30:39.802 - 00:31:15.814, Speaker A: This is our Immutable contract that cannot be changed. And then we have the proposal payload, which there can be many of them, they can be swapped out, they're Immutable and they can be changed. And then our Immutable governance contract is going to delegate call into proposal. So this pattern, the reason I'm using this framing is because this is super common in governance systems, where the action that will be performed when a vote passes is a Governance contract might delegate call into a proposal payload. And then the proposal can go on and pretend it's Governance. It can reconfigure core system of contracts because it is now acting as if it's the protocol owner. It can even update the internal state of the governance contract.
00:31:15.814 - 00:31:53.622, Speaker A: So it can, for example, modify the Quorum or the vote length or any other of these sort of internal pieces of state. Now, this is nice because it's incredibly flexible, but it does have some downsides. One, dad says it's hard to constrain, it's hard for Governance to be able to prevent the proposal payload from doing a particular action. There's one small way we can constrain it. We can, for example, have the Governance contract after the delegate call finishes. It can check some invariance, it can say, well, make sure that the proposal payload didn't, I don't know, mint new governance tokens. If it did, revert the entire transaction, sort of undo it all.
00:31:53.622 - 00:32:38.534, Speaker A: So that is one way we can do constraint, but it's hard to do. And again, it allows you to only constrain very limited sets of things. The other downside of this is that you'll notice that if you have lots of modules, lots of proposal payloads, you'll notice this looks a little bit like the diamond pattern. But because it is and for the same reason as why the diamond pattern is sort of frowned upon is this is often frowned upon in complex systems because all of these modules will share to the same state. And every time the main contract delegate calls into your module, there's a chance you are going to corrupt the state of the entire system. So it can be very, very difficult to reason about and each of these modules can modify things in unpredictable ways. So for that reason I tend to shy away from it.
00:32:38.534 - 00:33:06.622, Speaker A: I do, however, think it's fantastic for the use case of governance. Lots of provident governance systems do this. Maker, for example, does this. The only difference is that they name their proposal payload that gets delegate called into are called spells. But it's still basically this exact same setup as well as most ave proposals use this mechanism. So now I want to talk about an actual module based system that I think makes really good use case of some of these patterns. And that's zora v three.
00:33:06.622 - 00:33:32.662, Speaker A: So Zora is an NFT marketplace and they have a pretty extreme focus on decentralization. And because of this goal they've made heavy, heavy use of the module pattern and support only incredibly limited upgradability. So let's sort of lay out our scene here. We have Bart and Bart has an NFT and the smart contract NFT is on the right. And we'll see three sort of system contracts for Zora. One is called the module manager. One is called the transfer.
00:33:32.662 - 00:34:07.890, Speaker A: Helper. But we also have a bunch of modules. But we're only going to show one here which is called the Ask Module, which is sort of used for selling NFTs at fixed prices. So when Bart uses a system he starts off by telling his NFT that he approves the Transfer Helper to spend his NFT. This is a really common action for tokens you can call an approval. And what this means is that the Transfer Helper can sort of rip his NFT out of his wallet whenever it wants to. Fortunately, the Transfer Helper is in immutable contract so we know exactly how it's going to behave and in what cases it will be allowed to sort of remove that NFT from Bart.
00:34:07.890 - 00:34:40.880, Speaker A: Then the second thing Bart's going to do is he's going to prove the Ask module with the modulemator. He's going to tell the module like, hey, that Ask module, I trusted it. And this is actually sort of a core invariant of Zora is that the user always needs to approve a given module. If they don't, the modules are sort of powerless to act on that user. And then finally Bart's going to list the NFT for sale on the Ask module. And the Asked module has arbitrary rules for how it sells it. And in this case, I believe it sells it at a fixed price.
00:34:40.880 - 00:35:40.640, Speaker A: So now, let's look at how all this comes together when someone, Ned Flanders here, comes to purchase Bart's NFT. So Ned calls purchase on the Ask module and the Ask module maybe sort of, probably takes some tokens from Ned, right, and gives them the Bart. But what happens inside the Zora system? Well, the Ask module is going to tell the transfer helper, which is allowed to spend, hey, like a sale just happened, please transfer Bart's NFT to Ned. And the transfer helper, though, is not going to simply blindly trust the Ask module. Rather, it's going to sort of ask the module manager say hey, module manager, does Bart trust Ask module? Has he approved it? And in our case, because Bart had previously approved it, the module manager say yep, we approve it. And then the transfer helper will only then transfer the NFTs to the buyer. So this system is really great because it allows the modules to have these incredibly constrained behavior and user has full control over how the system is going to behave in the future because it has full control over what modules they want to trust.
00:35:40.640 - 00:36:31.834, Speaker A: Now, we can also imagine that this does support some upgradability because you can add new modules, right? But you can imagine another interesting type of upgradability that Zora doesn't support. But they could would be maybe allowing the admin to blacklist certain modules from the system. You can imagine that one module may have a critical bug in it that allows, for example, someone to steal NFTs without paying the correct price. And in theory, you could have it set up such that an admin can tell the module manager hey, this module is no good anymore, please unapprove it for all users. Now, this would be great for safety, but it wouldn't actually significantly change the trust assumptions that you have in this pretty trustless system. So wrapping up on modularity module patterns are really fantastic for constrained upgradability. And they also really give us the spectrum.
00:36:31.834 - 00:37:19.870, Speaker A: You can be as constrained or unconstrained as you want. You can use these delegate call based patterns or invoke based patterns and have them be act in whatever way the modules please. Or you can do these highly, highly constrained things like in Zora's case, it also makes composability really easy to slot in. And I think a reason for this is because of the amount of constraint you can build into your systems. If you can make core guarantees on invariant, that will always be maintained in your module system. Now, protocols integrating with it can understand how their invariants play with that and make sure that their systems will be safe when used in the context of your system forever and into perpetuity, which is fantastic, particularly for infrastructure. So the last thing we're talking about is composability.
00:37:19.870 - 00:38:19.746, Speaker A: And I think composability is sort of this essential aspect because it allows protocols to be easily integrated with other protocols and allows people to build these sort of like crazy things on top of your protocol that you may have never anticipated. And I think the key to building composable contracts is using standard interfaces. And one of the easiest ways to do this is by handling many accounting tasks using tokenization when it makes sense. So two notable examples of this are uniswap V, two LP tokens and Compound C tokens. So we're talking about uniswap v two. If you've used it, you might remember that when you deposit liquidity provide two tokens to facilitate swaps, you receive sort of a receipt for accounting called an LP token that is sort of an IOU on the underlying LP position. Now, because the LP token is just a normal token, a normal ERC 20, it becomes really easy for contracts to compose of this.
00:38:19.746 - 00:38:51.594, Speaker A: So way back in 2020, during DFI summer, this feature of Uniswap was often used to build these farming contracts. So we can have, in our example, Homer here with his LP token and he can simply deposit it inside the farm contract. Now, the farm contract might lock it up for some period of time and maybe give Homer some staking rewards for his troubles. But what's really cool about this is I don't think this is a really interesting use case of composability. It's boring. What I think is really cool about is the code. It's not because the code is cool, it's because the code's also super boring.
00:38:51.594 - 00:39:36.970, Speaker A: So in our code here, we have just our LP token address, which is an ERC 20 and a mapping of deposits. And we have two functions deposit withdraw. And all deposit does is it takes some of your token of that LP token from you and increments your deposit. Mapping entry and withdraw simply gives you the token back and decrements your entry. What you'll notice here is that there is really no mention of the mechanics of Uniswap V Two. Because Uniswap made tokenize this asset, it was incredibly easy to work with. You didn't have to think about what do I need to call to ask Uniswap how much they have? How do I make sure that person can't withdraw it? All you need to know is that Uniswap gives you an IOU and a token and you can take that token, which makes it really easy because their smart contract engineers are really good at dealing with tokens.
00:39:36.970 - 00:40:26.406, Speaker A: In the second example I'm going to give you is a little bit more complicated and it's how compound C tokens are used to build much more complex systems because of their sort of liberal use of tokenization. So in the example I'm going to use is actually going to be example from my life. When I worked at Indexcoop and set protocol, and at Index, we built crypto index products, tokens that hold other tokens. So we got really good at building infrastructure for managing tokens. So you can see here a highly simplified example of what our contracts looked like, of some mapping that kept track of how many of each token we had, as well as a trade function that allows us to swap between tokens. And let's say that was about all we could do. But we wanted to do something new, right? All we had done is had tokens that held over tokens.
00:40:26.406 - 00:40:55.458, Speaker A: And that's interesting, but not that interesting. And we wanted to build a leverage ETH product, but we again only had infrastructure for dealing with tokens. And if you think about what levering up on ETH looks like, it means you probably deposit some ether as collateral into some other complicated smart contract system. You're going to then borrow and maybe get something else like USDC. And then you're going to trade that USDC for ether and maybe redeposit your ether to up your collateralization ratio. It's complicated. And the complicated part often deals with other protocols such as like compound.
00:40:55.458 - 00:41:31.386, Speaker A: But fortunately, because of what compound does, they were able to make it really easy. And this is because compound represents their collateral as a token. They call them c tokens. So in the case of ether collateral, if you deposit it into the compound system as collateral, you get C ether as an IOU for your underlying ether. What's really nice about this though, is if you deposit ether and you get a token back, c ether, well, that just looks like a trade, right? So our system built for managing tokens and doing trades was all of a sudden able to interact with compound and do deposits. And then from the rest, it's very easy. We called a function that all of a sudden gave us USDC.
00:41:31.386 - 00:41:49.990, Speaker A: And that's just the token. We know what to deal with that trading it for ether. Another thing we were really good at. And then finally one more. Because of Compound being so great with its tokenization, we were able to deposit back into compound ether. And to us, it just looked like a trade. What's really great about this is we built this really complex system for levering up on tokens.
00:41:49.990 - 00:42:33.070, Speaker A: But we didn't need to really think too much about compound's internal mechanics. In fact, the core smart contracts we used were completely unmodified. We just had to add a couple very small modules. And because compound did this, they were able to get a new user of the protocol that contributed something like 100 million in TVL. So, really fantastic use case of composability and how we can build complicated things out of it. So wrapping up, we're building critical infrastructure that we want others to rely on. To do that, I think we need to minimize upgradability with reasonable constraints and maximize composability using standard interfaces.
00:42:33.070 - 00:42:47.580, Speaker A: And if we do those two things, I think we're building to be built on top of and you'll find people using your protocols and coming up with these sort of amazing use cases that you never would have considered before. So happy to take any questions.
00:42:48.270 - 00:43:20.414, Speaker B: Thanks so much. No, I thought that was a really interesting talk. In one of the previous slides, or the earlier slides, it seemed like the core problem with modularity is this idea of memory management in the proxy and delegate contract spaces. The solution you presented, using the Kachak hash to kind of like dynamically allocate the implementation address, it seems like you could kind of extend that out to do dynamic memory allocation in general. Has anybody thought about a separate contract that could be used to dynamically allocate slots instead of depending on the compiler?
00:43:20.542 - 00:43:59.354, Speaker A: Yeah, so this actually does get used. So I didn't really go into it because the thing I wanted to convey on the diamond pattern is not to use it, but the diamond pattern generally when you use it, use this thing called diamond storage. And the whole point of that is it's sort of like this library that maps your variables to weird slots and makes sure that the different facets don't conflict. So people have thought a lot about this in the context of proxies and in a lot of other pretty interesting concepts, but because of it, it's still really easy to make the mistake of like if you just accidentally allocate a variable, which is something that you would very often do, you can completely break the system. So I still sort of shy away from using these techniques.
00:43:59.482 - 00:44:04.462, Speaker B: Yeah, it makes a lot of sense. It reminds me the early days of Malik versus using the stack for variables.
00:44:04.526 - 00:44:05.138, Speaker A: Exactly.
00:44:05.304 - 00:44:06.180, Speaker B: Thank you.
00:44:06.870 - 00:44:34.940, Speaker C: I wanted to ask this maybe isn't related to the design patterns themselves, but more like around tooling. If you've seen anything that developers use to kind of track across all these proxies and these contracts they're deploying, you end up with a ton of contracts on chain. How do you track what did you actually deploy, what belongs to your organization, and is there anything that's out there to solve that?
00:44:35.390 - 00:44:58.158, Speaker A: Unfortunately, not a ton. Hardhat does have OpenZeppelin has this upgrade library. It's written in JavaScript or TypeScript, and you can use it to manage your upgrades a little bit. So it's really good for working with proxies. But there isn't, I think, a great generalized thing for keeping track of all your contracts. You can build it yourself. When I worked at Index, we built one ourself.
00:44:58.158 - 00:45:15.306, Speaker A: It was a very complicated deployment process that loaded addresses in this big mapping and when a new one was deployed, it would update it. So you can build it. I can link you to that repo, but I haven't seen anyone building a good sort of pre built one. Yeah.
00:45:15.408 - 00:45:43.282, Speaker C: Thank you. Hi Lewis from Shield. When you talked about the modularity and being able to approve certain modules that are related to that transaction? Are there instances where that gets a bit complicated and you have to approve a bunch of modules individually and thinking of, UX, how is it so that you can do that? And as a like, I don't have to think about I think so.
00:45:43.336 - 00:46:29.150, Speaker A: In Zora's case, they skew crazy towards being as unupgradable as possible. So they do require the user to constantly approve it. Right, but if you think about other modularity cases, for example, our simple composition, one with the verbsdao, the user doesn't need to be in the loop. They buy their NFT via the auction module, they call the auction module and it sort of seems to just work. So the Zora is kind of special in that regards. But you are kind of right that it does get complicated when you have lots of modules with different interactions and different rules for who can do what. You need to sit down and really map the authorizations that are out there and make sure that there is in fact no way to produce a complicated series of calls between modules or a complicated upgrade that can sort of get around your core invariants.
00:46:29.150 - 00:46:31.900, Speaker A: Awesome. Well, thank you so much, Noah. That was great.
