00:00:00.650 - 00:00:34.822, Speaker A: So in this talk, I'm going to describe and explain data availability sampling, protodink sharding and dink sharding. If you haven't heard these terms before, this is somewhat new developments in the blockchain space. Those are being pioneered by the Ethereum Foundation and those effectively will come to shard our blockchains to make them more scalable, but do so in a much, much simpler way compared to the ideas for Sharding that we had before. Since a number of projects are working on data availability solutions, I hope it's helpful to show how some of the best schemes work so that others could.
00:00:34.876 - 00:00:37.350, Speaker B: Either improve on those and pick up.
00:00:37.420 - 00:00:39.538, Speaker A: Perhaps an idea for research project from.
00:00:39.564 - 00:00:46.090, Speaker B: This work, or incorporate these ideas into their own projects. So I'll start with explaining what problem.
00:00:46.160 - 00:00:55.786, Speaker A: Ethereum is trying to solve here. I'll show where it fits onto the roadmap. I'll explain exactly what will be achieved by this upcoming upgrades and I'll briefly.
00:00:55.818 - 00:00:57.760, Speaker B: Explain how this is going to be done.
00:00:58.210 - 00:01:00.714, Speaker A: So, the main goal with this upcoming.
00:01:00.762 - 00:01:03.342, Speaker B: Upgrades is to help Ethereum scale and.
00:01:03.396 - 00:01:22.418, Speaker A: Ethereum L2 S or Roll ups effectively already help scale the execution of transactions. These L2 S take some subset of transactions and process them off chain. The chain only sees the post effect of these transactions. So Ethereum Validator set effectively doesn't have to execute those transactions.
00:01:22.514 - 00:01:25.218, Speaker B: Those executions are happening off chain.
00:01:25.394 - 00:01:34.358, Speaker A: Gas fees are typically a good indicator of whether we are making the blockchain more scalable. So if the gas fees go lower, it means it's cheaper for the validators.
00:01:34.374 - 00:01:36.666, Speaker B: To process those transactions, so we make.
00:01:36.688 - 00:02:13.302, Speaker A: The blockchain more scalable. So, if you look at the gas fees on the L2 S, they're typically six to 30 times smaller compared to transacting directly on Ethereum. But if we dive deeper and dissect the gas costs on each of the rollups, for example, if you look into optimism, we will see that most of the transaction fees go to L One data fees. So those fees go to storing transactions. Storing data on an Ethereum L One and only a tiny fraction, only the top kind of gray area shows you how much you pay for the actual.
00:02:13.356 - 00:02:15.590, Speaker B: Execution fees on the L2.
00:02:15.740 - 00:02:25.738, Speaker A: So we can make roll ups even cheaper if we lower the cost of storing data on the Ethereum L One. And that's what Ethereum is trying to do with this upgrades that I'm going.
00:02:25.744 - 00:02:27.754, Speaker B: To explain in this talk.
00:02:27.952 - 00:02:41.866, Speaker A: So there were a number of proposals for how to make Ethereum scale and how to make storing data cheaper. Some of the initial ideas were around full charting. Full charting effectively splits your large blockchains.
00:02:41.898 - 00:02:45.214, Speaker B: Into smaller blockchains and tries to sync between them.
00:02:45.332 - 00:03:00.374, Speaker A: That's a very complicated design. And the nice thing about the current state of Ethereum is that roll ups are effectively already doing part of the split. They take some of those transactions and execute them themselves and then they use the Ethereum l One in order to.
00:03:00.412 - 00:03:02.402, Speaker B: Sync between those roll ups.
00:03:02.546 - 00:03:13.338, Speaker A: So L2 S already kind of went into the direction of full sharding. So the only thing that Ethereum blockchain really needs to do for this roll ups to become even cheaper is to.
00:03:13.344 - 00:03:16.010, Speaker B: Allow them to store data with lower fees.
00:03:16.510 - 00:03:50.054, Speaker A: So full sharding was kind of replaced with another two proposals, at least for now. Those have very similar names, EIP 4488 and EIP 4844. AIP starts for Ethereum improvement proposal. So don't mix them up. They're pretty different. The 4488 was proposing to make call data cheaper, but instead Ethereum decided to focus on another proposal, EIP 4844, which suggests to add data which will have an expiry. So the Ethereum will now store some.
00:03:50.092 - 00:03:52.886, Speaker B: Data blobs some data fragments that it.
00:03:52.908 - 00:04:00.246, Speaker A: Will expire and erase after some period of time. The current thinking is it's going to be one to two months of guaranteed storage.
00:04:00.358 - 00:04:03.670, Speaker B: EAP is also called colloquially protodank Sharding.
00:04:03.830 - 00:04:11.420, Speaker A: So that's what Ethereum is implementing right now. It's mostly implemented. It should be incorporated into Ethereum pretty soon.
00:04:11.790 - 00:04:13.466, Speaker B: So if we look into the roadmap.
00:04:13.498 - 00:04:15.882, Speaker A: For Ethereum and where those upcoming upgrades.
00:04:15.946 - 00:04:18.718, Speaker B: Fit in there, the merge is already done.
00:04:18.804 - 00:04:26.690, Speaker A: So the next is helping rollups scale. So the protodank sharding will come first and the protodank sharding will follow.
00:04:26.760 - 00:04:28.946, Speaker B: That still requires a bit of a.
00:04:28.968 - 00:04:30.466, Speaker A: Research, and there are a number of.
00:04:30.488 - 00:04:32.478, Speaker B: Open problems still to be solved.
00:04:32.654 - 00:04:50.714, Speaker A: So why roll ups need the blockchain to store some data without executing them? That's kind of a one slide explanation of what a rollup is and why it needs to store some data onto Ethereum L One. So roll ups are processing transactions from the users off chain. They're kind of taking all of these.
00:04:50.752 - 00:04:54.726, Speaker B: Transactions, executing them, and instead of relaying.
00:04:54.758 - 00:05:12.542, Speaker A: Them to the L One, they're only posting a single transaction that reflects the effect of all of those green transactions on the right. So this transaction TX is going to update the state transition. It's going to update the Merkler root hash of account balances effectively or account.
00:05:12.596 - 00:05:14.846, Speaker B: States from S to S prime, and.
00:05:14.868 - 00:05:48.858, Speaker A: Will only be allowed to do so if it can present a commitment to the transaction list on the left. So the commitment to the user transactions and a valid proof that the state transition conforms to this transactions and then use the commitment that those transactions are valid. So the transaction is really succinct. Because the root state is small, the commitment is typically also very small. This proof can be there or may not be there, depending on the type of the roll up we're talking about. If it's zero knowledge roll up, this will be a zero knowledge proof. Then the size of the proof will depend, of course, on the type of.
00:05:48.864 - 00:05:50.890, Speaker B: The proof system that the roll up is using.
00:05:51.040 - 00:06:00.014, Speaker A: If it's an optimistic roll up, then the proof will not be there and will be fraud proof based. So the clients will have an opportunity to raise a dispute if they think.
00:06:00.052 - 00:06:02.910, Speaker B: That the state transition was done incorrectly.
00:06:03.570 - 00:06:07.746, Speaker A: Those transaction lists needs to be made available in order for the roll up.
00:06:07.768 - 00:06:09.630, Speaker B: To be fully trustless.
00:06:09.790 - 00:06:25.078, Speaker A: What it means is that the roll up should be replaceable. Anybody, if the roll up goes down, becomes malicious disappears. Anybody can replace the state of the roll up by restoring its state. In order to restore the state and get all of the account states of.
00:06:25.084 - 00:06:27.510, Speaker B: The users underneath the roll up, this.
00:06:27.580 - 00:06:50.026, Speaker A: New entity new roll up needs to replay all of the transactions. And in order to replay transactions, it needs to download them from somewhere. So that's why rollaps are storing this transaction list on some data availability solution. And typically that's an Ethereum blockchain itself. So that's where most of the gas costs for roll ups go. And if Ethereum can make it cheaper for roll ups to store those transaction.
00:06:50.058 - 00:06:53.710, Speaker B: Lists, it will make the roll ups fees cheaper.
00:06:54.050 - 00:07:13.766, Speaker A: So if we look into Ethereum block size today, it's pretty small, only about 100 KB. So 0.1 megabyte per single block. One block appears every 12 seconds. Now, with Protodank Sharding, the suggestion is to expand the block size with additional data. So about 0.5 megabytes of data.
00:07:13.766 - 00:07:27.066, Speaker A: The main purpose of this data is availability. Validators will not have to do any processing on this data. They will need to make it available only. So we will maintain this 100 KB data for execution, but we'll add an.
00:07:27.088 - 00:07:29.686, Speaker B: Additional 500 KB for storage.
00:07:29.878 - 00:07:35.914, Speaker A: The storage data for Protodank Sharding is going to be fully replicated between the Validators, and it will have an expiry.
00:07:35.962 - 00:07:37.182, Speaker B: Of one to two months.
00:07:37.316 - 00:07:41.998, Speaker A: This data will not be accessible to execution. Only a digest of the data will.
00:07:42.084 - 00:07:43.806, Speaker B: Some hash of the data and the.
00:07:43.828 - 00:07:45.598, Speaker A: Main users for this data are going.
00:07:45.604 - 00:07:46.638, Speaker B: To be roll ups.
00:07:46.734 - 00:08:06.134, Speaker A: And then what will come next is Dank sharding. It will expand the data even further. And the hope is that it will grow as large as 30 megabytes, which is mind blowing. So this data will have the same property as for Protodon Sharding. It will have an expiry. It will not be accessible to execution, but the Validators will be storing this.
00:08:06.172 - 00:08:08.338, Speaker B: Data and will be serving it to the clients.
00:08:08.514 - 00:08:17.594, Speaker A: The reason why we can make this second jump from zero five megabytes to 30 megabytes will be the main focus of my talk. I will explain how this expansion is.
00:08:17.632 - 00:08:21.178, Speaker B: Possible without making the Validators store more data.
00:08:21.344 - 00:08:34.234, Speaker A: So storage of this data is going to be distributed among the Validators instead of replicated. Validators will not be storing 30 megabytes for each block. They will cleverly split this data and only store small fragments of each block.
00:08:34.362 - 00:08:36.402, Speaker B: So if you look into Ethereum state.
00:08:36.456 - 00:08:42.606, Speaker A: Size, in order to be processing transactions, each Validator needs to store about 100GB.
00:08:42.638 - 00:08:45.470, Speaker B: Of data in order to verify and execute transactions.
00:08:45.550 - 00:09:18.606, Speaker A: So Prototync Sharding will grow the storage requirement a little bit. Since we add this additional data that the validators will now need to store for a month or two months, the state is going to grow to about 200 to 400GB. And then with Link Sharding, despite the fact that we're going to increase the block size, the storage on the validator side is going to stay roughly the same because the storage data will now be split between the validators instead of fully replicated. So with Dank Sharding, validators will still keep about 200, up to 400GB of.
00:09:18.628 - 00:09:20.826, Speaker B: Data in order to execute transactions.
00:09:21.018 - 00:09:31.694, Speaker A: So let's see what Protodank writing is. Protodank Riding introduces a new transaction type called Blob carrying transaction. Each transaction of this type will submit.
00:09:31.742 - 00:09:34.370, Speaker B: A long data vector and a short.
00:09:34.440 - 00:09:36.498, Speaker A: Commitment to this vector, which is going.
00:09:36.504 - 00:09:38.194, Speaker B: To be signed by the user.
00:09:38.322 - 00:09:42.418, Speaker A: The thinking right now is that the number of these vectors will be initially.
00:09:42.514 - 00:09:44.774, Speaker B: Pretty small, two, three, or four.
00:09:44.892 - 00:09:55.974, Speaker A: And the size of each of the vectors is about 130 KB. So that's rough sizes, I guess. Ethereum plans to see how the validators react to that and then maybe increase.
00:09:56.022 - 00:09:57.690, Speaker B: Or decrease this number.
00:09:57.840 - 00:10:05.566, Speaker A: So this data is going to expire in one to two months so that validators will drop the data Blobs, but they're going to keep the commitments, so.
00:10:05.588 - 00:10:08.622, Speaker B: The commitments persist, and Blob data will.
00:10:08.676 - 00:10:22.770, Speaker A: Have separate fee market. So cold data is the cheapest way to store data in Ethereum right now costs about 16 gas per one byte. This Blob data is going to cost one gas per one byte, but there's going to be a separate fee market.
00:10:22.840 - 00:10:23.986, Speaker B: For this Blob data.
00:10:24.088 - 00:10:30.994, Speaker A: So we don't really know right now until it's been implemented and running. How this gas two compares to gas.
00:10:31.042 - 00:10:33.046, Speaker B: One, that remains to be seen.
00:10:33.228 - 00:10:47.882, Speaker A: So let me explain you the commitment scheme that Protodyncarney is going to use. I was saying that we will use a commitment scheme here to commit to the data vector. Now, Hash is a good commitment scheme, so you can just hash a data.
00:10:47.936 - 00:10:50.838, Speaker B: Vector and it's going to be a binding commitment.
00:10:50.934 - 00:11:15.346, Speaker A: But we will do something more clever called polynomial commitments, and this commitment will give us some additional properties. The commitment that Protodynx Sharning is using is KCG polynomial commitment. I'll explain it in one slide. If you haven't seen this before, this will give you a rough idea, but I highly encourage you to look into the paper. It's a very well written paper and it's easy to follow and see how everything works, and even the proofs pretty straightforward in this paper.
00:11:15.368 - 00:11:17.070, Speaker B: It's a very elegant scheme.
00:11:17.230 - 00:11:29.599, Speaker A: So we assume that we have three elliptic curve groups g one, G two, and GT, with a bilinear pairing that will operate on the groups g one and G two will move effectively. An element in G one and an.
00:11:29.599 - 00:11:31.846, Speaker B: Element in G two to the group GT.
00:11:31.958 - 00:11:37.382, Speaker A: This polynomial commitment scheme requires a trusted setup that will generate a structured reference.
00:11:37.446 - 00:11:38.746, Speaker B: String of this form.
00:11:38.848 - 00:11:40.986, Speaker A: So G one is a generator of.
00:11:41.008 - 00:11:42.026, Speaker B: The group G one.
00:11:42.128 - 00:12:03.678, Speaker A: So the SRS is going to be of the form G one to the power tau, G one to the power tau squared, G one to the power tau cubed, et cetera. So they're going to be n powers of tau in this SRS. And the way I'm going to describe it, you only need one power tau in G two, but for efficiency reasons you may want to generate several of those to do batch proving, which I'm.
00:12:03.694 - 00:12:05.058, Speaker B: Not going to explain now.
00:12:05.224 - 00:12:07.106, Speaker A: So the SRS should be generated in.
00:12:07.128 - 00:12:09.130, Speaker B: Such a way that nobody knows tau.
00:12:09.230 - 00:12:17.542, Speaker A: And when SRS is published, of course, in these groups the discrete logarithm problem is hard. So given G one to the tau, there is no way you can figure.
00:12:17.596 - 00:12:20.330, Speaker B: Out tau unless you can break discrete logarithm.
00:12:20.750 - 00:12:27.386, Speaker A: So KCG polynomial commitment allows you to commit to a polynomial of degree n, and this n is the same as.
00:12:27.408 - 00:12:28.726, Speaker B: The size of the SRS.
00:12:28.838 - 00:12:36.286, Speaker A: So the polynomial is described as usual school book polynomial representation. You have a coefficient, say zero a.
00:12:36.308 - 00:12:38.666, Speaker B: One, a two an, and the polynomial.
00:12:38.698 - 00:12:42.506, Speaker A: Is the sum of a zero a one times x, a two times x squared, et cetera.
00:12:42.538 - 00:12:44.798, Speaker B: So all the usual nice stuff.
00:12:44.964 - 00:13:18.986, Speaker A: You can commit to this polynomial with a very short element in G one. So I put it in gray just because I don't want to go into too much detail, but this commitment is effectively G one to the power f of tau. And it's pretty remarkable because no matter the degree of the polynomial, it can be as large as you want, as long as it's smaller than the SRS, you can still commit to a large polynomial with a constant size element. So CF binds you to the polynomial. There is no way without knowing tau to come up with another polynomial that.
00:13:19.008 - 00:13:21.594, Speaker B: Will commit to the same c and.
00:13:21.632 - 00:13:23.822, Speaker A: It'S constant size, it's just a single.
00:13:23.876 - 00:13:27.470, Speaker B: Element in G one. Now, to open a commitment, I can.
00:13:27.540 - 00:13:33.038, Speaker A: Basically prove to you that the polynomial underneath the commitment evaluates to a certain.
00:13:33.124 - 00:13:34.782, Speaker B: Value at a given point.
00:13:34.916 - 00:13:36.514, Speaker A: And the proof is also very short.
00:13:36.552 - 00:13:38.770, Speaker B: It's a single element in G one.
00:13:38.920 - 00:13:49.026, Speaker A: Now the committer and the opener needs to know the polynomial. Now, the verifier, in order to verify that the committed polynomial evaluates point alpha.
00:13:49.058 - 00:13:53.794, Speaker B: To some value beta, it only needs to know the short proof pi.
00:13:53.922 - 00:13:58.826, Speaker A: So it's a very efficient way to convince somebody that the polynomial evaluates to.
00:13:58.848 - 00:14:01.850, Speaker B: A certain value with a very short proof.
00:14:02.190 - 00:14:21.614, Speaker A: So the polynomial commitment scheme is basically these three functions, the commit open and verify. Now, this polynomial commitment is binding, so the main property is it's polynomial binding and evaluation binding. It's not possible to come up with another polynomial that will commit to the same value. And it's also not possible to open.
00:14:21.652 - 00:14:25.470, Speaker B: This polynomial at the same point to two distinct values.
00:14:25.630 - 00:14:30.034, Speaker A: So once you commit to the polynomial, you can only faithfully approve things about.
00:14:30.072 - 00:14:36.414, Speaker B: The polynomial being committed there. All right? So that's the polynomial commitment scheme, and.
00:14:36.472 - 00:14:43.878, Speaker A: It can be viewed as a vector commitment, because effectively you can commit this way to the vector of evaluations of.
00:14:43.884 - 00:14:46.754, Speaker B: This polynomial f, and then the prover.
00:14:46.802 - 00:15:01.466, Speaker A: Can open selectively any elements of this vector commitment to convince the verifier of the selective opening of this commitment. So, as I mentioned, this scheme requires a trusted setup. And Ethereum is running a trusted setup right now.
00:15:01.568 - 00:15:04.410, Speaker B: It's generating four powers of tau strings.
00:15:04.570 - 00:15:10.670, Speaker A: The first string has 4095 powers in G one and 64 powers in G two.
00:15:10.740 - 00:15:16.398, Speaker B: The size of this whole setup is about 200 KB. Then there is a larger setup, twice.
00:15:16.414 - 00:15:25.662, Speaker A: As much powers in the G one. So up to tau to the 8000, that's about 400. Then you have larger and larger setups.
00:15:25.726 - 00:15:35.746, Speaker B: Those that are effectively two times the lengths of the previous strings. So 400 you can participate in the setups.
00:15:35.778 - 00:16:01.726, Speaker A: Right now it's basically every participant that shows up can re randomize this string and add randomness to this tau. And the whole process is engineered in such a way that as long as there is one honest participant who correctly contributes to the setup and completely erases and forgets the randomness used to participate, the whole setup is secure. So you can show that as long as one participant forgets the secrets in.
00:16:01.748 - 00:16:04.582, Speaker B: Its contribution, nobody would know the tau.
00:16:04.666 - 00:16:16.534, Speaker A: So these types of setups really benefit from a large number of participants, because in a large number of participants, more likely somebody will be honest and will correctly erase all of the secrets and.
00:16:16.572 - 00:16:20.470, Speaker B: Not keep them around. There is a link to participate.
00:16:21.450 - 00:16:33.994, Speaker A: So the way this committee scheme is used in protodync Sharding, the data is treated as a vector of 4096 elements in ZP, where P is a prime, it's an order of g, one group.
00:16:34.032 - 00:16:43.386, Speaker B: Of the BLS twelve 381 curve. So P is about 256 bits. So the data blob is just a vector of this 256 bit elements.
00:16:43.578 - 00:17:11.254, Speaker A: That's about 130 KB. We interpolate the polynomial through those values, so we create a polynomial of degree 4095, such that f of I equals Yi. And we know that such polynomial is going to be uniquely determined just because the number of points is 4096 and the degree for the polynomial is 4095. So such polynomials are always uniquely determined. And then the commitment to this data.
00:17:11.292 - 00:17:17.142, Speaker B: Blob is the commitment to the polynomials, the KZG commitment. And the nice thing about KZG is.
00:17:17.196 - 00:17:31.886, Speaker A: I can show you selective disclosure of this data blob. I can prove to you that certain points indeed correct values of the data blob and that they conform to the commitment that they generated in the first place by doing KCG openings on this.
00:17:31.908 - 00:17:34.974, Speaker B: Polynomial f. So at the high level.
00:17:35.092 - 00:17:46.580, Speaker A: We have our old transaction lists that ethereum blocks contain. And then with protodank Sharding, additionally, the block is going to contain the commitment to the data blobs and the data blobs themselves.
00:17:47.270 - 00:17:47.682, Speaker B: Okay?
00:17:47.736 - 00:17:50.258, Speaker A: So new ethereum block is now going.
00:17:50.264 - 00:17:52.354, Speaker B: To consist of two parts, the old.
00:17:52.392 - 00:18:03.366, Speaker A: Ethereum block commitments and then data blobs. So the green is the block for execution, and it's going to be fully replicated to the validator set. So each validator is going to store.
00:18:03.468 - 00:18:07.142, Speaker B: The green block, but the yellow data.
00:18:07.196 - 00:18:13.386, Speaker A: Blobs are blocks for storage. Those are for protozank Sharding, also going to be fully replicated. But those are going to have an.
00:18:13.408 - 00:18:15.194, Speaker B: Expiry of one to two months.
00:18:15.392 - 00:18:21.530, Speaker A: So the ethereum block size now comprises of two parts 0.1 megabytes of data.
00:18:21.600 - 00:18:27.722, Speaker B: For execution and 0.5 megabytes of data for storage. So that's proto Dank Sharding.
00:18:27.866 - 00:18:37.614, Speaker A: Now let me explain you the Dank Sharding. Dank Sharding is an invention of Dankrad Feist from the Ethereum Foundation, and it's even named after him. So Dank in dank.
00:18:37.662 - 00:18:39.694, Speaker B: Sharding stands for Dankrad.
00:18:39.822 - 00:19:03.162, Speaker A: So the idea is to apply erasure coding. So don't be scared. This erasure coding we're going to use is super simple. So our data blob, as I was explaining before, is evaluation of a polynomial at points one, two, up to 4096. And we're going to continue evaluating this polynomial, evaluate it at zero, 4097, 98, et cetera. So we're going to evaluate at 4096.
00:19:03.216 - 00:19:07.610, Speaker B: More points, and this is going to be an extension of our data blob. Okay?
00:19:07.760 - 00:19:18.414, Speaker A: So that's called read sullivan encoding or low degree polynomial extension. So you interpolate the polynomial through the first half, through the data blob, and then you evaluate this polynomial at more.
00:19:18.452 - 00:19:21.630, Speaker B: Point to extend the data blob to create this extension.
00:19:22.130 - 00:19:28.706, Speaker A: Now, since the polynomials of degree 4095, it means that any 4096 elements are.
00:19:28.728 - 00:19:31.890, Speaker B: Enough to reconstruct f. So even if.
00:19:31.960 - 00:19:52.442, Speaker A: Some of the elements of the extended data blob get corrupted, you can still reconstruct the original polynomial and reconstruct your data blob. So that allows us to do the dispersion of data. What we can do is we're going to take this extended vector where there are 8192 elements, and we're going to.
00:19:52.496 - 00:19:55.446, Speaker B: Give each validator one element of this vector.
00:19:55.638 - 00:20:09.822, Speaker A: Now, if some of the validators go Byzantine go missing, they drop their fragments. As long as 50% of validators are honest and correctly keep their fragments, we can always reconstruct all of the data.
00:20:09.956 - 00:20:12.734, Speaker B: From just 50% of it just because.
00:20:12.772 - 00:20:16.786, Speaker A: Of this property, as on the polynomial, that any half of the elements are.
00:20:16.808 - 00:20:20.338, Speaker B: Enough to reconstruct f. All right, so.
00:20:20.424 - 00:20:33.318, Speaker A: This is an initial idea. We're going to make it more efficient. But for now, the commitment to the polynomial f is going to be fully replicated to the validator set, but the actual vector is going to be split into fragments, and each validator is going.
00:20:33.324 - 00:20:36.310, Speaker B: To get one evaluation of this polynomial.
00:20:36.650 - 00:20:38.994, Speaker A: The question is how the validators know.
00:20:39.052 - 00:20:40.982, Speaker B: That they got correct fragments?
00:20:41.126 - 00:20:46.310, Speaker A: Well, they get the commitment opening proofs for their fragments from the block builder.
00:20:46.390 - 00:20:48.362, Speaker B: So the block builder is going to.
00:20:48.416 - 00:21:04.286, Speaker A: Do some heavy computation to not only extend the data block by evaluating the polynomial at more points, dispersing the elements to the validators, it will also produce evaluation opening proofs to convince the validators that the fragments that they got correspond.
00:21:04.398 - 00:21:05.970, Speaker B: To the actual commitments.
00:21:06.550 - 00:21:12.706, Speaker A: So how do we apply these ideas to multiple data blobs or A block? Because it's not very useful for a.
00:21:12.728 - 00:21:15.182, Speaker B: Single vector, it's pretty straightforward.
00:21:15.246 - 00:21:21.926, Speaker A: So in Dank Sharding, the number of data Blobs is up to 256. So that's about 32 x increase from.
00:21:21.948 - 00:21:23.170, Speaker B: Draw to Dank Sharding.
00:21:23.250 - 00:21:27.826, Speaker A: So we're going to extend each data Blob individually, the same way I explained.
00:21:27.858 - 00:21:30.502, Speaker B: Before, and then we're going to split.
00:21:30.566 - 00:21:41.386, Speaker A: The extended block into columns, and each validator will receive a column of this extended block. So as long as 50% of validators are honest, they can always piece the.
00:21:41.408 - 00:21:44.366, Speaker B: Block back together because every row can.
00:21:44.388 - 00:21:46.814, Speaker A: Be interpolated and can be corrected for.
00:21:46.852 - 00:21:52.970, Speaker B: Erasures if you only have 50% of elements in it. So Dank charting goes a step further.
00:21:53.050 - 00:21:59.342, Speaker A: This scheme already works. There is one annoying part where you might want to use some more complicated.
00:21:59.406 - 00:22:02.750, Speaker B: Tools, and that's the locality of the reconstruction.
00:22:02.910 - 00:22:35.678, Speaker A: So right now, if the validator is missing its column, the way to get it back is to try to reconstruct the whole block effectively. So this poor validator will have to talk to the whole validator set to try to get 50% of columns, then do the interpolation to reconstruct his missing fragment. So that's not great because the blocks in Denk Sharding are really large. Those are 30 megabyte blocks. So that's going to take a lot of effort on the validator side. And the hope is that validators can be really light, that this will not.
00:22:35.764 - 00:22:38.538, Speaker B: Add a lot of burden on the validators.
00:22:38.714 - 00:22:53.474, Speaker A: So for that, Denk Sharding does another step. So let me explain how Denk Sharding achieves local reconstructibility. How do we make sure that the validators can reconstruct its missing fragment with few other fragments without going to the.
00:22:53.512 - 00:22:57.394, Speaker B: Full validator set, without doing full reconstruction? Right.
00:22:57.432 - 00:23:32.186, Speaker A: So right now, if the validator is missing, its fragment needs to reconstruct the whole block. But to get local reconstruction, dank Sharding needs two additional properties of the commitment scheme. It needs homomorphism of the commitments. So the commitment to polynomial f plus the commitment to polynomial G gives you the commitment to polynomial F plus G. So you can add up the commitment and this will cause the polynomials to add up. KCG commitments are homomorphic, bulletproof commitments are homomorphic, fry commitments are not, for example. So we have plenty of examples of homomorphic commitments.
00:23:32.186 - 00:23:55.286, Speaker A: And that's what we're going to need for this step. For Denkrating and the other property we will need is homomorphism on the proofs. And that's a tricky property. And we only know of KZG commitments that achieve both, that achieve homomorphism on the commitments and homophobiaism of the proofs. Unfortunately, KZG commitments require a trusted setup. So that's an open problem of how to construct the commitment scheme with both.
00:23:55.388 - 00:23:57.490, Speaker B: Properties without a trusted setup.
00:23:57.570 - 00:24:11.002, Speaker A: There's some work being done in the group sofano and order that's pretty recent. But the homomorphism of the proofs property says that you can add the proofs. So you can now take the opening proof for the polynomial f and point.
00:24:11.056 - 00:24:12.686, Speaker B: Alpha and you can add it to.
00:24:12.708 - 00:24:19.966, Speaker A: The proof for the polynomial g at point alpha. And this will effectively be the same proof as for the opening of the.
00:24:19.988 - 00:24:21.790, Speaker B: Sum of the polynomials.
00:24:22.130 - 00:24:24.946, Speaker A: Okay, so those two homomorphic properties are.
00:24:24.968 - 00:24:29.250, Speaker B: Required to make Ding Sharding achieve local reconstructibility.
00:24:30.150 - 00:24:32.530, Speaker A: So here is how this property is used.
00:24:32.600 - 00:24:34.770, Speaker B: So the way I explained it before.
00:24:34.840 - 00:24:50.342, Speaker A: We were using univariate polynomials and we were evaluating those univariate polynomials at more points to create this extension on the right. Now, you can also treat the whole block as a Bivariate polynomial. So you can feed a Bivariate polynomial.
00:24:50.406 - 00:24:53.894, Speaker B: D through this left part and evaluate.
00:24:53.942 - 00:24:57.946, Speaker A: It at more points on the right, and you can also evaluate it at.
00:24:57.968 - 00:25:00.140, Speaker B: More points extending down.
00:25:00.830 - 00:25:03.514, Speaker A: Now, extension to the right is equivalent.
00:25:03.562 - 00:25:06.558, Speaker B: To the univariate case, but extension down.
00:25:06.644 - 00:25:38.210, Speaker A: Can also be done in a univariate fashion if you feed a univariate polynomial through each column and evaluate more points. But it's much nicer to view it as a bivariate polynomial evaluation. So that's how it's done. You basically do two x expansion to the right and two x expansion down. And now with this expanded block, each validator is going to get two rows and two columns of data. So let me just explain a little more detail. Each validator is getting from the builder all of the commitments.
00:25:38.210 - 00:26:12.514, Speaker A: So C one through C 256, those are commitments to the vectors of the original block. Now, it also gets from the builder two rows of extended block and two columns. Columns will be slightly larger. It's going to be columns of width 16. This is done in order to make this game a little bit more efficient, because you can do evaluation opening proof on 16 elements, and they're also going to be short. So the proof size for opening 16 elements is the same as a proof size opening a single element. It also is more friendly to the network because you're sending a little bit.
00:26:12.552 - 00:26:15.300, Speaker B: More data, so your packets are more full.
00:26:15.990 - 00:26:18.290, Speaker A: That's just a technicality for why it's.
00:26:18.370 - 00:26:21.046, Speaker B: 16 widths column, but you can think.
00:26:21.068 - 00:26:23.046, Speaker A: Of it as the validator getting two.
00:26:23.068 - 00:26:33.558, Speaker B: Rows and two columns. So that's about two megabytes per validator per block. Now to verify the elements in the bottom half we need the commitment scheme.
00:26:33.574 - 00:27:03.266, Speaker A: To be homomorphic because those extension is a linear transformation on the block wherever you're interpolating the polynomial and evaluating at more points, that's actually a linear transformation on the vectors that you are doing so you can translate this linear transformation and extend the vector of polynomials to also cover the bottom half rows of this matrix and that's how you can verify that you actually got the correct row, that your row corresponds to the commitments you can use the homorphism to.
00:27:03.288 - 00:27:08.850, Speaker B: Extend these commitments and then check that your row commits to the extended commitment.
00:27:09.190 - 00:27:23.206, Speaker A: But for the columns, each validator is going to get the proofs from the builder and again, for those at the bottom part, it's going to just check against the commitments, these green commitments for the top part and for the bottom part, the commitments are going to be extended and you're going to be checking.
00:27:23.238 - 00:27:27.030, Speaker B: Again against those bottom commitments each validator.
00:27:27.110 - 00:27:31.594, Speaker A: Can now locally reconstruct its missing pieces so if the validator, say is missing.
00:27:31.642 - 00:27:33.934, Speaker B: A column, it's going to ask other.
00:27:33.972 - 00:27:49.982, Speaker A: Validators who are storing the rows and who are intersecting obviously this column of the validator to supply this validator with fragments of his column and the moment it gets 50% of elements in the column, it will be able to reconstruct.
00:27:50.046 - 00:27:52.798, Speaker B: And fulfill the whole column and that's.
00:27:52.814 - 00:28:03.846, Speaker A: Where we need homophism on the proofs as well because when you are fulfilling elements of the column, you also want to fulfill proofs for those elements and fulfilling the proofs will require homomorphism for.
00:28:03.868 - 00:28:09.846, Speaker B: The proofs so that's how local reconstructability works so again, the properties that we.
00:28:09.868 - 00:28:15.674, Speaker A: Need from the commitments came from Dengueting is homomorphism on the commitments, homorphism on the proofs and only KZG has both.
00:28:15.712 - 00:28:18.986, Speaker B: Properties so the reason Denshrading extends the.
00:28:19.008 - 00:28:41.810, Speaker A: Block both ways extends right to get resilience against malicious 50% of validators because validators are getting columns and half of the validators can forget their columns, you will still be able to reconstruct the original block and Dank Sharding extends down in order to get local reconstruction in order to allow the validators to reconstruct their missing columns or rows without doing.
00:28:41.880 - 00:28:48.118, Speaker B: Full block reconstruction so let's talk about reconstruction briefly the way it's proposed to.
00:28:48.124 - 00:29:12.806, Speaker A: Be done in Dink Sharding is if 75% of elements in the block are there, then at least one incomplete row or column will be reconstructible, will have at least 50% of elements in it so you'll find such row or column and you will reconstruct it basically patching your gap then you will find maybe column with 50% of elements and you'll.
00:29:12.838 - 00:29:14.506, Speaker B: Patch that and you will repeat the.
00:29:14.528 - 00:29:16.926, Speaker A: Iterative process until you reconstruct all the.
00:29:16.948 - 00:29:19.966, Speaker B: Missing pieces now, we know that we.
00:29:19.988 - 00:29:22.078, Speaker A: Require 75% of the block in the.
00:29:22.084 - 00:29:27.586, Speaker B: Worst case and the worst case is here if you're having 75% of the.
00:29:27.608 - 00:29:31.342, Speaker A: Block and this is the yellow part minus some tiny strip.
00:29:31.406 - 00:29:32.590, Speaker B: Minus Epsilon.
00:29:32.670 - 00:29:38.886, Speaker A: So you're missing a little bit of this corner here. So this yellow area, including the.
00:29:38.908 - 00:29:42.066, Speaker B: Striped one is 75% minus epsilon.
00:29:42.178 - 00:29:52.474, Speaker A: So given only this area, you will not be able to patch and reconstruct this missing white quarter, because none of the rows or columns will have 50%.
00:29:52.512 - 00:29:53.658, Speaker B: Of elements in it.
00:29:53.744 - 00:30:00.362, Speaker A: And this worst case is very real because validators are getting rows and columns. So it might happen that the data.
00:30:00.416 - 00:30:02.966, Speaker B: Goes missing in exactly this pattern, and.
00:30:03.008 - 00:30:26.914, Speaker A: You get this worst case. So while exploring this with Denbane, we wrote a blog post, by the way, that you can check out on the A 16 z website. But we also had a proposal there of improving the reconstruction by having the validators, instead of storing rows and columns, store some randomly dispersed data from the block. So let me explain in a few.
00:30:26.952 - 00:30:28.054, Speaker B: Words how it works.
00:30:28.172 - 00:30:59.322, Speaker A: So instead of going through row and column wise reconstruction, we can go through Bivariate interpolation. So instead of doing this iterative process where you're finding incomplete rows and columns, you try to reconstruct your Bivariate polynomial as a whole. So this new method allows to reconstruct from 25% with high probability when these 25% are randomly distributed across a block. So instead of rows and columns, the validators, we propose to give the validators.
00:30:59.386 - 00:31:01.738, Speaker B: Random elements from the block.
00:31:01.914 - 00:31:11.794, Speaker A: It remains an open question, however, how to do Bivariate interpolation efficiently. So let me show you a polynomial algorithm for Bivariate interpolation, but it's not.
00:31:11.832 - 00:31:13.170, Speaker B: Good enough for us.
00:31:13.320 - 00:31:16.094, Speaker A: So if each validator gets random elements.
00:31:16.142 - 00:31:18.822, Speaker B: Of the block, the elements from honest.
00:31:18.876 - 00:31:29.318, Speaker A: Validators are going to be randomly distributed across the block. So your task is now to patch for the missing white elements. So the yellow are the elements that you have, and the white elements are.
00:31:29.324 - 00:31:30.574, Speaker B: The ones that are missing.
00:31:30.722 - 00:32:03.022, Speaker A: So the polynomial that we are seeking for is a polynomial of two variables. It has degree n minus one in each variable, so it has n squared coefficients. And given n squared random evaluations, we need to obtain the coefficients of this polynomial. So each evaluation that we have here, those elements that are present, gives us a single linear equation on the coefficients of this polynomial. So here the coordinates XY. You can write equation on the coefficients of this polynomial. So each element gives one equation.
00:32:03.022 - 00:32:30.246, Speaker A: So now we can write it as a system of equations. So those are our unknowns, the coefficients of the polynomial. The matrix m is constructed this way from the coordinates of the evolution points I one, j one, I two, j two, et cetera. So they're going to be n squared points that are present in the block n squared unknowns. So you should theoretically be able to find those unknowns given those n squared.
00:32:30.278 - 00:32:31.740, Speaker B: Evaluations on the left.
00:32:32.110 - 00:32:53.794, Speaker A: And indeed, solving linear system, we know how to do it in polynomial time. For general matrices, it takes time n to the 2.37 if you use the best algorithms. In our case, however, n is really large. It's two to the 32. So the size of this matrix is 128GB. So that's not a practical approach, although it's kind of an efficient algorithm just.
00:32:53.832 - 00:32:56.226, Speaker B: For our sizes, it's not suitable, but.
00:32:56.248 - 00:33:11.686, Speaker A: We know that the matrix is very structured, so the better algorithms should exist. So it would be nice to come up with a better bivariate interpolation algorithms and this will improve the reconstruction. Now let me talk about data availability sampling and how it fits into the.
00:33:11.708 - 00:33:13.526, Speaker B: Picture for Deng Sharding.
00:33:13.718 - 00:33:19.706, Speaker A: So in Denk Sharding, the blocks are reconstructible from 75% or possibly lower if.
00:33:19.728 - 00:33:22.458, Speaker B: We can make bivariate interpolation faster.
00:33:22.634 - 00:33:45.198, Speaker A: So to understand whether the block is available, the sampling client is kind of going to throw random darts into this block matrix, hoping to find out any missing pieces. So the sampling client will request random element of the block, it will send the coordinate IJ to the validator set, and the validator set is going to reply with the value of the polynomial dij.
00:33:45.294 - 00:33:47.314, Speaker B: And a proof, we assume here that.
00:33:47.352 - 00:33:50.646, Speaker A: The client have the commitment to the block, so it will be able to.
00:33:50.668 - 00:33:53.318, Speaker B: Verify that it got back the correct value.
00:33:53.484 - 00:34:00.522, Speaker A: So the probability that the value comes back and it is correct but the block is unavailable is zero point 75.
00:34:00.576 - 00:34:02.890, Speaker B: And that matches the 75%.
00:34:03.040 - 00:34:32.878, Speaker A: So imagine that your block is unavailable, so more than 25% of it is missing. Only 75% minus epsilon is present. So the probability that you hit the present element, yet too much of the block is missing for reconstruction is zero point 75. The probability that you do it again, so you do it two times in a row is zero point 75 squared. And by repeating the sampling, you can amplify this probability and goes down exponentially quickly, so you can make it negligible.
00:34:32.974 - 00:34:34.770, Speaker B: With small number of queries.
00:34:35.210 - 00:35:03.262, Speaker A: And if with bivariate interpolation we can improve on this 75%, make it 25%, then the probability will go down even faster. So data availability sampling allows our client to verify whether the data is available without basically knowing any information about the validator set, without knowing the public keys of the validators, without verifying any signatures, by just simply throwing this darts into the block and verifying that it got.
00:35:03.316 - 00:35:05.520, Speaker B: Back correct values from the set.
00:35:06.050 - 00:35:35.910, Speaker A: And this is also going to underline the consensus design in Ethereum because data availability or dank sharding is going to be blended into the consensus protocol. So each validator during the attestation phase in the consensus will attest to the block BN only if the two conditions are met, if this validator has sampled all the previous blocks and the sampling was successful. So with good probability, the validator is convinced that all the previous blocks are available.
00:35:36.060 - 00:35:38.870, Speaker B: So it determines availability of the previous blocks.
00:35:38.950 - 00:35:47.466, Speaker A: And it also attests if it received correct fragments of all the previous blocks. So there's green lines, two rows and.
00:35:47.488 - 00:35:50.074, Speaker B: Two columns each validator gets for each.
00:35:50.112 - 00:35:55.646, Speaker A: Block and it needs to verify that those conform to the commitments. If these two conditions are met, then.
00:35:55.668 - 00:35:57.866, Speaker B: The validator attests to the block BN.
00:35:57.978 - 00:36:25.010, Speaker A: And that's happening in addition to what Ethereum Consensus is doing right now, which is verifying and rerunning all the transactions within the block. It will also verify that this additional data that we're adding with Dink Sharding is available. All right, so that's all I have here at Important Disclosures to check out. Hope you enjoyed this presentation, and please check out the blog post that we wrote with Danbane. And yeah, let us know your thoughts.
