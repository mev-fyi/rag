00:00:07.380 - 00:00:07.930, Speaker A: You.
00:00:09.980 - 00:00:22.052, Speaker B: Very happy to introduce Ari Jewels, very well known in the space, wears a lot of hats, professor at Cornell, co director of IC Three, chief scientist at Chainlink. Going to tell us about some of his latest work. Ari, all yours.
00:00:22.116 - 00:00:57.844, Speaker A: Okay, thank you. Delighted to be here. I'm going to talk today about trusted execution environments and focus mostly on applications to blockchains, although I'm going to talk about a couple of other applications as well. This is a very unusual talk for me in that normally I give a talk after a paper has come out, after a body of work is fairly mature. Today, on the other hand, I'm going to talk about two blog posts. So this is kind of a rough and ready presentation. It's a work in progress presentation, if you will.
00:00:57.844 - 00:02:00.680, Speaker A: I wanted to give you that caveat up front. A number of really powerful cryptographic primitives are starting to find their way into blockchain systems. And they include things like Snarks, various succinct, zero knowledge, argument and proof systems useful for all kinds of things from private oracle queries to decentralized identity to ZK rollups, which of course aren't actually ZK. I'm not going to go there. Fully homomorphic encryption is starting to get a little bit of traction as a means for realizing private smart contracts that's still in its infancy. Secure multiparty computation similarly offers the possibility of realizing private smart contracts and it's good for other things as well, like key management. I'm going to make the bold assertion that all of these are functionally subsumed by trusted execution environments, as well as some things I haven't talked about, like black box obfuscation, which is not realizable using cryptography provably unrealizable.
00:02:00.680 - 00:02:55.070, Speaker A: But there's a huge proviso here which I'll give you a little later. Functionally at least, trusted execution environments can do all these things. What is a trust execution environment? It's an environment in which a program can be run with some special and fairly powerful protections. In theory at least, this environment is often referred to as an enclave. When a program is running in an enclave, in principle its integrity is protected in the sense that exactly the program that has been launched is the program that will continue to run. And the program can't be tampered with even by the creator of the software underlying it, even by the owner of the host on which it's running if the te is functioning correctly. So that's one nice property we get from a te.
00:02:55.070 - 00:03:44.188, Speaker A: The second key property is confidentiality. In principle, this program can run with secret state state that other processes can't access, and again, even the owner of the host doesn't have access to, again, assuming that the tee is functioned correctly. So these are the two key properties. Additionally, at least some tes provide a capability known as attestation. Attestation enables the te to prove remotely to a party that a particular program is running. It's characterized by its build and within this Attestation can be placed a little bit of user data. By user data I mean data from the program.
00:03:44.188 - 00:04:51.410, Speaker A: Typically that would be something like the digest of a public key associated with the particular instance of the software that's running with this particular instance of program X. And this means that a user interacting with the program knows exactly what she's interacting with and thanks to the integrity and confidentiality properties, knows that this program enjoys the protections that the Te bring to bear on it. So this is the general setup for Tes and you can use them for lots of different things. To give you a very simple example here, if you wanted a zero knowledge proof around a decentralized identity document, say that Alice wants to prove to Bob that she has a digital driver's license from California. She wants to prove she has a valid California license, but she doesn't want to reveal anything else private information on the license for instance. She wants to keep all that confidential. Well, in principle you could use a zero knowledge proof or argument system to do this, but you can also use a Te and with a Te accomplishing this is conceptually very simple.
00:04:51.410 - 00:05:56.016, Speaker A: A program designed for this purpose, generating zero knowledge proofs on driver's licenses or whatever, ingests a digital version of the driver's license signed by an appropriate authority, in this case presumably the California DMV. And then the program sends to Bob, in this case the one that Alice wants to convince an Attestation. So Bob knows he's interacting with a valid piece of driver's license processing software with this program X, along with a public key associated with the instances program. And then the program can sign a statement proving the thing that Alice wants to prove to Bob. In this case, Alice has a valid driver's license from California and that's it. All of the other details are hidden. So this is how we accomplish construct zero knowledge proofs using Tes and minimal cryptography, right? Just basically digital signatures.
00:05:56.016 - 00:07:02.910, Speaker A: There are a few different types of Te platform and several popular ones. AWS Nitro is a software tee. The protections a piece of software enjoys derive from other software, software protecting a hypervisor in this case, where a virtual machine essentially is the enclave. Intel SGX on the other hand, is an instruction set architecture extension in some Intel CPUs that provides hardware backing for the enclave. There are special instructions that provide the properties that I described and enable things like Attestation. AMD has its own analog to intel SGX works a little bit differently. It has a larger trusted computing base meant to protect a virtual machine rather than just an application, but operates essentially along the same lines with hardware backing for the Te.
00:07:02.910 - 00:08:00.424, Speaker A: And it's likely everyone has a Te here, either on the table in front of you or in your pocket, namely in your mobile device arm trust zone which is somewhat similar to the previous two, but doesn't have attestation capabilities. So these things are in widespread use and there are different variants. That's the important thing to take away. My group has been working with trust execution environments for quite some time. Way back in 2016, I guess, we worked on an Oracle system called Town Crier, where the Oracle provided both confidentiality and integrity deriving from the properties of Intel SGX. We stood this up as a public service, and according to our colleagues at intel, this was actually the very first public facing Intel SGX application. And I think it saw a grand total of four uses by users.
00:08:00.424 - 00:08:48.988, Speaker A: It didn't see a huge amount of uptake, but it was a first. And it launched me at least on my exploration over the years of trust execution environments. All right, so I've given you some detail, but the takeaway here is that in fact, there's a very simple mental model to characterize Tes. Basically, a Te acts like a trusted third party. It's a trusted third party that can enforce integrity and confidentiality, as trusted third parties are able to do in a fully general sense. And it's also capable of arbitrary, fairly inexpensive computation. There's some overhead associated with using an enclave with, say, Intel SGX, but that overhead isn't all that large.
00:08:48.988 - 00:09:41.740, Speaker A: Actually. In some cases you can get performance close to that of the native speed of the again, you know, some serious provisos. That will actually be the pith of the second half of this talk. Well, I said I was going to focus on blockchain related applications for Tes, and in particular I'm going to focus on the topic of block building. To understand why you might need special security properties for block building, I need to give you a little bit of background on what's called mev maximal extractable value. So let me do that now, just give you a brief primer. The problem of mev stems from what can be characterized as an unfortunate fact about the way that blockchains operate today, and that is that the process of ordering transactions is temporarily, at least, centralized.
00:09:41.740 - 00:10:27.470, Speaker A: When transactions enter a mem pool, they get taken up by a Validator, and that Validator forms a block consisting of whatever transactions it wants, in whatever order it wants. It has unilateral control over the contents of that block. So for instance, transactions may come into the mempool in the order one, two three. The Validator can order them in the block one, two three, or it can swap the ordering of these transactions. It's entirely up to the Validator. Often, Validators will order transactions by the gas fees they offer in a system like Ethereum, but not always. All right, well, why does this matter? Why do we care about the order of transactions? Let me give you an example to illustrate how important it ends up being.
00:10:27.470 - 00:11:02.452, Speaker A: Let's suppose that Alice here is interacting with a DeFi system. Decentralized service like a decentralized exchange, a Dex. And she wants to buy some Bob's bubble token. New token just came out whose current price is one ETH per BBT. Well, what she can do then is send 1000 ETH to the Dex and she'll get back 1000 BBT. All is well and good. The nice thing about decentralized services about DEXes is that they provide transparency.
00:11:02.452 - 00:11:47.616, Speaker A: So Alice knows exactly what she should get from the system. Now, an effect of her buying this asset is that the price in the Dex will rise. This is true of any exchange, not just a Dex. You buy an asset, its price rises. Well, a Validator, of course, in constructing the block that contains Alice's transaction, gets a glimpse of her transaction before the block has been fully constructed. So what the Validator can do is manipulate the transactions in the block in the following way. Take advantage of Alice's transaction by making use of this observation that Alice's transaction will cause the price to rise.
00:11:47.616 - 00:12:24.048, Speaker A: What the Validator can do is squeeze in before Alice's transaction a buy transaction. It's as though the Validator can look into the future and see that the price of this asset is going to rise. So it knows to buy this asset prior to the event Alice's transaction. That will cause the price to rise and then it can turn around, sell that transaction and pocket the profit. So now we might have a situation like this. Validator buys the asset, Alice buys the asset, price rises, validator cashes out. The Validator is going to make money here, right? Because the price rose after it purchased the asset and it just turned around, sell it.
00:12:24.048 - 00:13:18.768, Speaker A: Where does the profit for the Validator come from? In this simplified example comes of course, from the pocket of the user here from Alice. This is known as a front running attack. The Validator has front run Alice here, meaning it squeezed its transaction in first. And to be more precise, this is a sandwich transaction where the Validator squeezed Alice's transaction between two of its own. Back in 2020, we published a paper in which we put forth the term minor extractable value to characterize all of the various opportunities afforded to Validators to make a profit through reordering and transaction injection of the type that I showed you. Since miners have gone away in Ethereum and have been replaced by Validators, people use the term now maximal extractable value. Same acronym though mev.
00:13:18.768 - 00:14:01.468, Speaker A: And this is an acronym that people use fairly regularly. Mev is challenging to deal with in a number of ways. I'll talk about in a little bit more detail. The ecosystem has chosen to deal with mev by constructing a fairly complicated supply chain as it's referred to. The way that these opportunities get capitalized on involves a lot of different players in a kind of pipeline. So I give you a little detail because this will be relevant later. Arbitragers those who identify opportunities to make money are known as searchers.
00:14:01.468 - 00:14:46.976, Speaker A: They will observe users transactions or receive users transactions and put them together with their own arbitraging transactions in little sequences known as bundles. Searchers will submit these bundles to entities that construct blocks. These are known as builders. So searchers are in some sense, competing to get their bundles into blocks. Here, builders will act independently of one another to construct different blocks, which they then submit to what's called a relay. Now, ultimately, the block that gets taken up by a validator is going to be the block that offers the validator the biggest bribe. Validators obviously want to make as much money as possible.
00:14:46.976 - 00:15:21.864, Speaker A: So each of these blocks includes some money, a kind of tip or bribe for the validator. These block builders are competing with one another to offer the largest bribe to the validator. Where is that bribe going to come from? It's going to come from extracted mev. So some sense searchers compete with one another. Block builders compete with one another trying to produce the juiciest block for the validator. They submit their blocks to Relay. Relay will select the block that offers the largest bribe and that will get transmitted to the validator with a little extra infrastructure to achieve certain trust properties.
00:15:21.864 - 00:16:14.620, Speaker A: And in fact, relays also compete with one another. So the takeaway here is that you have this complex multistep, multi participant pipeline, the supply chain, to handle mev. And I'm going to talk in a moment about a way that we might embellish the supply chain to minimize the extraction of mev from unwitting users. This is an early version of an architecture floated by the Ethereum Foundation and other is called Proposer Builder separation. The validator is often referred to as proposer, at least in this context, and builders are exactly the entities I described. The goal in PBS, as it's called, is to keep these two entities separate in the service of decentralization. I'm not going to talk about decentralization.
00:16:14.620 - 00:17:19.356, Speaker A: Interestingly, one of the main protagonists in this drama of mev known as Flashbots, has begun to use trusted execution environments and to insert them into the supply chain. And particularly, they've constructed a block builder that runs inside an enclave. This has been running on the main net for something like six months. Additionally, they have very ambitious plans to build what my colleague Andrew Miller characterizes as a marketplace of mechanisms inside an enclave. Ultimately, what they envision is users submitting transactions with preferences as to how they want them to be processed and arbitragers, providing various mechanisms to handle users transactions. And this kind of grand environment bringing together mechanisms and transactions in some way that has yet to be specified. This ambitious project is known as Suave.
00:17:19.356 - 00:18:12.320, Speaker A: At the moment, it's somewhat nebulous, but it too is likely to make use of trust execution environments. Well, mev remains what I would consider a problem for users. Users are losing a lot of money to arbitragers and I don't have fully up to date statistics, but Flashbots provides, or has provided in the past a nice transparency dashboard, as they call it, that gives you some sense of how much mev is being extracted in the ecosystem. This is actually just the tip of the iceberg. This is a very particular type of mev. But over the course of a recent period of something like eight months, $300 million in mev has been captured by Arbitragers and Validators and others in the mev supply chain. And much of this comes from users'pockets.
00:18:12.320 - 00:18:57.250, Speaker A: As I said, this is also just the tip of the iceberg. There's a lot of arbitrage going on other places, like in centralized exchanges and between centralized exchanges and decentralized exchanges. But this gives you some sense of the scale of the issue. Well, some have argued that mev competition, this aggressive extraction of mev where builders are competing with one another and relays are competing with one another, is essentially inevitable. Inescapable, in fact. And they've made an informal argument to this effect, offered an informal proof, which I'm now going to describe here. Suppose that a Validator is offered a choice between two blocks, block B and block B star.
00:18:57.250 - 00:19:47.280, Speaker A: And let's suppose that B pays reward R and B star pays a higher reward, R star, maybe just a little higher than R. Which block is the Validator going to choose? Well, it's pretty obvious. If we assume that the Validator is rational, the Validator is going to choose the block with the juicier reward, the bigger payment. So it'll choose B star. Well, where is the reward coming from in these blocks? Essentially, it's got to come from mev extraction. Now, of course, they're fee payments as well. But if you imagine both of these blocks have the same transactions or roughly the same transactions and provide the same fees, the reward here, the bribe for the validator is going to come from mev extraction.
00:19:47.280 - 00:20:10.570, Speaker A: And therefore, at the end of the day, the block with the highest mev extraction is the one that's going to go on chain. And therefore competition of the type I described is inevitable. This is the argument made by proponents of the mev supply chain who say we can't get away from extracting mev, so we might as well systematize it.
00:20:12.300 - 00:20:21.404, Speaker B: Doesn't this sort of rule out by assumption, like, lots of solutions people propose, though, like kind of encrypted mempool type stuff where the block is.
00:20:21.442 - 00:20:41.890, Speaker A: Yeah. So now let me prove the opposite. Exactly. Okay, now we want to prove that mev competition is not inevitable. Suppose again, same setup. Validator is offered block B or B star. B pays reward R and B star pays a slightly higher reward, epsilon higher.
00:20:41.890 - 00:21:46.164, Speaker A: Which will the validator choose? Well, same setup as before, validator is going to choose B star. But let's suppose that the reward here comes from a special set of transactions, a special bundle, if you will, to use the term I introduced earlier, bundled transactions worth a little bit here. And let's suppose that these transactions have been fairly ordered, ordered in a way that doesn't give arbitragers opportunities to extract mev aggressively. You can choose your favorite notion of fairly ordered here, I don't care how you define it and it comes from private order flow, I should mention. Right? So the transactions here are not present in that block. Well, now the validator is going to choose this block B star that contains transactions that have not been subject to maximally aggressive mev extraction. So I would argue that this shows that mev competition is not inevitable if we can append the bundle of the type that I've described here in some way.
00:21:46.164 - 00:22:48.520, Speaker A: If there's a mechanism to do this and I'm now going to propose such a mechanism in a system called Prof, which stands for Private Order flow. This is joint work with a whole bunch of people, at least one of them here now with in a group of Andrew Miller at UIUC, group of Don Song at UC Berkeley and at least one participant from Fidelity Labs. So, as I mentioned, Prof stands for protected order flow. And the idea behind Prof is actually fairly simple. We could use a trusted third party for it. But as I've suggested, tes behave in a sense like very practically instantiable trusted third parties. So what Prof is going to do is run an application in a Te that ingests transactions from private order flow or a private mempool and it's going to build a fairly ordered bundle.
00:22:48.520 - 00:23:26.224, Speaker A: Again, use your favorite notion of fairness. I'll talk a little bit about that later. Why use a tee here for this purpose? Well, we can do things like encrypt the transactions going into Prof. You can create an encrypted channel between the user submitting a transaction and the prof service itself. If you use a te, use the confidentiality property of the te and this helps prevent arbitrage. If transactions are encrypted, they're harder to arbitrage, it's harder to extract harmful forms of mev. And this also, of course, protects the bundle.
00:23:26.224 - 00:24:08.084, Speaker A: Once it's been constructed, the transactions in the bundle have to be concealed from potential arbitragers until they get released publicly. Tes help you do that. Plus, remember, Tes enforce an integrity property. When a program has been instantiated in a Te, you as a user can check that that program is what's running. And so if this program realizes a particular notion of fairness, you have the assurance as a user of the service that that notion of fairness will apply to your transaction. Prof constructs a transaction bundle, then what does it do with this bundle, this fairly ordered bundle? It's basically a block enrichment service. This is one way to think of it.
00:24:08.084 - 00:25:02.660, Speaker A: When a block has been constructed by, for instance, a block builder or has been received by a relay that's meant to go to a validator. What the prof service will allow you to do is send the block into prof and prof will append this special bundle to the block. And it'll do all this privately to begin with. So the gray box there indicates that all this is concealed to begin with. It's all happening inside the enclave and therefore confidential with respect to everyone else. And then Prof does something that's done in the mev supply chain, which you don't need to worry much about, but a little bit of trickery to ensure that block contents don't get prematurely exposed to the world. In particular, it outputs the header of this enriched block to be signed by the validator.
00:25:02.660 - 00:26:02.824, Speaker A: And only when it gets a signature from the validator commitment to this block, from the validator, does it release the contents of B star. If a validator signs the block and then sees the contents of the block and incorporates them into a new block, it will have equivocated, right? It will have signed two different blocks and then subject to slashing and so on and so forth. This trick is used, as I said, in the mev supply chain. This isn't peculiar prof, it's just a way of ensuring that things don't get revealed prematurely. So this is basically what Prof does. It enriches blocks with this private water flow and here's a summary slide, right? So in summary, transactions go into Prof, constructs his bundle and now makes this bundle available on a selective basis to the mev supply chain. Prof is not technically all that interesting, or rather the use of Tes is fairly straightforward here.
00:26:02.824 - 00:27:01.400, Speaker A: It's more interesting as a mechanism. And as a mechanism it has some rather intriguing features. The first, I've already alluded to in my proof that mev maximal mev extraction isn't inevitable validators. And therefore those in the supply chain are, as rational entities, essentially compelled to choose an enriched block over an ordinary block, to choose a Prof embellished block because they'll get higher rewards. So remember that this mev supply chain is a competitive one. These builders are competing with one another, relays are competing with one another to furnish the juiciest block to the validator. If they're going to be competitive with respect to others in the supply chain, they need this kind of epsilon advantage that Prof is going to offer them, right? I'm assuming here that Prof pays some epsilon amount extra to the validator.
00:27:01.400 - 00:27:34.400, Speaker A: So rational relay, for instance, will choose to get this extra revenue and those competing in the supply chain will have to incorporate this revenue into the blocks that they construct. Now, I haven't described whether Prof gets used by a relay or by a block builder can actually be used by either. And we're still figuring out exactly where to position in the supply chain. But pick either one and just assume that it's operating there. Okay? So it's attractive within the supply chain. It's also attractive to users. As a user you have a choice.
00:27:34.400 - 00:28:30.112, Speaker A: You can send your transaction into the public mem pool, or you can send it to some entity in the mev supply chain and have the mev squeezed out of it to put things in somewhat simplistic terms. Or you can send it to the prof service. Now, prof only needs to offer an epsilon reward, tiny reward, to be attractive to the supply chain and therefore can charge very little to users to use its service. So a user may only have to pay, say, a penny extra to use prof to get this protection as opposed to paying what is essentially a tax, large tax on her transaction. So it's also attractive to users. And the hope is that it kind of sweeps over the ecosystem and makes harmful mev extraction from users less prevalent. Well, I said this is work in progress.
00:28:30.112 - 00:29:19.850, Speaker A: There are still a lot of things we have to figure out. As I said, we have to determine exactly where in the mev supply chain prof should be situated. We need to think about how payment works. There are a lot of details to work out. What if there are multiple instances of prof we would like for the possibility of multiple entities standing up different prof services? Can they operate in conjunction with one another? I believe they can. One prof instance may allow, for instance, or may allow another prof instance to append its own bundle after the first prof instances bundle because this doesn't degrade the protections afforded to users. But this again is something that we need to work out in detail.
00:29:19.850 - 00:30:00.448, Speaker A: Plus, I've just described one mechanism. It's not clear that it's the best mechanism for this purpose. There are others floating around like mev share, which I won't describe in detail, that need to be compared with prof to determine whether it's really the best possible mechanism for this purpose. All right, well, I said I'd talk a little bit about this notion of fair ordering. You can choose your favorite notion of fair ordering with prof. You could do what sometimes called temporal fair ordering, or first come, first serve ordering, something Mahimna here has been working on for a number of years and decentralize the process of ordering. You can just use encrypted transactions.
00:30:00.448 - 00:30:17.848, Speaker A: Remember I said Te allows you to encrypt transactions quite seamlessly. Or you can do both, actually. These are complementary approaches. Or you can do neither. You can do something else entirely. Prof can accommodate any of these things. Let me go back to this mental model I offered you for what tes do.
00:30:17.848 - 00:30:45.490, Speaker A: So tes are trusted third parties. I said there are serious provisos, though, and let me talk about those provisos now. And the second half of my talk is going to focus on the limitations of tes security limitations talk about something called the Sting Framework, which is meant to bolster te security. This is joint work with Andrew Miller's group with, again, a whole bunch of people.
00:30:48.420 - 00:31:05.800, Speaker B: So the private order flow, I'm just trying to think about where that comes from in competition for it. Right. So somehow, in addition to the technical innovation, you also have to sort of win the market battle about who's getting that private order flow. And I realize that's kind of like probably outside the scope of what you talked about, but I was just wondering if you had thoughts about that.
00:31:05.870 - 00:31:27.840, Speaker A: Yeah, it's not something we thought very deeply about, but as I said, a prof service is going to be attractive to users as a user has a choice either get front run or pay this tiny amount to a service that's going to provide protection from front running. So it should be attractive to users and therefore a prof service should attract order flow naturally from users.
00:31:28.820 - 00:31:38.884, Speaker B: The worry would be that mev share kind of solution could then offer like a big discount. It's not just you'll pay a cent, but actually I'll give you money back.
00:31:38.922 - 00:31:58.660, Speaker A: In some sense, mev share does in fact reward users with some of the money that's been taken by Arbitragers. The question is, are users better off using one service or the other? And if you have Arbitragers in the mix, I would say there's a good chance that you're not getting the best possible execution.
00:31:58.740 - 00:32:01.144, Speaker B: There's still some cut being taken basically, right?
00:32:01.182 - 00:32:01.768, Speaker A: Exactly.
00:32:01.934 - 00:32:19.132, Speaker C: Yeah, I guess like most of the concerns you can imagine, there's like a hedge fund block builder and they just won't integrate the prof order flow. And because they're just very focused on generating mev, do they always just have better bids than the builders integrated with prof? Would that be a concern?
00:32:19.276 - 00:32:32.944, Speaker A: Well, again, if you've got two builders, all other things being equal, and one builder uses prof and the other doesn't, the one that uses prof is going to win the competition to get its block adopted. So they would be giving up essentially a competitive advantage.
00:32:33.072 - 00:32:42.764, Speaker C: I guess in practice with all those things, equal doesn't seem as reasonable. You can imagine there's just like latency disadvantages, like going through T then directly.
00:32:42.912 - 00:33:34.564, Speaker A: We can certainly talk at length about all the practical nuances, but at least in this very basic model of rationality, it behooves participants in the mev supply chain to use profit. Okay, so let me talk about the Sting framework here. All right, so I said if a te is functioning correctly, it gives these wonderful properties integrity and confidentiality. But as it turns out, tes are often not functioning properly. And there have been myriad pretty serious attacks against intel, SGX in particular, which is really the leading te, at least fully functional te meltdown Inspector many of you may remember back in 2018 affected SGX. The colorfully named SGX axe came out a little later. Earlier this year, in February, multiple holes in SGX patched.
00:33:34.564 - 00:34:14.740, Speaker A: And last week, yet another serious vulnerability in SGX was identified and is being patched. All right. So why bother with tes? Some contend that they're fatally flawed and we should use cryptography exclusively to enforce properties of the type that I've described in this talk. Well, there are a few reasons to take tes seriously. I'll try to convince you that in the long run they're going to be a foundational technology. First, you can use them as a defense in depth layer. If you add a te to a system in the right way, you make it strictly stronger.
00:34:14.740 - 00:35:14.948, Speaker A: This can even be a cryptographic protocol like secure multiparty computation. You can run MPC and put the nodes in enclaves. Now, to break the MPC protocol, you have to compromise a certain number of nodes, but you've made it strictly harder to compromise those nodes. So the protocol as a whole has become strictly stronger. Additionally, and this is a somewhat more nebulous argument, I would say that T's with respect to cryptography are a kind of disruptive innovation in the very classic sense of Clay Christensen. You've probably heard the example of radios, transistor radios given to describe to characterize what a disruptive innovation is. Way back in the early 20th century, people had these fancy radios with vacuum tubes that functioned extremely well, provided excellent sound quality, and then along in the 1950s came transistor radios.
00:35:14.948 - 00:36:15.710, Speaker A: This newfangled thing called a transistor enabled you to build a radio that offered much lower quality than the furniture radio. The radio had been around for many years, but it was cheaper and eventually it grew to be as good as and better than the original radio, unless you're a diehard audiophile. This is the hallmark of a disruptive technology to begin with, it's in some way worse, but it's cheaper, faster, has some obvious advantage. And this is true of tes are much easier to use than fancy cryptographic technologies and also conceptually simpler. Plus they provide very high performance at low cost, so they have a number of advantages in terms of security. We can argue this, but they're basically worse. That's true for the moment.
00:36:15.710 - 00:37:04.156, Speaker A: So I would argue maybe they're like transistor radios. And finally, I would say that there are ways to meaningfully bolster te security. I'm going to talk about one of those today, and that is the Sting framework. So one observation I'd like to begin with is that in the case of block building in particular, and this is true of some other protocols as well we only need to enforce confidentiality temporarily. Ephemerally in the case of block building, once transactions go into a block, which will happen in a matter of seconds, they get revealed to the world. So at that point they're no longer confidential. It's not as though you've got persistent PII, personally identifiable information sitting in an enclave, right? These are things that are going to be disclosed in the short term anyway.
00:37:04.156 - 00:37:57.032, Speaker A: So temporary leakage really isn't catastrophic. The thing we're really worried about in, for instance, the case of block building, remember I mentioned that Flashbots has a te based block builder and Suave is based on the use of te. Thing we're really worried about in that particular application of Tes is systemic abuse. We're worried about some dark service. I'll call it a subversion service, subversion service arising that gives an adversary access to all new transactions coming into the service and also potentially gives it the ability to inject its own transactions into blocks in a way that it decides. Now, you may ask, is this a real threat? Is somebody actually going to stand up a service to do something illegal criminal like this? Well, yes. I mean, they're already a real threat.
00:37:57.032 - 00:38:25.024, Speaker A: There are plenty of examples of compromises being turned into services over the long term. Ransomware as a service has proliferated for many years. Botnets are mainly serving as denial of service. As a service you can get exploits. As a service, there are zero days that you can access. Through a service, you can basically rent a zero day. This is happening in dark markets.
00:38:25.024 - 00:39:18.968, Speaker A: I would even say that in some sense, the mev supply chain is itself a subversion service. Somebody noticed that there's this flaw, if you will, in the way that blocks get built and created. You can think of it as a dark service, a service to exploit this flaw systematically. So I would contend that subversion services are a real threat and concern. Now, the question is, if there's a subversion service, can we prove its existence? I'll explain a little later what we might do with a proof of existence, but this is the goal of the Sting Framework, to be able to prove the existence of a subversion service. The setup is as follows. We have some target application, good application like block building, and our concern is that there exists some subversion service that's allowing people to exploit this thing in a systematic way.
00:39:18.968 - 00:40:13.370, Speaker A: What we want to be able to do is enable a user, whom we refer to as the Informer to prove to a verifier that the subversion service exists. The Informer is going to do this in the Sting Framework by relying on an application called the Sting Framework application, the SF application. And to give you a little bit of a preview, what the SF application is going to do is generate fake inputs to the target application that will help the user construct this proof. So this is the setup. This is the framework, as it were. All right, well, why should we trust this Sting Framework application? It's playing a critical role in verification. On what basis are we going to trust it? Well, the Sting Framework application itself can run, for instance, in a te, can be hardened by a te.
00:40:13.370 - 00:41:46.790, Speaker A: Now, obviously, we need to be careful to ensure that the software is correct, and we want to make sure that your trusted computing base is minimal and so on and so forth. But the thing you may be thinking is, okay, if there's a subversion service, maybe it's been constructed or it's possible to construct it because SGX has been broken, right? I began the second half of the talk by saying SGX has all these vulnerabilities. Maybe the thing that, as I said, enables this aversion service is the fact that SGX has been broken. So it's no help, it would seem to be running an SF application within an enclave if the underlying service is broken, right? What's the point? But we get a nice feature in this framework, namely that if the SF application is broken, suppose that it's creating bogus verification or facilitating bogus verifications because SGX is broken. Well, that's okay, actually, because if SGX has been broken and that's what's giving us the bogus verification of Sting proofs, then the target application is in trouble because it's using SGX. So in fact, if SGX is broken and that's really all that we're learning from an SF proof, that's fine, that already tells us that the target application is in peril. Okay, now let me give you three examples of how Stingers get constructed and how the Sting framework can be used to detect subversion services.
00:41:46.790 - 00:42:27.228, Speaker A: So I'm going to talk about three target applications. The first is private contact discovery. So in this case, we're thinking about a target application like Signal, for instance, which provides exactly this functionality. Target application that will ingest users'contact lists, keep them confidential, and reveal matches. Indicate, for instance, to Bob whether any of the users in his contact list are using the messaging service. In this case, Signal, for instance. But we'll reveal these matches only to the user.
00:42:27.228 - 00:43:27.220, Speaker A: So here, for instance, Bob learns that Alice is a user of the system, and Alice will also learn that Bob is a user of the system. But others are not going to learn that these matches have been indicated to the two users. So Signal actually does this, and they too use tes for this purpose, along with another cryptographic primitive called Oram, which I won't get into, which basically provides a kind of secure memory extension, is the way to think about it. All right, now let's suppose there's a subversion service here. Say that SGX is broken and somebody constructs a subversion service that creates, for instance, a government backdoor so the government can learn people's contact lists. Or maybe there's just some side channel attack against SGX and somebody has decided to set up a subversion service and actually sell contact lists. So we're supposing that the subversion service here leaks what are supposed to be private contact lists to an adversary.
00:43:27.220 - 00:44:09.444, Speaker A: How does an informer prove the existence of this subversion service? The way it works is as follows. The SF application in this case generates a Stinger, a fake input, that is a essentially bogus randomly selected contact list. And that contact list gets injected into the target application. So this fake user gets inserted into the target application. Now, the SF application generates this stinger secretly, privately. It doesn't reveal it to the informer or anyone else, and it gets sent privately into the target application. So in principle, nobody should see this thing.
00:44:09.444 - 00:44:52.690, Speaker A: There is no user. You here. This is a contact list corresponding to a user that doesn't exist. The way that the informer proves the existence of this aversion service is by extracting this contact list and then sending it to the Verifier, proving that it's correct. How does the user do this? The user sends it to the Verifier and then gets the SF application and say, yes, this is a contact list that I just injected into the target application. So now the user has proven the existence of a subversion service, has proven that contact lists are leaking. Second application, in some sense, the main application I'm interested in this talk private block building.
00:44:52.690 - 00:45:43.596, Speaker A: So, as I said, we already have private block builders running in SGX on the Ethereum main net. What do we do if there's a subversion service? The target application in this case is the Block builder running in an enclave. Its job is to ingest transactions and construct blocks or bundles. The transactions are encrypted, they're sent in encrypted form into the application. And the use of encryption on the transactions and the use of the enclave more generally should prevent things like front running or should be able to prevent certain forms of exploitation. It should keep transactions confidential while the block is being built. At least that's the kind of the minimal functionality you need for correctly operating block builder.
00:45:43.596 - 00:46:28.604, Speaker A: Now, this target application could be the Flashbot'sgx builder. It could be prof just something than just transactions and constructs a block or a part of a block. All right, so suppose we have a subversion service. How does an informer prove the existence of this service? Let's suppose that the service both leaks transactions and allows insertion of transactions into a block. This is actually the thing that an arbitrager would want. This would be very profitable for an arbitrager, because the arbitrager then could extract mev arbitrarily. And if the subversion service is made available on only a limited basis, like if only one arbitrager has access to it, the arbitrager can extract mev without competing with other arbitragers.
00:46:28.604 - 00:47:16.560, Speaker A: So this would be a truly profitable service or opportunity for the arbitrager. Now, you might think that if blocks get manipulated, it's going to be obvious to people. But I do want to point out that the use of a subversion service can in fact be hidden. It's very hard to tell whether a transaction is generated by an arbitrager or comes from an ordinary user. To go back to my early example, the Sandwich attack, the arbitrager was injecting a buy order into the system before the user's buy order. arbitrager can easily make its buy order look like that of an arbitrary, ordinary, benign user. So use of the SS can be hidden, and therefore it really is important to prove its existence.
00:47:16.560 - 00:48:11.340, Speaker A: How do we do this? Again, the protocol here is actually fairly simple. The SF application generates a secret stinger. In this case, just essentially random transaction. And this transaction is going to be very hard to guess because it's got lots of entropy in the signature, sends this transaction in encrypted form into the target application. And what the informer does to prove the existence of the subversion service is extract the transaction from the subversion service and then construct a second transaction that depends on the first. And I'll explain in a moment how it might depend on the first, and then places this second transaction into the same block as the first. Well, why does this prove anything? Transaction one should be kept secret, or should have been kept secret until the block was published.
00:48:11.340 - 00:48:42.940, Speaker A: But we've got this second transaction that depends on the first transaction. The second transaction shouldn't exist. It depends on a transaction that was supposed to be secret with respect to the entire world. And transaction two is present in the same block as transaction one, which means it was created before the block was published. In other words, before transaction one became publicly visible. So this constitutes a proof of existence of the subversion service. Let me get to my final example, which is not a blockchain service, namely Tor.
00:48:42.940 - 00:49:38.040, Speaker A: I think most people are familiar with Tor, but just to give you a very brief description of what it does, it hides network traffic. And the way that it does that is by constructing what's called a circuit, a sequence of privacy preserving nodes, as it were, between a client and a target. Server circuit gets constructed, typically consists of three nodes, although in principle, could be more. The circuit is secret in the sense that only the client knows it, nobody else should know it. And this is how network traffic gets hidden. The server the user is communicating with has no idea where the user came from, because the user is employing this sequence of proxies in the circuit. Suppose there's a subversion service, a service that removes the privacy protections from circuits.
00:49:38.040 - 00:50:14.504, Speaker A: What it does is it outputs client identities and the circuits that they've built. This could happen if there's a powerful network adversary, for instance, can happen in other ways as well. Governments are known to try to break. Tor turns out to be very well engineered and hard to break. So often what they'll do is compromise endpoints. As we know from the Snowden leaks, the wonderful name Egotistical Giraffe program at NSA is aiming at compromising Tour in exactly this way. But in any case, a subversion service is clearly a desirable thing for governments and others.
00:50:14.504 - 00:50:54.928, Speaker A: How do we prove the existence of a subversion service? Very similar idea to the two preceding examples. The SF application generates a secret stinger. In this case, it's a circuit, then it runs tor on behalf of the client. It doesn't want to reveal the circuit to the user. So it basically handles the circuit. And the informer then extracts the circuit from the subversion service and proves, again, similar format to the previous two examples, proves to the Verifier that the extracted circuit was correct. So as I said, the circuit should be private, even with respect to the informer.
00:50:54.928 - 00:51:28.732, Speaker A: So the ability to learn the circuit proves the existence of the subversion service. Now, there are a whole bunch of subtleties here. Like the informer actually learns the first node in the circuit. It has to know the first node in the circuit, so it has to know where to send the traffic to. Plus, if it colludes with the server that's being communicated with, it can learn the third node. But the second node so called middle relay, should remain confidential. All right, well, I'm running out of time here, so I'm going to skip over this discussion of some of the nuances of the Sting framework.
00:51:28.732 - 00:52:07.820, Speaker A: Suffice it to say that Stingers need to look realistic. If they don't look realistic in principle, the subversion service can refuse to produce outputs. If it thinks somebody's trying to construct a proof of its existence, it can drop out of sight. This is one of the things that we have to contend with, and this turns out to be a substantial technical challenge. Yeah. In fact, since I'm low on time here, I'm going to skip over a number of things. I'm just going to say some of the applications of SF proofs are just whistleblowing to help the community achieve a high level of assurance in the applications it's using.
00:52:07.820 - 00:52:51.944, Speaker A: Particularly interesting is the possibility of Bounties. What we've shown is that the Verifier can be a smart contract and the smart contract can pay a reward for providing an SF proof. Somebody can set up a bounty for, say, a block builder. That can be claimed by anyone who's able to prove the existence of a subversion service. You can also imagine offering Bounties for not full breaks, but partial breaks of a system. And from a mechanism design perspective, this turns out to be an especially appealing option. As I said, this talk is based on a couple of blog posts, one back in April on Prof and another in June on the Sting framework.
00:52:51.944 - 00:53:27.904, Speaker A: There are papers forthcoming in the next several months. I'm hoping. Finally, I want to mention that as an aside, yesterday I announced that my blockchain thriller novel, The Oracle is going to be published in February. I'm delighted to say, as far as I know, this is the first, at least traditionally published novel that has crypto at its core and certainly the first crypto thriller. So if you like thrillers and you like crypto, you may want to have a look. That's it. I'll end there.
00:53:27.962 - 00:53:59.040, Speaker D: Yes. I was wondering, going back to the first half of your talk. If you have this option for regular users to submit their transactions either to this private mempool or the public mempool, where they'll lose mev, do you expect that? Why would anybody ever submit to the public mempool anymore? Wouldn't the normal blocks basically start shrinking to nothing and blocks end up becoming just this private part that you were appending to the end of blocks before.
00:53:59.110 - 00:54:20.596, Speaker A: You'Ve just alluded to my master plan? Yes. I mean, the hope is that transactions eventually get routed exclusively through services that order them fairly. So it's not that I want the public mem pool to shrivel up, but I would like to see less mev depredation and I'm hoping that prof is a step in that direction.
00:54:20.708 - 00:54:25.160, Speaker D: So there's no problem if you're appending to like an empty block.
00:54:25.980 - 00:54:43.010, Speaker A: There in principle shouldn't be a problem appending to an empty block. But I should also point out that transactions that are not vulnerable to mev extraction, just sending money, for instance, can go through the public mempool with no problem. So I wouldn't expect empty blocks in any case.
00:54:45.140 - 00:54:46.304, Speaker E: I have a question here.
00:54:46.342 - 00:54:46.592, Speaker A: Yeah.
00:54:46.646 - 00:55:03.812, Speaker E: So in the Kickstarting phase, I imagine that traditionally there could be just blocks that are full with the regular mempool. So you need some sort of subsidy of this phase otherwise, because since it's an append, from my understanding, it's an append only. So if a block is full, it's not going in.
00:55:03.866 - 00:55:10.552, Speaker A: Yeah. So if blocks are full, we're potentially in trouble. But thanks to EIP 1559, blocks are supposed to be half full.
00:55:10.606 - 00:55:32.568, Speaker E: Yeah. So then it interacts with the pricing mechanism because let's say it's going to take 10% whenever the block builders, all the validators, need to account for the fact that they need to keep this 10% for prof, otherwise prices start increasing and we need to go back and.
00:55:32.754 - 00:56:07.064, Speaker A: Yeah, we don't go around that. Yeah. So we haven't thought through in detail how prof interacts with EIP 1559, but at least in principle, blocks should not be full. So there should be an incentive to append these bundles. And presumably block builders will take into account the extra fees incurred as a result of making blocks slightly larger. In fact, I guess it'll cause the fees to rise slightly, which might even be to their advantage. But again, we haven't thought this through in detail, so I can't give you.
00:56:07.182 - 00:56:22.430, Speaker B: Cogent maybe one simple version of this would be as a builder using the service, maybe I specify how big a bundle I want back from you, for example. So then if I have 15 million gas, I have to then decide how much do I fill up, like from the public mem pool, then the rest I'll get from the service.
00:56:23.440 - 00:56:28.300, Speaker A: Yeah. Having a limited size allocation would certainly be one reasonable approach to this issue.
00:56:28.370 - 00:56:32.544, Speaker B: Then it's kind of up to the builder to decide how to allocate but.
00:56:32.742 - 00:57:04.956, Speaker E: If with the 50 million, he gets mev. I'm just thinking you might need to subsidize them at the beginning because if it's not the 50 million with the 50 million they get mev. They will just say, okay, I'm going to put the 15 million and then maybe there is 1 million from you. But then that pushes the price up. This would lead them to shrink again the block size, because of how EIP 1559 not only about the price rising, but tries to keep the block size around 15 million.
00:57:05.058 - 00:57:30.310, Speaker A: Right? Yeah, I mean, it does that by raising the gas price. I think it's fair to say that as a block builder, if you're given the choice, if your block is not full and you're given the choice between filling it out with a prof bundle or not, you have room. You'll put the bundle in the block. Right. Now there may be situations in which you can't do that because blocks get full. I don't know what happens in that case.
00:57:30.760 - 00:57:53.420, Speaker B: Even the bootstrapping phase, I would think the new equilibrium to say like you were getting a million gas back from the service every time. You just have sort of like a new base fee where the public mem pool, you'd only have 14 million gas willing to pay the base fee. So you could only construct a 14 million gas out of the public transactions and then you'd get the other million back from the service. I think that would be kind of like the new equilibrium.
00:57:54.800 - 00:57:56.236, Speaker E: How about the trade off between the.
00:57:56.258 - 00:58:14.144, Speaker B: 1 million where they get revenue versus the subsidy? I think this is interesting. How would you expect what fraction of the blocks is it going to be like? Noemi said where kind of like you have nothing from the public mempool and it's all just from the service. That to me is very interesting to see how it plays out.
00:58:14.182 - 00:58:27.988, Speaker A: But even now it's not the case that all of the block is full. Basically just with me, there will be some space left and you can expect that to slowly decrease as users choose.
00:58:28.074 - 00:58:33.288, Speaker B: Private vem pool, maybe, yeah, it'd be fun to see how it plays out.
00:58:33.374 - 00:58:34.724, Speaker C: I mean, at least like game, theoretically.
00:58:34.772 - 00:58:37.592, Speaker B: You can try to you can speculate what it's going to look like.
00:58:37.646 - 00:58:44.860, Speaker A: There are a lot of considerations here. I think there's ample opportunity for follow up work, clearly.
00:58:47.440 - 00:59:02.012, Speaker D: Good question about prof. So you mentioned there are multiple enclave solutions. Have you thought about kind of enhancing prof to use all of them as maybe onion or onion of enclaves or like sansos run between different architectures?
00:59:02.156 - 00:59:46.690, Speaker A: We've considered only superficially how different prof instances would compose. So, as I mentioned, you could for instance, do the following. If there are two prof services rather than one prof service only allowing its bundles to be appended at the very end of a block, it might allow its bundle to be appended after a bundle produced. Sorry, before a bundle produced by the other prof service because it knows that the other prof service is ordering transactions fairly and that the other prof service is not going to end up sandwiching it in some way. For instance, that's as far as we've gotten in thinking about composition, but certainly interesting to think about more sophisticated forms of service composition. Yeah.
00:59:48.340 - 00:59:49.330, Speaker B: Thanks again.
