00:00:09.130 - 00:00:26.686, Speaker A: All right, so I think we're ready to go. So today we have Andy Lewis Pai from London School of Economics going to be talking about consensus. And I'll just remind that we do have two more seminars this week. Tomorrow we have Ling Ren who's visiting. He's going to talk about BFT protocols. And I believe Thursday we have Andy again.
00:00:26.788 - 00:00:27.294, Speaker B: That's right.
00:00:27.332 - 00:00:27.920, Speaker A: Yeah.
00:00:29.410 - 00:01:04.000, Speaker C: Good. Okay, so yeah, so this is going to be a nice, easy introduction to consensus. That's the idea. So I'm going to start off by assuming, like, zero background knowledge or essentially zero background knowledge. The idea is that today and Thursday I'm going to go through most of the most famous results from the literature with full proofs. Okay, so I guess if you already know a fair amount about consensus, I guess the first part, because I'm starting right at the beginning, the first part might be a little bit slow, but even if you know a fair amount, I hope that it gets interesting at least, like, halfway through the first talk. Okay, so hold on.
00:01:04.000 - 00:01:56.030, Speaker C: Before we start proper, I guess a crucial distinction that has to be made here is between permissionless and permissions protocols. So I guess everyone's probably familiar with this idea already. Basically, permissioned protocols are those where you know exactly who's involved in the protocol execution right from the start. Okay, so maybe there's some company they got from like, five servers in different parts of the world, and those servers are going to carry out some permission protocol to make sure that they're updating data correctly between them, that sort of thing. So that's a permission protocol because you know exactly who's involved as opposed to a permissionless protocol, like Bitcoin, where anybody can join in. I mean, you don't necessarily know who those people are and so on. Okay, so most of the classical theory dating back to the 1980s is with respect to the permission protocols, right? Often that might be with respect to what I call BFT protocols, where BFT stands for Byzantine Fault Tolerant.
00:01:56.030 - 00:02:36.170, Speaker C: Nowadays there's renewed interest in permission protocols, partly just because there's interest in implementing those protocols as permission protocols directly, but also because there are basic methods you can use for implementing permission protocols as permissionless protocols. Okay, so there are methods you can use for taking a permission protocol and implementing it in a permissionless setting, maybe as a proof of state protocol or something like that. Okay, so in this course, I'm going to be focusing at least on the permission protocols, okay, because that's where most of the theory is. But then on Thursday, I'll also talk a little bit about how the theory for permission protocols and permissionless protocols, how those theories relate.
00:02:36.590 - 00:02:39.114, Speaker B: Okay, good.
00:02:39.152 - 00:02:58.820, Speaker C: Okay, so let's go right back to the start then. So we want to study consensus protocols. First of all, I guess what we have to know is what is the problem a consensus protocol has to solve. And there are various different ways you can answer that question. Maybe the most famous consensus problem is the Byzantine agreement problem.
00:02:59.830 - 00:03:00.242, Speaker B: Okay?
00:03:00.296 - 00:03:16.300, Speaker C: So let's start with that one. And I'm going to start off by giving, like, an informal version of the problem. I'm just going to state it basically like it is in the original paper by Lamport, Shostak and Peace, which comes right back in the 1980s. So we're going to start off with an informal version, and then I'll make it formal later on.
00:03:17.630 - 00:03:17.946, Speaker B: Okay?
00:03:17.968 - 00:04:00.674, Speaker C: So we've got several divisions of the Byzantine army, a camp outside an enemy city, each division commanded by its own general. Here, it's basically only the generals we care about. The rest are just part of the story. And then the generals could communicate only by messenger. So the generals are communicating in pairs here. At any given point in time, each general can choose to send a message to each other generals or one of the other generals in particular, right? And they can do that as many times as they like, okay? So the generals can communicate only by messenger, and they have to carry out a protocol to decide on a common plan of action, either attack or retreat. So initially, each general has their own private opinion as to whether you should attack or retreat.
00:04:00.674 - 00:04:47.590, Speaker C: You can sort of think of that as being their input in this scenario, okay? Their own private opinions, if you like, their input. So the difficulty here is that some of the generals might be dishonest, okay? So they're going to carry out this protocol. We're assuming the honest generals are going to carry out the protocol exactly as you want them to, but the dishonest generals, we don't know what they're going to do, okay? And we want certain basic conditions to be satisfied. So first of all, we want to make sure that the honest generals terminate. They actually come to some conclusion. So obviously here we can't insist anything from the dishonest generals because we don't know what they're going to do, okay? But for the honest generals, we can assist certain things. So we're going to require the honest generals have to reach the decision.
00:04:47.590 - 00:05:04.090, Speaker C: We're going to require that they all reach the same decision, the all the honest generals. And then lastly, we're going to require that if all the honest generals start with the same opinion, if they all have the same input, then that common input should be their common output.
00:05:06.110 - 00:05:06.474, Speaker B: Okay?
00:05:06.512 - 00:05:36.440, Speaker C: So we've got a bunch of people here, a bunch of generals each have an input, have to go through some protocols. They each have to decide on some common answer. If they all start with the same input, they always have to give that common input as their output. Okay? Yeah. So this is like an informal version of the problem. As I said, I'll give you a formal version in a bit. But even with this informal version, there are various sort of things we can already say, right? So let's start sort of prodding around and see what we can immediately see.
00:05:36.440 - 00:05:52.620, Speaker C: So the first basic point to make here is without the validity requirement, it's pretty clear this would be trivial, right? So without validity, basically what the oldest generals could do, they could just ignore their input and they could do all just decide to attack whatever, right?
00:05:53.150 - 00:05:53.900, Speaker B: Okay.
00:05:54.670 - 00:06:21.380, Speaker C: So certainly validity is required to make this interesting, otherwise it'd be a bit trivial solution. First observation, okay? So what I've done here, I've just restated the problem more succinctly and moved it to the top of the slide and I put a red line about it. And I've also introduced some more terminology here. So I'm always going to use N for the number of parties, the number of generals, and F is going to be some upper bound on the number of dishonest generals here.
00:06:24.070 - 00:06:24.434, Speaker B: Okay?
00:06:24.472 - 00:07:05.634, Speaker C: So what else can we say, even with the informal version? So for clarity, let's suppose that the honest generals know F. They're given some bounds, they know that bound, that's common knowledge, okay? But obviously they can't know well, let's say they don't know which of the dishonest generals. If they know which of the dishonest ones, it makes it sort of trivial as well because you just ignore them, right? Okay. But they have some upper bound on a number of dishonest guys here. So next obvious observation. So if F is zero, then the problem is trivial, right? Because in that situation, we just do a majority vote. Everyone would just you can just each general can send their initial opinion to everybody else.
00:07:05.634 - 00:07:14.182, Speaker C: It will end up with the same list of opinions, right? Nobody's lying. Just do a majority vote if there are ties and break it in some arbitrary prearranged fashion, something like that.
00:07:14.236 - 00:07:14.840, Speaker B: Okay?
00:07:17.770 - 00:07:19.830, Speaker C: So if F is zero, then it's trivial.
00:07:22.890 - 00:07:23.302, Speaker B: Okay?
00:07:23.356 - 00:07:30.506, Speaker C: So it's clear then that one of the basic questions we're going to be interested in is of what values are N and F. Is it possible to design a protocol here?
00:07:30.528 - 00:07:30.666, Speaker B: Right?
00:07:30.688 - 00:08:11.682, Speaker C: So that's one of our basic questions. The next easy observation is, okay, so it's also pretty obviously not going to be possible if F is greater than or equal to N over two if we have a dishonest majority here. So let's take you through a sort of simple proof of that. So let's suppose we've got two generals. Let's suppose they're given the inputs, attack and retreat, that's where they're starting. And let's suppose that they're going to both act entirely honestly in this situation. They have to come up with some common output, right, to satisfy the agreement property.
00:08:11.682 - 00:08:21.160, Speaker C: So they come because I've got to decide on something. Everything's entirely symmetrical here so far. So without loss of generality, let's suppose that they decide to attack in that situation.
00:08:21.930 - 00:08:23.286, Speaker B: Hey, hopefully you're happy.
00:08:23.308 - 00:08:38.010, Speaker C: Everything's perfectly general so far because it's symmetrical. I could decide they retreat, and it would be a symmetrical argument. Okay, so we got two honest generals. One has initial position attack. That's their input. The other one has initial position retreat. Let's suppose they decide to attack in that scenario.
00:08:38.010 - 00:08:57.540, Speaker C: Okay? In that case, fine. So now let's consider another situation. Now, again, we got two generals. Let's suppose they're both given input retreat. But let's suppose that this guy is actually dishonest, and what he decides to do is to pretend that his input was attack. And then after that, just act like an honest general would.
00:08:58.230 - 00:08:58.980, Speaker B: Yeah?
00:08:59.350 - 00:09:19.180, Speaker C: So then you already know what happens in that scenario, right? So now everyone's acting honestly after that point. So then the output then is attack, right? That's the output in this scenario as well. But now we got a conflict with validity, right? Because this general here so all of the ons generals, in fact, had the input retreat here, but they decided to attack.
00:09:22.240 - 00:09:22.844, Speaker B: Okay?
00:09:22.962 - 00:10:24.188, Speaker C: That's quite simple. Okay, so if F is zero, it's trivial, trivially solvable. If F is greatly equal to N over two, got a disinvisable majority, then it's fairly trivially non solvable, right? And then I guess the next thing you might think is, okay, so when F is less than N over two, well, maybe then it's still like trivially solvable. So maybe it's trivially unsolvable. When F is greater than N over two, maybe it's trivially solvable when it's less than N over two in particular. So you might think, well, why can't we just do some sort of majority vote type thing? So, yeah, well, the problem with that approach stems basically from the allowed form of communication here, okay? We're having the generals communicate in pairs. If you had a scenario where imagine everyone's just standing around in a circle and they're shouting out their votes, right? So that means that whenever any general shouts out, maybe like their initial input, whatever, everybody hears that and they all hear the same thing.
00:10:24.188 - 00:10:30.240, Speaker C: So you can't say different things to different people. Well, then it would be trivial. Then you could just do a majority vote argument.
00:10:31.860 - 00:10:32.224, Speaker B: Okay?
00:10:32.262 - 00:11:00.760, Speaker C: So in that case it would be trivial. But that's not our set up here, okay? So here we're having communication between pairs, one pair of generals at a time. And then the problem now is that the dishonest generals can tell different things to different parties, right? Okay, so to make that concrete, let's suppose N is three. We've got three different parties involved here. We've got f is one. So most one of the general is going to be dishonest. Let's suppose one honest general initially wants to attack while the other one wants to retreat.
00:11:00.760 - 00:11:52.718, Speaker C: If the dishonest general sends a retreat message to the one who wants to retreat and an attack message to one who wants to attack, then they'll both see different majorities, right? One who wants to attack will see an attack majority. The one who wants to retreat will see a Jeep majority. Okay, so majority vote doesn't work. And in fact, you can show basically there's no really trivial answers going at work here because, well, in fact, you can show that there's no solution that works when F is greater than equal to N over three, unless you endow the generals with some extra capabilities. Okay, so it's maybe not as easy as it might initially seem. Okay, so that's initial prodding around the edges as to what the problem feels like. Okay, so yes, the next thing we have to do is to establish our formal framework.
00:11:52.718 - 00:12:24.700, Speaker C: It's maybe a bit boring, but unfortunately it's really necessary to be careful with the details of details here. Generally, I think consensus isn't very difficult in the sense that the protocols don't tend to be very complicated. What makes it tricky is that small little changes in the setup can make big differences to the answer. You set things up one way and you get a certain set of answers. You change things a little bit, you get a completely different set of answers. You have to sort of memorize all these different possibilities. Okay, so we're going to formalize the framework and sort of outline what the different possibilities are that make a difference.
00:12:24.700 - 00:12:38.590, Speaker C: Okay, so we're going to, I guess, unsurprisingly, we formalize each general as a processor. Doesn't really matter how you do that. Just take your favorite model of computation, imagine them to be interactive Turing machines, if you like.
00:12:38.660 - 00:12:39.280, Speaker B: Okay?
00:12:43.810 - 00:13:10.490, Speaker C: Then we're going to have the so the execution of the protocols. We're going to be divided up into discrete time slots. Okay, so we're going to start off at time slot zero. Then we have time slot one, time slot two, and so on. At each time T, each processor receives a certain set of messages from the other processors. And then depending on what those messages are, it carries out some finite set of instructions. Those instructions allow it to decide what message it sends out to other processors at that time slot.
00:13:10.490 - 00:13:31.102, Speaker C: Well, we'll come to that in a second. There are a few possibilities and we'll start off simple and then we'll sort of get more complicated. Okay, so each time slot you get a certain set of messages. You go through some finite set of calculations and then you decide what message to send out.
00:13:31.156 - 00:13:31.760, Speaker B: Okay.
00:13:36.130 - 00:13:52.070, Speaker C: So there are N processes, right? And we're going to give them names. Zero up to N minus one might seem a bit OD to do, zero up to N minus one more than one to N, but it makes it easier to work mod N when you're doing talking that stuff. Okay, so each processor here is told N and they're also told their own name.
00:13:52.140 - 00:13:52.374, Speaker B: Okay?
00:13:52.412 - 00:14:02.966, Speaker C: So that's part of their input. And then we have authenticated channels. Okay, so there's like a two way channel between each pair of processes.
00:14:02.998 - 00:14:03.514, Speaker B: Here. Okay?
00:14:03.552 - 00:14:07.370, Speaker C: So for each pair of processes I and J, we've got a channel IJ.
00:14:07.790 - 00:14:08.202, Speaker B: Okay?
00:14:08.256 - 00:14:37.160, Speaker C: The way that works is quite simple. So only I can send messages to J, only J can send messages to I on the channel IJ. And when I receives messages, it's aware of the channel by which the message was sent. So if it gets a message on a particular channel, if it gets a message on the channel I J, it knows that message was from J. Okay, so each processor sitting there, it's got a bunch of authenticated channels and it knows who's at the end of each channel. So a message arise on that channel, it knows who the message is from.
00:14:41.290 - 00:14:41.606, Speaker B: Yeah.
00:14:41.628 - 00:14:46.666, Speaker C: And as I said, so at each time slot, the instructions for processor I determine which messages it should send along.
00:14:46.768 - 00:14:48.090, Speaker B: Each of its channels.
00:14:50.190 - 00:15:41.606, Speaker C: Okay, then sometimes we want to assume public key infrastructure, sometimes not. If you're given a PKR public key infrastructure, that just means each process is given like a secret key public key pair and it's told the public key of each of the other processes. So as it looks along each of its channels, it knows at the end of this channel there's process J, and this is their public key. Okay, so now we have to get to how reliable do we want message delivery to be, since it makes quite a big difference. Okay, so to keep things simple, I'm going to start off in the sort of the easiest setting, right? So I'm going to start off in what we call the synchronous setting. That means if I sends J a message at times T, then J receives that message at the next time slot times T plus one. Okay, that's the synchronous setting.
00:15:41.606 - 00:15:46.166, Speaker C: Another version of the synchronous setting might be that you have some finite bound delta.
00:15:46.198 - 00:15:46.346, Speaker B: Okay?
00:15:46.368 - 00:16:14.930, Speaker C: So if I sends a message at times T, then J receives it by time T plus delta at the latest. Basically, for our purposes here, the distinction isn't that important. It isn't very interesting because any theorem we talk about here will hold for one if in any of it holds the other with basically the same proof or easy modification. Okay, so just to keep things simple, I'm just going to have this really the simplest possible version of the synchronous setting, but have in mind it could be slightly different. All the same results will hold at least as far as the stuff we're talking about now is concerned.
00:16:19.130 - 00:16:23.240, Speaker B: That you can send multiple messages at the same time.
00:16:23.690 - 00:16:31.340, Speaker C: Yeah, it doesn't really matter because you're just saying you can send some set of data if you want to sort of call it multiple messages. Yes. Okay, certainly you can send multiple messages to different processors as well.
00:16:31.710 - 00:16:34.090, Speaker B: But if I send all of them a same speed.
00:16:40.210 - 00:16:48.960, Speaker C: No. So I can send a message to each of the other participants any given time of slot, and they'll all arrive at the next time.
00:16:51.750 - 00:16:52.500, Speaker B: Okay.
00:16:54.470 - 00:17:24.060, Speaker C: Then we also have to decide how dishonest generals can behave. So we'll talk about the following way. So some of the processes are faulty or maybe faulty, as I said before. So each processor is given an upper bound f for the number of faulty processors as part of this input. But we're going to suppose that's known. And generally we're going to be most in analyzing settings where the faulty processors can just display arbitrary behavior. In particular, they might be malicious, right? So they might be trying to muck things up.
00:17:24.060 - 00:17:35.374, Speaker C: So in that case, we say the process is displayed by Xantine faults, so they can just follow some arbitrary program. Everything I'm talking about so far, by the way, I haven't put in the slides. We're going to imagine everything's deterministic so far.
00:17:35.412 - 00:17:36.000, Speaker B: Okay.
00:17:41.500 - 00:18:30.732, Speaker C: You might want to consider other sorts of faults, different settings, different sorts of faults might be interesting. You might also consider crash faults. So if you consider crash faults, that means basically processors have to follow the protocol precisely up until maybe some point where they crash, and then after that point they just stop doing anything. Okay, but mainly we're going to be interested in Byzantine faults because that tends to be one that people are interested in in the blockchain setting, right? And then just a little bit of informal terminology. So often we'll talk about an adversary. So often it'd be convenient to think of all the faulty processes that are displaying arbitrary behaviors being sort of coordinated by some adversaries trying to coordinate their actions so as to be as difficult as possible. Okay, so sometimes it's necessary to formally define the notion of reversary.
00:18:30.732 - 00:19:41.610, Speaker C: But for all the stuff I'm going to talk about in these tutorials, it's not okay, so it's just an informal plan. Okay, so that's basically the formal setup, if you like. What's our research program? Then? The questions we want to answer are basically these. So for which NNF do there exist protocols to solve the Byzantine agreement problem and other forms of the problem, to find some other ones as well? How does that depend on the various possibilities we talked about there? So how does it depend on things like message reliability, whether we're working in the synchronous setting or whether we're working in settings that make weaker assumptions on message reliability? Okay, so maybe I should have said before. So in the synchronous setting, we're starting off in the synchronous setting as a pretty strong assumption. So after a little bit, we'll relax that and we'll talk about other settings like the partially synchronous setting, where message delivery might be sometimes much less reliable, and that will change the set of results we get and the set of protocols we have to use. How does that all depend on the form of faulty behavior?
00:19:41.690 - 00:19:41.934, Speaker B: Right?
00:19:41.972 - 00:20:27.786, Speaker C: Whether we're talking about Byzantine faults or crash faults, again, Byzantine faults just means you can behave anyway whatsoever. Okay, and how does it all depend on whether or not you have a public key infrastructure that also makes a big difference? Okay, so that's the basic those are the questions we're looking to answer and the order in which we're going to do that is the following. So yeah, so we're going to start off in the synchronous setting, simplest setting, first of all. Basically we're just going to concentrate on Byzantine faults. I think I'm going to determine for which NNF Byzantine agreement is possible depending on whether a PKI is given that makes a difference. Okay. Then we'll consider the same question for crash faults at this time and then we'll do the whole thing again for weaker assumptions about message delivery.
00:20:27.898 - 00:20:28.560, Speaker B: Okay.
00:20:31.730 - 00:21:04.184, Speaker C: And also we won't just talk about the Byzantine agreement problem. I'm sort of focusing on that to make things simple at the beginning. But we'll also talk about some other forms of problem. So biozantine broadcast and state machine replication are two other important variants. So basically state machine replication is just what bitcoin solves in some sense. Okay? Right. So I stated by Zantin agreement before in a slightly informal way, but also the version I stated before was like a binary version of the problem.
00:21:04.184 - 00:21:32.690, Speaker C: So there were two options attack or retreat. Right. So sometimes it's useful to have a more general form. So let's write that down. So we consider a set of N processors, most F, maybe faulty, and then for some set V, each processor is given an input in V. Obviously different processors might get different initial inputs. We're going to imagine V is told to all the processors n could be of any finite size greater than equal to two.
00:21:32.690 - 00:21:36.416, Speaker C: Doesn't really matter that it's finite here all I care about is that V is decidable.
00:21:36.448 - 00:21:36.644, Speaker B: Okay.
00:21:36.682 - 00:22:02.156, Speaker C: So process can determine whether any given values in V. Then we just have the conditions we said before. Okay, so we need termination. All non faulty processors must give an output in V agreement. They will have to get the same output again, validity the same as before. So if all non faulty processors have the same input, then that's got to be their common output. Okay, so that's the Byzantine agreement problem.
00:22:02.156 - 00:22:06.776, Speaker C: Hopefully you have that memorized now because we're going to be using that for the rest of the talks.
00:22:06.808 - 00:22:11.890, Speaker B: Good. Are they allowed to output something not in B?
00:22:12.580 - 00:22:15.490, Speaker C: No. Exactly right, so you have to give an output in B. Yeah.
00:22:19.460 - 00:22:34.470, Speaker A: Are there ever like formulations of this to consider a fairness notion of if one do sort of force the outcome to be what they want it to be, even if assume it's a valid output, but it's going to be not what everybody else started with.
00:22:35.720 - 00:22:39.764, Speaker C: So you're talking about something other than the sort of broadcast version of problem. It sounds a bit like the broadcast.
00:22:39.812 - 00:22:56.780, Speaker A: Version that broadcast from now is just like the notion of like, you get everybody to agree on an output that's in the valid, but maybe you don't want one node to just be able to dictate the whole process by deviating from the protocol.
00:22:57.120 - 00:23:08.188, Speaker C: Yeah, if you solve this, and if you've got a protocol that works for large F, you won't have one node be able to dictate it. Do you mean one honest node not being able to dictate it or any faulty node not being able to dictate?
00:23:08.284 - 00:23:10.608, Speaker A: Maybe one faulty node can steer everybody yeah.
00:23:10.614 - 00:23:31.720, Speaker C: Okay. You're going to have to satisfy validity. So you're saying in scenarios where they don't have the same input, you still don't want them having that much influence. They're interesting. Okay, I'm not sure about that. Okay, so that's our first version. That's by Zantine agreement.
00:23:31.720 - 00:23:58.428, Speaker C: Then here's another variant which you're going to have to memorize. Okay, so it's a simple variant though. In fact, in the original paper where Lamport, Schostuck and Peace introduced the Byzantine Agreement problem, they really focused most of the time on this variant called the Byzantine Broadcast Problem. It's now called the Byzantine broadcast problem. So the setup now is similar. So we've got n processors f faulty. So now one processor is designated the broadcaster.
00:23:58.428 - 00:24:20.244, Speaker C: So they're given a special role. Everybody knows who the broadcaster is. That's part of your input. Now only the broadcaster is given an input. Okay, so the broadcaster is given an input in some set V, and again V is told to all the processors. Now we have to satisfy the following conditions. So again, it's a termination.
00:24:20.244 - 00:24:57.590, Speaker C: So all non faulty processors have to give an output in B similar to before agreement, they will have to give the same output. But now the validity of the condition is different. Okay, so now if the broadcaster is non faulty, has input B, then all non faulty processors have to give that value as their output. Okay, so it's kind of similar, but now we've got one particular processor who's distinguished from the others. And the idea is that he's trying to tell everybody his value. Everybody should agree on that value, right? If he's non faulty, everybody will agree on that value. Even if he's faulty, they're still going to agree on some value, but obviously not necessarily his value.
00:25:00.200 - 00:25:01.670, Speaker B: You happy with that?
00:25:03.240 - 00:25:24.828, Speaker C: So we're two different versions of the problem. In Byzantine agreement, everyone's given an input. They have to terminate some common output. And if they're all given the same input, their common input has to be that output. In the broadcast version of the problem, simply we got a particular node who's the broadcaster. Everybody has to output the same output. And if the broadcaster is honest, then you have to output his value.
00:25:24.994 - 00:25:27.390, Speaker B: Okay. Okay.
00:25:31.920 - 00:25:40.850, Speaker C: So now you got two different versions of the problem. I guess the natural question is how do they relate? Are they essentially the same? Hopefully they're the same we forget about it and go back to one version of the problem. Right?
00:25:42.180 - 00:25:42.688, Speaker B: Okay.
00:25:42.774 - 00:26:20.220, Speaker C: So to what extent are these the same? So we saw before that so Byzantine Agreement can't be solved when F is greater than or equal to N over two, when we have a dishonest majority, right? That was a sort of simple argument with two different generals. It's easy to see though, and I won't go through it, but it's easy to see. The same argument doesn't apply to Byzantine Broadcast. And in fact, we'll see that if a PKI is given and if we work in a synchronous setting, then there are protocols for solving Byzantine Broadcast that can deal with any number of faulty processes. Okay? So they're not exactly the same problem. There are some scenarios at least where you can solve BB by Xantine Broadcast and not Byzantine Agreement.
00:26:20.560 - 00:26:21.310, Speaker B: Okay?
00:26:24.960 - 00:27:11.976, Speaker C: On the other hand, okay, if we're working in the synchronous setting, this won't necessarily be true. Another setting, if we work in a synchronous setting and if F is less than N over two, so this is the sort of the realm in which you can solve By Xanthanine agreement. Maybe then the two problems reduce to each other quite easily. Okay, so let's see that. So on the one hand, if we can solve Byzantine Broadcast, then to solve Byzantine Agreement, we have all processors broadcast their inputs using the protocol for Byzantine Broadcast, right? So if you just go through n different versions of that protocol, so each one takes their input, digital broadcast that to others. Then once the values decided, correspond to each processor process, then decide by majority vote, right? Breaking ties in some arbitrary fashion. So essentially what you're doing here is you're just executing that majority vote protocol we talked about before, but you're getting rid of the problem.
00:27:11.976 - 00:27:18.768, Speaker C: That dishonest. Guys can say different things to different processes, right? If they go via the Byzantine Broadcast protocol, you should get over that problem.
00:27:18.854 - 00:27:19.490, Speaker B: Yeah.
00:27:20.500 - 00:27:53.900, Speaker C: Okay, so that's one direction. Other direction is also quite simple. So if we can solve Byzantine Agreement, then to solve Byzantine Broadcast, we can have the broadcaster send their input to all of the processes at time zero. If we're in the synchronous setting, that should arrive by time slot one. So each process then takes the value received at time one as their input value. Or they didn't get anything because the broadcaster is not honest and they just make something up. Okay, then we just have the process carry out a protocol for buzan agreement on those input values.
00:27:59.630 - 00:28:01.722, Speaker B: Is that clear? Okay.
00:28:01.776 - 00:28:30.834, Speaker C: So there's a fairly easy reduction in both directions. So the result is, okay, so they're not the same problem. But if we work in the synchronous setting, and if F is less than N over two, then they are basically they're reducible to each other. And I guess the consequence of this is overall, so far it seems like we. Only really have to worry about Byzantine Broadcast because if Byzantine Broadcast is impossible, then Byzantine Agreement is definitely impossible. And if Byzantine Broadcast is possible impossible, the other one is as well, right?
00:28:30.952 - 00:28:31.234, Speaker B: Okay.
00:28:31.272 - 00:28:39.270, Speaker C: So if you work out for which F you can do Byzantine Broadcast, that gives you the result of Byzantine agreement, so long as you're in the synchronous setting.
00:28:46.900 - 00:28:47.312, Speaker B: Okay?
00:28:47.366 - 00:29:07.160, Speaker C: So now let's get on to the results. Okay, so we'll start off with, I guess, the easiest one. So it's easiest if you've got a PKI. So we're in the synchronous setting. We send messages to arrive at the next time slot. We can imagine we have a public infrastructure. The result here is that there exists a protocol that solves the Byzantine Broadcast problem for any number of faulty processors.
00:29:07.160 - 00:29:16.990, Speaker C: So this result is originally due to lamport, shostak and peace. But I'm going to talk you through a more elegant protocol by Dolov and Strong.
00:29:20.480 - 00:29:20.844, Speaker B: Okay?
00:29:20.882 - 00:29:46.100, Speaker C: And as I just said, so we're talking about Byzantine Broadcast here, but this also deals with Byzantine agreement, right? So by the reductions we just discussed, also suffice to show that we can solve Byzantine agreement in a singular setting with PKI, even if, even only if F is less than N over two, okay? Because Byzantine agreement just generally isn't possible if F is greater than equal to N over two. But if F is less than N over two, then you can use Byzantine Broadcast to solve Byzantine agreement.
00:29:48.760 - 00:29:49.124, Speaker B: Okay?
00:29:49.162 - 00:30:09.724, Speaker C: So we only have to worry about Byzantine Broadcast. That's what we're going to do. And again, maybe before we talk through proof, maybe it's worth thinking about why it isn't trivial. So we talked about why Byzantine Agreement wasn't trivial before because the majority of your vote sort of thing. But now we're talking about Byzantine Broadcast, and now also we've got a PKI. So maybe it's worth thinking about it again a little bit.
00:30:09.762 - 00:30:10.350, Speaker B: Okay?
00:30:11.920 - 00:31:13.928, Speaker C: So what might be an obvious sort of way to proceed? So an obvious way to try solving Byzantine Broadcast, if you've got a public infrastructure, maybe you've got one guy, he's the broadcaster, and we're trying to get everybody to agree on his value if he's honest, right? It's an obvious thing to do would be to have the broadcaster send out signed versions of the values of the versions of their inputs to all the other processors at the beginning, right? And obviously, if they're honest, they'll send everybody the same signed value. If they're dishonest, they might be sending different people different things. So we'll start off like that. Then the processors could just repeatedly share all the signed values they've seen produced by the broadcaster. If they only ever see a single value produced, then they output that value, we're happy. Then they've all terminated, they've all agreed. And if the Broadcast is honest, they only were seeing this single value he's sending out, so they're outputting the correct value.
00:31:13.928 - 00:31:40.320, Speaker C: So we're happy. Other hand, if they sue two different values being produced, then they realize the broadcast was faulty because an honest broadcaster, a non faulty broadcaster, wouldn't send out two different signed values of versions of their initial value, right? So in that case, well, they know that the broadcast is faulty, so all they've got to do is agree on some value. It doesn't have to be their value. So in that case they just give some default value as their output.
00:31:41.160 - 00:31:41.910, Speaker B: Okay?
00:31:44.200 - 00:32:15.096, Speaker C: That would be the idea, right? This doesn't work. Okay, so the idea is if the broadcast is non faulty, then they'll only produce a single sign value and all non faulty processes will output that. That sounds good. Okay, on the other hand, if the broadcaster produces two different sign values and shows them to non faulty processors, then the idea is everybody eventually see those two values and they'll give the default output. Okay, in that case we're fine as well. Okay, so that's the idea. Hopefully.
00:32:15.096 - 00:32:38.900, Speaker C: It's also fairly clear what the problem with that is. Problem is when do we stop sharing values, right? So we share values up until time t. Then what the adversary can do is you can just show everybody like one particular value up until time t and then at time t when it's too late to share anymore, then he suddenly shows some subset of the honest processors two different values.
00:32:39.400 - 00:32:39.764, Speaker B: Okay?
00:32:39.802 - 00:32:50.596, Speaker C: So then some of them would go to the default value, some of them give another value and you've broken the agreement property. Yeah, see that the problem is when do we stop sharing values?
00:32:50.628 - 00:32:51.210, Speaker B: Right?
00:32:51.660 - 00:32:58.984, Speaker C: Basically wherever you put the cut off, the bursary can start playing games with showing different processes, different things at that exact cut off.
00:32:59.022 - 00:32:59.610, Speaker B: Okay?
00:32:59.980 - 00:33:34.420, Speaker C: And again, you might sort of think, well, there must be something simple I could do here, something will work out. But in fact, you can kind of show that nothing really simple will work. Because if you have F 40 processors, you can show you need at least F plus one rounds of communication. So there's no really simple answer here. Okay, so let's see the nice solution. Database strong. Okay, so what we need is a clever mechanism here to ensure that if any non faulty processor, let's say, recognizes a certain value produced by the broadcaster, then they all recognize that value.
00:33:35.290 - 00:33:36.040, Speaker B: Yeah.
00:33:39.930 - 00:33:45.670, Speaker C: Right. So if you have the case, okay, whenever any non faulty processor recognizes a certain value, then they all do.
00:33:45.740 - 00:33:45.974, Speaker B: Okay?
00:33:46.012 - 00:33:59.178, Speaker C: Then what that means is that either way, either they all recognize a single value produced by the broadcaster and they all output that single value, or they all recognize multiple values so they all give the default value.
00:33:59.264 - 00:33:59.526, Speaker B: Okay?
00:33:59.568 - 00:34:02.398, Speaker C: So if we can ensure that this is true, then we're happy.
00:34:02.484 - 00:34:04.640, Speaker B: Is that clear? Yeah.
00:34:06.370 - 00:34:33.254, Speaker C: That'S what we want. Okay, so here's the mechanism. It's quite elegant. So at time zero, the broadcasters send assigned version of their input to each processor. Again, if they're honest, they'll send the same value to everybody. If they're dishonest, there might be multiple values there. At time one, the processors look to see whether they've received a signed value from the broadcaster, and if so, they sort of recognize that value.
00:34:33.254 - 00:34:37.190, Speaker C: They recognize this is something, a value that the broadcaster has produced.
00:34:37.530 - 00:34:38.280, Speaker B: Okay?
00:34:39.130 - 00:34:52.750, Speaker C: So now though, rather than just passing on that signed value to other processors, what they do is they attach their own signature to message. So now it's been signed twice, first by the broadcaster, then by them, and then they send that new version of the message to all processors.
00:34:56.050 - 00:34:56.800, Speaker B: Okay?
00:35:00.130 - 00:35:09.490, Speaker C: Then more generally we stipulate if the processor is to recognize a new value at any time T, then the message has got to be signed by t distinct processors.
00:35:10.150 - 00:35:10.754, Speaker B: Okay.
00:35:10.872 - 00:35:39.786, Speaker C: And if they recognize a new value at time T, then they add their signature to the list and they send that new message out. Now with T plus one signatures. Okay, so at time slot zero, the broadcaster sends out signed versions of their input at time slot one. Other processors like receive that it's got one signature at time slot was time slot one. So they're happy to recognize that value. They then add a second signature, send that out at time slot one. If other processes receive that at time slot two, it's now got two distinct signatures so they're happy to recognize it.
00:35:39.786 - 00:35:46.526, Speaker C: Then they might then add a third signature and so on. At times three people will be happy to recognize if they see three distinct signatures on it.
00:35:46.548 - 00:35:46.734, Speaker B: Okay.
00:35:46.772 - 00:35:50.590, Speaker C: And the signatures have to be distinct from different processes.
00:35:54.160 - 00:35:54.524, Speaker B: Okay.
00:35:54.562 - 00:36:00.064, Speaker C: So that one there is a generalization of that. So I'm just going to encapsulate everything. The shorter description there.
00:36:00.102 - 00:36:00.304, Speaker B: Okay.
00:36:00.342 - 00:36:02.320, Speaker C: So I've got some more space on the slide.
00:36:04.180 - 00:36:07.090, Speaker B: Pretty happy with that process. Okay.
00:36:09.060 - 00:36:24.230, Speaker C: Then finally, just at the end what we do, so it's going to be a finite process. We're going to have F plus one many stages. So termination will be automatic. Everyone's just going to terminate after F plus one round. So at time F plus one, we give the processes a last chance to recognize new values, but they can't share again.
00:36:24.680 - 00:36:25.476, Speaker B: Okay.
00:36:25.658 - 00:36:40.142, Speaker C: And then what they do is they either output the single value they've recognized if it's only a single value, or if they've recognized more than one value, they'll go to the default option. Okay, so it's a protocol clear first of all.
00:36:40.196 - 00:36:41.200, Speaker B: Yeah. Okay.
00:36:44.130 - 00:37:06.600, Speaker C: So now let's see what that works. We have to show that any non faulty processor recognizes a certain value, then they all do. As long as that's the case, we're entirely happy. That's what we have to show. So there are two different cases to consider here. So first of all, it's the easy case. Let's suppose some non faulty processor I first recognizes some value before it's too late to share.
00:37:06.600 - 00:37:40.714, Speaker C: In that case, it's quite simple. Basically, they just have to add their signatures or share the value, right? So suppose some non faulty processor I first recognizes V at some time T strictly before F plus one, when it's not too late to share. What does that mean? In that case, I receives a message relaying the value of V at time T, which has T distinct signatures attached. Otherwise I wouldn't recognize that value at that time, right? It's got to have T distinct signatures for I to recognize the value. Okay, so processor I then adds their signature to form a message with T plus one distinct signatures, and they send that to all processors.
00:37:40.842 - 00:37:41.134, Speaker B: Okay?
00:37:41.172 - 00:38:17.450, Speaker C: So that means all non faulty processors will recognize V by the next time slot. Okay, so that was a sort of easy case. You've recognized the value, but it's not too late to share that value with other people. So next we come to what might be the tricky case, right? It's when you learn about it, right at the end before it's when it's too late to tell other people about it. See what happens there. So suppose next that some non faulty process I first recognizes V at time F plus one when it's too late to share. So in that case, I receives a message relaying the value V at times F plus one, which has f plus one distinct signatures attached, right? Otherwise they wouldn't recognize the value at that time slot.
00:38:17.450 - 00:39:07.586, Speaker C: Okay, but if it's got f plus one distinct signatures attached, that means at least one of those signatures must be from a non faulty processor, because we've only got f many faulty processors at most, right? So at least one of those signatures is from a non faulty processor who's previously relayed the message. And that means, let's suppose it's signed by that non faulty processor is J. That means that case one applies with respect to J. So J has already seen the value at some previous time slot and has shared it, and now everybody knows about it anyway. I guess it's quite slick, that last little turn there. Okay, so that's the dole of strong protocol, I think. On the slides I wrote down a sort of formal version, but maybe it's not that useful to go through the formal version and we start a little bit late.
00:39:07.586 - 00:39:38.452, Speaker C: So I think I'll carry on. Okay, so in that protocol, we used f plus one rounds of communication. And in fact, in the original paper where dolevan Strong produced that protocol, they showed that F plus one rounds are necessary. Okay? Yeah. So it's clear you can't do something really trivial anyway. Okay, so that was our first theorem. So with PKI, you can basically do deal with any number of faulty processors.
00:39:38.452 - 00:39:52.430, Speaker C: The next very famous theorem is the following one. So consider the synchronous setting without PKI. So here, no protocol could solve by xantine cream or Byzantine broadcast when F is greater or equal to N over three.
00:39:53.440 - 00:39:53.804, Speaker B: Okay?
00:39:53.842 - 00:40:09.456, Speaker C: So again, this is originally due to Lamborghin piece, but the proof I'm going to talk you through here is a much nicer proof by Fisher, lynch and Merrit. And I'm going to present it in a way that's a little bit different than usual as well. So maybe if you have seen the proof before, maybe this will still be interesting.
00:40:09.558 - 00:40:10.210, Speaker B: Okay?
00:40:14.050 - 00:40:49.722, Speaker C: So again, we're solving it for Byzantine agreement, but that gives the result also for Byzantine broadcast because they're reducible to each other when F is less than N over two. Yeah, and I'm going through the official lynch merit version of the proof. Okay? So in order to give a nice proof where you understand exactly why, what elements of the proof are there, first of all, I'm going to sort of change our formal framework a little bit and then we'll change it back and we'll give a full proof for the full framework. But the proof will be nicer if you sort of go via modified version first.
00:40:49.776 - 00:40:50.380, Speaker B: Okay?
00:40:51.150 - 00:41:24.470, Speaker C: Okay, so according to our formal framework, the way we set things up, so each processor has a private communication channel to each of the processors and you know right at the start, like, which processor is at the end of each of those channels, right? So if I'm processor I and I've got a communication channel to J, then right at the start of the protocol execution, I know that J is at the end of that channel. Just briefly, though, to make things a little bit simpler, let's consider an alternative setup in which processors no longer begin with knowledge as to which processor is at the end of each of their channels.
00:41:24.890 - 00:41:25.302, Speaker B: Okay?
00:41:25.356 - 00:41:41.962, Speaker C: So we still have one channel for each of the processors, but now at the beginning, I don't know who is at the end of each. Okay, so there's a five processor execution if I'm one of the guys involved and I got four different channels and only one person can write something to me along each of them, but I just don't know who's at the end of each of those channels at the beginning.
00:41:42.026 - 00:41:42.640, Speaker B: Okay?
00:41:46.870 - 00:42:22.442, Speaker C: Okay. So in this situation, we can describe a simple proof by contradiction. The approach might seem a little bit OD at first. Because what we do is we suppose a working protocol exists. Then we deduce certain things about how the protocol must behave in scenarios other than the intended application, which might seem an OD sort of thing to do, but it works out because the analysis allows us to quickly deduce that actually there are sort of valid situations in which the protocol can't behave properly. So that sounds a little abstract. Okay, I'll make that concrete right now.
00:42:22.442 - 00:42:26.574, Speaker C: So let's start off with the case. N is three and F is one.
00:42:26.612 - 00:42:26.766, Speaker B: Okay?
00:42:26.788 - 00:43:02.550, Speaker C: So we've got considering three processes or a protocol for three processes where most one is faulty. Let's suppose we've got a working protocol. Let's do something a little crazy. Let's imagine let's consider what happens when four processors all execute the protocol for N is three and F is one. Let's suppose they all execute the protocol correctly, but they do it when we set up the communication channels in some OD fashion like that, okay? And I'll explain what this picture means. So each node here is a different processor. This is a processor zero.
00:43:02.550 - 00:43:09.050, Speaker C: This is the processor one, but this is a process one down here. This is the processor 10 prime and processor one prime.
00:43:09.630 - 00:43:10.380, Speaker B: Okay?
00:43:11.390 - 00:43:20.174, Speaker C: And we're going to suppose that if you're zero or zero prime, they're both told that the name is zero. Whether you're one or one prime, you're both told that your name is one.
00:43:20.292 - 00:43:20.574, Speaker B: Okay?
00:43:20.612 - 00:43:30.110, Speaker C: So we're thinking that we know they're different processes, but they don't. Okay? As far as they're concerned, they got the same name as each other. And the A and B's there, that's just their inputs.
00:43:30.270 - 00:43:30.642, Speaker B: Okay?
00:43:30.696 - 00:43:59.846, Speaker C: So process of zero has input A, process of one prime has input B, process of one has input A and so on. So is that clear? So this might seem like a sort of strange sort of setup, but it makes sense to consider it, right? You might not be immediately clear why you're considering it, but it makes sense to sort of set things up like this. Each processor has got a certain input at each stage. They're going to receive messages along each of their communication channels. The protocol tells them what messages to send. Okay? You can ask the question, so what happens then in this OD setup?
00:43:59.878 - 00:44:00.458, Speaker B: Right?
00:44:00.624 - 00:44:05.474, Speaker A: The assumption is that they're like just communicating in a ring. It's not a complete craft.
00:44:05.622 - 00:44:07.790, Speaker C: Yeah. So they're just communicating in a ring. Exactly.
00:44:07.860 - 00:44:08.142, Speaker B: Right.
00:44:08.196 - 00:44:22.930, Speaker C: So each of these guys, you can sort of think that they're kind of unaware what the main context is, right? They're just sitting there. I've got two communication channels. I'm just following the protocol. You send me some messages, I go through my instructions, that determines what I send out, and we just see what happens.
00:44:23.000 - 00:44:24.180, Speaker B: Right? Okay.
00:44:27.770 - 00:44:37.238, Speaker C: These are zero prime and one prime. But as far as they're concerned right? So if your processor I or I prime, they're told their name is I.
00:44:37.324 - 00:44:37.960, Speaker B: Okay?
00:44:38.810 - 00:45:01.034, Speaker C: And again, the A and A's and B's are just their inputs. Okay? So again so each process is just going to act entirely honestly here, okay? We're not going to deviate from the protocol at all and we're going to wonder what happens. As I say, this is not a configuration which the protocol is intended to operate, but we're going to analyze what happens here and it's going to allow us to do some contradictions to the idea that it's a valid protocol.
00:45:01.082 - 00:45:04.442, Speaker B: Okay? Okay.
00:45:04.516 - 00:45:34.620, Speaker C: So what can we say about how things will unfold here? Well, the first thing we can say is that processors zero and one here, they both have to output A. Why? Because this four processor execution is indistinguishable as far as they're concerned from the three processor execution in which so they're given the inputs A and there's a second processor, processor two over here is faulty and just simulates the process of zero prime and one prime here.
00:45:35.470 - 00:45:35.834, Speaker B: Okay?
00:45:35.872 - 00:45:46.350, Speaker C: So each stage process one prime sends to zero what process? Sorry. The simulating processor, processor two sends to zero what processor one prime sends in this four processor execution.
00:45:46.850 - 00:45:47.310, Speaker B: Right.
00:45:47.380 - 00:45:56.850, Speaker C: And the faulty processor, the one who's simulating these two guys here, he sends to processor one what processor zero prime sends in this four processor execution.
00:45:57.750 - 00:45:58.500, Speaker B: Okay?
00:46:00.310 - 00:46:13.186, Speaker C: And when I say that two executions are indistinguishable, I mean that with respect to from the perspective of a particular processor, that means they have the same input and they see exactly the same messages at each stage.
00:46:13.378 - 00:46:14.214, Speaker B: Right.
00:46:14.412 - 00:46:25.420, Speaker C: So this four processor execution is indistinguishable, as far as these two guys are concerned from a three processor execution in which the third processor is faulty and simulates these two here.
00:46:26.910 - 00:46:28.140, Speaker B: Happy with that?
00:46:28.670 - 00:46:34.720, Speaker C: Okay, so in that situation, all the non faulty processors have input A, so they have to terminate an output A.
00:46:40.680 - 00:46:41.044, Speaker B: Okay?
00:46:41.082 - 00:47:00.650, Speaker C: But then similarly, just by symmetry, so these two guys here, one prime and zero prime, they have to terminate an output B because this four processor execution is indistinguishable as far as they're concerned from a three processor execution in which the third node is faulty and dissimilarates these two processors here.
00:47:03.820 - 00:47:04.196, Speaker B: Okay?
00:47:04.238 - 00:47:43.704, Speaker C: So these two guys have to output B. So so far we've determined so these two guys have to output A, these two guys have to output B. Now we get to a contradiction because we've already determined that zero outputs A, one prime output outputs B. But now this full processor execution is indistinguishable as far as they're concerned from a three node execution in which these two guys are honest and this guy is faulty and simulates these two nodes here. But now we've got a problem because they've given different outputs. So we violated the agreement requirement. Yes, exactly.
00:47:43.704 - 00:48:16.072, Speaker C: My question when I saw the hexagon is why do you need a hexagon? So that's why I'm giving you the four node version first. Now you see why you need a hexagon. Okay, so we'll see that in a second. That's the right question. Okay, so we got our contradiction, but this was all in our modified setup where I suppose we begin the whole thing without knowing who's at the end of each channel. If we now go back to the full setup, try and do the same argument as a bit of a problem. Problem now is we have to be more careful about deciding how to treat each channel during the indistinguishability argument.
00:48:16.156 - 00:48:16.452, Speaker B: Okay?
00:48:16.506 - 00:49:02.688, Speaker C: So it's not really that deep, but okay, let's go through it. So let's consider first process of zero and one. So zero and one treat the channel between them as the channel zero one. And if each processor I and zero one treats the channel between I and one minus I prime as a channel I two. So if zero treats this as a channel zero two and one treats as a channel one two, then it is indistinguishable from this preprocessor execution in which the faulty process assimilates these two. So then in that situation you can conclude they both output A and then similarly if you reverse in I prime there they're both regarding this as the channel 10 and this guy regards as a channel one two. He regards this as the channel zero two.
00:49:02.688 - 00:49:23.476, Speaker C: Then again you can conclude that they must both out but B. But then you get into a problem in the final step of the argument, right? Because now the execution doesn't look indistinguishable from any valid execution as far as zero and one prime are concerned because we just said the zero has to treat this as a channel zero two and this and one prime has to treat this as the channel one two, which they never would.
00:49:23.578 - 00:49:23.892, Speaker B: Okay?
00:49:23.946 - 00:49:35.496, Speaker C: So it's just sort of like a rather silly problem really with the fact that you're given the wrong names or you have to assume the wrong names for people at the end of your channels. Okay, but then we can solve that quite easily by doing the hexagon.
00:49:35.528 - 00:49:35.676, Speaker B: Okay?
00:49:35.698 - 00:50:12.136, Speaker C: So if you've seen the proof before that's why the hexagon is there. I don't think it's very clear then when you read the original proof. Okay, so we solved that just by sticking two guys in the middle we call two and two prime, okay? Okay, so we introduced two and two prime. We suppose each processor with the name I or I prime is told their name is I. So two primes told their name is two, two is also told their name is two and they treat the channels just in the obvious way. So these two treat this is a channel zero two, these two treat this a channel one two and so on. Okay? So now you don't really have to think through all the tedious details you don't want.
00:50:12.136 - 00:51:00.596, Speaker C: Now basically the same argument works, okay? So now you conclude these two have to output A because this is indistinguishable, this six processor execution is now indistinguishable as far as they're concerned from a three processor execution in which one guy simulates these four. Similarly, these two here have to output B because this six processor execution is indistinguishable as far as they are concerned from a three processor execution from a three processor execution in which their faulty processor simulates all these four nodes over here. And again now you reach your contradiction because now you have two non faulty processors giving different outputs when that this six processor execution is indistinguishable from a three processor execution in which they shouldn't be giving different outputs. Okay, I guess don't worry too much about the details here. It's essentially the same as the four node thing, but now it works out with the names.
00:51:00.628 - 00:51:05.110, Speaker B: Okay, good.
00:51:05.180 - 00:51:36.566, Speaker C: Okay, where are we? Okay, so that was just for the case. N is three and F is one, but okay, basically that gives you the general case as well. Okay, so if you suppose there exists some N greater than three and F greater over to N over three for which the protocol works, well, then you could use that to get a working protocol. For N is three and F is one. Basically you just divide all the processes up into equal groups of equal size. So they're all of size at most F, and you have each of the three processors control like one of those sets of processes.
00:51:36.618 - 00:51:38.530, Speaker B: Okay. Yeah.
00:51:38.680 - 00:52:19.096, Speaker C: Okay, so the proof we went through was for a case N is three and F is one. But that immediately gives you the general case basically. Right, because if you had a protocol work for any other F and any other N and then the other F, but it was N over three, you could very easily use that to get a protocol that worked. For N is three and F equals one, which we've just shown is impossible. Okay, so where are we so far? So we're still in the synchronous setting. We saw if you have a PKI, you can deal with any number of faults. You have this sort of dole of strong type protocol we've seen consider the same thing without PKI.
00:52:19.096 - 00:52:31.728, Speaker C: So we know no protocol can solve BA or BB when F is greater than N over three. So obviously the next thing we want to do is show that okay, when F is less than N over three, you can okay, so that's what ties things up so far.
00:52:31.814 - 00:52:32.450, Speaker B: Right?
00:52:32.820 - 00:52:41.636, Speaker C: Okay, so we're considering the synchronous setting without PKI. We want a protocol that works when F is less than N over three.
00:52:41.818 - 00:52:42.550, Speaker B: Okay.
00:52:46.520 - 00:53:26.304, Speaker C: So again, it suffices to prove theorem for Byzantine agreement. I'll give us the same the result for Byzantine broadcast. So theorem was originally proved by Lamport, Shostek and Peace, but I don't think that initial proof is that sort of informative. So what I'm going to do instead is give a more instructive proof by Berman, Garay and Perry, or adjustment of that, which is known as the Phase gain protocol. Okay, so yeah, I guess this protocol is probably the most complicated one I'm going to talk through today or Thursday. So I don't know if the previous boost for easy or hard anyway, you have to maybe concentrate a little bit to follow this one, but I don't think it should be too hard anyway.
00:53:26.342 - 00:53:26.930, Speaker B: Okay.
00:53:31.620 - 00:54:11.550, Speaker C: So I'm going to describe a protocol called the Phase King Protocol. It's going to show us how to, how to solve bizarre agreement when F is less than N over three. First of all though, I'm going to explain the main protocol. I'm going to show you. First of all, like a simple two step subprrotocol which is called gradecast, okay? So with gradecast, just as for Byzantine agreement, each processor receives an input. And now they have to give an output just as they did before. But now they also have to output a grade together with that value, a grade either zero, one or two.
00:54:12.800 - 00:54:13.550, Speaker B: Okay?
00:54:14.800 - 00:54:41.700, Speaker C: And the grade is going to indicate something about the knowledge the processor has regarding other processors outputs, okay? Okay, so it's a very simple protocol. So what I'm going to do, basically, I'm going to throw it at you and then we'll start talking about what it achieves. Okay? So step one. So this is the instructions for processor i. So processor I has their input V. Their first instruction, step one is just send V to all processors.
00:54:43.400 - 00:54:44.470, Speaker B: Simple enough.
00:54:45.080 - 00:54:57.560, Speaker C: Step two. So if N minus F distinct processors sent B to I, right to I here in step one, then I will send B to all processors.
00:55:00.500 - 00:55:00.864, Speaker B: Okay?
00:55:00.902 - 00:55:20.392, Speaker C: So first step, you send your value out. Next step, you're waiting to see if there's some value that lots of people sent me. In fact, if it's N minus F, then I'll send out that value in the next step. Yeah, hopefully it's clear why we consider N minus F here. If you ask for anything more than that, then, well, the faulty processors can just not do anything and you won't send anything.
00:55:20.526 - 00:55:21.210, Speaker B: Okay?
00:55:22.380 - 00:55:28.792, Speaker C: So first of all, you're sending V to all processors. And then step two, if N minus F distinct processes, send B and step one, then you send B to all processes.
00:55:28.856 - 00:55:29.470, Speaker B: Okay.
00:55:31.680 - 00:55:56.150, Speaker C: So so far I guess it might not be immediately clear exactly why that step two is there, but we'll see why. Okay, so that's the end of basically the protocol. But now we have to decide how to output. Okay, so we output as follows. So if N minus F distinct parties sent B to I, that is in round two, that should say step two. There's a typo in step two. Then you output B with grade two.
00:55:59.370 - 00:55:59.734, Speaker B: Okay?
00:55:59.772 - 00:56:11.980, Speaker C: So if N minus F distinct party sent B in round two in step two, then output B with grade two. Otherwise, if that's not the case, if F plus one distinct party sent B in step two, then output B with grade one.
00:56:13.870 - 00:56:14.426, Speaker B: Okay?
00:56:14.528 - 00:56:35.746, Speaker C: And otherwise output B with grade zero. So I realize it might seem a little initially a bit mysterious what these grades meaning and stuff, but we're going to sort of talk through what it means, okay? It will be quite simple. Okay? So that's the whole protocol. Hopefully you agree that it's quite a simple protocol. This is the sub protocol, right? Great card. Okay, but then we don't yet understand what that does or what is defined. The way it is, but let's think about it.
00:56:35.746 - 00:56:43.022, Speaker C: Okay, so there's the protocol. Just put up the top of the screen, okay. So let's examine its properties.
00:56:43.086 - 00:56:43.266, Speaker B: Okay.
00:56:43.288 - 00:57:31.854, Speaker C: So first of all, it's easy to see it satisfies a certain form of validity, right? So if all non faulty processors have the same input value V, then they're going to all going to output V with grade two. That's easy to see, right? Because what will happen is, well, they all start off with value V, so they all send V to all the other processors, right? That means that in step two, every processor gets at least N minus F distinct processor, sending it that value. So they could send the value again at step two. So then when they come to output again, each of them will receive that same value from at least N minus F distinct processors. So you can just follow it through, right? So they all start with a particular value. They'll send that out. That means they'll receive it from at least N minus F distinct processes.
00:57:31.854 - 00:57:33.480, Speaker C: Next steps, they'll send it out again.
00:57:33.850 - 00:57:36.950, Speaker B: Okay, happy with that.
00:57:37.020 - 00:57:39.590, Speaker C: And then ultimately then they'll all output with grade two.
00:57:39.740 - 00:57:40.440, Speaker B: Okay.
00:57:42.250 - 00:57:44.630, Speaker C: So hopefully you agree. That's a simple observation.
00:57:44.710 - 00:57:45.820, Speaker B: Yeah. Okay.
00:57:47.870 - 00:57:54.170, Speaker C: Next observation is that outputting V with grade two also implies knowledge about the outputs of other processes.
00:57:55.390 - 00:57:56.140, Speaker B: Okay?
00:57:56.510 - 00:58:35.480, Speaker C: Right. So that's true because the following condition is satisfied and we'll prove that in a bit. But I'm just going to tell you first of what's satisfied. So we have this knowledge of agreement property. So if any non faulty processor outputs a value B with grade two, then in fact all non faulty processors have to output B, maybe with some other grade, right? But if any non faulty processor outputs a value B with grade two, then all non faulty processors have to output B, in fact with grade two or one. Okay, so what that means is, so if a non faulty processor outputs B is grade two, then it knows that all non faulty processors are output B.
00:58:36.570 - 00:58:36.934, Speaker B: Okay?
00:58:36.972 - 00:58:51.310, Speaker C: And this is a useful sort of knowledge, right? As we're trying to get to agree with each other. We're not quite sure where other people are in the process and so on. But here we know. So a non faulty process outputs B with grade two. After this really simple two step protocol, then we know that all non faulty processes have that same output.
00:58:52.210 - 00:58:52.960, Speaker B: Yeah.
00:58:54.290 - 00:58:58.750, Speaker C: We know that if they all start with the same input, then they will output with grade two as well, right?
00:58:58.900 - 00:58:59.600, Speaker B: Okay.
00:59:00.290 - 00:59:09.074, Speaker C: So so far we've got a simple process protocol means everybody starts with the same input, they're all going to output end with that same value, and they'll all know that they have the same value at the end.
00:59:09.112 - 00:59:09.700, Speaker B: Yeah.
00:59:10.710 - 00:59:41.720, Speaker C: Okay, so next, what we want to do then is we want to prove this knowledge of agreement property. So I've just written it up there. Okay? So we want to approve knowledge agreement. It's a very simple proof. We just do it in two very small steps, okay? So first of all, we're going to prove a weak agreement property, okay? So here it is. So if I is non faulty and sends B in step two, then no non faulty processor sends a different value than B.
00:59:43.210 - 00:59:43.622, Speaker B: Okay?
00:59:43.676 - 01:00:28.770, Speaker C: So if B is non faulty and sends so if I is non faulty and sends a value B in step two there, then nobody who's non faulty sends a different value. So already we've got quite a strong form of agreement there, right? So it's not necessarily the case that they're all completely agreeing because some people might be sending a value and some people not. But if any non faulty processor sends the value B even at that step two, then nobody can send a different value. Why is that? Well, it's just a sort of counting argument, right? It's just because F is left and N over three here, the faulty guys can't Google cause too much trouble. Okay, so let's say it. So it can't be the case that one non faulty processor as sent B by N minus F processors in step one and therefore sent B in step two, while another ascent B prime not equal to B by N minus F processors, right?
01:00:28.920 - 01:00:29.234, Speaker B: Why?
01:00:29.272 - 01:01:02.222, Speaker C: Because any two sets of n minus processors, n minus F processors have to have at least n minus two F in the intersection. Hope you can see that if I've got two sets of N minus F processors, the size of the intersection is at least N minus two F, right? Maybe some picture, picture that in your head. Okay, so any two sets of N minus F processors have to have at least N minus two F in the intersection, but N minus two F is greater equal to F plus one because we're considering the case f is less than N over three.
01:01:02.356 - 01:01:02.654, Speaker B: Okay?
01:01:02.692 - 01:01:26.440, Speaker C: So that means any two sets of N minus F processors have to have F plus one processor in the intersection and that means at least one non faulty processor in the intersection because we've only got F faulty processors, okay? So any two sets of N minus F processors have to have a non faulty processor in the intersection. But non faulty processors can't send two different values in step one. They're not going to send a single value.
01:01:28.250 - 01:01:29.000, Speaker B: Okay?
01:01:30.250 - 01:01:49.178, Speaker C: So that means if any non faulty processor sends B out here because they got N minus F, they got sent B by N minus F distinct processes in the first step, then no other non faulty process can send a different B out, right? So they kind of seen that B prime not equal to B sent to them by N minus F distinct processes.
01:01:49.354 - 01:01:49.982, Speaker B: Okay?
01:01:50.116 - 01:02:13.560, Speaker C: So that's weak agreement. And then once you've got weak agreement, you can easily prove knowledge of agreement. So let's prove knowledge agreement. So if a non faulty processor outputs B with grade two, then it sent B by at least N minus F processors in step two. That's what the instructions say. Okay, if it outputs B with grade two, then it sent B by at least N minus F processors in step two. That's the instructions here.
01:02:13.560 - 01:02:51.650, Speaker C: Okay, but if he sent it by at least N minus F processors, that means all non faulty processes sent B by at least N minus two F processes because it's only that the faulty ones that can be doing making things different. So they'd all send it by at least N minus two F. So grade one F plus one process in step two. So that means that anyway they're then anyway outputting B. Okay, just to make sure things are well defined here and that you can't be outputting multiple B with grade one. Note that from the weak agreement property, no non faulty processes can be sent B prime not equal B by F plus one distinct process in step two. Okay, so that's just saying you could only output one value with one grade here.
01:02:51.720 - 01:02:52.340, Speaker B: Okay.
01:02:54.070 - 01:03:06.520, Speaker C: So the point of that is we've got this simple protocol and it sanitizes this nice knowledge agreement property which says if any non faulty processor outputs a value B with grade two, then all non faulty processors output B.
01:03:07.050 - 01:03:07.800, Speaker B: Okay.
01:03:11.370 - 01:03:31.034, Speaker C: So where's that got us so far? Okay, so so far, yeah, we got a simple protocol. If all non 40 processors start with the same input, then it produces a nice situation, which they all know that that was the case, they'd all end up with that same value. But now they all know that's the case, right? That's the point of the knowledge agreement property. So what we haven't achieved yet though is any method for tiebreaking.
01:03:31.082 - 01:03:31.246, Speaker B: Okay?
01:03:31.268 - 01:03:36.830, Speaker C: So everybody just starts off with mixed inputs. We've got no particular way yet of getting to agree on some common output.
01:03:36.910 - 01:03:40.162, Speaker B: Okay, so how can we do that?
01:03:40.216 - 01:03:42.030, Speaker C: Well, we just use a really simple method.
01:03:42.110 - 01:03:42.402, Speaker B: Okay?
01:03:42.456 - 01:03:52.230, Speaker C: So what we're going to do is we're going to run F plus one many rounds, each of which has got a different leader.
01:03:54.170 - 01:03:55.014, Speaker B: Okay?
01:03:55.212 - 01:04:02.714, Speaker C: So processes start each round with a certain value. Initially that's just their input value, but they're going to constantly update their value as these rounds go on.
01:04:02.832 - 01:04:03.500, Speaker B: Okay.
01:04:05.310 - 01:04:34.546, Speaker C: Each round will just start with an instance of gradecast, the simple two step protocol we just saw. They'll just carry out gradecast. So what they'll do is they'll just in each round go F plus one rounds. In each round they'll just carry out great cast, they'll update their value to the output of great cast. And then after gradecast leader just shares their value, basically inviting everyone to agree with their value. Okay, so the leader just shares their value. The idea being that they're inviting people to update their value to the leader's value.
01:04:34.546 - 01:05:02.620, Speaker C: So everyone now agrees. So each non faulty processor now changes their value to that value suggested by the leader, unless they're like really sure they shouldn't. Unless the output of the gradecast instance for that round is grade two. Okay, so just F plus one rounds, each one's very simple. You just do gradecast update. Your value leader shares this value. Maybe you update to either update to that or you do update to that unless you're really sure you shouldn't because you output a gradecast with value too.
01:05:02.620 - 01:05:33.734, Speaker C: Let's see then if we proceed in that way. First of all, so it's easy to see that validity is going to be satisfied. Imagine everyone starts off with the same value. What will happen is when you run gradecast, they all end up with that same value and the grade two, right? That's what we decided before. Which means they just ignore the leader all the time, right? You only update your value to the leader's value if you didn't output gradecast with grade two. Okay, so it all starts with the same value. You run gradecast, you end up the same value of grade two.
01:05:33.734 - 01:05:42.360, Speaker C: You ignore the leader, take that value into the next round. You do gradecast you same value, ignore the leader, take that value into next round and so on, right? So no one ever changes their value.
01:05:43.210 - 01:05:43.670, Speaker B: Okay?
01:05:43.740 - 01:05:46.630, Speaker C: So it's clear that validity is going to be satisfied.
01:05:47.610 - 01:05:48.360, Speaker B: Okay?
01:05:50.330 - 01:06:16.660, Speaker C: So what we need here, we need termination, which is automatic because it's a finite protocol. Then we're going to terminate. We need validity, which I just said is really easy because if they all start with the same value, they're never going to change it. But we also need agreement, right? That's the last thing we need. So let's see why agreement is satisfied. So it's also to see that after any round with a non faulty leader and then all subsequent rounds, all non faulty processes are going to have the same value. As soon as the leader is non faulty, they're going to end up the same value.
01:06:17.030 - 01:06:17.538, Speaker B: Why?
01:06:17.624 - 01:06:52.046, Speaker C: Well, if a non faulty process doesn't change their value to the value suggested by the leader, why is that? That's because they outputted the gradecast incident with grade two. Right, but then the knowledge of agreement property says that the leader then must anyway have the same value if you output it with grade two. All non faulty processors also outputted with that same value, maybe not the same grade. So if there's any non faulty processor doesn't update to the leader's value when it's suggested, well then they didn't need to update anyway because it's the same value.
01:06:52.228 - 01:06:52.960, Speaker B: Yeah.
01:06:56.610 - 01:07:46.510, Speaker C: Okay, so just to remind you the knowledge agreement property. So if any non faulty processor you can't see the edge there, outputs a value with grade two in the gray size instance, then all non faulty processors output B, right? So that's justifying that bit there okay, so let's just sort of write pseudocode version of the protocol down then. Okay, so this is the instructions for processor I. So first of all they're setting an initial value which is just their input, okay? Then we're going to do like F plus one round. So from T equals zero to F plus one round in each round. In the first two time slots you just run an instance of gradecast. In the next time slots you just update your value to the output of the gradecast and then if you're the leader so if you're in the teeth round and if your name is T, then you send your value to all processors.
01:07:46.510 - 01:07:55.540, Speaker C: And the next time slot everybody just updates their value to the leader's value unless they output a grade. Start with grade T with grade two.
01:07:57.670 - 01:07:58.420, Speaker B: Okay?
01:07:59.510 - 01:08:00.962, Speaker C: At the end you just output your value.
01:08:01.016 - 01:08:01.186, Speaker B: Okay?
01:08:01.208 - 01:08:28.062, Speaker C: And as I said, so validity and proof of agreement. Well we've both seen these base, right? So validity follows from the validity property of grade casts and the fact that each round the grade will be two, meaning the leader's value is ignored. So you can just see an inductive process. Everybody starts in the same value of one grade, cost that output, that same value, they ignore the leader, feed that value into the next round and so on. So validity is satisfied. Proof of agreement. That's true because you just consider the first round with a non faulty leader and the knowledge of agreement property.
01:08:28.062 - 01:09:04.640, Speaker C: All non faulty processes have either switched to leader's value or already had that value with grade two. Okay, so we're basically the end of today's talk then. So summary of where we are so far. So Byzantine agreement and Byzantine broadcast, so they're not the same problem. But if you're in the synchronous setting then they're equivalent to each other as long as F is less than N over two. The first theorem we saw. So if you consider the synchronous setting with PKI, then there exists this nice protocol, do live Strong, that solves by Xentine broadcast for any number of faulty processors.
01:09:04.640 - 01:09:39.776, Speaker C: Then we consider the synchronous setting without PKI. So this is like two of theorems we saw combined, right? So there exist protocol solving byzantine agreement and Byzantine broadcast even only if F is less than N over three. Okay, so what we're going to do next time is consider state machine replication. That's basically the protocol that blockchains protocol normally solve, like protocols like bitcoin solve. I don't think we'll actually look at crash faults but then we'll all do the same. We'll do some similar questions for the partially synchronous setting. Basically I'm going to sort of simplify things a bit.
01:09:39.776 - 01:09:44.224, Speaker C: Basically what I'm going to do is I'm going to show you how tender mint works and that will sort of solve everything for us.
01:09:44.262 - 01:09:44.512, Speaker B: Okay?
01:09:44.566 - 01:09:52.300, Speaker C: Tendermint. I think it's actually a simpler protocol than that face game protocol. Okay, so I guess we'll do that all next time. So that's.
