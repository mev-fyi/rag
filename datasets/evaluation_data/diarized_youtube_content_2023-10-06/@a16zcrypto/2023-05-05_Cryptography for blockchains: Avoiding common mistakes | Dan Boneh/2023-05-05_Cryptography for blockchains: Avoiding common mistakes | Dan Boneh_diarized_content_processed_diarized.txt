00:00:13.930 - 00:00:30.518, Speaker A: All right. Thank you, Jeff. It's wonderful to be here. It's wonderful to see all the teams. I'm really, really excited and looking forward to seeing what comes out of what you're building. So welcome all and let's get get started. So I guess I should say also, by the way, thank you to a 16 Z for hosting this wonderful event.
00:00:30.518 - 00:01:01.514, Speaker A: So let's get started. So I guess when people ask me what I work on, I typically say that I work on the science of blockchains. Yeah, so there's blockchains and then there's the science of blockchains. The science of blockchains is basically the underlying technology that makes blockchains work. And it's amazing how much technology is needed to make blockchains work. And in fact, the world of blockchains is dramatically pushing forward different tiers of science and much of the rest of society can benefit from that as well. So I primarily am a cryptographer.
00:01:01.514 - 00:01:46.746, Speaker A: Yeah, I work on cryptography, cryptography for blockchains. And in fact, as you might have heard, there is a lot of cryptography used in the world of blockchains. Yeah, so just to give you a few examples, blockchains use a lot of data integrity mechanisms like digital signatures, commitment schemes, proof systems. And so that's all kind of about data integrity. What's interesting is also in kind of the recent year or so, it turns out, there's also a need for other types of cryptography and blockchains primarily having to do with privacy and security. These are things like zero knowledge proof systems. It turns out even fancy encryption schemes now come up in the world of blockchains specifically to address some mev proposals.
00:01:46.746 - 00:02:12.786, Speaker A: And I think I'll talk about that towards the end of the lecture. It's really, really quite fascinating what's happening in the mev space. It's really dragging in a lot of very fancy encryption schemes into the blockchain space. And that's going to have a lot of implications on what's happening in blockchains and beyond. And then there's also applications for multi party computation. What's interesting is that traditionally cryptography had a primary customer. The customer was the Internet.
00:02:12.898 - 00:02:13.222, Speaker B: Yeah.
00:02:13.276 - 00:02:49.982, Speaker A: So we want to make sure that as you type in your credit card and you send it to Amazon, that credit card gets to Amazon in a secure way. That type of cryptography primarily focuses on confidentiality, making sure that attackers can't look at your data and so on. So that was one type of crypto in the blockchain space. As I say here, most of the cryptography that's been used up until now focuses on integrity, not so much on confidentiality, because on a blockchain, as you know, whatever you post, at least on ethereum, things are kind of public for the world to see. So it's kind of interesting that it uses a different type of crypto. That's what's used in the internet. Although as I say, in the bottom, this is kind of changing.
00:02:49.982 - 00:02:56.046, Speaker A: Now even confidentiality is becoming important in the world of blockchains, and we'll talk about that towards the end of the lecture.
00:02:56.158 - 00:02:56.754, Speaker B: Okay, great.
00:02:56.792 - 00:03:09.186, Speaker A: Lots of crypto used in the world of blockchains. The problem is you have to know what you're doing. Right. If you try to implement cryptography, is one of these things that's like an area where a little bit of knowledge is really quite dangerous.
00:03:09.298 - 00:03:09.718, Speaker B: Yeah.
00:03:09.804 - 00:03:17.238, Speaker A: If you just know roughly how things work and you kind of try to throw things together, very likely the system will work, but it will be insecure.
00:03:17.334 - 00:03:17.594, Speaker B: Yeah.
00:03:17.632 - 00:03:43.934, Speaker A: This is a very important thing to remember. It's easy to get systems to work so that they'll do what they're supposed to do, but they'll be insecure, and you'll never know it until somebody else points it out for you. So in that sense, it's an area where it's really important to know to use cryptography correctly. If you use it incorrectly, you end up with a bunch of hacks. And that's actually what I want to talk about today, basically, how to use cryptography correctly in the world of blockchains. So I'm going to start with signatures.
00:03:43.982 - 00:03:44.146, Speaker B: Yeah.
00:03:44.168 - 00:03:57.862, Speaker A: So signatures are kind of the bread and butter of blockchains, and since this is week two, day two, week one of the school, I wanted to kind of start from zero.
00:03:57.916 - 00:03:58.086, Speaker B: Yeah.
00:03:58.108 - 00:04:08.826, Speaker A: So let me assume you guys don't haven't heard of signatures. Let's start from the beginning. We will walk through it quickly just to bring everybody up to speed. So in the physical world, we know what a signature is.
00:04:08.848 - 00:04:08.986, Speaker B: Right.
00:04:09.008 - 00:04:17.342, Speaker A: When you sign a check, you just sign your name on the check, and that binds you to the check. The problem is that in the digital world, this can't possibly work.
00:04:17.396 - 00:04:17.614, Speaker B: Right.
00:04:17.652 - 00:04:58.470, Speaker A: In the digital world, if you just attached a picture of your signature to a document, anyone can just take that picture and stick it on a different document that maybe binds you to a much larger check and so on. So we have to do something different if we're going to implement signatures in the digital world. They fundamentally have to be different from signatures in the real world, in the physical world. So the solution is what? The solution is to make it so that the signature on a document actually depends on the contents of the documents. Every time I sign a document, there's a different signature attached to each document that I sign. So that's how digital signatures work in the physical world? In the digital world, yeah. So a signature depends on the contents of the document.
00:04:58.470 - 00:05:05.918, Speaker A: And so let's dive a little bit more deeply and see what the syntax of a digital signature is. And so there are three algorithms in a signature system.
00:05:06.004 - 00:05:06.254, Speaker B: Yeah.
00:05:06.292 - 00:05:12.542, Speaker A: There's a key generation algorithm. What the key generation algorithm does is it generates what we call a secret key and a public key.
00:05:12.596 - 00:05:12.766, Speaker B: Right.
00:05:12.788 - 00:05:47.878, Speaker A: The secret key is used to sign messages. The public key is used to verify signatures. Then there's a signing algorithm that uses the secret key to sign a particular message and it outputs a signature. And then there's a verify algorithm that takes the public key, the message, and a signature and says, yes, this is a valid signature, or no, this is an invalid signature. Yeah, that's kind of the syntax for a digital signature scheme. I hope many of you have seen it before. One thing that I want to stress is when we talk about cryptographic primitives, it's important to talk about what the API is, which is what I showed you here, but it's more important to talk about what does it mean for the primitive to be secure?
00:05:47.974 - 00:05:48.474, Speaker B: Yes.
00:05:48.592 - 00:06:26.070, Speaker A: I always want you to think about security for these primitives. And so what does it mean for a digital signature scheme to be secure? Well, there's a formal model that explains what security means. I didn't want to bore you with, like, formal definitions in cryptography, so I just wrote things in English, plain English. So what does it mean for a signature scheme to be secure? It means that an adversary who gets to see many, many signatures on messages of their choice, of course, the adversary also gets the public key. So public key plus many signatures of messages of their choice can't produce a signature for some new message. Yeah, that's what we call existential unforgivability. Yeah, the word is existential unforgivility.
00:06:26.070 - 00:06:49.230, Speaker A: I can give you as many signatures as you want for any messages that you want. You will never be able to sign another message. That's the security property for a signature scheme. Terrific. Okay, so now we know what a signature scheme is. I was actually going to tell you a little bit about how to future proof the signing key and to protect yourselves from potential future quantum attacks. But I think in the interest of time, maybe I'll skip over this and we'll come back to this.
00:06:49.230 - 00:07:21.478, Speaker A: If you guys are interested in protection against quantum attacks, we'll come back to this at the end of the lecture. So I'll skip this for now and let's talk about other ways to protect the signing key. Okay, so how do we protect the signature key? The signature key is really crucial for us, right? This is how we sign transactions. If somebody steals your secret key, they're basically, you right, they can steal all the assets from your wallets. They can issue transactions on your behalf. And unfortunately, these things really do happen in the real world. So how do we protect the signing key? Again, I'm going to start slow and then we'll build up from there.
00:07:21.478 - 00:07:41.454, Speaker A: I hope many of you have heard of what's called threshold cryptography threshold signatures, but let's walk slowly and see what these things are. So this is a way to protect a signing key. How do we protect it? We protect it basically by splitting it up into pieces. Okay, so here's an example of splitting up a key in a two out of three way.
00:07:41.492 - 00:07:41.646, Speaker B: Yeah.
00:07:41.668 - 00:08:02.726, Speaker A: So basically, let's see. So we'll have a key generation procedure here. I'll show it to you again. We have a key generation procedure that will generate three secret keys SK One, SK two and SK Three. And three different parties will have those secret keys. And these keys are set up in such a way that when somebody wants to sign a message, they can send the message to these three parties. So they all get to see the message.
00:08:02.726 - 00:08:27.050, Speaker A: And then maybe, I don't know, maybe two of them decide to respond. So they check some policy that the message is valid. This is a valid transaction. The user is authorized to request signatures on such messages. And then let's say two of them respond with what we call signature shares. I couldn't resist using some Greek letters in this talk. So we'll use Sigma One and Sigma Two for the signature shares.
00:08:27.050 - 00:09:07.002, Speaker A: Yeah, so they respond with these shares. And then there's another party called a combiner that takes the signature shares, combines them together into the actual signature that you can publish to the world, and anyone can verify that signature using the public key. Yeah, so that's basically kind of how a threshold signature works. Again, I imagine many of you have seen it before. By the way, the reason I'm showing you this is one of the points that I want to make is that, again, there's a lot of cryptography used in blockchains. I know a lot of people when they talk about cryptography and blockchains now they hone in on zero knowledge proofs, which is a big tool in blockchains. And we're going to talk about zero knowledge proofs in week three, I think.
00:09:07.002 - 00:09:27.746, Speaker A: Yeah, so there's a whole week devoted to the topic. But I want to stress that there's a lot more to cryptography than just zero knowledge proofs. And everything has to work correctly. It's not just enough to get your proof system to work correctly. Good. So let's continue our story with threshold signatures. So that's what they are, right? So we can generate these signatures in a threshold way.
00:09:27.746 - 00:10:08.558, Speaker A: And there are a couple of applications for this. Yeah, so the two applications that come to mind are, one, as we said, it's a way to protect a secret key. So, for example, you can take your secret key, break it up into three shares, store the shares on different machines. Maybe some of the shares are stored in a safe that's offline. But you can split your key in this way. The point is, if the adversary breaks into just one of the shares and steals one of the shares, he does not get your secret key. What's interesting about this application is if you take your secret key and split it up, let's say, into nine shares, where five are needed to generate a signature, if you're doing it to protect the secret key, maybe you want to hide, actually what the Threshold is.
00:10:08.644 - 00:10:08.894, Speaker B: Yeah.
00:10:08.932 - 00:10:25.314, Speaker A: So the attacker maybe can compromise the attacker can compromise less than T shares, and he's not going to be able to generate false signatures on your behalf, but maybe you want to even make it so the attacker doesn't even know what the threshold is in that case.
00:10:25.352 - 00:10:25.506, Speaker B: Right?
00:10:25.528 - 00:10:35.810, Speaker A: So if you do a five out of nine scheme, ideally you want to hide the fact that you're using five out of nine. So the attacker, the poor attacker, doesn't even know that they're supposed to steal five shares.
00:10:35.890 - 00:10:36.134, Speaker B: Right?
00:10:36.172 - 00:11:07.646, Speaker A: So we'll talk about how to do that in just a second. So that's one application, basically, to make sure that the key is protected. And the attacker doesn't even know how many shares they need to steal. The other application, of course, is when we want consensus. For example, in a bridge, the bridge might author if it's a mint and burn bridge, the bridge might need to have a coalition of parties sign and approve minting or approve burning of assets, in which case we would use Threshold signatures to indicate agreement.
00:11:07.758 - 00:11:08.034, Speaker B: Right?
00:11:08.072 - 00:11:17.614, Speaker A: So if five out of the nine trustees share sign, that means oh, five out of the nine trustees agree that this is a valid operation, and then the operation can go forward.
00:11:17.672 - 00:11:17.846, Speaker B: Yeah.
00:11:17.868 - 00:11:38.530, Speaker A: So there are two applications for Threshold signatures one to protect keys, and the other one to indicate agreement, indicate consensus that an operation is supposed to happen. And again, I stress that these are very different applications for Threshold signatures. And in fact, it turns out this is important to remember. In fact, for these two applications, we need to use different types of Threshold signatures.
00:11:38.610 - 00:11:38.854, Speaker B: Yeah.
00:11:38.892 - 00:12:07.438, Speaker A: So I want you, again, when use Threshold signatures, I want you to think, why are we using them? Are we using them for consensus or are we using them for protection of the key? And let me explain what I mean by that. What I mean by that. Okay, so before I explain what I mean by that, I guess I have to go through the API of Threshold signatures. So let's do that very quickly. What does it mean? What is a threshold signature? What's the syntax? And then we'll come back and see what the differences are between protection and consensus. So what's the syntax? Well, let's see. So there's again a key generation algorithm.
00:12:07.438 - 00:12:33.870, Speaker A: But now the key generation algorithm is a little bit different, right? The key generation algorithm will generate a public key. Here, let me use my magical stick here. So the key generation algorithm will generate a public key, and then it will generate N shares if we want to generate shares for N parties. So in the five out of nine case, we'll generate nine secret keys and we'll give one secret key to each party. Then there's a signing algorithm. The signing algorithm is something that each party runs on its own.
00:12:33.940 - 00:12:34.174, Speaker B: Yeah.
00:12:34.212 - 00:12:43.562, Speaker A: So it'll take one of the secret keys, one of the nine secret keys, the message, and potentially the set that's actually generating a signature. This is called a quorum.
00:12:43.626 - 00:12:43.806, Speaker B: Right?
00:12:43.828 - 00:13:01.890, Speaker A: So the quorum of five out of the nine that's generating the signature, and it'll generate what's called a signature share sigma sub I. Then there's a combined algorithm that will take all the signature shares that have been generated by the quorum. And if the quorum contains more than the threshold number of parties, it will generate the actual signature.
00:13:01.970 - 00:13:02.166, Speaker B: Yeah.
00:13:02.188 - 00:13:34.730, Speaker A: So if you have fewer than the threshold number of parties, sorry, you cannot generate a signature. But if I give you enough shares, then the signature becomes you can generate that signature. In fact, anyone can generate the signature just using the public key. And, of course, finally, there's a verify algorithm that checks that the signature is valid. Does this make sense to everyone? So, yeah, this is kind of the standard API for a digital signature system. And again, as I said, it's more important to understand what the API is. It's more important to state what is the security property for a threshold signature scheme.
00:13:34.730 - 00:13:53.554, Speaker A: So here, security is a little bit harder to state. So again, I'm going to state it just informally. Let me try to explain what the security property is. The security property basically says if the adversary is given the public key and somehow by magic, the adversary was able to recover up to T minus one secret keys.
00:13:53.602 - 00:13:53.814, Speaker B: Yes.
00:13:53.852 - 00:14:39.522, Speaker A: In the case of five out of nine, maybe the adversary was able to recover three of the secret keys. Literally, by breaking into three machines, the adversary was able to recover three secret keys. That's not enough for the adversary to fake to forge signatures. Yeah, he needs five shares to forge signatures, but we also give him the ability to go to any party that he wants and say, hey, Mr. Bob, give me a signature share on this particular message. So we give the adversary some shares and we give some secret key shares, and we allow the adversary to ask individual parties to sign messages on his behalf. And the adversary, even though he has all this power, he shouldn't be able to produce a signature on any message for which he has less than T shares.
00:14:39.522 - 00:14:51.994, Speaker A: Yeah, that's the requirement. So unless he gets T signature shares for a particular message, he can't actually produce a valid signature on a new message that he wants.
00:14:52.032 - 00:14:52.186, Speaker B: Yeah.
00:14:52.208 - 00:15:16.586, Speaker A: So that's kind of informally what the security property is. And it turns out, actually, we can build threshold signature schemes that are quite efficient and pay attention because there's a quiz coming. So I'm going to ask you the quiz in just a second. So let's go back to the two types of threshold signatures that I wanted to tell you about. So, again, when you try to use threshold signatures yourself, I'm sure you're going to be using them in your projects.
00:15:16.618 - 00:15:16.814, Speaker B: Yeah.
00:15:16.852 - 00:15:33.442, Speaker A: These are so inherent now to blockchains. I'm sure you're going to be using Threshold signatures in your project. And so I want to, again, kind of organize this in your mind that there are really two families of Threshold signatures and they're really quite unrelated to one another. The first one is what we call Accountable Threshold signatures. ATS?
00:15:33.506 - 00:15:33.782, Speaker B: Yes.
00:15:33.836 - 00:16:13.986, Speaker A: The word is ATS. Accountable threshold signatures. This is what you use when you want to use Threshold signatures for consensus in an ATS settings. You want to make sure that if a certain quorum signs a message, the signature that they produce should identify the quorum that generated that signature. Specifically, in the five out of nine case, if these five people agreed to sign a message that caused the Bridge to release some funds, we want the signature that they generated to identify those five so that if they incorrectly sign the message, they are accountable. We can go and blame them, we can slash them, we can do all sorts of things to them.
00:16:14.008 - 00:16:14.146, Speaker B: Yeah.
00:16:14.168 - 00:16:27.634, Speaker A: We can kick them out of the system and so on. So this is called an Accountable Threshold signature. And the security property means that if another set of five signs a message, they cannot generate a signature that looks like a different set of five generated that signature.
00:16:27.762 - 00:16:28.150, Speaker B: Yeah.
00:16:28.220 - 00:16:55.674, Speaker A: So when I look at the signature, I should be able to verifiably know which set of five parties generated that signature. So if something went wrong, they are held accountable. So that's what we call an Accountable Threshold signature. That's one type. The other type is what we call a private Threshold signatures, a Pts, a private Threshold signature. This is what's used when you want to protect a secret key by splitting it up. So in a private Threshold signatures, we want the exact opposite.
00:16:55.674 - 00:17:02.686, Speaker A: The signature should reveal nothing about the quorum that generated it, and more importantly, the signature should reveal nothing about the Threshold.
00:17:02.798 - 00:17:03.266, Speaker B: Yeah.
00:17:03.368 - 00:17:36.218, Speaker A: Remember, in the five out of nine case, I told you that we want to hide if we're protecting the key, we want to hide the fact that the Threshold is five. So the attacker doesn't even know how many shares it needs to compromise in order to forge signatures. Okay, so again, I want to solidify this in your mind. There are two types of Threshold signatures, and you would use a different type for different applications. So if you're using it to protect keys, you would use a private Threshold signatures. If you're using it to do consensus, you would use an Accountable Threshold signature because you want accountability. And these are very different constructions.
00:17:36.218 - 00:18:11.420, Speaker A: So let me show you the kind of the simplest let's see. So let me show you the simplest possible Threshold signature. In fact, I'm going to ask you, let's see if somebody can propose the simplest, simplest Threshold signature. You know, actually, maybe I'll show you the signature scheme, this Threshold signature, unless somebody has an idea. Like, if I ask you to kind of build the trivial, most Threshold signature scheme, what would you do? Let's see if anybody has any ideas. What would you do? Like the simplest, simplest, simplest threshold signature that comes to mind? Well, I kind of already wrote the answer on the slide. Yeah, please.
00:18:11.420 - 00:18:14.614, Speaker A: Perfectly.
00:18:14.662 - 00:18:15.260, Speaker B: Exactly.
00:18:15.950 - 00:18:45.042, Speaker A: So this is what's called multisig. So multisig is used in Bitcoin and inherited actually, in Ethereum, too. Multisig is what I call the trivial Threshold scheme. So let's see how multisig works. So in multisig, what happens is we're going to give every user, every one of the nine shareholders is going to generate a private public key pair. So their own, let's say, schnorr signature key pair for themselves. And so they're going to keep these secret keys for themselves.
00:18:45.042 - 00:18:49.938, Speaker A: And the public key is just going to be the set of all public keys that these users generated.
00:18:50.034 - 00:18:50.342, Speaker B: Okay?
00:18:50.396 - 00:19:12.922, Speaker A: So everybody just generates a non threshold, a regular signature key pair for themselves. The public key is just the concatenation of all those public keys, and the secret keys are just what they generated. Now, when we want to sign a message, what happens is, again, we send a message to all the parties. Some of the parties respond and the signature, we simply append all the signatures that we got back together.
00:19:13.056 - 00:19:13.306, Speaker B: Yeah.
00:19:13.328 - 00:19:35.926, Speaker A: So the signature is just going to be sigma one and sigma three, which says two people signed. And therefore this is a valid Threshold signature. Yeah, because the threshold is two in this case. So we have a valid Threshold signature because at least two people signed. So we're happy. So let me ask you this. So first of all, look at this signature scheme, and now you guys need to be able to answer this.
00:19:35.926 - 00:19:51.690, Speaker A: Is this a private Threshold signature, a Pts, or is this an Accountable Threshold signature? An ETS? Which one is it? Pts or ETS? Pts. Let's see. Is the threshold revealed? Does the signature reveal the threshold?
00:19:52.910 - 00:19:53.370, Speaker B: Yes.
00:19:53.440 - 00:20:13.434, Speaker A: Well, if the signature reveals a threshold, it's not private. Exactly. This is an Accountable Threshold signature scheme, right? Because when you look at the signature, you literally see it says sigma one and sigma three. You literally see user number one signed and user number three signed. So we know exactly who signed and therefore they have accountability.
00:20:13.562 - 00:20:13.914, Speaker B: Yeah.
00:20:13.972 - 00:20:17.950, Speaker A: So this is used in Bitcoin's multisig transactions.
00:20:18.030 - 00:20:18.226, Speaker B: Right.
00:20:18.248 - 00:20:34.466, Speaker A: So when you sign, you know exactly when in a multi SIG transaction, you know exactly which subsets of the nine actually signed the message and you have accountability. Unfortunately, I have to say this is the wrong way to implement an Accountable Threshold signature.
00:20:34.578 - 00:20:35.046, Speaker B: Yeah.
00:20:35.148 - 00:21:20.370, Speaker A: And you can kind of be maybe my ambassadors here to say that if you need to implement Accountable Threshold signatures, even though this is a trivial scheme and it's very easy to come up with this is not the right way to implement an ATS. Yeah, this is an important message, and so I'm going to explain why this is not the right way to implement an ATS. First of all, you realize that we accept the signature if it contains valid, at least T valid signatures. So first of all, you realize our public key is linear in size because we have PK one to Pkt. Worse, the signature is the size of the signature is linear in the threshold T. Right? So if we have five out of nine, every single signature now has to carry five signatures in it. That's kind of long, five signatures.
00:21:20.370 - 00:21:27.554, Speaker A: So A, it's a long signature, b, the poor verifier. Every time you want to verify the signature, now you have to verify five signatures.
00:21:27.602 - 00:21:27.814, Speaker B: Right?
00:21:27.852 - 00:22:06.702, Speaker A: This is five times the verification work. So it's long and it's inefficient to verify. So these are just kind of inefficiency arguments why multisig is the wrong way to implement an ATS. We're going to see a security argument in just a minute. Okay, so good. So then the question is, how do we implement Threshold signatures, ATSs and PTSS? And it turns out, basically, we can take the classical signature schemes and convert them into either Accountable Threshold Signatures or Private Threshold signatures. How do we do it? Well, so let's look at two families of signature schemes, right? So BLS signatures, BLS signatures are used in Ethereum too, for consensus and Schnor signatures.
00:22:06.702 - 00:22:36.990, Speaker A: Schnorr signatures are used in Taproots and modern transactions in bitcoin and in other blockchains as well. Okay, so in BLS signatures, it turns out it's trivial to convert it into a Threshold signature. You get a very efficient Accountable Threshold signature. You get a very efficient private Threshold signature. It's just fairly straightforward. It's like very simple construction and it's nice and easy to use. So of course, maybe I'm a little biased, but I highly recommend using those as an ATS and a Pts.
00:22:37.490 - 00:22:37.902, Speaker B: Good.
00:22:37.956 - 00:23:09.618, Speaker A: Schnorr signatures also give us accountable Threshold Signatures. And private threshold signatures. It's a little bit more complicated. There are systems that do it either using but now it requires a protocol, a multi round protocol between the combiner and the signers. Yeah, you have to kind of go in a ping pong back and forth, and you can do it in two rounds or in three rounds. For a private Threshold signature, there's a system called Frost. For an Accountable Threshold signature, there's a system called MuSig, and it allows us to also get these Threshold signatures.
00:23:09.618 - 00:23:36.434, Speaker A: And in fact, this is used in bitcoin's Taproot system. I hope you guys have heard of Taproot. The reason they moved to Schnorr signatures is exactly so that they implement multisig correctly so they can use these more efficient multi SIG systems. Yeah, and the point of this is, this is much better than traditional multisig just because we get shorter signatures much faster to verify and it's just more efficient, better. So keep that in mind.
00:23:36.472 - 00:23:36.626, Speaker B: Yeah.
00:23:36.648 - 00:24:03.962, Speaker A: If you need to use a threshold signature, don't use multisig. Use one of these correct threshold signatures. And there are now many libraries that actually implement this for you, including distributed key generation and so on. So there are many open source projects that now implement this quite well. Although, again, you have to think, do I want accountable or do I want private? And many of these open source projects actually don't distinguish between the two. So that's up to you. You're going to have to figure out which one you actually want.
00:24:03.962 - 00:24:17.518, Speaker A: Terrific. So now we understand the kind of the core constructions. Now let me kind of switch gears and talk about kind of a cryptographic tool that's actually quite old in cryptography, but somehow is not used in the blockchain space.
00:24:17.604 - 00:24:17.854, Speaker B: Yeah.
00:24:17.892 - 00:24:44.482, Speaker A: So again, I want you to know about this technique. This is a very important technique for protecting secret keys that somehow very, very few projects use. So please, you need to be aware of this. And I hope that in the school, when you implement your systems, you'll actually be using this protection technique. So this protection technique is what's called a proactive refresh. And the idea, the problem that it comes to solve is this problem of what's called perpetual leakage. Perpetual leakage.
00:24:44.482 - 00:24:46.242, Speaker A: So let's go back to the Ronan hack.
00:24:46.306 - 00:24:46.486, Speaker B: Yeah.
00:24:46.508 - 00:25:09.338, Speaker A: I'm sure many of you have heard of the Ronan hack. Ronan was the bridge to the ronin blockchain. That bridge used a five out of nine threshold signature. Yeah, five out of nine. It wasn't a coincidence that I used five out of nine as my example. That's exactly what Ronan used. And unfortunately, the attacker was actually able to control five of the secret keys.
00:25:09.338 - 00:25:45.718, Speaker A: Yeah, the attacker got control of five of the secret keys. He was able to issue a fake signature to say that the bridge should release funds to the attacker when it shouldn't have. That signature was published, and the funds were lost. This caused about, what was it? About $600 million or so were stolen in the Ronan attack. And that, by the way, had a lot of the Ronan attack is a very interesting story that had a lot of downstream effects in the ecosystem. Maybe you've heard of what happened to tornado cash as a result and so on. But let's focus on the attack itself, the five out of nine secret shares.
00:25:45.718 - 00:26:21.254, Speaker A: So what happened in the Ronan attack is, again, as I said, unfortunately, four of the shares were held by a single entity. And that entity, one employee at that entity got hacked. And as a result, four of the shares got leaked. So one lesson from this is if you're going to do threshold signatures to protect your secret key, you really have to give the secret shares to different entities. It's not a great idea to have one entity hold multiple shares. Because that's not really what Threshold Cryptography is doing. Yeah, okay, but let's talk about the principles of this.
00:26:21.254 - 00:27:08.418, Speaker A: So the principle here is the attacker actually had a lot of time where it could just literally go entity by entity and spend as much time as it wants to extract the secret key from each entity. This is what's called perpetual leakage, right. The attacker invests a lot of energy in attacking one entity and gets their secret key. Then he turns on to another entity, invests a lot of energy and gets a secret key. Over time he basically will eventually he will collect T shares, five shares, and then he can issue signatures and cause a lot of damage. Yeah, this is what's called, again, perpetual leakage in Threshold Crypto. So what do we do? How do we defend against perpetual leakage? So actually, let me ask you, what would you do to defend against this perpetual leakage problem? What comes to mind? Anybody have any ideas? Yeah, please.
00:27:08.418 - 00:27:32.618, Speaker A: If you have some ways, like invalidate certain signatures, like say, remove them from the signing group. I see, so when a secret key is compromised I see. Maybe you somehow kick that secret key out of the group so they can no longer sign. Yeah, so that's a very interesting idea. There are two issues with that. One is you might get hacked and you might not know that you got hacked. So your secret key might be exposed and you would never know it.
00:27:32.618 - 00:28:00.774, Speaker A: That's one problem. The other problem is if you're going to remove a secret key from a Threshold signature, typically that means that you have to generate a new public key. Yeah, somehow we have to generate a new public key and then assign shares to the other eight parties and not to the one that got hacked. Changing the public key is kind of a painful process, right? Because now if there are a lot of assets associated with the old public key, now you have to issue transactions and pay for those transactions to move the assets from the old address to the new address.
00:28:00.892 - 00:28:01.126, Speaker B: Yeah.
00:28:01.148 - 00:28:23.786, Speaker A: So changing a public key is kind of a painful process. People do it actually a lot of the custodians, they will actually generate new secret keys every couple of months and they will spend the effort to actually move the funds around. But we'd like to do something simpler. So let me show you this trick. Yeah, this is a good trick. You need to know about this and I hope you actually get to use it in your projects. So this is what's called proactive refresh.
00:28:23.786 - 00:28:57.910, Speaker A: It's an idea that dates back to 1991, so 30 years ago. But again, somehow it hasn't reached the blockchain world. So hopefully more projects will use it, will use it in the future. And so what is the idea of a proactive refresh? The idea is that we are going to constantly refreshing our secret keys. So once a day, let's say once an hour, whatever, let's say once a day, we are going to refresh our secret keys, but in such a way that the public key doesn't change. That seems like magic, right? So we have, like, a secret sharing of a secret key. Yeah, a five out of nine sharing of a secret key.
00:28:57.910 - 00:29:22.506, Speaker A: It turns out we can actually change refresh all of our secret keys, and the public key stays the same. The world doesn't even know that we did this refresh. And because the world doesn't know, we can do this as often as we want, once an hour, once a day, and so on. So let me explain how this works. Basically, we have our parties, let's say our nine parties, they have their secret keys. What they're going to do is they're going to run a protocol amongst themselves. This is called the proactive refresh protocol.
00:29:22.506 - 00:29:44.806, Speaker A: And at the end of this protocol, they all of a sudden hold new secret keys. All their shares got refreshed. But magically, the public key doesn't change. Yeah, magically, the public key doesn't change. Now, we can go into the mathematics of this, but honestly, I wanted to spare you the mathematics, so I'm just going to keep it at a high level, and we'll see a very simple example in just a second.
00:29:44.988 - 00:29:47.526, Speaker B: Okay? Yeah. So that's that.
00:29:47.548 - 00:30:22.018, Speaker A: So that's basically how the refresh works. And the point of this is if the attacker breaks into one party today and then he breaks into another party tomorrow, they'll get one secret key today from one party, and they'll get a different secret key from another party tomorrow. If the refresh happened. In the meantime, those two secret keys tell him nothing. They can't combine them anymore. So now, the poor attacker, he can't just take his time to attack enough parties until he gets to five parties. He actually has to attack all five parties in one day.
00:30:22.018 - 00:30:40.326, Speaker A: That's the idea, yeah. And in fact, if you do the refresh every hour, the poor attacker now has to extract many, many shares within 1 hour. If he takes 90 minutes, he's out of luck, because the shares that he extracted in the first hour are not going to combine with the shares that he extracted in the second hour.
00:30:40.428 - 00:30:40.694, Speaker B: Yeah.
00:30:40.732 - 00:31:01.354, Speaker A: Does that make sense? It's like you can see why this is such an important idea. So it allows you again, to refresh the shares, and the public key does not change. Nobody knows. Nobody in the world knows that you did the refresh. So you don't have to issue transactions, you don't have to move assets around. It's just a very simple and efficient way to protect your secret shares against perpetual leakage. Terrific.
00:31:01.354 - 00:31:23.602, Speaker A: Okay, so we have our proactive refresh. So how do we implement that? Well, it turns out there are good constructions for this. Let's start with the basic threshold construction. So the trivial basic construction is multisig. Remember multisig from Bitcoin? Good old multisig? Well, I told you it's inefficient. So you shouldn't use it because it's inefficient. Even worse, it turns out multisig cannot be refreshed.
00:31:23.602 - 00:32:02.814, Speaker A: You cannot do a proactive refresh if you use a multisig. Let's think for just 1 second why remember, the public keys are basically PK one to PKN, right? Every it's a list of all public keys that all the users had. If the attacker breaks into user one and steals that user one's secret key, the attacker is effectively now the same as user number one. There is no way to refresh the shares. The attacker will always be able to sign on behalf of user number one. There is no way to do a refresh until you change the public key. So without changing the public key in a multisig environment, it's simply not possible to do a proactive refresh.
00:32:02.814 - 00:32:28.534, Speaker A: This is a really important thing to remember if you use multi key. If you have multisig, you're effectively preventing a proactive refresh in your system. So don't use multisig. Use the other threshold signature techniques. Okay, so that's lesson number one problem. This is a security problem with multisig, which is one reason why we shouldn't be using it. Lesson number point number two is that, in fact, we have good proactive refresh mechanisms.
00:32:28.534 - 00:33:00.370, Speaker A: For example, in a private threshold signature scheme, it's actually not that difficult to do a proactive refresh. Yeah, there's a protocol, it dates back to 1995 that shows how to do it. Let me give you a very simple example of this protocol. Let's suppose that we have two parties and we take our secret key and we break it up into a sum of two secret keys. So SK is SK one plus SK two. So this is what's called a two out of two sharing in that you need both shares in order to sign SK one plus SK two. How do you refresh such a sharing? Well, it's really quite simple.
00:33:00.370 - 00:33:30.430, Speaker A: I mean, I wish I hadn't put it on a slide so I could ask you to come up with it yourself, but it's really quite simple. What the parties would do is they would choose some random number r, and then one party would add r to SK one, and the other party would subtract r from SK two. And you notice the sum doesn't change. So this is still a sharing of SK. So the public key didn't change, but now the shares are completely re randomized. We just added a random mask. We added a mask to one and we subtracted a mask from the other.
00:33:30.430 - 00:33:51.890, Speaker A: So the shares are completely randomized, but the public key didn't change. So that's a very simple mechanism that allows us to do a refresh for a private threshold signature. And it turns out this also generalizes to five out of nine. So if we have a five out of nine sharing, there's a very cute observation. Maybe I can ask you to think about this as a homework problem.
00:33:51.960 - 00:33:52.158, Speaker B: Yeah.
00:33:52.184 - 00:34:31.566, Speaker A: It's actually quite easy to come up with a protocol that will refresh a five out of nine sharing. Maybe as a hint, I'll tell you, the idea is you choose a random polynomial whose constant term happens to be zero, and you use that polynomial to refresh all the shares. But let's leave it at that level. I hope this is clear, right, that you can easily refresh a private Threshold signature. The question is, what do we do about Accountable Threshold signatures? And in fact, this is much harder. So can we refresh an Accountable Threshold signature? At first glance, it seems like this is impossible. You can't refresh an Accountable Threshold signature because the private key is what's used for accountability.
00:34:31.678 - 00:34:31.954, Speaker B: Right.
00:34:31.992 - 00:34:56.662, Speaker A: The way I know who signed the message is by basically tying them back to their private key. So if we change the private key, how are you going to do accountability? But it turns out, nevertheless, it is possible. And in fact, this is some work that we did very recently. It's harder to do, but I put a link to the paper if you're interested in learning how this works. But it's a very practical mechanism that allows you to do a refresh for Accountable Threshold signatures.
00:34:56.726 - 00:34:56.906, Speaker B: Yeah.
00:34:56.928 - 00:35:21.694, Speaker A: So again, if that's what you need, if you need Threshold signatures for consensus, it's important. Up until now, it was kind of people thought, oh, maybe accountability, maybe refresh is not possible, so we might as well use multisig. But no, actually, refresh is possible if you use BLS or schnorr. It's really quite practical, and I think it's a technique that should be used by more projects.
00:35:21.742 - 00:35:21.954, Speaker B: Yeah.
00:35:21.992 - 00:35:22.580, Speaker A: Please.
00:35:23.430 - 00:35:34.310, Speaker C: What is the use case for ATF? What's the advantage? Is it literally that the signing parties are accountable? Like, they put their reputation on the line such that you know who signed this transaction.
00:35:34.810 - 00:35:36.934, Speaker A: Yeah, exactly. So that's exactly right.
00:35:36.972 - 00:35:37.126, Speaker B: Yeah.
00:35:37.148 - 00:36:19.058, Speaker A: So they're accountable for their actions. So for an Accountable Threshold signature, if the quorum of parties signs a message incorrectly, like, for example, releasing funds from a bridge, they will actually be accountable for their action. We will know that those are the parties assigned that message, and then we can go slash them or penalize them. In the case of Ronan, when the hack wasn't initially, if they had used a private Threshold signature, we wouldn't have known which of the five out of the nine shares were compromised. But because they used an Accountable Threshold signature, it was very clear, oh, it's these five that were hacked. And in fact, four of those, as I said, were held by a single party.
00:36:19.154 - 00:36:19.558, Speaker B: Yeah.
00:36:19.644 - 00:36:53.806, Speaker A: So that's the beauty of an Accountable Threshold signature. If something goes wrong, you know exactly who misbehaved, who got hacked, who did something incorrectly, and then you can go and penalize them in some way. This, by the way, happens often in proof of stake consensus right there. You often need Accountable Threshold signatures because if somebody signed a block incorrectly, the accountability aspect allows you to see exactly who signed incorrectly, and then you can go and slash them. A private Threshold signature wouldn't work because the block would get signed, an incorrect block would get signed, and you would have no idea who did it.
00:36:53.908 - 00:36:54.378, Speaker B: Yeah.
00:36:54.484 - 00:37:11.846, Speaker A: So private Threshold signatures are used for protecting keys. Accountable Threshold signatures are used when they're needed for consensus. There's a different Threshold signature mechanisms. And I hope this talk kind of makes it clear to you that, really, when you use Threshold signatures, you have to think, which version do I actually need?
00:37:11.948 - 00:37:12.166, Speaker B: Yeah.
00:37:12.188 - 00:37:25.962, Speaker A: And there's the real separation between the two. And the point of this is we can even do refresh for private Threshold signatures. We can do refresh for accountable Threshold signatures, we cannot do refresh for multisig. This is kind of an important point in the talk.
00:37:26.016 - 00:37:26.618, Speaker B: Yeah.
00:37:26.784 - 00:37:34.670, Speaker C: In prox refresh cases, are there ways to prevent previous rounds of refresh keys from leakage or compromise?
00:37:37.170 - 00:38:08.200, Speaker A: Right, okay. That's a good question. So the question was, when we do a refresh, is there a way to prevent older versions of a secret key from getting leaked? So typically, if the participants are honest, what they would do is, after the refresh, they would destroy their old they would delete their old secret keys. Yeah, but maybe the participants got hacked or something. Right. And they're not deleting their old secret keys. Then if the attacker gets control over more than T shares in any round, then there's a problem.
00:38:08.200 - 00:38:26.590, Speaker A: So this basically would work as long as enough participants are honest to actually delete their shares after every refresh, which is kind of the normal operations. But again, the assumption here is very difficult. It's difficult for the attacker to break into many parties at once. So it's quite a reasonable thing to do.
00:38:26.740 - 00:38:27.054, Speaker B: Yeah.
00:38:27.092 - 00:38:28.334, Speaker A: So it's a very good question.
00:38:28.452 - 00:38:28.734, Speaker B: Yeah.
00:38:28.772 - 00:38:33.038, Speaker A: Please, just a question to understand the difference really clearly.
00:38:33.134 - 00:38:33.826, Speaker B: Yeah.
00:38:34.008 - 00:38:42.462, Speaker A: Because we need the accountability, does it mean that we need to share some information about the keys?
00:38:42.526 - 00:38:43.140, Speaker B: Right.
00:38:45.590 - 00:38:49.734, Speaker A: Accountable Threshold signatures necessarily reveal what the threshold is.
00:38:49.852 - 00:38:50.134, Speaker B: Right.
00:38:50.172 - 00:39:11.194, Speaker A: Because you can just look at the signature, see who generated that signature, and that reveals the threshold. So, you'll know so if you're an attacker, you'll know, oh, I need to break into five users, five parties, in order to recover the secret key in a private Threshold signature. You don't know what the threshold is. You can look at the signature. You have no idea what the threshold is, so you don't even know how many parties you have to break into.
00:39:11.312 - 00:39:11.750, Speaker B: Yeah.
00:39:11.840 - 00:39:50.246, Speaker A: So that's like, why PTSS are used for protecting keys and ATS are used for consensus. Can we combine the two? Let's say if you want accountability oh, my God. Of quorums oh, that is such a wonderful question. That is such a wonderful question. So the question, thank you so much for asking that. So the question is, I told you there's ATSs and PTSS and you have to choose which one do you want? So the wonderful question is, is there a way to kind of get the best of both worlds? Can we have accountability and still have privacy? So that sounds contradictory, right? I mean, if we have accountability, we know who the parties are, so how can we have privacy? Turns out there is a way to do it. So there's another mechanism.
00:39:50.246 - 00:40:11.230, Speaker A: This is a paper that just appeared a year ago. There's another mechanism. It's called private accountable threshold signatures, Pats. Pats. And in a pats, what happens is you have privacy from the public. So the public would have no idea what the threshold is and no idea who generated a signature. But there is a special secret accountability key.
00:40:11.230 - 00:40:45.302, Speaker A: So anybody who has the secret accountability key, they can use their key to look at a signature and figure out exactly who generated that signature. So we kind of have the best of both worlds by having privacy from the public and accountability against an accountability authority. The question, of course, who runs the authority and so on. But that can be arranged as well. Yeah, so that was a wonderful, wonderful question. So if you're interested in that, there's this mechanism, it's called pats. I have to say right now the constructions for pats are not the most efficient.
00:40:45.302 - 00:41:06.270, Speaker A: Potentially we could build something more efficient, but that's kind of directions for future research. So if any of you are interested, maybe think about more efficient patch systems for the future. That was a wonderful question. Thank you for asking that. Great. Any more questions on this on the proactive refresh versus ATSs?
00:41:06.710 - 00:41:07.122, Speaker B: Great.
00:41:07.176 - 00:41:51.690, Speaker A: So in that case, let's move on. So I wanted to take do a very quick Whirlwind tour in five minutes about an area that I think is really exciting and I hope it'll be exciting to you too. So this is basically kind of more advanced cryptographic schemes that are not used in the blockchain space today, but they could be used actually in the coming years and put to very good use in the ecosystem. So again, hopefully in some of your projects these techniques will be useful. So yes, I call these advanced cryptographic primitives that could have applications in the coming years in the blockchain space. So this is like a Whirlwind tour of very, very deep topics, but I just want to give you a taste of what's coming. So the first example, of course, is what's called confidential computing.
00:41:51.690 - 00:42:10.242, Speaker A: So confidential computing basically allows us to compute on data without knowing what the data is. That's kind of a remarkable thing. How could you possibly compute on data if you don't know what the data is? Turns out crypto magic allows us to do that. Why is this relevant in the blockchain space? Well, it comes up in the context of mev.
00:42:10.306 - 00:42:10.486, Speaker B: Yeah.
00:42:10.508 - 00:42:18.202, Speaker A: Maximal extractable value mev. So here's the problem. Let me just make sure everybody's on the same page. What is the mev problem? Mev problem?
00:42:18.256 - 00:42:18.714, Speaker B: Yeah.
00:42:18.832 - 00:42:55.886, Speaker A: The problem is, imagine I'm a searcher and I look around for various transactions that could make a profit for me. Maybe I find an arbitrage opportunity. Something is being sold for one value in one marketplace, and that's a different value in another marketplace. I can issue an arbitrage transaction and profit from the result. One could argue that the searcher is providing a service because if there's a gap in prices between different marketplaces, the searcher is equalizing those marketplaces. And sure, it's making a profit in the process, but he's also providing a service that is equalizing these marketplaces. Terrific.
00:42:55.886 - 00:43:26.346, Speaker A: So how does a searcher actually do this? Well, not today, but let's say a few years ago, the searcher will basically work hard to find these arbitrage opportunities, and then they would post the arbitrage transactions onto the mempool to get posted. What happens? Somebody tell me what happens once the searcher posts these transactions into the mempool. What happens exactly? It gets sniped, right? So somebody looks and says, oh, thank you very much, searcher. This is a really cool idea. I'm just going to take your transaction and change it so that I'm the one who profits on the arbitrage.
00:43:26.378 - 00:43:26.670, Speaker B: Right.
00:43:26.740 - 00:43:39.758, Speaker A: And maybe I provide a higher priority fee so that it'll get placed in the blockchain, in the block earlier than yours. And now I basically stole your mev. I stole your arbitrage profits.
00:43:39.854 - 00:43:40.258, Speaker B: Yeah.
00:43:40.344 - 00:44:11.498, Speaker A: So as you know, this is a problem. If this had gone untreated, this would have been a real problem because it causes price, what's called price gas auctions in the mempool. So it kind of degrades the blockchain experience for everybody, because if I post a transaction and you try to snipe it, I'm going to try to snipe it back. And you see, we kind of have this kind of tit for tat battle in the mempool. That's not what the mempool is for. It's hurting everybody else's transactions on the mempool. It causes high gas prices and so on.
00:44:11.498 - 00:44:33.620, Speaker A: So good. So this is exactly where Flashbots comes from. So the idea behind Flashbots was to say, well, let's try to take all these wars between searchers, the searchers, they're free to battle one another as much as they want, but let's take all of that out of the mempool. So Flashbots is kind of a way to do these auctions somewhere else. So the mempool is used by people who are end users, who don't have to suffer from this.
00:44:34.230 - 00:44:34.980, Speaker B: Great.
00:44:35.430 - 00:45:18.686, Speaker A: The ultimate solution, however, is today, basically we use mevboosts, which is kind of what it does, kind of takes these price gas auctions out of the mempool. But the ultimate solution that we'd like to do is what's called Flashbot suave. So maybe you've heard of Suave? This is kind of the coming architecture, I'll tell you that. Kind of the rough idea of Suave is to say that somehow, by magic, we want the searchers who have transactions. We want them to keep their transactions to themselves so they don't have to tell the world what the transactions are. And nevertheless, we want the builders, the people who build blocks, to be able to build blocks from the searcher transactions.
00:45:18.798 - 00:45:19.218, Speaker B: Yeah.
00:45:19.304 - 00:45:57.322, Speaker A: So somehow the transactions should be encrypted. So the searchers, maybe when they post them, they should be encrypted. Nobody can read what they are. But the builders, when they build blocks from these transactions, they should be able to look at the contents of the transactions so they can package them in the ultimate way. Maybe from a gas point of view, they need to be able to package them so that it optimizes some optimization function. So that looks like, again, a contradiction. If the transactions are encrypted, how can you possibly apply a building strategy to build efficient to build efficient blocks? So it's a contradiction and, well, this is exactly where cryptography shines whenever you have contradictory requirements.
00:45:57.322 - 00:46:39.910, Speaker A: Remarkably, cryptography can actually be used to solve the contradiction. So the way Suave actually works, what Suave is trying to do is sort of solve the following problem. Yeah, we have searchers on the left, right? So Sam and sue, we have block builders on the right, Bob and Brooke and so on. And then we have the block proposer on the bottom that needs to sign the final block that gets constructed. What we'd like to do is we'd like them all to provide their inputs. So Sam and sue will send their transactions, their encrypted transactions. Bob and Brooke will send various building strategies, and the block proposal will contribute its signing key because it needs to sign the block once it's created.
00:46:39.910 - 00:46:43.326, Speaker A: And then by magic, nobody will be able to read anybody's data.
00:46:43.428 - 00:46:43.742, Speaker B: Right.
00:46:43.796 - 00:46:58.162, Speaker A: Everybody's data will be kept hidden from everybody else. By magic, somehow the block gets constructed correctly and gets signed. That's the problem that Suave is trying to solve. Is that clear? This is a really difficult problem.
00:46:58.296 - 00:46:58.738, Speaker B: Right.
00:46:58.824 - 00:47:36.954, Speaker A: Somehow we need to be able to operate on these transactions, on these encrypted transactions, apply building strategies and then sign the block at the end without anybody looking at the block data. How do we do that? Well, that's exactly the magic of cryptography, right? So we do that using what's called confidential computing. The two methods I want to highlight is basically what's called MPC multiparty computation, which allows us to do it. And the other method is, of course, using hardware enclaves. So these are techniques that have not played a role yet in the blockchain space. And now they're going to get pulled because of mev. They're going to get pulled into the blockchain space and play a very major role.
00:47:36.954 - 00:48:32.142, Speaker A: What's exciting to me about this is now all of a sudden, the blockchain ecosystem is going to zoom in on these two techniques and just like zero knowledge improved dramatically as a result of blockchain attention, these two areas, we're going to see massive improvements in these two areas because of blockchain attention. So the fact that all of a sudden we're going to get efficient and practical hardware enclaves, this is a big deal, right? This has been an open problem now for a long time. I think the blockchain attention is going to force the development of these enclaves, and this is going to be a major boost to the rest of society. So this is a big deal. So I just wanted you to know that this is coming. If you're interested in kind of jumping in on this train that's going, you can go learn more about multiparty computation, learn more about hardware enclaves. But this is kind of a big technology development that's probably going to happen in the next two to three years because of the attention from the blockchain space.
00:48:32.142 - 00:49:06.390, Speaker A: I think it's really, really interesting that this is happening. So that's one technology I wanted to tell you about, another technology I wanted to tell you about is something that enables private storage. Again, this is something that's not used in the blockchain space yet, but could very easily get used in the near future. What is the idea of private storage? So imagine we have a server that stores a bunch of data, and we want to read that data without revealing to the server what it is that we are reading. So there are two techniques that I'll just tell you the names. One is called Private Information Retrieval. The other is called oblivious Ram.
00:49:06.470 - 00:49:06.714, Speaker B: Yeah.
00:49:06.752 - 00:49:17.360, Speaker A: These are two techniques that could help here. And so private Information retrieval makes it possible to read data from the storage without revealing to storage what I'm interested in.
00:49:17.810 - 00:49:18.174, Speaker B: Yeah.
00:49:18.212 - 00:49:41.126, Speaker A: So I can read a cell and not the storage would have no idea what I just read. And oblivious Ram allows me to run an entire program. This is kind of a remarkable thing. I can run an entire program, and all the memory access patterns that that program makes to the storage is independent of the program that's running. So I can run a secret program, and the storage server will never know what program I'm actually running.
00:49:41.228 - 00:49:41.446, Speaker B: Yeah.
00:49:41.468 - 00:50:12.142, Speaker A: So it's a way to access storage in a privacy preserving manner. Why is this useful in the blockchain space? Well, there are these storage systems in the blockchain that we would like to maybe access privately. In particular think of infer Alchemy. Right. Today, when we access Infer and Alchemy, we basically are telling them exactly which contracts we're interested in, exactly what data we're interested in. It'd be nice if we could do it in a way that doesn't reveal to them what it is that we're doing. And perhaps these techniques will be useful for that.
00:50:12.142 - 00:50:24.882, Speaker A: So, again, it's very interesting. If the blockchain world focused on these privacy techniques, they would see significant improvements in performance, and that would benefit the rest of society as well. The third example and then I'll stop.
00:50:24.936 - 00:50:25.106, Speaker B: Yeah.
00:50:25.128 - 00:50:38.182, Speaker A: Then I want to leave time for questions, so then I'll stop. The third example is a bit more theoretical, but I do want you to know that this exists. And this is the idea of hiding secrets in code.
00:50:38.316 - 00:50:38.710, Speaker B: Yeah.
00:50:38.780 - 00:50:50.602, Speaker A: If I have a secret key and I want to put it in a program and give you the program, I want to be able to do that in a way that you can look at the program, and you will never be able to extract the secret key from that program.
00:50:50.736 - 00:50:51.178, Speaker B: Yeah.
00:50:51.264 - 00:51:32.394, Speaker A: This is called code obfuscation, but the technical name for this is virtual black box VBB code obfuscation. The idea of an obfuscator is that it will actually take a program. It'll take a program, run it through this obfuscator, and you'll get a different program. This new program is going to be identical to the old program, so it'll have the same input output behavior as the old program. But the magic is that this new program, P prime, reveals nothing about how the program works beyond its input output behavior. All you will learn is the connection between the inputs to the program and the outputs to the program, but you'll learn nothing about any secrets in the program. That's what an obfuscator does.
00:51:32.394 - 00:52:08.206, Speaker A: It hides the inner workings of a program so that you can't actually see what it does. In particular, if there's a secret key embedded in the program, you will never be able to extract that secret key from the program. Why is this useful? Well, this is useful because now if we had an obfuscator, we could actually publish solidity code, and the solidity code would have secret keys embedded in it such that the solidity code could sign messages. And you will never be able to extract a signing key from the code. So we can make sure that now the contract can sign messages only when certain conditions specified in the contract are specified are satisfied.
00:52:08.318 - 00:52:08.738, Speaker B: Yeah.
00:52:08.824 - 00:52:33.534, Speaker A: And so this will be like do you agree? This is like super duper cool. You can kind of post programs to the chain. The chain itself will generate signatures, and no one can extract a secret key. These signatures will only be generated when the code says that it's okay to generate those signatures. So bridges become a lot simpler. Basically, there's a whole bunch of applications that will become possible once obfuscation happens. So this sounds great.
00:52:33.534 - 00:52:48.158, Speaker A: There's only one problem. The one problem is that obfuscation right now is I would say it's polynomial time. It's polynomial time. So Theoreticians would say, great checkmark, but it's not practical.
00:52:48.334 - 00:52:48.722, Speaker B: Yeah.
00:52:48.776 - 00:53:04.662, Speaker A: So just like zero knowledge. 20 years ago, zero knowledge was completely theoretical. We would say it's. Not practical. And lo and behold, now it's super practical. The hope is that with obfuscation today, it's not practical. The hope is that new ideas, all it takes is one idea.
00:53:04.796 - 00:53:05.382, Speaker B: One idea.
00:53:05.436 - 00:53:24.320, Speaker A: By the way, this is what happened with zero knowledge. One idea is what moved zero knowledge from being impractical to being practical. One idea. 2013. Yeah, it's pretty interesting. All it takes is one idea, and we could end up with practical obfuscation, and all of a sudden, you will benefit from secrets in your code. So, yeah, please.
00:53:24.320 - 00:53:37.150, Speaker A: Yeah, it's a good question. So today, basically, the problem is that the program P Prime, the Obfuscator program, is too slow to run.
00:53:37.300 - 00:53:37.614, Speaker B: Yeah.
00:53:37.652 - 00:53:48.718, Speaker A: The Obfuscator the only secure office gators we have. Even if they take very simple programs, they output ridiculously large programs. The programs will take hours, perhaps even years to run.
00:53:48.904 - 00:53:49.206, Speaker B: Yeah.
00:53:49.228 - 00:54:20.570, Speaker A: So not practical. What we want is an officecator will take a program P and produce a program, an officecator program P Prime whose running time is about the same as the running time of program P. Yeah. That's what we'd like to have, if you have a moment. What was the idea in 2014 that made CK work? Okay, well, so there's a classic paper. It's called the Ggpr paper. That what it did is basically it reduced the proverbs running time from quadratic in the length of the computation to linear or quasilinear in the length of the computation.
00:54:20.570 - 00:54:53.158, Speaker A: So the move from quadratic to quasilinear made it possible to do proofs for gigantic statements, which is what, actually, we're seeing today. We're going to talk about zero knowledge in week three. So you're going to hear all about this, the history of zero knowledge and how it was developed. You're going to hear all about this in week three. But, yeah, there was this one critical idea that reduced things from quadratic to linear, and that actually enabled a whole bunch of applications here. Unfortunately, with Obfuscation, we're not even at quadratic at this moment. I think we're like at quartic or it's like the algorithms are quite inefficient.
00:54:53.158 - 00:55:06.574, Speaker A: They're polynomial time. They're quite inefficient, and we have to go to linear for that to be practical. But we could be one idea away. So this is a challenge for all of you, if you're interested. As you can see, there's, like, really cool problems to think about here.
00:55:06.612 - 00:55:07.440, Speaker B: Yeah, please.
00:55:17.110 - 00:55:24.530, Speaker C: Resources sharing the evolution of zero knowledge. And then we have, as Dan mentioned, those speakers coming independently.
00:55:25.350 - 00:55:42.506, Speaker A: Let me repeat that, sonal, because that's a very important point. So A 16 Z has this wonderful, wonderful zero knowledge canon. I highly, highly recommend looking at that. It contains a list of all kind of the key developments in zero knowledge, along with survey articles and books and so on. Very, very well done. Zero knowledge canon. Please take a look.
00:55:42.506 - 00:55:46.490, Speaker A: You can see exactly how zero knowledge works and the history of how it was developed.
00:55:46.910 - 00:55:47.466, Speaker B: Perfect.
00:55:47.568 - 00:56:11.582, Speaker A: So that's actually all I wanted to say. So let me just summarize by saying that this is an amazing time to be a cryptographer. This area is so much fun now. I can't remember I've been doing this a long time. I can't remember another period where I've had so much fun doing cryptography. Yeah, it's like the systems that we're building, they can be deployed. They affect real world blockchain applications.
00:56:11.582 - 00:56:39.126, Speaker A: There are applications outside of the blockchains. It's just so much fun to be a cryptographer these days. So I'm really happy to see all of you here, and I'm really excited to see all the projects that you're going to build. But we're not done. There's a lot more, as I just showed you, there's a lot more coming. There's a lot more technologies that need to be reduced to practice and transitioned into the blockchain space. And so I think the next decade is probably going to be as exciting as the decade that we've just experienced.
00:56:39.126 - 00:56:41.840, Speaker A: So thank you very much, and I'm happy to take any questions.
00:56:46.770 - 00:56:48.480, Speaker B: You yeah, please.
00:56:50.450 - 00:56:57.042, Speaker A: Oh, yeah, there's a mic. Hi. Thank you so much for the talk.
00:56:57.176 - 00:56:59.170, Speaker C: Your enthusiasm is infectious.
00:56:59.590 - 00:57:00.578, Speaker A: Happy to hear it.
00:57:00.664 - 00:57:19.050, Speaker C: This is more of a philosophical question, but I was curious for cryptography, is it building towards a convergent grand unified vision of some end state of the ultimate version of privacy and security? Or do you find it's more divergent where it's this incremental movement towards different goals?
00:57:22.110 - 00:57:42.970, Speaker A: No, I think there are, like, multiple goals. There's not a single target that we're going for. I think different applications in the ecosystem require different tools. In some cases, you can't use something unless it's private. In other cases, you can't use it unless it's transparent. Right. So I think there are actually different goals that need to be satisfied.
00:57:42.970 - 00:57:53.630, Speaker A: As a result, different technologies are applicable to different applications. That's great. Right? There's not going to be a single solution that solves everything in the world. We're going to have to build lots and lots of different tools.
00:57:53.790 - 00:57:54.402, Speaker B: Thank you.
00:57:54.456 - 00:57:55.540, Speaker A: Yeah, for sure.
00:57:57.190 - 00:58:40.850, Speaker C: Hi, Professor Bonie. I'm just saying I went to U of Waterloo for math and learned RSA encryption and, like, really big prime numbers a long time ago. So I read about homomorphic encryption, and that intuitively makes sense to me. So I work with game studios, and our use case would be like, let's say you're a Big Red studio. You have an obi course, a million players, and they're on the blockchain, but you want to keep those users private to stop Big Blue Studio from coming and airdropping and building a similar game and stealing them. So I think I don't know enough about homorphic encryption. I just want to know what's stopping us from implementing that today and what are some projects I should follow in that space?
00:58:40.920 - 00:59:02.186, Speaker A: Oh, yeah, nothing is stopping us so fully. Homomorphic encryption is a fantastic development in crypto as well. It's closely related to the confidential computing that I mentioned earlier. In fact, you could say there are three techniques for confidential computing multiparty computation, hardware enclaves, and fully homophobic encryption. All of those allow you to compute on data without actually seeing the data in the clear.
00:59:02.288 - 00:59:02.940, Speaker B: Yeah.
00:59:03.470 - 00:59:13.360, Speaker A: So fully homomorphic encryption actually is becoming quite practical. If you want to follow the developments, there's a startup, it's called Zama. Zama?
00:59:13.890 - 00:59:14.206, Speaker B: Yeah.
00:59:14.228 - 00:59:43.078, Speaker A: You should look at their tools. It's really quite beautiful to see what they're doing. So they're focusing right now on using fully homomorphic encryption for machine learning. So you have an encrypted data set that you want to run a model on. They will actually run the model on your encrypted data set. They will obtain encrypted results, encrypted classification results, send them back to you. You can decrypt and get the results without them ever knowing what your data was.
00:59:43.164 - 00:59:43.414, Speaker B: Yeah.
00:59:43.452 - 01:00:15.470, Speaker A: So it's really quite amazing to see that actually getting used. And so yeah, I think Zama would probably right now, as I said, they're focused on machine learning, but it would be equally applicable in the blockchain space, in fact, for the Mev application, if Fhe was sufficiently efficient, it would be a terrific application for suave. As I mentioned, it's just the suave problem. The suave computation is just so complex that it's probably beyond what Fhe can do today, but maybe in the future it will do that and then we'll be a perfect fit.
01:00:15.620 - 01:00:30.854, Speaker C: Yeah, for sure. That's super cool. Thanks. And I think, like machine learning, it's kind of like you need a large centralized entity to collect all this data. So it's like an enterprise customer. Right. Whereas we interface with game studios directly and they could have like a million consumers and that's more of a faster consumer use case.
01:00:30.854 - 01:00:33.126, Speaker C: That's like on chain, but yeah, thank you. Thank you for that.
01:00:33.148 - 01:00:35.320, Speaker A: Yeah, makes sense. Thanks. Great question.
01:00:35.930 - 01:00:44.202, Speaker D: Hi, Emmanuel from Shield Security. I'm curious, what kind of product and user experience manifestations do you see coming.
01:00:44.256 - 01:00:47.434, Speaker A: From that increased blockchain attention on things.
01:00:47.472 - 01:00:52.730, Speaker D: Like NPC as well as proactive refresh?
01:00:52.810 - 01:01:29.000, Speaker A: Yes, I would say, like the NPC application that I mentioned, multiparty computation, that is primarily a privacy mechanism. So if you want to keep your data private, like the searcher, who wants to keep their transaction private, but they have to give it to somebody else. They have to give it to somebody else so they can make a block out of it. That contradiction. I want to keep the data private and yet I have to give it to someone so they can compute on it. That contradiction is exactly what MPC hardware enclaves and Fhe come to solve. So if you're in an environment where you are facing that contradiction, I would say, come talk to us.
01:01:29.000 - 01:01:36.314, Speaker A: But in general, that's exactly where these techniques would apply. Does that make sense? Does that answer the question? Yes, it does.
01:01:36.352 - 01:01:36.730, Speaker B: Thank you.
01:01:36.800 - 01:01:37.420, Speaker A: Perfect.
01:01:37.790 - 01:01:38.442, Speaker B: Yeah.
01:01:38.576 - 01:02:00.850, Speaker A: It's really cool that there are all these like very often there are these contradictions in the world where they seem like impossible to resolve, but cryptography resolves them. Yeah, because I'll give you just one more example of that. There's very often situations where you want to compute, like, an analysis of a large amount of data, but this data is very private and it belongs to your customers.
01:02:01.000 - 01:02:01.362, Speaker B: Yeah.
01:02:01.416 - 01:02:26.250, Speaker A: Typical example is you want to know how people you're a browser manufacturer and you want to know how people use your browser. How people use your browser is a very private thing. Nobody's going to tell you how they use your browser. And yet you want to compute aggregate statistics over how people use your browser. It seems like a contradiction. They won't tell you, and yet you need to compute aggregate statistics. It sounds like you can't do it, but in fact you can.
01:02:26.250 - 01:02:53.022, Speaker A: These are contradictions that can be resolved using cryptography quite efficiently. So again, keep that in mind if you have a large user population that wants to keep their data private, but somehow you want to learn aggregate information about what they're doing with their data, sort of aggregate information about their data, we can do that. Cryptographically actually quite efficiently. There's a system called Prio p Rio that does this quite efficiently. So it's another example of a contradiction that can be resolved using crypto.
01:02:53.166 - 01:02:54.034, Speaker B: Yeah. Please.
01:02:54.152 - 01:03:00.742, Speaker A: Thank you for your answer on Fhe. Actually, Zama have some testnets for private computation for others to look at.
01:03:00.796 - 01:03:01.458, Speaker B: Yep.
01:03:01.634 - 01:03:17.578, Speaker A: I have a question on the implementation on the limits of how large we can have quorum to be in Pts. So can we have really large, large quorum that overhead being like, millions of users, for example?
01:03:17.664 - 01:03:18.106, Speaker B: Yeah.
01:03:18.208 - 01:03:48.114, Speaker A: In fact, in Ethereum post merge, they are using an accountable threshold signature effectively. It's called a multi signature there that has a quorum of 500. Well, what the number of users is like currently? 500,000. Right. As the amount of validators grows, they're going to have more and more and more entity users basically signing transactions in that system. So, yeah, you can have very large user populations and very, very large quorums for both Pts and for both Pts and ATS.
01:03:48.162 - 01:03:48.374, Speaker B: Yeah.
01:03:48.412 - 01:03:52.280, Speaker A: These systems scale quite well. Yeah, it's very interesting.
01:03:52.890 - 01:03:53.734, Speaker B: Yeah, thanks.
01:03:53.772 - 01:03:54.840, Speaker A: It's a great question.
01:03:55.770 - 01:04:33.780, Speaker D: Hi there. Great talk. Isaiah from Shield Security. Yeah, we also believe greater commitment to user security is definitely going to be what stimulates greater adoption, similar to how SSL did it in Web two. The question that I have, though, is related to how do you see cryptography combining with Quantum, the quantum platforms that are in development and also AI? Do you have a broader long term perspective of how those come together to create something great, or is there anything in the short term that you've seen that has been really interesting?
01:04:34.950 - 01:04:45.234, Speaker A: Oh, boy, that's a good question. Let's start with the quantum world. So you're asking maybe I can interpret your question as what is the impact of quantum computing on the blockchain?
01:04:45.362 - 01:04:45.750, Speaker D: Right?
01:04:45.820 - 01:04:59.130, Speaker A: Yeah, it's interesting that this question comes up quite a lot. Yeah. So it's true that a quantum computer would have an impact on the current primitives that are used in the blockchain, but we know exactly what to do.
01:04:59.200 - 01:04:59.434, Speaker B: Yeah.
01:04:59.472 - 01:05:46.470, Speaker A: In fact, for every primitive that we use, there's a quantum secure primitive. So what's called a post quantum primitive that's secure even if the adversary has a quantum computer. So the risk is actually not that great in the sense that as they come closer to fruition, we will just transition to these post quantum systems. The one caveat to that is privacy. If you're trying to protect privacy, then today maybe you want to be protected even in 50 or 100 years when these quantum computers appear. Then to protect privacy, you might think about using a post quantum system today. So even if in 50 years somebody has a quantum computer, they can't go back and unmask everybody's privacy.
01:05:46.470 - 01:06:08.514, Speaker A: Yeah, that's the one difference. But again, primarily in blockchains, the application is integrity, data integrity, not so much privacy. And so that's the sort of thing that as these computers become closer to reality, we can just switch to integrity mechanisms that are post quantum secure. Yeah, I hope that makes sense. Yeah. So maybe we'll leave it up. And by the way, I'm going to stick around.
01:06:08.514 - 01:06:15.300, Speaker A: So these are long conversations. I'm happy to kind of have these conversations also after the talk.
01:06:16.230 - 01:06:24.038, Speaker C: Hi Prof, thank you very much for the talk. I have a question actually about the third application that you meant, the obfuscator one.
01:06:24.124 - 01:06:25.046, Speaker A: So I just want to make sure.
01:06:25.068 - 01:06:34.694, Speaker C: You understand it correctly. So the purpose of that is to protect a contract from everyone to see such that hackers and not quite so.
01:06:34.732 - 01:06:37.538, Speaker A: On the chain, everybody can read the code of the contract.
01:06:37.634 - 01:06:37.894, Speaker B: Right.
01:06:37.932 - 01:06:42.014, Speaker A: The contract gets posted on chain in the clear. Everybody can read the code.
01:06:42.212 - 01:06:42.862, Speaker B: Yeah.
01:06:42.996 - 01:07:03.218, Speaker A: What we want to do is we want to write the code in such a way that even if you can look at the code, you can run it yourself. You can do all sorts of things that you have the code. Even if you can look at the code, you still can't extract the secret key from the code. The only way to generate a signature is if the code says that it's okay to generate the signature. That's the goal. Okay.
01:07:03.384 - 01:07:05.910, Speaker C: What's the applications that you see?
01:07:05.980 - 01:07:06.166, Speaker B: Yeah.
01:07:06.188 - 01:07:54.030, Speaker A: So, for example, imagine you're building a bridge to bitcoin. If you want to build a bridge to bitcoin, then somehow you need to sign a message saying telling the bitcoin side of the bridge it's okay to release funds. And so the way you would do that the only way we know how to do that. And again, by the way. This is because Bitcoin is too weak to verify zero knowledge proofs. The way we do that today is basically we have off chain parties that sign that jointly use a threshold mechanism to jointly sign a message saying telling Bitcoin, yes, it's okay to release the funds. We could get rid of those parties if we had a contract on the Ethereum chain that says, yes, it's okay to release yes, here's a signed Bitcoin transaction that says it's okay to release the funds.
01:07:54.030 - 01:08:16.214, Speaker A: To do that, we have to have a signing key on the Ethereum chain. But if we put a signing key on the Ethereum chain, everybody can just steal it and just issue signatures on their own. So we have to be able to hide the signature key inside of a contract, inside of solidity code, so that you can't just steal the key. You can only generate a signature if it's a valid if the conditions are satisfied for that signature to be generated.
01:08:16.342 - 01:08:17.162, Speaker C: Okay, I see.
01:08:17.216 - 01:08:18.154, Speaker A: Okay, got it.
01:08:18.192 - 01:08:18.394, Speaker B: Yeah.
01:08:18.432 - 01:08:46.942, Speaker A: By the way, this is specifically for bridging to Bitcoin. If you're bridging between blockchains that can verify zero knowledge proofs, there are easier ways to build bridges that don't require a set of. So I'll leave it at that. Thank you. Yeah, for sure. Hi, Christophe from Pimlico here. How comfortable are you embedding the future of block building on SGX? I see.
01:08:46.942 - 01:09:20.750, Speaker A: That's a very good question. Wow. Okay, so I am not comfortable at all. Let's just say the reason I say that is because, first of all, some blockchains who relied on SGX have already gotten bitten by the SGX vulnerabilities. I can tell you that in many security conferences now, there are entire sessions devoted to SGX bugs. I think it's a wonderful idea. What intel tried to do is a wonderful idea, but it's a very difficult problem to solve.
01:09:20.750 - 01:10:17.086, Speaker A: I would say that if we're going to rely on hardware enclaves for security of a blockchain or for security of an Mev system, for example, I would probably think about using dedicated hardware enclaves for that. So by the way, you notice I use the word hardware enclaves, not SGX. SGX is just an example of a hardware enclave, but there could be many others. And in fact, one of the things that I'm excited about is the fact that the blockchain space is now generating interest in hardware enclaves actually suggests that there's opportunity for startups to go and build more secure hardware enclaves. Yeah, this is an opportunity for all of you, right? We don't need to rely on SGX, on Intel'sgx. We can build, like, separate coprocessors that would sit as a card on a device or maybe as a separate machine. That all it functions as, a hardware enclave.
01:10:17.198 - 01:10:17.474, Speaker B: Yeah.
01:10:17.512 - 01:10:34.742, Speaker A: Why don't we just build one that's custom made for that task and is much harder to break? So is that how you think Flashbots should move forward after mev? Boost is using hardware know that's a that's a long conversation. Why don't we take that? Let's do that conversation. Thanks.
01:10:34.796 - 01:10:35.400, Speaker B: Yeah.
01:10:36.170 - 01:10:42.118, Speaker A: Great question. Lucas from Plurget here. Earlier in the presentation and the Q A, you talked about quantum resistant blockchains.
01:10:42.134 - 01:10:46.250, Speaker D: So I was wondering if you could go more in depth out of curiosity into quantum attacks.
01:10:47.390 - 01:10:49.894, Speaker A: Well, maybe I'll talk about quantum defenses.
01:10:49.942 - 01:10:50.118, Speaker B: Yeah.
01:10:50.144 - 01:11:04.026, Speaker A: So there are post quantum digital signature systems. In fact, I hope many of you know that the National Institute of Standards ran a competition or ran a process to choose post quantum crypto systems.
01:11:04.058 - 01:11:04.206, Speaker B: Yeah.
01:11:04.228 - 01:11:36.838, Speaker A: And they have, in fact, standardized there are standardizing on a number of post quantum systems both for key exchange and for signatures. And so if you need to use post quantum signatures now, there are ones, there are concrete proposals that are available on the NIST post quantum website. One thing I would say is for signatures, for example, software updates, the software update mechanism, the way we update everybody's software, that's a process that's heavily dependent on signatures.
01:11:36.934 - 01:11:37.580, Speaker B: Yeah.
01:11:38.110 - 01:11:56.442, Speaker A: And that's a process also where the length of the signature doesn't matter so much because I'm sending you megabytes of a software update. It doesn't matter if I add a few tens of kilobytes for a post quantum signature. I would say that that's kind of a target for the first application of post quantum signatures just for software update mechanisms.
01:11:56.506 - 01:11:56.686, Speaker B: Yeah.
01:11:56.708 - 01:12:17.080, Speaker A: So keep that in mind. Also, if you're building a software update mechanism for your wallet or for whatever it is that you're distributing to end users, that's a place where you should use what are called hash based signatures that are very trusted to be post quantum resistant. And like I said, one of those is already available as part of the NIST process.
01:12:18.250 - 01:12:18.614, Speaker B: Yeah.
01:12:18.652 - 01:12:29.770, Speaker A: So we know how to do it for key exchange, we know how to do it for digital signatures. And so we're literally just waiting. It's going to take another year or two for the NIST standards to come out.
01:12:29.920 - 01:12:30.186, Speaker B: Yeah.
01:12:30.208 - 01:12:34.334, Speaker A: And then the primitives will be ready for everyone to use. So that's where we are.
01:12:34.532 - 01:12:35.374, Speaker B: Yeah.
01:12:35.572 - 01:12:36.430, Speaker A: Excellent.
01:12:37.250 - 01:13:08.200, Speaker D: Hey, professor, thanks for the fascinating talk. Brandon yeah. So it seems like in the proactive refresh scheme, you're taking advantage of the property of time, which is that there is some minimum amount of time t that an attacker would need to exactly right. Is there any encryption research or scheme I've always been curious about this. That takes advantage of that property within the encryption of the data itself. For example, can you encrypt data using a scheme s such that even if you had the key, it's only valid for some time t?
01:13:10.890 - 01:13:28.650, Speaker A: The opposite is possible. We can make it so that I can encrypt data to you so that you will not be able to decrypt it until time t has passed. Right. So that we can do that's called, basically time lock encryption. Where I can encrypt to the future. You have to spend time t before you can decrypt.
01:13:28.730 - 01:13:30.106, Speaker D: Can you do the inverse where it's.
01:13:30.138 - 01:14:03.494, Speaker A: Only so the inverse, I think, is where it's only decryptable for time. T the inverse is not possible by cryptography alone, but it would be possible, for example, using hardware enclaves, you can imagine the key would live in a hardware enclave, and after a week, the hardware enclave will just erase the key. And now you can no longer decrypt. Right. Or via sharing, where enough parties would erase the key, then you can no longer decrypt. But cryptography by itself can't do what you said. There needs to be some auxiliary mechanism that makes it possible.
01:14:03.612 - 01:14:04.038, Speaker D: Got it.
01:14:04.044 - 01:14:04.214, Speaker B: Okay.
01:14:04.252 - 01:14:04.614, Speaker D: Thank you.
01:14:04.652 - 01:14:04.854, Speaker B: Yeah.
01:14:04.892 - 01:14:05.958, Speaker A: Great question.
01:14:06.124 - 01:14:06.454, Speaker B: Wow.
01:14:06.492 - 01:14:18.380, Speaker A: This is a fantastic set of questions. Thank you so much for all the questions. And as I as I said, I'm really, really excited about everything you're building, and I'm really looking forward to seeing to seeing your projects in the future. So thank you all very much.
