00:00:10.570 - 00:00:57.070, Speaker A: About evaluating crosschain messaging protocols. But I think, like the more important topic, especially piggybacking on kind of the first two conversations, just building protocols in general in the space. And I think it's both ways how you look at protocols you're interacting with and how you think about building your own protocols along the way. So the current kind of state of the world of cross chain messaging, as Naz and Riaz just went through, is a little bit hectic in terms of like a lot of the hacks have kind of revolved around that. You see exponential growth in the protocols themselves. We've gone from all messaging protocols collectively doing tens of thousands of messages per month to single applications doing millions of messages per month. And that's just been in about a year now, right? So tremendous, tremendous growth.
00:00:57.070 - 00:01:36.122, Speaker A: Proliferation of L two S has only accelerated this and that's, getting crazier with Base and ZkSync and everything else coming out right. That layer of horizontal composability is expanding rapidly. Unfortunately, the same trade off and how these systems are being built right now is like increasingly centralized systems. So most protocols, when it comes to messaging, I go to this topic of service versus protocol. Most of what you're getting from many of them is you're opting into a service, right? There's a third party service. They're not building like a protocol. You're relying on an individual set of actors to basically perform this messaging for you.
00:01:36.122 - 00:02:42.942, Speaker A: And if for any reason they fail or they turn malicious or like all of these other things, there's just this vector of one entity that controls it and provides this for you. So, like Ali was talking about earlier, there is this trade off where early on those systems will be more performant, but they have a much higher failure rate and there's a lot of other things that go into that. And so right now we often see risk traded for ease. So when you're evaluating a crosschain messaging protocol, or just any protocol in general, and how I think or we think about building protocols, there's really like three things that are fundamental to most things in this space, and it's immutability, permissionlessness and censorship resistant. Those three things, I think, are the foundation of almost every super successful protocol in the space and really kind of the earliest catalyst for why the space exists in the first part. So first one is easy immutability. Why does it actually matter? So going back to the Nomad hack, the Nomad hack has this interesting system.
00:02:42.942 - 00:04:03.254, Speaker A: You have optimistic messaging, you have all this stuff that's sort of meant to be this security vector in improving how the system works. But the end of the day, they had the ability to push underlying code, right? So they could update the code in the contract at any point in time, which completely changes the spectrum of security that the end user or the application building on top has. So when you talk about how do you actually think about evaluating the security of a protocol? You can do things that give you a better indication early on so you can get audits, you can have rigorous internal auditing process, you can have external bug bounties to make sure that there are white hat eyes on this, that basically there's been enough time for people to look at it and try to break it. And it stood the test of time. But ultimately, if you look at any system in the wild, it's really how much value has been secured and how long has it existed for? Why is Uniswap as a mechanism seen as so much more secure? As a dex who takes liberties and spins up something entirely new, right? It's really because the contracts for Uniswap have been securing tens of billions of dollars for many years now and have never had a security issue, right? They're not upgradable, they can't be changed. It is a set of things that exist and everybody knows what they're opting into. In most protocols you see when they launch, TVL grows over time with the most successful.
00:04:03.254 - 00:04:55.274, Speaker A: Ave certainly did not launch with $30 billion of TVL. It launched with a small amount and overall over time as it hardens, it increases. And so I think the best ad hoc measure is simply value secured amount of time. How big of a honeypot has it been and how long has there been for bad actors or good actors in the case of white hats, to come and try to basically do this? What has their incentive been? So the issue with Immutability is this anytime you upgrade a contract, you basically lose all security. So you have this billions of dollars secured, it's been around for a year, you're in a great state, you push a change of code that may seem completely benign and security goes back to effectively zero. And this has been time and time and time again. I actually think in the last six months we've probably seen four to five major examples of exactly this.
00:04:55.274 - 00:05:31.398, Speaker A: And so again, these are like the vector of the validator set is malicious and they're actively trying to exploit you. And the crypto economic system has been broken. That has basically never happened or almost never happened in all of these hacks. What has happened repeatedly is I'm a dev and I want to make an upgrade to the system, so I'm going to push some code. I'm not trying to hurt anybody, I'm just trying to make the system a little bit better, add a new feature, do whatever. You don't necessarily understand all the interactions that that brings. You've missed something, the auditors have missed something and all of a sudden everything's gone right.
00:05:31.398 - 00:06:18.338, Speaker A: Which was the case in the Nomad hack. They pushed something again that was extremely benign and just forgot to check for the zero address. And then everybody could just repeatedly perform this attack. And so when you have the ability, any protocol, especially messaging, if it has the ability to upgrade the contracts and the underlying, it will always be an existential risk for the applications building on top. And this is the same way if uniswap had the ability. Like when I talk about Immutability, I think uniswap is honestly the gold standard. So when uniswap migrates from v one to v two and v two to v three, it is painful and miserable to try to coordinate tens of billions of dollars moving from one contract to another, right? There's this massive social coordination effort.
00:06:18.338 - 00:07:00.626, Speaker A: You are now in something that they view as less efficient, possibly less fee efficient for the LPs. And if they had an easy button that they could press and auto migrate like 100%, they would do that. But if they had the ability to do that, then the relationship they have with the LPs and the underlying stake is drastically different. Right? Nobody would trust the protocol because they would have the ability to move your LP at any point in time, which means they could effectively have malicious rug your funds. And so the reason it becomes so trusted is that they do not have this ability. And so, yes, when you go v two to v three, v two still has billions of dollars in it, right? They want everything to be in v three, but they don't control it. That's fine.
00:07:00.626 - 00:08:10.554, Speaker A: You make a system and the market sort of decides what the best system is. But the code stands for itself and has stood the test of time at scale. And so if we don't accept that in applications that we regularly use, it's crazy to me that that becomes common practice at the messaging level. So again, almost 95% of messaging protocols today are completely upgradable. They have the ability to change the underlying way that the validation system works, that the contracts do authentication, and that again puts every single application at the risk of a completely benign piece of code being moved and the whole security state changing for the application. So I think of all things that you can consider that should be the number one thing is are the contracts mutable or Immutable? And if they are upgradable, like, what surface is exposed to me? Because even the best developers, it is very hard to write good code, let alone perfect code. And so over a course of time, any good developer will make a mistake at some point in time.
00:08:10.554 - 00:08:38.690, Speaker A: And if that can repeatedly change you're just like you have tail risk and on a long enough time frame, something will always go wrong. So Immutability, I think is like the number one principle for this number two principle permissionlessness. This is like great examples of this. Well, obviously uniswap great. Anybody can LP, anybody can trade the entire system. Is there's no gatekeeping, there's no whitelisting for who can make a pool on uniswap who can LP. Ethereum is very much like this as well.
00:08:38.690 - 00:09:20.378, Speaker A: Anybody can spin up a node, anybody can participate in the network. There's permissionless application deploy, anybody can deploy a contract on Ethereum. You don't need to go to the ETH Foundation and ask permission. You don't need to get whitelisted to do anything. Systems today are increasingly sort of bifurcated in how they're built along the spectrum. But permissionlessness itself is just another vector of security, right? Ultimately, if there are so again, I'll keep going back to the Nomad case, but there were the watchers in all optimistic systems are like this but the watcher set was not permissionless, it's this whitelisted set of watchers where only a certain number of people could. So you had two or three watchers that have the ability to go down to potentially be DDoS.
00:09:20.378 - 00:10:16.290, Speaker A: There's all of these complications and there's reasons why that system was built that way because it's very hard to make a permissionless set in that and still keep liveness. But anytime you don't have permissionlessness, what you lose in the system is the ability like TCP, IP, like all of that, the ability to have the adoption and the network effects go. You want to create a protocol that has the ability for anybody to participate in, anybody to build on. And one of the big things is back to immutability of like without immutability, permissionlessness doesn't exist. You can always change it. So there's whitelisting, you can always gatekeep, you can always do things and that itself becomes a huge problem in the next step, which is censorship resistance. Because our principle when building is basically if you have the ability to censor, it will always be enforced, always.
00:10:16.290 - 00:11:05.562, Speaker A: Like even in the most free and open system, possibly the entire world right now, which is effectively ethereum. You look at what the validators have to go through right now in terms of basically removing blocks and doing governmental things that are mandated down. If you have the ability in the code, in the contracts to enforce any sort of censorship, it will always happen. And there are a ton of reasons why as application developers that you don't want this, right? So one is the ability to reorder transactions. So already there's mev that sort of like exists in every system you have submit a transaction, there's a mem pool, there's value that can be extracted there and that's chain specific, you're not going to change that. You're not going to basically reduce that surface significantly. What you don't want when thinking cross chain is you don't want to add to that surface.
00:11:05.562 - 00:12:04.862, Speaker A: So any set of validator and again, every single messaging protocol in the world except one right now, I won't say which one, but every protocol in the world right now has the ability to do this, which is really important. They have the ability to reorder transactions in the middle, which means there's no guaranteed delivery of transactions. But it also means, like, if you think about what high frequency trading has done to traditional markets, great. You see a trade pop up here, and then you race that person to another market to take the value to front run them. This is you now own the layer of how messages get delivered. And instead of just like trying to beat them, you can literally reorder them all so that you can exploit the maximum amount of value based on the order that they're submitted, which is an unbelievably large surface of value that can be extracted on top of the on chain mev. And so now that itself, you very much want non sorter enforcement.
00:12:04.862 - 00:13:16.694, Speaker A: One, because of the financial constraints, if you're doing anything that's a financial application, there is a huge amount of value that will be extracted from all of these messages, from being reordered. And lots of these protocols are even moving in the direction of that being like part of the protocol, like flash bots for crosschain stuff, but it's at the messaging layer in the middle. But it also means that there is the ability to censor transactions, there is the ability to take a governance vote that's going across. And you can think if you were ever building a system for votes within an electoral system, right, within any political system, the ability to even just the possibility of losing votes, the possibility of removing a vote that you don't want, you can see how quickly perverted that could become and what that could devolve into. And any ability to censor not only will likely be exploited, but will be forced to be enacted. So I think censorship resistance at its core is incredibly important. This, again goes back to immutable contracts, right? You deploy Uniswap, and for some reason the government at some point in time, the government of Belgium says no more dog coins.
00:13:16.694 - 00:13:47.222, Speaker A: Like dog coins are outlawed. You can't put them in there. Like uniswap can't change that code. There's nothing that they can do. The next version might have something. But the system that is built and it's constructed in a way that sort of aligns with the ideological world of the system that was being created cannot be perverted sort of later on down the line. Which again, I think is incredibly important because without that things will get very restricted very fast.
00:13:47.222 - 00:14:28.978, Speaker A: And obviously as you're building the systems, you need to build them in such a way that complies with current standards at a global scale always. I think it's an increasingly sort of like complex surface to consider. But if you leave it open to, again, the ability to change the way that it functions, it's going to drastically change how people interact with that. And so, once again, without immutability censorship, resistance is never guaranteed. If you can add it in later, somebody will add it in. If you can enforce censorship, it will always be enforced at some point in time. So we'll go to the bulk of the conversation, which is really like building a better system.
00:14:28.978 - 00:15:31.026, Speaker A: So as you build and this up, there is like, our method to do this, but how do you build a system that is immutable, is permissionless, is censorship, resistance? And how do you not get stuck in all of these sort of like, local quagmires? So one of the trade offs that you guys were talking about with Nas and Riaz is like, what happens if something bad happens, right? The ability to pause a contract, the ability to change state over time. How can you live in a line that gives users some form of protection, but also gives users protection from you? Like, ultimately, if you're building a protocol and not building a service, or if you're building a service, your service provider is great. There's lots of services. We all use every day. If you're building a protocol, the underlying user or application developer who's building on top of you should not like, if you disappear, if you go away, if something happens to you in the team, that protocol should still exist. The inventor of TCP IP doesn't change the current state of TCP IP. It exists.
00:15:31.026 - 00:16:02.654, Speaker A: It's a protocol. It's used at scale. It's adopted. If you are intentional and malicious and as adversarial as humanly possible, the underlying user shouldn't need to care that much. Like, if the Uniswap devs decided all they wanted to do was try to harm the users of Uniswap, there is nothing that they can do. Literally, they can turn on the fee switch, right? That is the surface of control that Uniswap has, is they can add an extra five bips on a fee switch there. And that is incredibly important because if you want to get adoption, you can't leave that surface there.
00:16:02.654 - 00:16:32.634, Speaker A: And so at the same time, it's completely at ODS with something bad is happening in Nomad, and I want it to stop, right? Can somebody please save this? And so I think you have people on both ends of the spectrum. Uniswap is if there was a bug in Uniswap, there's nothing that can be done, right? It's completely immutable. There is nobody who can pause it. There's nobody who can save the LPs. It is a piece of code that is meant to stand the test of time. And if something is wrong, it's going to be a race between LPs getting out and people exploiting that. That's just the fact of the case.
00:16:32.634 - 00:17:06.774, Speaker A: But that has allowed uniswap to become as incredibly successful as it has. So how we think about it internally and one thing that I think is an interesting trick, time locks. There's a couple of things you can do to like, okay, this can change, but everybody has some heads up and can opt out of the system while this is changing. So that was kind of like the first surface of, like, we can upgrade code, but you're going to have a seven day heads up, so feel free to flee if you want. Now, that's probably fine. Maybe that's fine for something like a Dex, like a uniswap, where, okay, seven days, I can remove my LP. I've heard about this.
00:17:06.774 - 00:17:58.742, Speaker A: Great. If you're a messaging protocol and somebody has built their entire business on top of you, their protocol is like, they need to shut down their protocol and flee redeploy, like, do something. It's catastrophically bad to have that. So the way that we thought about when doing this is basically having an append only library of validation libraries. The bet that we were making as we were building is, listen, we want to get this part right of what this protocol looks like, the IP, right? The TCP IP structure. Like, what does messaging look like, what does the protocol look like? What we're not convicted on is whether or not it'll be Ethernet or broadband or Wi Fi or all the things in the bottom half of Ali's funnel there, right? And so for us, that's the validation library. For us, we said whatever exists right now in the state of validation library is very, very unlikely to be de facto five to ten years from now.
00:17:58.742 - 00:18:34.526, Speaker A: Like, almost certainly will not be. And there's unbelievable amounts of research happening with zero knowledge proofs with all of these advancements in the validation technology. And so what we did is you make validation libraries published. We have about five published right now. You can always publish new ones, but you can never modify old ones, and you can never make people force them to move off of an old one. So what it gives is every application the ability to opt in to existing sets of contracts. The security is static if you've chosen it to be static, but it allows the protocol to innovate and continue to push features.
00:18:34.526 - 00:19:17.386, Speaker A: So you're starting to see more and more systems start to walk a line like this, where there is some form of proxy, there is some form of the ability to add a surface, but it is entirely opt in, and it cannot affect prior applications. And I think that is, like, an incredibly important thing to think about as you're building your protocols and as you think about doing this. You don't necessarily want to build something that you know will 100% be the case. So there's two sides. There's uniswap, which is V one, v two, v three. We're going to launch an entirely new protocol. Every single time we develop something new, everybody will need to migrate, move to a new system, and the old system is dead.
00:19:17.386 - 00:19:58.586, Speaker A: And again, for LPs, that's, like, not really that hard to do. It's not really that bad of a system, and it can function for a messaging protocol. When you're thinking about what you're building on top of, you are, like, very anchored there, because if you have the ability to easily change messaging protocols. You can simply point it to yourself and rug everybody, right? Like the application has that ability, then the user is basically absorbing the risk of the application security parameters. Basically, if the application can change from protocol A to protocol B of the messaging layer, you just spin up something malicious of whatever multi SIG it is to control. Point to your own messaging layer and say yes, I definitely put a billion there. Give me the full billion on this side.
00:19:58.586 - 00:20:52.406, Speaker A: And so you want the ability to add feature sets, but you don't want the ability to basically make that possible because the user won't bear it. And again, this is not like you should think about it in a way of like yes, this is how you should build systems. But even from the most greedy possible internal perspective, if you look at everything that has gotten massive adoption in the space, everything that's been built on chain with that, as soon as you have that risk to the underlying user, the relationship changes completely. So again, you look at Uniswap, you look at Aave, you look at Ethereum, you look at all of these, all of these are built in these same exact principles. All of them are structured in the same exact manner. And I think as you're evaluating which crosschain protocol to use, this is the framework you should use for valuation. And I think most as you look, the big flags you will see is upgradable contracts.
00:20:52.406 - 00:21:28.994, Speaker A: The ability to upgrade contracts means your security is completely non static and will be changing frequently in the future. If the pace of upgrades right now is sort of existing permissionlessness, if it is a whitelisted set. Again, there were two things on the nomad side. One, the watchers are whitelisted. Two, actually the person who pushes the updates for actually posting the route was completely whitelisted as well. So you have like in, in non permissionless sets, you have severe liveness issues and then you have also security issues. And then third is censorship resistance.
00:21:28.994 - 00:21:59.890, Speaker A: Again, if you're doing something that has any surface of again, governance is like a very good example, but a bunch of other cases, if you can censor transactions, if you can reorder transactions, it will be done and it is already being done in the background, but soon to be in the foreground. Again, this is something like people are openly adopting in the way that some modern protocols are kind of openly adopting MEB extraction at them pool level being commoditized into the protocol. So, happy to answer any questions anybody.
00:21:59.960 - 00:22:08.978, Speaker B: Has in the cross chain Bridging architecture. How do you mitigate the risk of the off chain components of Bridging in addition to the Immutable contracts?
00:22:09.074 - 00:22:36.730, Speaker A: Yes, no, I think it's a great question. Okay. We actually changed our stance around this a lot. When we first launched our paper. We basically said trustless messaging protocol, right? Our stance was that from the application level you could achieve true trustlessness by the following method. Basically, some transaction happens on source. You break apart that state into two pieces, sort of block header and receipts route.
00:22:36.730 - 00:23:13.302, Speaker A: You move this state across some parties, it can be X. Number of parties move the state across it's reassembled merkel inclusion proof happens on the destination chain. Validated message is passed to contract if you give the application the ability to opt into running one of those components themselves. So again, completely open and permissionless system. If you're an application, if you're a uniswap and you're doing cross chain transactions, if you run just one of those components yourself, you now have complete veto rights. So no malicious transaction can ever go through unless you sign off on it. So you have 100% veto, right? Even if every other validator in the network is completely malicious, you are safe.
00:23:13.302 - 00:24:11.002, Speaker A: And at the same time, if you are compromised, if your off chain infrastructure is compromised, you're backstopped by the rest of the network. Right? So that was a way that we thought about it and like, okay, this is how you an application building would want to structure trustlessness. What we didn't consider at the time is that the user does not inherit that same set of trustlessness, right? This is trustless at the application level, but the user using it now trusts the application. So fast forward two and a half years of thinking about literally nothing but this. I am 100% convicted in the fact that there is no true trustlessness in any system, in any messaging protocol. And this includes another sidebar we can have is talking about a lot of the forefront right now is the research in zero knowledge proofing and messaging. Like how that actually affects, and I think it's an extremely interesting topic and how that structure is and actually the lack of trustlessness in it and sort of like how misunderstood it is.
00:24:11.002 - 00:24:48.338, Speaker A: But there are things that you can do to reduce the surface. So one thing that ZK stuff does that's really good is it reduces the surface of where the attack can come from. So you have a pure open, you know, basically you have some amount of economic stake. The value that's being transacted or exposed can never exceed that economic stake. Right? Or then you just sibyl it and you basically collude to exploit the network. So that is the overall risk. By zero knowledge stuff you reduce the set of bad actors to now they are the Ethereum validators and they're part of the sync committee.
00:24:48.338 - 00:25:20.174, Speaker A: So now there's like a limited set and it's because Ethereum is so broad and decentralized it's harder to get a set of those willing to collude. My counterargument is like Flash bots is literally large scale validator collusion in production at like 60% to 70%. So you reduce the surface of that. So you can do some things to make it limit. Who the bad actors are, but it still doesn't change the underlying risk. So there will always be some form of risk at the off chain level. Ultimately, you're mutating some state on a destination chain based on a belief state of source.
00:25:20.174 - 00:26:20.406, Speaker A: And the destination chain has no observability into true canonical state on source. So in a proof of work system, it's easy, right? There's a fork and you're frozen at a point in time and you just grab a block. It doesn't matter which one the uncle or what ends up being canonical. Like at a certain point of time, they're both canonical and the destination chain will never know which one actually was, right? So you can wait a certain amount of time and you can measure block height and you can do this, but you sell people are like reporting these things when it comes to ethereum transactions and state proofs. Like, great, I can fork the chain, I can mutate some state, do some transactions on that, and then take that and report it over there, right? And so this was kind of the whole premise of ZK stuff was, okay, now we'll make sure that the right people are signing the message or signing the message. So there are ways, again, that you can limit surface, but you'll never remove it completely. The best thing you can do is choose a validator set that either you have participation in, your stakeholders have participation in.
00:26:20.406 - 00:27:20.150, Speaker A: So like, one thing is, again, imagine Uniswap governance is going across chains, right? Uniswap governance already has some. I guess ave governance is a little bit of a better, a little better because Uniswap governance has limited control of what they can do, right? They can add and remove people and flip on the fee switch. Ave governance has the ability to change risk parameters, which means if they mess it up, you basically can blow up the protocol, right? So it's like very important. And the protocol already trusts that group of validators a ton, right? So now take those same people and say, okay, we're going to do something cross chain. How do we do this without extending the surface of risk at all, right? We have a surface of risk. Now the goal is don't compound that by introducing a new surface of risk. So if that same set of validators ran one of these off chain components, ran a cohort of like, okay, we're going to run a little network of this and the same people with the same economic stake are validating that then that basically means you have the minimum viable security of exactly what you already have.
00:27:20.150 - 00:27:26.474, Speaker A: And so that is like the best case suggestion, I would say, to minimize it. But there is no way to eliminate it completely.
00:27:26.672 - 00:27:39.306, Speaker B: Yeah, it makes a ton of sense. It seems somewhat analogous to the sequencer problem with kind of roll ups and data availability. And I wonder if that distinction between ZK. And optimistic plays a role here where you could use fraud proofs or some other mechanism.
00:27:39.418 - 00:28:01.110, Speaker A: Yeah, okay, now we can get in here. This is a conversation I like to have in a roll up. One of the really nice things that you have and what makes a roll up a roll up is that you have a canonical contract that lives on Ethereum. Right. There is a source of truth that lives on chain. And if you want to validate a fraud proof you validate against that. Everything that's on the L two is rumors.
00:28:01.110 - 00:28:42.034, Speaker A: The canonical contract is the source of truth and that is the only source of truth. And so anybody can submit to that that maintains the total state. And if you're going to run a fraud proof you simply basically run an on chain geth client and run it against that and you can validate state. Now the ZK stuff, the goal was great. We're going to basically take the people who sign this block and because they have economic incentive to sign the block canonically on Ethereum, then they'll move the block over to the destination chain to roll up wherever this is going. And we can trust that state is the same because otherwise they'll get slashed. So it has as much security as Ethereum has.
00:28:42.034 - 00:29:08.198, Speaker A: Right? That's theory of zero knowledge messaging. The problem is what they can do with zero economic penalty is you can create a canonical block on source that is honest and valid. You create the correct block on Ethereum at the same time the validator set in secret amongst themselves creates a completely malicious block. They create a snark of that block so the block is thrown away. Nobody sees it. You can't get slashed. You present the block to the destination chain.
00:29:08.198 - 00:29:29.694, Speaker A: The destination chain has no idea which is the true canonical state. So they just accept this malicious block and now that attack is basically affected, right? And so in all messaging anything. So again, canonical contract, source of truth lives there. Great. Everything happening on the l. Two rumors. Everything happening on other chains.
00:29:29.694 - 00:29:53.394, Speaker A: Rumors. There is somebody who needs to move that state and the person who can move the state can manipulate the state. You can reduce how many people can manipulate that state. You can make sure it is the same people who are validating on Ethereum or on whatever chain but you cannot remove their ability to do it. And that is only because the destination chain cannot read directly from source it doesn't know canonical state. Awesome. Well, thank you so much, Brian.
00:29:53.394 - 00:29:54.130, Speaker A: That was fantastic.
