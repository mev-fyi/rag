00:00:06.330 - 00:01:00.794, Speaker A: You. So I am going to focus this talk on giving an introduction to selfish mining. Okay, so what's my goal? So I'm going to spend the first portion of the talk just giving a clear introduction of selfish mining. So selfish mining is this attack that was discovered now, maybe eight years ago specifically for Bitcoin. And it refers to just some way that you can not follow the longest chain protocol and you can make some extra money if you have sufficient hash power to do so. And what I'll do is just dive straight into that. What I want to focus on is I'm going to present a formal model where this analysis was done and I'm going to show the analysis technique.
00:01:00.794 - 00:02:29.162, Speaker A: So I am not going to slog through all of the calculations to get the result, but I am going to show you kind of like the interesting part of how to set up the calculations for that. And then afterwards I am going to kind of at some pace, rush through some subset of what I write on this slide for what's happened since this attack. And what I am most comfortable presenting is, okay, so here's first some follow up work that came soon after, which gives an alternate analysis technique that I think is super useful for follow up work. So I will also briefly overview that analysis. And this analysis is useful because this alternate style actually lets you find the optimal strategic deviation, not just this specific one that's called selfish mining. But then since then, sort of like one of the things that I've been involved in is we asked sort of like, well, what if you took Bitcoin, but instead of having the block reward, you had transaction fees? How does that change the strategic behavior? It turns out it changes it a lot and said like, well, what if instead of having a proof of work based longest chain protocol, you have a proof of stake based longest chase protocol? And so it turns out that changes it a lot too. And so if I have time, I have basically just created quick slides where I said, here's the change in the model, here's the new result.
00:02:29.162 - 00:03:23.100, Speaker A: And there's no proofs or analysis or anything for that. So if I have time at the end, I'll try and just give a taste of those. Okay, so now I'm going to dive right into selfish mining. Hopefully what I guessed everyone's background is was close to correct, but definitely feel free to interrupt with whatever questions are needed. Okay, so here is a quick recap of when I talk about being strategic in Bitcoin. So what are things that you can't do in Bitcoin? So you can't be strategic by forging transactions, right? To do that, you would need to be able to break digital signatures. You can't be strategic by retroactively changing the contents of a block, because in order to do that, you would need to break the security of the hash function that's being used.
00:03:23.100 - 00:04:52.870, Speaker A: So there's a lot of strategic deviations that you don't have to worry about because state of the art cryptography is great and because we have good cryptography, these issues are not a serious concern for bitcoin. Now there are things you can do, right? So the bitcoin protocol says when you create a block, please add a pointer from your block to the existing longest chain. And another thing that the protocol asks you to do is when you create a block, please broadcast it to the entire network right away. And another thing it asks you to do is it says please include as many transactions as possible and subject to whatever block size limit there is and please prioritize transactions that have paid higher fees. Now these are actual decisions that when you create a block, you can choose to follow that protocol or you can choose to do something else. And the only way to reason about this is by reasoning about the incentives that it gives the miners. There's no amount of cryptography like these are not cryptographic problems or security problems to solve, right? There's no amount of cryptography or a clever security protocol that's going to force someone to broadcast something immediately or that's going to force them to have heard about some block, right? The reason that you can point to any block is because maybe as far as you knew, that was the longest chain because you didn't hear about something that was broadcast later.
00:04:52.870 - 00:05:46.358, Speaker A: So these are inherently incentive problems. Okay, so what I want to do on this slide and then I will pause a little bit for discussion to make sure that this is clear is just try to abstract away a lot of the security details and latency details and all of that from how bitcoin really works and try to just zero in only on the incentives. Okay, so what's the setup for the game? So there's a set of miners. Every miner has some fraction of the mining power. Okay, that's just saying that there's some distribution of mining power and X is denoting that at all times. Every minor has some directed tree of blocks, right? So the tree refers to every node in the tree is a block. There's an edge coming out of it pointing to the block it's pointing to.
00:05:46.358 - 00:06:37.900, Speaker A: And they all share the same root. And I'm just referring to the distinction between there's blocks that have been created, but maybe minor M hasn't heard of them yet, maybe because they haven't been broadcast and the ones that minor M is aware of. So I'm just using G of M to refer to that. So what's the actual game? So what are the strategies that the players have? So a random miner is selected to mine proportional to their computational power. What do you do when you mine? When you're selected, you create a node that's the new block you just made and you add a directed edge to any other node that you've heard of. And again, you are allowed to pick any node that you've heard of. The game would like you to pick the long, but the actions you can take are anything.
00:06:37.900 - 00:07:29.434, Speaker A: Also, each time step you have the option to broadcast any nodes that you've created or heard about to everyone else, to simplify the latency and not worrying about what happens if someone hears about something before someone else. What if you selectively broadcast? We're just going to say there's one broadcast action. If you broadcast, everyone hears about it and they hear about it instantly. Okay? And so this you can choose to do, right? So you can create a block and you can choose not to broadcast it, or you can choose to broadcast it. You can choose to broadcast it in a later time step that's okay. And so now what are the payoffs? So the previous bullets that defines the entire game, the payoffs are just at the end of the game, you get reward for every block you have in the longest chain. So let me just kind of parse through this.
00:07:29.434 - 00:08:15.642, Speaker A: So the eventual payoff is just going to say as T goes to infinity, look at the limit of something. What's going on here is there is some longest chain at time T. So among everything that's been broadcast, there's some longest chain that's this. Now, for every minor M, they have produced some number of blocks on the path right on this longest chain that's this. And they get reward. We'll normalize it to one for every block that minor M has created on the path from the longest chain to the root. Okay, now this is the slightly interesting thing is the payoff to the miner is equal to the steady state.
00:08:15.642 - 00:09:12.490, Speaker A: So this is just the limit as the game goes forever of the number of blocks that they create on the longest chain to the length of the longest chain. So it's not just the number of blocks they create, it's specifically the ratio of the blocks they create to the length of the longest chain. Okay, so let me quickly go through. So I will pause on this slide for questions about the model. But first I just want to state why did we choose this specific reward function? Okay, so first remember that in Bitcoin there is a difficulty adjustment. So what that means is that bitcoin is set up so that whatever strategies the miners happen to use, if it creates orphans, creates more orphans, less orphans, whatever. There is one new block on the longest chain produced every ten minutes in expectation.
00:09:12.490 - 00:10:01.350, Speaker A: So what that means is that the rate at which the longest chain grows is one block per ten minutes. And so in particular, that means that if I look at dividing by the length of the longest chain, this is proportional to physical time so if I'm interested in understanding something like how much bitcoin are you making every ten minutes that number is, how many blocks are you getting per extra one length of the longest chain? Okay, so that is a huge part of the analysis. And so I'm trying to spend a little bit of extra time motivating specifically. Why this fraction instead of just this sum?
00:10:03.130 - 00:10:07.680, Speaker B: Matt, maybe it'd be helpful to just say what would be the first thing right now?
00:10:08.290 - 00:11:14.466, Speaker A: Sure, yes. So what I can say is the first thing that I might try is I might say, let me just look at instead of letting things go to infinity, let me just pick a fixed capital T and say that your reward is just this sum, the number of blocks that you create in the longest chain. Or if I really wanted to let things go to infinity, I might normalize by the number of time steps, right? So I might say, like, well, I mean, if the game goes on for 1000 time steps, I want to look at my reward per time step. And the main thing that I'm trying to point out is that one time step in this game is not equal to ten minutes of real life, because that depends on the strategies people are using. If everyone is being honest and is just building on the longest chain, then it is then one time step in this game means the longest chain grows by one. That means ten minutes have gone by. But if they're doing all sorts of crazy things and maybe half the blocks are being orphaned, so let's stick with that.
00:11:14.466 - 00:11:57.790, Speaker A: If half the blocks are being orphaned, then that means that one time step really only adds two time steps are needed to add one block to the longest chain. So actually, two time steps are needed for ten real minutes to go by. And so what that means is that I'm saying, you know what, let's just put all of that math that we need to do is perfectly captured by just saying that we're going to normalize by the length of the longest chain, because the length of the longest chain is exactly proportional to physical time. And what I really want to capture is how much reward am I getting per unit of physical time? That's a meaningful measure. How much reward am I getting per block that's created? That's not a meaningful measure.
00:12:00.450 - 00:12:06.500, Speaker B: Why is payoff zero if the limit doesn't exist? You're giving a of zero.
00:12:07.830 - 00:12:28.570, Speaker A: Sorry, that's just a technicality. I first made these slides when I was trying to give talk to a very mathematically formal setting, and that's just to be mathematically formal. But you should expect the limit will always exist. There's no reason and all the analyses we're going to do, the limit will always exist. There's no reason to suspect that the limit should not exist.
00:12:29.710 - 00:12:36.882, Speaker B: Matt, could you also comment on the model of the communication network and to what extent it's unrealistic and to what extent care is unrealistic.
00:12:37.046 - 00:13:06.422, Speaker A: Yes. So in this communication model, we have abstracted a way that there's like point to point communication. We've just said when you speak, everyone hears, right? And so that's unrealistic for sure. Right. So I know that's not how the bitcoin network works, right? And just to be clear, there's two things we've abstracted away. One is when you speak, everyone hears. There's no point to .2
00:13:06.422 - 00:14:07.744, Speaker A: is when you speak, everyone hears during the same round, there's no latency. And that latency is not the idiosyncratic. Now, there is a really nice mild, how would I phrase it? Slightly later in the analysis, I will show you how the original authors tried to capture things like latency or connectivity with a parameter. I will hint at how that affects the analysis and how you should interpret that. But one thing I can promise is that the analysis is still convincing. Even if you acknowledge that this is unrealistic, it's not how things work, that basically we're going to be as pessimistic towards the attacker as possible. And when doing this analysis, in other.
00:14:07.782 - 00:14:12.080, Speaker B: Words, like this strong assumption should only make the result stronger, right?
00:14:12.150 - 00:14:15.056, Speaker A: As far as yes, if you give.
00:14:15.078 - 00:14:16.796, Speaker B: Honest notes to the superpower they don't.
00:14:16.828 - 00:15:08.580, Speaker A: Have, even then yes, that's correct. Yes, that's correct. So for the way that I personally like to state the result so again, so I'll mention this near the end, there's a range of parameters and variants of this result that are in the original paper. The one that I find most convincing is that even if exactly, as Tim put it, even if you let all the honest nodes communicate instantly, and you let them have significantly lower latency than any communication that happens with, the attacker even under this assumption. And the attacker can't do point to point communication. The attacker has to broadcast to everyone when they broadcast. Even in these settings, there is still something clever that the attacker can do.
00:15:08.580 - 00:15:48.050, Speaker A: So that's the version that I personally like presenting and that's what I'll present as like the main result. We all know that the real way that bitcoin happens is everyone has these separate mining processes, right? Everyone's mining on their own. Everyone's mining on their own. And then at some point someone succeeds, right? And that is not captured here. I've just kind of said like, well, each time step I'm going to select someone. So related to the previous discussion, I really want to think of a time step as somebody just created a block. That's what a timestep means to me.
00:15:48.050 - 00:16:56.868, Speaker A: And what we know is that because of the way in which bitcoin mining is done, it is still true that even conditioned on someone just mined a block, who that miner happens to be is random proportional to computational power. It's independent of the past and stuff like that. So the first thing I want to do is just sanity check. What is the longest chain protocol in this language? Right, so we've abstracted away all sorts of things, but just focusing on the mining incentives, we said, okay, the longest chain protocol says whenever you're selected to build a block point to the furthest node from the root among those that you've heard of. And there's this subpart that says if for some reason you have to break a tie, break ties in favor of the node that you've personally heard about first. Okay? And you should always broadcast when you create a node, broadcast it immediately. And then prior to this selfish mining paper, okay, so the way that the Bitcoin community operated, they wouldn't have said, oh, here's a formal game, here's a theorem that I believe is true.
00:16:56.868 - 00:18:00.420, Speaker A: But I think prior to the selfish mining paper, it was widely accepted that if everyone else is following the longest chain protocol and you have less than 50% of the computational power in the network, then the best thing you can do is just to follow the longest chain protocol as well. And there was even this correct random walk analysis in Nakamoto's White paper where they considered a specific deviation. So the specific deviation that they considered was, well, what if you just try to make your own chain and ignore what everyone else is doing? And that specific deviation, if you have less than 50%, that's a very bad deviation. You're just going to waste all of your blocks. If you have more than 50%, then yes, you can make your own chain and you can just take all the rewards. So that part was correct, but what had not been previously considered was whether you can do something more clever. And so then this seminal work that's now referred to as the selfish mining paper showed this clever strategy.
00:18:00.420 - 00:18:49.480, Speaker A: And here's the version I like to phrase. So if you have at least a third of the computational power, then there is something better that you can do than following the longest chain protocol, assuming that everyone else is following the longest chain protocol. Okay? And this is the version that I like. The one third is the number that I like remembering. Even if we do everything reasonable against the attacker, but the attacker has 34% of the total computational power, they can still strictly profit. Okay? So now what I'm going to do is present that strategy. I'm going to build up intuition first, and then, like I said, I will touch on the analysis.
00:18:49.480 - 00:19:29.012, Speaker A: So here is some quick intuition for why it works. So imagine that you are so well connected in the network. So this is the unrealistic one. This is favorable to the attacker. You are so well connected to the network that if for some reason there's ever a tie, so you and someone else have two blocks of the same height, everyone else will have heard of yours first. And this is true. Just imagine, no matter what the reason is that even if this one was broadcast first and you heard about this one, and then after that decided to broadcast this, everyone still hears about this first.
00:19:29.012 - 00:20:05.376, Speaker A: You're so well connected. And I'll say that everyone breaks ties in favor of you. That's how I'll capture that. So here is something you can do that's clever if you are extremely well connected like this, as you say. Well, why am I in a rush to broadcast my blocks the moment I create them? Let me just wait until someone challenges me with a block of the same height and then I'll create mine. Or then, sorry, then I'll broadcast mine and everyone will hear about mine first anyway. So mine will clearly get into the longest chain because everyone's going to hear about mine first.
00:20:05.376 - 00:20:37.516, Speaker A: And I have this added bonus of getting rid of someone else from the longest chain. And remember that we want to increase my fraction of blocks in the longest chain. So this is great for me. I'm getting rid of other people and all of my stuff is still getting in. So what this strategy would look like is I'm still always building on top of the longest chain. I tie break in favor of myself, and the only thing I'm doing differently is I'm just waiting to broadcast until my block gets challenged. Okay, so let me just run through.
00:20:37.516 - 00:21:19.130, Speaker A: I have a quick animation of what's going on in the graph. So blue means it's been broadcast. So in this sample run, the first thing that happens is one of the honest miners finds a block, and then I find a block, and I don't broadcast it because I'm in no rush. Why would I do that? And then someone else finds a block and they broadcast it. And that triggers me to broadcast now the block that I found. And because I'm so well connected, even though the order of operations was that they broadcast first, then I hear about it, then I broadcast. Everyone else is still going to tie break in favor of me.
00:21:19.130 - 00:22:10.730, Speaker A: And so let's say what happens is that I find the next block again. And so I point to my own block, I hide it, I'm triggered by another broadcast that causes me to broadcast mine. And then this is where I'm using the assumption that I'm so well connected that even when an honest person finds an X block, they still point to mine when this happens. Okay, this part of the analysis, again, is just for intuition, for what's going on, right? So this is a very powerful attacker. But if the attacker is this powerful, then this is the best strategy you can use. Why is it the best strategy you can use? Because all of your stuff is getting in the longest chain, and each one of your blocks also kicks someone else out of the longest chain. And that does strictly better than being honest.
00:22:12.460 - 00:22:22.748, Speaker C: I have a quick question. Is the assumption that they're well connected separate from the fact that they have more than a third of the hash power? Or is it like as a consequence of it?
00:22:22.914 - 00:23:13.790, Speaker A: Sorry, those are distinct assumptions. So let me clarify first. So far for these two intuition slides, I'm making no assumption on the fraction of computational power. If your computational power is X, x could be less than 1%. You can still do strictly better with this attack. But the key assumption for this attack is you better be really well connected in the network because you need to make sure that if this sequence of events happens that you create a block, have not broadcast it, then someone else makes a broadcast before anyone else hears about that. You hear about it, broadcast your own, and then everyone else hears about you.
00:23:13.790 - 00:23:47.930, Speaker A: So as long as you can do that, then you can get this X over one minus X, which is strictly better and that holds for any X. You don't need it to be a third. For the real attack that I'm going to go into, I'm going to get rid of this really strong assumption that you're super well connected and then there's going to be like a teeny bit of math and the math will work out whenever you have more than a third. Did that answer the question? Yes. Thank you. Awesome. Okay.
00:23:47.930 - 00:24:49.324, Speaker A: So now let me first state the strategy and then I will walk through with pictures again, what it's doing? So let me say maybe first I have pictures coming soon. So here's the main idea. The main idea is that, let me say the main idea before presenting the text. So the main idea is that you can't rely on this sequence of broadcasting to be able to beat one block with one of yours. If somehow though you find yourself with two blocks here, then no matter how slow you are at broadcasting, everyone will always believe your chain of length two over some other chain of length one. So the game now is to see like, well, I'm going to try to get some chain of my own that's at least strictly longer than the chain that others have. So that's going to be the game.
00:24:49.324 - 00:25:45.020, Speaker A: And the downside is that there's going to be some risk trying to do that. So here's the text for what the strategy is doing. I'm actually going to step through the example iteration first. So here the first thing that happens in this simulation is an honest person creates a block and then I find a block. Now what do I do? I point to the longest chain because this is what the strategy always does and I'm going to check whether I should announce it. So one reason to announce it would be if there's another block here that's the same distance to the root that doesn't happen. Or then there's this special case which is basically saying like, well, if this block points to something that's trying to kick something else out and I'm in danger of not having other stuff to point to it, then I should broadcast it.
00:25:45.020 - 00:26:12.330, Speaker A: But this doesn't get triggered here either. Now I find a second block. I hide that one too, because neither of these trigger. So this you should recognize is like, this is the good situation because now I have two hidden blocks. With two hidden blocks, I can sit tight and wait. And when I get challenged, then I can say, well, the honest network has one block, but I have two. So even if I'm super slow, everyone's still going to mine on top of.
00:26:12.330 - 00:26:41.660, Speaker A: Or I could get even luckier. I get a third block here that I hide. So now what happens is the rest of the network produces a block and that triggers me to broadcast. That triggers this case one. There's some other block that someone announced that's the same distance to the root. So now I broadcast. So now remember that what's going to happen is that the rest of the network is not tiebreaking in favor of me anymore.
00:26:41.660 - 00:27:04.852, Speaker A: I'm poorly connected, right? So every single other miner heard about this honest block first. So if they create a block, they are definitely going to tiebreak against me. So they tiebreak against me. That's bad news. It seems like bad news for me. And then what happens is this triggers me to have this case one. So this block I'm going to broadcast.
00:27:04.852 - 00:27:52.948, Speaker A: But now I'm also like, oh crap, my lead is about to run out and I should just broadcast this one too to get this chain of length three in the longest chain and kill two honest blocks. Okay, so that's what this strategy does. And then no matter how poorly connected I am again, right? So even if everyone I have latency whatever, this is still a chain of length three compared to a chain of length two. So everyone's going to build on top of it. Okay, so this previous example, this is kind of like the what could go, right? So this is great if you find two blocks in a row and hide them, that's excellent. Next example is the what could go wrong. So I hide a block, right? Because I'm thinking like, oh, cool, I'm going to get my lead of two.
00:27:52.948 - 00:28:23.280, Speaker A: That's going to be awesome. But instead I don't get a lead of two. And now they find a block. So what's going to happen now is that this is going to trigger me to announce with case one, but I'm not safe yet, right? So what's going to happen is maybe I find the next block. If I find the next block, that triggers case two. Because I realize that as soon as I create this block, this is very dangerous to continue hiding this. So I published that immediately.
00:28:23.280 - 00:29:18.656, Speaker A: And that's good, that's still fine. The bad thing that might happen is maybe I don't find the next block. If I don't find the next block, then this one that I hid, that's just orphaned forever, right? Because now everyone, including me, because this is what I want to do to maximize my own future profit, is to continue building on the longest chain. Okay, so state the theorem, right? So the theorem is that if everyone else is using this longest chain strategy, so remember that they are always going to tiebreak against you. So that means you are so poorly connected that whenever you try and do this broadcasting in response to them, you will always be late. And on top of that, you can't broadcast point to point. You have to broadcast to everybody when you broadcast.
00:29:18.656 - 00:30:10.304, Speaker A: So even under those situations, if you have at least a third of the mining power, then this selfish mining strategy is strictly better than being honest. Okay? So what I want to do now, I am going to give a taste of the analysis or show you how to set it up. And the main thing I want to point out is that even though I didn't show you the analysis for the lucky selfish mining, the one where you win all the tiebreaks, that analysis is easy. So if I was teaching a class, I would assign that as like a homework problem. I think that's very feasible to do. And it's easy because there's no risk, right? All of your blocks are in the longest chain. You just have to figure out how much you're kicking out, right? And once you figure out how much you're kicking out, then that's the entire math for the real selfish mining.
00:30:10.304 - 00:30:55.104, Speaker A: When you lose all the tie breaks, there is some risk, right? There's this risk where you create a block and then the honest people get two right afterwards, and then this is the risk. You lose that block. The reward is like, what if you get two in a row or you get one, they get one, you get one. And somehow the point is just that we have to do some calculations, right? There's no way to just think a little bit and see like, oh yeah, clearly this is better. We have to do some calculations. And maybe more evidence that we have to do some calculations is that this is not always profitable, right? It's profitable if you have lots of mining power. That's because you're more likely to be in the reward than the risk case.
00:30:55.104 - 00:31:24.892, Speaker A: And it's not profitable if you have less than that. So again, what I want to do, I'm going to set up the analysis and try and have as much structure as possible and then hopefully you'll kind of see how these ideas could be used for other strategies or other settings. Okay? So the kind of terminology I'm going to use, I'm. Going to set up what's called a Markov chain. And I think it'll be clear from the pictures what's going on. But I'm going to use this terminology. I'll refer to a state.
00:31:24.892 - 00:31:48.310, Speaker A: I and that just refers to the fact that the selfish minor has created exactly I, hidden blocks right now. Okay, so how does the game start? The game starts in this state. Zero. There's a unique longest chain. Everyone agrees on the longest chain. The Selfish Miner has nothing hidden. This is where the game is right now.
00:31:48.310 - 00:32:19.790, Speaker A: One thing that might happen is maybe an honest miner creates a block. If an honest miner creates a block, then they broadcast it immediately. And we still have a unique longest chain. The selfish Miner has nothing hidden. So I'm drawing this as a transition to say, okay, we're staying in state Zero. If the attacker mines a block, then now they have one hidden block because they choose to hide this block. So I'm going to refer to the state we're now in as State One.
00:32:19.790 - 00:32:49.694, Speaker A: From state one. If honest miner mines a block, then we have this special case right, where now we've triggered that there's these two competing blocks. And the moment that the next block is found, this race is going to end. I'm going to broadcast mine if I found it. The honest network is going to broadcast theirs if they find it. This is like this special state I'll refer to as the race. But if the Selfish Miner mines a block, then now they have two hidden blocks.
00:32:49.694 - 00:33:24.750, Speaker A: So we go to this state. Okay. And let me just go through this last one. I'll skip the rest of the transitions. But hopefully you can kind of see the picture that we're building as we're saying like, okay, from this state, what happens if an honest minor finds a block? And what happens if the selfish minor finds a block? Right? And so here, no matter what happens, we're going to go back to State Zero. But if the honest minor finds a block, then it means that the honest network is going to have this in the previous block, in the longest chain. If we find a block, then it's going to be us that has two blocks in the longest chain.
00:33:24.750 - 00:33:42.580, Speaker A: Okay. So all of this is just to say this is how you build this picture. And this picture kind of has different states that stores how much is hidden right now. And let me skip this too.
00:33:43.670 - 00:33:44.594, Speaker B: Maybe a quick thing.
00:33:44.632 - 00:33:45.314, Speaker A: Yes.
00:33:45.512 - 00:34:11.362, Speaker B: Just to kind of design this back into the intuition we talked about before. Because when you first did this really nice segue, you're like, oh, if you're the attacker ties are always broken for you. You can just cancel one on this block with one of your blocks. And you just keep doing that. So that's a great starting point. Then you had this nice intuition that said, okay, well even if ties are broken, so I always lose. But I have two of my own blocks in a row.
00:34:11.362 - 00:34:46.620, Speaker B: I can use that to cancel one on this block. And so I feel like that's kind of like the first simplest strategy you might try in that case. So don't worry about canceling more than one on this block at once. And so I just think some of the extra complexity that you see on the slide is because you're like, well, why stop at canceling one on this block? Maybe I want to cancel as many as possible. So in the off chance I have this big lead, let me just make sure rather than wasting two of your blocks to cancel one on this block, you're going to be using K of your blocks to cancel K minus one on this blocks. And that's the reason you need like this big state space going up.
00:34:49.950 - 00:35:05.934, Speaker D: Can I just clarify the state transition from two? When the selfish minor has two hidden blocks and an honest minor mines something, why do we go to zero?
00:35:06.132 - 00:35:31.400, Speaker A: Great. So let me first just confirm that is correct. Let me go back to the picture here. So let me actually step through this and say how the states would be. So here we started in state zero. I found a block and hit it. So now I'm in state one.
00:35:31.400 - 00:35:49.214, Speaker A: I found a second block and hit it. Now I'm in state two. I have two hidden blocks. I found another block and hit it. So now we're in state three. I have three hidden blocks. Now they found a block that triggered me to broadcast this.
00:35:49.214 - 00:36:06.066, Speaker A: So now I only have two hidden blocks right now. Also, if they find the next block, this is the transition you asked about. So I'm currently in state two. They found a block, and that is going to trigger me to broadcast both of these.
00:36:06.168 - 00:36:08.850, Speaker D: I see. I'm basically like skipping the race.
00:36:11.050 - 00:36:50.322, Speaker A: Exactly. I'm basically saying every transition in that picture corresponds to one time step or one new block being created. So it's not like every transition corresponds to me doing something with a block. I wanted every step to correspond to a new block has been created. And then when that block is created, what changes? So in this case, when this block is created, a lot changes. So that's why it was kind of like a big single transition that went from two to zero. So for here, the race state is different.
00:36:50.322 - 00:37:20.620, Speaker A: The race state is because I hit a block here. So now I'm in state one. Now I enter the race state and from the race state, if I find the next block, now we're going back to state zero. If they find the next block, we're also going back to state zero. So that's why this race state is special and different from just being in state one or state zero. Again, did that answer your question? This part about why go from cool.
00:37:21.310 - 00:37:31.438, Speaker C: What about the state transition at the N block going back to N minus one, like the Black Arrow from three to two? Where does that correspond? The diagram we went over?
00:37:31.524 - 00:37:48.562, Speaker A: Yes. So that is here. So currently we're in state three. So we have lead of three, and now the next block is going to be created, and it's not ours. So that triggers this. And now we only have a lead of two.
00:37:48.696 - 00:37:58.470, Speaker C: But theoretically, if we were to cash out or broadcast the lead, we'd still end up with three. Right. So why does the state go back to two?
00:37:58.540 - 00:38:38.466, Speaker A: Good. I think that I will do a better job answering that. Maybe like, five to ten more minutes in the talk. Basically, what I want to say is that so far, I have not actually said how am I going to do analysis from here? I haven't actually said exactly what's going to happen. All I've said is like, well, this is one way to describe the state that we're currently in, and I haven't yet said how are we going to cash out, basically, or how are we going to compute rewards. So I think when I start talking about how to compute rewards, it'll be convenient that we describe the states in this way.
00:38:38.648 - 00:38:52.290, Speaker D: So if it were me, I'm, like a very nervous person. If it were me, I would just freak out and post all my hidden blocks all at once. And I assume we're going to see why that is like a strictly inferior strategy.
00:38:52.450 - 00:39:25.460, Speaker A: Got it. So I am not going to explicitly do those calculations. I think what Tim said is the best quick intuition I can give. So just to repeat, what Tim said is that if we do what you said, where like, oh, I have K hidden blocks and you found one, I'm going to publish all K. Then I have now used K of my blocks to kill one of yours. So that's a ratio of, like, K to K plus one. Right, okay.
00:39:25.460 - 00:40:20.020, Speaker A: Sorry, how would I phrase it? I'm decreasing the denominator by one, and that's consuming, like, K of my hidden blocks to do. So if instead I can decrease the denominator by K minus one, that's better because now the denominator is getting even smaller. When I do this, the idea is that I want to get rid of as many honest blocks from the longest chain as possible and get as many of my blocks into the longest chain as possible. The exact trade off between, like, is it better for me to have one extra block in the longest chain or remove five of theirs from the longest chain? That's what requires this kind of analysis to exactly figure out. But definitely, if I can just say remove one block or remove K minus one, it's definitely better to remove K minus one.
00:40:21.590 - 00:40:27.714, Speaker B: So you want the honest miners to waste more time making more blocks that you want to kill, like the satisfaction of killing.
00:40:27.762 - 00:41:24.226, Speaker A: Yes, that's absolutely correct. And if it helps, one way to think of this is so we already said the reason that this is happening is because there's this difficulty adjustment. So if you want to see the full chain of what's happening is that by getting the honest network to waste their computational power, you are lowering the effective difficulty to create a new block. Right? Because if really there's like 100 units of power in the network creating blocks. But you get them if you're 40% and they're 60%, but they operate as if they're only 40% because so many of their blocks are getting orphaned, then now what's happened is you have lowered the effective difficulty. It used to require 70 leading zeros and now it requires 69 leading zeros or something. So what you've done is by getting them to waste their stuff, it's now easier to create blocks.
00:41:24.226 - 00:41:50.578, Speaker A: And so more of the blocks that you create, twice as many are going to wind up being successful. So if it helps to see that direct chain, that's kind of the direct chain for what happens is they waste their stuff, that lowers the difficulty. By lowering the difficulty, your hash rate is now more successful at producing blocks than it was before. Did that answer the question?
00:41:50.664 - 00:41:55.380, Speaker B: You're like artificially having the difficulty look higher than it is? Like you're hiding your.
00:41:57.670 - 00:42:28.116, Speaker A: That'S correct. Yes, that's correct. And that's because the difficulty adjusts based right. So remember that all of the bitcoin adjustments exactly. It's only based on that chain itself, right? So that chain itself doesn't know that there's equally it doesn't know that there's twice as many orphan blocks going around that it does the difficulty adjustment based on its own chain only. Okay, just one more quick question just.
00:42:28.138 - 00:42:33.236, Speaker C: To make sure I find this in the intuition. If tiebreaking is just done by at.
00:42:33.258 - 00:43:07.104, Speaker A: Random will still work, I guess it's not, right? So if tie breaking is done at random, that's actually better for the attacker. So here's what would change. Let me go back to this. Let me repeat. So the very first thing I showed here, this, we said tiebreaking is perfect for the attacker. Definitely tiebreaking randomly is worse for the attacker than this. Here we basically said the attacker is losing.
00:43:07.104 - 00:43:47.170, Speaker A: Let me go to here. The attacker is losing every tiebreak. Compared to this, winning sometimes is better. So the reason that would be different is so this is the same if you're the attacker, you're always going to tiebreak in favor of yourself. And even if the protocol says, please do it randomly, you're going to be like, no, I'm tiebreaking in favor of myself. If the rest of the network finds the next block, then if they are tiebreaking randomly, then sometimes they'll happen to point to you. Right? And so this means that you can actually get a little bit of extra reward sometimes just by luck in how the randomness goes.
00:43:47.170 - 00:44:20.568, Speaker A: Let me go to here. So if you change the protocol to ask everyone to tiebreak randomly, this one third number becomes one fourth. So that's another number that happened to be a cleaner number to remember from their paper that if instead of tiebreaking against you tiebreaking is done randomly, then you need 25% in order for this attack to be strictly profitable. Did that answer the question? Yeah. Thank you. Awesome.
00:44:20.734 - 00:44:21.980, Speaker B: Matt, a quick one.
00:44:22.050 - 00:44:22.908, Speaker A: I don't know whether you're going to.
00:44:22.914 - 00:44:31.790, Speaker B: Get into this specifically, but does this fully explain the reasons why Uncle Blocks get rewards in other proof of work?
00:44:32.240 - 00:44:51.140, Speaker A: So I actually think it is the opposite. So Tim maybe can correct me if I'm wrong, but I think that giving Uncle Rewards is actually makes selfish mining more profitable because now you are less stressed about less risk first block.
00:44:51.560 - 00:45:36.380, Speaker B: Agreed. I don't know that the Ethereum team was aware of that. My understanding is that basically Ethereum wanted to crank up the block rate by lot, actually by factor 40 or something like that. And so that means you're just going to get a lot even if everybody's honest, you're going to be getting a lot more kind of orphans. And so I almost like the uncle rewards are optimized for fairness in the all honest case. But then, like you say, Matt, when you do this analysis, you realize that actually if there's selfish mining, which we can discuss maybe to what extent there is selfish mining, but at least in principle, it makes it actually safer for the attacker.
00:45:36.540 - 00:46:11.310, Speaker A: Yeah, that's yeah, yeah. And I can just repeat my understanding is similar to Tim's, that assuming everyone is honest, a well connected miner would have less orphans. And so assuming everyone is honest, it would be disproportionately profitable to be a well connected minor because you would have less orphans. So my understanding was that the uncle rewards were to try and make it more equitable between well connected and poorly connected miners. So that even if you were poorly connected and your blocks were getting orphaned more often, that you would still get some reward for that.
00:46:11.680 - 00:46:20.572, Speaker D: Quick comment. Is it obvious that it's only better for the attacker because the on correct.
00:46:20.626 - 00:46:25.276, Speaker A: It's not obvious. That's why I was deferring. That's why I wanted to confirm you.
00:46:25.298 - 00:46:25.870, Speaker D: Wanted.
00:46:41.420 - 00:46:47.000, Speaker B: But I think when the dust settles, it is in fact true that it's easier to attack Ethereum, right?
00:46:47.150 - 00:47:23.430, Speaker A: Yeah. So that is my recollection. But I don't remember yes, I'm not comfortable saying I remember that confidently and that that's correct. But that's consistent with what I pretty remember. But the good news is that the analysis that I'm about to show you, the kind of analysis is very easy to adapt to handle uncle Blocks, uncle rewards too. And then you just have to change like a couple of numbers and chase through the I mean, it's not going to be pleasant. You have to chase through some calculations, but the setup is not hard.
00:47:23.430 - 00:48:24.332, Speaker A: So I'm clearly not going to get to any of the bonus stuff that I mentioned at the top, but I will at least just try and finish wrapping up. How do you actually do this analysis? So here's the goal. I want to compute three things, okay? The first thing I need to do is I want to compute in this diagram what is the fraction of all time steps? What is the fraction that we spend transitioning from state X to state Y? So that is something that can be done if you've seen Markov chains before. You need to compute this thing called the stationary distribution. Once you compute the stationary distribution, these probabilities follow. So this is something that can be done. The second thing we need to do is we need to say, well, when I take a transition from X to Y, how many blocks does the attacker get in the longest chain during that transition? And let's do the same thing for the honest miners.
00:48:24.332 - 00:49:19.784, Speaker A: Let's see, for every transition, when I take that transition, what is the number of blocks you get in the longest chain during that transition? If you can compute all three of these numbers, then there's a very simple formula that says, what is the fraction of blocks created by the selfish minor? So let me just quickly walk through. Let me be clear. So this is a theorem I'm stating, and it applies to any strategy, right? So this is why oh, you can just modify these numbers. If you can compute these numbers with uncle rewards, then you can compute selfish mining with uncle rewards. So what's the numerator? The numerator is just saying we'll sum over every transition the fraction of steps you spend taking that transition times the selfish blocks during that transition. The numerator is just on average during a state. How many blocks does the selfish minor get? The denominator is doing the same thing.
00:49:19.784 - 00:49:59.990, Speaker A: It's summing over every pair of states the fraction of time that you spend going from X to Y times. Now I'm just summing the selfish plus honest blocks you get during that transition. So that's the average over time steps of the total number of blocks that enter the longest chain. Sorry. So this means the goal is just I need to say how do I compute all three of these things for each pair of states? Okay? And that's the entire game. So this is the framework. If you have any strategy you want to analyze and you can do this computation, then you can analyze that strategy and find out what its reward is.
00:49:59.990 - 00:50:54.730, Speaker A: So I told you, so I'm going to skip this is the calculation heavy part is finding the stationary distribution of this Markov chain. It's not that bad, but it's calculation heavy, and I'm going to skip it the cleaner part is figuring out how to do this counting. So here's what I want to do. I want to say for every block, when am I going to count it? I'm going to count it during the transition when that block is first published. And I know during this time step that that block is in the longest chain forever. Okay? The first transition where I know that that block has been published and is definitely in the longest chain forever, that's when I'm going to count it. I'm not going to count it during any other transition, and I'm not going to count any other blocks because I might be wrong about them.
00:50:54.730 - 00:51:36.340, Speaker A: So, for example, this is the full table of counting. Let me just zero in on, let's say this one here. So when I transition from state zero to state zero, zero to zero, the attacker produces no new blocks in the longest chain. The Honest group has produced one new block that is broadcast during this round. And I know it's going to be in the longest chain forever. How about when I go from X to X minus one? When I go from X to X minus one, this means that I had a lead of X. The Honest group found a block.
00:51:36.340 - 00:52:00.456, Speaker A: That block is actually not going to be in the longest chain. They broadcast it, but I know it's not going to be in the longest chain. So I'm not going to count that because that's going to be wrong. What it does do, however, is it triggers me to broadcast one block, and that block I know is going to be in the longest chain. So I'll count it. So this is just the others follow. Similarly, this I will skip.
00:52:00.456 - 00:52:24.400, Speaker A: But there's another way to count if you want. I just wanted to show the flexibility of this. But as long as you find some way to count every block during exactly one transition, then you have a correct scheme and that's it. So that's all you have to do. So just to repeat this first step, this is the calculation heavy part. It absolutely can be done. It's finding the stationary distribution of the Markov chain.
00:52:24.400 - 00:52:39.210, Speaker A: But it takes some calculations. These two are easier. You just need to be a little bit clever. Sit down and focus. And then the numbers you have to deal with are zeros ones and twos. It's not that bad. Okay.
00:52:39.210 - 00:53:18.724, Speaker A: And then it turns out you get this function. This is the reward you get from selfish mining. I don't know how to explain why you get particularly this formula, but this is what you get. And it's bigger than alpha if and only if alpha is bigger than a third. I have basically no time. So maybe I will do the wrap up with this on the slide and I will just state. I mentioned earlier that there was some way to talk about abstracting away the network protocols with one parameter, and the original paper used this parameter gamma to refer to that.
00:53:18.724 - 00:54:02.132, Speaker A: They basically said, like, look, however well connected you are in the network or whatever's going on, let's just parameterize that by gamma. Let's say that I don't know whether it's because of latency, I don't know whether it's because of point to point communication. Let's just say that if you happen to try this specific thing of wait till they broadcast, then I broadcast that a gamma fraction of the time you're going to succeed. Let's just parameterize it by that. Then as long as you know gamma, you can do the analysis. And so they did that. There are other formulas that I'm not going to get into, and then maybe the very last thing I will state is just that there was follow up work that I was going to discuss, but I'm not going to that shows that you can do a little bit better.
00:54:02.132 - 00:54:39.276, Speaker A: This selfish mining is not the best thing you can do, and the best thing you can do is not that much better. So as long as you have less than 32.9% of the mining power, then there is nothing clever you can do. So that is a theorem, and that does mean that if you're really concerned about selfish mining, you only need to be concerned when there are large miners. So not 50%. It's not a 51% attack, it's like a 33% attack, but you still need to have 33% in order to do something clever. Okay, so let me pause here.
00:54:39.276 - 00:54:45.230, Speaker A: I was going to pause for discussion, but I guess I'll pause because it's the end of the talk. Instead, this is.
