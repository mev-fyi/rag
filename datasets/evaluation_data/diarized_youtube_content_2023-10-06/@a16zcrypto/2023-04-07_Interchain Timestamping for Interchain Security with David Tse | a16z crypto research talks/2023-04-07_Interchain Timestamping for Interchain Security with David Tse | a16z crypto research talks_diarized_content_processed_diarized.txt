00:00:06.720 - 00:00:09.908, Speaker A: You. Okay.
00:00:09.994 - 00:00:29.364, Speaker B: So welcome, everyone, to today's a 16 z crypto research seminar. Very happy to introduce David, say, from Stanford and also now Babylon chain. David's group over at Stanford, I think, has been doing some of the absolute best work in blockchain consensus for many years now. So very happy to have him, have him here.
00:00:29.402 - 00:01:09.188, Speaker C: David, floor is yours. All right, thanks a lot, Tim, for inviting me here. Yeah. So I'm at Stanford, and today I want to talk about some research we've been working on under the general umbrella we call interchange timestamping. And we are also doing a startup, Babylon chain. I want to leave right now from Stanford working on that, give some discussion on the theory, as well as give a demo of something we've been building. Okay, so the merge has just happened a month ago, by the way.
00:01:09.188 - 00:01:16.184, Speaker C: That's a month ago, but it's a long time since then. Many other things have happened. So the merge, I guess, is no longer sort of current.
00:01:16.382 - 00:01:17.544, Speaker B: It was like five years ago.
00:01:17.582 - 00:02:02.388, Speaker C: It was just five years ago, but actually it took seven years to do this merge and it just happened a month ago. So it's still pretty recent. So proof of work to proof of stake, there are certain advantages, well known, less energy. That's the confirmation. And there's this mechanism which is absent in proof of work called slashing, which gives stronger, so called stronger economic security. However, there are actually several. Even with the slashing, there are several limitations of proof of stake protocols that we sort of learned over the years as we worked on proof of stake protocols and contrasting proof of stake and proof of work protocol.
00:02:02.388 - 00:02:57.524, Speaker C: As Tim said, we spent quite a few years working on this kind of consensus protocol, permissionless consensus protocol. So one thing we realize is that although proof of stake protocols are so called permissionless, is not really completely permissionless, because stake unbonding, in other words, to leave the system, there is an unbonding period, and typically in consensus approval, stake consent protocol. This is very long, multiple weeks. Second is that slashing succeeds for safejack tax, double signing. However, censorship is not accountable. I think Tim actually mentioned that in one of your open problems. And so how to deal with censorship is a limitation.
00:02:57.524 - 00:03:50.696, Speaker C: In proof of stake proof and three proof of stake protocol, the economic security is sort of measured by the value of the chain, the token valuation. And so if you start with a small chain with more valuation, bootstrapping could be quite difficult. So those are the three limitations we identified. We've been doing some research on how to overcome these limitations, and we're also building a project called Babylon, to solve these problems, but more specifically in context. So I think it's always good. Nakamoto, his eight page paper, inventing bitcoin, as I mentioned, is a bit of like a system paper rather than a theory paper. So I always think it's good to have a system to focus on so we can focus on our talk.
00:03:50.696 - 00:04:41.960, Speaker C: So the system we have in mind is cosmos. Okay, so what is Cosmos? Cosmos is this system where you can summarize in one equation. Okay, so the equation is that you have many sovereign chain app chain specific to particular applications, like a Dex or gaming application. These are typically relatively small proof of stake chain, but they communicate with each other through a bridging technology called IBC, inter blockchain communication. And together they form this network called one name for the interchange. I think it's a pretty good name, the interchange, because it carries the idea of multiple chains, but at the same time, they are intercommunicated. So, like the Internet.
00:04:41.960 - 00:05:16.576, Speaker C: And this IBC is actually a very interesting technology. We were talking about the light client. So the light client was invented by Nakamoto SPV. I think one of the significant realization of the light client is actually in this IBC, because this bridge is a light climb bridge. So to maintain this bridge, there are light clients on each end viewing the other. So the IBC was invented as a transport layer. If you think about the energy with Internet as a transport layer.
00:05:16.576 - 00:05:45.344, Speaker C: But of course, the main thing, people transport is basically token transfer. What we realize is that this IBC is actually much more versatile and it can be used to transfer security. And I will talk about that later on in the talk. Okay, so these are the three limitations. I will talk about one, three of them, one after another. So for a brief of time, I will have to focus on two of the three. The first and the third.
00:05:45.344 - 00:06:10.516, Speaker C: And I'll briefly mention the middle one. Okay, so here's the deal about proof of work to proof of stake. So, bitcoin is an example. Proof of work chain. The first proof work chain, people say slow bitcoin confirmation take hours. Slow. So proof of stake comes along and the finality is at seconds.
00:06:10.516 - 00:06:52.596, Speaker C: So going from hours to seconds is amazing. However, there seems to be some kind of conservation of latency, because there is another event which is unbonding, which is very slow. So it seems like you speed up something, but then sort of something got lost. So in proof of work, if a miner wants to leave, they can leave anytime they want. They can stop mining. But for proof of stake chain, if you want to unborn often take weeks. So going back to our system cosmos, a typical cosmos chain takes three weeks to unborn, three weeks.
00:06:52.596 - 00:07:04.970, Speaker C: Some are longer, four weeks. Some are a little bit shorter, two weeks. But three weeks is a typical number. So let's understand why. So our first question is, why is it so long before we can try to fix it?
00:07:06.140 - 00:07:13.684, Speaker B: One possible complaint about this line is sort of apples versus oranges, right? I mean, it's users, end users that care about latency.
00:07:13.812 - 00:07:14.056, Speaker A: Right.
00:07:14.078 - 00:07:16.552, Speaker B: And then a bonding is relevant only for the validators.
00:07:16.616 - 00:07:16.892, Speaker A: Right?
00:07:16.946 - 00:07:26.610, Speaker B: So it's conceivable that one timescale would be more appropriate or more reasonable for one of those two sets of entities versus the other.
00:07:28.500 - 00:07:35.676, Speaker C: So the clients are worried about clarification and stakers, not necessarily the validators.
00:07:35.708 - 00:07:35.904, Speaker A: Right.
00:07:35.942 - 00:07:45.696, Speaker C: I mean, you delegate stake, so whoever has stake would worry about that. So you're saying it's different audience is involved.
00:07:45.808 - 00:07:54.312, Speaker B: Yeah, I guess I'm saying, like, the value of being in seconds might be much higher for one of these groups. Perhaps that might be much more important.
00:07:54.366 - 00:07:55.656, Speaker C: For the clients good.
00:07:55.758 - 00:07:56.472, Speaker B: Than for the state.
00:07:56.526 - 00:07:57.176, Speaker C: Yes.
00:07:57.358 - 00:07:58.090, Speaker A: Okay.
00:08:01.440 - 00:08:07.950, Speaker D: Is there any slashing concerns that would delay finality from the perspective of the clients as well?
00:08:10.960 - 00:08:11.772, Speaker C: What does that mean?
00:08:11.826 - 00:08:24.496, Speaker D: I guess maybe responding to what Tim was saying. Saying that if there is a world in which someone does an invalid thing and that they could be slashed, that might take a while.
00:08:24.598 - 00:08:33.620, Speaker C: Yeah. This will show up later. Yeah. So the question is, why is it so long and it's related to slashing? Is that the question?
00:08:33.690 - 00:08:34.484, Speaker A: Okay, good.
00:08:34.602 - 00:08:37.220, Speaker C: Yeah, it's completely related to slashing.
00:08:38.440 - 00:08:39.190, Speaker A: Okay.
00:08:39.660 - 00:08:59.448, Speaker C: All right, so Juno is a cosmos chain. So let's see what happens to Juno under a. So Juno is growing a canonical chain. So these are the blocks produced on this chain. It's growing like a chain. So it's nice. What is an attack? Attack is a fork.
00:08:59.448 - 00:09:01.500, Speaker C: Is a fork on this chain.
00:09:02.320 - 00:09:03.070, Speaker A: And.
00:09:05.620 - 00:09:20.584, Speaker C: The economic security is realized here through catching the attacker, because now the attacker has to double sign on these two folks. And so this is so called a slashable folk.
00:09:20.732 - 00:09:21.380, Speaker A: Okay.
00:09:21.530 - 00:09:53.580, Speaker C: And so attacker is now punished, and that provides a deterrent to forking. Okay, so this is slashable crime. And you can think of the economic security, say, called s Juno is the slashing penalty. So typically, one third of the people get slashed. Slashing penalty is what's called s Juno. Now, unfortunately, not all acts are slashable. And here's an example of an attack that's not slashable.
00:09:53.580 - 00:10:49.120, Speaker C: So to slash someone, not only you have to catch them, not you have to prove that they are double sided. But you have to be able to slash the stick before they unbond. So if they have already unbonded, and then they grow the fork, which they can do because they have the signatures, they have the keys, so they can still grow this unslashable fork. So although they have double sided, they now cannot be slashed. So this is an example of an unslashable fork. Okay, so this problem is kind of pretty well known in proof of stake. Vitalik talked about it back in the day, 2114, when you start thinking about the proof of stake Ethereum.
00:10:49.120 - 00:11:31.100, Speaker C: And so the typical solution that is adopted by most proof of stake chains is this idea of long and bonding. Okay, so let's see what that means. We have to do this a little bit carefully because it's a key slide here. Okay, so you have a validator or staker. They issue an unbonding request in a block. The unbonding request goes into the ledger, and then the unbonding request is granted only after a certain long period of time. Okay, so 21 days, in the case of our cosmos example.
00:11:31.100 - 00:11:40.160, Speaker C: So 21 days. Okay, so let's think, what is the use of this law unborning? And how does that prevent this attack?
00:11:40.310 - 00:11:41.010, Speaker A: Okay.
00:11:41.460 - 00:12:42.500, Speaker C: All right, so let's consider two cases. One is that, suppose one thing I forgot to mention, one thing I forgot to mention is really, what is this attack worry about? Okay, so if you go back to the previous slide, the attack is really for a client, for a client that is not always online. Because if you're always online, then you will see that the canonical chain in the middle here growing, and you will not be fooled by this fork that is created later. So the concern is that users or clients are not always online. They come online and then they leave the system, and they come online again. And when they view the system, then they see these two folks, then they don't know which to follow. Or even worse, they may only see one of the two folks and they may follow the wrong folk.
00:12:42.500 - 00:13:05.980, Speaker C: So the 21 days should be understood in this context. Okay, so 21 days basically means what? It means that if you come online within 21 days of the last time you left the system, then your chain will have a block in the canonical chain.
00:13:06.480 - 00:13:07.230, Speaker A: Okay.
00:13:09.440 - 00:13:20.880, Speaker C: So then you will continue following this chain. So when the attacker tries to create a fork, the fork.
00:13:24.100 - 00:13:24.816, Speaker A: Has to be.
00:13:24.838 - 00:13:47.220, Speaker C: Before the unborn request. Because after the unborn request, the stake is already frozen, it cannot vote anymore. So it has to be created before. So therefore, when you join within 21 days, and you see a fork, the network will be slashable. But if you don't see the fork, then you're safe.
00:13:47.380 - 00:13:48.040, Speaker A: Okay?
00:13:48.190 - 00:14:33.800, Speaker C: So that means that the system is now safe if you join the system within 21 days. Okay, so, for example, in Cosmos, this 21 days is used in the case of the design of the IBC light client. So the most important client for cosmos is actually the IBC light client. So you're on the other chain and you're viewing this chain, and you want to verify that the transactions that is communicated to you is valid. So you won't be able to follow the correct fork on the sender chain. And this allows you to say that as long as you send a message, an IBC message, every 21 days, then you're safe. You're protected by slashing.
00:14:34.380 - 00:14:34.936, Speaker A: Okay?
00:14:35.038 - 00:15:13.110, Speaker C: So that's where the 21 days come in. In Cosmos, they want to make sure that even though IBC light client may not be always on, as long as they're always on every 21 days, then you're fine. Now, what happens if you go beyond 21 days? Okay, that's when things become really quite fuzzy, because when you're beyond 21 days, then you're no longer protected. And this is one so called social consensus, which means that you're beyond 21 days. You really have to trust your friends to be able to find the right chain of junction. So this is the vague part of the protocol which is not really fully specified what that really means.
00:15:13.480 - 00:15:15.604, Speaker A: Okay? All right.
00:15:15.722 - 00:15:28.070, Speaker C: And in the case of IBC, if your IBC connection is not updated for 21 days, then you have to shut down the entire IBC connection. You have to restart, which is effectively another social consensus process.
00:15:29.320 - 00:15:30.070, Speaker A: Okay?
00:15:30.440 - 00:15:33.948, Speaker C: All right. So this is the reason why it's 21 days.
00:15:34.034 - 00:15:34.670, Speaker A: Okay?
00:15:39.600 - 00:17:03.720, Speaker C: The question is, really, how do you have a more secure way of onboarding late joining clients without having needed to wait 21 days or be able to join even safely beyond that bonding period, however long it is. So what is going on here? What is the confusion here is that there are two chains here created, and the user who is always online, the client always online, knows that the upper chain is the correct chain because it's growing. This one is later arriving, and so the online client will reject it. The problem is the late joining client. So therefore, what we need is really someone to be always online watching you watching this chain, and someone that can be trusted by the clients, the system. So basically what we need is a timestamp server. So in Nakamoto's paper, when he introduced bitcoin, he said hey, what I want to build here is a peer to peer distributed timestamp server to timestamp bitcoin transactions as to when they occur.
00:17:03.720 - 00:17:24.460, Speaker C: Okay, so what we're going to do is we can use bitcoin to not only timestamp bitcoin transactions, but to timestamp events that are happening outside the bitcoin chain. And the events that are happening is the creation of blocks in the proof of stake chain.
00:17:25.920 - 00:17:27.730, Speaker A: So it's another way of thinking about this.
00:17:31.460 - 00:17:45.536, Speaker B: If you go back to the forking question. So if it were true that every block had embedded in it an accurate timestamp of its creation, then you're saying just program the client. So whenever there's conflicting a block, always follow the earlier early timestamp.
00:17:45.568 - 00:17:45.956, Speaker A: That's right.
00:17:45.978 - 00:17:58.216, Speaker B: And so that's just kind of the client side way of doing fork resolution, where everybody stays in sync. And so being always online just means that, well, the blocks don't have timestamps, but you know the timestamp because I.
00:17:58.238 - 00:17:59.272, Speaker C: Keep track of my time.
00:17:59.326 - 00:18:04.590, Speaker B: Okay, so you're just saying, let's replace that with bitcoin basically being a public service.
00:18:05.360 - 00:18:14.140, Speaker C: So we're using bitcoin as like a public timestamping service to timestamp events that are happening on the proof of stake chain.
00:18:15.380 - 00:18:16.224, Speaker A: Yeah.
00:18:16.422 - 00:18:38.820, Speaker C: So that's the high level idea. Maybe I'm jumping ahead, but I think you, technically, you need more than just timestamping. You need timestamping plus data availability. Yeah, it's coming. If you are jumping ahead, it's good. Yes. So let's understand that a little bit more carefully.
00:18:43.520 - 00:18:44.270, Speaker A: Okay?
00:18:44.640 - 00:20:05.140, Speaker C: All right, so we have the slashing of Juno, which cannot be resolved. And now we use bitcoin, and we basically send a timestamp, say, of every block of the Juno chain. So what we do is we send a so called checkpoint transaction onto the bitcoin network, which goes into the bitcoin network, and the transaction is recorded. And that provides a timestamp to a fork, let's say to a fork. Okay, so now the canonical fork has a timestamp, which is earlier than the later created unslashable fork, which has a later timestamp. And so now a late joining client, whether it's coming short or long time later, will always be able to see the timestamp because it can observe bitcoin and therefore can determine the earlier fork as the canonical fork. And no one will get confused.
00:20:05.720 - 00:20:06.420, Speaker A: Okay.
00:20:06.570 - 00:20:28.540, Speaker C: No one will get confused. So that's a general idea. That's the idea. And the good thing about bitcoin is indeed, you can send transactions into bitcoin that are not bitcoin transaction. They're called op return transaction. There's a particular transaction type to bitcoin that allows you to send arbitrary data, but very small, only 48 bytes. Only 48 bytes.
00:20:29.520 - 00:20:31.790, Speaker A: Okay. All right.
00:20:32.640 - 00:21:48.890, Speaker C: So now the question is, okay, so if you have future system, then can I change the unborning time? So unborn time used to be 21 days, but now. So what is the effective unborning time for this system using bitcoin as the timestamping server? Well, as long as the timestamp is confirmed on the bitcoin chain, where confirmed means a certain depth into the bitcoin chain as reliability that you like, then the reversion probability is very small. And then you can now trust that timestamp. So really, the unbonding time is now equal to the BTC timestamp confirmation time. And this confirmation time can be chosen to your level of security. So, for example, if you think 20 block deep is what you like, then your unborn time will be the time in which the confirmation, the checkpoint or timestamp becomes 20 block deep into the bitcoin chain. And this you can observe roughly 20 block deep would be roughly 200 minutes.
00:21:48.890 - 00:22:17.248, Speaker C: But this could be a random variable. Okay. So therefore, now we reduce the unborn time from 21 days to the bitcoin confirmation time. Okay. All right. So to prove a security theorem is not enough to just give you one example of an attack and then show that the attack can be. Because, you know.
00:22:17.248 - 00:22:43.690, Speaker C: Well, that's what Nakamoto did in his paper. But that was Nakamoto. I'm not Nakamoto, so I think I have to be more careful. So, in fact, this is one particular attack. Let's call it the post unbonding attack. That means you grow the fork after you unbond, post unbonding attack. But actually there's another attack possible.
00:22:45.500 - 00:22:46.250, Speaker A: Okay.
00:22:46.700 - 00:22:59.950, Speaker C: And this is a data availability attack. Somehow this concept of data availability always creeps in. No matter how hard you try to avoid it, it just always shows up. Don't know why.
00:23:00.480 - 00:23:01.230, Speaker A: Okay.
00:23:02.720 - 00:23:42.956, Speaker C: All right, so here's an attack. So instead of doing post hawk attack, post born attack, the attacker first create a private block where the data is hidden. And then the canonical chain get rolled. And you only review the private fork after the canonical chain. So this is like a prehog attack. And this could still cause confusion. Okay, so let's understand how bitcoin timestamping could help.
00:23:42.956 - 00:24:37.848, Speaker C: Or can it help? Okay, now for this prehawk attack to work with a bitcoin timestamping service, then the attacker cannot just grow a private vault with ten data and keep it invisible to everybody, because otherwise it doesn't have an earlier timestamp than the canonical chain. So it has to put a timestamp onto bitcoin. It has to put a timestamp of bitcoin. Otherwise it cannot confuse the late joining client. Now, at this moment, there's a timestamp on bitcoin. But imagine now all the other validators, they see, hey, there's a timestamp on bitcoin. All right, but I don't see the blocks.
00:24:37.848 - 00:24:40.350, Speaker C: I don't see the actual blocks. So what happened here?
00:24:41.440 - 00:24:42.190, Speaker A: Okay.
00:24:46.020 - 00:24:52.940, Speaker C: Now the question is, what is actually this checkpoint or this timestamp put into the block?
00:24:53.020 - 00:24:53.600, Speaker A: Okay?
00:24:53.750 - 00:25:28.780, Speaker C: Even with just a hash, a block hash of the data is not sufficient, because now everybody can put a hash on timestamp, and that is not enough of a signal to tell you something goes wrong. So what we require is that it should have the quorum certificate. In other words, the same people who signed the blocks also signed this checkpoint or this timestamp. Okay, what does that do for me? All right, first, it means that to create such a block, the attacker has to have a lot of voting power to create this block.
00:25:29.120 - 00:25:29.484, Speaker A: Right?
00:25:29.522 - 00:25:52.100, Speaker C: Because it has to have the quorum. Because if it doesn't, then I just reject the timestamp. It's not valid. Second, I observed that I don't have the data. So then what the protocol would do, our protocol would do is at this moment, you say, hey, there's something wrong here. Nobody should go forward with growing the chain. Nobody should follow the chain anymore.
00:25:52.440 - 00:25:53.188, Speaker A: Okay?
00:25:53.354 - 00:26:40.324, Speaker C: So therefore, this becomes a halting condition. That means, basically you say that, hey, danger, someone has taken over this chain. We should now go to social consensus and try to restart the whole thing. So therefore, what happens here is that because we have a data availability problem, we have to deal with it, and we're using this Bt signal to host the system, to store the system, and avoid a safety problem. Now, you could completely solve the problem. If I could put the entire data onto bitcoin, then there's no data available problem. But bitcoin, you cannot put so much data on it.
00:26:40.324 - 00:27:33.936, Speaker C: This problem comes from the fact that the bitcoin has a limited time stamping service. Data. Limited time stamping service. And therefore, what this protocol does is it translates to a limitation on the liveness of the protocol. However, by doing this, I can protect the slashable state. Okay, so in this paper that we are going through the review process of s p, we proved the following theorem. So this protocol, if we build it on, say, tendermint, then what we can show is that this protocol has one third slash for safe.
00:27:33.936 - 00:28:04.400, Speaker C: Okay, so what one third slash for safe means? It means that no matter what attacks you go on this protocol, I can guarantee you that whenever there's a safety violation, I can slash at least one third of the validators. So therefore, this protocol can protect against all unslashable egg type. Okay, so that's the first statement of Ethereum. Now, what about liveness?
00:28:04.740 - 00:28:05.104, Speaker A: Right?
00:28:05.142 - 00:28:59.010, Speaker C: So security theorems usually have safety, and that's liveness. So what we show here is we have slash for safety. What about liveness? Now, liveness of attendment protocol typically is one third, okay? That means that if the validators take over one third of the voting power, then they can censor transactions or they can store the protocol. What we showed in this paper, but no time to show in this talk, is that by using bitcoin as kind of a censorship complaint platform, you can actually improve the resilience from one third standard tenement to one half. So you can strengthen the censorship, require censorship protection of the base proof of stake product.
00:28:59.780 - 00:29:02.412, Speaker A: Okay, so that's what we showed.
00:29:02.556 - 00:29:39.468, Speaker C: However, we also showed that as long as your timestamping service is data limited and you want to provide slash four safety, then the liveness resilience threshold cannot exceed one half. And that's due to the data availability constraint. Because your data limited, you cannot put all the data under bitcoin. You also cannot exceed a liveness resistance of more than one half. Okay, so that's what we showed in this paper question.
00:29:39.554 - 00:29:47.984, Speaker B: So on the first point, when you say slashable safe, should I think of that? How does that connect to definitions out there of accountability, like what you've worked on?
00:29:48.022 - 00:29:48.416, Speaker A: Right.
00:29:48.518 - 00:30:19.652, Speaker C: So accountable safety means that whenever there's a safety violation, you can provably identify violators of the protocol, and you'll never identify the honest protocol, you'll never misidentify the honest protocols, honest validators. So that's what accountability is. Slashable means that you can also catch them with this crime and slash the stick before they unbond it. So it's a stronger requirement.
00:30:19.716 - 00:30:23.416, Speaker B: So if you had infinite unbonding, period.
00:30:23.528 - 00:30:24.190, Speaker C: Exactly.
00:30:25.120 - 00:30:27.176, Speaker B: Accountable would imply slashable.
00:30:27.288 - 00:30:44.320, Speaker C: Yeah. So in particular, in a permission protocol, which is the definition of an unbound infinite bond, period, then accountability and slash witness is the same thing. But in a permissionless proof of stake protocol, they're not the same thing. It's stronger.
00:30:44.980 - 00:30:53.604, Speaker B: Meanwhile, in liveness, this is actually not going to be a slashable attack. Is that right? So you're saying like, despite the fact.
00:30:53.642 - 00:31:40.340, Speaker C: Yeah, that's right. Exactly. So liveness, we show in this paper, not only cannot be slashed, but we cannot do better than one half. So slashing basically means that it doesn't matter how many people are bad, okay, as long as they commit a crime, a safety violation, then I can slash them. Okay, so that's stronger than your classic sort of assuming a certain fracture people honest type assumption, so that we can do for safety, for liveness. What we showed is that it's not slashable. If your timestamping service is data limited and we need an assumption of majority honesty.
00:31:43.160 - 00:31:44.756, Speaker B: In this range, between a third and.
00:31:44.778 - 00:31:45.510, Speaker C: A half.
00:31:48.200 - 00:31:49.620, Speaker B: It is flatchable.
00:31:50.620 - 00:32:14.620, Speaker C: No, between one third and one half, we retain liveness. Okay, so what you want, ideally, we have a theorem. We say that if it's above one half, we can slash them for committing a liveness crime. We don't have that. And in fact, what we showed in the negative result is that you can't have that as long as the timestamps are, stay limited.
00:32:18.100 - 00:32:18.896, Speaker A: Okay.
00:32:19.078 - 00:32:19.520, Speaker C: Yeah.
00:32:19.590 - 00:32:38.550, Speaker D: Can you go to your previous slide for a second? So there's examples for why. So why can't you splash the person who published a false timestamp on bitcoin? So this seems like an attack on ledgenet, where to me it seems like slashing would help.
00:32:39.420 - 00:32:41.080, Speaker A: Am I misunderstanding?
00:32:45.740 - 00:33:20.000, Speaker C: Why can't you slash someone who published. Because you may end up slashing. Let me think about this. I think you may end up slashing honest people if you do that. Here's the problem. Is that the evidence you see, okay, the evidence you see is that I don't receive the block, right? But I see a signature. But you see, not receiving a block is not a provable evidence.
00:33:20.000 - 00:33:34.360, Speaker C: It's not a verifiable evidence. Right. Because you may be pretending that you don't receive the block. So therefore it's not like double signing, where it's irrefutable evidence.
00:33:36.300 - 00:33:39.320, Speaker D: But you also have majority honest, right?
00:33:39.470 - 00:33:48.860, Speaker C: No. Okay, so flashability, do not assume majority honest. Flashability says no matter what happens, you can still provably verify.
00:33:52.800 - 00:33:57.090, Speaker B: Okay, for the impossibility, is that synchronous model or.
00:33:59.140 - 00:34:03.490, Speaker C: Yeah, the impossibility is any model.
00:34:04.420 - 00:34:04.832, Speaker A: Yeah.
00:34:04.886 - 00:34:12.096, Speaker C: Even partial synchronous, it applies. So let's say if I assume it's synchronous.
00:34:12.128 - 00:34:14.308, Speaker B: So making it harder for you to prove an impossible result.
00:34:14.394 - 00:34:14.740, Speaker A: Yes.
00:34:14.810 - 00:34:33.156, Speaker C: So the impossible result is proved under the synchronous model, but the partial synchronous, even worse. So it's easier. It will be implied from this result. Got it. Okay. All right. So we decided to build this thing for cosmos.
00:34:33.268 - 00:34:33.930, Speaker A: Okay.
00:34:34.560 - 00:35:24.584, Speaker C: And so we have bitcoin on the one side and cosmos, all these many proof of stake chains on the right hand side. So, one way of building this is to have each one of these chainstamping onto bitcoin. Obviously, it's not a very scalable solution because of two reasons. One is that all of these chains, if they all have to timestamp bitcoin, then you're getting many, many checkpointing transactions into bitcoin. Two is that it is very hard to optimize the checkpointing mechanism onto bitcoin without a significant change to each of them protocol. So what we came up with is sort of an intermediate architecture. So we built a chain, which is a cosmos chain.
00:35:24.584 - 00:36:06.136, Speaker C: So, Cosmos have this thing called Cosmos SDK. It allows you to build a chain. And we built this cosmos chain, and we use this chain to timestamp onto bitcoin to get the bitcoin security that we discussed earlier. Okay. And then we bridge Babylon to all of these other chains in order to spread the security from bitcoin to all these other chains. Let me go into a little bit more detail how this works, because that's where the connection with IBC comes in. Okay, so, first, this part.
00:36:06.136 - 00:36:36.684, Speaker C: So, this part is quite a lot of engineering effort required. And the reason is because bitcoin has only very limited capacity to take in arbitrary data because it is just 48 byte. So, basically, we have to fit in the checkpoints, the timestamp, the signatures, all into 48 bytes, if possible. Okay, so we couldn't do it. We couldn't do 48 bytes. We could do 96 byte, though. So two transactions.
00:36:36.684 - 00:37:04.284, Speaker C: I was going to say 48 is not really a hard limit. You can have as much as you want. Yeah. But then you have to put in many transactions, hundreds of transactions. That makes it, engineering wise, very difficult. And two, the miners really don't like this. You want to sort of stay sort of a little bit low profile, because once you start sending in hundreds and thousands of these transactions, then God knows what will happen.
00:37:04.284 - 00:37:06.568, Speaker C: So right now, we send two transactions.
00:37:06.744 - 00:37:07.324, Speaker A: Okay.
00:37:07.442 - 00:37:17.680, Speaker C: Do you send two transactions or a transaction with two outputs? Two op return transactions, a pair of transactions, separate transactions.
00:37:18.820 - 00:37:19.520, Speaker A: Okay.
00:37:19.670 - 00:38:04.144, Speaker C: So there's quite a bit of engineering here. Probably won't go into details, but the whole point is that first we remember that we're basically sending in signed header as our timestamp. Okay? So every time the valid data set changes, you have to send a checkpoint in. So if the value set changes arbitrary, then you have to send checkpoint basically for every block. Timestamp for every block. By making sure that the value set don't change very often on Babylon, then we can assure that we don't have to checkpoint very often. So in Babylon we checkpoint about once every half an hour.
00:38:04.144 - 00:38:40.072, Speaker C: Once every half an hour. Second, we don't want. In cosmos, they don't use aggregate signature. So they keep the list of all the individual signatures of, say, hydrovalators. That's way too much for stamping onto bitcoin. So we wrap around that and use a aggregate BLS initiative to do that. So all these optimization, basically, you think about it, what we're doing here is, roughly speaking, we're building a bridge from Babylon to bitcoin to get the timestamping in.
00:38:40.206 - 00:38:40.804, Speaker A: Okay.
00:38:40.942 - 00:39:10.550, Speaker C: All right. So this is quite a bit of work. Now, once, however, we get Babylon to bitcoin security, then this part is actually much easier. And basically this part is through IBC. Okay, so it turns out that we can connect Babylon to all the other zones through IBC. And through this IBC, they can get the bitcoin timestamp security. So let's see how it works.
00:39:10.550 - 00:39:55.628, Speaker C: All right, so the first observation is the following. IBC actually provides a timestamping service already. Okay, so let's see how it works. So in IBC, you have a sender chain and you have a receiver chain. And what the sender chain does is it sends the signed headers of the sender chain from the sending to the receiver chain through the IBC connection. It's actually through some relay nodes. What this does is to allow the receiver chain to maintain a light client of the sender zone.
00:39:55.628 - 00:40:31.992, Speaker C: So what is a light client? A light client is basically you have the chain of headers of the blocks, but not the blocks themselves. That's why it's called light. The headers allows you to know, keep track of the valid data set. To know that the stuff that has been sent over is valid by doing a Merko inclusion proof. So the receiver chain basically maintains a like client sender zone. But what is a like client? Like client is nothing but a sequence of headers. And this light client is a so called on chain like client.
00:40:31.992 - 00:41:11.050, Speaker C: That means this like client is stored in the ledger of the receiver chain. Why do you want to be in the ledger, because you want to make sure that all the validators on the receiver zone agrees on, just like client, so that everyone is in consensus. But that's effectively the same as putting the timestamps on the headers of the standard chain at the receiver chain receiver zone. So therefore, having a IBC with a likeline is already automatically providing the timestamping for you on the receiver chain. Okay, so what does that mean for us?
00:41:12.160 - 00:41:16.620, Speaker B: So are you sort of saying the receiver chain is always online and so that's.
00:41:19.440 - 00:41:26.380, Speaker C: No, the receiver chain is not always. Okay. The receiver chain in this case is always online because it's Babylon.
00:41:27.040 - 00:41:27.790, Speaker A: Okay.
00:41:28.580 - 00:42:04.670, Speaker C: So therefore, what's going on here is that using IBC, we can have individual cosmos chain to first timestamp on Babylon, and then through the timestamp from Babylon, optimized to bitcoin as an aggregate, they will also get all the bitcoin timestamps. And so therefore, we don't need 100 chains or 1000 chains. All timestamping onto bitcoin. One timestamp can aggregate all timestamps. That's our design to make this timestamping idea scalable. Okay.
00:42:05.120 - 00:42:05.772, Speaker A: All right.
00:42:05.826 - 00:42:51.550, Speaker C: So right now, we are integrating in progress with a bunch of cosmos chains, and this is work in progress. So to integrate with them, we have to do governance proposals. So we were talking about earlier on chain governance versus off chain governance and cosmos uses on chain governance. So we have to write a governance proposal to propose them to integrate with us. And then they will have their community members, the validators, to vote on whether or not they accept it. So this is in progress. But so right now, what we're doing is we are opening IBC connection with them and we're giving them bitcoin timestamping information.
00:42:51.550 - 00:43:27.220, Speaker C: So this is the bitcoin. So, right now, Babylon is in the devnet mode. It is timestamping to the main net of bitcoin. The main net of bitcoin. All right, so here we have apocalypse of 400 blocks on Babylon. And each at the end of APOC, we send one timestamp onto bitcoin. So these are the recent, most recent timestamps onto bitcoin.
00:43:27.220 - 00:44:10.532, Speaker C: Whenever you issue an unbonding request, we wait until the timestamp of that unsponding request becomes 20 block deep and there's definite. And the unbonding time, which is the delay to get into the bitcoin chain and wait until it's 20 block deep, is, on average, four and a half hours in our experiment so far. So you can see that the checkpointing is actually rather irregular. Rather irregular. That's because of the statistical nature of bitcoin. It takes time to get a transaction into bitcoin. Sometimes slow, sometimes fast.
00:44:10.532 - 00:44:40.300, Speaker C: Depends on the congestion. The block creation process is also random. So you can see the randomness here, but you can see that with 20 block deep, which is pretty good, you can get an unbonding time of four and a half hours, if you prefer, 100 block deep, then it will be five times that. So it's going to be about 20 hours. So less than a day. I don't think any PoS chain would like an unborn period of 4 hours. It's probably too fast, but it may be a little bit longer, like a day or so.
00:44:40.300 - 00:44:44.750, Speaker C: So the people that we're talking to, they're thinking about unborn period of a day.
00:44:47.200 - 00:44:47.864, Speaker A: Okay.
00:44:48.002 - 00:45:40.620, Speaker C: All right, so that's the Babylon chain running with timestamping onto bitcoin. And the unbonding right now is applied to the Babylon chain itself. So this is our eat our own dog food chain now in terms of providing service to others. So right now we have four cosmos chains, injective osmosis, Akash and Juno. Some of them are pretty big, like osmosis and Juno, pretty big chains. So they are opening an IBC connection to Babylon. And Babylon in return is giving them the timestamping information on which block has the BTC timestamps and what BDC timestamps are there each blocks.
00:45:40.620 - 00:46:10.680, Speaker C: So here are the height of these blocks. Who has BD timestamp. And these are the finalized BTC block that timestamp them. So that means that whenever your client, you look at this oracle, you know, sort of the timestamp on your blocks. And that can help you to safely join the system. Okay, so the next step is to automate this and to use the timestamp information in an automated way to help them safely unborn. So that's work in progress.
00:46:10.680 - 00:46:25.124, Speaker C: But this is a live running chain right now. All right, so the second part is about bootstrapping small chain. So bitcoin allows us to make all that tax lashable.
00:46:25.272 - 00:46:25.970, Speaker A: Okay?
00:46:26.900 - 00:46:48.340, Speaker C: But if the token valuation of a small chain is low, then you're still limited by the economic security. Okay, here's an example. Suppose I have a new Cosmo zone called rug pool. Rug pool zone. It is communicating with osmosis, which is a Dex. Which is a Dex. I need to communicate with it through IBC.
00:46:48.340 - 00:47:29.670, Speaker C: So the founder locks 1 million rug tokens for 100 osmos token on the rug pool chain. And then sends an IBC message to osmosis. And at the other end, the osmosis founder receives 100 OSmo token at the osmosis. So very good. However, it then does a double spend a fork on the sender chain. And so this transaction is now negated. So that means it got now 100 osmo token without paying anything for it.
00:47:30.040 - 00:47:30.404, Speaker A: Okay?
00:47:30.442 - 00:48:10.844, Speaker C: You say, hey, how can that happen? Of course it can happen. It can happen because it can fork, the founders depend at more than 1ft. It can fork the chain after they get an osmos token. Of course, this forking is not punishable by slashing. But if it's a small chain, the slashing penalty could be less than the amount stolen. Okay, so in this case, the economic security itself, although I could flash, is not sufficient to protect in some sense against this IBC communication is that money is now stolen.
00:48:10.972 - 00:48:11.504, Speaker A: Okay?
00:48:11.622 - 00:48:16.050, Speaker C: And so osmosis is now saying, hey, it's not so good to communicate with this guy.
00:48:17.320 - 00:48:18.164, Speaker A: Okay.
00:48:18.362 - 00:48:41.160, Speaker C: All right. So actually, if you think about what we did for bitcoin timestamping, what are we actually doing here is you can think of the timestamping as like providing bitcoin level security to a particular transaction type earlier, which is the unbonding request.
00:48:42.160 - 00:48:42.572, Speaker A: Right?
00:48:42.626 - 00:49:35.804, Speaker C: So all the transactions or the PoS chain is going through the fast finality process, except for this unbonding request, which is going through the slow bitcoin confirmation. And based on that, we act on that, based on unbonding. So a natural question is, why don't we just apply bitcoin confirmation to all transactions? Every transaction you have to wait until bitcoin confirmed. So it's a double confirmation process. First you finalize on the rug pool chain, and then you wait until the timestamp is confirmed, bitcoin only. Then you consider transaction really final. Now, in that case, then for the attacker to steal the money, it has to fork bitcoin, which is very hard.
00:49:35.804 - 00:50:01.670, Speaker C: And so in some sense, your economic security is now the sum of the bitcoin economic security and the rug pool economic security. You have to fork both chains, bitcoin and rug pool. The bad thing about this is bitcoin is slow. So if you do this for every transaction, everything slows down into bitcoin confirmation. We don't want that. We don't want that.
00:50:02.840 - 00:50:03.540, Speaker A: Okay?
00:50:03.690 - 00:50:27.790, Speaker C: And the reason is because here we are relying on double confirmation, not only on a special transaction like Nbondi, but for every transaction, okay? So however, there is actually a chain that can actually provide this time stamping. Naturally, because remember.
00:50:33.060 - 00:50:35.632, Speaker A: That we are talking.
00:50:35.686 - 00:51:35.512, Speaker C: To osmosis through an IBC, right? But the IBC, as I mentioned, provides a natural timestamping onto osmosis. So actually osmosis by the fact that it's running a live client to observe rug pool, is already timestamping rug pool's blocks. And so that becomes the natural chain that can provide additional economic security to rug pool. So I find that quite fascinating, is that you're running a like client to observe the other guy to make sure that the transaction is valid. But at the same time, you're also providing economic security protection to that chain. So let's see how that works. All right, so now, instead of thinking about timestamping to bitcoin, which is very slow, I now timestamp to osmosis, which is a proof of sick chain, which is much faster.
00:51:35.512 - 00:51:37.700, Speaker C: So to wait for double confirmation.
00:51:43.480 - 00:51:43.844, Speaker A: All.
00:51:43.882 - 00:52:55.768, Speaker C: I need to wait for is to confirm. What we have to wait for now is a confirmation on broadfall and a confirmation on osmosis, which is much faster. Now, the economic security is not as good as bitcoin, no doubt, but it's much faster. So there's a trade off between speed and security. But the good thing about this is because the IBC already provides a natural stamping, I don't need to do this explicitly additionally anymore. So, therefore, to attack this whole system, the attacker not only has to fork off rug pull, which is easier because there's low economic security, you also have to fork off osmosis, which is a bigger chain. So osmosis, by virtue of economic sort of communication, economic transaction with the smaller chain, can also provide security to it, additional security to it, and that makes the confidence of the economic exchange stronger.
00:52:55.768 - 00:52:57.470, Speaker C: So I think it's quite nice.
00:52:58.880 - 00:52:59.630, Speaker A: Okay.
00:53:01.360 - 00:53:28.890, Speaker C: So osmosis is transferring security from itself to the rightful chain. You can apply this concept to even two big chains. Osmosis can provide security Juno, because they do communication through IBC. And in fact, you can make this both ways because the IBC is timestamping in both directions, so they can exchange security and you can get the sum of security. So you can prove some security theorems behind this as well.
00:53:29.420 - 00:53:30.170, Speaker A: Okay.
00:53:30.620 - 00:53:59.330, Speaker C: All right. So I find that quite interesting, because the whole point of the interchange is you have these sovereign chain as though they're countries having economic alliances through IBC. What we're observing here is that security alliances can follow naturally from economic alliances, which I think is quite interesting and can be developed further, I believe.
00:54:00.660 - 00:54:01.840, Speaker A: Thank you, David.
00:54:09.160 - 00:54:12.310, Speaker C: I guess I had a question more about the first part of the talk.
00:54:12.920 - 00:54:13.670, Speaker A: Sure.
00:54:16.120 - 00:54:19.732, Speaker C: I guess what happens if bitcoin collapses?
00:54:19.796 - 00:54:20.024, Speaker A: Right.
00:54:20.062 - 00:54:26.680, Speaker C: And you've shortened your unbonding period because you're sort of trusting bitcoin for timestamping.
00:54:27.980 - 00:54:28.392, Speaker A: Yeah.
00:54:28.446 - 00:54:57.676, Speaker C: So, that's right. There's no free lunch. If you trust something, then if that thing collapses, then you have a bit of problem. However, if bitcoin collapses, there may be many other problems. I don't know. So we thought about how one could design a system in which one can have some fallback if bitcoin gets forked. We have not succeeded.
00:54:57.676 - 00:55:03.270, Speaker C: And I think there's probably impossibility. Result? We say that, yes.
00:55:03.880 - 00:55:20.068, Speaker D: So on the second part of the slide, you were kind of gesturing at an additive economic security situation for additive confirmation time, adding, is there a theorem of that form? It literally just adds the theorem we'll.
00:55:20.084 - 00:55:21.210, Speaker C: Work on right now.
00:55:22.400 - 00:55:28.440, Speaker D: And it's the idea that you take the minimum of all of those timestamps for every block.
00:55:28.520 - 00:55:38.012, Speaker C: Yeah. So what's the confirmation rule? Right, let's see. Let's look at this. So, normally, I confirm when I see enough signatures on this block.
00:55:38.156 - 00:55:38.850, Speaker A: Okay.
00:55:39.300 - 00:56:17.816, Speaker C: So now this timestamp goes into this chain, and this chain will now have their chance to vote on it. So it's like having two committee, committee, rug pool first vote, and then committee from osmosis, then vote. Okay, so to destroy this finality, you have to fork both rug pool and osmosis. And that's why the Economic Security act, because now you're paying a slashing penalty on both the purple chain and the yellow chain.
00:56:18.008 - 00:56:24.456, Speaker D: So what if we also have bitcoin as a third chain and you're trying to derive economic security from both?
00:56:24.578 - 00:56:25.248, Speaker C: Yeah.
00:56:25.414 - 00:56:28.224, Speaker D: So I guess it's unclear to me how that mechanism would work.
00:56:28.262 - 00:56:31.408, Speaker C: Yes, that's right. Yeah. That's research.
00:56:31.494 - 00:56:32.560, Speaker A: Yes. Okay. Yes.
00:56:32.630 - 00:57:14.610, Speaker C: So your question is, if I checkpoint simultaneously to more than one chain, then how do I combine and get more security? That's open research problem. Still working on that. Right now, it's just one. It's now the yellow chain checkpointing to its IBC partner, which is the purple chain. But I think one can probably prove a theorem which is more straightforward, which is, suppose the yellow chain is checkpointing to the purple chain for fast economic security, and simultaneously checkpoint of bitcoin to get long range protection. You can prove a theorem which you can get. That's pretty straightforward, I think.
00:57:14.610 - 00:57:23.660, Speaker C: All right, World cup time. Thank you very much for having me here. Bye.
