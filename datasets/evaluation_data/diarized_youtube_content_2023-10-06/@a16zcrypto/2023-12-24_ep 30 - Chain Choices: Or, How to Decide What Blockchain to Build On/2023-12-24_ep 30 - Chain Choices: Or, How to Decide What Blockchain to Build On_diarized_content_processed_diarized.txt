00:00:00.330 - 00:00:05.886, Speaker A: You welcome to web3 with a.
00:00:05.908 - 00:01:04.618, Speaker B: Six and Z, a show about building the next generation of the Internet from the team at a six and Z crypto. That includes me, your host, Sonal choxy. Today's episode is about a popular topic for many builders in web3, as well as people coming into the space for the first time, or for just anyone interested in tech innovation and the evolution of infrastructure, which is decide which blockchain to build on. It's a nuanced topic, so we dive into all the tangly threads here. The first third of the conversation focuses on the overall landscape, orienting us into the broader implications, why it matters, useful definitions, and a quick sketch of how the space is shaking out so far. And then after exploring that terrain, we focus the rest of the episode on common questions, specific tradeoffs, and how to decide between different chain choices, including discussing tech specs, community marketing and ecosystem support, security custody, programming languages, much more our expert guests today are AsiCs and Z Cryptos Guy Woolette and CTO Eddie Lazarin. The first voice you'll hear after mine is Eddie's, followed by Guy's.
00:01:04.618 - 00:01:25.654, Speaker B: As always, the show notes have links to related episodes and resources mentioned in the episode. And as a reminder, none of the following should be taken as investment, legal, business or tax advice. Please also see asics.com disclosures for more important information, including a link to a list of our investments. Since we are investors in some of the companies mentioned in this episode today.
00:01:25.772 - 00:02:04.934, Speaker A: We'Re talking about a topic that's super top of mind for all kinds of founders and builders in the crypto space, and actually even for people entering the space. And one of the questions that comes up is actually, in any technology company, one of the fundamental questions you think about is what is your tech stack going to be? And in the world of blockchains and crypto, that's actually a much more nuanced question. So before we actually start talking about the topic of this episode, which is chain choices, or how to think about choosing your blockchain, why does it matter? I mean, in other fields you might just be like, oh, I can just switch. And we're so used to technology that is kind of fungible. Like, oh, I'm just going to switch my data service provider. I'm going to switch my so and so.
00:02:05.012 - 00:02:14.690, Speaker C: Yeah, if you wanted to switch from Google Cloud to AWS to digitalocean to whatever, it's a seemingly straightforward path to do that. And it's different for blockchain.
00:02:14.770 - 00:02:17.126, Speaker A: Yeah. And so why is it harder here?
00:02:17.228 - 00:03:01.938, Speaker C: Yeah, one obvious one is that if you're deploying a system that you hope to be decentralized and outside of your control, definitionally, you can't pack up everything and just move it. You've deployed a system that other people can build on and take its properties for granted. That's part of what makes crypto so exciting. If that's what's happened, then you can't sweep up everybody and move them. That makes it a little bit harder. Now, of course, everybody could coordinate and do a migration together, but it's a lot more work to do that. The second is that if you think of a blockchain computer as a shared state computer, a shared state machine, and if the applications you've developed are working, they're probably intertwined with all kinds of other applications.
00:03:01.938 - 00:03:37.954, Speaker C: That makes it harder to move, because where you're going isn't where all the stuff you're already integrated with exists. So those technological properties make it harder. Why it matters partly because it's hard to move, right? That's like a big part of it. But the choice of chain affects the gas fees, it affects the security model, it affects the tools you have available, it affects the ecosystem that you're enmeshing yourself with. There's a lot of consequences that come with this type of decision. It naturally comes up a lot. As a top question, a few points.
00:03:37.992 - 00:04:30.306, Speaker D: Here, I think it matters. One, because the switching costs are so high for all of the reasons eddie just articulated. And I think there are two good examples of projects that have successfully switched. And even in those cases, it demonstrates why it's so challenging. The first being helium, which initially launched its own blockchain and has recently decided to move over to Solana, a process that has taken quite a bit of time and effort, not only getting the community to help form consensus around that choice, but also just on the engineering side, there's also a game called Axie Infinity that originally started on Ethereum mainnet and then moved over to loom, which was an early scaling solution, and finally decided to deploy its own blockchain called ronin. And in both of those cases, I think it was easier to switch than for the average crypto application because they were both useful in their own context and didn't compose a lot with other projects. And so I think, one, it's hard to align the community.
00:04:30.306 - 00:04:40.862, Speaker D: Two, it's a significant technical challenge. And then three, to the extent you have significant integrations and you've composed with other projects on a given chain, it's almost impossible to move over after some point.
00:04:40.936 - 00:04:59.894, Speaker A: Right. And this goes to what Eddie was saying about the ecosystem you're enmeshing with. But also just again, for the listeners who might still be new to the space. When you say compose, you mean it in the context of composability, which is one of the key features that we care so much about in crypto and blockchains, the ability to essentially use these elements like Lego blocks that people can build on top of each other, et cetera, et cetera.
00:05:00.022 - 00:05:16.542, Speaker D: Yeah. You can think of this like if you've built a foundation of a house, it's hard to move the house without destroying that foundation. Especially if people are building things on top of your protocol and those things built on top of your protocol are valuable and highly used, then you can't sort of smash that foundation down without destroying everything built on top.
00:05:16.676 - 00:05:22.562, Speaker A: Great. Let's actually set a little bit more context about what is a blockchain and then kind of the elements that make that up.
00:05:22.696 - 00:06:17.954, Speaker D: Yeah, so when I refer to a blockchain or a chain in this context and choosing a chain, I'm thinking about what is the set of infrastructure that enables me as a developer, as a founder, to build a decentralized application. And almost all the time we're going to talk about smart contract platforms that have some notion of consensus, allow me to deploy an application on what you can imagine is sort of like a world computer. There are multiple components of this. You might hear things like l one or l two, and you can decompose it into multiple layers of a technical stack. But we're probably going to refer to this as a chain or a blockchain in this context. And that's really what we mean. And when you're choosing a chain, there are a lot of different technical dimensions that we'll get into, but there are also dimensions around the user experience, around the community you're building, around the other applications on the same chain that you can interoperate with and compose with, that you can put those Lego pieces together, essentially.
00:06:17.954 - 00:06:25.138, Speaker D: And those are all considerations that you, as someone who's building a new project and protocol, should take into consideration.
00:06:25.314 - 00:07:09.998, Speaker C: I'd also say maybe just for the builder, the way to think about what a chain is, is it's the place you deploy your application. So we're at a really interesting point in the history of the development of blockchains. Only a few years ago, there were very few actual live choices. And right now there are tons of choices, and they're all scattered across the trade off space. And exactly how those choices will play out is not yet clear. Many of the most interesting choices that people talk about aren't even fully formed yet, are just at the horizon. We're in this weird moment in time, this exact moment in time where I think it is probably the hardest to make the decision, and it'll get a lot easier in the coming years.
00:07:09.998 - 00:08:07.358, Speaker C: But if you're trying to take advantage of some of the new technology right now, you need to make a choice right now, at least provisionally. And underneath the hood, there are all kinds of possibilities in terms of where's the data stored, what is the exact execution environment I'm running on? Like where's the consensus being held, whatever, all those types of things. But some of the options in the framework that we're going to talk through are going to just assume it's a place where you deploy your application and abstracting those properties away. Take Ethereum as an example. In Ethereum, the l one, today, execution and data availability and consensus are all happening in the same machine. So we typically think of that as like the blockchain bundle, but it is possible to separate them out to some extent in some very interesting ways. One is if you look at an l two, on Ethereum, that is a way to move execution to a different set of machines.
00:08:07.358 - 00:08:44.386, Speaker C: But to keep data availability on Ethereum, there's even ways to separate components of consensus away from that. There's some so called modular blockchains where they're considering really separating each of these components out. But I still think that although it's very interesting to get into those details, they're only one part of the story in terms of a chain choice. And even then, there's probably only one place that you're really thinking about deploying your application. When you write the actual code, you're kind of pointing it at one thing, and it's possible those other components have been bundled with it or separated from it.
00:08:44.488 - 00:09:42.806, Speaker D: To make this very concrete, you can spend a lot of time trying to pick a different Ethereum l two, and then spend a lot of time thinking about which shared sequencer might I choose and which data availability solution might I use. Celestia Ethereum, something like Eigen da. I tend to think about the blockchain design space as being highly dimensional, and this is something we talk about on our team a lot, as each blockchain being a vector in this multidimensional design space. I think this is a useful way to think about it, especially from an engineering standpoint, and there's a good reason so many people have tried to build different blockchains. There's a good reason why there are so many choices, because there are a lot of valid choices that you, as a builder or developer wanting to deploy a smart contract might choose. And it's further useful to say that there aren't one or two trade offs that are important, but there are a lot of different trade offs. You almost need to be like doing our job or an academic to go through and really look at each of the different choices today.
00:09:42.806 - 00:10:10.762, Speaker D: And it's not going to be the way, at least in my opinion, developers will pick where they deploy their applications. It's not that complicated in the traditional world, and it can't be in crypto moving forward. And so the way I think about this is founders and builders should essentially stack rank the dimensions that they care about most, and then try to find the vector in that highly dimensional design space that is closest aligned to what their ideal would be. And to me, that's really the process of choosing a blockchain.
00:10:10.826 - 00:10:12.394, Speaker A: So that's what you mean by multidimensional?
00:10:12.442 - 00:10:12.942, Speaker D: Yeah.
00:10:13.076 - 00:11:19.122, Speaker C: So this is definitely a little bit oversimplified, but if we take two of the things, which is data availability and execution, one of the most interesting ways that efforts to scale blockchains have separated is along that line. Like do we separate out execution and data availability, or do we keep them together and try to scale with them together? That's one of the key kind of rifts if you think of that. That way there are layer ones and that include new layer ones. We can talk about some of their properties. And there are this kind of amorphous category of almost application specific or sharded sort of roll up blockchains, where there's one thing at the center, like ethereum, maybe there's not really a specific thing at the center, but kind of a protocol that connects the parts. And then there's these many different chains that are all interacting together, mediated or not, by something in the middle. So on the one hand there's new layer ones where all the core pieces are put together of data availability and execution.
00:11:19.122 - 00:12:04.900, Speaker C: And then on the other hand, there are maybe these application specific chains is one way to talk about it, where at the center there may be a network that provides data availability or not, or a protocol to communicate about what data is available. And then at the periphery there are a bunch of different chains that are all performing execution and coordinating like that. So very loosely speaking, those are the two categories that we're seeing emerge. Some examples of new layer ones or of layer ones that are really pushing the envelope for scaling explicitly are like Salana Sui, aptos near. They are specifically trying to scale the L1s in and of themselves.
00:12:05.290 - 00:12:05.750, Speaker A: Right.
00:12:05.820 - 00:12:32.394, Speaker C: And then these broader, maybe application specific strategies, not necessarily application specific, but where they separate execution, are like optimism, arbitrum, cosmos, zksync. They are thinking a lot about creating a separate execution area and then allowing scaling to bloom from there with maybe application specific chains or things like that.
00:12:32.512 - 00:13:16.086, Speaker A: Okay, I have to just say, that is so fascinating to me. I grew up in the Bay area as a kid, and so the heart of Silicon Valley, and my dad's an electrical engineer. He's retired now, but he was like a pioneer in VLSI design. And what you just said was so interesting to me because it reminds me exactly of how semiconductors evolved, a, with this whole wave of more general purpose circuitry, and then b, application specific ways of thinking about those layers of circuitry. But it's also really interesting to me because it reminds me that when we think about computing today, it's actually not also like previous waves of tech innovation, because these things are also kind of happening at the same time. Because in past computing waves, they kind of happen almost linearly and locked up. And here it's almost like you can kind of go nonlinearly.
00:13:16.086 - 00:13:36.030, Speaker A: Like you could have this debate play out at the exact same time. That was not possible in previous computing. We often talk about parallels in the history of computing and crypto and where they do and don't apply. I mean, this is just a side riff, because I obviously am a huge student of technology history and computing history. So for me, I find that a very interesting pattern. Anyway, little sidebar for a second.
00:13:36.180 - 00:13:44.960, Speaker C: When you say the debate plays out at the same time, do you mean like the debate about the architectures kind of play out as the space is figuring out what to do with the application?
00:13:45.370 - 00:13:55.074, Speaker A: In previous areas of computing, the constraints define the problem. And while that is absolutely true here, you can do so much more in software, it's kind of fascinating how the debate is playing out a little differently.
00:13:55.122 - 00:14:27.854, Speaker C: No, I think that's right. And I think a lot of that has to do with the fact that maybe just a funny little way to summarize it, is that the architectural choices we're all debating, although they are the properties of a kind of computer, a blockchain computer, it's all happening in software. Yeah, I mean, that's kind of weird. Like architectural considerations of fundamental infrastructure and all the important advancements over the last five years. Have been really in the software. There's been very little that has fundamentally changed the space that occurred specifically in the hardware level that may change.
00:14:27.892 - 00:14:28.250, Speaker A: Exactly.
00:14:28.340 - 00:14:44.038, Speaker C: Definitely with like ck proving stuff, and ASICS is an exception for bitcoin. But a lot of things we're talking about right now, these application specific chains, this data availability layers, like l one versus execution shards, blah blah blah, all of this is all software stuff.
00:14:44.124 - 00:15:15.538, Speaker A: And it reminds me, by the way, just close that thread in the whole evolution and the moment in computing history when we went from networking that was so defined by the hardware layer to software defined networking, which our colleague Martine obviously was a huge pioneer in. So it's always becoming full circle and very exciting for me because of course I'm a total nerd for all this stuff. I love it. So we covered the definitions, we covered a little bit about why it matters. This is just setting context. One thing is can you guys quickly tell me what are the most frequently asked questions you get when builders come to you at first, what do they ask?
00:15:15.704 - 00:16:01.210, Speaker C: The questions range from very qualitative to is such and such option legit? That is the most basic. But we live in a complicated space, there's a lot of non legit options. So the basic kind of legit check is almost always the first one, right? And then they go all the way to more specific things like what are the transaction fee properties? What can I expect in cases of congestion? What are the security assumptions of my system? Do I have to run infrastructure? What developer tooling surrounds this ecosystem? Is it growing? Are other good people building on it? How long is it really going to last? Is it very decentralized? The range of questions is just massive, from extremely technical and specific to very qualitative.
00:16:01.290 - 00:16:58.510, Speaker D: Gut I think one question that people almost never explicitly ask, but they're almost always implicitly taking for granted or should be asking, is, how do I define decentralization? A lot of people coming from web two have some notion of decentralization in their head, and it's never formally defined in crypto, and I would argue it's probably impossible to formally define it. And different chains will say they're decentralized, meaning different things. And so I think it's worth, as someone building a project, to ask, why do I care about decentralization? How is it meaningful for my project? And then on those dimensions of decentralization, does this infrastructure or chain choice actually give me the characteristics I need? Ali on our team wrote a very good post a couple of years ago called the Four Horsemen of centralization that goes through and sort of breaks down how you might reason about decentralization and how it matters.
00:16:58.590 - 00:17:24.474, Speaker A: That's great. I'll put that post in the show notes for the listeners that are curious. I'd also guide them to Miles's guide on legal frameworks for decentralization and how to think about it as a builder, and I'll link to that as well. So that'll be great context for the listeners. So guy, maybe you can start off with some frameworks which I think are very helpful, especially if you oriented into the builders. Because one thing I like to do in my episodes and the listeners knows this is set a bit of a map in the terrain for thinking about.
00:17:24.512 - 00:17:58.402, Speaker D: The space for sure. So I think the most common thing is people want me to give them an answer, and I think that's absolutely the wrong approach. Like you should not find your investor or your very technical friend and be like which blockchain should I choose? Because they don't actually know what you care about and they're going to give you the answer for them. They're going to give you advice that they would want to take, but they're not you. They don't understand the project you're building in depth, they don't have the same set of considerations and priorities that you do. And so I would encourage everyone not to ask for an answer, but to ask for a process.
00:17:58.536 - 00:17:59.590, Speaker A: Oh, interesting.
00:17:59.740 - 00:18:54.342, Speaker D: So when I think about choosing a blockchain, I have a framework, a plan, words of a pid loop. It doesn't mean the same thing, but the p is prioritize, I identify d decide. So figure out what you care about, which dimensions of the multidimensional design space you care about the most, and prioritize them very explicitly. The second step, identify the solutions that fit your priorities, that fit your requirements, start to narrow them down, and then d decide. Go through and actually talk to different people building in those ecosystems, the associated foundation, projects that have users that you're interested in targeting or projects that you're interested in composing with, and then make a decision. I would encourage you to think of this as an iterative process as well, especially because the pace of infrastructure is changing so rapidly. It's not something that you would do once and will be the correct answer for the next ten years, probably not even for the next twelve months.
00:18:54.342 - 00:19:01.190, Speaker D: So as you go through and do this several times, it should be a quicker and lighter weight process as you become better at it.
00:19:01.260 - 00:19:19.694, Speaker A: I like it. So guy, instead of Uda loop, which everyone loves to talk about if they haven't read the biography of Boyd, we should coin this guy's PID loop or whatever for choosing a blockchain. You mentioned that there's like multiple dimensions, like technical dimensions, community dimensions, et cetera, et cetera. Can you talk a little bit more about that?
00:19:19.812 - 00:19:53.254, Speaker D: Yeah. So I think as a person building a crypto project, wanting to deploy an application, you should think about a bunch of different components that are technical. There are a bunch of different components that relate to the community that's a part of that chain. There are a bunch of different components relating to Ux. There are a bunch of different components relating to things like liquidity and financial markets on that chain. There are a bunch of different components relating to interoperability or cross chain. So I'll go through first, what are the technical considerations? What are the technical dimensions of a blockchain? I think the first one would be the programming language.
00:19:53.254 - 00:20:14.890, Speaker D: So what is the developer experience for you as someone building an application? What language am I building in? Is this language supported by other chains? And when I say programming language, that also often comes with a virtual machine. So, solidity is a programming language that compiles down into EVM bytecode, that can be run on Ethereum, but can also be run on a bunch of different other blockchains.
00:20:14.970 - 00:20:31.446, Speaker A: Are there ever questions from people coming from web two to web3, where, let's say they're just super familiar with one programming language or one way of thinking or one mental model of approaching a problem? And do they often ask what's most familiar to x in order for me to easily transition to y?
00:20:31.628 - 00:20:55.994, Speaker C: I have gotten that occasionally, but it's usually a pretty short discussion, because the truth is there's nothing even in Solana, where they use rust, which, of course, is an increasingly popular general purpose programming language. It has a lot of idiosyncrasies that are specific to Solana, so it's just not a clean mapping.
00:20:56.122 - 00:20:56.846, Speaker A: Got it?
00:20:56.948 - 00:21:28.482, Speaker D: Yeah. Another important technical characteristic is latency. So how long does it take when a user submits a transaction to my application for it to be considered final and irreversible? Another is throughput. How many users at one point in time can all be using my application? And then another important technical consideration that I think is a little bit more amorphous, but matters quite a lot is decentralization. And you can look at things like a Nakamoto coefficient, or how easy it is to run a full node and to verify the chain as being some simple heuristics.
00:21:28.546 - 00:21:33.818, Speaker A: There are there any others along the lines of UX or other dimensions you want to say more about?
00:21:33.904 - 00:22:45.498, Speaker D: I'll go through some of the things that you might care about when you're thinking about the community associated with building on a specific blockchain. One of them is simply what are the other projects that have also deployed on this chain? Because if another project has also deployed on the same chain, you get atomic interoperability, atomic composability with that project. You also can think about this from a user standpoint of like where are the users that I want to use my application? If they're on one chain, then you should perhaps strongly consider building on that chain because your users are already there and it's going to be easier for them to access what you're building. There are some, I would say pseudo technical considerations around tooling support like block explorers and wallets, developer experience around documentation, things like RPC providers that make it easier for other people to build and to compose on your application will also make it easier for you to hire people to help you build this application. And even you yourself experimenting with building these applications. And then a lot of these also interface with the experience your users have. So some blockchains, it's much easier to build a web two like experience where someone doesn't need a wallet, can pay with a credit card, for example, if they need to issue a transaction.
00:22:45.498 - 00:23:02.246, Speaker D: Other blockchains require that your user has a notion of a seed phrase and is pretty technical in some cases. And depending on the application you're building, you might actually want to target a very technical audience who's willing to get into the weeds, or a fairly nontechnical audience who wants a slick experience and wants it to be abstracted away.
00:23:02.348 - 00:23:17.606, Speaker A: So those are some of the dimensions under the community category. And you also covered technical. And by the way, I agree with you that even though Devx is semi technical, it to me falls into community as well, because it really is about the community of developers being there and working together and creating that tooling.
00:23:17.718 - 00:24:02.138, Speaker D: Yeah, choosing a chain is not just about technical infrastructure, AWS or GCP, but it's also about choosing a cultural, and in some senses a religious movement. People have really strong affiliations to Ethereum, for example. And just like in the traditional, the web two or even consumer goods worlds, there are commodity products that are marketed very differently to different groups of people. I think like soft drinks is an excellent example of this. You have a drink like Mountain Dew is marketed very differently than a drink like Coke or PEPC is marketed very differently than a drink like sprite, it's all flavored sugar water. But the groups of people that actually buy that product and engage in it are in many cases very different. So there are two questions.
00:24:02.138 - 00:24:37.318, Speaker D: One of which is, for a commodity product, which group or religion am I associating with? And then second, for differentiated products, do those natively sort of enable the cultural or religious group or movement that I want to associate myself with? And I think it's almost impossible to totally decompose from the other elements of the chain. But in many cases, you would choose to build on a gaming chain that is almost identical to a defi chain, simply because there are a lot of other games there, and because a lot of users themselves are really interested in this specific type of crypto application, for example.
00:24:37.484 - 00:25:38.402, Speaker C: Well, the negative framing is that in the absence of more specific trade offs, people often create sort of religio cultural ways to define who's friendly and who's not, and what's a good choice and what's a bad choice, and what's my team, and what's your team? And that is a little bit of what's going on. A lot of the time people are trying to create distinctions and distinguish themselves through these things. That's kind of like the negative frame. The positive frame is that in some sense they're just technical properties and machines with very obscure or opaque differences. To make those most legible to people, sometimes you have to abstract them up into cultural, religious stuff, because that's how people reason very quickly. It kind of makes archetypes and memes make these complex ideas very easily legible.
00:25:38.466 - 00:25:40.342, Speaker A: In a small amount of very gerardian.
00:25:40.486 - 00:26:10.206, Speaker C: For better or for worse. Some blockchains are thought of as like being right for this type of application or this type of person, like this type of blockchain. And those can be positive or negative. They can be positive because they attract that type of person. They just think, well, I'm the type of person, so I'm pattern matched to this blockchain or this ecosystem. It can be negative because it can exclude people can think, well, that's just not for my type of project. Even though there's no technical properties that make that the case, I think bitcoin.
00:26:10.238 - 00:26:37.830, Speaker D: Is a good example. You can think about bitcoin as being likely the most decentralized and censorship resistant blockchain. And you see that manifested in the stereotype of the traditional bitcoiner. Someone who's interested in austrian economics and sort of using the stake gun in bitcoin's meme, which is very different from ethereum, which is much more focused on programmability and much more focused know, building a world computer, as opposed to building digital cash or digital gold.
00:26:37.910 - 00:27:04.398, Speaker A: That's fascinating what you guys just said, eddie and Guy, because it actually just goes to show that brand plays a role, whether it's like a marketer or a community. Bottom up design brand. At the end of the day, these things have personalities and an ethos and a culture and guy's phrase, even a religion. And Eddie, to your point, I don't think it's about being positive or negative. It doesn't even have to have a moralistic angle to it. That just happens to be the way cultures evolve.
00:27:04.494 - 00:27:08.814, Speaker D: Yeah, I think white papers are like crypto product marketing.
00:27:08.942 - 00:27:18.726, Speaker A: They 100% are. I totally agree with that. Okay, so Eddie, would you add anything more to some of those dimensions that guy outlined? I mean, do you think he missed anything? Is there more to say there?
00:27:18.828 - 00:27:53.218, Speaker C: I don't think guy missed anything. I'd add a couple interesting nuances. One is composability. We talked a little bit about throughput, in particular because of how it relates to fees. But to take those two as an example, there's a tension between them, because the more composable the environment is, and the more like, if you go to theorem l one, everything is synchronously composable with every other thing in there. That also means without some clever tricks, you get all applications share the same gas market. They all share the same gas market.
00:27:53.218 - 00:28:22.698, Speaker C: And now Solana has local fee markets. So they have ways to separate the gas auction, the compute auction by applications. And a lot of systems will probably experiment with this type of thing to alleviate some gas contention. But across other chains, you have to make this type of choice. Like, to what degree can I insulate myself from congestion at the level of my chain versus to what extent am I fully composable and can take advantage of everything else around?
00:28:22.784 - 00:28:24.254, Speaker A: That is so interesting.
00:28:24.452 - 00:29:08.106, Speaker D: To make the abstract point, if you think about this as a vector, the dimensions are not independent from one another, in fact orthogonal. Many of them have a strict trade off. And Vitalik famously talked about the scalability trilemma of scale, decentralization and security. And that's a very simple razor about which to think about this. But I think that idea applies across almost all of these domains, in that a choice along one dimension is going to limit or constrain the set of choices you'd make along other dimensions. Which is why I think it's important to stack rank how much you care about each dimension. Like a simple way to think about this was to greedily optimize the priority you care about first, and then subject to the constraints that introduces go through, 2nd, 3rd, fourth, all the way down the list.
00:29:08.208 - 00:29:18.750, Speaker A: Yeah, it's basically a complex system, and you're giving people an easy way to reason about it by choosing one thing to focus on as a way to help drive them through that when they're making exactly practical decisions. That makes a ton of sense.
00:29:18.820 - 00:30:18.706, Speaker C: Yeah, and another example, and guy and I have talked about this one a bunch, is the exit cost or portability of what you're doing. This touches many of those other dimensions mentioned. So for example, your choice of language. If you're choosing a language that happens to be usable across many different blockchains, then that probably decreases your exit cost and increases your portability, because you can probably move that code somewhere else or redeploy it somewhere else. Also relating to exit costs would be composability, because you have to consider what you need, what your application depends on, what other kinds of systems it depends on, that exist in alternative chain choices. You can specifically design a system to minimize your exit costs to maximize your portability. One portfolio company of ours, they decided this is not necessarily the best choice for everybody, but they decided that the key assets for their game called pyrenation, would be on ethereum l one.
00:30:18.706 - 00:31:13.554, Speaker C: And there's a bunch of things that went into this that have to do with NFT markets and how people value the provenance of nfts and sort of long term stability of ethereum many, many dimensions. I don't want to speak for them, but they decided to go with Ethereum l one for that. But then Ethereum l one is just not suitable with regard to gas fees and latency and other things, many of those other dimensions we talked about. So they decided to go with Polygon for some time, and things have changed and their options have changed. And very cleverly, they designed the system intentionally so that the cost of moving the game assets that were on Polygon to arbitram was very low. So they were able to move all those relatively inexpensive game assets while keeping all the core assets on l one. And this specific design just made it really comparatively easy for them to make the move.
00:31:13.554 - 00:31:27.606, Speaker C: That was something they decided was critical for them upfront. They wanted to minimize that exit cost, and I think they did a bunch of clever things to do that. I think it's a strong example of a success case to me. Yeah, that's because they knew what they were afraid of and they planned for it.
00:31:27.708 - 00:31:40.170, Speaker A: This sounds very basic, but why again does the exit matter? Obviously you want the freedom and in case there's a risk of something going down or something not working or other things. But actually why does it matter to be able to have that type of portability?
00:31:40.770 - 00:32:15.270, Speaker D: I think very succinctly it's almost impossible to predict which of these chains will continue to evolve the fastest and be the best choice in a year, two years, especially longer out than that. And so what is a good choice today might be a bad choice in a year. And you want to have that optionality. I think it's less common to say I'm building a consumer social app and my choice of cloud is going to be existential within the next twelve months. That's not something that I imagine consumer social founders think about. But building in crypto, you really do have to have that consideration today.
00:32:15.340 - 00:32:21.094, Speaker A: I have to say, I fucking love this about crypto. It's so darwinian and cambrian.
00:32:21.142 - 00:32:21.980, Speaker D: Oh, it's great.
00:32:23.790 - 00:32:30.554, Speaker A: I love this about our space. It's like real time evolution. I mean, we have to just pause and celebrate that for a moment.
00:32:30.752 - 00:32:34.010, Speaker C: I totally agree. It's frothing and I love that about it.
00:32:34.080 - 00:32:54.846, Speaker A: Literally the image in my head is literally this moment of the primordial soup of evolution. And you have all these elements composing together and then evolving and then something survives and something doesn't and then it creates the next thing. It's just so exciting. Eddie, you said that you and guy talk about this a lot. What more do you guys say when you talk about this topic of exit costs and portability?
00:32:55.038 - 00:33:35.418, Speaker C: Why is the exit cost important? Why is portability very helpful? It ties back to the thing we said at the beginning, which is the space is at its most uncertain because there are so many choices. There were not so many choices three years ago. There's a ton of choices right now and there are clearly going to be a ton more in the next year or two. Like the set is rapidly expanding. So generally what is a good heuristic to do when the world looks like that? Maximize optionality. That's kind of a general heuristic that you should apply in these cases. Are there sometimes when maximizing optionality has too high costs and you actually kind of need to commit?
00:33:35.514 - 00:34:11.514, Speaker D: Yeah, I do think there are a bunch of caveats to this. If you have specific opinions and if you have strong opinions, then you should break the rules. But I do think you have to know the rules to know when to break them. Essentially so if you think the ZKE EVM projects are going to be too slow, that's not my personal opinion. But there are a lot of smart cryptographers who've looked at this and drawn their own opinion. You might want to choose to build in a DSL because you think the performance improvements will be significant. You might think that the improvements in DK proving are essentially ossifying, like they won't continue to get better.
00:34:11.514 - 00:34:58.774, Speaker D: So that might draw you to a specific conclusion. You might think that the majority of crypto developers will come from web two today and will want to use the simplest programming language, that the existing solidity developers today won't be all that important over the next few years. So that would lead you to a separate conclusion. The simple answer to the question of long term portability. It's the language solidity, and EVM is the virtual machine that is most likely to be backwards compatible with any new chain or infrastructure in the future. With that said, there are a lot of compelling projects that are innovating at the programming language level and might give you new capabilities that you otherwise don't get from solidity. There is a good rationale to be writing smart contracts in move, or to be writing smart contracts in a rust like language.
00:34:58.774 - 00:35:50.534, Speaker D: I also think there are good arguments that solidity will eventually not be the lingua franca of crypto anymore, with efforts like Risk zero and other people building ZK intermediate representations that you can have any popular high level language target today. But these are very hard to predict, and the thing that would give you the most certainty or the most future proofness to the extent you're not certain about the infrastructure choice you're making is to just write your contracts in EVM. It's higher risk to choose a different programming language, but there are certainly payoffs and rewards from it. I guess the point I would make is that there are good reasons to choose a variety of different languages. I would just challenge any founder or builder in the space to intentionally articulate them, as opposed to making a choice out of dogma or making a choice by default, essentially.
00:35:50.662 - 00:36:12.478, Speaker A: That's fantastic what you just said, guy. So it sounds like what you guys are saying. If I were to bottom line, it kind of simply, you have to think about a lot of this stuff up front, no matter what. And as you just said, guy, you have to obviously be intentional and not just decide by default. That makes perfect sense regardless of your goals. But two, it also kind of maybe plays out as a debate between how fast you want to get to market. And it's really about innovation.
00:36:12.478 - 00:37:00.498, Speaker A: Do you want to have the perfect architecture for your needs and goals versus long term game? And if you want to share a product or get feedback very quickly, sometimes it's not all religion and dogma like, it's about how fast you can get your product to market too. Okay, so now, just to sum up, we've set the big picture why this matters, both what's unique and different about blockchains, as well as the specific frameworks for thinking about this space, as well as some nuances about it. You answered my exit cost question, and we've also talked about the dimensions and some of these trade offs, which is super interesting. Now let's actually take the second half of the episode and really break down the specifics. What would you say to people concretely who are trying to build in this space? How should they navigate this? Very tactically, what's the first thing you would ask them to do?
00:37:00.584 - 00:37:59.638, Speaker D: So when I think about actually going through the process of choosing a chain first, it is very important for the founder or whoever is leading the technical development of the project to sit down with everyone on their team and to concretely hash out the technical characteristics that are requirements and things that they would like to have, but are not strictly requirements. And then to go through and identify essentially what choices even fulfill my requirements in the first place, narrow down the set of possibilities, and then from within that more narrow set of possibilities, then start introducing things like community, things like ux, things like developer experience. And people talk a lot about what is the best blockchain. There's a lot of content about that. I think there's less around. What are the things that are actually a huge pain as someone building a company or a protocol that you wouldn't think of to start with. And so I would just lump this category as like tooling and support for your application.
00:37:59.638 - 00:39:09.722, Speaker D: Does the chain I'm building on have a good block explorer? Like can my users understand the transactions they're submitting? This is something people take for granted a lot, but is not true for every blockchain. Are there good wallets that will have a good user experience? And is the wallet, I think that's best for my application, available on this chain? Are there good RPC providers with high uptime? That means my application will always be available and will always be the best experience on that chain. There are a whole bunch of developer experience considerations that are generally specific to a chain. And so I think there are tangential considerations that are not talked about as much that really do matter and that you should seriously consider. One of the things most founders don't think about is custody. So to the extent you want institutions, be it Fortune 500, Global 2000, be it investors, to be interacting with your asset to the extent you have an asset, oftentimes you need institutional custody providers and they're very slow to integrate new projects and it's often a real challenge. This is something that I've seen people run into and introduce a lot of headache that you really would not consider.
00:39:09.722 - 00:40:47.882, Speaker D: There's also the consideration of are you targeting larger traditional web two companies and are they going to be comfortable or even able to work within the context of this chain? And some of the questions you might ask there are does this chain have strong support from traditional custodians? Does this chain have essentially web two and a half infrastructure providers who are able to bridge the gap? And I think this is one of the reasons that Polygon has done quite well on the gaming front, because they are supported by all of the centralized tooling providers that you would want if you were a web two company looking to get into web3. Another one to think through is whether or not you can get a grant or marketing, development and research support from the foundation of the chain that you're building on. I think there's an interesting question of assuming it's possible for me to get a grant for x dollars from chain with a set of characteristics a or a grant of y dollars from chain b with a different set of characteristics, how do I as a company weigh the difference in the grant amount? And oftentimes, especially if you don't have that much Runway, it's a real consideration. So commercial relationships, meaning first grants, research, engineering, marketing support from the foundation or ecosystem itself. And then to the extent you want to work with large web two companies, is it even possible on a given chain? So thinking about the support you can get from the ecosystem you're building in is a consideration that people should think through as well.
00:40:48.016 - 00:41:07.106, Speaker A: That reminds me of the history and evolution of open source and how the Linux foundation played a really important role in the ecosystem. The ecosystem was kind of developing on its own, but there were things that they did to help advance the corporate partnerships and to help supporting all these things that sort of helped it come about as the language du jour. I think that's a good analogy to think about.
00:41:07.208 - 00:41:32.518, Speaker D: Another way to think about this is you might consider the chain you're building on to be distribution or almost like a publishing arm, depending on the type of application you're building. If you're building a game or a consumer app, oftentimes the marketing support from a foundation or from an ecosystem can be really helpful and really meaningful. And that would be as important as some of the technical differentiators for many folks.
00:41:32.614 - 00:41:33.882, Speaker A: Yeah, that's great.
00:41:34.016 - 00:42:26.554, Speaker C: So building on what? Guys have two exercises that I like to run that address two of the key challenges. One is very quick napkin math in terms of what the expected cost of the system is. Just play out for a second. How much data is being stored? How many transactions per day or per month or per minute do you expect from the users that will quickly narrow the set of possible deployment strategies? Because if your system is a system that's relatively infrequent, large dollar values are being transmitted at a time, then maybe the difference in transaction fee is actually not a huge deal. But if your system is obviously a type of system that is very sensitive to congestion and to increased gas fees, that's just going to make only a few possibilities even available to you.
00:42:26.592 - 00:42:26.794, Speaker D: Right?
00:42:26.832 - 00:42:35.038, Speaker C: That's a very quick one. People can be kind of surprised by doing this napkin math, seeing like, wow, I didn't realize these three things are just not an option for me.
00:42:35.124 - 00:42:48.818, Speaker D: Yeah, the napkin math here. I would also encourage people not just to think about the average transaction throughput, but the peak transaction throughput, because that's when fees are going to be especially high, and that is in many cases when things are going to break.
00:42:48.984 - 00:42:54.098, Speaker A: Yeah, and it feels so obvious, the napkin math, but it's actually not. People probably don't do that.
00:42:54.184 - 00:43:04.822, Speaker C: They really don't. Just a few specifics can really narrow it very fast and it can also reveal opportunities for optimization. Like maybe certain things don't need to be here, whatever.
00:43:04.956 - 00:43:47.070, Speaker A: I think that could sound intimidating to a builder. Like, oh my God, does it mean I have to know everything? But no, you're just saying figure out the goals and then to guy's point, you're only as strong as your weakest point, so to speak. But the third thing is, I was even just thinking about this concretely for myself. If my product were like a game where the goal is to trade nfts and really transact around all these micro objects on an hourly, daily, minute by minute basis, versus another product where I'm doing something much more different behaviorally, then maybe I would make a very different choice based on that napkin math you just outlined. I was just trying to think of a concrete example or way of thinking about it. If you have a simple application comparison for that, that might be super helpful here. Before you give the second heuristic.
00:43:47.230 - 00:44:42.054, Speaker C: Totally. It's very obvious that if you want to make a fully on chain game, one of my favorite categories that cannot be on l one, because every small game event is going to add up. Games may be constructed of thousands and thousands of different events, and if you're trying to save them all somewhere, you probably need upfront to think about where that data is going to be stored, what actually needs to be stored. That's actually a great segue in my mind to the other exercise, which is to walk through step by step what you actually expect the user experience to look like tangibly. And that's starting at the boundaries of your application, starting at the boundaries of the user's needs. What do you mean by that first step? They need to get some eth to an address from Coinbase. That's not your application, but that may be where their journey needs to begin.
00:44:42.054 - 00:45:02.330, Speaker C: In fact, it may even begin earlier. They may have to have a choice of wallet. What wallet have they installed or have they purchased? Right. All those different steps are totally different. Depending on an application. Some applications can say no. First step is they show up on our website and then we're going to integrate with a key management system.
00:45:02.330 - 00:45:22.126, Speaker C: We have an on ramp, we have gas subsidies, whatever. That means that the user journey actually starts here. If you go through each of those steps, you will see the things that you need or are missing. I just alluded to a few of them. Maybe you need a key management system. Maybe you want people to come with a wallet already. You expect them to already have a wallet set up and they're kind of onboarded.
00:45:22.126 - 00:45:54.378, Speaker C: Maybe you'd like to hide the wallet from them and you don't want them to. Think about the fact that they're using crypto. They just have an account, maybe they can exit it. But you have some noncustodial system for them to manage their own keys. That's kind of hidden for them behind like an email address or something like that, right? Yeah, that can be a totally different type of thing. So I've presumed the existence of that type of key management system or wallet system. If you expect them to read and write from the blockchain, many times they need a nice RPC endpoint.
00:45:54.474 - 00:45:56.606, Speaker A: Yeah, remote procedure call. Keep going.
00:45:56.708 - 00:46:30.418, Speaker C: Yeah, they need a nice RPC endpoint. What do those look like? Maybe you need some analytics system. How do the analytics for applications developers look? If you're trying to show all kinds of numbers to your users, is that going to be something you're going to build, or is that something that has already been built? I'm just giving a few examples. But the point is, if you walk through the full actual expected user experience, you will see all the things that you need that likely have already been built or don't exist at all and are going to be your problem and so on. Those are all part of bundle that you are inheriting by choosing a blockchain.
00:46:30.514 - 00:47:15.714, Speaker A: So I'm going to give you a name for those two heuristics, Eddie. The first one, let's call it Eddie's napkin rule, where you do the napkin math for like, here's what the cost of the system is going to be. And the second one, we're going to call it Eddie's whiteboard exercise, which is you sketch out the user journey from the very beginning, and not just do it all in your head, but really think about it from their vantage point so you can identify all those points. Okay, so now I want to probe on what you guys both mentioned about programming languages. You guys have said a number of things about programming. Guy, earlier when you were talking about, I thought that was super interesting what you said about the thinking about the future when more web two developers might come to web3. Eddie, you talked about the case of Russ and how it's kind of a programming language de jour for a lot of developers and what that means for the ecosystem.
00:47:15.714 - 00:47:33.290, Speaker A: And we did a whole episode actually, Eddie, Noah and I with Sam Blackshear from Miston and programming languages and blockchains in general. But specifically here in this context, is there anything more to say about choosing your blockchain in the context of programming languages?
00:47:33.450 - 00:48:06.850, Speaker C: Maybe one is that this seems to have been one of the key pressure points that blockchains have encountered, because blockchains that previously relied on or drove people to other languages have since changed their mind. Because the network effects around high quality solidity code are really high. It already exists. It's been audited, it's been tested. People know how it works. It makes it easier to use different developer tools relating to that solidity. There's just a lot of benefits to picking a language that everyone else has already suffered through refining.
00:48:06.850 - 00:48:41.902, Speaker C: Right? So that's a huge one. And then another thing is that unlike other conventional programming in blockchain world, you're picking the programming language and the virtual machine at the same time. And that means that systems that rely on the EVM are just going to need to support solidity. And if you want to support solidity, you're probably going to need to run the EVM or something very similar to the EVM. You don't have to, but it would take more work not to. And that contributes to both their network effects. Both of those different things have network effects that are different, and now they're combined.
00:48:41.902 - 00:49:07.962, Speaker C: So it's a very potent bundle. That doesn't mean it's going to run away and win. In fact, like I've said before, I think move rust, many other candidate languages have very compelling features, and there may be competing vms. Even like the move VM is very, very interesting. It has safety properties that may become indispensable, but that's just the way the world looks right now.
00:49:08.096 - 00:49:41.046, Speaker D: One other point I think is useful to make when choosing a language in reference to a chain. When you choose a blockchain, you're not only choosing the language that you're going to write your application in, but you're choosing the language that everyone else who wants to interact with your application is also going to write their application in. At least today. If you think about atomic composability on a single chain, you're not just making the choice for your team, but for all other teams who want to talk to your application. And I think that's an important difference to highlight. This I think will change as cross chain bridges become more popular. Things like layer zero.
00:49:41.046 - 00:49:48.006, Speaker D: But for the most part, today, you really are choosing the language for everyone else in your ecosystem, as well as for your own core know.
00:49:48.028 - 00:50:36.742, Speaker A: I'll say one quick note on this, just another point from tech history and how it ties in here. One is what you just said, eddie, about network effects, because when most people in tech think about network effects, I think they think about it too much abstractly, like in terms of objects and numbers, and not actually in the human side of network effects, which is talent and people, the OG network effects as people because obviously they talk about in the terms of users, which is such an abstract way of saying about it. But I mean, like just the sheer network effect of people coming together. And that goes to what guy said earlier about community as a dimension and how to think about choosing blockchains. The other quick point of history I think is super fascinating on the language note. So one of my former colleagues from Xerox park was Brian Arthur, who's some would argue the father of network effects theory. He wrote a very famous paper back in the day on increasing returns on the new world of business.
00:50:36.742 - 00:51:33.434, Speaker A: That was like a paper he wrote like back in 96. Anyway, it's super interesting because I had him on a podcast with me and mark a few years ago, and one of the things he talked about is how English itself, as a language, it's almost an accident of history that it won in the network effects of a language that humans use, because it could have very easily been another language. And it was almost like a little tipping point that took what could have been a very small language locally confined to a certain region, and made it a global language. Politics aside, I just think it's a really interesting kind of point there, what you just said, because it just really underscores that you cannot only bet on one thing in the future. The future can unfold in very unexpected ways when it comes to these things tipping and taking off. And I just think that's a super interesting thing to think about. The other quick thing, I want to just probe on what you said about how it's really unique, Eddie, that in crypto, it's unique in this context, that the choice of language and machine are tied together.
00:51:33.434 - 00:51:35.994, Speaker A: Could you say a bit more about that before we move on?
00:51:36.112 - 00:52:29.014, Speaker C: And just that when you write code in a programming language, like if you write code in rust or something, you can set it to many compilation targets, and you can have it run in many, many different environments, independent of operating system, independent of container, it can just run as such. Whereas solidity is typically always written to run in something that looks very much like the EVM. Yeah, that is just a property that it has, and that's because you only have a limited set of computers to run it on, and that's the blockchains. They have one virtual machine, and you have to kind of take that virtual machine or leave it. And then conversely, there are actually multiple languages that compile to EVM. Solidity, Viper. There's some experimental other ones, but they are second place by a decent distance.
00:52:29.014 - 00:52:42.414, Speaker C: I think there's actually some really exciting properties about them, and I'm glad people are experimenting with them. I love seeing it. But just if you're using the EVM, first and foremost, you're dealing with solidity, and that's because of that tight link between them.
00:52:42.532 - 00:52:48.258, Speaker A: Great. Okay, two things we haven't covered. You guys talked about security a little bit here and there, but you haven't really talked about it.
00:52:48.344 - 00:53:22.742, Speaker D: Yeah. On the dimension of security, I think people conflate this sometimes with decentralization. Security is going to be very different for different applications. So if you're trying to build a reserve currency for the world or a fully decentralized exchange, you really want to resist censorship and even state violations from nation state adversaries. If you're building a video game, chinese intelligence services and the NSA probably don't care. And so I think that's a real question to ask yourself. Are you building something that is going to be a threat to governments and to intelligence services or not?
00:53:22.896 - 00:53:57.938, Speaker C: Another dimension that we set context for, but we didn't, was application specific chain versus l one distinction. It actually does tie in a little bit with the security dimension, because like in the polka dot and Cosmos case, in different ways. They require that you in some sense set up your own security, whereas Ethereum doesn't. You just pay Ethereum the fee, the gas fee, park your data on it, and you get Ethereum's security. And the same with Solana. So it does tie into those things. You can basically set up a system where you have to set up your own security, or you can set up a system where you don't.
00:53:57.938 - 00:54:56.170, Speaker C: Other ways that this ties in is just to give a specific example. If you're going to be one of ten op stack chains, you can probably bet that people are going to build a lot of ecosystem software that's going to be compatible with your application specific chain. That's just a really nice place to be in. And you also get more or less separate gas characteristics. Not totally, because you all still have to keep paying l one to park the data, but you do get some separation in terms of congestion for what's happening in your chains, which is nice, but then you have a cost, and that cost is less composability, because now users might have to bridge or use some kind of interoperability solution to be able to do things between those bridges. And that's why optimism and many others are looking for ways to create unification between these different application specific chains. Optimism calls it superchain, Polygon calls it supernets.
00:54:56.170 - 00:55:00.438, Speaker C: There's many projects thinking about this set of tradeoffs.
00:55:00.534 - 00:56:17.054, Speaker D: There's definitely a difference between application specific blockchain and general purpose blockchain. I think this is part of the question of should I build my own chain? If you're going to build your own chain, generally you're building it as an application specific blockchain, although that's not always true. Sometimes an application then wants to create infrastructure so that people can compose with that application. I think Ronan is a good example of that. On the points of do I build on a generalized chain versus an app chain, there have been a number of projects that have essentially taken thesis of I want to include logic about my application in consensus and they usually do this because they want to provide a subsidy for the service that the chain is providing, and they can use the block reward distributed as part of consensus to make it cheaper for the users to access the service that the application specific chain is providing. I think this often overcomplicates development and conflates these two points, and people should just, at least in my opinion, build on an established general purpose stack like the EVM or like the Cosmos SDK and tendermint, and then separately if they want, add that subsidy in their token and token economic model. Usually this just creates a lot of complexity that, at least in my opinion, I don't think is worthwhile.
00:56:17.182 - 00:56:25.442, Speaker A: So just to make sure I understood that when it comes to application logic and consensus, you're generally not a fan, even though you do kind of see the purpose of it in certain cases.
00:56:25.586 - 00:57:15.698, Speaker D: I think the general rule is including application logic and consensus overcomplicates it and is not particularly worth it, even in some cases that I think have been pretty well justified by the team as they're going through this process. I think they've later on realized that if I had to do this again, I would not include application logic in consensus. I think it's becoming a worse idea all the time as we move forward in the future. And the off the shelf solutions we have for consensus are getting better. And so there are some rare exceptions when you would consider it. But if you don't really want to do this, I would encourage you not to. Yeah, one point I don't think either of us have made yet is that if you're building on a general purpose chain today, for the most part, you have no control over the MEV that your application is exposing.
00:57:15.698 - 00:57:52.606, Speaker D: If you build an application specific chain, oftentimes you can change how the MeV your application exposes is captured or internalized. I think osmosis is a very good example of this. It's an application specific Dex on cosmos that has a threshold encrypted mempool, and they have managed to internalize MEV and plan to distribute it, effectively lowering the swap fee to users. So I think if you're concerned that your application is exposing too much mev today, at least at this point in time, it's worthwhile considering building your own application specific chain or building your own chain.
00:57:52.718 - 00:57:59.460, Speaker A: Got it. So when it comes to telling builders, should you build your own blockchain, what would you first say to them as an answer?
00:58:00.150 - 00:58:14.562, Speaker C: Most of the time, if someone says, we'd like to build our own blockchain. The answer is, please don't do that. Why are you doing that? That's too kind of difficult because that's very difficult to do, right? Please don't.
00:58:14.706 - 00:58:30.074, Speaker D: This is like when you're selecting a difficulty level on a video game and there's the highest difficulty level that it's like realism. You will die. Like, don't do this. This is dark souls and that's building your own blockchain. If this is the 10th time you've played the game and you know what you're doing, fine, but otherwise, don't.
00:58:30.202 - 00:58:38.222, Speaker A: But if you are a power gamer, what if you do want to go to that difficulty level? When should you build your own blockchain? What are the reasons that people might want to do that?
00:58:38.356 - 00:59:18.010, Speaker C: So a couple of years ago, the answer would have been to have to start something more or less from scratch. There were some tools, and there have been some tools where you can get started, and some off the shelf products like tendermint and substrate people recall have been around for some time, but now you have, relatively speaking, very complete packages that you can pull off. The shelf op stack is a great product. We're big fans of it. That comes out of optimism, and that'll get you much further there. The first thing I'd ask is why? And that's an obvious question, but it's because you have to have very specific reasons to do so. You probably want to be able to customize the chain.
00:59:18.010 - 01:00:09.262, Speaker C: You probably want to be able to customize the way people interact with it and build software around it. You probably want to be able to take certain things for granted or make specific upgrades that are difficult to do to someone else's or to some other existing chain. Look at what Coinbase has done recently with base is a great example of a project starting their own chain. So it's where you want to go much, much deeper, and you want to have a level of control to offer a specific type of experience. Maybe that has to do with identity management or account abstraction, maybe it has to do with encrypted mem pools or mev related stuff. But these are very low level considerations that you probably have to have some very good reason why you've gone that far down the thought process and you've encountered the idea, maybe I should roll my own network. And that became a viable option.
01:00:09.262 - 01:00:19.374, Speaker C: So it's probably not the place to start. We're at a really interesting time in history. The choice is difficult right now, but that's part of what makes it a great opportunity I'm very excited.
01:00:19.502 - 01:00:26.018, Speaker D: This is fun. Enjoy it. Crypto is a dark forest and have fun with it.
01:00:26.104 - 01:00:27.538, Speaker A: Awesome. Thank you so much.
01:00:27.624 - 01:00:28.466, Speaker C: Thank you so much.
01:00:28.568 - 01:00:29.466, Speaker D: Thanks so much. Tunnel.
01:00:29.518 - 01:00:35.414, Speaker A: Bye, guys. Thank you. Thank you for listening to web3.
01:00:35.452 - 01:00:48.534, Speaker B: With a six and z. You can find show notes with links to resources, books or papers discussed, transcripts and more@asicsycrypto.com. This episode was produced and edited by Sonal Choxy.
01:00:48.582 - 01:00:49.306, Speaker A: That's me.
01:00:49.408 - 01:01:13.002, Speaker B: The episode was technically edited by our audio editor, Justin golden. Credit also to moonshot design for the art and all thanks to support from Asics and Z Crypto. To follow more of our work and get updates resources from us and from others, be sure to subscribe to our web3 weekly newsletter. You can find it on our website@asicsnzcrypto.com. Thank you for listening and for subscribing.
01:01:13.146 - 01:01:14.140, Speaker A: Let's go.
