00:00:07.050 - 00:00:49.210, Speaker A: You. So today's talk is going to be some sort of tutorial on what kind of signature schemes we have encountered on the blockchain space. And by no means this is not going to be exhaustive. I'm not going to cover every single thing that we have seen in terms of digital signatures. But I'll try to give like a pretty fair overview. So let me start and say, why do we care about digital signatures and what are digital signatures? So I'm going to use the cryptographic definition of a digital signature scheme. So if you ever took a cryptographic class, you have seen this definition.
00:00:49.210 - 00:02:05.540, Speaker A: So typically we define a digital signature as a protocol that consists of three algorithms. There is a key generator algorithm that takes us input some security parameters and outputs a pair of a secret key and the public key. There is a signing algorithm that takes us input a method and the secret key and outputs a signature. And then there is a verification algorithm that takes us inputs the methods, the public key and the signature. And if the signature verifies for that particular message under that particular public key, the verification algorithm will say accept, otherwise it will say so the idea is that the verification algorithm can be run by any third party as long as it knows the public key of the sign. The two crucial security properties when we talk about signature schemes are correctness, which basically means that if a signature was signed with a secret key that corresponds to the public key, it should also verify under that particular public key and enforceability, which informally says that if you don't own the secret key, if you don't know the secret key, you shouldn't be able to produce accepting signatures under the corresponding public key. And I'm going to formalize this definition soon.
00:02:05.540 - 00:03:09.830, Speaker A: So why do we care about digital signatures in web three? Because they're literally everywhere. Every single blockchain system uses digital signatures at one point or another. And the main reason that we use digital signatures for is to authenticate transactions. And if you just recall for a second how bitcoin transactions work, that they have inputs and outputs. Basically in every single bitcoin transaction, you need a signature for every single input in the transaction in order to verify the transaction. So beyond that, beyond the basic use of digital signatures, we've seen many more exotic, as I want to call, digital signature schemes that appeared in the blockchain space. We have schemes like multisignatures threshold signatures, ring signatures, adapter signatures, and we also care a lot about certain properties or features of digital signatures like malleability and aggregation.
00:03:09.830 - 00:04:13.660, Speaker A: So what I'm going to do in the rest of the talk is to cover the three most popular digital signature schemes that we have seen in the space of web. Three. Discuss the properties of aggregation and malleability and then also overview at least the feature the properties of these more exotic, as I call signature schemes like multi signature threshold and so on. And feel free to stop me at any point or ask questions whenever you have. So I'm going to start with ECDSA because this is a signature scheme that is used by Bitcoin and many, many more systems. It was introduced back in 92 by Scott Vanstone and probably some of the reasons for which ECDSA was adopted by Bitcoin from the very beginning is that it is a standardized scheme, it is efficient, it is a litkf based, and it's not patented. Okay? So it was freely available to use.
00:04:13.660 - 00:05:09.390, Speaker A: So I'm going to give you a description of how ECDSA works. And for all these schemes, I didn't clearly define that when I gave you the algorithms from which the signature scheme consists of. But for many of these signature schemes there is also some sort of setup phase that certain parameters are deciding. So for the ECDSA signature scheme, we need an elliptic curve. Specifically, Bitcoin uses SEC p, we need a base point in the curve, the point Z, and we also care about N, which is the order of the point Z. In order to generate your secret and public key, you start by picking the secret key as a random integer in the space from one to n minus one. And then you do one point multiplication between the secret key and the base point Z.
00:05:09.390 - 00:05:58.880, Speaker A: To get your public key. In order to sign a message, you start by taking the hash of your methods. And then crucially, you pick a random nonce that I'm going to call K and define compute the elliptical point that is defined by this random non scale. So you're going to do again a point multiplication with Z and get a coordinates x one and y one. You're going to isolate x one and take it module N. And then for your signature, you're going to invert your random nons K and then take the half plus the secret key times the randomness that was generated by K. Modular, yes.
00:05:58.880 - 00:06:47.520, Speaker A: So this is a particular elliptic curve that is being used by Bitcoin. So there are many, many different options on elliptic curves that one can use in such skins. And this is the specific one that is used, I think. So what you output as your signature are those two values r and S. How do you verify the signature? And I'm not going to really show you correctness here, I'm not really going to show you why things work out, but just to have an idea of what kind of computations are happening here. So basically, again, when you verify the signature, you need the method, the public key, and the signature consists of those two values r and S. You have to check that k, sorry, that the typo that R and S are in the correct space.
00:06:47.520 - 00:07:36.586, Speaker A: You recompute the half of the methods E and then you inverse S. Take s to the minus one. And you compute two values, e times s minus one and R times s minus one. And then you do two point multiplications with both u one and u two to get an elliptical point x one y one. And you're going to output that your signature is valid if the R that was given as part of the signature is equal to x one. And again, I'm not going to show you correctness here because I would have to dig into a little bit on how this point multiplication works and why there is like a symmetry here. But you have to trust me that indeed, if the signature was correctly computed, r is going to be equal to x one here.
00:07:36.586 - 00:08:13.410, Speaker A: Okay? For other signature schemes that we're going to sit down the path, it's going to be much easier to actually verify. Correctness yourself. What I want to highlight here a little bit is a few important points in terms of security. And again, I'm going to formalize things a little bit more. The security of its DSA actually relies on the hardness of the discrete logarithm problem in LTK. So if you see the public key, it's hard to extract the secret key here. And one more point that I want to make here is that the way that I defined is DSA here is deterministic.
00:08:13.410 - 00:09:06.806, Speaker A: What does this mean? This means that if I'm signing the same methods with the same secret key and every single time I pick a different random nonscale, I'm going to produce a different signature. There is a way to actually make ECDSA deterministic and you can refer to a particular RFP if you want to see the specification for that. In a very high level. The idea is that you are basically not just picking K randomly, but you are hashing the methods together with a key in order to fix a particular value for that message and key. But you can refer to the specification for more on that. So in terms of efficiency, this might seem like a lot of operations, but many of these are actually pretty, pretty cheap. The operations that we actually care about, the most expensive operations in this scheme are actually the point multiplications.
00:09:06.806 - 00:09:40.286, Speaker A: And as you notice during signing, there is a single point multiplication. And what I also want to highlight here is that at least for the nondeterministic case, you can actually pre generate these K and R values. Because you can see that up to here, I'm not really using the method. The method E is only used at this bar. So this operation and this operation could potentially be precommuted. So you can kind of save a little bit on the signing phase. During verification, you have to do two point multiplications.
00:09:40.286 - 00:10:30.894, Speaker A: And there are also some tricks there with like precompute tables and something that's called the SUMIF trick that could break this down to roughly one point multiplication. There is one more operation here that is kind of expensive, not as expensive as the point multiplication. And this is the inversion of the value s. But these are the most expensive operations here in terms of sizes. The signature size is 64 bytes and the key sizes are 32 bytes. Technically, for bitcoin, the size of signatures are a little bit larger, roughly between 71 to 73 bytes. And that's because ECDSA was implemented with the OpenSSL Library and has a particular encoding that the signatures need to satisfy.
00:10:30.894 - 00:10:52.300, Speaker A: It kind of blows up the size a little bit. Okay, so the size of signatures on bitcoin, I think most of them actually these days are 71 bytes. All right, so any questions on how the scheme works? High level here? I bet most of you have actually seen ECDSA before.
00:10:53.150 - 00:10:58.846, Speaker B: Any full node implementations actually compress the signatures on.
00:10:59.028 - 00:11:10.480, Speaker A: I was actually looking into this and I'm not aware. Yeah, that's a good question. Exactly. Yeah, because if you bring it down to 64 yeah, that's actually important.
00:11:11.330 - 00:11:13.230, Speaker B: What is the schmier trigger?
00:11:14.230 - 00:11:36.638, Speaker A: Yeah, so basically it's a combination of precomputations that you can do on certain points in the curve and inversions that you can do a little bit faster. It's hard to describe it, but I can give you references if you want to look at. And my understanding is that actually certain full nodes are using such tricks to verify signature a little bit faster.
00:11:36.674 - 00:11:40.134, Speaker B: So it's like for a specific generator point, you can get much faster conversions.
00:11:40.182 - 00:12:39.150, Speaker A: Or like what's the yes, again with certain pre computation tables. Okay, so moving on into security, as I said, the critical properties for digital signatures are correctness, which is easy to describe and also unportability, which I will now describe a bit more formally because this kind of actually matters a lot for security. So usually in cryptography, we define security via a security game. So we're trying to capture exactly what an adversary can and cannot do with a security game. So here the idea is the following. We define a challenger and we have an adversary that tries to break the possibility of a scheme. The challenger typically will pick a pair of secret key and a public key will send the public key to the adversary.
00:12:39.150 - 00:13:16.998, Speaker A: And then the adversary will start the so called silence phase, where it's going to select messages and send them to the silent. The silenter will sign the messages with that particular secret key and send back signatures to the adversary. And this can be repeated many times, technically polynomial number of times. And at the end of this game, the adversary is going to output its false. This n star and sigma star. And we're going to say that the adversary wins. The adversary, in other words, breaks the enforceability of the signature stream.
00:13:16.998 - 00:14:32.114, Speaker A: If it manages to output a signature that verifies and the method then start wasn't queried before. Okay, so this is what we call unforceability and we call this existential chosen method attack. Unfortunately. So having this definition when we're trying to prove security of digital signatures or authentic cryptographic scheme, really what we're trying to the ideal theorem that we want to give is that the signature scheme XY is unforceable under a particular hard problem in the standard model. So this is like the ideal security definition that we want to give. So what is the case with each DSA? We know there has been a lot of research in trying to actually formalize and pinpoint exactly what is the level of security of this DSA starting back in 2002. So back in 2002, Brown group security of its DSA in the so called generic group model, which is kind of an idealized security model.
00:14:32.114 - 00:15:46.454, Speaker A: It's not like a standard model under haspolution resistance. Later in 2016 we had security again with GM under different has assumptions and an idealized function that was used for the mapping of the random NUMS and the Apkr points. And very, very recently, a couple of months ago, we had a new proof of security by Gross and Soup on a special version of generic group model that was specific to you know, for those of you who are not cryptographers in the room, this might sound kind know, funky and really wondering what are the differences between these results? Well, in practicing as cryptographers, we really care about the underlying assumptions, the models under which signature schemes are being proven under. And the problem with Ccdsa is that all these 610 standard bits these security groups are given are actually kind of idealized models of computation. So again, they're not like standard model groups. Again, this doesn't mean that these are insecure or there are certain attacks. It's just not the ideal type of security proof that we'd like to have.
00:15:46.454 - 00:16:49.502, Speaker A: Okay, just to clarify that again, there are no attacks. I'm not claiming any attacks, it's just that we don't have proof of security for it to be a say that are under the most acceptable standard model. Okay? Beyond the theoretical security and as I said, there has been a lot of effort on that. ECDSA is actually pretty implementing ECDSA is actually pretty notorious and there can be many many issues that completely happen at implementation level or incorrect configuration of APIs and so on. And I just want to highlight a couple of attacks. So there is a way known attack that allows an advisory to recover the secret key from a signature if this random null SK that was used during signing was revealed. So if for any reason this random SK that you picked during signing was revealed, then an attacker can extract your secret key.
00:16:49.502 - 00:17:25.990, Speaker A: And to make things even worse, this can actually happen even with parts of case being published or even by having a way to have a biased randomness generator that spits out this case. And you can figure out something about the next randomness that's going to be. So these are hardware attacks. They use like pre analysis, Lassid based attacks and there's like a plethora of research work on that as well. So the good practice there is to actually keep all case use secret, do not reuse, and be very careful.
00:17:27.290 - 00:17:32.438, Speaker B: Do any of the wallets generate them pseudo randomly using a PRS or are.
00:17:32.444 - 00:17:35.640, Speaker A: They all I don't know.
00:17:54.390 - 00:18:13.446, Speaker B: Because then you might have a bad randomness generator and then you get random issues. The better way is to just generate private key pseudorand. If you don't know the bias, do you know that there exists some bias? Can you still attack it?
00:18:13.628 - 00:19:18.370, Speaker A: I don't think so. I think they actually need to know certain patterns on the next nonsense that are going to be tested. The second point that I want to make about ECDSA is that ECDSA signatures are malleable. And what does this mean? So specifically for ECDSA, it's actually pretty easy to see why this happened because the elliptic has used they had some sort of symmetric properties. It's very, very easy for an adversary looking at the method and the signature to just take the symmetric point of the signature on the curve and come up with a second signature that is also valid for the same method. So this can create replay attacks, especially if signatures are used as the unique transaction IDs of transactions in Bitcoin. And this was a case with Mount Coast many years ago.
00:19:18.370 - 00:20:14.150, Speaker A: And what is important to enforce here is that there is a single canonical signature for any given public enhanced method. And this is something that is actually adopted by Ethereum. So they kind of remember that I said that it's very, very easy in this DSA to just take the symmetric of your signature and have the minus sigma also being a valid signature. So what a theorem does is that it kind of splits the space in half to essentially not allow you to be able to pick this metric point. No nothing. And another thing that you can do here, specifically if you care about these unique transaction IDs, is, as Bitcoin does, to basically treat the transaction IDs differently with the separate introduction. And again, I'm not going to get into too many details on this because there is so much to cover.
00:20:14.150 - 00:21:05.310, Speaker A: So this kind of concludes my discussion on Acdsa. And what I'm going to do now is to actually move into different signature schemes and see what else is out there. Any more questions on Acdsa? And again, I'm happy to give you references. There is a lot going on there. So what do we have beyond Dcdsa? There are basically two more types of signatures that we've seen a lot in the blockchain space. The first type of signatures is the so called Snore signatures, which are now accepted in Bitcoin Post, Uproot and Polkadot. And there are also the EdDSA signatures which are basically the deterministic Snore signatures.
00:21:05.310 - 00:22:08.190, Speaker A: And we also have BLS signatures which are adopted by cello and hopefully ethereum two. So I will basically go over Snore and BLS signatures and then move on with the other, more like different signatures and properties of signatures. So before doing that, why do we care about different signature schemes? We care about more efficient signature schemes, we care about schemes that have better or more standard proofs of security. And we also want extra features as I'm going to discuss, which were not supported by Ecbsa. So Snore signatures are actually kind of older compared to Ecbsa. The problem though is that Snore signatures were patented up until 2008. So many people actually believe that this was the reason that they were not immediately selected.
00:22:08.190 - 00:22:59.150, Speaker A: By default, they're not standardized yet. As far as I know, there is a specific specification for bitcoin for the particular AP curve that is used in bitcoin. And let me show you how they work. So the parameters that we need for the scheme is a group Z or prime order Q with a generator, a little Z. He wants this group to be selected in a way such that the discrete logarithm problem is hard. So now I'm going to show you the scheme, not by using LCF notation, not by using point multiplication to kind of make it a little bit easier to distill. So the key generation algorithm picks a random secret key, compute the public key by taking the generator and raising it to the secret key.
00:22:59.150 - 00:23:32.090, Speaker A: Again, because of the discrete logarithm problem, it's hard to figure out the secret key from the public key. And now the styling algorithm again picks this random NUM k. It sets R to be V to the K, hases the method along with this random SR and computes S to be k plus E, which was the output of the hash times SK, the signal key molecule and output arrangement. What's that?
00:23:32.160 - 00:23:34.030, Speaker B: The public key in the hash?
00:23:36.530 - 00:24:04.596, Speaker A: Good point. Yes, you need to include the public key in the hash. So to verify it's actually easier to see why the signature verifies, you need to recompute E. And here, if you obviously include the public key, you have to include it here as well. And verification is pretty simple. You just take the generator raised to F, and if you see F, is this K times E secret key. So this is Z to the K.
00:24:04.596 - 00:24:19.544, Speaker A: Z to the E times SK. And that's R, which is again Z to the K. So the two Z to the K. Go away. Public key raised to the E. And again, if you see z to the E times K, you can see that things cancel out. And it's very high.
00:24:19.544 - 00:25:13.560, Speaker A: It's much easier to see that it's verified compared to Ecbsa. So in terms of efficiency, things kind of look similar to Ecbsa. We have one exponentiation that is needed during timing and two exponentiations that are needed during verify. You can think of exponentiations being almost equivalent to point multiplications here. So efficiency is similar and the signature size is actually 64 bits. And again, the keys of before are 32 bytes, 34 bytes, and signature keys are 32 bytes similar to ECDSA for the same security level. Okay, so what do we know about security for Snore? So Snore actually has a better unfortunability property.
00:25:13.560 - 00:26:08.936, Speaker A: It has a better, unfortunately, definition. So recall the unfortunability definition that I gave you before. I would think that the adversary wins if it outputs a method and the signature such that the method was not created before. So now I'm allowing the adversary to win even if it outputs a new signature on a method that it did query before. Okay, so basically, again, if an adversary manages for a method that it has already queried to output a different signature than the one that it received during the silent phase, this is still considered an attack. So we still consider this advertiser to be breaking the scheme. And this is the stronger property, this is a better property than the one that is satisfied by CSA.
00:26:08.936 - 00:27:20.530, Speaker A: And this is basically the reason why the Snore signature scheme is not Mariable. It doesn't allow to have multiple signatures for the same. So what do we know? What are the theoretical results that we know on the security of Snore signatures? So there is this very celebrate and famous result by Monster Balance in 96 who formally proved Snore signature scheme in the random Oracle model under the discrete logoism assumption. So they introduced a technique, a proof technique that is called the forking Lemma and it's a proof technique that is used in many, many security proofs of signature skin. They gave a new introduction. Again, I want to highlight that the random Moratorium model, similar to the generic group model that was used in ECDSA, it's again like an idealized model commutation, it's not standard model, but it's probably a little bit more standard compared to the DGN. And there was again, like numerous results and I'm not being exhausted here, that actually improved the tightness of the reduction that was originally given in 96.
00:27:20.530 - 00:28:43.140, Speaker A: So I just want to mention that just because it popped up like a couple of days ago and many of you might have seen that on Twitter. So, as I said before, EdDSA is a deterministic version of Snow. And I just want to highlight an implementation pitfall that was actually discussed on Twitter by Koso Salkia, one of the Suey Missenland cryptographers. So basically they found out that roughly 40 Eddfa libraries for the particular ed, 250 5th, 255 19 kids, they would expose the private key if the signing function was misused, either accidentally or on purpose. And what was the problem there? So basically the problem there was with the timing API of the library. So the timing API essentially embedded the secret key but allowed to give us input the public key as well on top of the methods. So this could potentially give rise to an attack such that an adversary could extract the embedded secret key if it asks for signatures on the same methods under two different public keys.
00:28:43.140 - 00:29:50.804, Speaker A: And again, it's a little bit hard to show you like the math behind the attack, but it's actually not that nothing fancy, it's not like an expensive attack or something. So the reason that I wanted to mention that again, as I said, it's because it just popped up like a couple of days ago and it received a lot of attention on Twitter and it's a very clear example of how things can go wrong completely in an implementation. So there were no known at least vulnerabilities that could know be an attack vector. But many companies that were using these libraries, they're trying to pass things up. So a very nice property of the Snore signature scheme and here I'm just recalling the Snore signature for you is what is called Bat verification. And this is a property that is not supported by Ecbsa. So what Bat verification allows to do is the following.
00:29:50.804 - 00:30:59.596, Speaker A: So you assume that you have a minor and it looks at a block that has a whole bunch of signatures and of course the miner should verify all signatures first. So the nice thing with Snore is that you can actually but reduce the cost for the verification of the signature. So basically what do you do is that you take all the signatures and look again, this was an expensive verification operation that required two exponentiations. So you would have to do two exponentiations times N to verify all the signatures individually. But because of some essentially linear properties that's nor satisfied, you can take the sum of all the S's, raise D to the sum which we are one exponentiation now and then multiply all R's together and then do of course the separate exponentiations for every public key. So the nice property here is that you're taking this from two times ten expunciations to N plus one. Okay? So this is a significant improvement on the time of verification.
00:30:59.708 - 00:31:00.370, Speaker B: Here.
00:31:04.500 - 00:31:50.224, Speaker A: I'm trying to draw some comparisons between ECDSA and Snore and I'm also going to add DSA in the picture. So again, specifically for the case of Bitcoin, ECDSA signatures are gloves. Signing verification cost is pretty similar in terms of security. Snor has stronger security and doesn't support liability and it's also proven secure in a kind of more acceptable security model. And it also has a very nice feature of bus verification that is missing from Ecbsa. So next I'm going to move into DLA. Are there any more questions? Is it the attention note before doing.
00:31:50.262 - 00:31:55.010, Speaker B: That GGM model contained inside the Ro model.
00:31:57.220 - 00:31:58.352, Speaker A: Sorry, can you repeat that?
00:31:58.406 - 00:32:01.380, Speaker B: Is the GGM model contained inside the Ro model?
00:32:01.530 - 00:32:16.170, Speaker A: No. So these are two very different computational models and in general the DGM model is considered more strong compared to the random market model. And in cryptography, when we say the model is stronger, it's kind of worse than the random market.
00:32:17.580 - 00:32:24.472, Speaker B: The edge verification you just showed, it like as an adding. Do I not need to take a random linear combination?
00:32:24.536 - 00:32:28.670, Speaker A: Yes, it does. I mean, I'm just showing the basics. Yes, of course.
00:32:33.440 - 00:32:37.970, Speaker B: To summarize, there's basically no reason to use CBSA ever.
00:32:40.580 - 00:32:47.184, Speaker A: I wouldn't like to make to come to such conclusions, but no known advantage.
00:32:47.232 - 00:32:51.950, Speaker B: Besides, patents are like standing up on the table.
00:32:54.530 - 00:33:19.220, Speaker A: The patent expired in 2008, the Snore patent. But I mean, at least by browsing online, because it was so much on the edge, people say that this was the reason that it was not. And also it was not standardized back then. Even now, Snore, as far as I know, is not standardized. As I said, there is a specification for Bitcoin, but there is no general standard.
00:33:20.150 - 00:33:25.430, Speaker B: The great irony is the past was like, it expired, just bitcoin could have used it.
00:33:25.500 - 00:33:26.082, Speaker A: Right.
00:33:26.236 - 00:33:29.370, Speaker B: A lot less like, well, widely used at the time.
00:33:29.440 - 00:34:31.930, Speaker A: Right? I mean, again, and this is just speculation of why it wasn't used and cannot be. All right, so let me move into BLS, which is going to be the last scheme to cover so Ble signals, which are much more modern games compared to it BSA and Snore introduced by Dampon, Urban, Lim and Hoba Saho in 2004. There is a standardization effort in progress right now, and they use a different primitive. Instead of just like the basic discrete log that Snor and Bcdsa was using, they use something that is called the bilinear pairing. And they rely on elliptic curves that are actually pairing friendly. And what I want to highlight here is that the particular elliptic curve that is used by Bitcoin does not satisfy this problem. So we could not implement BLS on top of Bitcoin.
00:34:31.930 - 00:35:36.978, Speaker A: So I just need to give you this very short prelim here on what the bilinear pairing is. And then after the end of the pack, you're going to see that the scheme itself is actually very straightforward and very easy to digest. So a bilinear pairing is basically a mapping where that takes two inputs from Z, where Z is a parent friendly curve and gives an output to another curve. The very, very nice property that you have here is that if you have two values z to the A and Z to the B that are part of Z, then if you take the pairing, if you apply the function d to the A and Z to the B. Then this is equal to basically bringing the exponents outside and taking E to the z comma z raised to a times b. And as you can see, this property is going to make our life very, very easy in verification. So let's see how the scheme works again.
00:35:36.978 - 00:36:04.890, Speaker A: Parameters group z. Of prime order q with generator Z. Again, you want the discrete log to be had. The public key and the secret key are selected in exactly the same way as with Snore signatures, but not hashing is done differently. So the signature is just one line. Remember, is it the same Snore before that had like multiple computations with the signature. So you basically just has the method and you raise the secret key.
00:36:04.890 - 00:36:47.260, Speaker A: So notice that this has function needs to have kind of special properties. It needs to be a hash function that maps to points in the curve. So not every single hash function can be used here. And then to verify that the signature is correct, sorry, this should just be sigma. Here you just need to check if the pairing of sigma comma z is equal to the half of the method comma pocket. And here again, it's very, very easy to see why in algebra works, verification is very nice. Do people see why this verifies? It's much simpler than before.
00:36:47.260 - 00:37:22.850, Speaker A: So something that I want to highlight about BL signatures is that they are deterministic. There's no randomistic here. And on top of this, they are also unique. So unique means a different thing than deterministic for digital signatures. So unique basically says that there is no other signature. So that every signature really maps a particular method and secret key and that's unique. It's not possible to compute another signature sigma for a different combination of methods and secret keys.
00:37:22.850 - 00:38:11.966, Speaker A: While deterministic says that for this particular secret key and method there is a unique signature. But again, unique the other way that there is no other combination of method and secret key that would give you the same signal. Okay? So it's kind of those two properties, I feel that they're often confused. All right, so again, what happens in terms of efficiency? So we have like one exponentiation for the key generation similar to all the previous schemes, and one exponentiation for signing and for the verification. What we need is to compute two parents. So typically this pairing computation is more expensive than the exponentiation computation. So this is something that we have to keep in mind when we're looking into DNA.
00:38:11.966 - 00:38:55.452, Speaker A: So verification can be more expensive. Signature size is much smaller. It's like half compared to Snore and itbsa because it's up one group element. So it's just like bits and bites. And signature sizes are also counting public key, secret keys. Sorry, I should have the signature size plus public key plus secret key, but it's ignored. So what do we know in terms of security? The security of BLS has the same.
00:38:55.452 - 00:40:03.520, Speaker A: So BLS applies the same, unfortunately definition as with Snow, if you get the stronger version of unforceability. And in terms of theoretical results, the original paper showed that BLS is securing the Erratomorical under the so called computational difficult function. And then there was a more recent result that actually managed to make this reduction a little bit tighter in a new model for English security model that's called the algebraic group model under the discrete logos. So again, if I try to put together and draw some comparisons here, the main advantage of BLS signatures is that they're much shorter signature verification cost, signing costs about the same. Verification cost is higher because as I said, the pairing operation is typically more expensive than exponentiations. The security is comparable to that of Snores and it also allows for battery verification.
00:40:05.220 - 00:40:13.650, Speaker B: Do people worry about like you can only implement DLS in pairing friendly curves so there's more chance that some discrete log break.
00:40:14.280 - 00:40:57.168, Speaker A: Yeah, I think they do. So there's a lot of discussion on the right cares. So Binge though has many other nice properties that make it attractive and I want to highlight some of them. Does the same go up until, is it 1 hour or 1 hour and a half? Okay. And we started a week later. So a nice property of BLS signatures is that they also allow for aggregation. And let me explain what this means by giving you kind of the definition, explaining what an aggregateable signature is.
00:40:57.168 - 00:42:15.544, Speaker A: So when I defined digital signature before, I said that they consist of the algorithms, keep them signed, verified. An aggregatable signature scheme will add two additional algorithms the signature aggregation that is going to take as input a vector of messages, a vector of keys and a vector of signatures and output a combined aggregated signature and a verification algorithm for this aggregate signature. So if we kind of try to view that as a graph, the idea is that it has an algorithm that takes signatures under different public keys and distinct messages and combines them to a smaller to a much shorter aggregated signature. So let me show you how this is possible to do with BFX. And obviously the main advantage that makes this property very sexy on the blockchain space is that it can really compact the space, the storage space in a block. Instead of storing every single signature, you can just aggregate them together and really reduce the storage space. So again, remember how the Varia signature works.
00:42:15.544 - 00:43:24.560, Speaker A: I'm just recalling the schema there and let me show you how can you possibly combine multiple signatures together? BIS is pretty simple. You just take all the signatures again take different signatures, different messages, different public keys. You multiply all the signatures together and then in order to verify which in a sense also supports bug verification, at the same time in order to verify, you just take the pairing of the aggregated signal two, and then you multiply the pairings of every single method with the corresponding public key. And if you do the math and you bring out the exponent here, you're going to see that this actually is very fine. So again, the nice property here is that instead of storing N times 32 bytes for the signatures on the same, you're now only storing 32 bytes. Still again you would have to store separately the public keys and the methods because they're different. You can just combat the signature size together.
00:43:24.560 - 00:44:05.624, Speaker A: You can just combat the signature. Okay. And as I said, this naturally gives back verification and it takes the pain from two times 1020. Okay, is it clear why this works in BLS? Yes. So this is a very nice property. So a different property that is also very commonly discussed in the blockchain space is that of multisignatures. And if you think about what multisignatures are, you can think of them as a special type of aggregate signatures.
00:44:05.624 - 00:44:52.780, Speaker A: But now the difference is that you want to produce a single signature but on the same method. Again, remember that in aggregate signatures you had different public keys, different messages. Now you want to have like a bunch of signers signed together the same method. Such schemes are possibly interactive but not always. And essentially the idea is that instead of having the single sign algorithms you might have an interactive algorithm that is run among every signmer in order to produce the final signature signal. When you verify the signature you still need to know all the public keys that were involved in the sign. Okay? Again, the main difference is that you have a single method.
00:44:52.780 - 00:46:11.600, Speaker A: So what do we know? Well, first of all, do we care about multi signatures and web three and blockchain systems? They're very, very valuable in multi user wallets where you want to have multiple users signing atoms in order to go through. But we've also seen them being heavily used in layer two protocols like certain bitcoin tumblers and also on payment tumors like the license. So let's see how we can build BLS multi signatures. Again, I'm just up here just recalling how BLS works. And now let's think know I'm doing the same operation that I was doing before with aggregated signatures but now again, keep in mind that all the signatures now correspond to the same method. So basically what I'm doing is that I'm multiplying all the signatures together and now verification looks even similar because on that side I'm still taking the same pairing as before. Actually I forgot to take the subscript here, that should be the multi signature and I can only do luckily two pairings here by just multiplying all the public keys together and taking the half of the method because there is a single method here.
00:46:11.600 - 00:47:31.100, Speaker A: So this would very nicely give you a multi signature scheme if it worked. But unfortunately this is vulnerable, it is vulnerable under a special type of attacks that are called wrong public key attacks. And basically if you did BLS multi signatures this way it would allow an attacker to create an wrong and adversarial public key which I'm calling the public key star using an honest user public key and then kind of frame this user the honest user as also signing the methods, although the user never signed the method himself. So the idea is that if an attacker just knows the public key of a user can set its own public key to be as PK star z two SK over the public key of the user, where SK is absolutely this SK star, the secret key of the attacker signed this way, which does its own secret key. But then the signature will verify under both PK and PK stat. So it will look like also the honest user signed the signature. Okay, so this is actually a problem.
00:47:31.100 - 00:48:47.060, Speaker A: We wouldn't like to be able to do that. And now I want to ask you guys, do you actually want to see how BLS solves this problem? Do you want to see the scheme or just take it as granted that there is a way to resolve this issue at BLS and move on? Yeah, okay. And I'm just using the slide actually by the author. So this optimization, this extra picture on BLS signatures was not added with the introduction, but it was added in a paper called Compact Multi Signature for the Global Chain that was published in 2018. And the idea here is the following. So again, key generation as before, I mean, here they're using different notation for the generators. But now here is how do you aggregate the signature? You need to start by first aggregating the public keys.
00:48:47.060 - 00:49:59.076, Speaker A: So what do you do is that you take all the public keys of the signers of your method and you multiply them together after raising them to this value alpha, which is computed by taking the half function on the concatenation of the public key that you are multiplying and all the rest of the public keys. Okay? So again, it's going to give you a different alpha for every public key because you're changing the order of the input. So then after you have aggregated key, in order to sign, you first compute all the separate signatures, all the sigma I, and then you also aggregate them together in the same way you did for the public key. So you take all the signatures and every corresponding signature, you raise it to the corresponding value outside, which is again the half of your own public key and all the rest of the public key. To verify, you just need two pairings. You take the signature and zip two on the one side that we always do with BLS. And here we just have the methods and we take the aggregated public key.
00:49:59.076 - 00:50:18.668, Speaker A: So this result was actually proposed in some forum post by Maxwell, I believe, and then, as I said, was formalized later. And this gives secure multi signatures, BLS multi signatures, and the fun flavor of the CDA problem in the market.
00:50:18.834 - 00:50:25.310, Speaker B: So is PKI also included in the set of or the contamination on the right side?
00:50:26.240 - 00:50:40.480, Speaker A: I think it does, but again, the important point to notice here is that this AI is going to be different for every key because you're putting that particular public key first and again, literally, you can think of this whole thing as a contribution.
00:50:41.060 - 00:50:46.230, Speaker B: Are G one and G two required to be the same in the setup or is it more general?
00:50:47.000 - 00:50:51.732, Speaker A: In the previous slide I was doing this as being the same for simplicity, but in practice they're different.
00:50:51.866 - 00:50:52.980, Speaker B: Does that affect.
00:50:55.640 - 00:50:58.420, Speaker A: It was mostly done for notation to simplify.
00:51:00.220 - 00:51:03.732, Speaker B: Is it important that h one and H not are different hash functions?
00:51:03.796 - 00:51:54.968, Speaker A: Yes, they are different hash functions. The crucial part with this particular hash function here that is used in signing of BLS is that it is a special hash function that maps to a T point. And this is important and not every has function satisfies that this is a regular function without maps. So it's more flexibility. And again, in implementations of BLS there's quite some discussion and I believe there are also some relevant research papers on this halfway get points functions which might also give some complications. So this is like a point in the implementation of BLS that kind of needs a little bit of speculation. So in terms of security, again, the importability gain changes when we refer to multi signatures.
00:51:54.968 - 00:52:59.440, Speaker A: It's not the same as before. So here the idea is that again, you have an adversary takes us input a public key that like the ownest user's public key that the advertiser doesn't know the secret key. Because this is a multi signature scheme, we might ask the adversary again, the adversary might ask the challenger to receive a bunch of signatures under the corresponding secret key. But also the adversary might create a bunch of secret key pairs, secret public key pairs on its own. And we're going to say that the adversary brave unprofibility if it manages to output this multi signature on this combined public key that also includes the honest user's public key on a method for which it didn't receive a signature up here. So a method is saying that it managed to create a multi signature tool that includes a particular method that includes the signal tool from the honest user as well, although the honest user never signed. Okay, so again, you see like a different flavor.
00:52:59.440 - 00:53:46.904, Speaker A: We have to be very careful on how we define these things. And again, I'm putting certain things under the rug here. But these definitions can be even more complicated. They might allow the person to be adapting to, for example, declare ahead of time what are the keys that it has generated and they are considered to be corrupted or be able to corrupt users and generate more keys as the game keeps going. So there are many, many different flavors of these definitions. I'm just giving you the very basic ones. So what do we know about multi signatures for the BLS? We already saw the results the nice thing about the DLS multi signature is that, as we saw before, it kind of looks like an aggregate signature.
00:53:46.904 - 00:54:47.170, Speaker A: It doesn't really need interaction between multi signatures are also supported by snow. So it's not a picture that is missing from Snore, but Snore multi signatures require interactions in order to produce the signature. They cannot be done by kind of aggregating things together. Naive protocol is easy to see without interaction, actually, but again with being secure under this similar again, there has been a long line of research of north multi signatures giving you only like the most notable result. There was an impossibility result at some point on two round snow style multi signatures. And more recently there was a paper that actually managed to overcome this interaction by changing a little bit how the signing process would work. And this is a so called Mousse two scheme for those of you that have heard it.
00:54:47.170 - 00:55:41.652, Speaker A: And the nice property about those multi signatures in Snore is that the final signature is actually indistinguishable from a regular Snore signature. You cannot even tell if the signature is a multi signature or not. ECDSA also supports naive multi signatures in the sense that it can just concatenate things together, but without all these nice savings in the size of the signature or in the verification. So this is what we know in terms of multi signatures. Again, the main point here is that for Snore you need a direction. So I want to cover a few more signature noctures, not in that many details as BLS. So I'm not going to be showing you how schemes work.
00:55:41.652 - 00:56:31.376, Speaker A: I'm going to tell you the definitions and I try to highlight the differences between the different properties the signature schemes have. So the next signature I want to mention is the so called Fret Hope signatures. So multi signatures have this N out of N sign policy. You want to have that old N signer signing the method. What if you have other policies? What if you want just to get these signatures out of a set of N public keys and so on? So threshold signatures allow us to do that and they have like an important point that we should be careful about. So the key generation process is not independent as before. It's not the case that every user can just generate their own keys.
00:56:31.376 - 00:57:50.036, Speaker A: Typically in threshold signatures you should think of the affiliate space. Again, well, in multi signatures you should think that every user has its own keys and they can put their keys together to sign something. In threshold signatures you should think of it as a group of signers, as a key, and they break down the key pieces and give all the pieces all the stairs of the key across the different members. That's why the key generation process in aggregate signatures is actually a multiparty protocol. It's a protocol between the participants of the group, between all the parties in order to define a single public key that looks like a regular signing public key and all the pairs of the secret key. So you might have had this as being called the distributed key generation protocol. There is a lot of research on just this part of the protocol like leaving the threat of timing aside, how can we efficiently create those keys? And I think Sarah also has some designing protocol is also typically interactive.
00:57:50.036 - 00:58:05.170, Speaker A: So we want all the timers to interact together using the search of the keys. Again, the nice part is that you can only neglect few of the timers sign up the signature will verify as long as the correct threshold of signature was.
00:58:05.700 - 00:58:17.590, Speaker B: Do you roll out a secret channel for the setup of that between the yeah. So you can post the interactions like public chain and then work from there?
00:58:17.960 - 00:59:09.980, Speaker A: Not as far as I know. If you know that after you are going to authenticate, I'm not aware of anything. So one of the nice things, as I said before, the signature is completely distinguishable from any of signatures the same for the public key. And the nice property of threshold signatures is that you actually get privacy for the signs. So you don't really know who are the P signers out of the M that actually sign the case. The problems are this interactive, expensive one time key generation, it's hard to update the public key. So I say that you want to remove a member from the group or add a new member to the group.
00:59:09.980 - 00:59:46.820, Speaker A: You have to recreate new keys and also the timing is necessary interacting before for BIS, for example, multi signatures there was no interruption. So if you try to compare threshold signatures and multi signatures, it's really a trade off. It depends on what kind of applications you want, what kind of computers you want. The most important thing is that in terms of sizes, typically threatful signatures are softened. You just need a single public key multi signature. Eventually you need all the public keys. The key setup is required.
00:59:46.820 - 01:00:24.340, Speaker A: Signatures in multi signatures is completely transparent. Everyone does its own interactions need beat in threshold signatures, not always for multi signatures and sign the privacy threshold signatures hide who signed the method. Multi signatures on the other hand, offer accountability in the sense that so the pricing can be a feature or a problem, depending on what is your goal to get the results.
01:00:25.320 - 01:00:33.112, Speaker B: Is the resulting signature and the virtual signature the same no matter which key minor you have or the signature might be different.
01:00:33.246 - 01:00:40.280, Speaker A: The signature might be different, but it doesn't allow you to distinguish. Like the signature itself can be different but cannot distinctly.
01:00:44.060 - 01:00:54.824, Speaker B: On the previous slide when you were doing the I guess the aggregation step in the middle. Is the message required to be the same for each of those inputs?
01:00:54.872 - 01:01:48.540, Speaker A: Yes. Typically vessel signatures and methods combine things with different methods. So what do we know for vessel signatures? So on top of correctness and comfortability, I'm not going to give you the full definition here, but essentially comfortability. You want comfortability against T minus one for active users. So as long as you have less than the threshold for active users, you shouldn't be able to hold signatures. And the property that is often required threatful schemes is that of robustness, which basically says that if one of the parties aboard you want to be able to still complete the process. What do we know for the signature scheme that we've been discussing in Etbsa? There is actually a very long line of work on threat of signatures.
01:01:48.540 - 01:03:03.464, Speaker A: The most notable technique among some of these works is that they're doing some pre processing to reduce the costs of online time phase. And there have been works that actually have identified so maybe the problem is not about, but at least you can identify and potentially penalize the boarding parties. For Snore, maybe one of the most notably schemes is Froze. We have one down threshold signatures, again with identifiables and for BLS we also have a few constructions. Something to note about BLS is that it's only allowed for static adversaries. The adversary cannot cover up, as I said before, additional parties throughout the game, which is actually satisfied by so here, I would say, in threshold signatures, BLS is doing maybe a little bit worse in the sense of the table to kind of summarize the properties that we discussed without, of course, having all the caveats from the security models and so on under the rank.
01:03:03.612 - 01:03:07.140, Speaker B: Is there any idea if that's a fundamental limitation of BLS?
01:03:09.400 - 01:04:19.988, Speaker A: I'm not aware of any possibility results, but I'm also not aware of any group in the adaptive model. That's a good point. And this was like 2020, maybe it might be. The last two signature schemes that I want to mention if people are still here with me are those of ring signatures and adapter signatures. And that will be so ring signatures have been used in the blockchain settings or mainly for privacy oriented cryptocurrencies. So the idea is that you have a timing algorithm that takes a ring with a method, a secret key and a so called ring, which is a set of public keys. The secret key should correspond to one of the public keys in the set and in the verification you get a method.
01:04:19.988 - 01:05:07.630, Speaker A: The ring is a signature and it should accept the text. The important property that you get here in the ganoxanophormalis I'm going to go a little bit faster signature schemes is that you actually want an identity. And what does this mean? This means that when you say signature, you don't know who was assigned, so who was the user assigned. Notice that this is different than stressful signatures because the signing algorithm is not interactive or anything. I'm just signing alone. I can pull the public keys of whoever I want without them being ever involved and create a signature that is hiding my key under their key. In threshold signatures people work together.
01:05:07.630 - 01:06:25.492, Speaker A: So you shouldn't use this as like one out of ten threshold signatures. This is not the case. So I think I'm going to skip the security game here but I'm having with people if you want to and as I said, the most notable use of link signatures is in Monero where they're basically used to hide who was the sender of the transaction within the ring. We have seen additional applications, not strictly online crypto Paris, but when there were original proposals proposed as a way of electronic voting, hiding who you are among a set of voters and also for Whitter glowing, which again might be interesting, like layer two of the case. What do we know in terms of construction? So ideally when you construct a signature, you want the signature side to be sublime to the side of the ring. Ideally you want to avoid any sort of transit setup and optionally, you might want accountability, you might want to be able to figure out who was assigning. They were introducing signatures back in 2001 and there is a bunch of sublinear constructions in the random order CRM and standard model here.
01:06:25.492 - 01:07:37.860, Speaker A: Unfortunately there is not a strict mapping list DSA DNS and Snore as I was doing before. Some of these schemes are under similar computational assumptions but it's not like we can just convert, for example, DNA wearing signatures. Okay? So there might be schemes that kind of use similar skins but it's not like this one to one mapping with the properties that we did before. The last thing that I want to mention just because kinds of signatures kind of gain some popularity, say a couple of years, are the so called adapter signatures or scripted scripts. So these are signatures that achieve two properties at once. You're able to authorize the method as a regular signature and at the same time allow the liquid of a predefined secret value. So what's the idea here? The idea is that this is kind of a very different signature scheme because you have a signer secret key in the public key and you have some entity, some party that it's typically called the publisher, that knows some secret and also has a method.
01:07:37.860 - 01:08:41.376, Speaker A: So what is the idea? The idea is that if you get a signal from the signer on the method then this should allow the signer to extract the secret value. So in a very high level the protocol allows the two parties to interact, send some messages to each other. From those methods you can view this as some sort of like a presigning process. From those methods the publisher can get a signature using the secret sorry, I missed the methods here, the methods and those values and this signature should verify under the method. And if the signature is posted somewhere typically in a blockchain from the signature the time you can actually extract the key. So you might be wondering why this is even useful. This is useful in a sort of fair setting where you might have go very close, very quickly analyze this.
01:08:41.376 - 01:09:49.180, Speaker A: But if you have like a seller that wishes to sell some secrets and you want to kind of pre lock the coins of the buyer before starting the exchange, these signatures kind of allow very natively. Note that this pair exchange crystal pancake is also possible without these signatures. But then you're really stuck to use the particular cut functions that are supported by the underlying system while doing it in a signature level. It might give you a little bit of more flexibility. The primitives that were introduced by Boys Round in 2017 we have compatible Snore and Dcvsa constructions and unfortunately we have impossibility results for BLS and in general unique signal. So again, the nice thing here is that if your blockchain system supports Snor and BSA, you can build this adapter signature where you're not stuck to use a particular half password.
01:09:50.560 - 01:09:56.656, Speaker B: And W contains some of the semantic contents of the M. I don't think.
01:09:56.678 - 01:10:19.620, Speaker A: That they need restriction on whether WSM so you should use W as something that the seller wants to sell, for example, that I'm hacking the correct thing and then use protocol just to get a fair extent of coins.
01:10:22.200 - 01:10:34.600, Speaker B: Or an application for something like selective disclosure of a certain part of like a dental right where M would be like encrypted. And you want to reveal some subfield containing M unencrypted.
01:10:35.420 - 01:11:42.030, Speaker A: Exactly. So I'm trying to keep you longer and I just want to conclude with some takeaway points the literary review of the digital signature. Many schemes with many different properties and I didn't even cover every single signature scheme that we've seen in the block space, development space out there. All the schemes that I discussed are not post quantum secure. So there is a lot of discussion and also what can we do post quantum secure schemes? We know classes based half based signatures, their efficiency issues of missing features in such schemes. I want to highlight that it's very very important to understand the security model when you're trying to decide which signature scheme to use, understand what attacks is this scheme security game, under what assumptions and very very importantly also look out for implementation levels of API issues. They can be lookhold for vulnerabilities and we've seen that multiple times.
01:11:42.030 - 01:11:47.780, Speaker A: And with that I want to conclude the thank you, I'm sorry for taking classes.
