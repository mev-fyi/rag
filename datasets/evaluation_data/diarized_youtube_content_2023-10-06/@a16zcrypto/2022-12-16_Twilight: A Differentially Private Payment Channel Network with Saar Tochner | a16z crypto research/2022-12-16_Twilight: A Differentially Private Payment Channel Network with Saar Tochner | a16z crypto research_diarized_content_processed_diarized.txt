00:00:09.140 - 00:00:51.280, Speaker A: So hi everyone. This talk is going to present a paper that just got accepted to usenix security like we presented two weeks ago there. I think I really like this paper because it spans through many different topics. So like in every groups that I presented to has different kind of questions. So just feel free to talk and to interrupt with any questions because I really want you to understand that deeply. So the paper is called Twilight a Differentially Private Payment channel network. And this is a joint work with Maya Dotan Yosen of Ivzor.
00:00:51.280 - 00:01:26.160, Speaker A: We're all from the Hebrew universities. Okay, so a bit about myself. I'm a PhD student, finishing my PhD at the Hebrew University of Jerusalem. I have a lot of different papers in the area of cryptocurrencies. Twilight is the paper that I'm going to present now. But we have also Blockchain Stretching and Squeezing, which is a paper that discusss how to change the rate of block creations in blockchains. And using that we were able to create an arbitrage between different DeFi platforms.
00:01:26.160 - 00:02:15.920, Speaker A: We have this paper about how to add new channels into payment channel network and then hijack traffic and create maybe denial of service. And another completely theoretical paper about how to avoid isolation attacks or eclipse attacks in general, peer to peer networks. But this paper, this talk is about Twilight. So let me first try to introduce the basics, the preliminaries of this talk. The first thing that I want to make sure that everyone in this room knows is payment channel networks. So PCN, PCN is a network. In every network we have the relays which are the participants in the network.
00:02:15.920 - 00:02:48.120, Speaker A: We have channels. Channels are the edges between the relays and in a channel there are locked coins. And when I said locked coins, let's assume that we have Alice and Bob. Each one of them locked five coins. In this locked amount of coins they can just now create transactions or create small payments. For example, Alice can transfer two coins to Bob. When they do this transfer, they just decide on a new division of the locked coins.
00:02:48.120 - 00:03:25.440, Speaker A: So the same amount of coins is here. But now the coins are devised between the parties differently. They can now do however many payments that they want. And an important thing to note here is that giving this new state, after Bob paid one coin to Alice, in this state, alice will not be able to transfer five coins back to Bob. Right, because we don't have enough liquidity in her side of the channel. Perfect. Then we have routes.
00:03:25.440 - 00:04:13.540, Speaker A: Routes are just list of channels from a specific source to a specific target. And then we have payment. Payment is just shifting coins across this long route. So for example, we have Alice, Bob and Charlie. Alice can transfer two coins to Charlie across this route. And as we can see the liquidities, the divisions of the fund will be updated throughout the route. Again, an important thing to notice here is that Alice should not be able to transfer another two coins to Charlie because even though she had enough liquidity in the channel that is direct to her somewhere later in the route, there isn't enough liquidity.
00:04:13.540 - 00:04:53.090, Speaker A: Perfect. This is a payment channel network. And this is not something that I just invented. There is the lighting network, which is a big payment channel network that has a capacity of over $100 million. This $100 million are just the locked funds, which means that transactions that goes on, it may be much, much higher. And this $100 million is after the great cut in bitcoin prices in the last two months. So people use that.
00:04:53.090 - 00:05:39.420, Speaker A: And why do people use that? The main motivation is blockchain. I will just put it here. That's okay if you will not understand it. The idea is that we use only two transactions in order to summarize or to squish a lot of different payments or different coin transfers that happened. So we do a single transaction that locks the coin, that creates a channel. This thing happens inside the blockchain and then outside of the blockchain, we will do many payments, which are different divisions of the same locked fund. And then when we decide that, okay, this is the less division that we want to do, we will just commit it back to the blockchain.
00:05:39.420 - 00:06:21.100, Speaker A: So we were able to create a lot of different coin transfers with just two transactions in the blockchain. And this is awesome because it creates a great scale. We got fast payments, and I actually didn't tell you how to do that. But we can also get the trustless property, which is, well, this is great. This is what we need to have. And there is a but an interesting but in this kind of networks is the probing attack. A probing attack is an attack that was presented first in a paper in 2017.
00:06:21.100 - 00:07:23.936, Speaker A: So probing is to inquiring closely into something. And in this attack, we base or base it on the idea that to probe, to understand something about the network is very cheap. Or in here, this is actually free. The idea is that an attacker can execute a transaction or can ask the network, hey, can I move a specific amount of coins from me to someone else? And then after receiving a response from the network, the attacker can just cancel the transaction and not pay anything. So the attacker was able to achieve observation from the network without paying anything. And the idea here is pretty simple. The idea is that the attacker can just repeatedly query channels over and over again until he will see changes, which is pretty cool.
00:07:23.936 - 00:07:52.556, Speaker A: For example, we can look on the right, which is marked in blue here, and the attacker just query, hey, can I send 100 coin? And for example, the network now tells him, yes, you can transfer this 100 coin. Cool, thank you. I will cancel the transaction. A second later he will just query that again. And a second later he will just query that again. Each time he gets a yes. Because okay, there is a yes.
00:07:52.556 - 00:08:33.610, Speaker A: But then in the fourth time that he queries the network, he maybe gets this answer the no. So any attacker that observes these changes in the network can just react to these changes. And for example ask hey, can I send 50 coins? The idea here is a simple idea that leaks lot of different kind of information about the network. It leaks the current liquidity of the channel. Because we know how much money both sides locks. But we don't know how the money transferred between the two parties. It leaks the existence of the transaction that a transaction just happened.
00:08:33.610 - 00:09:33.100, Speaker A: It leaks the size how many coins moved from one side to another. If the attacker will do that to many channels in the network because he can this is free. Then it also leaks the identities whom send money to whom. And this is silent to Alice and Bob. Alice and Bob will not know that someone is currently trying to understand whether they just pay to one another. This is a great but Twilight is a system is a payment channel network that tries to solve this problem, that tries to solve probing attacks. I think that this will hint you how do we do that? But the basic idea is that we're using noise in order to provide differential privacy guarantees.
00:09:33.100 - 00:10:11.492, Speaker A: We then use trusted execution environments in order to enforce the relays to use our protocol. And this is a systems paper. So we both have analysis and simulations to all the three properties of the cost privacy and security. And we have a full prototype implementation. This slide is our agenda for the rest of this talk. We will first talk about how do we achieve this differential privacy guarantee. A very interesting construction.
00:10:11.492 - 00:10:55.312, Speaker A: I think that the people that love privacy will enjoy that. Then we have the trusted execution environment which is how to define protocols correctly between trusted and untrusted parts and how to engineer it. And then in the last we will talk about real implementation and what are the performance of this network. So let me start with explain you a bit about differential privacy. Does anyone know what is differential privacy? Awesome. So I'll just go fast on it. In our case specifically we wanted the attacker will not be able to distinguish between two events.
00:10:55.312 - 00:11:43.232, Speaker A: The first event is that Alice paid Bob and the second one is that Alice didn't paid Bob. The formal definition uses epsilon and delta. The epsilon is here. As epsilon goes to zero. The probability to see a specific observation of the attacker on the network should not be correlated with whether Alice paid Bob or Alice didn't pay Bob. So as epsilon goes to zero, we bound. What is the probability to see this observation in two different events, whether ours payball or Alice didn't payball? And we want to be able to make sure that in most of the cases, the attacker will get this thing.
00:11:43.232 - 00:12:06.010, Speaker A: So that's okay, that the attacker will get more information in some of the observations. But we want to make sure that the leaking observations will be as few as possible. And this is delta. In our case, we use delta ten at minus five. So in a very small chance, the attacker will get more information than that.
00:12:07.020 - 00:12:08.420, Speaker B: What about epsilon?
00:12:08.580 - 00:12:26.444, Speaker A: Epsilon is here. In our case, all our analysis will be on Epsilon, which is zero point 15. So usually this is a valid epsilon delta for a differential price.
00:12:26.482 - 00:12:27.420, Speaker B: That's pretty small.
00:12:27.570 - 00:13:08.270, Speaker A: Yeah. Wait to see the numbers. Great. What is noise in our case? Noise in our case is some random number R. And this random number the channel will generate upon a query. Upon someone asks him hey, can you transfer M coins for me? And then instead of checking, hey, do I have enough liquidity? He will check if he has enough liquidity minus this random number. In the next four slides we will discuss more about how to generate this number.
00:13:08.270 - 00:13:42.170, Speaker A: But I want to highlight here that this is said right me as an channel owner, I will say no to much more transactions because I have lower liquidity. And that's a bummer. I hope that later in this talk I will convince you that this is not that bad. Or I will give you some economical argument about what it really gives us.
00:13:44.300 - 00:13:53.180, Speaker B: You're generating random transactions here. Is it all like revenue neutral? So nobody only hurting liquidity if people aren't?
00:13:53.520 - 00:14:31.990, Speaker A: That's an important question. So we don't generate random transactions, we just generate random number that reduce locally from the liquidity. This is not a real transaction. This is not a real money that goes in the network, just every channel by itself. When he tried to enter, whether he can transfer coins, yes or no, he will just reduce locally just for this specific worry. So someone wants just transfer 100 coins, like in your example, and you sample R is like 50. You will only do the transfer if you have more than 150.
00:14:31.990 - 00:15:12.740, Speaker A: Yeah, I will still transfer only the 100 that the attacker asked. I will not transfer more. This R is only used to answer the question can I transfer yes or no? Because this is the only observation that the attacker sees. So we just want to somehow noise it awesome. How do we generate this random number R? First of all, I want to make sure that we all understand that the naive solution doesn't work here. And the naive solution is pretty simple. Let's just assume that the channel owner just every time query a random number independently.
00:15:12.740 - 00:15:52.508, Speaker A: So it will not work, because the attack is really cheap. Is actually free. So the attacker can just do it over and over and over again and just see how many observations does he really get of yes and no. And to reconstruct everything, the noise formula is known, everything is known. So he can just rewrite everything on a paper, solve it and understand what is the real liquidity. And it doesn't matter how many yes or no he gets, he just can always rebuild the histogram. So we can't use something that is that naive.
00:15:52.508 - 00:16:43.372, Speaker A: We will actually use something that is more complex, which was presented in 2011. And the idea is that we want to achieve differential privacy under continual observation. And the basic idea here is that we want to drop the independency property. We want somehow that the queries that the attacker query us, the noise will be dependent and in what sense dependent? We want that over time there will be dependency. So I'll now going to present you a construction on how to build the noise. We will later just give you the intuition on why it works. So here is the construction on how to build the noise.
00:16:43.372 - 00:17:25.330, Speaker A: First divide the time into slots and build a tree where the lives will be the time plots, the time spent. Then we want to track payments in the subtree in the route to the route. So for example, we had a coin transfer here. Then all we can see here the changes that we know. Okay, a payment happened in this subtree. Now we derive noise from the minimal covering set. For example, if the attacker queries at T equals seven, then the noise will be derivative from the time span between zero and six.
00:17:25.330 - 00:18:29.590, Speaker A: The minimal covering set of this time span is the nodes that are currently marked in blue. Okay, we sample noise just once for every tree node and then we can just answer the question can we transfer Mcoin? So please note that we added here a time which gives us the dependent between different queries. And then the answer will be just the capacity minus the actual payments which gives us liquidity. And then we add our R, our total noise. This is the construction. So the important things that we need to notice here is the minimal covering set and the idea that we sample noise once for every tree node. Does the construction make sense? No fair.
00:18:29.590 - 00:19:07.600, Speaker A: Let me present you why it makes sense. And here is the idea. The idea is pretty simple. The idea is that we want to limit the number of different noise that happens on the same coin transfer. And let me give you an example. Let's assume that we have a coin transfer at T equals one and then the attacker queries on the red plot in T equals two. Then the minimal covering set will be the node that is currently marked in blue.
00:19:07.600 - 00:19:50.110, Speaker A: So the attacker will now see a specific sampling of noise that hides this coin transfer. Okay, he gets one observation. Now the attacker queries again at T equals three. The minimal covering set are the nodes that are currently marked in blue. But note that we did not generate a new noise here. Which means that the same noise that hides this coin transfer, we use it the same noise again for the attacker. So the attacker now didn't get a new observation of noising the same coin transfer.
00:19:50.110 - 00:20:53.280, Speaker A: This is the intuition. And only next, when the attacker queries on time t equals four, we will query the random number generator and get a new noise. So in total, the number of different Noising samples that the attacker gets for every coin transfer is limited is limited in the number in the height of the trip. So if we will compare it to the naive approach where the attacker just gets a fresh new noising over the same coin transfer here, it doesn't get too much fresh noises. We limit the number of fresh noises that the attacker gets for every coin transfer. So if we assume, if we said before on the naive approach that the Decker just gets different noising, a lot of different Noising of the same thing now we just limit the number of different noising. He just gets a fewer number of samples.
00:20:53.280 - 00:21:55.264, Speaker A: And the next slide gives us the analysis of okay, so what? So we get five samples instead of 5 million. How good is that? The idea is that we need to somehow construct a noise that will all the time will look the same. So we want that. As I said before, in order to generate the noise, we will sum the noise of all the tree nodes, of all the tree nodes in the minimal covering set. If you will just create a noise for every node while you go like if I'm querying now in time T equals five, then I will generate five. And if I'm querying on T equals six, then I'm generating six. So the noises keep getting bigger.
00:21:55.264 - 00:22:54.766, Speaker A: So it's just impractical. You want somehow that you will limit the number of noises, of different noises that you add in your noising mechanism. So you need to balance between the different sum, the number of summation that you do of noises on the one end and on the other end to give enough privacy. So this is the thing that the tree tries to balance between. How can you just add a fixed or a limited number of noises while still preserving some kind of privacy? Does this make sense? Perfect. Maybe later in this talk it will make more sense. Let me present you just the basic of the analysis.
00:22:54.766 - 00:23:49.278, Speaker A: The basic of our analysis is, first of all, based on how many different samples of the noise on the same coin transfer does the attacker get. So if the attacker gets more samples of this Noising mechanism over the same payment, we lose privacy, right. So for longer routes where the attacker can just query each channel independently, there will be more samples leaked. So longer channels, longer route means less privacy. This is L. Then we have R is if there's two routes that Alice could use in order to pay Bob, this somehow helps the privacy. Right? Because the attacker don't know which route to query.
00:23:49.278 - 00:24:39.922, Speaker A: Or he will see two different observations, but he will not know which one he really need to use. And this is where I went, which is a real theorem that try to use this L and this R and this T, which is the number of noise, and log T which is the height of the tree. And we try to build something that will gives us real numbers on what is our privacy guarantee. And I know that this theorem or these numbers don't give you a real intuition. In two more slides I will just plot it so we can all see exactly the numbers. Yes.
00:24:40.056 - 00:24:47.526, Speaker C: The differential privacy guarantee, is it for the next 60 years or is it per some transfer?
00:24:47.708 - 00:25:11.454, Speaker A: That's a great question. So we assume, worst case, that the attacker can just query all the time, even in the future. So the same guarantee holds on a transaction that happens now, even in 60 years in the future. We also assume that the attacker can query all the channel in the network. We have a super strong attacker in.
00:25:11.492 - 00:25:15.694, Speaker C: The expression what is T? Is that like the amount of time?
00:25:15.812 - 00:25:42.816, Speaker A: Yeah. So log T is like the height of the tree. This is the maximum number of different samples that the attacker will get on a specific coin transfer. Perfect. So there is a trade off here, an interesting trade off, right. Adding noise means that we will fail more. So this is what you meant.
00:25:42.816 - 00:26:51.070, Speaker A: I think we will just say no to more transactions and the relays can just compensate it by locking more coins. And this is possible. But this extra locked coins means that he will pay more money. And how much more money will he need to pay? This is a very interesting question and I will give here some kind of economical argument that let's assume that the attacker don't need to pay for all these extra locked coins. Why? Because he can maybe just take a loan from the bank of these extra locked coins and then when the channel will be distracted, he will get all these locked coins back, he will repay the loan, which means that he only need to pay for the interest of this time. So when we ask how extra money does it cost to create our channels? It depends on time. And the equations that I will give will be depend on time.
00:26:51.070 - 00:27:49.710, Speaker A: As I promised numbers 9560 times the number of the minimal query. For example, if you want to hide queries of size one, you need that the channel will hold 9500 coins. This is a lot. Okay, perfect. And this is the Epsilon. This is the same Epsilon from the differential privacy guarantee. On the other hand, we have this thing of, okay, so maybe we can just lock much less money with the same Epsilon, but we will pay for it with a very bad we will just say no to everyone.
00:27:49.710 - 00:28:42.030, Speaker A: For example, if the channel will just say no to everyone, he can lock zero money, extra zero money, and the epsilon will be there. Right. So we need to somehow balance between the privacy and how much fails do we get. And this is, I think, the most interesting economical argument that we can give here. Let's assume a yearly interest rate of 3%. If we want to get a delta, the efficiency of ten in minus five, and we want to get an epsilon of zero point 15. And here comes the time that I talked before.
00:28:42.030 - 00:29:19.450, Speaker A: If the channel will handle 77 payments a day, then taking 1% is enough to cover all the extra costs, everything. So, yeah, I agree that this 9500 seems a lot, but 1% of 77 payments a day? Well, this is reasonable. I can give you, for example, Visa takes two and a half percent, american Express takes 4%. We're taking one. Okay. Makes sense. Yeah.
00:29:22.140 - 00:29:39.392, Speaker D: Does the maximum type of a payment come into play at all? Like, if I have a payment channel that can do a maximum of 10,000, I want to send 10,000. Presumably that will be easier for someone to detect now all of a sudden, yeah.
00:29:39.446 - 00:30:12.620, Speaker A: So this 9500 is comparing to the maximum number of coins that you wish to hide. So if your channel is wish to hide payments of one, then you need to lock that. If you want to hide payments of ten, you need to lock ten times that. But your channel will be able to transfer ten if you locked only that. But then you will provide worst privacy guarantees.
00:30:13.200 - 00:30:23.560, Speaker B: Follow up on Matt's question, which is the payments on the bottom of the slide? There has to be some relationship between the typical size and 77 payments.
00:30:23.720 - 00:30:59.816, Speaker A: Yes, this is 77 payments a day of the maximum amount that you wish to hide. If you wish to hide a single coin, which means that you need to lock 9500, then you need 77 payments of one. This is the maximum side that you want to hide. That's why you usually a channel will not say that he tried to hide thousand dollar payments because then it will cost him a lot in additional locked funds. So it's a balance, I guess.
00:30:59.838 - 00:31:12.220, Speaker C: I had a similar question, which is how does time play into these graphs? If you want epsilon equals zero point 15 for all time, then you'll have to pay a lot more additional locked points. Is T fixed to something here?
00:31:12.290 - 00:31:59.724, Speaker A: Yeah, this is really important epsilon affects so there are two different times in here. The time the T that Epsilon is using is a lot of time. It's like 64 bits of time. So we assume this 64 bits of time that the attacker can just query every time span across these 64 bits of time. This time is a different time. This time is a time of how much time do we want this channel? Let me phrase it like that. We're taking loan from the bank in order to create this channel.
00:31:59.724 - 00:32:22.470, Speaker A: And then the channel will be destructed and then we will repay our loan. What is this time period? So this is not necessarily the same time periods, right? The channel can live less than 60 years in the future. The channel can live for a day, a week, a year. That's fine. This is the time here. So, different times.
00:32:25.080 - 00:32:42.380, Speaker D: How does the parameters change? Like as they want to go from 60 years to like 120 years. What I don't understand clearly is how does the privacy versus efficiency change? Because it's like a log T here, and I'm trying to figure out if that's like bad when T grows or good when T grows because it's some linear.
00:32:42.960 - 00:33:28.810, Speaker A: When T grows, it means that if you will use the same tree structure and everything when T grows, it means that you will have more height, which means that the attacker will see more different observations, which means that you can just keep everything the same. You can keep the same 9500 extra coins, but then you will pay with Epsilon. So there is a delicate relation that is in these equations that gives you what is the balance that you're trying to achieve? If you're trying to achieve the same Epsilon for longer T's, then you will need to lock more money or to fail more.
00:33:29.180 - 00:33:39.870, Speaker D: Okay, so the way to look at this is this bigger T is bad just because it's growing in T. It's not good because it's growing sublinear in T. Like you don't save anything.
00:33:40.480 - 00:34:15.288, Speaker A: Yeah, that's a balance. Everything you hear is a balance. And that's why I say that this equation is pretty hard to digest, I would say, because it has a lot of different parameters inside. Perfect. And this ends our theoretical differential privacy part. Let's talk about protocols. Protocols are cool.
00:34:15.288 - 00:34:48.260, Speaker A: And here our protocol challenge is the following relays don't want to use Twilight. Relays that use Twilight will say no to more transactions. They can just say, hey, sure, I'm used Twilight. Yeah, I'm adding the noise and oh, the noise was small. I'm so lucky. We need to somehow force them to use Twilight. And this is an interesting challenge.
00:34:48.260 - 00:35:39.460, Speaker A: Realists don't want to use us, we want to make sure that they do use us. We can try to solve it from many different places. Forcing is a world that whereas the computer science don't love to use. We tried to think a lot about incentives in one sentence this is pretty hard because you cannot make sure that they created the noise as you wished. They might create noise differently and we want to make sure that they use the noise as they wish. So we just decided to force them. Yeah, that's a good reaction to just think about it.
00:35:39.460 - 00:36:07.000, Speaker A: Yeah. And when I say force, this is not that force and not that force, but this is that force. Trusted execution environments. So let's talk about that. Perfect. What is trusted execution environment? Trust Execution environment is just an isolated hardware that gives us two properties. The first one is integrity.
00:36:07.000 - 00:37:01.470, Speaker A: It means that when it starts to execute a program, it tells me, hey, this is the program that I'm running. And it cannot change the program in the middle, it cannot change Opcodes in the middle. It just has to run it back to front just in a single execution. The second interesting property is the confidentially. While this isolated hardware executes a program, we cannot see what is its memory, we cannot see which execution flow it took, we just cannot see anything. We can just think about trusted execution environment as a black box that can tell me, hey, I'm running this executable. This is the response and I can fully trust it.
00:37:01.470 - 00:37:31.044, Speaker A: An important thing to say here is that there are different ways to implement it in practice. There is the SGX of intel. Nitro of AWS. Different approach. To achieve this trust execution environment, I want to use it here as a primitive. Let's assume that we have this tool. Another important thing to say here is remote attestation.
00:37:31.044 - 00:38:15.604, Speaker A: This is the process in the beginning when the Teas initialized, they just attestate with everyone or with the third party to say, hey, this is the code that I'm running. This is a trusted part, a trusted phase that you need to make sure that works. Awesome. This is a great primitive, let's see how we can use it. We want that every relay will run a T. We want that the T's will be completely stateless. Why? Because if they will not be stateless, then there will be a lot of communication with the blockchains that need to happen.
00:38:15.604 - 00:38:50.188, Speaker A: There is a consensus that you need to implement inside the Tea and we just don't want to get into it. So we decided to get a stateless T. This decision creates a lot of different challenges. The new challenges are okay, so this is stateless. I'm, as a relay that has this T, can just rerun the T over and over and over again until he will respond me with the good noise that I want to see. Right. I can just re execute everything because this is stateless.
00:38:50.188 - 00:39:34.480, Speaker A: Then it means that we need to somehow hide everything. Hide everything means that we need to create like the thing that we promise to handle is now encrypted, which means a new smart contract in the blockchain in. Order to handle everything. It means a lot of things. The next thing is that a relay can cheat the T with what is my real liquidity, right? The relay can tell the T, hey, I don't have 100 coins locked in my channel. I have a million coin lock coins locked in my channel. Okay? So the T always say sure you can transfer these coins.
00:39:34.480 - 00:40:27.904, Speaker A: We solved it in the paper with simply inversing everything. Instead of the T checking whether I can send the coin, the T only check whether I can receive the coins. So by changing that, the relay has no incentive to cheat the Tea. If the relay will say that he has more coins in the incoming channel, then the T might accept to transfer to give money to someone, although I cannot receive this amount of money. So the relay has no incentive to cheat to bigger numbers. The relay has no incentive to cheat on smaller numbers because then the tier will just say no to transaction that I would have accept. So I don't have incentive to cheat lower.
00:40:27.904 - 00:41:22.930, Speaker A: So my incentive is to just say the right thing, which is amazing. Third channel is about colluding relays. Relays can just create many a single relay can create many nodes in the network. So he can just look whether the node before him said no, I don't have enough liquidity, and then he can just tell him. And we don't want that it will happen because the T is stateless. So we need to somehow make sure that all the payment looks the same whether it was accepted or not. Only after the payment will be finalized, only then we will know whether the money was transferred yes or no.
00:41:22.930 - 00:41:53.180, Speaker A: Cool, I will just keep that and let's talk about the implementation. The implementation of this thing is huge. We have three parts. We have the new smart contract that need to handle this encrypted. It's not HTLC now, right? Because everything is encrypted. We don't know how much money we promised to give, so everything is encrypted. So we need to create a new type of smart contract.
00:41:53.180 - 00:42:45.896, Speaker A: So we wrote it in solidity and tested with Ganache. The enclave itself was written in C because we wanted to write it on a real SGX. And we used Pistachio in order to communicate with the relay. And the relay themselves was written in Python using Fast API in order to communicate between one another and Pycryptodome in order to execute cryptographic operations in sea level in fast way. We implemented it all on Azure confidential Computing in order to have dozens of machines with an SGX hardware. We used Azure SDK in order to create big topologies with different connections. We wanted to use real time network delays.
00:42:45.896 - 00:43:30.760, Speaker A: So we want to create our machines in different places across the world. And we had to somehow monitor everything. So we used Elasticsearch in order to send all the metrics from all the distributed systems into one place. So we can just monitor everything from it. And it creates a very cool, I would say open source that is now available to everyone, which called Twilight, which has, I would say, a lot of different languages, very sparse implementation. That was awesome. Which gives us pretty good performance.
00:43:30.760 - 00:44:21.470, Speaker A: And when I say pretty good performance, I'll say here that we achieved a throughput of 850 payments per second, while currently the Lightning network handles 350, almost three times higher. I would say here that we have the T, which is the bottleneck. Let me later explain you why it happens. We have a very fast latency for a single payment to be accepted. Assuming that there are four intermediate relays between us, it's less than 1 second latency. Just think about the latency of using Visa. 1 second is pretty fast for private payment channels from private payment system.
00:44:21.470 - 00:45:22.412, Speaker A: And this is an important thing, the idea of me putting an encrypted data inside the blockchain. So when I'm trying to put an encrypted data inside the blockchain, it means a lot of things. It means that I need to pay on this stored data, I need to pay on the gas of decrypting it and validating it and all these things. So it creates us a very interesting trade off between what we want to happen inside the smart contract and what happens in the T. Because the T encrypts things and validates things and sign on things that happens on one side, but on the other side we have the smart contract that also need to decrypt. And here the cost is high. I don't know if you probably tried it.
00:45:22.412 - 00:46:02.268, Speaker A: How much does it cost to store a single bit in the blockchain? This is crazy expensive. Half of the price here is storing. So we wanted to make sure that everything is super tight, which created us an interesting trade off between this number and this number. We decided to once again we decided to move all the hard cryptography building from the smart contract to the T. Yeah. So you said the smart contract is decrypt. How is the key in the smart contract secret? That's an important thing.
00:46:02.268 - 00:47:13.676, Speaker A: So I didn't got too deep on how the trustless property of payment channel network works. But the idea is that there is a secret that the recipient of the payment release once he wants to get the money. So we want to make sure that his secret, the secrets of Bob, the recipient of the transaction, will somehow be the key to this encrypted value. Is it okay for that key to be public? Because I could imagine someone could intercept that might request in a peer to peer network and then who knows what they could do if they know the key. Yeah. So once Bob reveals his secret, it is completely public. So we need to somehow make sure that everything works as should and I think that a really cool thing to say here is that note that we encrypt this value that should be decryptable, although it should be decryptable by two different keys.
00:47:13.676 - 00:47:33.350, Speaker A: It should be decryptable by the key of Bob, but it also should be decryptable by the next key. So you need to do some very delicate cryptographic here, cryptographic operations here. This is something that I can take offline and explain.
00:47:34.280 - 00:47:41.370, Speaker D: And so I don't know if I missed something, but I thought you were pitching something like add on top of that's true.
00:47:43.200 - 00:48:33.390, Speaker A: You didn't miss anything. The 350 payments that I mentioned is something theoretical that papers showed that it is possible to do on currently lighting network because they just didn't try to make it more efficient. The idea is because the currently lighting network can handle 350 payments, in real life there are less than 350 payments per second. That's why our system will just handle it as well. You're right, we're doing more work than the lightning network. So conceptually they will bit us somewhere. But currently it's just not important because the throughput that they trying to handle, we can handle just I guess maybe I'll turn out.
00:48:35.040 - 00:48:43.804, Speaker D: What about this could possibly increase the throughput that it felt like what you were presenting was just like strictly more work and that somehow there's more throughput.
00:48:43.932 - 00:49:23.210, Speaker A: Yeah, so again, the more throughput is because they didn't try to make their code more efficient. We absolutely do more work. Our main bottleneck is the T, which is you can think on it because this is hardware. Our relays have lot of cores and one core to the T. So it's like we have a very strong CPU bottleneck. Let me just conclude in the last five minutes so we're able to achieve differential privacy under continual observation. This is the tree that we built in the beginning of this talk.
00:49:23.210 - 00:49:56.950, Speaker A: Then we talked about the extra cost, the additional coins that the relays need to pay in order to achieve privacy. Relays are selfish, they don't want to use Twilight. That's why we enforce them using Tis. And we have a full prototype implementation that works. So you can use it tomorrow if you wish to do private payments. That's it. Thank you.
00:49:56.950 - 00:50:02.150, Speaker A: Questions?
00:50:08.330 - 00:50:24.970, Speaker B: I hear conflicting things about PES. Right? Some people seem to think I said it's just a very pragmatic way to make progress. Your thoughts personally and just off of that?
00:50:26.060 - 00:51:36.012, Speaker A: That's a good question. You're right, there is a huge debate about it. I like to present this work, and I work more with this in different papers as a new primitive that we as the academy community can just use as new primitive to achieve new goals that we always wanted to achieve. And this idea of forcing a specific protocol that you cannot verify differently or you can, but it will be costy. This idea just gives us a whole new world of new problems that we can solve if we will look on how the industry really tried to create trusted execution environments, there are two different approach. The first approach is like a separated hardware. This is what intel does and it just keeps breaks, right? Every week, new researchers find a new way to just side channel secrets out of the SGX.
00:51:36.012 - 00:52:30.048, Speaker A: And there is another approach. The approach of AWS Nitro where they just say yeah, this is a nitrogen hardware. We don't promise you that this hardware is strong, we just keep this hardware in a different place. We are the API between your machine and the other machine and we just make sure that you cannot do anything there. So the industry tried to create to make these primitives feasible. They not there yet, but I do think that creating research over these new primitives is the way to to get very crazy things done. Awesome.
00:52:30.048 - 00:52:33.330, Speaker A: Thank you so much. I think that we're up on time.
