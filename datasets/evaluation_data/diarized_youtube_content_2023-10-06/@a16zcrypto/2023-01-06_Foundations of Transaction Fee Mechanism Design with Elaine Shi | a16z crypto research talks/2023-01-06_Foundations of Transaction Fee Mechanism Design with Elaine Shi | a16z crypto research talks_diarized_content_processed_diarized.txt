00:00:09.280 - 00:00:42.920, Speaker A: I'm very happy to be here visiting this amazing group. I'm going to talk about transaction fee mechanism design. This is joint work with my student Hao Chang. So transaction fee mechanism, this is what we need on the blockchain because the space on the blockchain is scarce, but there are many users who want their transactions to be confirmed. So they would all bid. And we run an auction to decide whose transactions get confirmed. Okay? So today Bitcoin's transaction is a simple first price auction.
00:00:42.920 - 00:01:24.684, Speaker A: Essentially, suppose your block has size K. Then you just take the K highest bids, you confirm them in the block, and everyone pays their own bid. And all the payment goes to the miner, the miner who mines the block. Okay? So essentially, whenever you mine a new block, this auction will be run. And as we know from classical mechanism design, first price auctions, they aren't awesome auctions. In particular, it would encourage untruthful reporting, right? So for example, you may be incentivized to bid barely enough to be among the top case. So you can still get confirmed but pay less.
00:01:24.684 - 00:02:10.936, Speaker A: So that's not too great. And one obvious question is, why don't we just use the classical body of work in mechanism design? We have learned from auction theory that second price auctions are awesome auctions. And so how would you run a second price auction here? Let's say your block, you want to confirm four transactions, so you can take the top four. And in this case, they pay the fifth price, right? So this is kind of generalized version of second price auction. But the issue here is like, even the auctioneer itself can be a strategic player. For example. So here the auctioneer, obviously the miner, the miner can inject a bid which is five.
00:02:10.936 - 00:02:50.660, Speaker A: And now five becomes the fifth transaction, and everyone would be paying five, and the miner would be earning more. So the problem here is like, not only do you want a mechanism that incentivizes the users to behave honestly, you may also want to incentivize the miner to behave honestly as well. So interestingly, in this decentralized world, these classical mechanisms fail. The vast majority of classical mechanisms don't consider auctioneer as a strategic player. I think there are some works, including matt's work, like for instance, the credible auction. They consider auctioneer as a player. But there the model is completely different from this decentralized.
00:02:50.660 - 00:03:34.470, Speaker A: You know, there's a line of work that looked at transaction fee mechanism design. And all of these works, they kind of agree, okay, on essentially a set of digital router. So what is the dream transaction fee mechanism? So, as I said, first, we want to make sure the user's best strategy is just to behave to bid truthfully. And this notion agrees with the classical incentive compatibility notion in classical option theory. But now, in a decentralized world, we want a couple more properties. First, we want to make sure the miner's best strategy is just to play by the book. The miner doesn't want to deviate from the honest protocol and this is called Mic.
00:03:34.470 - 00:04:33.240, Speaker A: And secondly, in this decentralized environment we have this smart contract which allows miners and users to collude. So we also want the mechanism to provide side contract proofness. And specifically this notion can be parameterized by a parameter C and it means minor colluding with at most C users they should not have incentive to deviate. So let's say the coalition's goal is to maximize its own joint utility because they can use the smart contract, the side contract, to split off the gains in the background. Okay? So if your goal is to maximize your joint utility, you should not have incentive to deviate. Okay? So among these three properties, again, these last two properties are kind of new in this decentralized environment. And this is where decentralized mechanism design departs from classical.
00:04:33.240 - 00:05:30.008, Speaker A: Okay, so Tim started this line of work and he asked an interesting open question can we have a dream transaction fee mechanism that satisfies all of these three properties? So what's interesting is if you look at all the works out there, there is actually no mechanism. That is the dream mechanism we want. And the closest we have come to in terms of achieving all three properties is actually ethereum's EIP 1559. And this mechanism was rolled out like in August last year and Tim actually was invited to do an extensive analysis of the scheme. So most of this talk is actually not going to be concerned about 1559. But just for your curiosity here's briefly how the mechanism works. This is very high level.
00:05:30.008 - 00:06:15.450, Speaker A: So this mechanism has two modes of operation. When things are congested, meaning there are more transactions than the block can contain, then it kind of behaves like a first price auction, right? Just like bitcoin's auction. And we know that first price auction is not awesome. So when the block is unconjected, let's say the block, we have more block space than the number of bids, then the mechanism kind of acts like a posted price auction. So what's posted price? It just means there's a take it or leave it price. Any bid that's at least this posted price will get confirmed and they pay the posted price. However, what's interesting is all the payment is burned, the miner receives nothing.
00:06:15.450 - 00:06:54.550, Speaker A: And this burn rule is kind of interesting because it's a new element in blockchain mechanism design. And you might wonder, if everything's burned, why does the miner have incentive to mine? Because there's a fixed block reward. And even before like 1559, most of the reward is coming from the fixed block reward anyway. And because that's a constant, it doesn't matter to the game theoretic analysis. So in today's talk, I'm just going to ignore that. So what's interesting about this burn rule is like you might want to ask, does the burn rule actually introduce more expressive power in decentralized mechanism design. And I'll try to answer that later in the talk as well.
00:06:54.550 - 00:07:46.496, Speaker A: Okay, so what I want to say is, why is this the closest we have come to in terms of having a dream mechanism? So Tim actually proved that this mechanism satisfies all three properties in this uncongested regime, in the congested regime, things start to fall apart. But here is where we have this dream world. But this still leaves the question open, right? Suppose we actually have finite block size. So uncongested is kind of like infinite block size, and this is kind of like finite block size. So the question still remains open. If we have finite block size, can we have a dream mechanism? So let me first tell you our results and then I'll go into technical details, right? So first we prove an impossibility result, and basically the answer is no. Unfortunately, if you have finite block size, you cannot achieve all three properties.
00:07:46.496 - 00:08:37.780, Speaker A: And this seems to have a pessimistic outlook. So then we ask, is this the end of the world? And we actually introduced like a relaxed notion that can allow us to circumvent this impossibility. You'll see this later in the talk as well. So third, because blockchain decentralized mechanism design is very new, there are these new elements like the burn rule and maybe other new elements. We want to ask, do these new elements introduce more expressive power? And we also kind of try to mathematically answer such questions. So let's now dive into the technical part. I'm going to first try to define the formal model for transaction fee mechanism, and then I'll talk about our impossibility result, and then I'll talk about the relaxed notion.
00:08:37.780 - 00:09:17.948, Speaker A: Okay, so what's the model? We have a set of users and they each have a bid. So the bid reflects, let's say, how much I'm willing to pay for my transaction to be confirmed. And to have a transaction fee mechanism, first, you have to have an inclusion rule. The inclusion rule decides which of these bits to pick to include in the block, right? So the block is finite. You cannot include all of them. And this inclusion rule is implemented by the miner, and the miner himself is a strategic player. Okay? And second, we have confirmation and payment rule.
00:09:17.948 - 00:09:53.644, Speaker A: So in the most general case, so here I'm taking second price auction as an example. And as I said, second price auction is not great here, but it can still serve as a good example to show that it's not necessarily the case that every included transaction must be confirmed. Because in the most general form, in this case, if you want to implement a second price auction, the block size is six. So you include six transactions and the top five are confirmed and they pay the 6th price. So it's important that this price is actually included in the block because the blockchain needs to be able to tally how much balance each user has.
00:09:53.842 - 00:10:01.120, Speaker B: Is it important that the transaction, the five transactions in the block, or is it just like the number five that needs to be put in the block?
00:10:02.340 - 00:10:54.690, Speaker A: In our model it is important because if the number five, the Miner can just forge any number and there's no penalty, essentially. But if you actually force it to put in a transaction, like in the second part of my talk, I'll mention, even if you don't get confirmed right now, your transaction may get picked up in the future block and you may still have to pay that fee. So I think it does make a difference in this sense. So this part is actually implemented by the blockchain. So you can assume the confirmation rule and payment rule is implemented honestly, right? So basically this looks at the onchain state and decides who to confirm and how much each confirmed user pays. So we are always going to assume if you are not confirmed, you'll pay nothing, right? You don't have to pay. Okay.
00:10:54.690 - 00:11:33.752, Speaker A: Finally there's a minor revenue rule and this decides how much the Miner is earning. And we are going to impose this natural constraint. The minor revenue should be upper bounded by the total user payment. Okay? When the minor rule, let's say, is strictly smaller than the total user payment, that means there's some burning happening. You can burn part of the payment to all of the payment. Okay, so that's kind of the most general model. And in order for me to talk about the impossibility, we also have to just define the utility.
00:11:33.752 - 00:12:12.984, Speaker A: But this is defined in the most natural manner. So the user's utility, if its transaction is confirmed, is the true value minus the payment. If its transaction is not confirmed, your utility is zero. Obviously you also pay nothing, right? The minus utility is just the revenue it is making. Okay, so throughout the talk, I'm going to use these as the utility functions. So again, the statement I want to prove is that assuming the block size is finite, then no non trivial transaction fee mechanism can satisfy both UIC and one SCP. So UIC is user incentive compatibility.
00:12:12.984 - 00:13:00.792, Speaker A: One SCP means even if the Miner just colludes with a single user, if you want to satisfy both UIC and one SCP, then you have an impossibility. So notice that to get this impossibility, we don't even need Mic and this just makes the impossibility stronger. And we only need collusion with one user and this also makes impossibility stronger. Okay? So this theorem works both in the deterministic case and the randomized case. But for this talk, I'm going to focus on the deterministic case because the proof is a little simpler for the deterministic. So what I'm going to do to prove this theorem is I'm going to try to kind of understand what are the requirements being imposed by UIC and what are the requirements being imposed by one SCP. And I want to show that these requirements are inherently conflicting to each other.
00:13:00.792 - 00:13:55.336, Speaker A: So this is very high level, okay? So that's why we can start by understanding the requirements imposed by UIC. And this is actually well known because UIC agrees with the classical incentive compatibility notion in classical auction theory. And Roger Myerson, who won Nobel Prize, like he has a famous llama called Myerson llama. And this basically says that if a transaction fee mechanism is UIC, then the following must be true. So first, the inclusion confirmation rule must be monotone. What does this mean? It means, let's say if my bid is confirmed right now and I increase my bid and suppose the rest of the world doesn't change, then I should still be confirmed. And conversely, if currently I'm not confirmed and suppose the rest of the world doesn't change, and now if I lower my bid, I should still be unconfirmed.
00:13:55.336 - 00:14:53.800, Speaker A: So this is a kind of like natural notion, right? And secondly, once you fix the inclusion confirmation rule, then the payment rule becomes unique. So there is a unique payment rule, and what should the confirmed user be paying? Okay, so it should be paying the minimum price it could have bid and still remain confirmed. So the way to think about it is, let's say I'm confirmed right now, and what should I be paying? So you can imagine I'm lowering my bid little by little, and at some point I will hit a critical transition point. If I lower some more, I will suddenly become unconfirmed. And that critical transition point is exactly the price I should be paying. Okay, so if your mechanism satisfies UIC, then this must be true. So Myers and Diploma has another reverse direction, but we don't need the reverse direction, so I'm not going to talk about that.
00:14:53.800 - 00:15:51.212, Speaker A: Okay, so this imposes some strong requirements on the mechanism already, right? Okay, so we haven't used one SCP yet. And in order to prove this theorem, I'm going to first prove a key lemma. So the key lemma says that any mechanism that is UIC and one SCP must always have zero minor revenue. The minus revenue always has to be zero, means everything has to be burned. And this key llama actually holds no matter whether the block size is infinite or finite. Okay? So we are going to prove this key llama first, and then I'll tell you how to use this key llama to get the final impossibility when the block size is finite. So actually, this key llama is also interesting on its own because if you think about it, it kind of says in EIP 1559, the burn rule is necessary.
00:15:51.212 - 00:16:17.428, Speaker A: Like, remember 1559 burns everything. And Tim proved that when it's uncongested, it's the dream mechanism. It satisfies all three properties. And this is not an accident that they burn everything, right? So let's prove this key llama. I'm going to do a proof by contradiction. So suppose there is a transaction fee mechanism with positive minor revenue that satisfies both UIC and one SCP. So I want to reach a contradiction.
00:16:17.428 - 00:16:55.248, Speaker A: So how do I do that? So first we are assuming this mechanism has positive minor revenue. Somewhere there has to exist a bit configuration under which the Miner's revenue is positive. And let's assume that bit configuration is b one to BN. Okay? So now let's do a thought experiment. We will start from user one and we will lower each user's bid to zero, one by one. So I want to argue, as you lower a user's bid to zero, the minor revenue should not change. So if I can prove that, then it's sufficient for proving this lamma.
00:16:55.248 - 00:17:35.040, Speaker A: Because at the end of the day, we just lower everyone's bid to zero and the minor's revenue is the same, right? But when everyone's bid is zero, the only possible minor revenue is zero because the minor revenue cannot exceed the total payment. So essentially, I just have to show, take user one as an example. When I lower user one speed to zero, I want to show minor revenue doesn't change. And that's sufficient. So throughout the proof, I'm going to assume the rest of the world doesn't change. Okay? So there are two cases I care about. Case one is when I start this first user's bid is not confirmed.
00:17:35.040 - 00:18:10.750, Speaker A: Okay? So what happens when that user lowers his or her bid to zero? So I have to prove two directions. One is that the minor revenue should not decrease, and the other is the minor revenue should not increase. So let's do one direction because the other direction is the metric. So I want to prove the minor revenue doesn't decrease. And to prove that, I have to use Myers and Slamma. But I also have to use this extra requirement one SCP. Okay, so suppose it's not the case the minor revenue decreases by delta when I lower this B one to zero.
00:18:10.750 - 00:18:50.324, Speaker A: So what happens then? I claim that there is a way for user one to collude with the Miner and such that the coalition can benefit from this collusion. One thing to observe here is that because user one is unconfirmed anyway, right? It's unconfirmed in the beginning and by Myers and Slammer, if I lower my bid, I'm still unconfirmed. So the user is actually just indifferent to biding zero, b one or zero. Its utility is always one. So imagine a scenario where the user's true value is zero. So my true value is zero. And now I'm colluding with the minor.
00:18:50.324 - 00:19:23.590, Speaker A: What should I bid? Should I bid zero or b one? And if you think about it, in this case I should bid B one, right? Because bidding b one doesn't hurt me, but it helps the minor by delta. So jointly the coalition is benefiting. So therefore, by the requirements of one SCP, we rule out the possibility that the miner's utility decreases by delta. So which means the miner's revenue cannot decrease in this process. And similarly, we can prove that the miner's revenue cannot increase. And the argument here is symmetric. So I'm not going to do it again.
00:19:23.590 - 00:19:49.752, Speaker A: So that's case one, and that's kind of the easier case. And case two is slightly more complicated. So in case two, we start in a scenario where b one is confirmed. If you bid b one, you are confirmed. And now you are lowering from b one to zero. So I also want to argue here that the minor revenue is unaffected. So to prove this is a little bit more complicated, again, I have to prove that the minor revenue does not decrease and it doesn't increase.
00:19:49.752 - 00:20:20.896, Speaker A: So I'm going to pick one direction, which is I want to show it doesn't decrease and the other direction is a little easier. Okay? So to prove this, I'm going to do it in three steps. First, I will lower from b one to p one. So p one is the price I'm paying if I'm bidding b one. This is the payment price when you bid b one. And next I'm going to lower it from p one to p one minus an arbitrarily small epsilon. So this is a critical point because in this region I'm confirmed.
00:20:20.896 - 00:21:04.736, Speaker A: And when I lower from p one to p one minus epsilon, I suddenly become unconfirmed. And then when I lower from p one minus epsilon to zero, I'm just always unconfirmed. Okay? So I want to show in these three regions, the minor revenue is unaffected. Okay? So the top region, it's kind of similar to the proof we have seen for case one. I can just do it again very quickly. So suppose for the sake of contradiction that the minor revenue does decrease by delta in this process. So what will happen in this case? Again, the user is indifferent to biding either b one or p one, because no matter what you bid, you are confirmed and you are paying p one by Myers and Slammer.
00:21:04.736 - 00:21:48.448, Speaker A: So if imagine a scenario where the user's true value is actually p one. Now the user is colluding with the minor, what should the user bid? Should it bid b one or p one? If it bid truthfully, it should bid p one. But actually it's better off if it bids untruthfully, which is b one, right? Because bidding b one is helping the minor buy delta. But I myself, I remain indifferent. Okay? So this means the user colluding with the minor can benefit from this coalition, and therefore it cannot be the case that the minor revenue is actually decreasing. Okay, so the top region is easy. The bottom region actually is just the same as case one, right? Because here the decision is unchanged.
00:21:48.448 - 00:22:24.472, Speaker A: I'm always unconfirmed anyway. So what's most interesting is actually this middle region. When you lower from p one to p one minus arbitrarily small deltas. What's interesting here is like, I suddenly become unconfirmed. So how do we reason about this case? So suppose for the sake of contradiction, and the Miner's revenue decreases by delta in this region, right? In some sense, if there is any change between B one to zero, all the change must be concentrated in this tiny region. Imagine if the user's true value is p one minus epsilon. So if it bids truthfully, it would be biding P one minus epsilon.
00:22:24.472 - 00:22:59.604, Speaker A: But I argue that it's better off for the user to bid P one if it is colluding with the minor. And why is this the case? So imagine if the user is bidding P one in this case, it will get confirmed and it will end up paying P one. But its true value is p one minus epsilon. So this means the user's utility is minus epsilon, right? It's negative epsilon. So it's hurting me a little bit by bidding higher than my true value. But it's helping the minor a lot more. The Miner gets delta more revenue, and because we can make epsilon arbitrarily small, we can make it smaller than delta.
00:22:59.604 - 00:23:38.356, Speaker A: So this action is hurting me a little bit, but it's helping the Miner a lot more. And so together we benefit. And therefore, by the requirements of one SDP, it cannot be the case that the Miner's revenue is decreasing in this middle region as well. And similarly, actually, you can prove that in this middle region the Miner's revenue should not increase two. But here it's actually easier because we can just imagine if the user's true value is P one, then actually it should bid P one minus epsilon, because if it's bidding P one, my utility is zero. I get confirmed, I pay P one. My true value is P one, so I'm getting zero out of it.
00:23:38.356 - 00:24:05.216, Speaker A: If I'm biding P one minus epsilon, I'm not confirmed, I'm getting zero out of it. So I'm indifferent to this. But the minor prefers if I bid P one minus epsilon. So this is an easier case. Okay, so that's the proof. We have looked at both cases, and what I have shown is if you take any user's bid lower the bid to zero, the Miner's revenue is unaffected. So you can just lower every user's bid to zero.
00:24:05.216 - 00:24:14.096, Speaker A: And you can conclude then that if a transaction fee mechanism is UIC and one SCP, then the minor revenue should be zero.
00:24:14.278 - 00:24:22.324, Speaker B: Does this depend on there being like a discretized or non discretized real number for the bids? I just noticed that in one step.
00:24:22.442 - 00:24:24.708, Speaker A: You said that we are assuming it's real.
00:24:24.874 - 00:24:25.636, Speaker B: Okay.
00:24:25.818 - 00:24:34.328, Speaker A: Because I guess here I'm making the assumption this epsilon is arbitrarily small, it can be made smaller than delta. Seems like there was one of the.
00:24:34.334 - 00:24:36.168, Speaker B: Previous steps that seems like it might.
00:24:36.254 - 00:24:56.056, Speaker A: Sorry, I think this is the step where I'm using real number because for any delta, that's a positive number. I always want to find an epsilon smaller than delta. So if there's a minimal currency unit, let's say delta equal to one satoshi or one way, then you may not be able to find epsilon smaller than delta.
00:24:56.248 - 00:25:01.600, Speaker B: You said something else in an earlier thing, maybe it was just recapping the Myers dilemma and how it applied.
00:25:02.020 - 00:25:06.450, Speaker A: Oh yeah, Myers dilemma, that's right, myers dilemma assumes it's real as well.
00:25:07.220 - 00:25:19.990, Speaker B: It seems like it was the other way around because it said that you can always make it, that there's a unique minimum payment smallest, like you make the bid the smallest one above, but there isn't necessarily the smallest one.
00:25:21.400 - 00:25:54.176, Speaker A: Yeah, that's assuming it's real. Maris and Lemmer, you just lower lower until you hit the critical point where you suddenly become unconfirmed. Actually, I don't know if there's a discrete version for Marathon Lamar, but that's actually an interesting question because my student and I, we actually at some point we were discussing what's the implication if it's discrete, there is a discrete version of Mars. Yeah, I'm just saying like for in general, anything above one gets accepted and.
00:25:54.198 - 00:25:59.330, Speaker B: One or below gets rejected. Then there is no smallest bid above one.
00:25:59.860 - 00:26:01.136, Speaker A: Yeah, I guess we were one get.
00:26:01.158 - 00:26:05.750, Speaker B: Stuck on unless it specifically requires also not that for later.
00:26:06.280 - 00:26:48.816, Speaker A: Yeah, somehow intuitively, if it's discrete, maybe it's similar to epsilon IC or something, because this one, we didn't understand it, we were discussing it, but maybe it kind of dropped at some point. But this is an interesting question. Okay, so this is the key llama we have proven and we just have to get from this key llama to the final theorem. So so far we haven't used finite block size yet. This key llama holds no matter what the block size is. So to prove the final theorem, we are going to throw in the finite block size assumption. So this key llama imposes a very strong requirement on the structure of the mechanism.
00:26:48.816 - 00:27:30.720, Speaker A: And now let's look at what happens when the block size has to be finite. So again, proof by contradiction, suppose that there is a non trivial transaction fee mechanism that satisfies both UIC and one SCP. Moreover, it works for finite block size. Okay, so what contradiction can we reach? So because the transaction fee mechanism is non trivial, right, there must be a bit vector and under this bit configuration some bit is confirmed. So let's say BJ is confirmed. So now imagine a different world. Now the world consists of B, one to BN, but also with many other bits who are bidding BJ plus epsilon.
00:27:30.720 - 00:28:10.764, Speaker A: But there are so many of these bits such that the total number is bigger than the block size. So you cannot possibly fit all of them in the block size. Which means if the world is like this, then some person from here must be unlucky and not included. So let's call that unlucky person U because U is one of these players bidding BJ plus epsilon. Okay, so now I argue actually, sorry, I argue this unlucky person U is better off if it colludes with the minor and the coalition can gain, right? Because the minor is just indifferent. Remember, because of the key llama, the minor revenue is always zero. So the minor doesn't care.
00:28:10.764 - 00:28:51.992, Speaker A: So now let's see if the minor can help this user U. Okay? U will collude with the minor and it will bid BJ instead of BJ plus epsilon, right? So this is under bidding and the minor will pretend that the world contains B one to BN and it will replace BJ with this user use bid. So now it runs the honest mechanism on this bid configuration and in this case, actually U will be confirmed, right? Because that's our assumption. So now the user U is getting epsilon value out of it. And again, the minor is indifferent because minor revenue is always zero. So therefore we reach the impossibility. So that's the proof in our paper.
00:28:51.992 - 00:29:48.636, Speaker A: We also extend the proof to randomized transaction fee mechanisms, but the proof is more technical. So I won't go into details in this talk. You can read the paper if you are interested. And then for the rest of the talk, I just want to spend some time discussing something more philosophical. Like I want to talk about how do we interpret this impossibility? Is this like the end of the world? So I'll talk about some relaxed notion like I don't know if this is the final answer we want, but I think it's like a meaningful first step. Okay, so one observation we had is like in the previous modeling, if you cheat, then so let's say you inject a fake transaction, are you bid higher than your true value? Because we are focusing on a single instance of the auction, we're not looking at the future. So if your transaction currently is not confirmed, you are paying nothing and therefore your cost of cheating is zero.
00:29:48.636 - 00:30:21.656, Speaker A: So this is what the previous model assume. But actually, if you think about it, if you inject a fake transaction or if you overbid and you are not confirmed in the present block, that doesn't mean our transaction will disappear like it's posted onto the public network, right? So it can be picked up later by a future block and it may get confirmed in this future block. So you may end up having to pay something in the future by making this advance. Yes.
00:30:21.758 - 00:30:28.090, Speaker C: So why wouldn't the miner just wait to broadcast that transaction only if they were chosen to build?
00:30:28.860 - 00:30:46.064, Speaker A: Well, sometimes, let's say, if you have some transaction in the block that sets the price, the miner cannot withhold it. I'm only going to review it if it helps me. You actually have to put it in the block and that transaction is there to set the price. And that decides how much the miner gets.
00:30:46.262 - 00:30:51.744, Speaker C: Couldn't they just only put it in the block if they win the block? And if they don't win the block, then not broadcast it?
00:30:51.782 - 00:31:20.088, Speaker A: Well, yes, but that transaction may be revealed, but that transaction, it's not everything included in the block is confirmed, right? So in the second price option example, you include a bunch of transactions and the last one is not confirmed. The last one is just there to set the price. So it could be like one of these, you actually have to disclose it to gain in the present, but by disclosing it, you may lose something in the future.
00:31:20.254 - 00:31:30.296, Speaker B: Yes, it seems kind of unintuitive to have a transaction in the block, but that it's not confirmed. What happens? Does the transaction automatically get confirmed in the next block?
00:31:30.328 - 00:31:34.332, Speaker A: Or like someone actually has to because.
00:31:34.466 - 00:31:38.076, Speaker B: It'S already incurred the cost of being propagated?
00:31:38.188 - 00:32:37.452, Speaker A: So we are actually not the first one to suggest this. I think there was some paper by Aviv Zoha and others, they also use this. It's not a new technique, actually, I don't know that any mechanism works like this in real world, but I think in the academic community it has been considered for a pretty long time. But you'll also see, actually, after I introduce this notion, even for this weaker notion, I can show, I can prove that it is critical to allow unconfirmed transaction in the block to have any possibility. If you don't have this, then it's still impossible. So the current modeling fails to capture this cost. And now the question is, okay, obviously if we somehow account for this cost, maybe we can circumvent this impossibility, right? But actually doing this is pretty hard because it's very hard for me to characterize how much you'll end up paying in the future, because this depends on the environment, it depends on what other people are bidding.
00:32:37.452 - 00:33:25.264, Speaker A: It also depends on the mechanism itself. So what do we do there? We don't just want to give up because it's hard to characterize the cost. So we start asking ourselves, okay, first, what is the worst case cost that can happen to you if you are the offender? What is the worst case cost you can incur? Should you inject a fake transaction or overbid? So the worst case cost is when I end up paying the full bid sometime in the future. And the cost in that case would be the bid minus my true value, right? So if it's overbid transaction, it's bid minus true value. If it's a fake transaction, the true value is zero. So the cost is just the bid itself. So I mean, of course, in practice, you may not be so unlucky like you may not be incurring the worst case cost because it also depends on what the mechanism is.
00:33:25.264 - 00:34:01.276, Speaker A: It depends on what other people are bidding. Okay? So in our model, we actually allow some parameter let's say I have some kind of discount factor gamma. And you can also view like gamma as a resilience knob. Okay? So imagine I will end up in expectation paying gamma times this worst case cost. So gamma is between zero and one. You can see if gamma is equal to one, then this is the same as the worst case. If gamma is equal to zero, it's the old model where you have no cost for this.
00:34:01.276 - 00:34:29.972, Speaker A: So when gamma is equal to zero, you should still suffer from the previous impossibility. So in practice, I guess one question, this is called the discount factor. In practice it may not be clear how to set the gamma. Like you can potentially look at the history, use history to figure out exactly how gamma might be, what range it might be. But you can also think of it as a knob. Like if you, you can always set it to be one, but maybe you end up with somewhat more. You can always set it to be zero.
00:34:29.972 - 00:35:10.500, Speaker A: Zero is like no cost. So it's the best case for the offender and the worst case for the mechanism designer if it's one. It's like the most relaxed notion, most relaxed incentive compatibility notion because it's like the worst case for the offender, the best case for the mechanism designer. So it's kind of like a knob that lets you tune the resilience of the mechanism. Okay, so under this model we actually have some feasibility result. We call it the burning second price option. And I will talk about a special case in this talk and I'll hint what the more general case is.
00:35:10.500 - 00:35:56.528, Speaker A: So the special case is when gamma equal to one, essentially you're incurring the worst case cost. And let's say we want to defend against collusion with only a single user. Okay? So in this case here's one mechanism that works. It's kind of cute, I guess. So what happens here? Suppose our block size is six, so we include the top six transactions in the block, but not all of them are confirmed, only the first three are confirmed and these confirmed transactions are paying the fourth price. So from the user's perspective, it's a second price auction, right? So that's why it's UIC. So now the question is what is the miner earning? So all of these people, they're included but not confirmed, so they don't have to pay anything.
00:35:56.528 - 00:36:11.960, Speaker A: So the miner is not getting the full payment, it's only getting eight plus six plus five. And this part of the revenue is coming out of this user's payment. Just don't be confused. Then the rest of the payment is just burnt.
00:36:14.300 - 00:36:17.544, Speaker B: I assume all of the confirmed ones pay the same thing.
00:36:17.662 - 00:36:19.050, Speaker A: Yeah, they all pay eight.
00:36:23.260 - 00:36:26.312, Speaker B: So they're going to pay total 24 and minor will get 19.
00:36:26.376 - 00:36:56.676, Speaker A: Yeah, they pay total 24, the minor gets 19. So five is burned. Yeah. So intuitively, why does this work? I can give you a quick intuition. This is not a formal proof. So imagine Matt is colluding with the miner and Matt wants to overbid. So Matt is raising the bid from eight to nine because this makes the minor earn one.
00:36:56.676 - 00:37:35.680, Speaker A: More like the miner is making the sum of these numbers. However, this action is not cost free for Matt in the worst case, because we're assuming gamma equal to one in the worst case, Matt may end up paying nine in the future, so will cost Matt one and then now the plus and the minus they cancel out. So the coalition is just basically indifferent in the sense. Okay, so this is not a formal proof. If you want to do a formal proof, you have to analyze all cases and that's what we do in the paper. So I'm not going to do that here. Okay, so this is coming back to Andrew's question, like should we allow the blocks to contain unconfirmed transactions? I guess there's a debate.
00:37:35.680 - 00:37:37.650, Speaker A: Yes.
00:37:38.580 - 00:37:42.816, Speaker B: Is it easy to explain how the mechanism changes as a function of C and gamma?
00:37:42.928 - 00:38:31.830, Speaker A: Yes. So let's first fix C equal to one and just imagine gamma is 0.5. So in this case the miner would be getting 0.5 times the revenue in this auction and you would be selecting gamma times. Let's call this parameter k. You are confirming the first k and then the next k prime are used to set the minor revenue. So in this case you just randomly sample actually gamma fraction of the top k and those you are sampling k times gamma users to be confirmed from the first k.
00:38:31.830 - 00:38:58.040, Speaker A: So this is what happens when you change gamma but C is still equal to one. But now if C is not equal to one, then you are actually sampling gamma times k over C at random. To confirm, the mechanism explicitly needs to know gamma and C. Yeah. So you need to know what resilience you aim to achieve and then depending on the resilience you want to achieve, you can choose the mechanism.
00:38:58.120 - 00:39:08.640, Speaker C: So if I choose gamma equals 0.5, it's like I see for gamma equals 0.5 to one exact value of gamma.
00:39:10.500 - 00:39:24.932, Speaker A: Gamma the smaller the gamma, the stronger the notion. Right, so you are right, if it's zero five, then it implies it's like between 5.5.5 is strictly better than one. Yes.
00:39:24.986 - 00:39:54.864, Speaker C: Matt, a question about the model. So the idea is that just by submitting a transaction with a fee of eight, I may lose eight. And the point is that the mechanism you described by which I might lose eight would be it's really a fake bid, but my transaction is confirmed later and then I have to pay eight for this thing I didn't even want.
00:39:54.902 - 00:39:55.970, Speaker A: In the first place.
00:39:56.900 - 00:40:19.880, Speaker C: If I have say like but if that's a genuine, if I really have value for then is what you're saying that sort of like I should really I don't know that gamma equals one is really describing sort of like this very special case that you're really talking about. Big bid.
00:40:21.820 - 00:40:43.310, Speaker A: Not really. Actually, I guess if let's say it's over bid transaction, then the cost is the bid minus the true value. I cannot swipe there. If your true value is eight and you bid nine, in the worst case you have negative one utility because in the worst case you end up paying nine.
00:40:44.320 - 00:40:51.152, Speaker C: I think I'm still confused. So you're saying that the worst thing that might happen to me is that my transaction gets confirmed later.
00:40:51.286 - 00:40:55.424, Speaker A: Yeah. You pay nine and suppose your true value is eight, yours is negative one.
00:40:55.462 - 00:40:58.736, Speaker C: So if the worst thing that's going to happen to me is that I.
00:40:58.758 - 00:41:01.856, Speaker A: Get confirmed later in my bid yeah, that's the worst.
00:41:01.968 - 00:41:22.710, Speaker C: Okay, but you can't confirm it. Okay. You can't confirm it now because if you confirm it now, then there's a first price auction and then it's not truthful. Okay, I understand that. So the worst thing that can happen is that somehow later there's some kind of auction, I wind up paying my bid and that's why.
00:41:25.000 - 00:42:19.290, Speaker A: Yeah, I mean, if it's confirmed now, the cost is already accounted for. We are just fixing this part. Like if you are unconfirmed, the previous model doesn't account for any cost. Is it fair to say that we introduced some honest users out there who can't potentially can because they were to congest the situation? There is some exchange with good trade going on and everyone is trying to do a trade, but it's only valuable now. But if they get unlucky and end up yeah, I guess this is because at least in some cryptocurrencies like Bitcoin, once you post the transaction, you cannot retract it, everyone can see it and the miner later can always just take it and confirm it. It's not like I can tell people, oh, I don't want this transaction. Right.
00:42:19.290 - 00:42:47.684, Speaker A: Also for the special case, like when gamma equal to one, where it's worst case cost, you can also think of the notion as like, I want to defend against paranoid players. Like paranoid players, they only want to deviate if they can surely win. But I mean, in practice, you don't have to have a really accurate estimate of gamma because this is kind of like you can view it as a knob. So it doesn't have to be oh, I have to set it precisely. Yeah, sorry, I asked another question.
00:42:47.722 - 00:43:10.844, Speaker C: So in some sense you can say the thought experiment I should really go through is once I post this transaction with a D of nine, at some point in the future I may be included in a block. If I'm using this auction, I maybe have some prior over what the expected price I wind up paying when I'm included in a block is. And that kind of parameterizes how bad.
00:43:10.882 - 00:43:47.420, Speaker A: It is for me to that's right, yeah. That's right. Also, back to Tim's question. For instance, in this mechanism I mentioned, let's say when gamma is not equal to one, you're sampling gamma fraction of the top K users to confirm. So if gamma is equal to zero, you're just sampling zero users. So this agrees with the previous impossibility result because the mechanism just degenerates to something trivial when gamma is equal to one, is equal to zero. So this is Andrew's question, like should we allow the blocks to contain unconfirmed transactions? So there's a debate.
00:43:47.420 - 00:44:37.460, Speaker A: I remember at EC last year there was a debate in Tim's poster session and this is how I learned about this question. Matt was also there. I think Matt raised this question like do you have to allow unconfirmed transactions in the block? Even with this new utility function, this weaker incentive compatibility notion, we show that if you do not allow unconfirmed transactions in the block, it's still impossible. So I won't go into the proof, but at least in this case it matters. Okay? So as I said in the paper, we generalize this to general choices of gamma and C. So what's interesting also, as I mentioned earlier, I'm randomly sampling a subset of the top K users to confirm it's. Like gamma times k over C users.
00:44:37.460 - 00:45:30.200, Speaker A: Which means, except for this case, in this special case, it's deterministic because I'm just selecting the top k. But any other case, when gamma is not equal to one or C is not equal to one, it actually becomes randomized, the mechanism. So one question we ask is like, is this randomization necessary? And it turns out that indeed it is necessary. Like if you want the transaction fee mechanism to satisfy to be kind of useful, unless you consider really degenerate ones where only one user is confirmed or something, then the random coins are actually necessary. So this lower bound is quite sophisticated to prove. So I won't go into the details here. Okay, just to summarize, so I find the space technically fascinating, partly because the vast majority of classical mechanisms just fail in the decentralized environment.
00:45:30.200 - 00:46:16.288, Speaker A: So I guess our work takes a step forward in understanding transaction fee mechanism. But I don't think this is closed. I think this is basically widely open space, lots of exciting open questions. Our paper contains detailed proofs and again, there are so many exciting questions. Like, for instance, how can we model this repeated nature in this transaction fee auction? Right now we are considering still a single instance. How can we model the long scale strategies? Can we consider other relaxed notions of incentive compatibility to circumvent the lower bound? How can crypto help? Okay, and before I end, I also want to advertise one new work. It's called ponita.
00:46:16.288 - 00:46:48.460, Speaker A: And in this work we try to design a side contract resilient fair exchange protocol. So fair exchange is used everywhere, like in atomic swaps, in payment channel, in contingent payment, in DeFi so on and so forth. And all the previous designs they consider only Alice and Bob as the players. And the Miner is not a player. So the Miner is assumed to be honest. So we basically start asking and this is actually one question the community really cares about because of mev miner extractable value. So what happens if the Miner is also a player? Like in particular the Miner can collude with one of the users.
00:46:48.460 - 00:47:35.052, Speaker A: So we design new protocols that provides resilience in this world with possible side contracts between Miner and user. And what's most cool about our work is the name Ponita. So Ponita is a fire type Pokemon and in our mechanism sometimes if you behave dishonestly, sometimes your collateral can get burned. So this is a way to incentivize you to behave honestly. So Ponita is a fire type Pokemon and it has special power. It can control its flames, so it can protect its rider from getting burned. So because our contract is incentive compatible, it will protect the players collateral, everyone will be incentivized to behave honestly and it will protect the players collateral from being burned.
00:47:35.052 - 00:48:29.024, Speaker A: Thank you. Just out of curiosity maybe can you elaborate on the question how crypto can help? Yeah, actually this is something we are thinking about right now. And what's interesting is like I think about 20 years ago there's a line of work that tries to connect crypto and game theory. But I guess these were kind of more theoretical nature. Like the modeling is not a great match for today's blockchain type scenarios. So I think in general this is a good time to rethink about this question. This question came from Andrew actually.
00:48:29.024 - 00:49:22.480, Speaker A: So Andrew when we were working together we had this question about doing lottery like leader election protocols on blockchain. And all of these earlier protocols they require people to put in collateral. And actually I think the earliest people actually won the Oakland Best Paper award in 2014 and then it spun like a line of work that tried to reduce the collateral. And then Andrew and Edo Bentov observed that okay, there's this classical tournament tree protocol, you can do this without any collateral at all. So we actually had some after that we had some new results. Like we proved some lower bound like log n rounds is necessary in some model and then we prove like if you are willing to relax the security notion to epsilon incentive compatibility, you can beat the log n lower bound. Like maybe have log log n rounds or maybe even log star rounds in some setting.
00:49:22.480 - 00:50:03.120, Speaker A: I have a paper actually in the upcoming Crypto in August. I mean there was also like did I have like a sequence of papers on this topic? Like there are also different variations of the problem that is the leader election and there's also like coin toss in general. So this is another I think in general like for instance, the question of how do you design these incentive compatible protocols with small collateral? Minimize collateral is like in general, very interesting question and there oftentimes you have to use crypto to help. And I think this is a good example where crypto actually helps because if you don't have crypto, there's lots of impossibility results.
00:50:07.620 - 00:50:46.910, Speaker B: Trying to work out why my intuition that including unconfirmed transactions is odd. Is there an assumption? Part of where this comes from is that I think of the finite block size is a model approximation. The reality is that the computers on the network have limited resources in broadcasting transactions and relaying them, checking them all takes time. If you've already included that transaction in the block, even if you're calling it not confirmed, it's already been relayed so that doesn't cost later. It's already been validated so that doesn't cost later. Do you have an assumption that all of the transactions are exactly the same size?
00:50:48.320 - 00:50:57.680, Speaker A: I guess if you're asking, one trivial thing you can do is later when you actually confirm it, you can just start a pointer to the previous occurrence on the blockchain, right? So that can minimize the state.
00:50:57.750 - 00:51:15.476, Speaker B: Would it then be cheaper to would it cost you less to then get that transaction confirmed later? Because then it's like you've made some progress. Like my transaction didn't get confirmed in this block. But then I would get a side benefit that later on when I go to get it confirmed for real, you've already done all of this work, so it's cheaper now.
00:51:15.498 - 00:51:29.370, Speaker A: But then that would I guess you are asking should we design mechanism that makes it cheaper if it's already there to confirm it? That I don't know. I think that's a very good question because we don't have anything to reason about this repeated nature yet.
00:51:30.220 - 00:51:48.028, Speaker B: And I wonder if maybe the answer is that it really is necessary to waste a resource and you can't give the user a benefit that would spoil the incentives. So you have to make them go through the whole process of relaying the entire transaction again from scratch, do everything that would cost them, even cost the whole network this extra redundancy.
00:51:48.124 - 00:52:19.000, Speaker A: Maybe that isn't but I guess if it's already on the chain and not confirmed, the user doesn't have to broadcast it, right? You can just assume anything on the chain unconfirmed, it's already in the ManPool. That you can assumption you can easily make. But the question is in the mechanism design. Yeah, in the mechanism design, should you make the payment lower for that user? That I don't know. That I think is like maybe we'll need to consider the repeated nature and consider longer scale strategies.
00:52:20.300 - 00:52:28.030, Speaker B: The other part of that I think it's related, but it's different. Are these results sensitive to all transactions being the same size?
00:52:28.560 - 00:52:55.012, Speaker A: Yes, that's what you were asking earlier. Yes, we do assume they have the same size. So this doesn't actually apply to the gas model of ethereum. So that's also so very interesting. The lower bound okay, maybe I should put it the lower bound holds for ethereum too, but the upper bound doesn't hold. We'll have a lower bound when they're all the same size.
00:52:55.066 - 00:52:55.236, Speaker C: Right.
00:52:55.258 - 00:53:00.370, Speaker A: So the lower bound holds, but upper bound doesn't. Okay, great. Sounds good. Thank you.
