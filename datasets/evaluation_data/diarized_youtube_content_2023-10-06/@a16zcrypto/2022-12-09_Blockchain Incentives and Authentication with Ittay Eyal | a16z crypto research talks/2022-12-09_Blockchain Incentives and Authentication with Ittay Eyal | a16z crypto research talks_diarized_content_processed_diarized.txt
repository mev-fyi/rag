00:00:09.050 - 00:00:21.280, Speaker A: Very happy to introduce tya Professor Techno, who's been in the space for a very long time, despite the fact he's still quite young. Blockchain incentives and authentication is what he's going to talk about today.
00:00:21.970 - 00:01:12.110, Speaker B: Thanks very much. So yeah, like the title hints. I would like to talk about both incentives and authentication here. Before I start, just a few words about the group back at Technion. So we're focusing mainly on three key points for the blockchain world. First of all, security with incentives, this is the way you get security in a decentralized systems. So we work on selfish mining analysis on incentives, how incentives can be used to attack the system, how incentives can be used across layers to secure applications using the miners themselves, and about designing more resilient incentive.
00:01:12.110 - 00:01:48.410, Speaker B: Incentives systems resilient more resilient with incentives. Second topic is performance. And take care of higher bandwidth, some L2 protocols, vertical sharding. If you want to improve blockchain performance with horizontal sharding, please talk to me. And getting deterministic safety, that's a recent result that will be shown in podcast this year. And the third topic is client side security. We had work about vaults at the time and how to design your cryptocurrency wallets.
00:01:48.410 - 00:02:34.666, Speaker B: These are three, I think, key challenges for the blockchain world and a lot of the solutions you see and what we are trying to avoid is making this more centralized. So we want to achieve all this in a decentralized fashion and continuing the discussion from lunch. Sometimes this means relying on proof of work rather than other mechanisms. So another angle that I'm particularly interested in is using the features of proof of work, but in a more climate friendly way. Unfortunately, I won't have time to talk about anything right here. I'll be glad to talk about this later. I'm going to be a little bit ambitious though and really try to talk about two things.
00:02:34.666 - 00:03:12.658, Speaker B: One is a new resilient protocol with better security against rational participants. And the second is wallet design, which is something very new. And I think there is a lot of room for discussion and research here. So I'm going to start with this one. So more broadly, this is about authentication. But we'll focus today here specifically on authentication for blockchain cryptocurrencies. All the range from decentralized cryptocurrencies all the way to central bank digital currencies.
00:03:12.658 - 00:03:58.450, Speaker B: In all the cases, if you want to secure your digital assets, then this becomes relevant. So this is for individuals storing small amounts for companies, smalling, large amounts for asset management companies that store clients, amounts relevant for everyone, really. Again, for any authentication context, if you're a large tech company with users who log in, that's relevant as well. But we'll focus on cryptocurrencies. So in the cryptocurrency world, the scenario is essentially this. You have some blockchain, the users send orders in the form of transactions and then they can send more orders and move the money around. The key is that there is no central party.
00:03:58.450 - 00:04:42.274, Speaker B: So if something happens to your funds and you cannot access them, you cannot go to your credit card company or your bank and say this transaction was faulty. So the problem becomes much more crucial and much harder to solve. Interestingly, the users in these systems, they choose their own authentication methods. So they design some smart contract, they put it on the blockchain, everyone can see it. And then the users tell whoever they want to get money from, please send the money to this smart contract and then they can later get the money somewhere else by authenticating to that smart contract. So it's all very visible. We'll call this contract that holds the money a wallet.
00:04:42.274 - 00:05:11.070, Speaker B: Doesn't matter if it's an elaborate ethereum thing or just two out of three signature in Bitcoin, right? That's a wallet. I said this already. Both the orders and the smart contracts themselves are visible. The authentication is typically not always, but typically done with cryptographic signatures. And so we will call the secrets maintained by the users the keys. The users have keys. These are essentially credentials.
00:05:11.070 - 00:06:08.382, Speaker B: Now, there's been a lot of work on client side security. There was Joe's paper from the time about alternatives to passwords, quite a big variety in the context of cryptocurrencies. This was listed among the chief problems for usage of cryptocurrencies, how to secure clients'funds, both because they might be lost or hacked sorry, both because they might be hacked and stolen, but also if they're lost. There are techniques to maintain keys locally and remotely with encrypting or not encrypting or even using physical hardware. So the secret keys never actually hit a connected machine. And ways to implement K out of N wallet. So you need to use three out of five wallets or whatever.
00:06:08.382 - 00:06:57.642, Speaker B: This has all been discussed and the techniques for these are well established. Now, secret sharing can also be used so we can split our secret among different machines, including with threshold cryptography. So the keys never actually reach ever a single point. One last thing that's kind of related is authorization policies. This is work from back in the end of the 90s. This is about authorization, not really authentication, about how, for example, a large organization can express the fact that certain parties, certain managers for example, can be allowed to provide certain orders and others cannot. This work was mostly about how to define formally these policies.
00:06:57.642 - 00:07:43.514, Speaker B: So not exactly related to what I have here, but this is the closest I found. So some examples that we know. Password is a form of credential, a physical device protected by a pin, some paper hidden in a vault in Zurich and K out of N padlocks. These are all examples of this type of authentication. Now, in order to everything here, I think everybody knows this is our life, but how to model this is what I'd like to talk about. So here's the model. It starts simple and gradually becomes more complicated.
00:07:43.514 - 00:08:14.294, Speaker B: So bear with me. We'll have two principles, an owner and an attacker. These are the only two principles we care about, apart from the authenticator. The wallet defines the authentication scheme and the owner authenticates using those keys. And the attacker is trying to authenticate instead of the owner. Now, each key can be in four different states. It can be safe, meaning only the owner has it.
00:08:14.294 - 00:08:34.190, Speaker B: It can be lost, meaning no one has it. It can be leaked, meaning the owner has it and the attacker has it. Or it can be stolen. That's the event of theft. And then the attacker has the key and the owner does not have the key. So far, so good. This translates to our example.
00:08:34.190 - 00:09:15.354, Speaker B: So a password lost, maybe because it was forgotten, or it is leaked, maybe because someone guessed it. There are other ways for it to be leaked, but that's an example for the physical key. For loss, it's enough to forget the Pin or to actually lose the physical device. But remember the Pin. For theft, the attacker would need to both steal the device and figure out the Pin. I'm going to just call both of these theft the combination of these two events, this is theft from the authenticator's point of view for a safe deposit box in Zurich. Unbelievable scenario, of course.
00:09:15.354 - 00:09:53.750, Speaker B: But if all global transportation stopped and you're not able to reach Switzerland when you need to, that's equivalent to loss in the case of a safe. And finally, threshold schemes, even if on the client side, this is a threshold crypto. We're going to call each piece hidden, a separate key. Okay, going on with our model. So we have keys. We numerate them one through N, and each key has a state. It is either safe, lost, leaked or stolen.
00:09:53.750 - 00:10:46.166, Speaker B: Now, together we have a scenario. A scenario is a vector of the states of the keys, so a vector of the different states. Now, given a scenario vector, we can reach the availability vector for each of the parties. So the owner's availability vector is going to be sigma O with its element I is Sigma O i, and for the attacker, similarly, sigma AI. So if sigma I is safe, for example, then in the availability vectors, it's available. It's true for the owner, but false for the attacker. Let's take one more in case of a leakage, it's true it's available to the owner, but also available to the attacker because the queue was leaked.
00:10:46.166 - 00:11:39.620, Speaker B: Yeah. Now, for now, actually, for this work, we're going to assume that there are probabilities for the events, for the different events, for different states of each key, and the probabilities are going to be independent. So the chances for one key being in a state is independent of the probability of another key being in whatever state. So there are a total of four to the N possible scenarios and each one has a probability given by the product of the probabilities of each of the states. For this table, I'm assuming the keys are symmetric. So the same probabilities for both keys. So for example, for safe and lost, the probability is P safe and P loss.
00:11:39.620 - 00:12:27.388, Speaker B: The vector for the owner is true and false, right? Safe and lost, and for the attacker is false and false, safe and lost and so on. Now a wallet is then a predicate on the availability vector. Okay? For example, let's say we have three keys, one to K one, k two and K three. Then the wallet requiring K one and K two or K two or K three will look like this. That's a wallet and we're going to say this is a model choice. You can have a different choice and it will result in something different. But we're saying that a wallet is successful if the owner can authenticate and the attacker cannot authenticate.
00:12:27.388 - 00:13:20.866, Speaker B: The reasoning is that if the attacker can authenticate, he will be very quick. We want to be conservative and not give him that option at all. So we're only interested in cases where the attacker cannot authenticate and the owner can authenticate. And the probability of failure is the probability of an unsuccessful scenario, I mean the probability that the scenario will be an unsuccessful one. Moving on from the model, naturally we're looking for optimal wallets. So here's an option, let's just scan the entire range of options and see what the best wallet is. So how many wallets are there? Wallets are in fact Monoton boolean functions, right? They only switch from false to true.
00:13:20.866 - 00:13:50.620, Speaker B: If you learn another key, you will not be less able to evaluate. So it's a Monoton boolean function. The number of Monoton boolean functions is the dedicated number, almost. So if we have no keys, we're going to have no wallets. There are still two monotone functions, the constant false and the constant true. We're not interested in those. Obviously, if we have one key, one key, then there is just one wallet, K one.
00:13:50.620 - 00:14:17.214, Speaker B: So again, the dedicated number is plus two. But that's not interesting. With two keys we already have four options. We can use just K one, just K two, the end key, k one and K two and the or key and the end wallet or the or wallet k one or K two. With three keys we already get to 20. These are the options. This is requiring just one of the keys.
00:14:17.214 - 00:14:40.986, Speaker B: This is requiring all three of them. You have somewhere here, any pair specific pairs, the or wallet, any of the keys, et cetera. So up to three we're fine. Four is going to be larger, 166 wallets. Five is going to be even larger. And we know the dedicated number. So the dedicated number grows very quickly.
00:14:40.986 - 00:15:23.334, Speaker B: In fact, the dedicated number beyond eight is not known to humanity. We only know, up to eight. So we cannot hope to go through all the possible wallets beyond eight, since we don't even know how many there are. Instead, we're reduced to evolutionary approximation or simulated annealing did this one for this work. So you start with a random population of wallets and iteratively you select some subset. Say you select three wallets from this random population. You choose the best one among them, you make some random changes, you take the result, you put it in the next generation.
00:15:23.334 - 00:15:41.806, Speaker B: You do this until you have the full generation, then you start again until it stabilizes. Now let's get some results. One key. We can go through all the options. This is the options. We're going to look over a few of those. So let me go through this.
00:15:41.806 - 00:16:03.000, Speaker B: So this is the wallet, just a one. We'll have more keys later on. I'm assuming a symmetrical distribution. So they all have the same probability of leak and of loss. So this is more probable that it's going to leak. This is more probable that it's going to be lost. This is both of them are high, so obviously dark is good.
00:16:03.000 - 00:16:25.850, Speaker B: As the probability of leakage and loss gets smaller, we get a better wallet security, a smaller probability of failure. Here, through most of the examples we'll have, probability of theft is 1%. Does this make sense? Okay, so now two keys.
00:16:29.390 - 00:16:37.182, Speaker C: So this is like a slice of a three dimensional graph where you fix the probability of theft exactly. .01.
00:16:37.236 - 00:16:37.840, Speaker B: Exactly.
00:16:42.050 - 00:16:54.280, Speaker D: Yeah. Do you have like, the key leak and key loss or it's possible that they're both never mind, you're only looking under the diagonal where they come to.
00:16:56.250 - 00:17:16.598, Speaker B: Yeah. Otherwise you'll get too many percent. Okay. Expanding to two keys. Now let's look at the end key and the or key. Similar result. The symmetry is obvious, so the end key is more resilient to leakage.
00:17:16.598 - 00:17:57.626, Speaker B: So even if one key is leaked, the attacker can't take the money, and the or key is more resilient to loss because even if we lose one key, we're still able to move the money to authenticate. Yeah. And now things become interesting. Which wallet is better for two keys? So again, the probability of theft is 1%. We get this. I'm going to switch to 4%, just so it's a bit more obvious. So here it's the same axis, but this is the category which wallet is better.
00:17:57.626 - 00:18:30.360, Speaker B: So if leakage is very likely, then the end is better. And if loss is very likely, then or is better. But the interesting area, the area we really care about is around here. Right. We're looking for keys that are unlikely to be faulty. And here the best walls is actually to just use one, either K one or K two. This might not be that intuitive, but only with actual careful formal analysis we get here.
00:18:34.410 - 00:18:41.770, Speaker C: When you say best, you mean maximizes the probability that the honest party can authenticate, an attacker can.
00:18:41.840 - 00:18:43.610, Speaker B: Yeah, precisely.
00:18:46.670 - 00:18:51.050, Speaker A: And is there, in hindsight, intuition for the green stripe?
00:18:54.290 - 00:18:58.960, Speaker B: Not really. Yeah, not yet.
00:18:59.890 - 00:19:11.250, Speaker C: Have you tried graphing in three dimensions? That's what I'm curious about, because it looks like as you go on this dimension increasing the probability of death, that script getting wider.
00:19:12.230 - 00:19:20.900, Speaker B: Yeah, I mean, for this you can actually write down exactly the areas it's very clear this will become wider. What do you expect?
00:19:22.150 - 00:19:23.970, Speaker C: What's a three dimensional graph?
00:19:26.170 - 00:20:04.174, Speaker B: It's a pain to read. It's a pain to read. But I'll show you some more of these results and hopefully it will help gain some sort of intuition of what this looks like and how unintuitive this is. This is three keys. Some good news here. So again, a lot of loss, probably the best or but here you see close to the basis, you see that actually the best wallet is any pair. Which is great news because this is common intuition and is used in a lot of cases.
00:20:04.174 - 00:20:43.850, Speaker B: And this actually stays the case even if you increase the theft probability. So below it was not before it was no theft. And this is with theft, actually a high probability of theft. So everything becomes very pronounced. You see that in the area we care about, we get this, any pair, four keys, about the same. I mean, if you transition from three keys to four keys, you need to make a decision, right? Do you want two out of four or three out of four? Well, this is roughly, I think, what one would have expected. If you add theft, it becomes complicated.
00:20:43.850 - 00:21:27.918, Speaker B: And again, we see what we saw for two keys. So the close to zero probability, the best wallet is actually not the symmetric one. So not any pair and not any triad. So to understand the behavior with multiple keys, we're going to switch to these graphs here I increase the number of keys and we look at the failure probability of the wallet. And the goal is to show here the optimal wallet. So up to five. My quick Python simulation can just go through all the options.
00:21:27.918 - 00:21:56.002, Speaker B: Beyond that, there are two curves. There is the guess, which is just any symmetric keys for up to whatever. And there is the heuristic, the evolutionary algorithm in black. So this, I think, is what you would expect, right? This is either only loss or only leak result. In the same result, you get exponential improvement with the number of keys when there is only theft. Ha. Things become a bit more surprising.
00:21:56.002 - 00:22:19.120, Speaker B: But this kind of matches what we saw earlier. So with two keys, you're just as good as if you just used one. With four and three, six and five. Maybe it goes on, I don't know. I'm being honest with you here. The evolutionary algorithm wasn't able to do as well. Obviously you can bootstrap it with the guess, but I wanted to see how it does.
00:22:19.120 - 00:22:55.158, Speaker B: So it wasn't able to reach the optimum here. And this is, I think, a more interesting example. Now, the keys are not symmetric, okay? So the first key has 1% theft probabilities and the rest of the keys have 1% loss probability. So the general trend you see here is still kind of exponential, but you see that the symmetric solution doesn't do anymore. You need something else. This is not surprising, right? But you need something else. And here the evolutionary algorithm at least continues this trend.
00:22:55.158 - 00:23:58.510, Speaker B: If you have any idea on how to find this in a non heuristic way, then I'd love to talk to you. Now, two small things to note here. One is like practical implications of this. This is three curves showing you the fault probability with 1% theft probability but with different loss probability. And you see here that you're better off using six keys that are prone to loss than three keys that are not so prone to loss, like order of magnitude better. And I know, I mean, if you speak to large institutions, their strategies often to place one very good, very big secret in a vault underground with armed guards and not replicate that and use some hot wallet strategy. While this is kept secret, this demonstrates that it's in fact better to have a few secrets, maybe hidden a little less underground.
00:23:58.510 - 00:24:37.878, Speaker B: You will get better. Bottom line security. Yeah, this I think is clear. I want to explain two curves here. This is the probability of loss for two keys. And we have a third key whose probability of loss goes from zero to 10% and the rest is leak probability. So if the loss probability is zero, then the leak probability of key three is 10% and vice versa.
00:24:37.878 - 00:25:21.718, Speaker B: So we have like a security budget and we're shifting the fault probabilities of k three between loss and leak. So this is an analysis of the asymmetric case you see here. The keys are symmetric, kind of, so they're all probably lost. That's the main thing that can happen. And so the best wallet is the two out of three. But at this point, suddenly the third key loss probability becomes so high it's not likely it will be leaked that we're better off just oring that key three. So key three is enough because it's unlikely that it will be leaked.
00:25:21.718 - 00:27:00.630, Speaker B: And then either that or both k one and K two. And if we had the flip side, you'll see it's symmetric and if you have a 5% key loss and 5% leak probability, then it's a version of this where if it's very likely that P three is lost, then we'll or it but if it's very likely that it's leaked, then we will require it. In both cases, it's unlikely that it will be lost. If you want to play more with it, we have an online calculator you can feed in your probabilities, you can try to design a wallet and calculate the probability or it will calculate the optimal wallet from you. This was originally designed a while back and this week there was a hackathon group at the IC Three boot camp at Cornell and this is the new result where not only it will compute the optimal wallet for you, it will actually take from you your private keys and generate a smart contract you can deploy on ethereum. This is all done on client side including the compilation of solidity. Nothing goes to any server and that's what I had to say about authentication.
00:27:00.630 - 00:27:11.978, Speaker B: But let me pause for a second for a question about this. I think this is new and there are potentially different ways one can take this. Yeah.
00:27:12.144 - 00:27:36.066, Speaker A: So one thing that point that jumps out from the graphs is that it's quite sensitive to the probabilities of the answer. I'm wondering how one would get any amount of confidence about what those p's are. And I guess a related question would be like if some random promising project said we're going to do a KFN multi SIG what you can envy, what would you tell them?
00:27:36.168 - 00:27:36.674, Speaker B: Sorry?
00:27:36.792 - 00:27:42.470, Speaker A: If some projects do what you can envy in a KFN multi SIG yeah, what would you tell them?
00:27:42.620 - 00:28:25.780, Speaker B: So that's an excellent question. I think this is really one question because to make this practical you would want a wallet that is resilient to miscalculation of your probabilities. So this gives you the ability that did not exist before to actually evaluate your fault probability. This is very important, especially if you have large sums of money. Now to design your wallet based on that, you'd probably also have some estimate on how accurate your estimation is of your key fault probabilities and this is thing that is waiting for future work.
00:28:28.870 - 00:29:04.110, Speaker D: So how sensitive? How sensitive is that to, for example, nailing the optimal design with, say, 20 keys versus, like, for example, one thing that's coming to my mind is, like, if you use the union bound over the two sources of failure, probably that's much more trackable than trying to nail the exact probability of failure is losing a factor of two. Is that useless? Or if you can do that for lots of keys, that would probably still be useful for some applications.
00:29:04.450 - 00:29:23.640, Speaker B: Since right now 20 keys is extremely far from tractable then any approximation would be appropriate. You'd still need to figure out the process, which I don't know how to do at this point. But like I said, I'd love to discuss.
00:29:25.850 - 00:29:36.540, Speaker C: When you're talking about this dedicated number. Seems like that's ordered though. But at least in your early examples, if you assume the keys are symmetric, that number goes way down.
00:29:38.590 - 00:30:10.020, Speaker B: You're probably right. I was not able to find that number yet in the symmetric keys it should be much more tractable and in most of the cases where I could actually run through all the options, the optimal wallet was simply asymmetrical one. Maybe not the symmetrical for using all the keys, but one less. But that was the best wallet design.
00:30:12.730 - 00:30:19.958, Speaker C: But if you assume all the keys are identical, then a lot of different configurations are equivalent, right?
00:30:20.044 - 00:30:50.626, Speaker B: Yes, but the question is how to reduce them and how to find the ones that you care about. Yeah, still also an open question. Maybe a lower hanging fruit, but yeah, just 20 seconds. I didn't immediately realize that this was the dedicated number. So I had an approach similar to what you just said. So let me count the number of possible wallets. So I took a marker and whiteboard and started running through these.
00:30:50.626 - 00:31:23.446, Speaker B: And after a couple of hours of feeling very stupid, I started looking around and it turned out that this is an actual hard problem. So there are trickier things hiding here than I expected. Okay, now for something completely different. Can we defer this to later? Yeah. Because I have an ambitious plan to talk about incentives a little bit. So something really completely different. Classical consensus protocols are permissioned.
00:31:23.446 - 00:31:54.274, Speaker B: We know who's going to participate. There is no obvious transition to the permissionless world. We need an algorithm to be resilient to attackers. And it's okay. Things should work. Okay. When the majority of mining power, and I'm talking specifically proof of work here, the majority of mining power is honest and there is a smaller attacker, then things should be okay, secure.
00:31:54.274 - 00:32:17.614, Speaker B: And if the attacker is larger, it will break. We're fine with that. But why would these honest parties follow the protocol? Because they are incentivized. Right. And we want to look for a Nash equilibrium where they all better follow the protocol and not do something different. Now, Nakamoto's proof of work blockchain works like this. I know you all know this, but there is one fine point I want to go through.
00:32:17.614 - 00:32:50.178, Speaker B: So anyone can join, they generate these blocks. What about fairness? We get that from proof of work. If you have about one fourth of the mining power, you should get about one fourth of the block. Because exponential distributions yada, yada. So the winds are proportional to your computational power, which actually means that your revenue is proportional to your computational power. And I mean that in terms of dollars per month. This is not immediately intuitive.
00:32:50.178 - 00:33:20.686, Speaker B: The reason is that we have this difficulty tuning mechanism. So if there is more mining power coming into the system, puzzles will become harder. If there are people leaving, puzzles will become easier. But the end of the month, you really only care about your ratio of blocks on the chain. The state needs to be immutable, even though there can be forks. So we pick the longest chain. The minority cannot outrun the honest chain except with negligible probability.
00:33:20.686 - 00:34:02.026, Speaker B: Great. What do we actually want from the system? Through things as defined by Gariatal and later by personnel. Consistency, growth and quality. Consistency, meaning everyone agrees on at least a prefix of the past. Growth means there is a linear increment extension of the ledger and quality, meaning certain fraction of no, this is only rough, but this is enough for us. Now, constant fraction of the blocks are generated by honest parties. These are the deciderata.
00:34:02.026 - 00:34:57.294, Speaker B: This is what we want from the blockchain. Now, Nakamoto said we get security with an honest majority, but if we want to talk about selfish behavior, this is the work with Gunseer. Then we see that the attacker can do better, right? They risk losing some of their own blocks, but they get the honest parties to lose a lot of blocks. So their ratio of the blocks on the main chain is higher. The analysis of this is done with a state machine. It's pretty easy because we can clearly define all we need in the state with just this single number and zero prime standard analysis, and we're done. Bottom line, there are different curves here for the revenue of the attacker, depending on the rushing control of the network.
00:34:57.294 - 00:35:32.230, Speaker B: But even if we assume no rushing. So the most optimistic assumptions after one third, the attacker rational player prefers to be selfish and not follow the protocol. Great. Now, in 2017, there was a major progress to address this in Fruit chains by Rafael Pass and Elaine she. And what they did is the following. They said, the miners don't just try to append blocks to the end of the chain. They also try to mine earlier in the chain for a different type of block.
00:35:32.230 - 00:36:19.462, Speaker B: And so if it's at the end of this chain, it's called a block, expanded regularly. And if it's here, it's called a fruit. The fruit are actually going to include transactions. So if the miner manage to generate a fruit, he puts the transactions in the fruit and extends, adds the fruit, hangs the fruit on the chain, and there could be more fruit, et cetera, and there can be more blocks. Okay, so the same mining effort will result either in a fruit or in a block. Now, you proceed with this. You get many fruit hung on the blocks, and then each block also has pointers or hash pointers to fruit.
00:36:19.462 - 00:36:53.724, Speaker B: Earlier on, once a fruit is referenced by a block, the transactions of the fruit are actually considered to be placed here, and whoever generated the fruit gets rewarded. If a fruit becomes very old without being referenced, then it's called ripe. It's discarded. No reward and no transactions. Just lost. All good. Okay, so the desired behavior in fruit chain is the following.
00:36:53.724 - 00:37:24.200, Speaker B: The longest blockchain, like Nakamoto, for the main chain, and then you add fruit not too recent because there might be small reorgs in the chain. That's a common behavior in a blockchain. And that's okay, so not too recent and not too old because we don't want it to rot. And then when you create a. Block, you point to all the unreferenced fruit. That's the desired behavior. However, here's a deviation.
00:37:24.200 - 00:38:07.732, Speaker B: Rather than point to all unreferenced fruits, you point only to your own unreferenced fruit, ignoring fruit generated by others. Now, this deviation carries no risk. Whatever everyone else is doing can only help you, and you will only reference your own fruit. So you will get whatever reward you might get. Now, what this protocol guarantees, this is an Epsilon Nash equilibrium. So the protocol guarantees that you cannot make more than some negligible amount by deviating in any way, and specifically in this way. However, the bottom line is that fruitchain is always almost a Nash equilibrium.
00:38:07.732 - 00:38:13.400, Speaker B: You're always better off deviating. You will earn only a little bit, but there is no risk.
00:38:19.580 - 00:38:24.152, Speaker D: Just to clarify, there's no rewards for the block. So that's how they get around selfish mining.
00:38:24.216 - 00:39:08.040, Speaker B: Correct. If you had rewards for the blocks, you would run the risk of I mean, you would open the door to selfish mining to some level. And what we learned recently from this work by Aviviation company is that miners do take advantage of small gain opportunities. To my knowledge, this is the first observation in the wild of selfish behavior on the consensus layer. Moving on. I would like to present color Dag. This is work with Ita brown danny Dolev and Joe Halpern.
00:39:08.040 - 00:39:58.024, Speaker B: And that is the following. So what we want to do is get better resilience, and we're going to use a dag rather than a chain. There are a lot of works that use Dags, starting with Levenberg, Sompolinsky and Zohar from 2015. We don't care for this work, you can do whatever you want with the dag, but for this work, we only use the Dag for incentives. We don't care about performance or bandwidth or this is just about incentives. So color dag uses three techniques to achieve this resilience. First of all, we color the blocks.
00:39:58.024 - 00:40:52.000, Speaker B: Each block gets a color uniformly at random. After you generate the block, you find out what its color is. In practice, you can use the LSB of the hash, and this way we take the original graph and we divide it into different miners for each color. If we increase the number of colors, we increase the number of minors, and we reduce the probability that there will be a fork in one of the miners because blocks of a single color become more rare. So we actually reduce arbitrarily the ratio, the rate of benign forks. And from now on, we're only going to look at a single color. Actually, we're going to look at each of the single colors separately.
00:40:52.000 - 00:41:00.080, Speaker B: So we removed the forks inside a single color, and then we can now look at each of the colors separately.
00:41:05.960 - 00:41:07.140, Speaker A: What's the goal?
00:41:07.640 - 00:41:26.836, Speaker B: Okay, the goal is to assign the rewards in a way that will make extending the Dag the best response. And by extending the Dag, I mean adding a new block that references all leafs and publish it immediately. Thank you for this question, but it's.
00:41:26.868 - 00:41:29.684, Speaker C: Forming minor what, like subgraphs or something?
00:41:29.742 - 00:41:59.220, Speaker B: Yeah, subgraphs. So specifically, I mean, you take all the for yellow, right? You take all the yellow blocks and you add an edge. If there is a path between two yellow blocks and there is no path between these blocks, that has another yellow graph in it. Yellow block in it. And that's a minor. That's like standard graph theory, nothing fancy.
00:42:02.280 - 00:42:07.352, Speaker A: As it happens here, all of the minors are just these paths, right?
00:42:07.406 - 00:42:07.720, Speaker B: Right.
00:42:07.790 - 00:42:10.810, Speaker A: They could be disconnected, for example.
00:42:11.500 - 00:42:31.760, Speaker B: No, it cannot be disconnected because we start with a genesis that has all the colors, a white genesis. And then every block will have at least one predecessor of its color. So there might be forks here, but they're very rare and by increasing the number of colors, we can make them arbitrarily rare.
00:42:34.100 - 00:42:37.010, Speaker C: How many predecessors does each block have?
00:42:38.580 - 00:42:59.560, Speaker B: As many as it needs. I mean, you should reference all leaves you are aware of. So it depends on network properties. So now let's look just at one color. This will be for every color. So the second technique is symmetric. Penalty.
00:42:59.560 - 00:43:34.500, Speaker B: Now, since we reduce the probability of forks, if we do see a fork, we know that it is the result of some malicious behavior. Someone intentionally created this fork, however, we don't know which one, right? So what we do is we apply a symmetric penalty so neither block gets any reward. For simplicity I did not say this, but for simplicity, I assume the rewards are either one or zero for all blocks.
00:43:37.320 - 00:43:41.030, Speaker C: Is that penalty burned or does it go to the person who reports it?
00:43:41.960 - 00:43:51.320, Speaker B: No one needs to report it because it's evident from the graph and it is burned. Yes. So they simply do not get the reward.
00:43:52.220 - 00:43:59.944, Speaker C: So that is recording it, right? They could not include a reference to one of them and then it wouldn't right?
00:43:59.982 - 00:44:17.650, Speaker B: Like in your example there, this guy could not could have avoided referencing this guy, right? No, I see where you're headed. We're not doing that. So simply symmetric penalty here. This guy gains nothing. It's the same.
00:44:18.500 - 00:44:22.610, Speaker C: Why wouldn't you take any epsilon broadhead and said not report it?
00:44:25.640 - 00:45:27.050, Speaker B: It is jumping ahead a little bit, but what we will show is that it's the best response to simply follow this protocol in the sense of a strict Nash equilibrium, like even in the presence of dinner. No, we did not look into that. So it's all internal. Yeah, that's a good point. Now, why would Symmetric Penalty even make sense? We're punishing everyone so intuitively, it's obvious, right? If I deviate and I get no reward, then I get no reward. But the point is this if an attacker gets X over X plus Y, so his reward divided by his and everybody else's reward, and we apply a symmetric penalty, then we get X minus D over X minus D plus Y minus D. And if X is a minority, so any minority attacker this would be worse than this.
00:45:27.050 - 00:46:24.152, Speaker B: So in absolute terms, the situation of the attacker would be strictly worse because of the symmetric penalty. And there's another catch here, which is that these symmetric penalties can be applied after a very long time, right? I can now go and create this fork from two weeks ago and then someone in two weeks ago should have been penalized even though they maybe already got the reward and used it, right? So this is why we have the third mechanism which we call unacceptable blocks. The idea is that we take blocks that are obviously from misbehavior and we call them unacceptable. Not only they do not get a reward, they also do not cause punishment or penalty to others. They're simply ignored. They will be on the Dag or not, but they are going to simply be ignored. The formal definition maybe is not very important, but it's simple.
00:46:24.152 - 00:46:53.912, Speaker B: So I will go over it quickly. We define a single canonical path, that's a longest path starting from Genesis and going all the way to a leave. And then if block is too far, meaning the smallest cycle of this form is larger than some parameter NL, then this block is called unacceptable. And these blocks are acceptable. Yeah, not the triangles.
00:46:53.996 - 00:47:01.540, Speaker C: What if the V two is not returning to B? Is that B like the abandoned?
00:47:03.320 - 00:47:58.404, Speaker B: Well, if we look at a snapshot, then we will logically add a virtual node at the end and assume that B is connected to that virtual node. But but eventually some honest miner will see this B and actually edit. So eventually the cycle will fall. So this is the summary. We color the blocks, we apply symmetric penalty and ignore unacceptable blocks and what we achieve is what we call Epsilon Nash equilibrium. This is a different solution concept that we propose and it says the following we look at histories and executions of the system and we assume an extremely strong adversary because we don't want to mess with probabilistic behavior of the mark of chains. So we assume an extremely strong adversary.
00:47:58.404 - 00:48:42.672, Speaker B: And it works like this the scheduler chooses the minor sizes throughout time for every step under the restriction that there is always a strict majority of honest miners. And then the scheduler chooses who gets to mine in every step according to the sizes chosen the previous step. And then the attacker, having seen this schedule, chooses their strategy. So it's a very weak model or incredibly strong adversary that really sees into the future. And in this model, the attacker takes no risk because they always know what's going to happen. They will never regret a step. And so each history has a probability over the scheduler's coin.
00:48:42.672 - 00:49:38.550, Speaker B: The history has some probability and what we're looking for is an equilibrium in one minus epsilon of the histories, where epsilon can be made arbitrarily small. In other words, we want and we show that color dug is this. So an epsilon? Sure. Nash equilibrium. In almost all executions with high probability, it is a strict Nash equilibrium. So first we define a safe history, for our system has certain good properties, unlikely events do not happen. And then we prove that by choosing appropriate parameters, there really is an overwhelming probability that we will have a safe history.
00:49:38.550 - 00:50:25.328, Speaker B: And then we show that given a safe history, all honest blocks are acceptable. So in a safe history, the attacker cannot make a block, an honest block, unacceptable. And for every honest penalty, there is a matching adversarial penalty. Which means that the strict best response in a safe history is to follow the protocol. Which leaves us with showing you that this is actually a ledger, as we wanted it to be. So we're using here a simple choice. As I said before, you have the Dag structure, you could do something fancy, maybe for a different talk, but here we simply pick one of the colors and say this is the ledger color.
00:50:25.328 - 00:51:14.316, Speaker B: And blocks of this color will have the transactions and the longest path of this color will be the ledger. And so consistency, quality, chain quality and growth we get immediately from these properties of the safe execution. I'm not going to drag you through them. There is just one interesting point that I want to emphasize here, which is revenue consistency. So most blockchains ethereum fruit chains included, you can look at the longest chain and realize who has how much the revenue. The awards are defined by looking at this longest chain and you're done. And here we also need to show explicitly that the rewards remain consistent.
00:51:14.316 - 00:52:13.764, Speaker B: It's not enough to show that the longest chain, the ledger chain, is consistent, we also need to show that the rewards are consistent and one cannot come a week later and change the rewards back in time. And this happens because of the acceptable block story. And again, it's derived from the safe history properties. So, this was the story of incentives, talked about better protocols and specifically about color. Dag and I would be very interested to talk about future problems, implying to both proof of work and not proof of work, particularly things that cross layers. So protocols at the application level that take advantage of minor behavior and minor strategies and exogenous incentives, as Joe mentioned before. That's it.
00:52:13.764 - 00:52:15.030, Speaker B: Thank you very much.
00:52:25.400 - 00:53:00.980, Speaker D: I have a couple questions about color bag. So first is, if I just wanted the theoretical result you have, if I just wanted the theoretical result, I didn't care about whether this would make sense for practice. Like I could say I just got rid of the colors, everything is one color. I still use the same rule that when I ask people to point to forks whenever there is a fork. I just give no one the reward. Would that get the same theoretical result? But that's just not useful in practice because there would be natural forks.
00:53:02.760 - 00:53:25.420, Speaker B: So you gave up the coloring and the notion of acceptable blocks or just the coloring for now. So if you give up on coloring, you would still get something that would work, but your bounds would be different because there is a certain probability for arbitrary.
00:53:26.720 - 00:53:29.950, Speaker D: Okay. The second part of that is that.
00:53:30.720 - 00:53:57.060, Speaker B: Maybe I want to sharpen this point a little bit. So we need for the competition, we need the honest blocks, the honest miners, to extend the chain quick. Even in this world, it's a chain that has to extend quick. And if there are forks, then their mining power is lost. Because of that. You can go back to the literature and there are expressions for exactly what you would lose in terms of resilience.
00:53:59.260 - 00:54:29.468, Speaker D: Okay. The second question is going to be in terms of the acceptable block. If I just wanted to focus on the theoretical result, would that actually be easier if you didn't have the concept of acceptable blocks? Because then you could just use the math that you wrote on the slide. You said that for every conflict it's one attack. The attacker is losing a block, janice is losing a block. And I'm wondering if it would just be literally the math you had on the slide.
00:54:29.564 - 00:55:14.830, Speaker B: So if we're being theoretical, then we need to be very accurate and then we're going to start having problems. Because if you get all the way down to the details, then the analysis is done for a bounded period. We need to assume something on the duration of the execution. If the execution ran to infinity, then every bad event will happen. So the execution time is bounded. Now, if you don't have any restrictions on this acceptability notion, then someone could next year revoke. I mean, after the time is done, the attacker can just cause penalties to participants from last year.
00:55:14.830 - 00:55:19.470, Speaker B: You'd need to redefine the model in a very curious way.
00:55:20.320 - 00:55:33.270, Speaker D: Sure. But if I just wanted theoretical results, it would still be the case that the attacker is paying more like the attacker has to pay something to get rid of. They're wasting their own block too.
00:55:38.040 - 00:55:50.056, Speaker B: And then you're saying, yeah, that might work. Again, it will not result in a sensible result, but that would be enough, I think. Yes.
00:55:50.238 - 00:56:07.436, Speaker D: And then the last thing I want to ask is you mentioned that you targeted epsilon or Nash equilibrium with that simplified the analysis. Do you know that it's not a Nash equilibrium?
00:56:07.628 - 00:56:08.128, Speaker B: Sorry.
00:56:08.214 - 00:56:10.156, Speaker D: Or it could be an Ash equilibrium.
00:56:10.348 - 00:56:18.210, Speaker B: The reason that okay. It's not a Nash equilibrium. There is a probability that the execution, I mean, this is a probabilistic world.
00:56:19.060 - 00:56:32.248, Speaker D: If you have a weaker adversary. So if the adversary doesn't know the future, then it is possible that it's an acquilibrium but it's just a huge pain to prove or, you know, it's not an acquilium even for the adversary that doesn't know the future.
00:56:32.334 - 00:57:20.100, Speaker B: So this is still in the works. But if you switch to a realistic adversary that does not know the future, then you'll get much better bounds. So here with this impossibly strong adversary we get concrete result. I can show you on a board, but if you actually want to let the math run and use a machine to find the optimum, then with an adversary that just looks at the probabilities and has to guess what the best response is, then we have initial results showing that this becomes very practical.
00:57:22.840 - 00:57:34.830, Speaker D: So you're saying that royal it could be all the way up to 50% 49% adversary who doesn't know the future still is incentivized to follow it. That that's possible.
00:57:35.920 - 00:58:00.470, Speaker B: Yeah. These results do not exist yet. So I don't want to commit to anything. But if you want to do a practical analysis then you get a bit further from the 50% because network because you still have some probability of you always still have some probability of forks. But you get close there. Yes.
00:58:04.920 - 00:58:20.120, Speaker C: Kind of a follow up on the primary question I was asking about what if those two parties are actually the same? So then the second one has kind of no intent to report that there was a fork.
00:58:20.700 - 00:58:26.816, Speaker B: So essentially a coalition. Essentially a coalition of two minors.
00:58:26.948 - 00:58:29.304, Speaker C: No, I mean what if it's just the same minor?
00:58:29.432 - 00:59:04.904, Speaker B: The same minor? Yeah. So this is exactly what we're maybe I'misunderstanding the question, but this is exactly what we're secure. Again, what you're secure against. Maybe what you're saying is the following. You're saying if I already had a fork and I paid whatever I paid because of the fork, then I have no incentive to immediately close that down until I reach close to the acceptability region. And that's I think, something that in a practical sense is something I would actually like to improve. But this protocol does not do it yet.
00:59:05.022 - 00:59:34.130, Speaker C: Yeah, that's interesting. That's not what I was thinking. I was thinking about reporting this thing. I guess you're saying you're secure against it as long as it's limited to a small coalition. But bribery is basically holding gates. But there's no censors, there's no floor. I guess there's no incentive to report.
00:59:34.660 - 00:59:58.810, Speaker B: So unfortunately I just flashed it briefly when I mentioned future directions. But I think that this is a critical question to answer. This is not this work, but it's a critical question to answer, which is against how much bribe worry? Is your blockchain secure? Is your protocol secure? That's a basic question, but for future work. Thanks very much.
