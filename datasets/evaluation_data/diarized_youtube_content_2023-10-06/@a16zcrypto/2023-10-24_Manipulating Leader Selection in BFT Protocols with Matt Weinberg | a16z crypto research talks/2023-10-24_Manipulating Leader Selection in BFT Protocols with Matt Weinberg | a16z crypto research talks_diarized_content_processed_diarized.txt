00:00:07.500 - 00:00:08.050, Speaker A: You.
00:00:10.260 - 00:00:32.804, Speaker B: Welcome everyone, to Today's, a 16 Z crypto research seminar. Very happy to welcome back Matt Weinberg, professor at Princeton, who is one of our faculty fellows last summer. So Matt's been finding game theoretic issues with blockchain protocols for a long time, 2016, which of course is the Dark Ages in this space. Lately he's turned his attention to proof of stake PBFT style protocols and he'll tell us about his latest work on that. So that all yours.
00:00:32.852 - 00:01:14.176, Speaker C: Awesome, thank you. So I'm going to talk primarily about this first work that was at EC last year. And throughout the talk I'm just going to briefly mention these two ongoing works as well. So I do intend to, I think, just kind of get straight to the model and I'll spend some time on background in the model. But I think I'm not going to do like a big broader picture overview. But if that means that there are questions because I skipped some basics. I don't know exactly how many BFT consensus talks you guys have seen over the summer, but if there's some background, I'm assuming feel free to just interrupt and I totally don't mind getting derailed.
00:01:14.176 - 00:02:09.312, Speaker C: I think that seems to happen a lot and I'm really okay with that. So at this point, I hope it's maybe not too bold to claim that it's kind of well understood how to manipulate longest chain protocols. So like the seminal paper introducing that is now like nine years old. And there's, I think, pretty significant follow up works that are now like seven years old. And I don't know if that's a little too bold to claim, but I want to say that's starting to become much better understood. And I think what's a little bit less well understood is for these more modern protocols that are based on Byzantine consensus, can you manipulate those in similar ways or how is that different? So that's what I'm going to focus on in this talk. And just to emphasize, if you haven't seen these kinds of presentations before, what I'm not going to do, I'm not going to show you how to violate Liveness.
00:02:09.312 - 00:02:45.168, Speaker C: That's not what these things are about. We're not violating Liveness, we're not violating consensus, we're not doing attacks like that. But what is happening is someone's going to be able to get a little bit of extra money by maybe being the leader more often or having their blocks adopted a little bit more often than if they were following the protocol honestly. And so the other thing I'm going to say is this is not a consensus talk. So I will give a couple slides just to recap. In case you haven't seen BFT style protocols before. What's the relevant aspect of those? I'm not actually going to talk about consensus at all.
00:02:45.168 - 00:03:35.964, Speaker C: The entire talk is just about one role in these consensus protocols and how you can be the leader in these protocols more often. So the main result is just going to be like there's a wide class of BFT protocols. I'm going to focus on a canonical one that I think captures a lot and they're going to be manipulable. I'll show you how to manipulate them and I will discuss how to optimize that process and be the leader as often as you can in those. Okay? So the first thing I want to do before diving into that is give you some motivation that is technically different right before the merge, so the technical details are not relevant anymore. But before the merge in the proof of work, Ethereum, they had a difficulty adjustment. And the difficulty adjustment was actually determined based on the timestamp difference between your block that you're creating right now and the previous block.
00:03:35.964 - 00:04:16.376, Speaker C: So fine. And in particular that difficulty went down every 9 seconds and it seemed like maybe if you add some seconds onto your timestamp, this makes it easier for you to find your next block. You can set the timestamp however you want and now all of a sudden you've just made yourself more likely to find blocks than you're supposed to be. But that's actually not what you should do because in Ethereum there are so many forks and ties between forks are broken based on difficulty. So it turns out that what you actually want is you want to shave some seconds off of your timestamp. That will make it harder for you to find your next block. But now you will win any tiebreakers in case of a fork.
00:04:16.376 - 00:05:09.836, Speaker C: So they proposed this and they looked at the source code, confirmed that this was correct. And then the thing that was amazing I think about their paper is that they showed that so this is the timestamps for a specific pool. I think it was F two pool in Ethereum proof of work. I think this is like super clear evidence that this was really happening on Ethereum at the time. So you can look that every 9 seconds they produce zero blocks that have a nine second difference or an 18 2nd difference between the previous ones. And you can see that what seems to happen, this should be like exponentially decaying and it really looks like someone just took the nines and moved them to the eights and the so that's what they claim happened. And then the other thing that happened was so this I believe is the manager of F two pool who basically said, I think it was like three days after the paper came out, was basically like, yes, we did this.
00:05:09.836 - 00:05:45.000, Speaker C: And I interpret this last thing as saying like, you guys should do more mechanism design so that this doesn't happen. And so I now use this as like a motivation for the general theme of like, why does manipulating protocols matter? People are really doing this. Now I'm going to get into so all of that technically has nothing to do with the talk. But is motivating the same concepts? So, Byzantine agreement, I assume probably someone this summer is talking about it in much more detail. Basically, it's a classical distributed systems problem. You just want everyone in the network to agree on the same thing. Some people are adversarial and trying to stop you from doing that.
00:05:45.000 - 00:06:35.160, Speaker C: So what does a simple proof of stake blockchain protocol look based on BFT, you somehow randomly select a bunch of users. Maybe you do that proportional to their stake in the currency. They each propose a block and then you run a BFT protocol. And then as long as at least some fraction are honest, they'll decide on the same block. And the nice thing is that there's no forks once this happens, that everyone agrees, and everyone agrees, they agree forever. And so I just want to emphasize because I didn't fully understand this myself until I saw enough talks, that the nice thing about this is that if you have an honest user, they'll never claim that they have decided upon multiple distinct blocks. And so what that means is that if you ever find a witness that says there's two distinct blocks from the same round, that each had a lot of people deciding on it, this is like an explicit witness that you must have had at least some number of dishonest users.
00:06:35.160 - 00:07:18.072, Speaker C: Okay? And so the way that these things go is you just need a large enough fraction of the stake owned by honest users so that you hope that every round has some number of honest users. And this seems like a reasonable assumption. So there's a lot of pros in comparison to longest chains and there are still some challenges. I'm not going to dwell on these. There's still some challenges. And I think the main challenge that's relevant for this talk is you need some source of randomness to select the committee. And one paradigm, I guess, that I noticed in a lot of the early blockchain protocols is they all have some notion of a leader and that simplifies the protocols in the following sense.
00:07:18.072 - 00:07:36.990, Speaker C: So like a sample protocol to have in mind again, I'm not going to give you like consensus level details is if you receive lots of different blocks, then which one should you try to converge on? Well, I should try to converge on the leader, whoever that is. And so then everyone eventually tries to converge on the leader and that helps make the protocols more.
00:07:39.040 - 00:07:39.544, Speaker B: Matt.
00:07:39.592 - 00:07:40.044, Speaker C: Yes.
00:07:40.162 - 00:07:58.384, Speaker B: Might be worth saying. I mean, you say need, there needs kind of a strong word. I would say if you want some degree of unpredictability, then you need, because some protocols, some proof of stake protocols, just use round robin, kind of stake weighted round robin for leader selection. So I'd say this is a class of such protocols.
00:07:58.512 - 00:08:14.308, Speaker C: Got it? Yes. Sorry. So I think I meant to stick just to this, which is, say, many efficient protocols have a leader. I did not mean to say that you need to have something like this. Yeah, so I agree with that. Thank you for clarifying.
00:08:14.324 - 00:08:16.772, Speaker B: And even if you have a leader, it need not be random.
00:08:16.916 - 00:08:26.604, Speaker C: Sorry. And even if you have a leader oh, I understand. Yes, I understand. So you're talking about this one that you don't need a source of well, both.
00:08:26.642 - 00:08:29.192, Speaker B: You say source of randomness, then you say randomly select a leader.
00:08:29.256 - 00:08:45.830, Speaker C: Yes, I agree. Yes. Okay, so I agree with that. You don't need to do that. For the initial protocols that got me looking at this, that is what they did. And my understanding is that a lot of protocols do this. But I agree you don't need to do that.
00:08:45.830 - 00:09:26.960, Speaker C: Why is this a challenge? Why would you care? Well, the committee members and the leaders get rewards. So maybe this is because there are explicitly transaction fees or block rewards in the protocol. Or now there's mev. And so being able to dictate contents of the blocks is important. And so users want to be on the committee and they want to be the leader. So what I would say is, again, I'm not aware of evidence of these specific kinds of manipulations. I don't know if someone in the audience is, but I would definitely be concerned if it was theoretically possible to manipulate a protocol to be the leader more often.
00:09:26.960 - 00:10:09.680, Speaker C: That is definitely a profitable thing to do. And so I would be concerned about that. And then the reason I showed you the first couple of slides was to say that there are definitely instances of people in practice doing profitable things. My role is to try and highlight what are profitable things, but I'm less knowledgeable about what's actually going on in practice. Okay, so what I'm going to do now is I'm going to present several slides on just sort of like, how might you do this? And so this is motivated by the first protocol that I was kind of aware of was Algorand. And so definitely the model is inspired by how Algorand did it. My understanding is that this framework is also how other people do it.
00:10:09.680 - 00:10:59.280, Speaker C: But I'm not claiming this is exactly what Ethereum does or exactly what other protocols do. So what is a representative framework to do this? So every round has some seed, and every coin based on that seed is then going to compute their own credential. So what is that? One way to do it is you can digitally sign it, and that's going to make it unique to the account. Maybe let's also just throw in the ID of the coin when you digitally sign. So it's unique to each coin, and then you hash it. And so what's nice about this is it means that once the seed is set, you can think of hashing as being like, fits, perfect randomness. It's basically just giving everyone an IID draw uniformly from zero one for each coin.
00:10:59.280 - 00:11:38.636, Speaker C: And now you can say, I'll say the smallest Credential is the leader, and the 1000 smallest credentials will be the committee. And what's nice about this is once the seed is fixed, that will just give you a uniformly random coin, and that's going to be your leader. So that's good. There's like this inconvenient thing that I will quickly address just because I've noticed that sometimes it distracts people during the talk of, like, exactly what should you do if you don't want to do one hash per coin? So there's a simple fix. I'll just quickly go through it on the next slide. But that initially sounds inconvenient, but you can make it so that there's just one hash per wallet. That's fine.
00:11:38.636 - 00:12:18.440, Speaker C: But the key challenge that's going to be the actual focus of the meat of the talk is how do you pick this seed across multiple rounds? And so what you might be concerned with is predictability. So kind of like what Tim was mentioning was that if you're not concerned about predictability, then there's an easy way to do this. You just fix them at the beginning of time and you have your leaders and there's no manipulation. That's it. If you are concerned about predictability, then you want it to kind of be set later. And then the question is, how do you do that in a non manipulable way or a minimally manipulable way? So let me quickly just address this. There's like a little bit of cool, quick math.
00:12:18.440 - 00:13:12.810, Speaker C: So basically what you want to do is you want to somehow draw a Credential in a way that is one Credential per wallet that's somehow weighted by the size of that wallet, right? And you would like it to be the case the property you really want is you would like it to be the case that, for example, if my wallet has twice as much as you, I'm twice as likely to be the leader as you. And so then the question is just a pure probability question. What are parameterized distributions such that when you parameterize them by the amount of the wallet, that having twice as much makes you exactly twice as likely to be selected. So the answer to that is those are exponential distributions. Okay? So just in case you'd like to see something very concrete, what am I saying you should do? What you should do is say your Credential. You're going to digitally sign and hash something. This is uniform in one.
00:13:12.810 - 00:13:55.000, Speaker C: You're going to take minus the log and divide by the size of the coins and then the smallest, this is going to be the leader. So this is just if you are really detail oriented and you want to see, why does this give you an exponential distribution, that's here, but I'm not going to read that out loud. And the two cool facts, if you haven't seen them before, is that the minimum of an exponential with rate x and an exponential with rate y is distributed exactly like an exponential with rate x plus y. So one thing that means that this is like sybil proof and it's also collusion proof. Right. So it doesn't help you to split up your stuff, it doesn't help you to merge. You're still going to have the same minimum Credential.
00:13:55.000 - 00:14:19.280, Speaker C: And the second cool fact is just that the minimum of two exponentials with different rates is equal to each one with probability proportional to their rate. So that's exactly what we want, that we are indeed picking proportional to stake. So what you should really do, if you don't want to do one hash per coin, you do one hash per wallet and you just scale it according to this. And now you've solved that annoying.
00:14:20.100 - 00:14:28.240, Speaker A: Matt yes. If you're just taking the minimum, why isn't everything invalid to a monotone transformation?
00:14:29.940 - 00:15:00.510, Speaker C: The distribution is not going to be like if you do oh, sorry. If I want wallets of different sizes, that's the issue. So if I have wallets of the same size, then yes, any monotone transformation, it's invariant under. If I have wallets of different sizes, I need to scale my like, I need to scale my twice as large wallet so that I'm twice as likely to be the min compared to you. So there are other ways to do it. I think this is just the cleanest function. I know.
00:15:00.510 - 00:15:03.310, Speaker C: Did that answer your question?
00:15:04.320 - 00:15:04.876, Speaker A: Yes.
00:15:04.978 - 00:15:05.630, Speaker C: Okay.
00:15:06.640 - 00:15:28.996, Speaker B: Matt maybe like conceptually way to say this is so previously you were flipping a thousand coins, right? And so the thinking is like, okay, but actually you only care about the minimum of those thousand experiments. Right. So why not just sample directly from the distribution exactly the minimum of 1000 experiments? And then all that stuff is just saying, look, you can actually do this in closed form really easily, right?
00:15:29.018 - 00:16:00.860, Speaker C: Exactly two separate points. That's exactly correct, yes. So just to repeat that, if you wanted to do the math slightly differently, but it would be conceptually simpler, what Tim suggested is you could just simulate you actually have two coins in your account or a thousand coins in your account. So there is a distribution which is what is the minimum of 1000 IID uniforms. That could be what you do here. And it turns out there are just other functions you can use and the exponential is simpler to use. So now we get to the key conceptual challenge.
00:16:00.860 - 00:16:38.764, Speaker C: Okay, so I took these slides from when I was giving a class based on this. So I'm going to actually several slides are both the animations and the content is sort of like as if I were teaching. So I will pause. If you guys want to participate in the math exercises, feel free to do so. But if I'm not getting that vibe, I will just click through them. So the first approach is you would say like, okay, what if we just had trusted external randomness, right? Then you would say, okay, I'm just going to use that trusted external randomness beacon and that is going to be my seed for each round J. And this would be great if you had that.
00:16:38.764 - 00:17:54.756, Speaker C: So there's no way to manipulate a trusted randomness beacon if you actually trust it and it's not predictable. So if you had this, this actually would be perfect. Now what I want to highlight is that this may seem trivial the way I'm presenting it, but this is not the case with longest chain protocols, right? So longest chain protocols, even with proof of work, are still manipulable, right? And trusted external randomness is even slightly more manipulable than proof of work. So longest chain protocols with trusted external randomness, that doesn't fully solve the problem for BFT protocols, if you have trusted external randomness that select the leaders in the committees, it fully solves this problem. The kind of problem that I'm looking at. So the entire challenge is how are you going to get as close to this as possible when you don't want to do this? So the second approach, and so this is a straw man that I would pause for participation in my lecture, is what if we set the seed for round J equal to the hash of the J minus first block. So this is good for unpredictability because you're not going to know what's the J minus first block until round J minus one.
00:17:54.756 - 00:18:38.064, Speaker C: So you're not going to know the seed for J. You can't pre compute. But I think there is a huge problem with this. So this is really manipulable. I don't know actually what is common nomenclature. I believe that what I'm using is consistent, is that I would call this like a stake grinding attack because there is basically an unlimited set of things you can try, so you can try adding, removing transactions, you can try changing whatever you want and every time you change the contents, you're going to change the hash. And so what I would do if I was leader for J minus one, I would just grind the block contents and make it so that I get a good hash for the next round and then I'm going to be the leader again.
00:18:38.064 - 00:19:13.710, Speaker C: So I would just take over the chain. And I would also like to point out, so this is really, really bad because it bleeds beyond just being the leader, that in theory you could also grind so much that you're now overrepresented on the committee. And when you're overrepresented on the committee, that's even worse than just being overrepresented as a leader because now you could violate consensus. So I'm not positive exactly how realistic it is to grind so much that you violate turnoff bounds, but that is at least something that in theory is possible. Was there a question?
00:19:14.400 - 00:19:26.076, Speaker A: Yeah, Matt, I can grind also by just creating the next block, you're saying if I'm in proof of stake, this actually becomes something more like a proof.
00:19:26.108 - 00:20:20.076, Speaker C: Of work, then yeah. So I'm saying it's actually worse than that, because in proof of work how would I describe it? Let me just repeat this part, is that the moment I'm the leader once, if I have enough computational power to make myself the leader next round, I will just always be the leader so I can fully take over the chain. Like, there's some minimum threshold of if I have at least this much compute, then I can take over the entire chain. Whereas in proof of work, you can invest a lot of compute and take over a fraction of the chain. But if someone else chooses to match your compute, then you're still only 50%. But here there's just a threshold which says as soon as you hit that threshold, you just own the entire chain. And it doesn't matter if someone else has 100 times as much compute as you.
00:20:20.076 - 00:20:24.710, Speaker C: You've locked it down. Did that answer the question?
00:20:25.480 - 00:20:52.110, Speaker A: Yeah, but I'm just thinking that in proof of work, you can say, okay, there's a threshold that's exogenous, that depends on what are the competition what's the competition doing. Here you have a threshold that defined within the protocol, respectful to what other people are doing. But in both, there's kind of like an assumption the protocol works because it can't grind too much.
00:20:53.360 - 00:21:24.928, Speaker C: Yeah, sure, okay. I think that's fair to say. It's maybe not fundamentally different. I think it's fair to say that at best you're just reverting to proof of work. And I would say this, I do feel like is still worse, because even if well, okay, we'll see a little bit later. But basically, even if I just do like ten hashes, this gives me ten times the probability of being the leader in the next round. Right.
00:21:24.928 - 00:22:01.520, Speaker C: And so I think something about that is still, I think, very different than proof of work, but I'll get into that aspect in a little bit more detail later. But, yeah, I think it's fair to say at best you just revert to proof of work. But I do think it's worse than that. So here's approach three. So the first place I saw something like this was algorand. I don't know if there's an earlier reference or if this is something people have considered for a long time, but I thought this was really clever. And so basically what they wanted to do is they said, like, okay, stake grinding is bad.
00:22:01.520 - 00:22:31.592, Speaker C: It's bad to let the seed depend on contents that you can just set however you want. Let's have the seed depend on something you can't control, but still something that's going to change from round to round. And so the idea here is you say, okay, let's look at round J minus one, and let's just look at their credential, right. So they cannot control their credential that's just they digitally sign last round seed. They hash it. The digital signature is deterministic. Hashing is deterministic.
00:22:31.592 - 00:23:26.750, Speaker C: And so they can't control this. So just to elaborate on what this means, conditioned on being leader, there's nothing you can do to change the seed for the next round. Once you're the leader, it's a deterministic function of your stuff. And the other thing that's nice about this is that because it requires your digital signature, that until you actually announce yourself as a leader in round J minus one, nobody knows the seed for round J because nobody else can compute your digital signature until you actually participate, they don't know what's going on. So that's nice. And if you want to think about what that means, so this thought is going to be relevant for later, when you're trying to plan for the future. You can think like, what do you know? You can say like, well, I see the seed for this round and I can imagine what would happen if I were to win.
00:23:26.750 - 00:24:35.828, Speaker C: If I were to win with any of my accounts, I do know what the seed would be next round. And then when you want to imagine what would happen two rounds from now, you can only talk about those seeds assuming that you win in the next round, because as soon as someone who's not you wins, that's a digital signature that you can't compute, so you have no idea what the seed is going to be. So what I would say is if somehow you believed that every user has exactly one wallet and no one can create multiple wallets or something like that, then I would say this also to me seems sorry, I shouldn't have said perfect. It seems really pretty good and maybe at the very end we can talk about how you can be very creative, that it's still not maybe still not quite perfect, but it's pretty good if everyone has only one wallet. And foreshadowing towards what's the interesting math we're going to do is you can think about what you might do if you had multiple wallets, if you were participating in this protocol. Yes. Can you grind over the public keys that you register? Like, if you know that you're going.
00:24:35.834 - 00:24:36.932, Speaker A: To be a leader for a while.
00:24:36.986 - 00:25:58.480, Speaker C: Can you manipulate your public key that you're going to rotate? Good question. If I were actually designing a protocol, what I would suggest is I would say nobody is going to be the leader for more than like ten rounds in a row or 15 rounds in a row, or certainly not 100 rounds in a row. So I would say whenever you create a public key, you're not eligible to be the leader for at least 100 rounds in the future or something. And then I would feel pretty safe about that, because as long as there's a single round that you lose between when you registered and when you're eligible to sign, then there's no way that you could have had an advantage over choosing that public key. Or maybe even let me phrase it as when the stake is moved between public keys, there should be some lag between when the stake is moved to a public key and when that stake is eligible to be a leader. And as long as there's one round between when the stake is moved and when you're the leader, you can't possibly have had any statistical advantage in moving it to a specific public key. So another thing that you might try so just to recap the approach, three is the one I'm actually going to do math for later in the talk, but I still want to highlight like, what are alternatives.
00:25:58.480 - 00:26:39.768, Speaker C: So another approach is you could do some very expensive operation to set a bunch of seeds at once. So, for example, maybe you say that I'm willing to use multiparty computation, but I can't do multiparty computation every 13 seconds. I'll do multiparty computation once a day. I don't actually have a sense of how feasible that is. But you do multiparty computation once a day or once a month or whatever the right timeline is. And then what do you do? You just set up a chunk of seeds all at once. And so what's nice about that as well? MPC is really secure, so you're not going to manipulate any seeds by participating in MPC.
00:26:39.768 - 00:27:13.428, Speaker C: So that's nice. The downside is that the seeds are predictable, like many rounds in advance. And so, again, so maybe I will skip the pause for lecture style discussion, but I think it's harder to quantify exactly why that's bad. I don't have a good mathematical model that says like, oh yeah, here's a clean explanation of why this is bad. So, like, the stuff I typically think about, there's no selfish mining. You can do just you can't manipulate anything. You know what it is, but you can't change anything.
00:27:13.428 - 00:28:12.680, Speaker C: And so then I think the question is a little bit more outside the box of like, what would you do if you knew that you were the leader 1000 rounds in advance? And I can think of some things, I don't know if other people, since it's on tape, want to say other things you could do. But it makes it a little bit easier for me if I wanted to solicit bribes for my behavior in that round because I have a little bit of a window in advance to actually solicit them. It's not like you can't do this if you only learn 13 seconds in advance, but it's just easier if I have some lead time. The other thing that I would say is maybe closer to stuff I think about is like, yeah, if I knew I was a leader for like four blocks in a row, I would definitely get better mev out of that. I don't have a good. Sense in practice of how significant it is, but my understanding is that it's definitely nontrivial that you can get more mev knowing that you're the leader of four rounds in a row. So I don't know if there are other major concerns, but these are the two things that come to my mind about why predictability is bad and it's just kind of like orthogonal to manipulation.
00:28:14.220 - 00:28:15.288, Speaker B: If you know who's going to be.
00:28:15.294 - 00:29:02.504, Speaker C: Elected, you can focus your resources to corrupt them. Right? Yeah, sorry, I'll just repeat what was just said. That's also true that if you are an attacker, and I guess what's a little challenging is that you would know that you're going to be the leader because you can compute your digital signature. And it may be risky for you to broadcast that, but I would still have to compromise you to learn when you're the leader or something like that. But I do agree that it's still just like one more security issue to worry about. But I agree with that. So the last thing at least that I'm aware of, there may be other things out there, but the last way that I'm aware of is you could do some kind of hybrid between three and four.
00:29:02.504 - 00:30:17.340, Speaker C: So what do I mean by that? I mean, there's no expensive computation, but you're still setting a chunk of seeds all at once. So what you could do is I could say maybe every thousand rounds or every 10,000 rounds for that round only, I'm going to use the initial Algorand approach. I'm going to say the leader of round 999, their credential is a seed for round thousand. And then for the next thousand rounds, I just hash the seed, right? So there's no influence on seeds thousand and one through 2000, through 1999, but seed Thousand and Seed 2000 and seed 3000, those are chosen by the same thing. It's definitely not secure like multiparty computation because in the round where you're setting the next thousand seeds, you can definitely manipulate those. The question is sort of like, I mean, how much can you really benefit if you manipulate a string of 1000 seeds? Yeah, you definitely will gain something, right, by having multiple options. Like you can probably increase your representation by a little bit, but it's definitely not going to be significant when averaged out over like 10,000 or 100,000, however many rounds.
00:30:17.340 - 00:31:05.808, Speaker C: So it's kind of in between. You still get the predictability issues that you do by using multiparty computation, but you don't have to use multiparty computation. And you get like a little bit of the manipulability issues, but you largely don't have to worry about them at the same scale. And so what I learned, I guess it's not so recent anymore, but at least last summer when I was doing more prep for the first time, I gave a related talk. I normally motivate this model by saying this is what Algorand does, and then I had to change, say, well, this is what Algorand did for like the first five years. And Algorand recently pivoted to something like this instead of the one that refreshed the seed every round. Sorry, what's the advantage of this one? So the advantage would be over the previous over multiparty computation or over the previous one.
00:31:05.808 - 00:31:54.364, Speaker C: So the benefit would be it is just less manipulable. So think of it as like if I gave you so imagine if every round you're manipulating the seed for the next round, having two choices for a seed for one round, that will help you every single time. If instead it's two choices for a string of 100,000 seeds, then I would ask you, okay, by turnoff bounds, you're probably winning very close to the same fraction of both of those. Yes. In terms of raw numbers, you're going to win more in one than the other, but averaged over 1000 rounds, it's just not that much. Just to recap the approaches. Okay, so the first one I would say is certainly viable, but is just pushing it off to trusted randomness beacons.
00:31:54.364 - 00:32:30.124, Speaker C: The second one I don't think is viable at best is just proof of work. And I think like I was telling Jake, but I think is worse than that. So I think the three viable ones are these guys. And just as a reminder of the trade off. So I think for four versus five, I think that's just a crypto question as to do you want to get rid of the mild manipulability in favor of using heavier crypto? I don't know that's a resources question for three versus four or five is exactly what Andy just asked. I would say the trade off is with three, you have near term manipulability. That's what I'm going to focus on in the rest of the talk.
00:32:30.124 - 00:33:36.828, Speaker C: But you don't have long range predictability for the latter two. You have long range predictability, but like either no or minimal predictability. And then I just want to highlight an orthogonal concern, which is that for all of these, you can still ask, is it possible to manipulate enough seeds? Not just that you're the leader slightly more often, but you manipulate the seed so much that you can get higher representation on the committee. I'm not aware of attacks that I've thought through that would get you all the way to here, but that's just an orthogonal concern to highlight. That should kind of be on the mind is that it's not just about being the leader, that if you can really manipulate so much, you are getting more chances to be higher represented on the committee. And if you're starting to get like an exponential blow up in the number of seeds that you can consider, then that would start to be a concern for this. So what I'm going to do first is here's a quick reminder of the framework and the one I said I'm going to focus on is the initial Algorand proposal, which just says in every round there's a leader.
00:33:36.828 - 00:34:05.092, Speaker C: That leader's credential just becomes a seed for the next round. Okay, so let's think about how this can be manipulated. So maybe you figured this out if you were thinking from when I mentioned it on the previous slide. So what I would do, I would definitely spread my stake across as many wallets as possible. I would make them all very small. And here's what I would think through. So if I owned two wallets and they both have smaller credentials than everyone else, so this means I have two wallets that both would be the leader.
00:34:05.092 - 00:34:42.948, Speaker C: If they were the only one that I chose to broadcast to everyone else, then what I would do is I would realize this and I would say like, well, I'm going to choose which of these ones I'm going to broadcast to everyone. I'm not just going to blindly broadcast both. And what this does is this gets me two choices for what the seed is going to be in the next round. And what I would do is I would just evaluate these two seeds, see which of these seeds looks better for me in the next round. So this is some intuition for what I would do. I'll analyze manipulation that looks very similar to this and then I'll talk about how you would do the optimal thing afterwards. Okay, so what does I would say let me make a formal game out of this.
00:34:42.948 - 00:35:55.100, Speaker C: So I would say every participant, I guess I called them miners on this slide, but every participant has some fraction of stake and the initial seed is just going to be a uniformly random number. And every miner at the initial part of the game, they can split their stake into however many wallets they want. And what happens in every round? So every wallet computes their credential and their credential is drawn, as we discussed earlier, from an exponential distribution with rate equal to the size of the wallet. And what I want to highlight is that every participant can compute their credential for any wallet they own in any potential seed because all they need to do is they digitally sign and they hash. They can do that for any seed and for any wallet they own. They cannot do it for any wallet they don't own because they don't know how to do the digital signature. Okay? So I'm not going to explicitly model computation in this, but I'm just going to say that the miner in terms of what information do they have, they have access to all of this information and they have access to none of this information when they're making decisions.
00:35:55.100 - 00:36:30.872, Speaker C: And so now what's the actual game is, every wallet can either broadcast or not broadcast. That's the entire game. And the leader of the round is just among the people who broadcast, who has the smallest credential, that Credential becomes a seed for the next round. Okay, so that's the entire game. And what is your payoff? Well, you just want to basically maximize the fraction of rounds that you lead. So this is maybe, I think this is a very good proxy for, I think what I would try and optimize in practice, it's not perfect because there are higher mev rounds. I would really want to win the higher mev rounds more often.
00:36:30.872 - 00:37:27.076, Speaker C: But let me just start with this and say that even if you're just blindly doing this, you're going to be in better shape than if you're just honest. The last thing I want to do is discuss. So if you guys are familiar with selfish mining, there's a parameter related to selfish mining that they call gamma, and that refers to how well connected are you in the network. And so for selfish mining, what's relevant is if you withhold a block and I hear that someone else sends a block, how quickly can I propagate my block in response to that to other people in the network? So they use gamma for that. We chose a different Greek letter, but it captures the same thing, which is just like when I'm choosing when to broadcast. What fraction of other broadcasts have I already heard? So, for example, beta equals one corresponds to being very well connected. And that means that I decide what to broadcast after hearing everyone else already make their broadcast.
00:37:27.076 - 00:38:16.276, Speaker C: Beta equals zero means I'm very poorly connected. That means I have to decide what to broadcast before I know what anyone else is doing. And so here's a quick so. I will not make you guys actually answer this live, but the quick math test is you can just think if you have an alpha fraction of the stake and the game has parameter beta then you can think through what is the distribution of the minimum credential that you will see before you decide what to do. And if it helps just a thing. So that's an exponential with rate equal to a beta fraction of the one minus alpha stake you don't own, that's going to be the distribution of what you see before you broadcast. And then after the minimum Credential you can also think through because you want to optimize for what are you going to see after you broadcast.
00:38:16.276 - 00:38:40.912, Speaker C: And you know what that's distributed like. So you should use that when you do math to figure out what you should do. And so what that's distributed like is there is a one minus beta fraction of the one minus alpha fraction of stake you don't own, and that's going to be independent of everything you've seen so far. So you don't need to memorize these formulas, but this is just to show that, yeah, you can compute this and you should use this information when you're optimizing what to do.
00:38:41.046 - 00:38:46.944, Speaker A: How important is the assumption that everyone else is honest, like if you were like a Nash Equilibrium?
00:38:46.992 - 00:39:20.304, Speaker C: Yeah, good question. So I answer this question a lot. Whenever I give talks on this, I view what all of the stuff I do I view as more like impossibility results in the sense that everyone wants their protocol to be followed. So what everyone really wants is at minimum their protocol to be a Nash equilibrium. Right. So if their protocol is an Ash equilibrium it's not crazy to say people will follow it. Maybe if you're really an economist you want more than just a Nash equilibrium but you probably want at least that.
00:39:20.304 - 00:40:17.968, Speaker C: And so everything I'm doing is I'm trying to understand whether it is a Nash equilibrium or not to follow the protocol. And if it's not, how far is it from being a Nash equilibrium? So you might tell me, you're like, yeah, you're telling me that you can get zero 1% additional revenue by being dishonest when everyone else is honest. Maybe that's fine. So I'm interested in understanding how much can you gain when everyone else is honest? Yeah. Did I answer the cool? So I think in terms of a positive result for finding an Ash equilibrium that is super hard and I'm not actually aware of clean results for any of the previous models or this model that says here's an Ash equilibrium, I think that's very hard. So let me show you a very simple profitable strategy that I will call the one look ahead strategy. And I think, well I will definitely present it and I may skip some of the math I had in here.
00:40:17.968 - 00:40:54.124, Speaker C: So what's the simplest thing I would do? I would say I just want to maximize the probability I win the next round. I don't want to sacrifice winning this round. And let me also just present it in the simplest case when I'm really well connected, I see everyone's credentials before I broadcast. So what would I do? I would say I have some set of wallets that are small enough to win. I'm definitely going to win if this is non empty. I'm not going to play very sophisticated games and lose when I can win. So what would I do? I would just compute for every wallet I own.
00:40:54.124 - 00:41:36.868, Speaker C: I would say what is the minimum credential among all other wallets I own? Next round. If I win with wallet w right now. Okay, so this says I want to find next round. What I know is that I do want the smallest Credential possible that's more likely to win because everyone else's credentials are drawn independently of everything anyway. I don't know anything about them other than that they're distributed according to exponential. Iterate one minus alpha. So what I'm going to do is I'm going to say which wallet among mine that can win gives me the best Credential in the next round.
00:41:36.868 - 00:42:16.488, Speaker C: So just to repeat that, I'm saying for each wallet that induces a seed for next round. For each seed for next round, I sign it and hash with every single one of my other wallets and I see what's the smallest. And then among all of those, I take the smallest one. I say, that looks best to me. I go with that Credential for this realm. So I'm going to maybe not pause on the calculations, but I'll just highlight how would I analyze this. So what I want to do is I want to say, okay, that sounds great, how do I figure out how good this is? So the first thing I would do is I would say, what's the probability that I have K wallets to choose from? Okay, so this is the answer.
00:42:16.488 - 00:43:14.472, Speaker C: And then you can ask what's the probability? Given that I had K things to choose from and I went through this process, what's the probability I win next round? For the best Credential that I take, remember that I had K different wallets. So this is k different seeds. For each seed, my best wallet in the next round is distributed like exponential of rate alpha. I get to do this K times independently and take the Min. So if you remember the fun fact from before, this means that I have the Min of K independent exponentials of rate alpha. So that means that my best Credential next round is going to look like an exponential of rate K alpha because I got K times the options the others, no matter what, they're going to be distributed like exponential of rate one minus alpha because whatever happens there is independent of whatever I did. Because I can't do any of their digital signatures anyway.
00:43:14.472 - 00:43:58.250, Speaker C: So whatever happens for them, as far as I'm concerned, is independent of what I choose to do. So that means that by the second fun fact, that mine is smallest with probability k alpha over one minus k minus one plus this. That's just because right, I sum the rates that's this and then minus smallest with this. Okay, cool. So what that means is that maybe you can see this is definitely much better. As K grows, this is getting much, much better. Okay, so now what's the next step is okay, so if I want to say great, now I want to figure out what's the fraction of rounds that I win, this isn't enough.
00:43:58.250 - 00:44:52.136, Speaker C: Because this is saying sort of like, given that this round was unbiased, I can compute this, and given that I happen to win this round with K, I know what this is, but this doesn't tell me how to really average over all rounds. So I think what I'm going to do is skip over that part of the math. But I just want to point out that there is math that fits in just here twice that fully says exactly what the answer is. So the answer is this divided by this. That's the answer. So that's how good it is, it's always strictly better than alpha no matter what alpha is. And just to give you a sense of this magnitude well, actually I don't know what that much is.
00:44:52.136 - 00:45:19.090, Speaker C: Maybe someone will tell me this is a lot. It's not that much, but if you have 10% of the stake then with this strategy you can get almost 10.1% of the rounds. So I don't know what to make of that. I think 10.1 is not that much bigger than ten, but that's probably a lot of money. I don't know that there are stakers that are quite this big in the algorand or ethereum landscape, but these numbers are starting to grow by a bit more.
00:45:19.090 - 00:46:03.570, Speaker C: So it's modest, I think it's like not trivial, but it's not like you're doubling your reward. Okay, so I just want to maybe start moving towards wrap up by noting that I presented the idea when you know all the credentials because that's the conceptually simplest to understand. The same ideas work if you don't see anything in advance. So what would I do then? So I'd say like, well, it's definitely not going to be quite as good as this. So it's harder because if I choose to not broadcast my lowest credential, that might cause me to lose when I otherwise would have won and I just won't know whether that's what's happening. But why it's still profitable is I was like, well, I mean, if I happen to have two credentials, they're like extremely close together, right? So I have a 0.1 and a zero one.
00:46:03.570 - 00:47:01.136, Speaker C: There's some probability that that happens and when that happens and one of them gives a much better seed next round, then I may as well hide the other because I think it's reasonable to conclude what we actually know. The probability that it lies that I would have won with my 0.1 and I would have lost with my zero one is super small and the benefit that I get in the next round will probably dwarf whatever that probability is. So I should just go for it. That's not a proof, but that's like intuition and the math backs that up. Okay, so the other thing I want to do so I know that I haven't given a selfish mining talk and I don't know how well everyone in the audience is knowledgeable about that, but just to compare to similar kinds of claims for selfish mining and longest chain protocols is, I would say, the big distinction. So first I mentioned that this parameter beta is really conceptually the same thing as gamma from selfish mining.
00:47:01.136 - 00:48:03.056, Speaker C: It just refers to how well connected you are. And in selfish mining if you are poorly connected, then honesty is optimal as long as you're not that big. And for proof of stake longest chain, the same thing holds. Okay, so just to repeat what that means, if you are very poorly connected in a longest chain protocol and you are not that big, then just following the longest chain protocol is optimal to nash equilibrium. For everyone to do that, we know that there are some settings. So like if there are transaction fees or mev instead of the block reward or you don't have external randomness and you have to do everything internally, then these are more like this where you're poorly connected but you can still do something strictly profitable no matter how small you are. So that's like how I think of the big distinction is do you need to be big in order to strictly profit or can you strictly profit even if you're tiny? And so this one is you can strictly profit even if you're tiny.
00:48:03.168 - 00:48:13.640, Speaker B: Yeah, so when you did the first half of the slide, I don't think in your intuition of why it still works with beta equals zero, you mentioned state being big or small, but now you seem to be saying it matters a lot for that intuition.
00:48:16.220 - 00:48:17.608, Speaker C: Sorry, can you repeat the question?
00:48:17.694 - 00:48:28.750, Speaker B: So above you said, oh, it's still going to work when beta equals zero because just think about this one case. Yes, but then maybe I misunderstood but now I thought you were saying that actually that intuition is wrong if you're small.
00:48:29.140 - 00:49:46.970, Speaker C: No, sorry, I wasn't saying that. Sorry, I can try to quickly repeat what I was saying here is I think that how I like to classify manipulability of protocols is basically, do you need to be big to profitably manipulate it or can you do it no matter how small you are. And so the proof of work with the block reward, you need to be big in order to profit by doing something like selfish mining proof of stake with trusted external randomness, you need to be big in order to profitably do something like selfish mining. And then on the flip side there's like proof of work with transaction fees or mev, where no matter how small you are, there's something you can do that's strictly better than being honest or proof of stake where there's internal pseudo randomness there's no matter how small you are, there's something strictly profitable you can do. And I was saying that this class of BFT protocols is more like the latter, that no matter how small you are, there is something strictly profitable you could do. Okay, so I definitely don't have time to do this, which is fine, let me just give, I'm just going to read this and then I'm going to click through the math and I'll again say if anyone thinks like the math here is cool, I'm very happy to chat about it. So the one look ahead strategy is basically like I want to win the next round as often as possible.
00:49:46.970 - 00:50:31.988, Speaker C: Following a round that's unbiased. And something better you could do is you could be like, I'm going to try and win the next two rounds as often as possible. And starting from a round that's unbiased. And what's even better is you should really just look is with all the information you have, you can compute your if I win for this round and I win with wallet W two next round and I win with wallet W three in the third round, what will the seed be in round four? You can compute that. You should do that. And you should look super far in the future and consider all these possibilities and just say which of these looks best for me in terms of optimizing the fraction of rounds that I win? So you can do that. You should do that.
00:50:31.988 - 00:51:19.568, Speaker C: So one thing we did, so we worked through, we do have like a purely theoretical upper bound on the best you can possibly do, no matter how far you look in the future. And I don't think this is close to tight. So just to give you a sense of the magnitude, I showed you a strategy that went from ten to 10.8, and this is saying you can't improve it better than 21 point eleven. Right? So I don't think these bounds are anywhere close to tight, but they're something. And one reason they're not anywhere close to tight is that they also hold against a really omniscient adversary who has more information than our player does because they can digitally sign on other people's behalf. So they can't change the seeds, but they can see what would the seeds be if someone else won and digitally signed or blah, blah, blah.
00:51:19.568 - 00:51:52.610, Speaker C: So even for there, there's some upper bound, but I don't think that's anywhere close to tight. The thing that I'm more excited about, but that has proven to be really hard, is I want to basically do it simulation based because I do not think there's a closed form for what the optimal thing is. Sorry, there obviously is a closed form. I don't think we're going to find the closed form. I don't think it's going to be tractable. So I think what that means is it should be done with simulations. And maybe the thing I want to do is I just want to make sure that whatever simulation we run is going to be provably close to whatever the right answer is.
00:51:52.610 - 00:52:41.516, Speaker C: This part I'm going to skip for the math. Or like, how do you take steps towards something being provably close? The one last new thing I want to say I just showed you in theory, and there's a lot of prior work in theory that says that in practice there are network, hash rate, whatever conditions, that show that there are players who can strictly profit from deviating. So, for example, I just showed you, I think, an accurate representation of Algorand for like the first five years it existed. And anyone who was staking in Algorand could have done this. And as far as I know, it was not detected. Right. And all of these attacks with one exception of the one I showed you at the front, most of these strictly profitable attacks in theory, are overwhelmingly not detected in practice.
00:52:41.516 - 00:53:27.804, Speaker C: And so you're going to ask why is that the case? So just to confirm, you have a permissionless protocol. So it's not like you can figure out who did this attack and go and ban them or blacklist them or something. You can spread stuff out among lots of wallets. It's not going to be clear which one was being malicious and who was just offline. This one I just showed you is profitable again, even for very small people. And it's definitely true that for smaller altcoins, people have had enough of the hash rate to actually selfish mine or do things that have been known for like nine years or whatever. And the most convincing argument I've heard in response is that, look, all of these deviations I showed you that you can get a little bit of extra BFT coin by doing this attack, and it will definitely be detectable that someone is doing it.
00:53:27.804 - 00:54:03.832, Speaker C: So I can discuss in a second why would it be detectable. And so what I might be concerned about is that, yeah, someone detects that someone's doing an attack, it tanks the value of the currency. And now I'm really excited about my 0.8% extra BFT coin, but they're worth like half of what they were before I launched the attack. And now all of a sudden, it doesn't seem so profitable. Detectable is that someone is doing it and traceable is who is doing it. So if I wanted to say specifically, I think you are selfish mining, that's really hard to do because it's permissionless and like maybe you were just offline, I saw two blocks come at the same time.
00:54:03.832 - 00:54:29.148, Speaker C: One of them was honest. One of them is from the selfish miner. I don't know. I don't know which is which. So that's what I mean by traceable versus detectable. But it's going to be very obvious if someone's selfish mining, there's all these forks for some reason. So this is a project with Miriam Was to ask sort of like, well, is it possible to do something strictly profitable in a way that's undetectable? So it really just looks like things are operating as normal.
00:54:29.148 - 00:55:13.548, Speaker C: So, yes, for the longest chain protocol, there is something you can do that's strictly profitable and undetectable. So. What I mean by that is it looks like there's just a little bit more latency than natural in the network and it looks statistically identical to that. But you're getting more profit this ongoing work. So what we've shown is that actually for leader manipulation, that's actually not possible in the poorly connected case. So what I mean by that formally is that when you're poorly connected, no matter how much hash rate, you have no strategy satisfies the following two properties. First, strictly profitable would mean that you win more than an alpha fraction.
00:55:13.548 - 00:55:53.740, Speaker C: Of the rounds. Second is the distribution of the leader's Credential in each round should still look exponential in something. So for example, if everyone is honestly following the protocol and everyone is online, if I look at the distribution of the minimum Credential over all rounds, it should look like an exponential with rate one, right? That's what should happen. If c fraction are online and honest every round, it should look like an exponential of rate c. And if somehow the distribution you see is not even exponential at all, then someone is hiding stuff or going online. Offline. Online offline.
00:55:53.740 - 00:56:21.524, Speaker C: So just to repeat what the theorem is, is that this particular detection method will catch anything that is strictly profitable for beta equals zero for being better connected. That's the ongoing part. So I mentioned that this isn't a completed project. The ongoing part is here. It turns out to be much more complicated. But if you force me to conjecture, I would guess that it's probably also true for larger beta too.
00:56:21.642 - 00:56:24.216, Speaker B: Yeah, this is basically saying like in.
00:56:24.238 - 00:56:40.200, Speaker A: An asymptote, it can't be justified in asymptote. Do you have any notion of how fast it converges towards this? Asymptote if I was interested in some sort of clomogara sphere test?
00:56:40.270 - 00:57:27.044, Speaker C: Yeah, so I think it depends on sort of like so then you have to go back and try and trade off. How much are you like, what does it mean to profit in a short term versus be detectable in a short term? I think that makes the question a lot messier because then you say like, okay, I want to maybe make a lot of money in one week before anything gets detected. And you can ask that question of how much money could you make in one week, subject to deviating from an exponential buy at most, blah. But I think I'm just saying you would need to change a lot about the question and what counts as reward, I think, to really make that into the model. Okay, so that was the last thing I wanted to say. So here's the summary. So I introduced, I would say, a canonical model for leader selection.
00:57:27.044 - 00:57:58.896, Speaker C: It's definitely not the only one. I introduced a couple of different variants that are used in practice for how to randomly select a leader. And then Tim noted that you can also do it with like round robin if you're not concerned with predictability. It's possible that there are other paradigms out there that I'm just not aware of, but those are the ones I'm aware of. So I showed you a simple strategy that's always strictly profitable. I gave you a very loose bound, a theoretical upper bound on the profitability. I didn't give you details of this, but there is basically a recursion you can set up to describe the optimal strategy.
00:57:58.896 - 00:58:41.840, Speaker C: And then the game is to how do you make a provably correct simulation for simulating that recursion. And then I briefly mentioned undetectability. Okay, so last notes is I focused on this canonical model, but the ideas definitely apply to other protocols. So the ethereum's Randall doesn't fit verbatim into this model. But the same kinds of ideas of not broadcasting when you should broadcast, they definitely apply there. And I've actually been meaning to look at this specifically and try and analyze it, but I just haven't gotten around to that yet. The other thing I want to remind is that these issues can be avoided if you're willing to use heavy tools.
00:58:41.840 - 00:59:27.280, Speaker C: So like, if you're willing to use multiparty computation, then it's not manipulable. You're in good shape. I believe that VDFS would also suffice that you can I believe you could probably replace MPC with VDFS, but I think it's still I'm not aware of a concrete, all the way detailed proposal of how to use VDFS for that. But I feel like my intuition is if someone writes it down carefully, I would expect it to probably work without these heavy tools. We talked about that the trade off is between predictability and manipulability. That if you're willing to say, do round robin, then it's predictable but not manipulable. If you want to change it every round, it's manipulable but not predictable.
00:59:27.280 - 00:59:58.812, Speaker C: And I will still say I'm curious whether it is possible to somehow get both without the heavy crypto tools. And it feels really hard. It feels like it might be impossible just because people have been trying to do it for six years and haven't done it. But I actually don't know. I don't know, sort of like a candidate proof approach for showing something like that. So I do think that's interesting to understand. What are the limits of this? Okay, sorry for going a little bit over, but that's everything I have.
00:59:58.812 - 00:59:59.724, Speaker C: Thank you.
00:59:59.922 - 01:00:34.730, Speaker A: About the reason why we have not observed an attack so far, I think that actually it's a really serious thing. If I can only own like 10% of the stake and I can tank the value of the coin by to its 10%, let's say from 100%. Because in this case, even though the 10% I own will lose its value, I might short the coin's value with much larger amounts of money. And I can make a net profit in this case, even though if I just restrict my payoff to the currency itself, it seems like I am losing money. But I can actually get money in real world.
01:00:35.100 - 01:01:22.320, Speaker C: Yeah, my take is I definitely agree with that and I think that is definitely a concern. If you were to ask me though, still in terms of why has it not happened yet? In practice, I would still guess that sort of like that's a very risky play to make and you would have to be pretty confident in exactly how much you're going to tank the value by in order to believe that your short is going to work out. So I do think there is definitely like a positive expected value play you could make along that form, which is you have some belief about how much you're going to tank it. You short for the right amount, you hedge, whatever, and you do the attack and hope what happens. But it's probably a really high variance play. And I don't know if anyone here has a legal background. I would guess in the US.
01:01:22.320 - 01:01:56.288, Speaker C: That's probably illegal too. So that would also explain why no one's tried that specific thing in a developed western country. But I definitely share your concern that unless you're going to rely on the fact that something is illegal or the fact that people don't make risky plays or whatever, that my understanding is that the short market is large enough now to try and do something like that. If you thought you had a good enough estimate. I think that's right. Okay.
01:01:56.374 - 01:01:57.116, Speaker B: All right. Thanks, Matt.
01:01:57.148 - 01:01:57.710, Speaker C: All right, thank you.
