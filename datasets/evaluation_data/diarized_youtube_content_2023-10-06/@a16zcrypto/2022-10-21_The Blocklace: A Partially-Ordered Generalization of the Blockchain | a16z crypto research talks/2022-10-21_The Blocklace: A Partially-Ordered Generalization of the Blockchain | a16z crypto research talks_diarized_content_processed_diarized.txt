00:00:06.360 - 00:00:06.910, Speaker A: You.
00:00:08.960 - 00:00:34.100, Speaker B: Very pleased to introduce Edward Shapiro from the he's a professor at the WiFi Institute. Definitely one of the more interesting people I've ever met in computer science. Some of you have already had a chance to talk to him, I hope the rest of you do too. He's a lot, he's a lot of people to talk to and has done many, many different things over his career. Currently he's actually quite interested in web three and specifically today he'll talk about the new census work like the black license.
00:00:35.480 - 00:01:03.484, Speaker A: Thank you. Thanks Tim, for inviting me. I already had some great discussions in the morning, so I'm looking forward to continuing them today. And if you have any questions during the talk, feel free to ask them during the talk. No need to wait till the end. So this way I understand better what you don't understand about what I'm talking about. So the talk is based on three papers, all are available online.
00:01:03.484 - 00:02:01.800, Speaker A: One is a foundational computer science paper, but the appendix actually describes the blocklace, which is the data type I'm going to talk about as the basis for the protocol stack. Cordial Miners is a joint paper with Idit KDAR and Odet Naur from the Technion and that's the new consensus protocol that I'm also going to talk about. And third paper is on sovereign cryptocurrencies and I've already spoke to a couple of you in the morning about them. I will mention them, that's not the main topic of the talk, but I'll just mention them because they're relevant for the value of the stack as a whole. And if there are time for questions, I'll be happy to answer at the end. But all are available online and I will share the PDF of the links so you can access them if there's interest. So I was thinking whether I should call it the holy trinity or the unholy trinity.
00:02:01.800 - 00:02:42.632, Speaker A: I said, wow, this will offend these people, this will be strange. So I said just the trinity. The trinity of distributed computing. Okay, dissemination is the first task. Let others know what I say or no, that's dissemination, equivocation exclusion, resolve equivocations in what I say, double spending. So if I tell team one thing and I tell Andy something else and they're inconsistent, then eventually we should figure this out. You should figure out that I'm telling different things to different people or double spending your money even worse.
00:02:42.632 - 00:03:45.056, Speaker A: So that's another task. And the third task is ordering. So you should order everything everyone said and this is necessary. For example, it turns out it is not necessary for financial systems that you can do asset transfer networks just with the provocation exclusion without ordering. But if you want to do smart contracts where everyone agrees on what's going on and what instructions or actions are being taken in what order, then you need full ordering consensus. So these are the three things that need to be achieved and for example, Blockchain Consensus achieves ordering and they should be achieved in the face of faulty Byzantine malicious agents or miners or adversaries. And there are various notions and definitions, but it gets interesting or difficult when they're faulty or malicious agents.
00:03:45.056 - 00:04:20.510, Speaker A: These three tasks are solved by, for example, Nakamoto Consensus. Part of the protocol includes the dissemination, the protocol includes ordering. And it turns out that once you have ordering, it's very easy to do equivocation exclusion. All the transactions are ordered, and if there's an equivocation or double spend, you just ignore the second one and that's it. So ordering solves equivocation exclusion. But as I mentioned, one fundamental result in distributed computing is that you can resolve equivocations without ordering. That's why it's a separate point.
00:04:20.510 - 00:04:59.684, Speaker A: So what's wrong with existing Blockchain Consensus protocols such as Nakamoto Consensus and other similar protocols? First of all, they try to solve all three problems dissemination, equivocation, inclusion, ordering jointly. So it's a black box monolithic protocol, dag based protocols, which I'll mention later, are excluded from this. The second is I contend that they're not scalable for two reasons. One, they use the data structure that's replicated. So when they say they're distributed computing, distributed algorithms, I think it's a bit of a misnomer. They're not distributed protocols or algorithms. They are replicated.
00:04:59.684 - 00:05:31.776, Speaker A: So you don't distribute a data structure, different pieces to different people. You replicate a single centralized data structure among multiple agents, miners, what have you. So these are replicated protocols, not distributed protocols or decentralized protocols. And the third, and that's specifically for blockchain protocols that are extendable at a single point at the tip. So everyone is fighting who is going to add the next block to the tip. So that's the reason why they're not scalable. And the third is that they are not affordable.
00:05:31.776 - 00:06:20.984, Speaker A: It requires high performance computers and networks. And part of what I'm trying to achieve is to be able to run things on personal smartphones. So our goal is a smartphone ready protocol stack. And that first of all, is modular. So it solves its problem, dissemination, equivocation exclusion and ordering separately. And I will show the different applications need different parts of the stack, so they don't need to pay the full price of ordering if all they need is dissemination, or they don't need to pay the full price of ordering if all they need is equivocation exclusion. And I'll talk about that and scalable.
00:06:20.984 - 00:07:05.564, Speaker A: So it uses data structure, it's replicated locally and extendable independently. And the third is affordable, so it can run on smartphones. So that's the overall goal. And this goal is part of a broader vision or goal towards digital democracy, grassroots communities, grassroots economy. But for the purpose of this talk, this is a sufficient description of the goal. And this is more or less a look at the solution, direction of the solution. So first of all, it's a protocol stack, so you have layers in the stack.
00:07:05.564 - 00:07:56.876, Speaker A: And ultimately you need blockchain consensus or something similar to blockchain consensus, but there are lower layers below that, there is consensus free. So you don't need consensus for that reliable broadcast. Typically you need a supermajority, a two thirds majority, assuming you have less than one third faulty agents, and you can do asset transfer networks or NFT trade networks using reliable broadcast alone. And what this part is novel is the suggestion that we actually want even simpler, weaker protocols, which I call grassroots, which only do dissemination or leader based equivocation exclusion. So you don't need supermajority, but it turns out that you can do equocation exclusion even without a supermajority or two thirds majority. And I'll talk about that. And these are matching applications.
00:07:56.876 - 00:09:00.324, Speaker A: So if all you want is a social network where people know what other people are talking about locally, through friends, et cetera, think about Twitter, but local feeds, then it's enough to have dissemination, local dissemination. I follow my friend's feeds, and if a friend follows a friend, then they can see also the friends of the friends, but it's local dissemination. And I have the notion of sovereign cryptocurrencies, which actually don't even need reliable broadcast. They can use leader based equocation exclusion and then everything else that you talk about, cryptocurrencies, smart contracts, dows, et cetera, need the full, the full scale blockchain consensus. So let's let's how we, how are we gonna how am I proposed to address this? It turns out that we can use a single data structure I call the blocklace. But it's not that new. I mean, other people proposed similar data structures in the past, so the name is new, but the content has been proposed in various ways in the past.
00:09:00.324 - 00:09:54.160, Speaker A: But not the whole kind of vision, but just the data structure. The best way to view it is just a partially ordered realization of the blockchain. And I'm going to show you in this talk that you can do all three things with a block list. Are you worried about the order in which I say things individually as well, or is it just what I say? Okay, there are various different definitions, but let me give you one which is confident, which fits what we're doing, that if you equivocate, then we approve at most one of the two things. So if you try to do double spend, then either this one succeed or this one succeed, or none will succeed. So it's okay, in case you double spend that both of them will not succeed. You have the freedom to reject both, or that the result will be that both fail.
00:09:54.160 - 00:10:17.180, Speaker A: In blockchain, this doesn't happen if you double spend. The first one always succeeds and the second one always doesn't succeed. So it's a more strict implementation, but the more general definition is that you cannot double spend. So if you try to double spend, you either succeed in spending once or once or never. But not both will succeed. So that's the formal definition.
00:10:17.920 - 00:10:20.930, Speaker C: I can't make a transaction and then reverse it.
00:10:21.300 - 00:10:51.800, Speaker A: Well, you're already talking about implementation more abstractly. Mathematically speaking, the outcome of a double spend should be that at most, one of the spending attempts will be successful. At most, one, but not exactly one. At most one. That's the abstract definition. That equivocation exclusion means you cannot equivocate. If you try to equivocate, you fail, either because the other thing is rejected or both are rejected.
00:10:51.800 - 00:10:59.364, Speaker A: That's the abstract requirement of equivocation exclusion. Is that okay? You're still puzzled?
00:10:59.412 - 00:11:09.636, Speaker C: I'm worried about a situation where I pay Alice, she gives me some goods, and then I get to reverse that transaction later on by having a double spend, and I got to cancel both the transactions.
00:11:09.688 - 00:11:50.270, Speaker A: Okay, so once we agree that this is abstract definition, although this is not the main topic, once we talk about sovereign cryptocurrencies, I can show you how you can achieve equocation exclusion without consensus, without supermajority, simply by the sovereign deciding which transaction to approve. If there's time, I'll talk about it. If not, after the talk. But you have a point. It's already a protocol or a mechanism to realize what you're describing. And at this level, I'm just talking about the more abstract requirement. That what you're trying to do.
00:11:50.270 - 00:12:14.164, Speaker A: The problem you're proposing cannot happen. How it cannot happen is already implementation details. Okay, so let's start with a block. Okay, so this is the block. Block has a payload and a collision free cryptographic hash pointer. Hash pointer is not really a pointer. It's just a hash value of another block and collision free.
00:12:14.164 - 00:12:44.350, Speaker A: It's our assumption or belief. We believe it will never have a collision. Okay? Very small probability. It'll have a collision. So we believe, and cryptographic, it's important because it means you cannot compute X given the hash value, which means you cannot effectively create cycles. Even the adversary, even a malicious agent, cannot create loops using cryptographic hash pointers because they cannot guess how the reverse pointer will be without the value of the pointer. Anyway, cannot happen.
00:12:44.350 - 00:13:09.344, Speaker A: That's a block. Okay? A blockchain is just a list of blocks, each one pointing to the previous one. And this one has zero hash pointers, so it has zero or one hash pointers. This is called the genesis block. And you can look at this elephant from many different directions. I know you've been looking at this elephant all the time, but for me, these are the three important properties of a blockchain. First of all, it's tamper proof.
00:13:09.344 - 00:13:37.992, Speaker A: So nobody can modify anything without people who look at it seeing that it's been tampered with another important one, which is less mentioned, but it's very important. It's not reputable. If there is something there signed by a person or an organization, they cannot deny that they've done this. You cannot deny creating this block. You cannot deny creating a signed transaction inside the block. And it's totally ordered. That's a blockchain.
00:13:37.992 - 00:14:13.160, Speaker A: Okay, any questions about what is a blockchain? Okay, now all I want to do is generalize the block so you can have several pointers, zero or more pointers. Everything else remains the same. And a block lace is just a bunch of blocks. That's all that's a block lace. Okay? So it's tamper proof, non reputable, and instead of totally ordered, it's partially ordered. That's all that's a block lace, and it's a data structure, but it induces a mathematical entity called the directed acyclic graph. So it's a bit more abstract than this.
00:14:13.160 - 00:14:40.268, Speaker A: Directed cyclic graph is a bunch of entities, edges, directed edges that do not create cycles. And remember, you cannot create cycles because these are cryptographic hash pointers. So a block lace induces a dag. So when people say, well, it's a dag, it's not a dag. It's a data structure that induces a dag. Okay? So it's a concrete data structure. Okay? So any questions? What is the block lace? Important thing is everything here is signed, cryptographically signed.
00:14:40.268 - 00:15:24.016, Speaker A: So we assume that the agents, miners, whoever have cryptographic, have key pairs and they can sign. So everything is signed, and actually you can see who signed what. And another requirement, which we'll see from the protocols, is that at least locally, every agent totally orders their own block. So when I create a new block, it must point to the previous block. So the red blocks are totally ordered, the green blocks are totally ordered, the blue blocks are totally ordered, but there is also a partial order among them. Okay? So if the miners are good, they can be bad, but if they're good, that's how they should behave. So let's look at the trinity of distributed computing and see how we can use the block list to achieve them.
00:15:24.016 - 00:16:06.124, Speaker A: Let's start with dissemination. And for dissemination, we need to let others know what I say or know. So how can I know that I know something that the others do not know? Okay, the answer is that a blockless in a blockless, a block reveals what its creator knows. Why? Because if every time I create a block, I make sure that it points to everything I already have, then people look at the block, see what I know. What I point is what I know. And the transitive closure of the pointers, the subgraph that is pointed by my most recent block is what I know. So if I send you a block, you look at it and you see what I know.
00:16:06.124 - 00:16:41.812, Speaker A: And if you know something I don't know, and you're a nice person or a kind miner or a cordial minor, you'll say, ah, I know something that you don't know. Here it is, and you send it back to me. Okay? So dissemination can be achieved in a very natural way by the blockless, by these two rules. When I send a block, it reveals everything I know, simply by having pointers to all the most recent blocks of every other miner or every other agent or whatever. And when I receive something from someone and I know something that he doesn't know, I tell him. That's all. That's blockless based dissemination.
00:16:41.812 - 00:17:38.676, Speaker A: Now, there is a huge range of trade offs in doing this, how quickly you do it, do you always do it? Do you wait a little? Do you tell him everything, even though he might know it in a microsecond later? Or do you tell him only things that happened two, three rounds ago? There's huge trade off. Now, this is a new approach, so it has not been well studied, but the problem so called reliable broadcast, which is an algorithm below the hierarchy of consensus. So it's a building block that people use for consensus. I'll mention it, people use it for consensus. Reliable broadcast is a well studied problem, which has well known, well studied, I mean, dozens and dozens of papers on reliable broadcast. And there is a well known trade off there between communication complexity and latency. And essentially the same trade off between communication complexity and latency applies also to block place based dissemination.
00:17:38.676 - 00:18:25.560, Speaker A: You can be very eager telling everybody everything all the time what you know and they don't know, and then you have very low latency and high communication complexity. Or you can be more modest and say, well, let's wait a little, let's do it probabilistically, let's do this, let's divide the work, let's do sharding, let's all sorts of tricks. And then you decrease communication complexity at the expense of increasing latency. So I will mention specifically how we do the Cordial minus protocol, which is an extreme end of the spectrum. We just do very low latency, high communication throughput but in general, every idea you have heard about on this trade off in reliable broadcast or similar protocols can be applied here to this dissemination. So that's how blockless based dissemination is achieved.
00:18:28.140 - 00:18:36.990, Speaker B: Should I be thinking about anybody proposing a block and predecessors whenever they want? Or should I be thinking about some leader selection serpentine? Both.
00:18:37.920 - 00:19:11.768, Speaker A: I will get there. For now, just think about the social network, not even consensus. When I say something, think about gossip, just social network. I say things, you say things, and if you're my friend, I want you to know everything I know that you haven't known. So every block is just an utterance in a social just think about it as a post in my Facebook page or a tweet in my Twitter at that level, that's all. Later specific protocols will do. When we have a blockchain consensus, then it'll be very specific.
00:19:11.768 - 00:19:17.380, Speaker A: But for now, just think about the most relaxed setup.
00:19:17.540 - 00:19:19.976, Speaker B: I had a question also, just to.
00:19:19.998 - 00:19:30.168, Speaker A: Make sure I'm following. Say if we took just practically like bitcoin and ethereum and say we took two L, one chains and then forced them to say every day one of the bitcoin blocks has the point of.
00:19:30.194 - 00:19:32.316, Speaker B: Both a bitcoin and ethereum block and vice versa.
00:19:32.348 - 00:20:16.750, Speaker A: So that would be a block? Yes. Okay, here is just what I said, that this guy knows all this, okay? So when say this block, this guy receives this block, he knows that he doesn't know this and doesn't know that and can tell him that. Okay? Yeah, and this guy knows only that. Okay? So the same thing holds. Okay, I mentioned trade off between message complexity and latency and all possible optimizations. Send once so you maintain a communication history. So if I told you something or you told me that you know something, I will not say it again.
00:20:16.750 - 00:20:53.336, Speaker A: Send backlog only in response. Delay, randomize erasure codes, standard techniques. Okay, so what can we do with dissemination? As I said, serverless, social network as a foundation. Think about Twitter without a server. I have my feed, Tim has his feed, everybody has their own feed. If I want to follow Tim, we are friends, he will notify me if I want to follow Andy, but I'm not his friend and Tim is his friend, then I will ask Tim to forward to me the blocks that Andy issues. And if we are friends, he will do that.
00:20:53.336 - 00:21:28.052, Speaker A: That's how it can work. Intuitively, of course, all this can be formalized, but for social network, this relaxing, we don't have to resolve double spends. If I tell different people different things, then they will just think I'm a jerk and ignore me. So it's all relaxed. Okay, that's that equivocation exclusion. How can we do Equivocation exclusion? So let's first agree, what is Equivocation here? This is an Equivocation. The blue guy, the green guy.
00:21:28.052 - 00:22:06.290, Speaker A: The green guy created two blocks that don't refer to each other. Okay? So he told the red guy this block and the blue guy this block, this block. So that's an Equivocation, that's a fault. And it can only be done maliciously. It's not an accidental fault because the green guy maliciously created two blocks knowing that they don't refer to each other. Okay, so it's a Byzantine malicious fault. As I said, the blue guy knows this one, the red guy knows this one, that's it.
00:22:06.290 - 00:22:53.868, Speaker A: But let's say there is a purple guy that happens to know both, then he sees that this is the Equivocation. Okay? So we have a notion that somehow I haven't been speaking about this a lot, but to the people I spoke with is utterly confusing. I don't know why it's so simple, but people, even my collaborators think it's confusing. So I don't know notion of approval. Approval is a relationship between blocks and basically you want to approve a block if by doing so you don't approve Equivocation, okay? That's intuitive what you want the approval. Approval is a relationship that must solve this problem. You never approve of an Equivocation.
00:22:53.868 - 00:23:32.340, Speaker A: Okay, formally, a block B, approves a block B prime if it observes b prime and does not observe an Equivocation of B prime. So even if there is an Equivocation, and I observe meaning, in the transitive closure of the pointers, okay? So every block has the blocks it observes through the transitive closure of the pointers. Okay? So if I observe a block and I do not observe an Equivocation, I approve the block. If I observe an Equivocation, I prove neither. Okay? That's very simple. If I see that someone is bad created the Equivocation, I approve. I don't approve.
00:23:32.340 - 00:23:57.812, Speaker A: I prove neither this one nor that one, but if I see only one, I approve it. So following this definition, the red guy approves this block, even though they're approvalating because he doesn't see this one. The blue guy approves this block because he sees this block but doesn't see this block. The purple guy approves neither because it sees an Equivocation. Okay? Now, it's a property of a block, not a person. The block does not approve this. This block approves this.
00:23:57.812 - 00:24:18.584, Speaker A: This block approves this. Okay? That's the definition of equivocation. I don't know, simple, complicated, confusing. That's the definition, okay? The last green block approves both. Right? This one, yeah. It should approve, yes. This one not approves.
00:24:18.584 - 00:24:39.184, Speaker A: This one does not approve. This one does not approve this, does not approve this. No. But it approves the blue block, which approves the Equilibration. Okay? Formally a Block B approves block prime. If it observes B prime and does not observe an equation. This one observes this and observes this.
00:24:39.184 - 00:25:04.548, Speaker A: Therefore, it does not approve, does not approve this, does not approve this. Also this one, okay? It does not approve. So as I said, it's a property of a block, not a person. This block approves this. This block by the same green person does not approve it. So from the perspective of the green person, he said, okay, this is fine, but then he created another block which saw the conflict. Ah, I made a mistake, or I approved it, but now I don't approve it anymore.
00:25:04.548 - 00:25:29.040, Speaker A: Whatever. What does it mean to point to blocks but not approved? Approval is a purely mathematical construction. It's a property of a graph, a property of two blocks in a graph. That's all. Think about it as an extremely abstract mathematical property relationship between two blocks. The relationship holds if these blocks sees this block but doesn't see any clovocation of it. That's all.
00:25:29.040 - 00:26:06.604, Speaker A: So it holds between this and this, holds between this and this. Sorry. Holds between this and this, holds between this and this, does not hold between this and this, because it does see this. Okay? It's just a binary relation on Dags. That's it. Okay, formally speaking, okay? Now, the important thing about it, like the magic, is that an agent can approve an Equivocation only by being an Equivocator himself. Okay? Why? Let's say the blue guy wants to approve both of them.
00:26:06.604 - 00:26:56.264, Speaker A: How can he do that? He create one block that sees only this and he create another block that sees only this. But these don't block. Block don't see each other. So in order to approve the green Equivocation, the blue guy had to quocate himself or herself. Okay, why? Because if the blue guy adds this pointer, suddenly this block sees both this and this, so he doesn't approve them. Okay, so if there is someone who is faulty but malicious and you want to support him, the only way you can support him is by being malicious yourself. So if there is a bound on how many malicious minors are there, if there is a minority of super minority of malicious less than one third, you cannot have supermajority approval for Equivocations.
00:26:56.264 - 00:27:33.290, Speaker A: That's all because if you have a bound on the bad guys, you cannot have a supermajority of the good guys that approve an Equivocation. So that's really the key thing that if you want to approve an Equivocation, you need to equivocate yourself. If the number of people who are willing to be faulty or faulty or Byzantine is bounded by minority less than one third. When I say super minority, it's less than one third supermajority greater than two thirds. Think about it this way. You cannot have a supermajority approval for Equivocations if you have a supermaority of faulty miners. I'll go back to that.
00:27:33.290 - 00:28:38.460, Speaker A: So this shows that if you use supermajority for approving transactions, then you cannot have provocations and can have asset transfers simply by supermajority. Okay? So if you want to see is this transfer good? Is there a double spend on this NFT or Coin or something? It's enough to have a supermajority approval by this definition of the blocklace and implement a trade network. Okay, that's the conclusion of the fact that to approve an Equivocation, you need to be an Equivocator. And if there's only a supermaority of faulty agents, you can never have a supermajority approval for Equivocation. Therefore, if there is a transaction has supermajority approval, it means that it's okay. You can trust it. You will not never have supermajority approval for Equivocations.
00:28:38.460 - 00:28:40.960, Speaker A: Okay, last one. Just to understand.
00:28:41.030 - 00:28:54.804, Speaker B: So correct to say that the safety property, again, assuming super majority honest safety properties, you will never have two blocks confirmed, neither of which is ancestor of the other.
00:28:54.922 - 00:29:16.004, Speaker A: Yes, by the same agent because it's a dag, it's a block lace, so it's still not totally ordered. But every agent has to order their own blocks. So if an agent equivocates, you will never approve the agent's equivocation. It's just per agent per minor and.
00:29:16.062 - 00:29:17.900, Speaker B: Then like liveness is straightforward.
00:29:18.640 - 00:29:22.430, Speaker A: No, nothing is straightforward. Okay, yes.
00:29:23.600 - 00:29:49.910, Speaker C: Just to confirm, so say that there is some transaction that is initially approved in some blockbuster and then later I create a block with an Equivocation and then I broadcast that block and other people become observe that equivocation. Then after they observe that Equivocation in later blocks that they produce. So what will happen.
00:29:50.840 - 00:30:29.292, Speaker A: There was a supermajority of agents that approved one of the okay, this is precisely the problem that this needs to address. So if I issue the block and a supermajority saw it and approved it, and I later issue a conflicting transaction, this transaction was approved by a supermajority. It's final. The other transaction will never get a supermajority because no supermajority will approve it. That's why when there is an Equivocation, at most one will be approved. I don't require that both will be rejected. At most, one will be approved.
00:30:29.292 - 00:30:35.910, Speaker A: So specifically, if there is a huge delay between the first and the second, typically the first one will be approved and the second not.
00:30:37.800 - 00:31:00.780, Speaker C: What are you asking the block creators to do that maintains that. So I follow that supermajority. Maybe almost the entire network observes and approves the first one. After that's, observed and approved. After, like way later, there's a block that's an Equivocation, and then are the minor. The block creators are supposed to never observe this other block.
00:31:01.120 - 00:31:43.156, Speaker A: I'm sorry, but I'm still trading in a very abstract domain still. I'm not yet talking about specific protocols at the abstract setup. I'm talking about the mathematical properties of these data structures. The mathematical property is that within this data structure, you cannot find two supermajorities of blocks by supermajorities of the miners that approve an Equivocation. That's all I'm saying. Within this data type, if this data structure could be infinite, think about it, even infinite data structure, it's infinite run. If there is a supermajority of honest miners, there will never be a supermajority approval of an Equivocation.
00:31:43.156 - 00:32:06.716, Speaker A: That's all I'm saying. It's a very abstract statement about an infinite data structure, if you will. Okay, so this is the first time I'm giving my talk, so there's still some glitches, I'm sorry. So I sort of ran ahead of myself and spoke already about this. But really I wanted to mention also this. So this even doesn't need supermajority. Sovereign cryptocurrencies don't even need supermajority.
00:32:06.716 - 00:32:40.460, Speaker A: Okay? Just take it on faith and let me just it's one of the papers, so you can look at it and it's a whole new topic. It's a whole topic which is rich and interesting, and I will not talk about it because there's no time. If there's time, I'll get back to the answers. But you see it's here. It doesn't even need supermajority. And that's the whole notion of grassroots, which means that communities can start independently. You don't need account of everybody involved, it's all local, et cetera.
00:32:40.880 - 00:33:10.310, Speaker B: Just to follow on Matt's question, I mean, I take your point that you sent up mathematical properties, but I wonder if it's helpful to have a reference naive patient in mind, so ignoring efficiency, all that kind of stuff. You just think about it like every time somebody creates a block, if you're honest, then you're actually just going to like so you basically look at all of. The other blocks that your new block approves. You just broadcast signatures to everybody, nothing like that.
00:33:11.080 - 00:33:53.750, Speaker A: All the protocols are based on the fact that people cooperatively create a block list and eventually everybody sees everything and everybody computes properties locally from the block list. That's it. That's all. Everybody decides. Everybody can look at the block list and decide what is true, what is false, what is good, what is bad. But the only thing that's happening here, and I'll fast forward to the protocol, to the consensus protocol in this layer, the only thing that's happening is that the miners of the people, it's true both here in the social network and also here. The only thing that's happening is that people are created cooperatively, this partial order, and eventually everybody.
00:33:54.760 - 00:34:02.500, Speaker B: Is it correct to say that the data structure itself already encodes all of the headlines, so you can just look at it statically.
00:34:05.400 - 00:34:15.720, Speaker A: The thrust of the protocols I'm going to talk about here is that the only thing that's happening is people are creating blocks and sending to everybody else and then everybody receives the blocks and locally computes whatever they want. That's all.
00:34:15.790 - 00:34:24.216, Speaker B: And so in particular, like if you fix the data structure, you don't care the process by which it became that data structure. No, the votes are just fixed.
00:34:24.248 - 00:34:58.196, Speaker A: Just the only guarantee you need is dissemination. That everybody will eventually see everything. The correct miners, that the correct miners will eventually have the same view that every block created by a correct miner will eventually be received by every correct minor. That's the only thing you need. Everything else is people compute locally. Okay? So, yeah, that's the no supermajority for Equivocations. And we are ready to talk about ordering.
00:34:58.196 - 00:35:43.104, Speaker A: Okay? So we know how to do provocation exclusion with the block list now about ordering. And the basic problem is how to turn a partial order into a total order or a block list to a blockchain. That's what they want to do, right? And there are two requirements that you want to satisfy. So the outputs the blockchains. So every miner sees this ocean of partial order and they want to produce a total order locally. Every miner outputs locally to its customers, to its whatever, to its agents, or to run the local Smart contracts, VM, whatever, a blockchain, okay? That's every miner. So the outputs, the blockchains produced by every two miners are consistent.
00:35:43.104 - 00:36:16.220, Speaker A: So one is the prefix of the other. So I may be ahead of Tim or Tim may be ahead of me, it doesn't matter as long as the one who is behind is a prefix of the one who is ahead. That's all we need. So I may be computing blocks more slowly, but if what I computed is a prefix of prefix, meaning beginning of whatever blockchain the other guy produced, then we're fine. Clarifying question. So you mean by outputs of every two minus the ones that they approve the block that they approve. No, think about it differently.
00:36:16.220 - 00:37:09.100, Speaker A: The problem is turning partial order into total order, okay? The way these algorithms work and I'll say these are the existing Dag algorithms work already. I'll explain it in a second. The way they work is miners communicate their blocks to every other miners. So every miner accumulates that partial order locally, and they may have different partial orders simply by I may see more blocks than you did from Tim, and you may see more blocks from Andy because you're closer to Andy. So I may be ahead in Tim's blocks, and you may be ahead in Andy's blocks. But when I compute locally, the total order, the blockchain from the blocklets, whatever I compute and you compute are consistent, which means my output is either longer than yours and yours is a prefix of mine, or your output will be longer, and mine is a prefix of yours. We'll never fork.
00:37:09.100 - 00:37:39.020, Speaker A: That's the whole point. We'll never fork, okay? That's the requirement. That requirement says never fork. It's not, we fork and we recover and do this and this. No, we never fork. Never, ever fork, okay? And liveness just means that if a correct miner created the block, then eventually everyone will output this block. Okay? These are two mathematical requirements from such a solution, okay? And and there are solutions.
00:37:39.020 - 00:38:16.180, Speaker A: It's not the first one, but there was one paper, like 2020 some years ago in this direction, but no one completely figured it out. It may work, it may not. But Doug Rider was published in Podc 21, and it has a successor called Bullshark, which approves it. And other people are jumping on this Dag bandwagon because it's actually very good, has the following ideas. First of all, it uses reliable broadcast for dissemination and communication exclusion. So it's a black box protocol. Every miner communicates to every other miner, using reliable broadcast, all their blocks.
00:38:16.180 - 00:38:59.328, Speaker A: And when this round is done, every miner is guaranteed to have all the blocks of the correct miners. Faulty ones are not guaranteed. Either all miners agree on the same blocks, or the block is not there and there are no equivocations. Okay? So by magically, it filters out equivocations, faulty miners, everything. And all the correct miners have brand new dandy blocks of all correct miners. So that's a reliable broadcast. So it achieves both dissemination and equivocation exclusion, and they are cordial in the sense every round, every miner waits for a supermajority, at least two thirds of the blocks of the other miners before issuing its next block.
00:38:59.328 - 00:39:56.112, Speaker A: So basically, the way the protocol works is all miners cooperate, they produce their blocks, send to all other miners, wait to receive supermajority of blocks from the other miners, and then issue the next block. That's all that's the protocols and ordering is achieved. And that's the key trick using okay, how do we turn a partial order into a total order? There is a thing called topological sort. Topological sort takes a partial order and just stretches it until it's a total order consistent with a partial order, but it has degrees of freedom. And in particular, me and Andy may not have exactly the same partial order. So if I stretch it this way and he stretches it that way, we may have a fork, but we don't want to have a fork. So we agree on something on leader blocks.
00:39:56.112 - 00:40:46.708, Speaker A: And once we agree on leader blocks, we use them as anchors for the topological sort in a way that ensures the consistency or the safety of our total order. So the one conceptual trick that these ordering consensus protocols, dag based protocols do is they have a magic way to agree on leaders and then use these leader blocks to do the total ordering. Okay, so that's that paper, these two papers, let me just say I see faces puzzled, so I'm not sure exactly whether I should say a few more words. Do you want me to say? Do you have a question about these? A question about the motivation? My narrow understanding is longest chain allows.
00:40:46.804 - 00:40:48.184, Speaker B: The possibility of forks. Right?
00:40:48.222 - 00:41:33.976, Speaker A: That's why it's one of the innovations. So here, with not being able to have forks protocol, what are we gaining? Okay, so let me go back. This problem of so called Byzantine atomic broadcast or Byzantine agreement on ordering has been worked on for 40 years, and there are lots and lots of protocols for that. And this is like the cusp of the progress in this area. And there's Nakamoto Consensus, which is seemingly a different branch. Now, all the money was here, right? So the people who did this for 40 years said, hey, I want to make some money too. How can I make money? So they said, okay, well, you can use these protocols by converting them into permissionless, and then you can make money.
00:41:33.976 - 00:42:21.680, Speaker A: Okay, so cardano and algorand and what else? Okay, you're prevented say it again. Okay. On my shoulder. Okay, how can I make money? I will take these protocols and use them by adding stake based sampling. Okay? So every miner puts some stake, and I learned it from some lecturer, amazing lecturer in Colombia University. I will not disclose, I will not implicate anybody by name, but that's what I learned in the course I took in Colombia. So you do stake based sampling.
00:42:21.680 - 00:43:12.656, Speaker A: Every miner puts some stake, and then you do random selection of miners based on the stake. And then you have a fixed selection of miners for a given epoch, which could take seconds or minutes or days or weeks. And for this epoch, you have a fixed set of miners which can then run this protocol of these other people who hasn't made money still and want to make money with this work. And that's how permissioned protocols can participate in the permissionless cryptocurrencies arena. Okay, so this is a long answer to your question that these two separate approaches to consensus, nakamoto Consensus and the previous Byzantine atomic broadcast permission, blah, blah, blah. And the permission can be used in the permissionless using stake based sampling. And now the gates are open, anybody can join.
00:43:12.656 - 00:43:54.944, Speaker A: And now the name of the game is who has the best protocol? And we can argue what is best. But presumably high throughput, low latency is a good criteria, are good criteria. And specifically, these protocols seem to have the highest throughput and lowest latency, okay? And highest throughput should be evident because nothing is happening except miners create blocks and sending to other miners. That's it. There's no bottleneck, there's no fighting, there's no forks, there's no backtracking, there's no winning. It's cooperative. We all create blocks as fast as we can, and we send these blocks as fast as we can to everyone else, and we're just cordial.
00:43:54.944 - 00:44:20.808, Speaker A: We wait for supermajority of blocks before sending our next block. That's all. That's the only thing that's happened at the communication level, at the computation level. Here's where the magic happens. Everybody looks at the partial order at the Dag or the block place and turns this partial order into a total order by magic, consistently with everybody else. That's it. So the conversion of the partial order to a total order happens locally by each miner independently.
00:44:20.808 - 00:45:17.944, Speaker A: And the magic of the protocol is that they all agree on the same total order, even though they are doing it independently and specifically how they agree, because they agree on leader blocks. Leader blocks. And to a first approximation, you can think about deterministic or even pseudorandom selection of leader blocks. For every round, we all agree on the same pseudorandom function. And every round we have a block, which is the anchor, and then we use it, everything it sees, we use it to do topological short for the rest. That's a good first approximation. The problem is that if the adversary knows in advance what is the order of leader selection and say they want to crush this currency because it's a bad currency and they want all these people who are trying to join the party.
00:45:17.944 - 00:46:10.540, Speaker A: Want them to lose a lot of money. Then the adversary can block the leader blocks can somehow prevent the leader blocks from succeeding. And that's why these protocols actually, in the general case, use shared coins for random retrospective leader selection so that even the adversary, nobody knows who is the leader beforehand and only after all communications are said and done. Then we retroactively select the leader using shared random coin and then compute the partial order on this, add some latency because there are some rounds that nobody knows what's going on. So we are four rounds behind or five rounds behind. Okay, that's very intuitively what's going on, but I remind you that dissemination and cache exclusion is not done by the block list, by the partial order. It's done by reliable broadcast.
00:46:10.540 - 00:47:13.650, Speaker A: And it turns out reliable broadcast has its overhead. You need two rounds or four rounds of communication, depending on the trade off between communication complexity and latency. And that's why in the cordial miners protocol, which was supposed to be the main topic of this talk, and next twelve minutes I'll try to explain it. We use the blockless for dissemination, ordering and Equivocation exclusion, okay? We don't use reliable broadcast as a building block, we just use the block list for everything and the results are accordingly. So depending on the model eventual synchrony or synchrony, these are different models of adversary or network. So the latency is two compared to four, or five compared to eight, or whatever the numbers are, okay? So it's a better algorithm, more efficient algorithm, and the reason is that we use the block list for everything, dissemination, ordering, and Equocation exclusion. So let me explain a little bit how this happens.
00:47:13.650 - 00:47:44.236, Speaker A: Dissemination is just what I said. I tell other people the blocks I know that I don't know that they know, that's all. And this is happening here. So let me just read this in English, okay? So this is a code for minor p. So I am minor p, and what I do for every other minor, which is different from me, and it's not an Equivocator. So if I know that someone is Equivocator, I already ignore him. These are bad guys, I can exclude them.
00:47:44.236 - 00:48:11.040, Speaker A: And this also improves the efficiency of the algorithm, et cetera. So if he's not an Equivocator, I send the new block. This is the new block I've created, but not just the block, but the closure. So everything the block sees, unless I already sent it to Q. So I send to Q everything I know, except things I know that Q knows already. That's it, that's what it says here. And I add to the history of Q what Q knows.
00:48:11.040 - 00:48:37.132, Speaker A: I add b. So now Q knows. Q also knows B. Okay. That's it. So that's how dissemination is achieved. Every miner tells other miners the new block, he knows the new block and everything that this block points to, except that the other guy already knows, and the other guy already knows either because I sent it to the other guy before, or I received it here.
00:48:37.132 - 00:49:22.284, Speaker A: When I receive from Q something, I also add to the history. So when I receive something from Q, I know that Q knows it already, okay? So the history is updated when I send something to people and when I receive something from people, that's the history, okay? And the definition of cordial block is just that there is a supermajority of previous blocks of the previous round. So I wait for supermajority and then create the block. So that's the dissemination protocol, blockless based dissemination, and now the ordering, I told you there's dissemination trinity, remember? Dissemination ordering equivocation exclusion. So now let's talk about ordering. Ordering. There is a function which called tau for I forget why and what it does.
00:49:22.284 - 00:50:00.228, Speaker A: It takes a block lace and turns it into blockchain. That's a total ordering. And the key idea for the safety is monotonicity with respect to supersets. So the way tau works is that if I have a block lace and I apply tau to it, I get a sequence. If the block increases, then the sequence increases. So this means that if I have a small block lace and I output something when I get more things, I don't need to compute tau from the beginning. I just compute the added suffix.
00:50:00.228 - 00:50:39.796, Speaker A: Okay? And this monotonicity is really this monotonicity implies safety. Why? Because here, let's say minor one knows broccolius b one and minus two knows broccolius b two. These are two different subset of the global broccoli, okay? And he computes the tau of b one. He computes the tau of b two. Since tau is monotonic, then both tau of b one and tau of b two are prefixes of tau of union b one and b two. Now, if two sequences are prefixes of a third sequence, they must be also consistent. One is a prefix of the other.
00:50:39.796 - 00:51:06.510, Speaker A: It's not possible the other way. So the fact that these two sequences are prefix of the union, they also means that they are consistent. So this consistency and implies safety. So the only thing we need to show is monotonicity of tau. And that's how tau works. Okay? It's a very simple recursive procedure. And what can I say about how it works?
00:51:11.780 - 00:51:17.680, Speaker B: Ignored efficiency considerations. Is it obvious that some monatomic tao should exist?
00:51:19.460 - 00:51:46.644, Speaker A: No, it's very finely tied. For example, tau exists because the protocol is cordial, so you have these supermajorities, otherwise it will not happen. And it exists because you have a notion of elected leaders, otherwise it will not happen. And it actually works from final leader to final leader. It's a very delicate construction that works only if all components are replaced.
00:51:46.692 - 00:51:48.344, Speaker B: So for generic dads, you can never.
00:51:48.382 - 00:52:01.490, Speaker A: Have to no, it's very specific to the block list, the way it's created by a cordial managers protocol and the idea of final leader selection and final leaders, which I have not explained exactly how they're selected. Okay?
00:52:04.100 - 00:52:09.740, Speaker B: So it's really not a function from in parentheses. You have partial order and total order. It's not really a function partial.
00:52:09.820 - 00:52:29.850, Speaker A: It's a partial function. Yeah, it works only on you agree? You're right. This is an overreach. This is an overage. It works specifically for the blocklets produced by the cordial minor protocol. Okay, you're right. It doesn't exist in general.
00:52:29.850 - 00:53:08.000, Speaker A: Yes. Okay, so the key idea let me show you the key idea. This is just to tell you that it cannot be that complicated if it can be described by five lines of pseudocode. But let me give you the idea. Actually, it's connected to biology. So this somehow what I've been doing for the last 20 years fits the way DNA is replicated. The replication machine can go only in one direction.
00:53:08.000 - 00:53:42.764, Speaker A: But the DNA double strand opens like this. So this strand, it can go in this direction, but in this strand it can go only in this direction. So how can it do it? It simply adds small fragments starting every time from the fork. So what's called the lagging strand is computed discontinuously by different short fractions which are then ligated. Okay? So if you just reorder it the other way around, so it's the same direction. So the output, the blockchain produced by each miner looks like that. It starts from the next leader and backwards.
00:53:42.764 - 00:54:10.900, Speaker A: And the next leader and backwards. The next leader and backwards. That's how it's constructed. So it is constructed in jumps. And this delay depends on the particular of the protocol, which I will mention very briefly. Again, this is basically how it works. You identify final leaders, which I have not defined what they are, but in a minute.
00:54:10.900 - 00:55:05.736, Speaker A: And then from a final leader you compute backwards. As the block list grows, you compute backwards and the other Dag protocols operate the same way. It's not specific to the block list, but what the blocklace does is sorry, there's one thing I did wanted to mention in the code, which is very simple, that the topological sorts only the blocks approved by B. Okay? So basically here you do vocation exclusion. So every minor when there is a final block that all have to agree upon, remember, we need to have consensual leaders leader blocks. So once there is a consensual leader block, we use it to do provocation exclusion of everything below it in the Dag. And this particular place is what it does.
00:55:05.736 - 00:55:24.080, Speaker A: It the leader block is used not by supermajority, but simply the leader itself decides how to resolve equivocations, the leader block. So that's how they all agree on the order and resolve equivocation.
00:55:24.500 - 00:55:27.200, Speaker B: Should we think of these meter blocks as checkpoints?
00:55:29.700 - 00:55:59.124, Speaker A: No. First, it is confusing. I mean, many people, they keep changing terminology and all that. The best way to think about it is an agreed upon way to break symmetry. Because the problem is everyone the situation is symmetric. How can you break symmetry? We cannot do it deterministically, so we need to do it nondeterministically. And either you use it using pseudorandom functions which are agreed upon by everyone, or random coins.
00:55:59.124 - 00:56:02.904, Speaker A: So the leader blocks are really a way to consensually break symmetries.
00:56:03.032 - 00:56:07.932, Speaker B: So at that point you just point to someone and say pick this double spend, is it A or is it B?
00:56:07.986 - 00:56:40.076, Speaker A: Yes or none? Yes. But that's what the Dug rider does. And they can do it because they use reliable broadcasts. So they've eliminated all equivocations before that. In the Cordial Miners protocol, you don't do it and you win half the latency because of that. But you are left with the blocklets with Equivocations and then you have to do what you've done but to do it reliably. We actually have a notion of super ratified leader.
00:56:40.076 - 00:57:35.112, Speaker A: So those who know the Bracha historical algorithms from the 80s, these are really the first algorithms for asynchronous consensus. He had a notion of a super, double supermajority. And it turns out that it's a fundamental notion that you really need it. And so an elected leader block is final only if there's a supermajority that approves it and a supermajority that observes there is a supermajority that each member of it observes, a supermajority that approves it. And that's the notion of finality. And the reason why we need such complicated notion of finality, which is sort of at least two rounds, but maybe more depending on various things, is that you want subsequent leaders not to be able to bypass this leader. And here it comes where cordiality is needed.
00:57:35.112 - 00:58:26.836, Speaker A: Again, I'm rushing this since I have 1 minute, but if this is super ratified and this is a cordial block, then for example, look here, there must be a block in the intersection. So this block will see this block in the intersection which sees a supermajority which sees that. So basically, this one sees a supermajority that approves everything that can decide for this and for everything else. So every decision does have supermajority support of minors. And therefore you can count that. It doesn't have faults that's hand waving, but that's the core of the proof. That because a combination of requirement of double supermajority and cordiality, this is cordial block.
00:58:26.836 - 00:58:47.810, Speaker A: So it observes the supermajority. It either has an intersection here or it has a correct minor that is common to here and here. And since this minor is correct, it has a path because a correct minor has a path from each block to its previous block. So this guy sees this block which goes through a path to this block, which sees a supermajority which sees this one.
00:58:48.260 - 00:58:52.120, Speaker B: So the role of the cordial assumption that's just to make sure everybody knows.
00:58:52.220 - 00:59:44.464, Speaker A: Supermajority is up to date, the cordiality implies that there is a supermajority here that you see. And since you require supermajority support here, they must have an intersection, these supermajorities of a correct minor. And therefore you have a path that goes through correct miners that sees a supermajority that approves this leader. And then this leader is final if it has this structure. And that's how Tau computes. And the monotonicity is guaranteed by the fact that a new leader will necessarily see this leader and therefore will only extend the output sequence. So everything up to here can be cached because he cannot bypass it, because it's guaranteed to see a supermajority that sees guaranteed to see someone that sees the supermajority.
00:59:44.464 - 01:00:38.176, Speaker A: So this leader cannot bypass this leader. And that's why you can cash that's the finality. That's why there's never forking, because once a leader is final, every future leader will see it and will never try to bypass it through another path. Because remember, the block lace or the dag, it's the same in both protocols, grows differently in different miners. I mean, different miners see different partial views of it, but this guarantees that once they output something, they will never regret it or never forkle it. That's the safety liveness is even more complicated to prove 80% of the work in the paper was on proving the liveness, but I'm already over time. So I will just say that the protocol works for both eventual synchrony and Asynchrony.
01:00:38.176 - 01:01:26.256, Speaker A: And these are two different models of distributed systems with adversaries and the wavelength, the gap between two leaders. Here it's two, and here it's five. Here the prospective leader selection, which means random pseudorandum. But here it's retrospective, so it's shared coin. And here some complicated conditions for finality and for completing rounds and probability of wave success. Here is four, nine, and here's two thirds, which is the way from which we derive the expected latency. So going back to the table, so we have achieved all these three goals within the block lace in a protocol.
01:01:26.256 - 01:02:17.910, Speaker A: These are by far the best protocols until now, much faster than all the alternatives. And also, experimentally, the Bullshark guys have implemented it and showed performance numbers that are off the charts. So this is even simpler and faster than bullshark twice the latency. And I should say that this is sort of an accidental I was really looking at the grassroots, bottom up kind of protocol stack, and the fact that there's a cherry on top with a consensus protocol that's faster than all the rest is a bonus. It was not a research goal, but is a happy, happy accident. Yeah, I guess that's the end of my talk. Okay.
01:02:25.180 - 01:02:34.872, Speaker D: First of all, just to confirm there is an impossibility result for Asynchronous protocol. Right? And the cordial assumption is what makes.
01:02:34.926 - 01:03:17.880, Speaker A: That result actually, what makes this result work is already in the Doug Rider protocol. It's not new to us. Not new to well, US is sort of because this paper, Cordial Miners Protocol, is co authored with some of the authors of the Doug Rider protocol. So let me go back to that. Here the ordering is used consensual ledger blocks, and these are elected using shared random coins. So the FLP result, or this is countered by electing the blocks that break symmetry using a shared random coin. So you add randomness to address the FLP theorem.
01:03:17.880 - 01:03:21.140, Speaker A: That's why it works for Asynchronous.
01:03:21.300 - 01:03:40.510, Speaker D: And I guess the separate question is you can consider a weaker notion of safety that isn't prefix consistency. It's just no inversion, if that makes sense. And do you think that is not sufficient? Or has anyone looked at whether it.
01:03:41.940 - 01:04:16.248, Speaker A: Okay, this weaker notion was invented by people who didn't want to go all the way down to here. So actually, you don't even need this is the true weaker notion. All you need is supermajority approval. You don't need to talk about order at all, just supermajority approval to eliminate equocations. Here the reason I'm interested in this. It's not that I'm not definitely it's important to have order in consensus because these are important applications. But these are even more important, if you will.
01:04:16.248 - 01:05:08.956, Speaker A: For example, if you need democratic dows, you cannot do democracy without total ordering because you need to know if votes happened before or after the closure of the ballot or things like that. So for that, anything that has to do with smart contracts or replicated state machine, you need total ordering because if you change the order of things, the result of the computation will be different. For the important applications here, the weaker notion of consistency is not good enough. And for these applications you don't even need that. So it's like a hybrid thing which is too strong for this application and too weak for these applications. That's why personally, I think it's not a useful notion, but I may be wrong. I may have an error perspective, but from my perspective it's not needed.
01:05:08.956 - 01:05:11.470, Speaker A: It's too strong for this and too weak for this.
01:05:13.680 - 01:05:24.000, Speaker D: I'll ask one final thing and is there a way in which to have Tau safety? You need cordiality.
01:05:24.500 - 01:05:25.730, Speaker A: Is there a way what?
01:05:26.260 - 01:05:35.392, Speaker D: This is not well defined, but it feels like to have this house safety property, you need cordiality. Do you show that or you just take this trip?
01:05:35.456 - 01:05:55.050, Speaker A: Well, personally I'm quite weak on negative results. I prefer to work on positive results and let other people prove negative results. So nobody this is all very new. So I don't know. I know that we need it for Tao to work, but we haven't proved that you cannot do without it.
01:05:56.380 - 01:06:03.196, Speaker D: At the beginning you said one of the properties we wanted was scalability. Can you say a bit more about how we achieved that here?
01:06:03.298 - 01:06:32.992, Speaker A: Yes. Okay. It's a huge question. I'll try to answer briefly. So, first of all, here at this level, scalability is achieved essentially like Doug Rider. By first of all, you have to agree that you don't need an unmounted number of miners. I mean, it's not scalable with the number of miners, but who need infinitely many miners.
01:06:32.992 - 01:07:20.676, Speaker A: I mean, people agree that you get reasonable safety with few dozens or hundreds of miners. You don't need more than that in a reasonable setup to feel comfortable about depending how they're elected, et cetera, et cetera. If they're sampled from a large population. These protocols do not the complexity is quadratic in the number of miners. Okay, typically, but let's assume that you have agreed on some reasonable bound on the number of miners. Then what's happening there is just extremely, extremely simple and efficient. The only thing that's happening is that every miner collects transactions, puts them in a block, creates adds to the block, pointers to the.
01:07:20.676 - 01:07:57.888, Speaker A: Most recent blocks it saw in the Dag. And it doesn't even have to have blocks to everybody else, because if I got a block from someone that already points to other blocks, I don't need to point to the other blocks. It's enough that I point to him. It's not necessarily even end pointers in each block, you may have less, and I send it to the other end miners. That's all I do. The round of a minor is just load transactions into a block, add pointers, send to N miners, load transactions in a block, add pointers, send to N miners, and between them, I wait for supermajorative blocks from the other miners. That's all.
01:07:57.888 - 01:08:49.804, Speaker A: Everything else is happening locally as a computation. So that's in that sense, just specifically head to head with blockchain consensus or other protocols or other standard protocols for Byzantine agreement, which are leader based, whatever. This is extremely relaxed and efficient. I think that it's fair to believe that you can get arbitrary large throughput with this protocol because you just load transactions sent to everybody, load transactions sent to everyone. That's the only thing that happens. The rest is just local computation of ordering this, that's at this level at this level, I say something much stronger and broader. And I want this to be grassroots.
01:08:49.804 - 01:09:25.928, Speaker A: What does it mean to be grassroots? It means that people in Timbuktu or Senegal or Israel or Tangier or New York can all start independently. Their local whatever local social network, local networks of sovereign cryptocurrencies, they can start them independently. And eventually, if someone happens to be connected to two communities, then these two communities will connect. Or if I establish connections with someone from another community, these two communities will be connect and still continue to work. We don't need to reboot. We don't need to start with a new directory. We don't need a new epoch.
01:09:25.928 - 01:10:02.040, Speaker A: This just grows and grows and grows independently in parallel and interconnected. And these protocols support this notion of grassroots. And in this sense, in that sense, they're scalable. Okay. And again, end, we need to talk specifically about the tasks, but both for this task and for this task, the communication is always local and linear in the number of whatever, but that's a different notion of scalability. Okay, thank you very much.
