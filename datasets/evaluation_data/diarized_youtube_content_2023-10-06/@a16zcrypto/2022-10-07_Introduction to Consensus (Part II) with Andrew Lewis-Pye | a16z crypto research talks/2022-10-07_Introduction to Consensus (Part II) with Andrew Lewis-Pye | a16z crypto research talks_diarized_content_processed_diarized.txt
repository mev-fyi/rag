00:00:09.100 - 00:00:09.728, Speaker A: All right.
00:00:09.894 - 00:00:10.784, Speaker B: Morning, everyone.
00:00:10.902 - 00:00:22.204, Speaker C: Let's go ahead and get started. So today we have again Andy Lewis Pie, one of our faculty fellows. He'll be giving the second part of this two part introduction to Andy.
00:00:22.332 - 00:00:23.250, Speaker B: Thanks, Tim.
00:00:23.700 - 00:00:24.112, Speaker A: Right?
00:00:24.166 - 00:00:24.384, Speaker B: Yeah.
00:00:24.422 - 00:00:51.980, Speaker A: So let's start by just quickly recapping what we talked about last time. So we set up a formal framework, right? And so let's just remind ourselves how that works. Joe's just coming in. Okay, so we've got a set of n processors. We're calling them from giving them names from zero up to n minus one, up to f of those may be faulty. We don't know which. Every processor knows N and they know f.
00:00:51.980 - 00:00:59.520, Speaker A: Okay? So they know the number of processes involved. They know some upper bound on the number of faulty processors, and they also know their own name, right?
00:00:59.670 - 00:01:00.032, Speaker B: Okay.
00:01:00.086 - 00:01:28.328, Speaker A: That's given to them as part of their input. We are considering an execution, which is divided up into discrete time slots. You got time slot zero, time slot one, time slot two, and so on. At each time slot, each processor receives a set of messages. They carry out some finite set of instructions, and that allows them to decide what message is going to send at that time slot. And then you move on to the next time slot. Between each pair of processors, there's some authenticated channel.
00:01:28.328 - 00:01:45.790, Speaker A: So for each pair, like inj, there's some channel just between those two. Only those two processors, only those two guys can send message on that channel. And each processor knows exactly who's at the end of their channel, each of their channels. Right. So if I'm, I and there's j over there, and then I've got a channel to Jay. I know Jay's at the end of that channel.
00:01:49.380 - 00:01:49.744, Speaker B: Okay.
00:01:49.782 - 00:02:00.880, Speaker A: Then we had to decide how reliable do we want to think of message delivery as being. So last time, we were focusing the entire time on the synchronous setting.
00:02:01.380 - 00:02:01.744, Speaker B: Okay?
00:02:01.782 - 00:02:14.864, Speaker A: And so the simplest version of that is just that if I send a message at time t, it arrives at time t plus one. Slight variant would be that you have some bound delta. If I send a message at time t, it arrives at least by time t plus delta.
00:02:14.992 - 00:02:15.728, Speaker B: Okay?
00:02:15.914 - 00:02:26.900, Speaker A: But for our purposes here, we don't have to really worry about the difference between these two, because every single theorem we're going to talk about holds for one and even only if it holds the other with, like, a very slightly modified proof.
00:02:27.060 - 00:02:27.396, Speaker B: Okay?
00:02:27.438 - 00:02:44.012, Speaker A: So we guess we're focused on the simple one. We send a message at time t, it rises t time t plus one. Yeah. So obviously that's like, a strong assumption. So later on today, we're going to consider the partially synchronous setting where message delivery might sometimes be less reliable.
00:02:44.076 - 00:02:44.304, Speaker B: Okay?
00:02:44.342 - 00:02:47.250, Speaker A: But for now, at the beginning, we're going to stay on synchronous setting for a bit.
00:02:48.580 - 00:02:48.944, Speaker B: Okay?
00:02:48.982 - 00:03:44.770, Speaker A: Then we also have to decide how our faulty processors can behave. So basically we're focusing on Byzantine failures, okay? So they can just behave arbitrarily and think of them as being nasty. And then what's the overall research program we're going through? So what we're interested in is which N and F remember, F is a number of faulty processors for which N and F. Do there exist protocols to solve By Dante agreement? Another variance of the problem. How does that depend on our assumptions regarding the reliability of message delivery, whether we're in the synchronous setting or partially synchronous setting, which I'll introduce in a bit. Well, how does it depend on the form of faulty behavior? In fact, we're just focusing on Byzantine faults. And then how does the answer depend on whether we are given a Public Key infrastructure? Okay, so those are the basic questions we're interested in.
00:03:44.770 - 00:04:11.668, Speaker A: And then last time, sort of, we do so we introduce Byzantine Agreement and Byzantine Broadcast. Hopefully you remember what they are. So for Byzantine Agreement, every process has got an input. All the honest processors have to give an output the same output as each other. And if they're all given the same input, they all have to give that common input as their output. That's Byzantine agreement. For Byzantine Broadcast, you've got a single one of the processes, like a designated broadcaster.
00:04:11.668 - 00:04:33.324, Speaker A: Everybody knows who that guy is, only the broadcaster has an input. Now it's got a fairly similar all the honest processors have to terminate and give an output the same output as each other. And if the broadcaster is honest, then the common output has to be that guy's input. So he has to successfully tell everybody about his value.
00:04:33.442 - 00:04:34.110, Speaker B: Okay?
00:04:35.120 - 00:04:52.790, Speaker A: So that was by Xantine agreement by Xantine broadcast. And what we saw is that they're not the same problem. There are some contexts in which you can solve one and not the other. But if you're considering the synchronous setting, and if S is less than N over two, if you've got an honest majority, then they easily reduce to each other.
00:04:53.240 - 00:04:53.700, Speaker B: Okay?
00:04:53.770 - 00:05:25.648, Speaker A: So some of the time we can sort of think of them as being the same problem. Okay? And then we had these sort of two main theorems. So yeah, all the time working asynchronous settings. First of all, the easiest case is you have a PKI Public Key Infrastructure. So in the synchronous setting with Public Key Infrastructure, then you can solve By Xantine Broadcast for any number of faulty processors. That's just the Dolef strong protocol we went through. And note that that tells you everything you need to know about Byzantine agreement as well.
00:05:25.734 - 00:05:26.032, Speaker B: Okay?
00:05:26.086 - 00:05:58.840, Speaker A: Because we saw Byzantine agreement can't be solved if F is greater than N over two. But if F is less than N over two, then you can solve Byzantine Broadcast. So this tells you can solve Byzantine Broadcast, and therefore you can solve By Xantine Agreement. If F is less than N over two. If F is greater than over two, you know, you can't okay, so that's the first one. And then this one we also saw, but it was broken down into two parts, right? So we had the impossibility result and then we had the possibility result. So, okay, now we're still in the second setting, but now we don't have a public infrastructure.
00:05:58.840 - 00:06:51.448, Speaker A: So first of all, you can't solve it if F is greater than N over three. Either of the problems if F is greater than N over three, but you can if F is less than N over three. Okay, so what we're going to do this time then? So we're going to move first of all, so we're going to stay in the synchronous setting for a bit and we're going to set a State Machine replication, which is basically what like blockchain protocols do, okay? And then we'll introduce the partially synchronous setting and we'll basically do this whole thing again. But I'll sort of cut it a bit shorter this time because basically what I'll do is I'll show you tendermint and that will sort of do most things for us. Okay, so so far we've just been talking about permission protocols the whole time, right? At the end we'll talk a little bit about how this stuff compares with permissionless. The permissionless setting, like Bitcoin in particular. Okay.
00:06:51.448 - 00:07:27.332, Speaker A: So state machine replication. So as I said, roughly so state Machine replication is just what blockchains protocols are supposed to do. So you've got a bunch of clients, they're sending in a sequence of transactions, they're choosing what transactions they want to send in, and then the process of implementing the SMR protocol, the State Machine replication protocol. They just have to agree on an order in which to implement those transactions. I guess everyone's familiar with that. Just like a word of warning. So often, as opposed to Byzantine agreement and Byzantine broadcaster, SMR is often treated like somewhat informally in the literature, so you're not quite sure exactly what formalization you're using.
00:07:27.332 - 00:08:26.068, Speaker A: Okay, so sometimes I think that leads to things being a bit confusing. Okay, so I'm going to write down a sort of particular formalization here, but there are other approaches you could take and sometimes things will be sensitive to exactly how you set things up. Okay, so later on we'll talk about does Bitcoin satisfy SMR? And you'll see it's a bit sensitive to exactly what you mean by previously. Okay, we were interested in is there not a PKI here? I'm just going to focus on the setting where we have a public key infrastructure because generally I think people normally consider SMR protocols in the context of a PKI. Okay, right. So I'm going to write down a formal version a little bit, but first of all, just at a sort of high level. So two basic differences between SMR on the one hand and BA and BB byzantine agreement, byzantine broadcast on the other hand, are as follows.
00:08:26.068 - 00:08:54.320, Speaker A: So, first of all, SMR protocols involve a second type of protocol participant. We're calling them clients. So roughly the idea is the clients don't actively participate in the process of reaching consensus. All they're basically doing is they're sending in these transactions. Sometimes they're also called requests. When they have other names, they send in these transactions that the process is actually carrying out the consensus protocol. And the clients have to be reliably informed by those processes when transactions have been implemented.
00:08:54.320 - 00:08:56.336, Speaker A: So they should be playing a sort of passive role.
00:08:56.368 - 00:08:56.950, Speaker B: Here.
00:08:59.320 - 00:09:33.596, Speaker A: One basic difference. Second biggest difference. So SMR, unlike BA and BB, doesn't require processes to give a single output, but rather now they have to produce like a continually growing output sequence that grows in length. As the clients submit more transactions, we have to gradually confirm more and more transactions. Okay, so yes, I'm going to write down one possible sort of way of one possible full formal set up. I guess some of this is going to be like a little bit arbitrary, but I just want to write down something concrete so we have a particular detail, a particular version to talk about.
00:09:33.618 - 00:09:34.190, Speaker B: Okay?
00:09:35.700 - 00:09:55.430, Speaker A: Okay, so we've got a set of N processes. Again, we're recording them zero up to N minus one. So we can talk about things mod M. And we got set of M clients. Okay, zero up to N minus one. I'm going to assume, given a PKI for the set of all clients and processors, maybe that's not entirely necessary, but again, just make things simple. I'm just going to start off that way.
00:09:55.430 - 00:10:17.404, Speaker A: And again, we're going to have authenticated channels. They work the same as before. Again, all the processors have each pair of processors has an authenticated channel between them. Okay, so it's basically the same as before, but okay, I'm going to assume for each client there's at least one non faulty processor that it has a channel to.
00:10:17.602 - 00:10:17.964, Speaker B: Okay.
00:10:18.002 - 00:10:21.716, Speaker A: And again, you could maybe set things up slightly differently, but okay, that seems like a minimal requirement.
00:10:21.768 - 00:10:22.370, Speaker B: Okay.
00:10:26.180 - 00:10:54.856, Speaker A: So that's all clear. And then, okay, we want to sort of somehow formalize the idea that the clients, they should only be able to play like a passive role. We don't want them to be able to sort of participate in the process of reaching consensus in sort of sneaky way. Basically, we want to answer like, for what? NNF? Is consensus possible? And if the clients can sort of get involved in some way that might sort of screw up that analysis somewhat. Right, okay. So we want to formalize the idea that they really are passive here as.
00:10:54.878 - 00:10:56.440, Speaker C: Opposed to like mass creating.
00:10:56.780 - 00:11:03.230, Speaker A: Yeah, maybe they can sort of change the number of processes involved by are they honest, they're not honest, and so on. Right.
00:11:06.480 - 00:11:11.084, Speaker C: In a real deployment, nodes surely can be clients too, right?
00:11:11.282 - 00:11:27.796, Speaker A: Oh, no, I'm not worried about whether the note. Well, I mean, okay, I think you can sort of separate their roles here. Okay. So in their role as client, basically, they could only send transactions, and we've got to imagine that they can send arbitrary transactions, and the protocol has to be able to deal with that.
00:11:27.818 - 00:11:28.148, Speaker B: Right.
00:11:28.234 - 00:11:31.584, Speaker A: And then I guess think of their role as processor as being like a separate role.
00:11:31.632 - 00:11:32.230, Speaker B: Okay.
00:11:33.800 - 00:11:34.950, Speaker C: Why do we need.
00:11:37.720 - 00:12:00.636, Speaker A: Well, again, for that reason. Right. So if I want to sort of separate out the fact that the clients are sort of passive, right? So if the clients can send any message they like, they can just participate in the consensus protocol, I want to know for what NNF can we solve certain problems then? If the clients can really start joining in, then I have to start answering questions like, are the clients honest? They dishonest, like so on.
00:12:00.658 - 00:12:00.796, Speaker B: Right.
00:12:00.818 - 00:12:01.724, Speaker A: It's going to confuse things.
00:12:01.762 - 00:12:04.204, Speaker B: Okay. Okay.
00:12:04.242 - 00:12:23.252, Speaker A: So I'm going to say I'm going to say they can only send transactions. Yeah. For now, I'm going to assume they're all signed. Every time you send a transaction, it's signed. Okay. And I'm going to suppose clients can send arbitrary signed transactions on their channels. And the idea is the protocol isn't able to tell the clients what transactions they can send.
00:12:23.252 - 00:12:26.544, Speaker A: They can send arbitrary transactions. You can think of that as being controlled by the adversary.
00:12:26.592 - 00:12:27.190, Speaker B: Right.
00:12:28.300 - 00:12:51.524, Speaker A: The protocol has to be able to deal with arbitrary sets of transactions sent by the client. Okay, so a confirmation for a particular transaction TX it's just a transaction signed by one of the processors. I think of that as being one way of formalizing the notion of a message from a processor that says, this is confirmed.
00:12:51.672 - 00:12:56.290, Speaker B: Okay. Happy so far.
00:12:59.910 - 00:13:01.506, Speaker A: Okay, so what are the requirements then?
00:13:01.528 - 00:13:04.930, Speaker C: Yeah, confirmation is a signature.
00:13:06.810 - 00:13:40.560, Speaker A: Yeah. Okay, but you're going to require more than one confirmation to be happy it's been confirmed otherwise yes, you're going to require F plus one confirmation. Okay, so what are the requirements? Basically, the requirements are that the processors have to keep a log of transactions. Right. And so we have two requirements of consistency and liveness. I think everybody's familiar with these ideas. Basically, consistency says that the logs don't disagree with each other.
00:13:41.090 - 00:13:41.840, Speaker B: Right.
00:13:42.390 - 00:13:58.102, Speaker A: And liveness says that. So if a non faulty processor receives a transaction, then eventually that's included in the blockchain. Everybody happy with that. Sit on it. But I think everyone's familiar with blockchain protocols do, basically.
00:13:58.156 - 00:13:58.760, Speaker B: Yeah.
00:14:00.650 - 00:14:07.718, Speaker A: Okay, so summing up. So process arrive regards a transaction as confirmed once a transaction ends as its log.
00:14:07.884 - 00:14:08.214, Speaker B: Okay.
00:14:08.252 - 00:14:24.880, Speaker A: So roughly the consistency in liveness conditions say that all non faulty processors must agree on set of confirmed transactions, although maybe not exactly the same time. One could be slow than the other, and any transactions received by a non faulty processor must be eventually confirmed. Okay, so again, I think everyone's happy with that basic idea.
00:14:26.290 - 00:14:35.482, Speaker C: Is the word distinguishing between a transaction known to some non faulty processor versus known to all non faulty processors?
00:14:35.546 - 00:15:13.710, Speaker A: Well, because here I'm requiring that you can just propagate them because they're signed by these guys over here. So you can't be making up the transactions so you can just propagate them, I guess. Okay, and then a last condition which you can sort of like be interesting later on maybe when I think about Bitcoin and other stuff. So there's an idea that these clients should be lazy in some way, right? So final condition is to require that clients should receive F plus one confirmations for a given transaction signed by distinct processors, even only if the transaction is confirmed by a non faulty processor.
00:15:15.650 - 00:15:16.400, Speaker B: Okay?
00:15:17.410 - 00:15:49.302, Speaker A: Obviously we need F plus one because otherwise the dishonest guys could be misleading. Okay? So what we're trying to capture here is just the idea that okay, so not only that are the clients not very passive and they're not participating. They should be able to, they don't even really have to listen to what's going on. So they should be able to go away a come back later on. They didn't have to really pay very much attention at all. Okay, if I've got F plus one confirmations, great, then I know my transaction has been confirmed. Okay, so here we're trying to formalize idea of a really like a passive and lazy client.
00:15:49.366 - 00:15:49.980, Speaker B: Okay.
00:15:52.110 - 00:15:55.130, Speaker C: So the nodes are actually speaking back to the clients.
00:15:56.110 - 00:16:30.050, Speaker A: Yeah, well they send confirmations messages back to the clients and obviously so I need F plus one because the dishonest guys could lie about when things are confirmed. But if I get F plus one, then I know it's been confirmed. I didn't really have to play any role in the process of that. Okay, so if we set things up that way and obviously there are certain aspects of that we can play with right then. So an immediate consequence of that is of the lazy client condition is so SMR can't be solved then when F is greater than N over two, because I need F plus one confirmation. So these honest guys could just sit there and never send confirmations and never get anywhere.
00:16:30.130 - 00:16:30.760, Speaker B: Okay.
00:16:32.570 - 00:16:37.782, Speaker A: Again though, so it matters exactly how you set up SMR because that doesn't need to be true if we set things up a slightly different way.
00:16:37.836 - 00:16:38.920, Speaker B: Right, okay.
00:16:44.810 - 00:16:55.360, Speaker A: So for which N and F is it possible then? First of all, okay, we'll see like a slicker, slicker protocols later on. But first of all, let's just see. We can do it quite easily using Dolif strong.
00:16:55.730 - 00:16:56.094, Speaker B: Okay?
00:16:56.132 - 00:17:21.960, Speaker A: So if F is less and over two, it's easy to modify the dole of strong protocol to give a protocol for SMR. So basically we're going to run repeated instances of dolefront. So we have processor IMOD, N acting as broadcaster in the it instance, the it sort of version of dolefrong. Remember Dolorestrong has this nice poppetted. It has like a fixed number of rounds, right? So you can just replace one instance after another one in a quite sort of simple way.
00:17:23.770 - 00:17:24.134, Speaker B: Okay.
00:17:24.172 - 00:17:33.526, Speaker A: When processor I as leader, okay, basically they form like a block of new transactions I think should be confirmed, right? They broadcast that sequence of transactions as their value for agreement.
00:17:33.638 - 00:17:34.300, Speaker B: Okay?
00:17:35.150 - 00:17:42.970, Speaker A: So they're acting as leader, they suggest a new set of stuff to be confirmed. Why say broadcast? I just mean send that to all processes.
00:17:45.570 - 00:17:45.886, Speaker B: Okay?
00:17:45.908 - 00:17:57.300, Speaker A: And obviously okay, minutiae. So processes ignore suggestive values for agreement that look like they're obviously wrong, okay? If they're not in the right form or if they involve transactions they've already been out to log and so on.
00:17:59.590 - 00:18:00.002, Speaker B: Okay?
00:18:00.056 - 00:18:30.138, Speaker A: And then if the Dole of Strong protocol decides false or bottom, whatever you want to call that symbol, right, which is one of the possibilities. If the leader is dishonest, then the non faulty processes don't extend their log. If it agrees on a particular value t that set of transactions, then they append it to their log. Okay, so there's nothing complicated so far. Just to wrap it up though, we have to worry about the clients getting their confirmations. And each client's only got a channel. Maybe it's one oddest processor or maybe more, but at least one.
00:18:30.138 - 00:18:35.258, Speaker A: So just a fairly obvious little thing. We've got a sort of gossip confirmations.
00:18:35.354 - 00:18:35.614, Speaker B: Okay?
00:18:35.652 - 00:18:59.874, Speaker A: So when a non vaulty processor adds any transaction to its log, it produces confirmation for that transaction and sends that to all processing, all clients. But then that might not be enough because I might not have a channel directly to a specific client. So they also resend all transactions and confirmations received. So when I first see the confirmation for a particular transaction produced by some other processor J, it sends back confirmation to all processes and all clients which has a communication channel as well.
00:18:59.912 - 00:19:00.210, Speaker B: Okay?
00:19:00.280 - 00:19:05.250, Speaker A: That just nothing complicated or clever happening there. It just makes sure that the clients are getting enough confirmations.
00:19:05.330 - 00:19:05.960, Speaker B: Okay.
00:19:08.970 - 00:19:27.742, Speaker A: So now we know SMR can be solved quite easily using Dolif Strong. Obviously that's not a particularly sort of slick way of doing it. Maybe we're going to have a nicer way. So later on we're going to see tendermint, which actually operates that works in the partially synchronous setting. So therefore it works in the synchronous setting and it's sort of slicker in various ways.
00:19:27.796 - 00:19:28.560, Speaker B: Thank you.
00:19:32.170 - 00:19:33.478, Speaker A: Everybody happy so far?
00:19:33.564 - 00:19:34.520, Speaker B: Good. Okay.
00:19:37.130 - 00:20:01.774, Speaker A: So there we used Dolo Strong to solve SMR just to sort of keep it clear. Now, what's easily reducible to what? So let's next see. So a solution to SMR in the synchronous setting can also be used to solve Byzantine broadcast and therefore Byzantine agreement. Right? Because we've got all these different forms of problem, I think it's useful to keep in mind what's easily reducible to what.
00:20:01.812 - 00:20:02.400, Speaker B: Right.
00:20:04.130 - 00:20:07.214, Speaker A: Okay, so we want to solve Byzantine broadcast.
00:20:07.262 - 00:20:07.426, Speaker B: Okay.
00:20:07.448 - 00:20:16.900, Speaker A: So that means you're given the sum set V, right? And you've got to give an output in V, right? That's what V is here. So we're going to let bottom there denote a default element of V.
00:20:19.910 - 00:20:20.274, Speaker B: So.
00:20:20.312 - 00:20:44.080, Speaker A: What we do, because we run an instance of SMR in which the number of clients is equal to the number of processors, in which clients have channels to all processors. You just have a nice simple complete graph there. For each I we have processor I also control client I. It might seem sort of fairly trivial what we're doing here, but formally in the SMR protocol it's the clients who have to send transactions in. So that's why we're sending things up this way.
00:20:48.870 - 00:20:49.282, Speaker B: Okay?
00:20:49.336 - 00:20:59.270, Speaker A: Then in the first time slot we had the broadcaster say that's I he sends a single transaction from client I to all the other processors, which is assigned version of its input.
00:21:05.280 - 00:21:05.692, Speaker B: Okay?
00:21:05.746 - 00:21:47.358, Speaker A: In the second time slot, if they're honest, I'll do that for if they're not honest, they're dishonest, they might not right, they might not send some message and so on. So in the second time slot, each non faulty J sends assigned did not receive transaction from the client they control, they didn't receive a transaction from client I. And then basically we just run SMR. So we wait until the SMR protocol confirms assigned value. Well, either confirms a sign value from the broadcaster, in which case everyone agrees on that value, or else we confirm F plus one did not receive transactions right, signed by different distinct processes in which case we all output the default value of false. Happy with that?
00:21:47.444 - 00:21:47.646, Speaker B: Yeah.
00:21:47.668 - 00:22:03.300, Speaker A: So they'll certainly all agree on some value because we've got liveness here in our SMR project call and we also got consistency. So everyone sees the same values, right? And if the broadcast is honest, then he's going to send out these values and they'll agree on his value.
00:22:03.750 - 00:22:06.458, Speaker D: So I don't really see the role of the client.
00:22:06.574 - 00:22:17.820, Speaker A: Well, the role of the client here is just kind of like sort of fairly silly formal role. It's just if you have an SMR protocol, it's the clients who are supposed to send in transactions, right? So I'm just giving them that formal role. I mean, there's nothing clever happening now.
00:22:22.970 - 00:22:31.290, Speaker C: Would you say that what extent all the settings that we normally talk about, when should review, when should regard all three problems as equivalent?
00:22:31.950 - 00:22:34.170, Speaker A: When should regard all three as equivalent?
00:22:38.510 - 00:22:42.250, Speaker C: I realize there are cases where there are these differences.
00:22:43.470 - 00:22:47.050, Speaker A: If F is greater than over two, for example, you can't do buz and agreement.
00:22:47.130 - 00:22:53.998, Speaker C: Yeah, like I said, I know there are cases where you did extinctions. Are they ever the scenarios we're actually going about.
00:22:54.084 - 00:23:06.562, Speaker A: Well, so in the partially signal setting you can't solve the way I stated it here anyway. You can't solve by Zanti broadcast either because the broadcaster might not, just might not send anything. Okay, so I think they are all different to each other. Definitely.
00:23:06.696 - 00:23:10.046, Speaker C: Synchronous setting is the first order when you're thinking about this.
00:23:10.088 - 00:23:10.390, Speaker B: Yeah.
00:23:10.460 - 00:23:18.120, Speaker A: Synchronous setting, if you were basically thinking you normally think F is less than N over two fine. And they're all the same, aren't they? I think I mean, yeah.
00:23:20.250 - 00:23:22.918, Speaker C: It'S still a strong input at the exception of preschool.
00:23:23.094 - 00:23:25.500, Speaker A: Okay, yeah.
00:23:25.950 - 00:23:30.490, Speaker C: In all other cases, we're always thinking about honest majority anyways.
00:23:32.930 - 00:23:53.266, Speaker A: That's true. Okay, so we're done then with the synchronous setting. So now we want to move on to the partially synchronous setting. The idea is the synchronous setting is nice and tidy, but maybe it's not that realistic. Sometimes you might want to be able to deal in real life. Sometimes the network goes down. You should be able to deal with that.
00:23:53.266 - 00:24:33.666, Speaker A: Right, okay, so in the partially synchronous setting, the rough idea is that process is told a bound delta, which will hold when network conditions are good. Okay. Sometimes though, network failure might happen and messages might be delivered delayed for arbitrarily long periods. Okay, so now again, the rough idea formalize this. So protocols now have to survive extended periods of network failure and produce outputs when network conditions are good. Okay, so if you're thinking about an SMR protocol, then you should maintain consistency when there's network failure. But then you can't be expected to confirm new transactions when the messages aren't being delivered because you're not even hearing about them.
00:24:33.688 - 00:24:34.018, Speaker B: Right.
00:24:34.104 - 00:25:03.386, Speaker A: So you have to maintain consistency while there's network failure. But then the liveness the confirmation of few transactions should happen whenever network conditions are good. So how do we formally define that? So normally the standard way is to use a little technical trick. Okay? So we formalize this by positing the existence of some unknown Global Stabilization Time. Okay. GST. So it's unknown in the sense that yeah.
00:25:03.386 - 00:25:39.430, Speaker A: So it's not given as an input to the processors. They don't know what it is, but it exists. Okay, let me specify that. Okay, so the bound delta holds after GST, but who knows what happens before GST? Okay, so any message now, if it send at time T is received by time at least at maximum T of GST, and delta by that time could be before. So in other words, if you send before the Global Stabilization Time, it could be delayed right. Until the Global Stabilization time has happened. But if you send after that, then the bound delta holds.
00:25:39.430 - 00:26:28.840, Speaker A: Okay, so that might initially a bit confusing because we wanted to formalize a situation where sometimes network conditions were good, then network conditions were bad, and they were good again and they're bad again and sort of in a continual fashion like that. Right. So why should it be the case? There's some point after which network's conditions are always good. Is that really formalizing what we want? Okay, well, you can kind of see in some intuitive rough argument that this does suffice to capture the more general notion. So we can give an approximate sort of argument, right? Because okay, here we have a formal definition. I guess the more general version I didn't formally define, so I can't give you like a formal proof, but okay, so here's an intuitive idea. These two ideas, this does capture the more general notion too.
00:26:28.840 - 00:27:01.870, Speaker A: So any protocol which functions under the apparently easier GST model will also function under the more general conditions where maybe just continually oscillating between good and bad network conditions. To see that, let's make it concrete. Let's consider a protocol for Byzantine agreement. Would have the protocol ever violated agreement or validity under the more general model, then it also do so under GST. You just have to choose GST to be sufficiently late.
00:27:05.950 - 00:27:06.314, Speaker B: Okay?
00:27:06.352 - 00:27:51.370, Speaker A: So that way this round is fine. On the other hand, if the protocol satisfies termination under the GST model, then for any choice of N, any choice of inputs, any choice of behaviour for the faulty processors and any choice of GST, there exists some T such that all non faulty processes terminate within that time. GST plus T. Okay, so the protocol also terminates under the more general model. So long as network conditions are good for sufficiently long, wherever you are. Basically, if you then make network conditions good for sufficiently long, you have to eventually get some everybody has to terminate. Okay, so this is just I guess it makes it a nice sort of easy it's a nice little trick in terms of giving us a simple way of defining the partially synchronous setting.
00:27:51.370 - 00:28:01.180, Speaker A: Okay? So I guess maybe that's the most standard formalization, the partially synchronous setting. In fact, there's another one, which is this one.
00:28:01.550 - 00:28:02.022, Speaker B: Okay?
00:28:02.096 - 00:28:58.160, Speaker A: So in this one we suppose that the bound delta now always holds. Not just after GST, it always holds, but now we don't know what it is. So the protocol has to function even though we don't know what the bound delta is. So I'm calling that the unknown delta setting. So now it might be annoying because you've got these two different definitions, we don't want to have more cases to deal with. But basically, guys, as long as all we care about is like, when can we make a working protocol for which NNF will a protocol work? You can see that these two definitions are equivalent. First of all, if the protocol works for the unknown delta model, then it works under the GST version because for the execution of the protocol, messages will always be delivered within some bounds delta prime, which is just GST plus delta, right?
00:29:01.960 - 00:29:02.276, Speaker B: Yeah.
00:29:02.298 - 00:29:07.128, Speaker A: So there is some bounds that messages will always be delivered within that bound no matter how long we go on.
00:29:07.134 - 00:29:07.690, Speaker B: For.
00:29:12.300 - 00:29:15.476, Speaker A: Any other direction. It's also like fairly simple, maybe a little bit more tricky.
00:29:15.508 - 00:29:15.656, Speaker B: Okay?
00:29:15.678 - 00:29:18.984, Speaker A: And let's suppose we have a protocol which functions under the GST model.
00:29:19.182 - 00:29:19.496, Speaker B: Now.
00:29:19.518 - 00:29:29.224, Speaker A: I'm going to turn this into the protocol that functions under the unknown delta model. So what do we do? Well, we've got a protocol that functions under the GST model, so we have to give them some value for delta.
00:29:29.352 - 00:29:29.704, Speaker B: Okay?
00:29:29.762 - 00:29:43.540, Speaker A: That's one of the inputs in that model. So let's just give them the input delta as one. Then what we do is a sort of simple trick. So then we insert increasing intervals between the time slots at which processors execute their instructions.
00:29:44.120 - 00:29:44.870, Speaker B: Okay?
00:29:45.960 - 00:29:55.364, Speaker A: So maybe processors might implement their instructions for time T. Actually at time two t, so we're executing the same instructions, we can sort of spacing them out so there's a bigger and bigger gap between them.
00:29:55.562 - 00:29:56.310, Speaker B: Okay.
00:29:56.920 - 00:30:38.870, Speaker A: And obviously then at time two T, we're sort of pretending it's time T as far as our instructions are concerned. Okay, so if we do that, then they don't know the actual value delta, but eventually the time between the points at which you actually carry out the instructions for different time slots would actually eventually be longer than that delta, right? So we don't know when that is, but it would eventually be longer than that delta. So we'll eventually reach a point where whenever I send a message, it arrives before the next point, which I actually execute my next instruction. So we achieve a sort of like a version where we achieve a sort of GST in effect after some point.
00:30:41.960 - 00:30:57.290, Speaker D: Where a protocol that works in the GST model is allowed to completely depend on the known delta. You can imagine there are two different protocols for delta one and two, right, and they don't talk to each other.
00:30:57.900 - 00:31:10.096, Speaker A: Well, no, you have to work for any delta. Right, so you're given delta. So if I'm given a protocol here, I can feed it the input delta is one and it has to function. Yeah. You're not allowed to sign up, you.
00:31:10.118 - 00:31:15.490, Speaker D: Have to refer all yeah, okay.
00:31:18.900 - 00:31:31.396, Speaker A: Yeah, okay, I guess. But generally it won't really matter. I mean, you just be the same thing, but you space it out if delta is five or delta is ten, normally I can like second, sorry.
00:31:31.578 - 00:31:41.364, Speaker D: If I can give a protocol that looks at delta and specifies after the fact what to do and there is no guarantee of consistency.
00:31:41.492 - 00:31:46.124, Speaker A: Well, okay, so here we're giving it a particular delta then, right? So we're giving it the value delta is one.
00:31:46.242 - 00:31:59.736, Speaker D: But there's no guarantee that protocols for delta equal to one and protocols for delta equal to two can talk to each other at all. I can give you a GSC protocol.
00:31:59.848 - 00:32:13.750, Speaker A: That I'm not requiring any protocols to talk to each other. We're just running a single protocol with delta is one. Right, and we're spacing at the points at which we execute the instructions. So all that matters is maybe I'm missing the question.
00:32:14.520 - 00:32:25.252, Speaker C: Doubling is a little unclear to me how exactly the doubling works. So does it just every node independent of what else? Like, do you just send your first message at timestip one, then two, then four, then eight, then 16?
00:32:25.396 - 00:32:45.416, Speaker A: Yeah. Okay. You're just waiting longer before you execute exactly the same instructions. So when it gets to that point, when it gets to time slot two T, you're pretending you're at times lot T and you're executing exactly the same instructions. It's just changing. You're just waiting for longer so that messages will actually will arrive.
00:32:45.448 - 00:32:46.124, Speaker B: Right.
00:32:46.322 - 00:32:49.344, Speaker C: Are you running the protocol again or.
00:32:49.382 - 00:33:05.060, Speaker A: Repeating every instruction multiple times? No, because the protocol once running the protocol once I'm running the protocol in a normal way, I'm just like on the side. Imagine I'm actually spacing out the points at which we actually execute the instructions.
00:33:08.840 - 00:33:21.080, Speaker D: So suppose I construct a protocol for the GSD model. What it does is it will explore every message with the value of delta that is blocked.
00:33:27.120 - 00:33:28.408, Speaker A: So it takes a value for delta.
00:33:28.424 - 00:33:39.680, Speaker D: As input and then it will echo every message. So if two machines are running this for different delta, the messages don't mean anything.
00:33:39.750 - 00:33:41.884, Speaker A: Yeah, but here they're not. They're all running it for the same delta.
00:33:41.932 - 00:33:42.530, Speaker B: Right.
00:33:43.380 - 00:33:45.410, Speaker A: They're all just running it for delta as one.
00:33:45.860 - 00:33:52.204, Speaker D: Look at that. They will proceed in time, block will increase.
00:33:52.252 - 00:34:15.160, Speaker A: Yeah, it's the same sort of thing they're just proceeding through because running exactly the same normal protocol, they got the input delta as one. It's just like unbeknownst to them. Let's imagine I'm God, I'm controlling them. I'm actually just, like, squeezing out the time between which they're executing instructions so that things are getting delivered fast enough. Right. So as far as they're concerned, they're just like, it's just one protocol. They're executing with one value of delta.
00:34:15.160 - 00:34:19.800, Speaker A: Is there a concern that these nodes.
00:34:22.590 - 00:34:25.402, Speaker C: Make the wrong decision and terminate too.
00:34:25.456 - 00:34:52.930, Speaker A: Soon before hitting GST? Well, no, they're just running the standard protocol. They're running a normal protocol. We're just spacing out the time at which it works. So if it works normally, then it has to work here, so long as there is a GST. Right. And here there will be a GST. There'll be a GST, there'll be some point after which whenever I send a message, it's delivered before the next time slot at which we actually execute instructions.
00:34:52.930 - 00:35:32.210, Speaker A: Yeah. This is a rubbish thing to do formally, these two, basically, I want to work with the GST model and I want to throw the other one away so we don't have too many things to think about. So these are formally equivalent in some sense, but okay, this is not obviously an efficient thing to do. I mean, you don't have to double. You could gradually increase it. I guess even that's not going to be an efficient okay, so we all know. So now what can we do? In the partially signal setting, I'm going to concentrate on the GST model.
00:35:32.210 - 00:36:51.224, Speaker A: So Byzantine brocast, byzantine agreement and SMR so, first of all, so Byzantine Broadcast isn't possible if the leader might be faulty. This is very easy to see. Simple proof towards the contradiction, I suppose we've got a working protocol, okay? We've got at least two processes. Okay? Let's imagine, first of all, these non faulty, okay? And let's suppose all messages delivered, like at the next time slot after sending, except that we withhold delivery of messages from the broadcaster, we're delaying GST until some other processor terminates. Can we do that? There's got to be a GST in the end, but we can do that as long as some other processor will eventually terminate. Some other honest process should say non faulty processor terminates then, yeah, okay, well, some processor well, everybody's honest here, so fine, some processor other than the broadcaster must eventually terminate because this execution is indistinguishable, as far as they're concerned, from one in which GST is zero, but the broadcaster is faulty and doesn't send messages, right? I don't know. Which one are we in? Is GST passed and he's just faulty or not? Okay, and then basically we're done, right? So let T be the first time which the processor I and the broadcaster terminates.
00:36:51.224 - 00:37:39.532, Speaker A: We define GST equals T plus one, okay? Now, he's terminated without knowing the broadcaster's input, so we have to be in trouble at that point. Let VBI's output. Now we've got a contradiction, because when he's terminated without knowing the broadcaster's input, so he could certainly get output of the wrong thing, right? Violating the validity requirement. So an execution such as that one in which the broadcaster's input isn't V, of course there are, because he hasn't even been able to say what his input is. Okay, so boys, Ng broadcast isn't possible in the setting, you can weaken it. So it is right? So we could say instead, okay, rather than requiring everyone to terminate, let's say if one honest guy terminates and all honest guys terminate, and if the lead is honest, then the honest guys must terminate and then it becomes possible.
00:37:39.586 - 00:37:39.804, Speaker B: Okay?
00:37:39.842 - 00:38:17.450, Speaker A: But for now, let's just leave that to one side. We've got rid of Byzantine broadcast. Okay. So now then we're interested in Byzant agreement and SMR so for which N and F can we do that? And here again, there's a really sort of simple, fairly similar proof that says you can't do it. If F is more than N over three, doesn't matter whether you have a public key infrastructure, okay? So we're going to approve by sanity agreement. You can easily modify it as well. Okay, so let's suppose N is three and F is one.
00:38:17.450 - 00:38:22.296, Speaker A: Can I get rid of can you see that?
00:38:22.318 - 00:38:22.890, Speaker B: Good.
00:38:23.260 - 00:38:55.730, Speaker A: Okay, so N is three of F is one. Let's suppose we've got processors zero and one here. They're honest, they're non faulty, and they've got inputs A and B, respectively, okay? So A and B, they're their inputs and they're called zero and one. And let's suppose processor two is faulty one. Let's suppose any message sent at time T is received at the next time slot, except we're going to withhold messages between zero and one until after GST. So we're basically not going to allow these two guys to speak to each other.
00:38:58.680 - 00:38:59.430, Speaker B: Okay.
00:39:02.520 - 00:40:04.134, Speaker A: So two Faulties what they're going to do in determining the message it sends to zero. I suppose processor two simulates a non faulty processor with input A that doesn't receive any messages from one. Yeah, so he's got pretending that he's got input A. He's pretending he hasn't got any messages from one, so he doesn't have to worry about forging messages from one or anything like that. Okay, let's suppose in determining message it sends to one, processor two symmetrically simulates a non faulty processor with input B, it doesn't receive any messages from zero. Okay, well, processor zero has to eventually terminate an output A because this execution is indistinguishable as far as they're concerned from an execution in which GST is zero but one is faulting isn't sending messages, they eventually have to terminate an output A in that case. Similarly one's eventually got to terminate an output B.
00:40:04.134 - 00:40:12.250, Speaker A: Okay, so now we got our contradiction because they've terminated and given different outputs. Okay, so nice easy proof.
00:40:13.630 - 00:40:14.380, Speaker B: Okay.
00:40:21.050 - 00:40:40.938, Speaker A: So now basically what we want to do is so if F is less than N over three sorry, F is greater than N over three, it's not possible. We want to show it is possible if it's less than N over three just to deal with BA Byzantine agreement and SMR at the same time. First of all, I want to show you that you can solve Byzantine agreement if you can solve SMR.
00:40:41.034 - 00:40:41.342, Speaker B: Okay?
00:40:41.396 - 00:40:58.830, Speaker A: Where is less than zero three? Okay, suppose we've got a protocol for solving SMR we can solve By Xantine agreement fairly simply, okay? So we run an instance of SMR in which the number of clients is equal to number of processors. I'm going to imagine clients have channels to all processors.
00:40:58.990 - 00:40:59.362, Speaker B: Okay?
00:40:59.416 - 00:41:22.650, Speaker A: I'm going to get again, similar to before, for each I we have processor I also control client i. At time zero. Each non faulty processor I sends a single transaction from client I which is assigned version of its input. It sends that to all the processors.
00:41:25.780 - 00:41:26.240, Speaker B: Okay?
00:41:26.310 - 00:41:37.440, Speaker A: Each non faulty processor then just carries out the SMR protocol until it's confirmed n minus F sine values from distinct processors. And at this point it outputs the majority value breaking ties in some arbitrary fashion.
00:41:38.420 - 00:41:38.784, Speaker B: Okay?
00:41:38.822 - 00:42:09.852, Speaker A: And basically the majority argument work because F is less than N over three. So we'll still have the majority amongst the N minus F values. Okay? So the main point there is it's quite easy to if you've got a protocol for SMR, it's quite easy to see you can solve by Zen's agreement. Okay, so all we've got to do then wrap everything up is just to solve SMR, right?
00:42:09.986 - 00:42:10.284, Speaker B: Okay.
00:42:10.322 - 00:42:29.076, Speaker A: So now we want to show the following thing. So in the partial signal setting, right, we got a PKI by xantine volts. Now we can solve SMR when F is less than N over three. And basically what I'm going to do is describe like a sort of slightly tidied up version of tendermint. It's basically tendermint, but made slightly easier to present, I think.
00:42:29.098 - 00:42:29.670, Speaker B: Okay.
00:42:37.200 - 00:43:19.450, Speaker A: So how does tendermint work? So I guess what we're the rough idea, first of all, okay, that's a general picture. So processes, they're going to take it in turn to act as leader, okay? Protocols be divided into round. Each round has one leader. In each round, the leader is going to propose like a new block of transactions and then the other processes are going to vote on it. So it's a simple sequential process. So one process leader, they propose a new block, everyone's going to vote on it, then someone else will propose a new block, everyone's going to vote on that and so on. That's the sort of basic format we're interested in.
00:43:24.080 - 00:43:24.444, Speaker B: Okay?
00:43:24.482 - 00:43:32.364, Speaker A: So if we're having processes vote on blocks, then it's natural we sort of naturally arrive at the idea of a quorum certificate.
00:43:32.412 - 00:43:32.672, Speaker B: Okay?
00:43:32.726 - 00:43:45.440, Speaker A: So if N minus F processors produce signed votes for a particular block in a particular round of voting, then we'll call that set of votes a quorum certificate for that block.
00:43:46.740 - 00:43:47.104, Speaker B: Okay?
00:43:47.142 - 00:43:53.030, Speaker A: So hopefully it's clear we're asking for N minus F here because we can't ask for more than that because the faulty processors might not give anything to us.
00:43:53.400 - 00:43:54.150, Speaker B: Okay?
00:43:55.900 - 00:44:42.510, Speaker A: So in a particular round of voting, if everyone's voting on a block, if we get N minus votes for a block, we'll call that a quorum certificate. So easy observation then. So if non faulty processors only vote on one block in each round of voting, they're only producing one vote, then two different blocks can't both get QCs in the same round. Just a simple counting argument. Why is that? Well, if we got two QCs, that corresponds to two sets of N minus F votes, okay, that follows easy then, because so for two sets of N minus F processors, two sets of N minus corresponding to two sets of N minus F votes, well, then you've got at least N minus two F in the intersection.
00:44:43.490 - 00:44:43.806, Speaker B: Yeah.
00:44:43.828 - 00:45:15.290, Speaker A: I guess you can see that in this little picture down here, that bit there, that's the size at least N minus two F. Yeah. Okay, so any two sets of N minus F, they've got at least N minus two F at the intersection. We're in the case F is less than N over three, right? So N minus two F is great equal to F plus one. Okay, so any two sets of N minus F have at least F plus one in the intersection. So in particular then they've got at least one honest processor in the intersection because we've only got f many faulty processors.
00:45:18.570 - 00:45:18.934, Speaker B: Okay?
00:45:18.972 - 00:45:53.120, Speaker A: But we said a non faulty processor won't vote twice. That's a contradiction, right? They can't be voting for two different things, okay? So basic fact, okay? So non faulty processors only vote once in each round. We can't get two different blocks getting QCs in the same round, okay? So now that's a basic idea. What I want to do is put forward a really simple idea that doesn't work, and then we'll tweak it a bit so it does work, okay?
00:45:55.090 - 00:45:55.454, Speaker B: Okay.
00:45:55.492 - 00:46:24.220, Speaker A: So first of all, a little bit of housekeeping to keep things simple, okay? I'm going to suppose that whenever a processor sees a block, they have automatically seen all the predecessors of that block in the chain, okay? So if you want to, you can achieve that. Just like whenever you send out a block, you send with it the rest of the previous chain. Or we think that's ridiculous inefficient you could imagine there's some sort of like, change of information protocol where if someone sends me a block and I don't know the predecessor, I say, can I have the predecessor, please? And I don't listen to the block until I've heard the predecessor, right? Something like that.
00:46:26.270 - 00:46:27.020, Speaker B: Okay.
00:46:31.460 - 00:47:08.936, Speaker A: So here's our very simple plan. So we're going to order the QCs by round number, okay? Like I said, we're going to proceed like round one, round two, round three, round four, and so on. Going to order the QCs by round number. So not necessarily according to the height of the block they're corresponding to. Anything like that just by round number, okay? In this simple version we're doing, first of all, so each round is of length two delta, okay? So round r is going to start at time two r delta. Around r is going to be very simple. So at time two r delta.
00:47:08.936 - 00:47:43.400, Speaker A: When the round starts, the leader is going to produce a new block. They're going to do that in a sensible way. So they're basically going to look at the block with the highest QC that they've previously seen produced and they're going to extend that. So they produce a new block and they can send that to all processors. Then at time t, at time t plus delta, right? When we hope that everyone else have heard about that before GST, they might not have done, but after GST they will. At time t plus delta. Then basically they're going to vote on things.
00:47:43.400 - 00:47:54.380, Speaker A: So each processor checks whether they've received a block b from the leader. If so, and if it looks sensible, then they're going to send a signed vote for that block to all processors.
00:47:56.080 - 00:47:56.444, Speaker B: Okay?
00:47:56.482 - 00:48:01.404, Speaker A: So really simple. Basically, the leader proposes a block, everyone waits time delta and they vote on it.
00:48:01.522 - 00:48:05.004, Speaker B: Simple, okay?
00:48:05.042 - 00:48:30.708, Speaker A: And a block is confirmed. In this simple version, that doesn't work if it receives a QC, okay? Okay. So that's very nice. And it's simple, but it doesn't work. I guess it's quite easy to be simple if you don't work. Okay, so why doesn't it work? A block B might be confirmed, a particular round R before GST. The fact that it's confirmed doesn't mean that any of the blocks know that it's confirmed.
00:48:30.708 - 00:49:14.284, Speaker A: They all produce the votes for the block, but they haven't necessarily seen that QC. Yes, they've produced all the relevant votes, but they don't know it's confirmed. And then at the next round, right, so a block B prime, another block, which is incompatible with B, might be proposed and confirmed at the next round. So the problem here is blocks could be confirmed, although basically because when it's confirmed, you don't necessarily see the QC involved. Okay, so that didn't work. But now what we can do is just a really simple little tweak and it will work. Okay, so what happens instead if we put in two stages of voting? So now it's going to be the case that the leader proposes a block, we have a first stage of voting and another stage of voting before the next leader proposes a block.
00:49:14.284 - 00:49:33.960, Speaker A: Okay, so in more detail as follows. Okay, let's suppose so the leader proposes a block. We have our stage one voting, same as before, but now if each processor sees a QC on the block produced in stage one of the round, the first stage of voting, then they produce a stage two vote.
00:49:35.660 - 00:49:36.410, Speaker B: Okay?
00:49:36.940 - 00:49:49.276, Speaker A: And it's a QC in stage two. Now, that means confirmation. The QC in stage one doesn't count for confirmation yet it's a QC in stage two that counts. So it's still hopefully very simple, the same thing. We just added one more round in.
00:49:49.298 - 00:49:53.748, Speaker D: Okay, so now the time that the round takes is more than two delta.
00:49:53.784 - 00:50:26.120, Speaker A: Yeah? Okay, so just to make that concrete, let's write it down. Okay, so again, we're all in acucs by round number. So each round is a length three delta. So round R now starts at time three R delta. So at time T at the beginning of the round, the leader just produces their new block time T plus delta. We do our stage one voting same as before, time two plus delta. Now each processor checks will receive a stage one QC for the block.
00:50:26.120 - 00:51:22.884, Speaker A: And now it sends assigned stage two votes to all processors. Okay, now a block is confirmed and it gets a stage two QC. Okay, so I'm just repeating what I said before, but writing it down again in a slightly formal wise, you have more time to think about, I guess. Okay, so where are we now? So does this work? Well, basically it basically does, right? We just have to finding a tiny Tweak. Okay, so why? Well, so the problem with the previous protocol, right, was that the block might be confirmed, but non faulty processors might not see the relevant QC. So how have we now improved in that situation. Well, now if B is confirmed, okay, well then that means in the stage it gets like N minus F stage two votes, okay? So that means at least N minus two F plus one non faulty processors must sustain the stage one QC, right? Because they wouldn't produce a stage two vote unless they see the stage one QC.
00:51:22.884 - 00:51:57.030, Speaker A: That's when you produce a stage two vote. Okay, so these N minus two F non faulty processors must have seen the stage one QC for the block because we need at least N minus two F non faulty processors to vote in the second round to produce confirmation because you need N minus F round two votes. So you need N minus two F honest votes. So N minus two F must have seen the stage one QC otherwise they wouldn't produce that vote. Okay, so we're in a slightly better situation, right? They haven't necessarily seen the blocks confirmed, but they've at least seen quite a few of them have seen the stage one QC is the point.
00:51:57.720 - 00:52:00.740, Speaker B: Okay, that clear.
00:52:00.890 - 00:52:06.996, Speaker A: So previously a block might be confirmed, no one's seen it, no one's seen the fact that it's confirmed. But now we've got something a little bit stronger.
00:52:07.028 - 00:52:07.224, Speaker B: Okay?
00:52:07.262 - 00:52:28.430, Speaker A: If a block's confirmed, then at least a fair number of the non faulty processes have seen the stage one QC for it. So now what we can do is a little trick. Suppose we now instruct processes have seen the stage one QC to lock on the block B. What does that mean? That means they don't yet consider it confirmed, but they'll now not vote for blocks incompatible with B while the lock's in place.
00:52:31.600 - 00:52:31.964, Speaker B: Okay?
00:52:32.002 - 00:53:17.692, Speaker A: So if they see the stage one QC, they lock on that. It's not yet confirmed, but they won't now vote for incompatible blocks while that lock is in place. If we do that, it's easy to see we get the consistency. So what do we want? We want consistency. In liveness from that, we're automatically going to get consistency. Why? So now if the block B is confirmed around R, right? Then as we're saying, but above, then at least N minus two F non faulty process has become locked on B, right? At least N minus two of the F of them have to have seen the stage one QC and that means they lock on B. But now, since at least N minus two F non faulty processes are required to produce any QC in subsequent rounds, in particular like a stage one QC, this makes it impossible for any block incompatible with B to get a QC in subsequent rounds.
00:53:17.692 - 00:53:53.608, Speaker A: So once they've locked on that, no subsequent block, no incompatible block can get even a stage one QC and become confirmed. Okay, so this is a simple little trick. We've definitely got consistency, okay? So we're happy. Okay, so we have two stages of voting. If we consider blocks confirmed when they see a stage QC but already have processes lock on a block when they see a stage one QC, then we'll satisfy consistency. That's where we are so far. The slight danger now, and it's not too much of a problem, but we can easily solve it.
00:53:53.608 - 00:53:58.552, Speaker A: The slight danger is that we might threaten liveness.
00:53:58.616 - 00:53:59.230, Speaker B: Okay?
00:53:59.760 - 00:54:37.736, Speaker A: So now what could happen was, so for example, so a single non faulty processor could become locked on some block. Maybe they see the stage one QC but no one else does. Maybe it's just them that gets locked in the next round. A single non faulty processor J, might get locked on some incompatible block. If they get locked on those things, we've split the honest processors and now we can't confirm new blocks because if the faulty processors do nothing, then you need all the non faulty processes to be voting to get anything confirmed, right? You need a minus f signatures. So if they're now split, then it seems like we're in trouble. Okay, so now it's not possible to confirm new blocks if faulty processes do nothing.
00:54:37.736 - 00:55:02.080, Speaker A: This though is going to be easy to fix. So basically after GST, these QCs will be seen. So we can have a processor release their lock on some B if they see a higher QC for an incompatible block. So this one here, who's stuck on the first block there, if they see this second QC here, if they see at a particular point in execution, they're going to release their lock when they see the higher QC.
00:55:02.820 - 00:55:03.570, Speaker B: Okay?
00:55:03.940 - 00:55:45.564, Speaker A: And this will make things work out. Now, if we do that, the important thing is that this doesn't spoil our previous consistency argument at all. If we're releasing a lock in that situation, it doesn't spoil the previous consistency argument. So let's go through again. So if the block B is confirmed around R, then at least N minus two F non faulty processes become locked on B. And since at least N minus two F, non faulty processes are required to produce any QC, no subsequent block can get a QC if it's incompatible with B. That's still true, right? There's no situation here where here the context doesn't arise where we release a lock because we see a different QC, right?
00:55:45.762 - 00:55:46.510, Speaker B: Okay.
00:55:50.660 - 00:56:29.164, Speaker A: So summary so far before we just write down the protocol. So we have two stages of voting each round. If our processors lock in a block when they see a stage one QC, if they release block when they see an incompatible block with a higher QC and they consider a block when it confirmed, when it gets a stage two QC, then we'll satisfy consistency. And I'm saying it's going to be quite easy to show that we satisfy liveness as well. So we'll see that after we define the protocol. Okay? So first of all, they're sort of boring preliminaries, okay? So processes begin with their lock set to be the genesis block okay, corresponds to round zero. All blocks and votes contain their round and stage number.
00:56:29.164 - 00:57:11.960, Speaker A: I guess you can sort of ignore most of these points if you like. Okay, we consider the obvious order on QC. So I said they're ordered by their round number, but okay, we also had two stages of voting now, right? So we ordered them by the round number and then the stage number within the okay, this point is maybe more significant. Okay, so I'm going to assume each message has attached the block with the highest QC seen by the sending processor together with that QC. So it's just going to make it sort of convenient in the liveness argument. So if I'm sending out a vote, if I'm sending out a vote or send out a block, I send out together with that vote. I take the highest QC I've seen and I attach that, I pin that to the message together with the corresponding block.
00:57:15.980 - 00:57:16.344, Speaker B: Okay.
00:57:16.382 - 00:57:37.660, Speaker A: And the highest core and blower block is kind of what you think it would be. It's the highest QC corresponding to any block amongst B and its ancestors predecessors. Okay, here's the protocol then. So this is basically just the same protocol we wrote out before. All I'm adding in is the business with the locks. Okay, so it's basically what you saw before. Tiny bit added.
00:57:37.660 - 00:58:08.824, Speaker A: So each round is length three delta. So round R starts at time three R delta. Round R has processor R mod n as leader. At time the start of the round, the leader produces a new block, time T plus delta. We do our stage one voting. So each processor checks if it's received a block from the leader, if so, and if it extends their lock, or else if the highest QC below B is as high or higher than they've previously seen. And in that case, if that's true, then they release their lock, then they send a stage one vote.
00:58:08.824 - 00:58:48.068, Speaker A: So basically it has to extend their lock or it has to be a situation where it's even a higher QC than their lock and they should release their lock. Then time T plus two delta. We do stage two voting. So each processor checks if it's seen a stage one QC for B, and if so, then it sets B as its lock and sends a stage two vote to all processors. Okay, as before, a block is confirmed when it sees a stage two QC. Well, you said highest is we order by round and then stage within the within round. Okay, so we've already proved consistency.
00:58:48.068 - 00:58:49.530, Speaker A: The same proof works.
00:58:50.140 - 00:58:56.508, Speaker C: Why is that important? I thought you're only using you're only locking based on stage one.
00:58:56.674 - 00:59:18.240, Speaker A: Oh, it doesn't matter. No, you're right. I mean, yeah, doesn't matter either way. Okay, so we want to prove consistency. So liveness isn't that hard either to go through the liveness proof. Okay, so we consider around just consider any round with. A non faulty leader that begins at time T, which is at least like GST delta after GST.
00:59:19.700 - 00:59:24.032, Speaker B: Okay? Okay.
00:59:24.086 - 00:59:47.656, Speaker A: Let B by the highest lock. So the worry is that they might propose a block and honest process won't vote for it because it doesn't extend their lock. That's the worry. But let B be the highest lock. I hope I'm the greatest round number amongst all the non faulty processes at time T minus delta. That's the last time they could have set their lock. Okay, well, basically they'll ascend a vote at that time, which the leader will receive.
00:59:47.656 - 01:00:42.902, Speaker A: So he'll have seen all those QCs, right? He'll have seen this corresponding QC. Okay, so the nonvaulty leader will see the corresponding QC by time T, and they'll propose a block that all the honest processors are going to be happy to vote for, basically. Okay, all non vaulty processes will then, because they're happy for it, they'll produce votes for the block in stages one and two, and then we got a confirmed block. Okay, so that's a simple liability argument. Okay, so that was like, well, a version of sort of tendermint like protocol. Just before we leave it behind, we can make it even simpler. Okay, so there we started off with this idea of like a one round thing where the leader proposed a block and everyone voted and we said, that doesn't work, so we had to put in two rounds.
01:00:42.902 - 01:01:08.020, Speaker A: In fact, you can make the really simple one work as well if we now take the ideas we've developed, okay, basically by chaining things. Okay, so what we can do, yeah, we get a simple protocol with a single round of voting if we apply our new notion of confirmation together with locking. So I won't describe this informally or completely, but here's the basic idea. So rather than having two stages of voting in each round, we have a single stage, but we have votes for that stage count in two ways.
01:01:08.550 - 01:01:09.300, Speaker B: Okay?
01:01:10.390 - 01:01:27.590, Speaker A: So first of all, they count as a stage one vote for that round, right? The block at that round. And if that block extends at like a round R minus one block with a QC, we also consider them as like a stage two vote for the previous round. So now playing two different roles.
01:01:31.690 - 01:01:32.198, Speaker B: Okay?
01:01:32.284 - 01:02:07.140, Speaker A: So now obviously, QC's correspondence, two compatible blocks and two successive rounds, R and R plus one. Then we consider the block at round R confirmed. Okay, so we've basically managed to make that initial, really simple critical work. Well, see, when you see one block confirmed, okay, yeah. You see two successive blocks with QCs, then you consider this one confirmed. It's affecting finality, but yeah, it's not really impacting latency either because you have to have two rounds before right.
01:02:12.060 - 01:02:12.520, Speaker B: Okay.
01:02:12.590 - 01:02:33.916, Speaker A: So just to summarize where we are, so that's the result so far. Okay, so got Byzantine agreement, byzantine broadcast, SMR synchronous with PKI synchronous. No PKI synchronous. Although I've written Psych PKI. Okay, yeah. So if synchronous setting with PKI, we know Byzantine agreement can't be solved if F is greater than N over two. Greater than or equal to N over two.
01:02:33.916 - 01:03:06.680, Speaker A: But it can if it's less Byzantine broadcast, NAF and SMR if F is less than N over two. But again, the setup there, the precise definition of SMR matters a little bit for that to happen. This if we have no PKI, we saw, we can do it even only if F is less than N over three. In the partially synchronous setting, we saw we can't do Byzantine broadcast, but we can do the other two if F is less than N over three. Okay, so to finish off then, let's just compare those results with what happens with permissionless protocols and specifically what happens with Bitcoin.
01:03:07.100 - 01:03:07.512, Speaker B: Okay?
01:03:07.566 - 01:03:53.160, Speaker A: So in what sense does Bitcoin satisfy SMR? First of all, so far we've been talking about deterministic protocols on differences. So Bitcoin is probabilistic, as I guess you're probably aware. So Bitcoin only works in the synchronous setting. Okay? Doesn't work in the partially synchronous setting. We still have to ask the question, does Bitcoin actually satisfy SMR? And maybe that depends on how you define SMR, right? So we also had this, like, lazy client condition, right? So just remind you what that was. The way we defined SMR was a client should receive F plus one confirmation for a given transaction, even only if it's confirmed. Okay? So obviously we don't yet have a definition that makes sense, actually, in the permissionless setting, right? Because that doesn't work in the permissionless setting.
01:03:53.160 - 01:04:08.024, Speaker A: But the idea behind that definition was that we wanted the clients to be passive and also lazy. So idea is they could sort of go away, pay no attention, come back, and they know accurately when transactions are confirmed.
01:04:08.072 - 01:04:08.670, Speaker B: Right?
01:04:09.840 - 01:04:53.784, Speaker A: Okay, so does Bitcoin satisfy that condition? So if you put your transactions in, you go away and you come back. It could be that the set of miners has changed entirely. You don't know who they are, you don't know what the longest chain is. If you can connect to someone who's an honest miner, then you can learn what the longest chain is, et cetera. But how do you know who's honest? Right? So you can try and connect into lots of different people, but potentially there could be a civil attack in which they just have loads and loads of different miners with low computational power. How do you know whether people are honest or not? Right? So you can ask, does Bitcoin really give a permissionless solution to SMR? It defends against civil attacks, and it depends on your definition of SMR. If you require that lazy client condition, then it doesn't.
01:04:53.784 - 01:05:15.330, Speaker A: But okay, maybe it's not that serious, because it does allow clients to go away and come back and learn correctly what's happened, so long as when they come back they connect to at least one honest processor. Right? But still, strictly speaking, if we're being they're difficult about it, that doesn't provide a permissionless defense against civil attacks, right?
01:05:15.940 - 01:05:16.690, Speaker B: Okay.
01:05:19.220 - 01:05:23.596, Speaker C: In the previous setting, we all need to connect to somebody who's curdf plus one.
01:05:23.718 - 01:05:37.216, Speaker A: Yeah, okay. But in the previous setting, I could ensure I do, but we weren't worried about civil attacks also, was the point. But I could ensure I do just by connecting to F plus one. I know I'm connected to someone who's honest. There's a simple way of doing it. And also, I'm not worrying about civil attacks here. I am worrying about civil attacks.
01:05:37.216 - 01:05:44.300, Speaker A: I'm sort of regarding that as being a problem. Do you see what I'm saying? I mean, you can say that that's fine, and I'm happy to go along with it.
01:05:44.450 - 01:05:46.430, Speaker C: Fundamentally, that's the same thing.
01:05:50.880 - 01:06:08.050, Speaker A: Right? There's a claim made, isn't it, about Bitcoin? The idea is this provides a permissionless solution to SMR that defends against civil attacks, right? So in the previous setting, okay, fine, we had to connect to an honest guy, but we weren't worried about civil attacks. That wasn't really an issue here. I'm saying that's supposed to be an issue, right?
01:06:08.900 - 01:06:29.450, Speaker C: The way I would phrase it is in both the context in some sense, the assumptions exactly the same, that they can figure out one on a snow to connect to. And then you can say, by the way, if you're in the permission setting with known F, a strategy to guarantee you doing that is that plus one people, whereas in permissional setting, so unspecified how you might go about.
01:06:33.280 - 01:06:35.468, Speaker A: I think that's a more positive way of putting it.
01:06:35.474 - 01:06:35.596, Speaker B: Fine.
01:06:35.618 - 01:06:49.744, Speaker A: Okay. Yeah. Okay. So anyway, maybe we're happy with that anyway, right? It seems to seems to work. That's fine. Okay. So now let's suppose we're happy.
01:06:49.744 - 01:07:05.296, Speaker A: Assume clients can connect to at least one on its node. Maybe that's not too much of an issue anyway, right? So then how do we compare that with results in the permission settings? So I guess a natural thing you might do is you might compare it to this bitcoin is working without a public infrastructure.
01:07:05.328 - 01:07:05.476, Speaker B: Okay?
01:07:05.498 - 01:07:31.548, Speaker A: So it's working in the synchronous setting, not the publicly partially synchronous setting. So you might want to compare it with this result here, right? You might say, well, Bitcoin works whenever F is less than N over two, which is definitely better than F being less than N over three. That's good. But in fact, it's more better than that. Why? Well, because proof of Bitcoin don't normally assume authenticated channels. So I don't really need authenticated channels for that. In some sense.
01:07:31.548 - 01:08:03.804, Speaker A: Suppose process is just like broadcast messages to all in some sense, because they spread across the network. So in the permission setting without PKI and with broadcast, in the sense that if I send a message at time T, everybody has to receive it within time T plus delta, then it isn't possible to handle even a single faulty processor. So in that sense, Bitcoin is raising F equals zero to F less than a half. So it's making a big improvement. Okay, so finish a little early, but thanks for listening.
01:08:03.852 - 01:08:04.450, Speaker B: Okay.
01:08:13.160 - 01:08:15.220, Speaker A: Go back to the previous slide.
01:08:18.760 - 01:08:22.900, Speaker C: Which results does the mission study without PKI?
01:08:24.120 - 01:08:32.776, Speaker A: Yeah, there are a couple of papers. There's one with I forget all the authors from 2005 or so. I think I can also show you a sort of simple proof later on as well.
01:08:32.798 - 01:08:33.370, Speaker B: Okay.
01:08:36.060 - 01:08:37.396, Speaker A: Well, basically, imagine the setting.
01:08:37.428 - 01:08:37.624, Speaker B: Okay.
01:08:37.662 - 01:08:57.440, Speaker A: Imagine we're doing broadcast. There's no sort of private channels between each of us. If I'm the adversary, I'm the bad guy. Whenever you speak, I can just be annoying and say the opposite of you and I can simulate all of you, right? If there's no restriction on how I can simulate people. So whenever you speak, I'll just say the opposite and then how could anybody else listening in distinguish between what's happening?
01:08:57.510 - 01:08:58.130, Speaker B: Right.
01:09:01.670 - 01:09:10.920, Speaker C: Do you want to comment? Slide back. It almost looks like a mathematical contradiction, like everything you said, right?
01:09:13.370 - 01:09:58.062, Speaker A: Say again? How is it a contradiction? So you're saying how does Bitcoin overcome that? You're saying yeah, okay, so I guess it overcomes it by so if you look at the proof we did that proved that result. So we had the sort of six node version. We had the four node version. It's crucial to that proof that the adversary is able to simulate a certain number of processes. Right. So in the six node version, actually, that's less relevant here, right? The four node version, the one that matters, it was necessary there that the adversary could simulate, like, half the processors in that proof. So if you change their ability to do that, if they can't, if you strip their ability to produce hashes and stuff, then that proof falls apart.
01:09:58.062 - 01:10:03.640, Speaker A: And that's another reason why I think the four node version is interesting. I think it shows you exactly the point on which it falls apart as well.
01:10:04.010 - 01:10:05.378, Speaker C: Why is it irrelevant?
01:10:05.554 - 01:10:16.682, Speaker A: So in the 6th node version, in order to the aversion would have to be able to simulate like two thirds of the processors to cause a problem. In the four node version, they only need to be able to simulate half the processes to cause a problem.
01:10:16.736 - 01:10:17.340, Speaker B: Right.
01:10:20.510 - 01:10:28.080, Speaker A: So if you strict them to being able to simulate less than half the processes, if you take like F less than over two, then it's fine, right.
01:10:29.250 - 01:10:32.334, Speaker C: You can't simulate anything more than what you are.
01:10:32.532 - 01:10:42.334, Speaker A: Right, okay. But your general requirement is that the adversary has like less than half the computational power, so they can't sort of simulate more than the rest of the guys there.
01:10:42.372 - 01:10:42.910, Speaker B: Right.
01:10:43.060 - 01:10:51.060, Speaker A: So if you inspect those two proofs, I think the I think the the N equals four the the four node proof is more informative than that in more in that regard.
