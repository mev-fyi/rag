00:00:00.330 - 00:00:00.880, Speaker A: You.
00:00:04.370 - 00:00:52.474, Speaker B: Welcome to Web Three with A Six and C, a show about building the next generation of the Internet. From the team at A Six and C crypto that includes me, your host, Sonal Choxi. This show is for anyone seeking to understand and go deeper on all things crypto and Web Three, whether developer, creator, builder, business leader, or policymaker. And we're now back with an all new season of Episodes. Today's episode is actually all about programming languages and crypto, and it's for both existing smart contract programmers as well as other developers seeking to enter the space. And for anyone who's just curious about how programming languages evolve and come into existence as well. Our special guests today include Sam Blackshear, co founder and CTO of Miston Labs, which is building foundations for the decentralized future of Web Three.
00:00:52.474 - 00:01:40.026, Speaker B: Sam has a long history in programming languages, from his PhD to working at Facebook to creating and being one of the authors of Move and Open Source Programming Language for building smart Contracts. And we'll talk more about that. And throughout this episode, we also have Noah Citron, smart contract and research engineer here at A Six and Z Crypto, who also recently authored a light client for Ethereum called Helios, and he won a challenging gas optimization challenge with another partner here, which we briefly allude to. And finally, we have Eddie Lazarin, head of engineering for Asics and Z Crypto. Before that, he was in software engineering at Netflix, as well as data engineering and data science at Facebook. As a reminder, none of the following is investment, business, legal, or tax advice. Please see asicsandzoo.com
00:01:40.026 - 00:02:18.550, Speaker B: disclosures for more important information, including a link to a list of our investments. Stick with us for the fun and fascinating ride in this episode because we cover everything from differences and similarities in conventional programming languages versus smart contract programming. We discuss and debate the unique constraints and opportunities of blockchains, and also touch on topics such as formal verification, governance and community tooling, cross platform adaptation, and much, much more. But we begin with the history of traditional programming, and the first voice you'll hear is Noah's, followed by Sam's. And then Eddie's.
00:02:19.610 - 00:02:31.866, Speaker C: We want to hear a little bit about how the history of programming affects the history of smart contract programming, because there's sort of, I feel like three things going there's, like traditional programming, smart contract programming, and then there's Move. And all three of those things have its own history, right?
00:02:31.968 - 00:02:41.674, Speaker A: Yeah, I love that framing. I mean, people with languages are like, oh, languages are about designing syntax or about making people really happy, and it is about those things, but it's not just about those things. So I love this big picture framing.
00:02:41.802 - 00:03:30.478, Speaker D: Yeah, well, just building on that in traditional programming, there have been all these trends over the last 2030 years. Over the years, traditional programming languages have changed. There have been different topics that have been trendy and come and go. There was a long time where dynamic programming languages and being very loose about type checking and types in general was kind of the way to go. It was thought like it's more ergonomic just to jump in, forget the types, forget all the cruft, just like write the code. But more recently it's been the way to go to think really deeply about type systems and static typing and compile time checks and things like that, to learn the most you can about a program before it even runs. There have been these ebbs and flows, however, for smart contract programming, just because it's so new.
00:03:30.478 - 00:04:00.934, Speaker D: We haven't had this type of history in smart contract programming, which I think is very different. And I think Move is some of the first evidence we've seen about how different it is and how differently you can design a language to accommodate that. I'd love to get into what are the types of things that we expect to change? Like what are the potential static versus dynamic typing type of topics in smart contract programming that maybe haven't yet emerged just because there's really only been one language, there's really only been solidity.
00:04:01.062 - 00:04:40.950, Speaker A: Yeah, absolutely. So my take on programming language design is that programming languages are problem solving tools. So a lot of the trends we've seen in language design is about what new problem arose and what sort of language came in to fill that niche and then what was important for that particular kinds of problem. So you look at say, JavaScript for example, this arose to fill the niche of these web things and we need some programmability beyond just static CSS and we need a way to talk about moving around Dom elements and communicating with the back end and all these sorts of things. And in that environment, the thing that was the most important was Dynamism. Web page is constantly evolving for many reasons. Like you don't just want to be refreshing or redoing everything after the fact.
00:04:40.950 - 00:05:19.838, Speaker A: So both in the language and the frameworks built on top of it, like things like React, it's all about Dynamism, it's all about reactivity, it's all about just making things as flexible as possible. And so that's one example of a language trend and why it went that way. And then you mentioned you also see a movement in the other direction like static type systems, safety more predictability. And I think a lot of where that trend came from is also with programming the web less client side, but more on the back end. We started off with Ruby on Rails or Python or all these very dynamic backend languages, even JavaScript itself to some extent. And then folks started off by building these very nimble startups that worked well because they could leverage the Dynamism of these languages to build products quickly and to iterate quickly. PHP and then Hackett.
00:05:19.838 - 00:06:08.126, Speaker A: Facebook is another example. And then over time as these matured from these small startups into much larger companies, they discovered, hey, it's really difficult to maintain these code bases, to refactor these code bases to keep things safe. It's great for iteration speed, but as time goes on, you actually really want the static types to be able to have a large number of programmers working on these code bases and to keep them functioning reasonably. And so you started seeing a lot more interest in static type systems, both in languages to be used for backend programming and also retrofitting type systems onto existing languages like they did with Hackett Facebook, like Stripe has done. With the Sorbet type system for Ruby, even for Python. Like, there's mypy and so there's a line of research from my field, Renji Jaws, that types One. There's this long debate of dynamic types for static types and Types One, even for the languages that are statically typed by like, everyone has some sort of way to retrofit types on top.
00:06:08.126 - 00:06:16.386, Speaker A: And I think we really understand that you can have the flexibility of Dynamism but then bring the types in once you actually know what your code is supposed to do and you want to be able to maintain it.
00:06:16.488 - 00:06:19.574, Speaker B: So how does that connect back to the shift to smart contract programming again?
00:06:19.612 - 00:06:56.014, Speaker A: Sam yeah, so working that into the smart contract space a bit, there's a different set of trends where with the EVM is the first entrant in the space of smart contract languages. So folks didn't really know what do people want to do with smart contracts, how do we program them, or any of these sorts of things. So I think flexibility was much more important to try to know what kind of expressivity needed to discover the use cases. And I feel like now we, we kind of know, or at least we have some idea of what the building blocks or sort of the trends are. Like with smart contracts, they're extremely domain specific. You sort of define templates for assets, you define policies for transferring assets, you check access control and permissions and that's basically it. You don't do other things.
00:06:56.014 - 00:07:06.578, Speaker A: You're not going to use a smart contract language to write a compiler or to write an operating system or any of these sorts of things. So they're very niche in what they do compared to a general purpose programming language.
00:07:06.754 - 00:07:56.994, Speaker D: No, I think that people undervalue how even the ERC 20 standard occurred a long time after it was possible to program the EVM, even something that we take for granted as such a basic building block of writing a program in Ethereum. And I just don't see any evidence that it was obvious before that what the most basic things were. So you're right that now that you can kind of take for granted, I mean, I think of types and those things as Circumventing. Writing types in a programming language is like being able to take a degree of technical debt. Right. If it's small, you just want to move really quickly and the code is something that you can toss away, that debt is totally acceptable. But what's funny is you framed it in terms of the size of the startup or the size of the company.
00:07:56.994 - 00:08:39.406, Speaker D: A small company, you're moving quick. Everyone kind of has the whole code base in their mind. That type of debt is tolerable, but when it's really big, there's tons of people changing the code. They don't know what consequences the new types of objects and systems they're building have. Putting that into the type system makes it so that you know what walls you're running up against as you're writing code in an explicit, straightforward way, as opposed to accidentally creating a pane of glass that someone's going to crash into later. But what's interesting is that the set of constraints is different but becoming more obvious in blockchain programming. For example, like you were talking about being able to prevent copying, being able to set a maximum supply of an asset.
00:08:39.406 - 00:09:15.386, Speaker D: These are constraints that are really important to maintain independent of the size of the project. They're constraints that are important to maintain for the sanity and safety of the project. And understanding what those boundaries are means you can now create programming languages that allow you to enforce them. That's kind of how I think about move is as we've learned about the types of constraints we need to do things properly, we now have the ability to include them in the language themselves. So I do see a parallel with the way types have won. As you were saying, you mentioned that.
00:09:15.408 - 00:09:28.958, Speaker C: Types are a lot of times for the sanity of the program and safety of the program. You guys said that dynamic might be good for small things, but as they grow, you should be static. I kind of disagree. I think this might be a hot take. It's for the sanity of the programmer.
00:09:29.054 - 00:09:29.474, Speaker D: That's right.
00:09:29.512 - 00:09:46.598, Speaker C: The scariest thing I've ever seen is when I've got one of my key binds is control K and it tells me what the function signature is. And when I write Python, it terrifies me. I look at a function signature, I just get names of the parameters. I'm like, what do you want from me here? I can't believe people accepted that that was a great way to write code.
00:09:46.684 - 00:10:01.258, Speaker D: That was never well, what they were accepting was just the task that they were taking for granted that they can maintain the requirements of the system in their mind. And that is probably not an acceptable thing to take for granted in contract context.
00:10:01.354 - 00:10:07.118, Speaker C: But I mean, I don't even think I could take that one for granted in 100 line program. Yeah, I can't keep that many things in my head at once.
00:10:07.204 - 00:10:42.134, Speaker A: I think you're totally right about that. And I think that mindset has kind of evolved where before it's like, oh, type systems are to protect programmers from their colleagues once your startup gets too big. But now it's more like, oh, it's actually to protect me from myself and in the smart contract setting, it's to totally protect me from attackers. And I think that's really the thing that's actually super different here, because a normal program, you don't deploy it in a setting where the attacker is subject to the type system. The attacker is deploying some machine code, or they could write in a different language and you just protect yourself via a firewall. But here it's like, I write this nicely typed object and it's going to flow into an attacker's code and maintain its integrity. And the type system has to have my back on that.
00:10:42.134 - 00:11:02.910, Speaker A: And as you were saying, Eddie, that's a great point. That gives you a different set of things you need to enforce, like preventing copying. That's not something you think about with a normal type system or prevent dropping or making sure that you use a value in a certain way or destroy in a certain way. These are because we're studying smart contracts and trying to provide the type system that makes sense for those use cases. These are the type of things that we end up putting into move and probably into future smart contract languages.
00:11:03.250 - 00:11:26.806, Speaker B: Fascinating. Actually, you guys, let's talk more about other differences between traditional programming and smart contract programming. But before we go further, could you guys give me a quick lay of the land of what languages are at a smart contract programmer's disposal? I actually think we need to orient the big picture here a bit. Know, I like to kind of have the map and the terrain, like, what's out there? Solidity, viper, et cetera. Noah, can you take this one really quick?
00:11:26.908 - 00:11:27.174, Speaker A: Yeah.
00:11:27.212 - 00:12:01.438, Speaker C: So I guess the basic land is that at the moment, if you want to write a smart contract, you're going to write it in Solidity almost always, unless you happen to be in one of the couple of other smaller ecosystems. If you're in the Solana ecosystem, you're going to write it. Solana is like a rust thing, right? If you're in the Cosmos ecosystem, you're using existing programming language. If you're in the StarkNet ecosystem, you can use Cairo. But for the most part, if you're just like, default and if I'm giving the advice like, hey, I want to learn how to write smart contracts, say, okay, go learn some solidity, learn to EVM, you might also want to use Viper. The only downside is Viper is newer. It's potentially more exposed to bugs.
00:12:01.438 - 00:12:11.274, Speaker C: I remember a few years back, they found a bunch of bugs in the Viper compiler when they were verifying the E two deposit contract, which the person who found that was actually now works at a 16 z is Dayjune.
00:12:11.342 - 00:12:12.198, Speaker B: That's so cool.
00:12:12.284 - 00:12:35.726, Speaker C: Yeah, because Dayjune is like a formal verification maxi. Like he studied that and I guess that's sort of the reality is that you need to learn Solidity. And what's even a little bit worse about needing to learn Solidity is that if you want to be really good you really need to learn devm. All of the best smart contract engineers I know know vevm to ridiculous level to a point where you could say how much gas each individual Op could cost and they can tell you the exact calculation for the gas costs. And that's sort of the world we.
00:12:35.748 - 00:12:36.910, Speaker A: Live in at the moment.
00:12:37.060 - 00:13:23.710, Speaker D: There is maybe a point worth making is that you can always as a software engineer learn about the machine that you're running code in. There's a lot to learn about the environment you're programming in. But in smart contract programming in particular, the environment is very rich and the environment is very complicated. And there's a lot of context you need to understand that have almost nothing to do with the language in itself, has to do with just what is around you, what objects are around you? How are different pieces of code invoked? That's a really strange thing. Much more strange than in other programming languages. I would say the closest thing I can think of is thinking about the Dom when writing JavaScript for the browser as opposed to JavaScript in itself. But it's even more involved than that.
00:13:23.780 - 00:13:28.874, Speaker B: And then is it true that the closest analog to learn Solidity is people who know JavaScript?
00:13:29.002 - 00:13:38.066, Speaker C: Everyone says it's JavaScript because function like you use the keyword function right? And they're like, oh, JavaScript uses that as well. But unfortunately there's not really that much like it.
00:13:38.168 - 00:13:55.874, Speaker D: Syntactically solidity does inherit a lot from JavaScript and if you squint or are having a really rough day, it may look similar but it is not similar. The virtual machine's environment is just so radically different that there's very little to preserve.
00:13:56.002 - 00:13:58.550, Speaker B: Yeah. So there any analog that's close?
00:13:58.700 - 00:14:19.450, Speaker A: Yeah, I think there's no direct analog. I think if you're familiar not with say JavaScript but with WASM and sort of like trying to write WASM in a setting where you care a lot about isolation. Like in serverless for example, they use WASM and you try to write containers that do independent things that communicate with each other a little bit but not too much. That's maybe the closest, but it's still not very close at all. It's a very different mindset. False similarity can be dangerous.
00:14:19.530 - 00:14:35.858, Speaker D: Yeah, maybe related to just big mistakes in programming language history. I don't know if there's things that you think were just like really bad paths in the IDMAs that we went down in programming language history related to blockchains or not just like are there just like awful paths we went down?
00:14:35.944 - 00:14:36.930, Speaker B: That's such a good question.
00:14:37.000 - 00:14:41.222, Speaker D: That's a Noah question by the way. Just I want to give Noah credit for that question. Go ahead.
00:14:41.356 - 00:15:00.362, Speaker A: So yeah, that's a great question. So 1977 was the year that C came out and was also the year that standard ML came out. Now, standard ML is amazingly influential. Now, like, there's this Ocama language. Rust is super strongly influenced by standard ML. Move is super strongly influenced. But those ideas have been out there for a long, long time.
00:15:00.362 - 00:15:20.690, Speaker A: I think a lot about the alternative future where instead of C becoming very popular and very dominant, maybe folks pick up the ideas of standard ML, like the strong typing, the built in safety, and where does the competing landscape go from that? So I'm not saying that's a mistake, but I think ML seems so modern even today and just to think about that alternative universe, I think is an interesting thing that blew my mind when I first found out.
00:15:20.760 - 00:15:37.858, Speaker D: Just out of curiosity, why do you think that C and similar languages that are just so straightforward, so imperative, they think about the computer on a relatively low level, right? They're not doing a lot as programming languages. That's how I think about C. Why did we go down that path?
00:15:37.954 - 00:16:11.726, Speaker A: So I think hardware limitations at the time these came out basically forced you to use C if you were going to write really efficient programs or to push the boundaries of what you can do with computing, period. I think maybe if you fast forward the hardware, you go on a different path. But I think also functional programming is hard and it's sort of like counterintuitive in many ways. I mean, not that C isn't hard, but I feel like it's easier to get into and then you realize, like, oh, I've actually done this very, very complex thing, or this thing that's hard to reason about, but it's sort of too late now. That's a good point. With functional languages there's a steeper learning curve, but once you get there, you're like, oh, I can really reason about the pieces that I have independently and things work out nicely.
00:16:11.758 - 00:16:33.498, Speaker D: Well, I think if you think a lot about how a computer works on a hardware level, a language like C is more straightforward. But if you don't know a lot about programming languages as such, then C is more preferable. But if you think a lot about programming languages, then I think ML and functional programming and those types, they have a lot more flesh, like, they have a lot more to them.
00:16:33.584 - 00:16:34.150, Speaker A: Totally.
00:16:34.230 - 00:16:36.262, Speaker B: That's a fascinating observation.
00:16:36.406 - 00:16:42.390, Speaker A: That's the big picture answer. I mean, this is going in a different, more small scale, like, quote unquote, computing or language mistake.
00:16:42.470 - 00:17:14.946, Speaker C: Wait, so I'm sort of torn on this because the thing is, I've always heard how great functional programming is done. A little bit of it found it to be quite difficult to sort of grock my head around. But the question I always have is, if it's so great, it never was able to overcome the network effect of current programming languages like that. It surprises me that it really hasn't. But I will add that I think the great contribution that functional programming gave to us was that all the imperative languages we use borrowed all of its best things. Like you just said, Rust is super influenced by standard ML. But Rust is basically an imperative language.
00:17:14.946 - 00:17:18.914, Speaker C: Right, but it's got all the wonderful Pixie Dusks that came from standard ML.
00:17:19.042 - 00:17:45.566, Speaker A: Totally. I think that's really the thing is the imperative languages were too influential from 1977 onwards. And then there was pure FP, which, as you say, isn't the greatest. Like it has its great ideas in isolation, each of them have their own issues and we're only really seeing true hybrids like Rust that marry them beautifully now and it's really changing the landscape. So the one other thing I was going to mention, which know, Tony HoR calls the Noel dereference the billion dollar mistake. And at the time he said that I think he intended to be hyperbolic. But I think it's clear this cost way more money than no, no, it.
00:17:45.588 - 00:17:46.758, Speaker D: May be a lower bound.
00:17:46.874 - 00:17:47.540, Speaker A: Yeah.
00:17:48.550 - 00:17:58.854, Speaker C: I was actually curious one question which you didn't really talk about, about innovation at the virtual machine layer versus the programming language layer and how that plays out generally over smart contracts as a whole.
00:17:59.052 - 00:18:36.730, Speaker A: Yeah, it's a great question. I think people don't think about these distinctions enough like the difference between the virtual machine and the programming language. I think there's been a lot of innovation beyond the EVM and new virtual machine layers and then also like a lot in source languages like Viper, Huff. These things are different and better than solidity in interesting ways. I think if Move does what we want, basically becomes the WASM of web3, the way we like to think about it, then innovation at the virtual machine layer will happen. But it'll be slow and gradual in the sense that the core is fixed and we add new things, but you're not going to blow it up and start all over. Whereas I think innovation at the source language level is going to be quite significant today we only have one source language, but it's very tied to the bytecode format.
00:18:36.730 - 00:19:18.026, Speaker A: But I can especially imagine that given the many different customers who are going to be coming to smart contracts and where they're coming from, given the emphasis on safety, that there's just going to be a lot of different things to try out. The source language bunch know program synthesis is this interesting research area. Maybe you start by writing your Move proverbspecks and then the synthesizer fills in the program for you or suggests different limitations. Maybe you're writing Move in a very specific gaming context for something that looks like the scene hierarchy. Maybe it's in like Python or uses Python libraries but compiles to Move bytecode. Maybe you're like Solana or one of these other platforms that's looking at incorporating Move but not incorporating the VM but doing it by having a compiler from Move bytecode to the Solana backend format and then using the Move source language at the developer level. So I think there's a lot of different ways, I sort of think of it as like the JVM.
00:19:18.026 - 00:19:37.302, Speaker A: Like the JVM is this beautiful all purpose virtual machine where it started off with just Java, but it sort of stood the test of time. And you have scala, you have groovy, you have all these other interesting ways of using those primitives to design different programming experiences that are very tailored to what folks are trying to do. So basically I have a biased view on the VM part because I think that gives you lot of room to experiment at the source language level.
00:19:37.436 - 00:19:55.546, Speaker D: How do you feel about all the alternative EVM bytecode languages? Like there's Fe, like Iron, there's Viper, these other interesting efforts to build more smart, contract, sophisticated languages for the EVM. Are you optimistic about those?
00:19:55.728 - 00:20:41.698, Speaker A: So this is different source languages that compile to the EVM to EVM by in. That the reason, when we started off at Facebook, decided to design Move instead of we looked at building another source language of the EVM, and we studied Solidity. We studied Viper, which is new at the time. We studied the EVM and we ended up thinking like the real I don't want to say problem here, because that sounds judgmental, but the thing that makes it difficult to write safe, smart contracts is how low level the EVM is and how hard it is to have typed values that can flow across trust boundaries and dynamic dispatch and these sorts of things. And these are EVM features. If you build a better source language, you make it harder for the developer to shoot themselves in the foot, maybe they can have more advanced verification. But ultimately what you get with Move and what we think is important is protection at the bytecode, Verifier and VM level from other programmers.
00:20:41.698 - 00:21:04.554, Speaker A: And a source language can't give you that that has to be baked into the VM. And no matter how much you iterate on the perfect source language for the EVM, which I think Solidity is great, could also do better than Solidity. But I think where you get to with that approach just ends up being not as good as somewhere where you have these fundamental protections baked into the VM. So I'm bearish not because I think Huff is very cool, for example, but just because I think the end state is less compelling than similar paths.
00:21:04.682 - 00:21:10.370, Speaker B: But can one of you make the countercase for like a Viper and anything else out there? These things are important for the ecosystem.
00:21:10.870 - 00:22:24.970, Speaker D: Yeah, well, it's a little bit hard to make the countercase because I've seen a lot of interesting examples where they've been able to write Viper that is much more performant out of the box that compiles to novel EVM bytecode structures that just are really hard to compile to from solidity that just end up with great performance characteristics, great space characteristics. So there's a lot of space to improve on Solidity. But Sam's point about being able to do type checking for more useful blockchain native types or smart contract native types in the EVM, that's just really difficult to solve at the EVM level. So I'm not sure I have a super strong case. Other than the fact that there's already a big network effect for solidity, there's already a big network effect for the EVM, and there is a good amount of space. I think, to bring some checks at compile time, at contract writing time, to improve the experience for engineers who are writing to the EVM. Think of it like we were talking about earlier, bolting types onto Python later with Mypy or improving the Type system in PHP with hack.
00:22:24.970 - 00:22:48.286, Speaker D: These are things that were added after the fact. They're probably not as good as Rust type system from the beginning or Haskell or something, but they're a net improvement that allows you to have your cake and eat it too a little bit. So there's a case to be made that there's fruit in new EVM languages, even if you can't get to exactly the same level as building it from scratch.
00:22:48.398 - 00:23:09.090, Speaker B: That makes know. Sam, you've mentioned cross platform a couple of times and I think you mean that Move has all these different flavors with different blockchains, but it's also one of those phrases that means a lot of different things. So can you say a bit more precisely about what you mean with cross platform and also more broadly why that matters for the smart contract programming context?
00:23:09.250 - 00:23:54.902, Speaker A: Yeah, sure. So let me start off with a spiel. So I think one thing with early smart contract languages and specifically the EVM, is that they overfit to the implementation details of the platform they're designed for. Inside the EVM there are instructions that talk about the transaction structure, that talk about the account structure, that use specific kinds of cryptography. And so I think this makes it really hard to use the EVM on a chain that doesn't look a lot like Ethereum. Like you end up having to inherit a lot of the design decisions that Ethereum made and maybe in some cases some of the mistakes that make it hard to scale Ethereum. So in designing Move, we were really conscious of not putting anything blockchainy into the core language like trying to make it as agnostic as possible so that you can take move and you can use it in a proof of work chain that has this crazy transaction structure in suite that does things this way versus aptos that does things this other way.
00:23:54.902 - 00:24:24.938, Speaker A: And so that way you don't have to bet on a particular chain to become a Move developer. You can take your skills and use them across all sorts of different chains, including. Ones that are coming in the future. We think that's going to be really important for a smart contract language to survive. The biggest asset a language can have is its community. And the bigger you can make the community by making your skill as basically crest platform instead of overfitting to one thing, the more you can succeed in doing that and then a large community is what makes it possible. To invest a lot in tooling, to invest a lot in common libraries and in all the things you really need for a language to become big time and to become successful.
00:24:24.938 - 00:24:31.726, Speaker A: And so this is something we tried to do from the very beginning. We're now seeing like multiple move chains that really are super different in how they end up incorporating the language.
00:24:31.838 - 00:25:01.542, Speaker D: I mean, in my mind, that's kind of the thesis that was underpinning Node, right, is that there's a ton of people that know JavaScript. There's a ton that they want to do, there's the tons of libraries that they want to be able to share with each other and the extent to which code that exists can bootstrap server side applications of JavaScript. That just makes Node useful out the box. And it means that there's all kinds of developers who may not do backend programming but can start to move into it and make that their domain.
00:25:01.606 - 00:25:02.774, Speaker A: I think that's a great analogy.
00:25:02.822 - 00:25:26.500, Speaker B: It's also, by the way, a good segue if we want to talk about governing programming languages because Node obviously had some very high profile I mean, every programming language community has had many high profile divides and splits on the governance side and many different evolutions of it. I covered Node a ton, it's one of my favorites actually. But I want to make sure we just finish this thread. Is there anything more else to say? Noah, I feel like you're a resident curmudgeon on this podcast, which I love.
00:25:27.830 - 00:25:28.194, Speaker A: Yeah.
00:25:28.232 - 00:25:30.102, Speaker C: So I have maybe a counterpoint or.
00:25:30.156 - 00:25:32.006, Speaker A: I've got a pro and a con pro.
00:25:32.108 - 00:25:47.258, Speaker C: That's very cool. I keep thinking about why doesn't someone build a Move optimistic roll up and that would be really cool given the optimistic roll up people are ethereum people and using MetaMask and ECDSA signatures, right, and they don't use Move I don't believe is using the same signature format as we. For example.
00:25:47.424 - 00:25:53.242, Speaker A: Yeah. In Swee we do both EdDSA and ECDSA. Mostly ECDSA for ethereum support. Oh well, perfect.
00:25:53.296 - 00:26:02.590, Speaker C: But my point being that you could build some pretty interesting things. But however, my counterpoint is when I was trying to learn Move I was staring at both the Swedoc and the Aptos docs and I was very confused.
00:26:03.810 - 00:26:31.830, Speaker A: So this is definitely a problem, right, where it's like when someone comes into Move, it's like do you teach them the core language and that they're familiar to blockchain? They'll be like, wait, I'm learning the smart contract language, but where's the blockchain? And then if you're trying to write for. Both are differences between the platforms. So I think that's the challenge we're still working on. I think the best path is like pick a platform, pick a suite, pick an appdos, you learn that really deeply and then you see that, oh, actually my skills and code, they really port easily to the other one. But yeah, I think there's some inherent problems there and then there's just some documentation problems that we need to work through to make that a bit easier.
00:26:31.990 - 00:27:05.380, Speaker D: Yeah, maybe the analog is like it depends on whether you consider SQL like a portable skill or not. There's tons of SQL dialects. There is an ANSI SQL, no one really knows what it is, but they kind of learn SQL. And then if you squint a little bit, you could use any database. Like you might be a little confused about a specific function name or specific type that's missing, but it's more or less the same shape. And I think that that has made SQL very robust and really durable. That's part of why it remains like a Lingua Franco for data.
00:27:05.380 - 00:27:10.838, Speaker D: Maybe that's where Move ends up. I think we could do a little better than that, but I think in.
00:27:10.844 - 00:27:24.486, Speaker A: Terms of being cross platform, that's a great thing to aim for and very application specific. And it's just the right language for talking about tables and talking about databases and that's just overwhelmingly clear, which is why I haven't used it. So I would love it if Move were to blockchain as SQL as to databases.
00:27:24.678 - 00:27:43.860, Speaker B: Okay, so we've covered and sort of circled back and forth between traditional versus smart contract programming waves and flows, specific constraints and differences, and also even some parallels between Trad and Smart contract programming. Is there anything major or even minor on things unique to the smart contract programming context that we didn't cover?
00:27:44.310 - 00:28:26.874, Speaker D: Well, another thing that is really important in a Smart contract context is resource use like gas metering in Solidity. Right. Although of course, always software engineers take into consideration the computational costs of what in many, many contexts that's very important. Computational resources are relatively abundant outside of smart contract context or outside of a blockchain context, which means it's just litigated and considered less. And I think having a notion of the resources you're consuming in the language could be an interesting resource for smart contract programming.
00:28:27.002 - 00:28:53.718, Speaker A: Yeah, it's something that we think about a lot. We have built in gas metering in the VM. That's something, as you say, it's very different from a conventional programming language. I actually think the trend on this going forward will be that gas metering will become more and more coarse grained and more about just preventing egregious resource misuse rather than really trying to nickel and dime for every instruction. I actually think things like Gas Golfing, although they are very fun and interesting, are actually pretty harmful for both coding style and for security.
00:28:53.804 - 00:28:55.218, Speaker D: I radically agree, and I think that's.
00:28:55.234 - 00:29:08.294, Speaker A: Because the only model we know is to charge per instruction. Even though if you have a fast VM, the difference between running 100,000 instructions and 500,000 is in the noise. If you're actually measuring runtime, why are we charging per instructions? I think that's a trend we'll see is how to make this more coarse.
00:29:08.342 - 00:29:39.926, Speaker D: Yeah, whenever I see all these unsafe blocks and so on and tons of inline assembly in solidity code, it just reminds me how early we are. Because that's just not the type of programming challenge that smart contract developers ought to be considering. That's just not the sign of a mature developer ecosystem. But we're getting there. I agree. At the limit. I think choosing the right algorithms, choosing the right data structures, choosing the right general approach, as is the case with most software engineering, will always be important.
00:29:39.926 - 00:29:47.782, Speaker D: But the minutiae kind of thinking about the exact cost of every instruction is probably a step too far.
00:29:47.916 - 00:29:58.010, Speaker B: What are other constraints? So we talked about gas optimization, talked about the types, we talked about the assets and safety. What are other constraints that come to mind?
00:29:58.080 - 00:29:59.146, Speaker A: Yeah, this is like a sort of.
00:29:59.168 - 00:30:08.042, Speaker C: Similar thread on gas, but I guess the specific subset is state. And this is a big thing for me when I sort of approach gas golfing. I do love to do like extreme gas golfing.
00:30:08.106 - 00:30:09.374, Speaker B: We know you do.
00:30:09.572 - 00:30:35.606, Speaker C: However, when we're dealing with real smart contracts that hold real money, my general thesis is that you should do reasonable optimizations where they're obvious except for one case. If you can bend over backwards to use slightly less state than you were using before, you should do it. That's the only time where I will break out large assembly blocks is that if you could do something stupid to use less state. Because it's like this whole never resource where we should put that just one above, just execution or call data or whatever.
00:30:35.708 - 00:31:11.362, Speaker A: I agree wholeheartedly because I think that's what's fundamentally expensive. Like if you have a platform where every contract is allowed to touch any piece of state, it makes it very, very hard to paralyze things. Whereas the approach Swee is taking, and a lot of these newer blockchains are taking, is make transactions explicitly sparse, like say, what state you're going to access, or at least give me an idea. So it's easier for the top level platform to paralyze transactions both through execution and through consensus. So I think that's something that will always be expensive and something that programmers will need to think about. Make this as sparse as possible in terms of not touching more state than it needs to, so that the validators can paralyze it more effectively and then effectively have more block space as compared to if everybody is contending for the same state.
00:31:11.496 - 00:31:24.038, Speaker C: Does that open up a world where eventually not all validators, even in a non roll up context have to download all states. If you can sort of very easily separate out state and what Validator potentially can service what kind of transaction, I.
00:31:24.044 - 00:32:07.942, Speaker A: Think it does enable that world. It also enables a different approach to doing it. And let me back up and say I think from a programmer perspective, it's very valuable to be able to touch the entire world across different transactions and not in the same one, without having to go through the friction of, oh, I have to go through a roll up here or this across shard transaction. And so it's slower, less secure, and users notices, I think, the abstraction of there's one ledger where all the valuable state is, and then I can just touch that all at once as a programmer is where the value of blockchain comes from. So I think it's like, how do you continue to broad that illusion while under the hood? Things actually do let you split it up and have it be sparse. And so in sweep, a Validator can be multiple workers, and each worker handles a part of the state, handles some subset of the state. But from the programmer's perspective, and even from the perspective of other validators, it seems like it's one logical entity that can do everything.
00:32:07.942 - 00:32:16.486, Speaker A: So that makes it a lot easier to Shard storage, to Shard execution without having to bake that stuff into the protocol level and have users and programmers have to think about it.
00:32:16.588 - 00:32:49.710, Speaker B: So, okay, just closing this thread on anything related to what's really unique about smart contract programming. What are the mindset shifts involved like? We already talked a little bit about one Eddie alluded to this. That a huge shift is that in the world of programming, at least since the early days of computing, we're in a world of abundance, but in this world, we're in a world of constraint. So that's one example of a mindset shift. What are other kind of mindset shifts, especially for each of you? As you guys have come to smart contract programming, what has it surprised you or taught you or made you think differently about that you knew going in as a programmer?
00:32:49.870 - 00:33:33.758, Speaker D: Well, maybe a silly one is I still remember the first time years ago that I learned that your balance of an ERC 20 token was not a thing that your account had. Like your address does not have a balance of tokens. That's not how it works. Instead, there is a token contract that's somewhere, and in that token contract, there is a mapping of which addresses have what balance. It's kind of inverted a little bit on its head. So when you want to transfer some tokens to someone, you're not sending them some tokens. Instead you have to do all this low level kind of go to this contract and then change the address and change the balance held by your address and their address.
00:33:33.758 - 00:34:15.294, Speaker D: And you have permissions to manipulate and mutate that contract. It's a very kind of counterintuitive way to think in the EVM in Solidity. And that's kind of one of the first things that stuck out to me about Move is that it is a little bit more like the way you would expect all of this to work. Naively hearing about it described in English. And that's an interesting mindset shift is just to take for granted that the words we use in English don't necessarily map onto the programming model in Blockchains. Yet there's just a lot of you're in a weird jungle space and things are all around you and they're just not really arranged how you'd expect that's great.
00:34:15.412 - 00:34:29.746, Speaker C: One thing I'd add is that and this just has to do with something that you realize when you're doing it, is that when in the normal world, we care a lot about developer productivity, because the job of an engineer is write a lot of code. And for that code to have only a couple of bugs and have those.
00:34:29.768 - 00:34:30.786, Speaker A: Bugs not be that bad.
00:34:30.888 - 00:34:58.170, Speaker C: Meanwhile, in the smart project world, your job is to write a very, very small amount of code and it must be perfect. It must be perfect in every possible way. Otherwise you're going to lose hundreds of millions of other people's money. And that's an entirely different mind shift. It is a weird thing to do to stare at 1000 lines of code for like two months and try and figure out how do I make this better? And more importantly, how do I make this literally perfect? And to have auditors then do that exact same job of saying is this perfect?
00:34:58.320 - 00:35:26.200, Speaker B: That's a big one. One of the pieces I edited at Wired was from Leslie Lamport proposing that software design should be like designing houses. That was like his big shtick for the longest time. And I remember pushing back and being like, well, what about Agile and all these people who disagree that you can have your specs and everything written up this beautiful, pure blueprint like way. And he got reamed in the comments for it. But it's funny because I feel like his worldview would actually be dominant now in this kind of thing. It's a sidebar, it's a great observation and totally true.
00:35:26.200 - 00:35:38.998, Speaker B: Well, I just think it's fascinating because that was his big shtick. And by the way, if you go to his website, he has a thing on his page about me as this annoying editor he had to work with on this piece, which is so funny because he was really mad that I asked that question about the difference between.
00:35:39.084 - 00:36:10.574, Speaker A: The Mindset chip totally. The barrier to changing your code is higher than it is in any other programming setting that I can think of. Where in the limit or in the most secure, most decentralized smart contracts it's immutable. Which means you get it out there and it's perfect. The first time and you never do it. I think this is something where we'll figure out in both language design and platform design how we can support safe, upgradability and trusted upgradability and make it look a little bit more like a conventional ecosystem. But I think that's always going to be a fact of smart contracts, that it's way harder than upgrading a mobile app or upgrading a website in a way that's trusted or without having breaking changes.
00:36:10.574 - 00:36:15.458, Speaker A: Building on Noah's answer, I think that's also mine, where it's definitely going to be a surprise for someone who's trying to iterate into relevance.
00:36:15.554 - 00:36:17.846, Speaker B: That's great. What else would you guys add to the list?
00:36:17.948 - 00:36:53.450, Speaker A: So I think as a smart contract programmer, you have to have an adversarial mindset, which may be very unfamiliar even if you're a product person, which may be very unfamiliar if you're coming from elsewhere just because of the deployment model. Like, you're not only thinking about the intended usage of your application, you also have to be thinking about the unintended usage. Because in conventional programming there's ways to hide yourself from this or limit it to a small API surface, or use a firewall to limit what an attacker can do or these sorts of things. But it's smart contracts. The whole point is what you're doing can interact with code you never imagined and do so safely. And so you have to think about that, the happy case of that and the sad case of that, and that's definitely a mindset shift compared to conventional programming.
00:36:53.530 - 00:37:03.790, Speaker D: Is this like a line in the sand that you're drawing that you think ought to be top of mind when we talk about how to write smart contracts and how to use smart contract programming languages?
00:37:03.950 - 00:37:33.510, Speaker A: Yeah, absolutely. And this is actually my absolute favorite thing to talk about. I am very opinionated about this, which is the thing that smart contract language designers should be thinking about is safety. And that's like the main focus, maybe even the only focus, until we can lock down this problem. I think smart contract safety is an existential threat to broader crypto adoption. And the reason I say this is because you look at Ethereum and Solidity, the EVM and Solidity, which is the most popular platform today, and you look at the early programmers who write this code, these are extremely highly qualified folks. They really understand the underlying blockchains.
00:37:33.510 - 00:38:13.202, Speaker A: They're really security minded, they know what they're doing. I think they take the responsibility of writing code that manages millions of billions of dollars very seriously. But still, if you look at the track record of smart contract security anywhere, it's just really, really abysmal and not to the fault of these folks. I think it's just an extremely hard problem and I think the languages make it harder. So if you look at something like my favorite website, Rekt News, you look at the leaderboard or you look at these ten hacks that are in the value of tens of millions of hundred millions of dollars are super routine, like a sort of weekly or monthly occurrence depending on the size. And at the same time the smart contract developer community is really small. Like there's about 5000 full time EVM programmers, which is really, really tiny compared to conventional developer communities.
00:38:13.202 - 00:38:46.262, Speaker A: So if you buy this thesis that the folks we have are sort of the most hardcore and the most security minded now, but the development practices and the security track record is unsustainable, then I think you conclude that there's no way this space is going to grow without making the security problem even worse. Which maybe means it's just not going to grow at all. Or like folks who are sitting on the side, like big financial institutions or companies who want to get into web3 but are looking at do I have to hire a smart contract developer? I'm going to get it hacked for tens of millions of dollars and are nervous about this. That narrative is only going to get worse for them and they might just stay on the sidelines. So I think as someone who's trying to design a new smart contract language, safety has to be the first thing you're thinking about.
00:38:46.396 - 00:38:54.454, Speaker B: You guys actually already alluded to this in the context of not losing assets. But what do you mean by safety, more specifically? Sam, since it's such an important point.
00:38:54.572 - 00:39:29.298, Speaker A: What I mean by safety is that we're both trying to prevent the programmers from shooting themselves in the foot, but even more so trying to give them the right primitives for being able to defend themselves from attacks. Because smart contracts are a setting where you're deploying your code next to an attacker who can directly call into your can directly link against it. Your code is open source, or at least the bytecode is open source. And so this is the most adversarial programming environment we've ever seen with the highest stakes for getting things wrong. So I think if you're talking about smart contract programming design, it needs to begin and end with safety. And once we've locked down the safety issue, we can think more about expressive and other things. But that's my somewhat boring but I think very opinionated answer.
00:39:29.464 - 00:39:35.586, Speaker D: What types of features make or break safety? Like what are examples of things that just embody that?
00:39:35.768 - 00:40:30.978, Speaker A: So I think the number one thing is encapsulation broadly and then I'll talk about specific sub features that correspond to where it's basically when you write your code, you don't know what an attacker is going to try to do when they call it or link against it. And so you need to be able to reason about it without being able to anticipate what a creative attacker will do. So you want a strong type system, not just at the source level, but I think, at the bytecode level, so that the guarantees you get when you're writing your source code will continue to hold when you publish your it on the blockchain and when other folks depend on it and when they want to link against it in move. One thing we look at with this feature that's popular elsewhere but we think is inherently unsuitable for smart contract programming is dynamic dispatch. Now, in conventional programming, like interfaces and dynamic dispatch, this is the key abstractive mechanism. This is ubiquitous, right? Like you define an interface and then other folks override the interface with logic that does something different and then you program against the interface and everything works out great. But we have this cheeky saying where it's like in a world where code is law, interfaces are a crime.
00:40:31.074 - 00:40:35.926, Speaker B: OOH, that is let's pause there for a minute. In a world where code is law.
00:40:36.028 - 00:40:37.202, Speaker A: Interfaces are a crime.
00:40:37.266 - 00:40:40.886, Speaker B: Can you explain that a little bit more before you keep going? I don't want to just skip over that too fast.
00:40:40.988 - 00:41:12.722, Speaker A: Yeah, absolutely. So the idea here is like an interface. It doesn't define behavior, it defines intended behavior. Like when you read the specification for an interface or the parameter names or even the types, it tells you what you want to be done, but there's no guarantee that that's actually going to be the case. And so if you're writing some code that's supposed to be protecting something, but you're basically leaving a blank check for an attacker or someone else to fill in and this is contract law, that seems like a crime. It's an ill specified contract. So big fan of this feature in conventional program languages, of course, but we think in smart contracts this has led to lots and lots of different issues.
00:41:12.722 - 00:41:43.454, Speaker A: Like Reenterancy requires dynamic dispatch, for example. You take away dynamic dispatch, you just don't have reenterrancy at all. Lots of things like say, poison tokens in ethereum like this happens because you override the transfer function, which everyone knows intuitively. This is just supposed to move money around and maybe not do anything else. But now you make it do something super unexpected and steal money. And so that's one example of a feature where if you take it out, reasoning about your code and having proper encapsulation just becomes much, much easier. Because every time you see a call site, you know exactly what it's going to do and you don't have to worry about someone else coming and doing something that surprises you later on.
00:41:43.572 - 00:42:20.998, Speaker D: Exactly. I think the analogy there is like if you define an interface around a chair, four legs and a seat, you're describing it at a specific level, you're describing it not at a behavioral level. You're not describing other things that may be implicit or assumed about a chair. Like it has a certain structural integrity, right? It has certain materials, like it's oriented a specific way. All of those things can be subverted and mean that the interface is really just an arbitrary set of descriptions that just doesn't capture the safety constraints that you want to enforce in that object. It's exactly defining things at the wrong level.
00:42:21.084 - 00:42:28.426, Speaker C: I'm curious though, how do you then sort of do modularity really well without interfaces? Because I think if interfaces are a crime, I might be a criminal here.
00:42:28.448 - 00:42:31.434, Speaker A: Because my favorite sort of way to.
00:42:31.472 - 00:42:56.050, Speaker C: Build complicated smart contract systems, I love to have different contracts that have sort of different purposes. And particularly when you have very complicated systems, you have a module based system where the module adheres to some sort of interface and then sort of the main contracts that can sort of knows to call those different modules and those modules generally get permissioned by governance in some way. How do you get that super expressive plug and play modularity without sort of standardized interface?
00:42:56.130 - 00:42:59.986, Speaker D: Yeah, how do you get inheritance? How do you like all these things that are kind of related to interfaces?
00:43:00.098 - 00:43:29.022, Speaker A: This is exactly the right question to ask because you're like, okay, you can rail against us all day, but then how do you still provide something that lets you write useful code? It's like there's no crime if you're not allowed to come out of your house or something. Anyway, the way we do that, the interfaces and inheritance are not the only way. I tend to think in terms of composition and so we provide several composition primitives that don't require dynamic dispatcher interfaces. So one is generics. We have runtime generics that look a lot like what you have in the clr. So let me give a very concrete example because otherwise this gets abstract pretty quickly. Something like, ERC 20.
00:43:29.022 - 00:43:48.846, Speaker A: This is obviously a fundamentally important crypto standard. If you can't do something like that, your platform or your language is not going to be very useful. So the way that works in a language like Move is you define a type called coin of T where T is a generic type parameter. And then you implement functions for coin. Like there's a function for joining two coins together. This works the same for all coin types. It's not something that someone wants to override.
00:43:48.846 - 00:44:35.054, Speaker A: You define splitting and then when you want to let somebody customize behavior of coin, use these so called capability patterns. Like for a coin, one thing you might want to customize is like what's the total supply? Or more fundamentally, what's the policy for minting and burning it? So the way you express that is, okay, you have the struct coin of T and then there's just different instantiations of tea like USD or GBP or EUR or whatever else. And then for stuff that you want to customize, you provide it at the capability level. The function for creating a coin, you say here's a type parameter for my coin, and then it gives you back what's called a treasury capability. And then there's other logic that makes sure that only someone who holds the treasury capability of T can mint and burn coins of type T. And then you can go take that treasury capability you lock in a different contract that enforces the total supply constraint. You put it somewhere that says anyone can mint it on Tuesday but not on Thursdays.
00:44:35.054 - 00:44:53.354, Speaker A: You go and lock it. You basically invert the control flow instead of putting it inside an interface. And then that allows you to do this arbitrary sort of composition. And so that's one example of the trick. But this works basically everywhere where if you want behavior to work one way, you've hard coded, sounds bad, but you implement swiftly into methods. Then you define these capabilities for stuff that you want to allow.
00:44:53.472 - 00:45:01.638, Speaker D: So do you think of capabilities as constraints that you can add to what might look like an interface to a conventional programmer?
00:45:01.734 - 00:45:11.902, Speaker A: Exactly right. I think most of these interface patterns you can very straightforwardly, not quite compile them. That's a little too hard. But say here's the equivalent capability pattern for this thing you want to do with interfaces. Yeah.
00:45:11.956 - 00:45:16.610, Speaker B: By the way, Noah, do you find that satisfying? Feel free to disagree. It's good to have a little conflict.
00:45:17.990 - 00:45:46.966, Speaker C: So I do find it relatively satisfying because I think if you can have modules or I guess structs that have capability inside them, and those Structs can be fed into modules that have very predefined behaviors, you can end up getting the sort of same exact behavior a module can do. X a module takes that Struct, a Struct that was sort of defined in that module, and then that Struct has a capability inside of it. It actually works quite nicely because then you get really great authority style registries that sort of naturally arise from that. Like a very makerdow like what's called DS off registry. Almost works just like that.
00:45:46.988 - 00:46:03.182, Speaker A: Right, exactly like that. And then these capabilities are an as a representation of things that you're allowed to do. So that has a lot of other benefits. Like you want to know what can my account do? You look at what capabilities it has and then maybe you can do program analysis where it says if I have a treasurer capability, show me all the functions that I could call and then all of these sorts of things.
00:46:03.236 - 00:46:28.402, Speaker D: So maybe I'm cutting ahead to the prover. But are these capabilities visible to the type system? And are they visible at the time of static analysis for the program? Like if I write some code for my specific instantiation of one of these types that has capabilities, then is it visible very early that I violated a capability? Or is that something that I can only learn about later if I'm running it in the VM?
00:46:28.466 - 00:46:50.138, Speaker A: Yeah. So let me give a short answer to the question and then provide some background where, yes, they're visible to the proverb and they're part of the type system. This. Is something that we leverage very heavily. But let me talk a little bit about Structs and the MoveAbility system and then how that rolls up into things like capabilities in the perver, if that's not too much of a distraction. So in Move you have struct types. And Struct is like another language, it can have fields, these can be fields of primitive types, these can be other structs.
00:46:50.138 - 00:47:23.942, Speaker A: And then the thing that's interesting and maybe more different about Move is these structs have abilities. If you're familiar with rust, abilities are a little bit like marker traits they declare built in operations that you're allowed to do on the struct. And just as importantly, if you don't have the ability, you can't do those things. And so to start with an easy one, one ability that's very important for financial programming is the ability to copy. Like if you have something that's a coin type or an NFT or something in the computer, it's just bytes. But you don't want to allow someone to copy that thing willy nilly. And so in Move, if you don't, say, has copy for your struct, then you're not allowed to use our equivalent of mem copy, like basically the copy operation.
00:47:23.942 - 00:47:48.866, Speaker A: So things like integers and strings, they have copy. But if you don't want your type to have copy, then you just don't give it that. And then there are other abilities like discarding. So this is called the drop ability. So this is where you get into interesting things like linear types you see elsewhere. If you want to be able to just drop something on the floor, let it go out of scope overwrite it, then you give it drop. But if you don't give it drop, then the only way to eliminate it is whatever policy the module that defined that type wanted.
00:47:48.866 - 00:48:23.226, Speaker A: So to give a concrete example, there something like you want to keep a total supply for your coin, you just don't give your coin drop. And then the only way to get rid of your coin is some burn function in the module that declared it, which then updates the total supply. So these are the sort of tricks you can type that you can play. And then there are several other abilities related to where you can put something in global storage, whether it can go there or not. I won't get into those as much because I think they're less relevant to the question. But basically like building into the prover and abilities like the prover is aware of the type system, it knows how to leverage the type system to figure things out. Like oh, I know if something doesn't have copy, I don't have to worry about it being copied.
00:48:23.226 - 00:48:32.510, Speaker A: And so if I write a specification that says there's only one of this thing, the prover can leverage that to prove this property. And so it really works hand in hand on top of the guarantees that the Type system is giving you.
00:48:32.580 - 00:48:42.530, Speaker C: As soon as you said drop, I wanted to talk about my favorite can you just talk about what the hot potato pattern is and if there's other similar, really cool things? It's one of my favorite weird things that arises from move.
00:48:42.680 - 00:49:03.558, Speaker A: It's definitely a weird thing. So, yeah, this is very closely related to abilities. So normally in a programming language, you don't have a lot of control over when someone can eliminate your value. Like maybe you have a destructor that says, this is what happens when your value goes away. But sometimes there's weak guarantees around a destructor being called. Or you can't just say something like, you're not allowed to delete my type. Now, that sounds like a weird thing to be able to say.
00:49:03.558 - 00:49:36.370, Speaker A: Why wouldn't you be allowed to delete something? But it actually ends up being very powerful, particularly in this setting where there's no dynamic dispatch. So I'll start with an example of hot potato, and then we can work more into the guts like a flash loan. If you're doing a flash loan on ETH, this is a standard that you override where basically you expose a callback where it's like, hey, flash loan contract. Like you give me money, call my call back, and then take the money back or something and move. The way you do that instead is someone goes to the flash loan contract and they say, hey, give me 50 sui. But then they also give you this so called hot potato object. And the hot potato object is a struct that has no abilities.
00:49:36.370 - 00:50:12.138, Speaker A: It doesn't have copy, so you can't copy it. It doesn't have any of the global storage ones, so you can't just stash it away in a contract somewhere and it doesn't have drops, so you can't get rid of it. So the only way to get rid of it is to pass it back to the flash loan contract. And the code in the flash loan contract that lets you pass it back, forces you to pay back the flash loan. And if you don't, it's not the program will fail at runtime. It won't even type check. So it's leveraging this interesting ability to control the destruction of your values and then as a programmer, to put arbitrary invariance on when are you allowed to what needs to be satisfied in order to destroy this? And then just sort of making these API call patterns very explicit.
00:50:12.138 - 00:50:18.980, Speaker A: Like another very obvious one is like if you want to force someone to call lock after they call unlock but want to let them do whatever they want in between, you can also do that.
00:50:19.670 - 00:51:06.830, Speaker D: Yeah, when I first heard about the hopidato pattern, it reminded me of Mutex's interesting uses of locks, where purely for the purposes of Ergonomics, you take advantage of the type system in order to force almost business logic level requirements in the way that specific objects are used, which I think is really clever. That feels like such a modern, such a high quality use of ergonomics in programming languages that really, I don't think, is super common in traditional programming languages even yet, but is so obviously valuable in a smart contract environment. Where there's even more logical requirements on what is possible. What is not possible when you have so much value and so much security at stake.
00:51:06.910 - 00:51:21.078, Speaker C: So before we go into any particular examples, can you give a quick high level overview of the sort of object system that Swee has? What are objects, who own them, how objects own other objects, how that pairs with modules, or sort of the bird's eye of how it all works?
00:51:21.244 - 00:51:56.910, Speaker A: Yeah, totally. So this is about the dialect of Move, specifically Swee move. And the basis of this thing is a different structure of global storage than the original dialect of Move that we used. So the original Move global storage scheme was very much like in the account based model like Ethereum is using. And in Swee we instead want to make things object centric with a high level of motivation of being able to express fine grained access as precisely as possible. This helps you do a lot of things that won't get into on this podcast, like paralyze transactions more efficiently, tell wallet users what a transaction is going to do before they sign it, and things of this nature. So in suite, the structure of the global storage is it's a map from object ID to object.
00:51:56.910 - 00:52:23.194, Speaker A: And then objects are just move structs that have this ability called key. Key says, hey, I'm allowed to be a key. I'm allowed to basically appear in the global object pool. And then every object has to have one of these globally unique IDs. And then you can write entry point functions for your modules and then they can directly take objects as input. And the Swee runtime is able to if you're writing a transaction, it has object IDs. And the Swee runtime is able to use the IDs to resolve the ID to an object and then plug it into the function for you.
00:52:23.194 - 00:52:48.850, Speaker A: And it just has this very nice object centric, asset centric programming experience that's a lot more direct than what we had in the original version of Move. And you mentioned also the parent objects and child objects and object hierarchies. This is very useful, but of course you still want to be able to do something like represent a large collection. I'm building a DNS style registry and I want it to have millions of entries. We have an object size limit. An object can be a couple of megabytes, but not bigger. But if you have DNS, that thing should be arbitrarily large.
00:52:48.850 - 00:53:25.566, Speaker A: And so the way we represent that is with parent child object relationships, we basically have a way to view an object as a heterogeneous map and then you can sort of add keys with dynamically chosen fields. It's very Javascripty in this way where you can say this object has a map inside of it and then I can put stuff inside this map or you can say, hey, when I define this object, it had ten fields, but I'd actually like to add a new field. I'm going to upgrade my contract and I'd like to add a new field after the fact. And the way we represent that is with these parent object child relationships where each child is associated with a key value that can just be an arbitrary move value, like a string or U 64 or whatever else you want it to be. Yeah.
00:53:25.588 - 00:54:15.614, Speaker C: And related to that sort of parent object idea, I think the thing that made that really click for me, actually, a couple of months back, I spent time doing a deep dive into swimove and basically started out writing a program that's just a single object all the way to re implementing most of Uniswap V two style decks. And the one little mini project I did that really made the objects, owning objects being so valuable hit me is I built a really simple system that was I think the three objects were there was a lock, something called gold. Like lock can hold gold and then like an empty object called a key. And a very basic module, which you could probably think about, it can create a gold owned by the key object. And then the only way to get the gold out is there's a function that takes the lock and key, then obviously destroys the lock, gives you the gold back and destroys your key. Right, and I think that's sort of interesting. Is this the benefit you get by having the object relationship, describing permissions in a really granular way?
00:54:15.732 - 00:54:48.118, Speaker A: Yeah, that's exactly how we think of it. And I love how you describe the nesting of the three different objects because this thing is even more powerful when it goes deeper. So yeah, it makes it much easier as a programmer to structure that to make sure I get to the second tier and then I can touch the third tier, but I can't go directly from the first to the other. And it also makes it a lot more approachable, I think, for programmers coming from outside the smart contract space. Like these books are very familiar to programming trees of objects. The Dom is a tree of objects. If you're a game programmer, everything is a scene hierarchy where it's a character and they have an inventory and then the inventory might have little subbits in there.
00:54:48.118 - 00:55:03.962, Speaker A: So you can encode this stuff very directly and move. And then the type system allows you to set up this access control in a very direct and safe way. So yeah, I think this is a very tactile programming experience. It really mirrors the intuitions you have about the real world or how you describe something, but then transcribes very directly into the relevant code, by the way.
00:55:04.016 - 00:55:20.754, Speaker B: Before I came to Wired and Asics and ASP at Xerox Park. And that reminds me a little bit of the history of object oriented programming, what you just said, which is super fascinating because they invented small talk, which is the early precursor of a lot of the object oriented frameworks today. Anyway, okay, cool. Anything else you guys wanted to cover?
00:55:20.872 - 00:55:30.718, Speaker C: I just have one general question, actually. Are there hacks and stuff that have happened in the EVM world that you think using Move just immediately would have made never happen in the first place.
00:55:30.744 - 00:55:34.834, Speaker A: Just because of the type system? Yeah, I have a whole Twitter throne on this that I'll have to plug.
00:55:34.882 - 00:55:36.886, Speaker B: In this show notes, I'll link to it.
00:55:36.988 - 00:55:49.158, Speaker A: So in the EVM world, we already mentioned dynamic dispatch and reentrancy. Move eliminates reentrancy by construction. Anything that has to do with reentrancy that just goes away, which I think people are pretty good now, I think, at avoiding reentrancy.
00:55:49.334 - 00:55:54.026, Speaker D: Well, could you spell out why? What is it about Move that makes that exactly impossible?
00:55:54.138 - 00:56:26.214, Speaker A: So with Reentrancy, right, what happens, you're writing some code, you call out to some function, and then the problem is somebody supplies an implementation of that function that you as the initial programmer, did not anticipate. And so in order for that to happen, that function call has to be dynamic. It has to call code. That's basically a function pointer supplied by the caller who might be an attacker. And so if you don't have any sort of dynamic make function calls, if you always know the target of a function call at Runtime, then this just can't happen at all. Like anything you call well, you might not know what the code did, but you knew what it was. You could have tested it, you could have verified it, it's all right there for you.
00:56:26.214 - 00:56:33.914, Speaker A: So it never happens that someone can supply code that makes your module behave in a way that you didn't expect. It's just a static function call.
00:56:34.032 - 00:56:40.806, Speaker D: Cool. So that eliminates reentrancy attacks, which has been a perennial issue in solidity development.
00:56:40.918 - 00:57:29.194, Speaker A: Yeah, I think a big issue, smart contract programming that Move basically eliminates is missing permission checks where a lot of times you're writing some code and then you pass in all these accounts explicitly and you have to say like, oh, am I allowed to do this on that account? And you write the straightforward code and there's just like, oh, I forgot to check that the sender is this person, or that this person can access that. And I think these sorts of things happen quite frequently. So in Move and in Swimve, specifically, the object ownership information lives in object metadata. It's not something the programmer even has control of. Like when you look at these objects, they'll say, I'm owned by this address, or I'm owned by this other object. Or I'm a shared object or I'm immutable so the programmer can't forget to check who owns it because the runtime does it. Before you even start executing code that passes in a suite object, the runtime will have said, okay, I see the transaction sender, I see all the objects they want to use.
00:57:29.194 - 00:57:53.762, Speaker A: I'm checking that they actually own them or that they own an object that transitively owns that so they have permission to use them. So a lot of permission checks that we ask the programmer to write end up happening in the Swee runtime instead so that you can't possibly forget them. And I think this is huge because the hardest things to guard against are like the specifications that the programmer hasn't told you are important. It's easy to forget those and it's hard to catch those with static analysis or something else because you always need some human intent on what's important.
00:57:53.896 - 00:58:24.910, Speaker B: I think it'll be really interesting by the way, just projecting way long term or near long term, which is what happens at enterprise scale when people collaborate in more ways. This way, it's obviously distributed and not only in one company that sometimes people collaborate. But what I mean is when you think of the olden days, of the way that things work out right now you have DevOps and you have all these best practices and all these methods and then you have these very different mindsets for doing things and we haven't quite institutionalized all that in this world yet, by any means. It's still too early. But I am very curious for what that kind of thing will look like.
00:58:24.980 - 00:58:25.358, Speaker A: Yeah.
00:58:25.444 - 00:58:35.214, Speaker C: What's left for Tooling? EVM tooling is so great. Move Tooling I think still has a little bit to be desired. What needs to be built still? Are we going to see major changes happening?
00:58:35.332 - 00:59:10.506, Speaker A: Oh, yeah, I think we're very early in Tooling, so I'll talk about a few things I'm excited about coming up. One is a package system and package manager. Think of like crates IO or NPM or whatever your favorite. The move module system is very amenable to this sort of thing. And so we're working on something like this and it's cross ecosystem. It's not just for sweet packages or starcoin packages or something, but it's like crates IO where there's one tab where you see the source code for this thing and you can use it in your manifest files to build projects locally and make it really convenient. But then there's another tab where it's like here are all the blockchains where this thing's deployed and then if they're vulnerability disclosures or upgrades, then it can be integrated with that.
00:59:10.506 - 00:59:44.642, Speaker A: So I think that's something where there's a real opportunity in the blockchain space and that we're really excited about that just makes it so much easier to share code, which is hard to do in, say, solidity because you share code by copy pasting basically instead of using modules or packages that are already published on chain. And so that's one piece of tooling we're very excited about. Correctness tools is what we've invested in the most early on and we have a lot of those, but I think there's a lot to be done to make them more usable. So we have a unit testing framework. You can write test, direct in Move, which folks use very heavily, and we've specialized it a little bit to fit the suite transaction model. There's of course the Move prover, which we've developed alongside from the beginning.
00:59:44.786 - 00:59:55.426, Speaker B: Can you briefly talk about formal verification and why the prover matters? Noah had already mentioned earlier about dejan, but we never actually shared context for listeners about formal verification.
00:59:55.618 - 01:00:29.298, Speaker A: Right? So formal verification is very challenging. Usually have to be an expert or have a PhD that use it. And so we're really trying to push the limit as far as we can to make this just something an everyday programmer can use and just not really think about instead of having to be an expert. And I think the jury is still out on how possible that's going to be. The Move Standard Library is all verified and someone who I didn't know just submitted a PR to a file that had a bunch of specs and then they added a new function and they just wrote specs because it was just easy to imitate what was there. Clearly, culturally that's what you're supposed to do. So I think these sorts of things are very promising, but so much, much more, both in terms of making the proverb more usable and making it more powerful.
01:00:29.298 - 01:01:04.654, Speaker A: I think things like fuzzers we haven't invested in as much because a fuzzer is never as good as formal verification. But on the other hand, fuzers are free. They work very well for blockchains, like important correctness tool, especially if you're writing very intricate code that's doing some parsing or loop kind of stuff. So we have some collaborators in academia that are working on these sorts of things. And then I think beyond that, it's just a lot about how do you make writing programs easier. First we have the source code, we have the compiler, we have the basic IDE integrations, but there's lots, lots more that can be done there both on sort of just supporting more Ides, but also like more powerful tools, maybe program synthesis, maybe AI integration. Just love to see what's going to come out there.
01:01:04.772 - 01:01:09.042, Speaker D: Cool. How do you use the Move prover today? Like what if I wanted to mess around with it?
01:01:09.176 - 01:01:43.978, Speaker A: Yeah, so you take your program, which you've already tested, verification is not a substitute for testing, and then you write some things that are either hard to test or just hard to check that you've gotten it right for all inputs. So it might be something as simple as function pre post conditions. You say, if this is true about the inputs to my function. This should be true about the outputs. You might also write data invariants like you have a counter and you want to show that it's always increasing. You can write a specification that's attached to that counterstruct, that checks that this is true and then it'll look at all the functions and make sure of that. And then there are more advanced usages about global storage invariance like you might want to say there's exactly one of this object always.
01:01:43.978 - 01:02:22.506, Speaker A: Or if there's two of this object, then there's three of this object and here's the relationship between the fields of that object and the fields of that one. It ends up being very application specific where the language takes a lot of basic mistakes off your plate. But then for you as the programmer, there's always going to be correctness conditions that are specific to your application, and the specification language makes it easy to write those out, either after you've written your code or in some cases, even before, and to make sure that they hold for all possible program executions and all possible function calls. And so today the spec language is integrated with the compiler so you can pull it out and try it out in any of these modes and then it's also integrated with the build system. So you just do move, build prove and it'll check these cool is the.
01:02:22.528 - 01:02:33.980, Speaker C: Prover yet, does it understand sort of the suite object model and the suite transaction system yet? Can I prove things about cross transaction things that can potentially modify the global state?
01:02:34.350 - 01:03:07.506, Speaker A: It doesn't yet. On the other hand, it doesn't need to understand like say the counter that's always increasing, that's a swee object. But it doesn't need to understand anything about sui to be able to prove that even in the prover for core move it really reasons at the level of objects in global storage and less about transactions because transactions aren't a core move concept. So that's a direction we may take the prover eventually like sort of symbolic transactions or interleaving transactions, but today it really looks at the level of functions and structs which works well. But I imagine we'll end up doing some swimoo stuff in the future, especially as regards the parent child relationships and these heterogeneous object maps.
01:03:07.698 - 01:03:33.210, Speaker B: Okay, so should we talk about governing programming languages then? A little. So there's actually long and storied history of how programming languages have evolved. But the governance topic is obviously even more top of mind in the context of blockchain than crypto, because there's all these other aspects to it. A decentralization, b open source distributed communities c tokens and economics and assets sometimes being involved as part of the incentive scheme.
01:03:33.370 - 01:04:35.838, Speaker D: Programming languages especially because they're open source, they're useful in so many different contexts, they are treated a little bit like public goods, but they're not the same. They're something that needs design and needs attention to detail. How should programming languages develop? There's so many ways that programming languages seem to be governed today. Like the top two that come to mind to me are like the C plus plus committee, the WG 21 committee, or it has some crazy name and then like Python with Guido being the BDFL, the benevolent dictator for life. What do you think is the modern way to govern a programming language, especially in crypto? It's kind of unique because these programming languages have layer ones attached to them maybe, which is a different type of thing that depends on that programming language. It's kind of a public good, but it has stakeholders, it has a lot of capital attached, there's a lot of value being transmitted. Maybe there's governance models for programming languages that work better for blockchains.
01:04:35.838 - 01:04:49.542, Speaker D: So I'm interested in thinking about how they should be governed or maybe better, how does Move evolve given all the huge variety of stakeholders and the importance of the design of the language and preserving its safety properties and so on.
01:04:49.676 - 01:05:54.974, Speaker A: Yeah, I wouldn't presume for my insights to apply to other programming languages, but for Move, I have a very specific take on this where this desire to be cross platform, I mean, in addition to the benefits for programmers and for platform designers, governance is another reason for that. Where almost all of the controversial decisions in a blockchain language, things like hey, should we increase this limit or should we support this signature scheme or should we have this library or not? We try to set it up. So those are in what we call the adapter layer, the platform that's building on top of the core move language and then the core language is extremely minimal. minimality is one of our key design principles for the language and just very blockchain agnostic. So if we're going to have a debate with stakeholders in the community, it won't be like, hey, should we increase the gas limit? It'll be like should we have enums? Which is a lot more of a pure design question and something that can be influenced by problems or use cases that are coming from one or more Move platforms but isn't likely to be driven in a direction that is really good for one stakeholder and not for others. So that model has been working out pretty well so far. I mean, we'll see what the future holds but basically the way Move is governed today is that originally Move was developed at Facebook and there there wasn't really any governance, it was just us using it, although building these principles in mind.
01:05:54.974 - 01:06:42.906, Speaker A: And now the team is spread out a little bit where we have many folks at Mifton, there are some folks at Aptos, there are some third party contributors in academia, in the security community and also at Starcoin and Ol, these other Move chains. And so we just have a meeting every Thursday and we talk about Move design topics and we're really conservative about extending language. minimality is the main thing, but then we're aggressive about it when it's like, oh, adding this thing would make it easier to experiment in these layers that build on top of Move. And then once we see the results of those experimentation, or everyone seems to be doing the same thing, that's when we move it into the core language. And so really our answer to governance is to mostly avoid it, both by having the controversial things being stuff that happens on top of Move and then also by having a core principle be we're really conservative about extending this thing. minimality is one of the most important features, so that we only add new stuff when it's just overwhelmingly clear that this is something that every programmer would want.
01:06:43.088 - 01:06:55.998, Speaker B: Do you guys, as programmers on the other side of things, Noah, do you actually care when you look at and you pick what to use, how to engage, do you care how the community or the language is governed? Or do you just care that you're getting the tools that you need?
01:06:56.164 - 01:07:00.094, Speaker C: I think it matters to a certain extent. Like you want to use a language.
01:07:00.142 - 01:07:02.018, Speaker A: That a is used by a lot.
01:07:02.024 - 01:07:09.058, Speaker C: Of other people so you can have contributors to your project, right. You want a language that's not going to get abandoned, right? I guess those are sort of the main things, right?
01:07:09.144 - 01:07:09.538, Speaker B: Yeah.
01:07:09.624 - 01:07:23.110, Speaker C: But I don't really care if it's Python governance by dictatorship or governance by committee, as long as the things get done. Although I think a lot of people do not. There are a lot of arguments for why governance by committee has sort of broken a lot of programming languages, I guess.
01:07:23.260 - 01:07:25.938, Speaker B: Yeah, totally. I always find it fascinating.
01:07:26.034 - 01:07:56.462, Speaker A: Yeah, I do think it's important for I mean, I had a certain technical vision and for these things like the cross platform for programming with assets and basically like a broad idea of what these things should be. But of course, this is a community project. There are many, many contributors who have added to many aspects of design. And I'm by no means the benevolent dictator for move or anything of the sort. But I do think of my role as being a curator in terms of making sure that everyone is on the same page and just making sure that when ideas come in, we're evaluating them against those principles. And those ideas could come from anyone. But the most important thing is just that we have that shared vision.
01:07:56.462 - 01:08:04.786, Speaker A: Every language is a little different, I think they inherently reflect what they're used for and the personality of the creator and the community and all these sorts of things. So there's definitely not going to be a one size fits all rule.
01:08:04.818 - 01:08:29.770, Speaker B: There no totally that makes total sense. So before we wrap up with the last few questions here, I just realized, Sam, that we never actually. Heard from you about how you got to move in the first place. And I'm mainly interested in it, not just because I want to hear your story, which I'm sure is great, but I'm actually much more interested in the idea maze you traveled, like, how you came to this problem in the first place. So can you quickly share a little bit about that journey?
01:08:29.850 - 01:09:15.882, Speaker A: Absolutely. So I started off my career as a programming language. As a researcher, I worked in static analysis and program verification, which means that I spent a lot of time looking at real programs, looking at bugs, and trying to figure out what are the kinds of bugs that programmers consistently create and what contributes to those. Is it underlying issues with the language that just makes certain kinds of mistakes too easy to make? Is it problems with frameworks that they're using? Is it just things about human psychology that makes certain kinds of mistakes easier to find than others? And basically, in my PhD, I spent a lot of time studying real programs, looking at bugs, and then building these tools that try to look at code without running it and try to catch these bugs beforehand. And this thing in general is undecided. You're in the static program analysis. You're always fighting the halting problem, but you can get arbitrarily close to getting a perfect result in practice without ever reaching it in theory.
01:09:15.882 - 01:09:51.702, Speaker A: So spent a lot of time doing this and looked at all sorts of classic kinds of bugs, like null dereferences, buffer overflows security issues. And I really, really enjoyed this work. But it was hard to find these examples and find a lot of data sets that folks really cared about. But towards the end of my PhD, I did an internship at Facebook, and this was back in 2013, 2014. They were making the transition from the web world to the mobile world and discovering, hey, when I ship a bug into a mobile app, it sits there for two weeks, as opposed to the web, I can fix it right away. And when I joined, the fragmentation in Android was causing the most problems in terms of shipping bugs that just sat there forever. So one of the big things they invested in was the static analysis technology.
01:09:51.702 - 01:10:36.182, Speaker A: They acquired a team of researchers from my field, and I got to sit in with them and take the work I really love doing. But instead of begging sort of single digit programmers to fix bugs, you ship this stuff in front of tens of thousands of developers and run it in CI and get real time feedback on it's. Awesome that you found this bug. Why didn't you find this one? Can you also use it for that? And so I've spent about three years there just really getting deep into program analysis and programmers, and I love the work, but if you do this work for a long time, you develop a lot of opinions about language design. The cardinal rule of static analysis is you're not allowed to change the underlying language. You work with a program you get and you just do the best you can, but you can't help a look and say, oh, if they just did this a little bit differently, my tool could be more precise, or it could be faster, or this bug could be prevented by construction and we wouldn't have to be doing what I was doing. I could be doing something else.
01:10:36.182 - 01:11:20.562, Speaker A: And so I just had a lot of opinions about language design and software safety and sort of human psychology and how it interacts with these things and about program composition. Like how do you make it when you smash two programs that never anticipate each other together, that they still behave as expected instead of having some weird occurrence happen. And so in 2018, I got a chance to put these ideas to work when I was asked to join the Libra project to build a global scale payment network that was powered by blockchain. And they were just bringing in folks who had the sort of relevant technical expertise, so distributed systems, cryptography databases, payments, and then also programming languages. And so when I got there, this was about April 2018, it was a very broad mandate with like, hey, there's this smart contracts thing here's, the EVM here's bitcoin here's, this other stuff like, just try to figure out what we should do with smart contracts in Libra.
01:11:20.706 - 01:11:28.918, Speaker B: So Libra also was renamed to DM. That's how a lot of people might know it today. And then the other quick note, your PhD, what was the actual topic of it?
01:11:29.004 - 01:12:28.038, Speaker A: Yeah, I worked in goal directed static analysis. So normally when you do static analysis, the way you sort of do it is you look at an entire program and you build a database of facts about the program, and then you try to find bugs by querying that fact database. And this works well, but it tends not to scale well for really large programs because you have to look at the entire program and sort of do everything, whereas you might have a very pointed question that's about one particular part in the program. Like if you're running your analyzer and CI, for example, you really want to report bugs that happen on that pull request, and you don't care so much about what happens in the rest of the program. And so in my dissertation, I was looking at goal directed static analysis where it's like, hey, I want the efficiency of this static analysis to scale not with the size of the input program, but with the complexity of the particular property that I care about. So if there's really simple reasoning for why this thing is safe or why there's a bug, I want that to be really fast, where if it's really intricate reasoning that requires looking at everything, then that'll be correspondingly slow. This is a useful thing to do because one of the big issues with static analysis is just really slow, especially when you run on giant multimillion line programs.
01:12:28.038 - 01:12:38.362, Speaker A: So I was working on new theory in this subfield of static analysis called Abstract Interpretation to make abstract interpretation more goal directed and property directed for both better efficiency and better precision.
01:12:38.426 - 01:12:52.590, Speaker B: OOH, fascinating. You mentioned in your background that you were also interested in the psychology of things when you think about designing your PhD, your work until now. Can you quickly close the thread about the psychology of the programmer? Because you didn't actually scratch that itch for me.
01:12:52.660 - 01:13:28.046, Speaker A: So in 2018 when I landed at A, Libra is basically we need to have smart contracts on Libra, and you get to figure out what that means. You can't reason in a vacuum like this. As I was saying earlier, languages are fundamentally problem solving tools. So I looked at a lot of solidity in smart contract code and I was like, what are programmers trying to do with these things? Where is the language helping them and where is it getting in their way? And the main conclusion from this is just basically there's something that all these programmers are trying to do. They're trying to talk about assets, they're trying to transfer them, they're trying to define them. But the way this code is written is always just so indirect. It's almost like a brutalist design exercise where it's like you're trying to talk about this thing, but there's no vocabulary to be able to say it.
01:13:28.046 - 01:14:08.502, Speaker A: And that was sort of like the psychology element. I can read the program and think about what is this person trying to say in their head versus the code that they actually wrote, and what gets in the way during that translation layer? And how can the language help? By providing the right abstractions. And there's no objective answer to these sorts of things. This is sort of like, well, I'm a programmer too. How would I want to write this code? Or what would I find intuitive versus confusing? And so basically the decision to create move instead of building on top of the EVM or using an existing language is like, well, this smart contract domain, as we were saying before, it's just really different from anything else. It doesn't really make sense to use an existing language because it doesn't have those abstractions that you want or the features that you need. And if you're using something like solidity in the EVM, it's the first effort in the space.
01:14:08.502 - 01:14:33.266, Speaker A: So it didn't quite anticipate understandably what folks are going to want to try to do. So I thought we have all this second mover advantage. We have information about what folks want to do, what works well and what doesn't, and we should use that to craft a new language. And it was an interesting journey that we could talk about some other time to convince folks that you need to build a new programming language. When someone tells you that, you should always say no. And so there's a lot of very reasonable skepticism. I'm glad Facebook had the vision to try it out.
01:14:33.368 - 01:14:46.390, Speaker B: I mean, interestingly, it feels like it's almost the only place you could have spawned it and almost even better that you then can take it away from it and move on. It almost feels like the ideal conditions, in fact, for both the birth and the evolution of it.
01:14:46.460 - 01:14:47.890, Speaker A: Absolutely. Very serendipitous.
01:14:47.970 - 01:15:07.598, Speaker B: Yeah. So that's great context. So, last quick thing. Any parting words of advice for people trying to understand? Just a lightning round, like two second answer. If you had one piece of advice for people coming into the space of smart contract programming languages, or they're already in the space and you want a word of advice for them, what would you guys say?
01:15:07.764 - 01:15:27.766, Speaker A: Read a lot of code and read code where you know what it's trying to do and understand how the underlying code actually does that and what it does well and what it doesn't and why. Just really quick, I think this is just the best way to understand something. Like a language is a big surface to understand. It's very abstract, but if you start with something you know and just are trying to figure out how to do it, I think that's a much more concrete root in and it's easy to generalize from. That great.
01:15:27.868 - 01:15:29.526, Speaker B: Eddie and Noah, anything you'd add?
01:15:29.628 - 01:15:59.454, Speaker D: It's such a great question. I totally agree with what Sam said. I'd also add that because we're in early days, people love sharing all the cool stuff about how crazy it is to program on a blockchain. There are so many people that are just so happy to share, so happy to get into the weeds. Every time I have questions in any kind of big chat group or any forum, people love to share with me. So I'd say find people that you really enjoy just sharing your crazy code with and build in the open.
01:15:59.572 - 01:16:23.782, Speaker C: Mine would be that if there is a tool you love, that you make use of it every day in your workflow, whether that's a compiler, a testing tool, or whatever it is that makes your life easier, you should learn how it works. And also, every time you find a bug, you should go in and fix it. Be a good custodian of open source software. That's a great it's something I certainly if something has made my life better, I want to at least give back a little bit.
01:16:23.916 - 01:16:32.418, Speaker B: That's great, you guys. Well, thank you so much again for taking the time. Sam, Noah and Eddie, thank you so much for joining this episode of Web Three with a six and Z sonal.
01:16:32.434 - 01:16:36.406, Speaker A: Thank you so much. Thank you, Noah. And Eddie. This was a really fun conversation. I appreciate you having me thanks so much.
01:16:36.428 - 01:16:37.142, Speaker D: This is really fun.
01:16:37.196 - 01:16:38.434, Speaker C: Thank you guys. It was a great chat.
01:16:38.482 - 01:16:39.026, Speaker D: Thank you, sonal.
01:16:39.058 - 01:16:43.006, Speaker A: Sonal, thanks so much for having it. The lunch conversation with other nerds is my favorite thing.
01:16:43.108 - 01:16:48.542, Speaker B: Yeah, no, that totally that's why I described it like that. Except no lunch. Anyway, you guys have a great day.
01:16:48.596 - 01:16:49.600, Speaker D: Have a good one.
01:16:52.290 - 01:17:17.858, Speaker B: Thank you for listening to Web Three. With a Six and Z, you can find show notes with links to resources, books or papers, discussed, transcripts and more@asicscrypto.com. This episode was produced and edited by Sonal Choxy. That's me. The episode was technically edited by our audio editor, Justin Golden. Credit also to Moonshot Design for the art. And all thanks to support from Asics and Z Crypto.
01:17:17.858 - 01:17:33.520, Speaker B: To follow more of our work and get updates, resources from us and from others, be sure to subscribe to our Web Three weekly newsletter. You can find it on our website@asicsncrypto.com. Thank you for listening and for subscribing. Let's go.
