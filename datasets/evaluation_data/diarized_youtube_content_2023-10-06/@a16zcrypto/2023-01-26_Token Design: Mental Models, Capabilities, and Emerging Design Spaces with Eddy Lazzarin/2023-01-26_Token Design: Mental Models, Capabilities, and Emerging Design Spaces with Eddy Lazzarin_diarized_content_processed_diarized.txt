00:00:01.370 - 00:00:56.606, Speaker A: So I'm Eddie Lazarn, I'm the head of engineering for the crypto team, and this talk is a pretty brief one. I cover a bunch of topics in it, but stay pretty high level. And that's because I think a lot of people, when they think about designing tokens, there's some common pitfalls that I notice, and I hope that these are useful in helping your design process. So first I'll say that this topic was ostensibly about token design, but the truth is that token design is a really early field, and I think it's not correctly named. The truth is, this talk should be called protocol design, because tokens are not the thing that you're trying to make. What you're really trying to make is a protocol. And tokens are an incredibly interesting and useful and powerful and new type of tool that changes how protocols can be designed and what's even possible.
00:00:56.606 - 00:01:38.438, Speaker A: But they're still not the core object that we're trying to make. I should say that a protocol design is more alchemy than chemistry. Now, in other words, our understanding is far from comprehensive or scientific, and most projects need to experiment in areas that few others have ventured. So first, mental models. I'd like to start with sharing some simple models for the design process that smooth things over. In the second part, I'd like to talk more specifically about what tokens actually are and how we can think about developing and enhancing their capabilities. So first, tokens serve protocols.
00:01:38.438 - 00:02:16.322, Speaker A: They're just a tool, they're just a part of the design process, and they shouldn't be the goal. If you want to make something that's truly decentralized, a real protocol that stands the test of time, a token is likely to be part of that, because it's a great way to give ownership and powers over a protocol, as well as alignment to a wide group of people. A token is likely to serve long term decentralization. Here's a way to think about the design process that I've seen shared by successful projects. I've seen in conversations with portfolio companies. These three stages emerge naturally from successful design processes. The first is orienting around a goal.
00:02:16.322 - 00:02:50.338, Speaker A: A goal is just a concise description of the result of a functioning protocol. What is it that you want to see out? A goal should be unmistakable in terms of whether it has been achieved by a specific design. So we should have a very clearly delineated success and failure condition that that goal describes. If it's not clear what our goal is, we need to start from the drawing board. Forget tokens. We need to think about a few other things. Ideally, a goal is measurable, even if we aren't sure how to measure success just yet.
00:02:50.338 - 00:03:39.566, Speaker A: Once we have a really clear goal for a protocol, for a system, then we need to introduce constraints. There's two kinds of constraints, very generally, endogenous constraints and exogenous constraints. Endogenous constraints are constraints that we choose to simplify the design process, to commit to known trade offs, or they're just interesting things that we like. It's totally possible to choose constraints just because you are familiar with that set of trade offs in that area and you're playing through your strengths. A really cool talk I saw that I can put in the recording notes was by subset games. The team that designed a few really cool games like into the breach and FTL, and it talks about designing under constraints. I really recommend that talk for anybody designing a protocol.
00:03:39.566 - 00:04:19.066, Speaker A: They choose constraints just based on what's fun, what they think makes fun in the game. Certain constraints are just delightful to consider. So the point is, endogenous constraints can come from many places, but usually from you. Exogenous constraints are imposed on you by nature, by the state of technology, by regulations, by all kinds of things. We'll talk a little bit more later about exogenous constraints coming from technology. It's a very interesting one. Once we have constraints and our goal now we can very cleanly and clearly think about mechanisms that can satisfy that goal according to those constraints.
00:04:19.066 - 00:04:58.486, Speaker A: And I think this is where the substance of a protocol design happens, where we know what binds us, we know where we're trying to go. And now every time we consider a mechanism, it should be really clear whether or not it violates those constraints and gets us closer to that goal or not. And this can really simplify and make more systematic how you're reasoning at the end. A protocol will be a family of mechanisms that all drive toward a specific goal according to some constraints. So let me walk through a simple example. Maker protocol. It's been around for a while and it's well understood.
00:04:58.486 - 00:05:37.730, Speaker A: There's a lot of wonderful documentation about it, if you aren't familiar. Their goal was to develop a stable asset native to Ethereum. And of course there's different ways to define stable. There's a couple of ways to interpret native, but that becomes clear when we contemplate the constraints they accepted. They decided that the price should be linked to the dollar. It should be backed by fully native on chain assets like ETH and a variety of other things. Some of those are endogenous some of those are exogenous, some of them are just you need to choose a fork in the road and you commit to one.
00:05:37.730 - 00:06:33.846, Speaker A: And the whole family of systems of mechanisms that make up the maker protocol are all pretty clearly intended to support some part of the design, some part of the goal. This will be more useful for people who understand how maker works, but I really recommend it as an example of an open protocol design that has very little fat on the bones, although of course it was early in the history of on chain protocols, and we've learned a lot since then. Here are some common failure patterns. The first is token first thinking. I've already alluded to this a little bit, but if you're thinking about rewards or token allocations instead of agents, or how to preserve alignment among the participants in your system, you're probably not thinking about a protocol. You're thinking about that token. And the token is not the protocol.
00:06:33.846 - 00:07:26.650, Speaker A: The token shouldn't be your goal, it should be just a tool. How do you get out of this trap? Well, besides the obvious, maybe ask yourself, how would the system work without a token? I've just removed the token altogether. What fails? If the system fails completely, like it disappears without the token, you're probably overemphasizing the role of the token. If a few key parts of the system fail, then you're in a slightly better place. It's probably the case that your token is really important and necessary to balance it up holistically, but it's still coherent and explainable. Without the token, you should still be able to have a conversation about the goals and functioning of the system without the token. A second common failure pattern is having an unconstrained design space.
00:07:26.650 - 00:07:51.394, Speaker A: This is where you're trying to think about what to design, what to build. There's too many possibilities. You don't even know where to start. There's so much happening, there's so much you could do. This is usually a consequence of having an underspecified goal. So go back and refine it. It could also be because you lack an understanding of, or you have not yet accepted constraints imposed upon you.
00:07:51.394 - 00:08:57.160, Speaker A: If you bring those constraints in, you will see that the design space will shrink and it'll become clear what exactly you have to play with. Two questions that are helpful in constraining the design space is to ask yourself, what's the powerful concept you're trying to build on? Usually, if you're at this point in the first place, there's a phenomenon out there that you, as an entrepreneur, as a protocol designer understand? And you are trying to build on it. You're trying to capitalize on something, some insight, some advantage, some change in the zeitgeist. What's that one powerful concept, and how can you capitalize most on it? Focus on that thing. Focus on the strength as opposed to the totality of the system. The totality will come later. Another question is, what's the biggest weakness of this design? What's something that keeps you up at night about it, or something that you think might not work, or something that concerns you? The key weakness? And what constraint could you accept that would ameliorate it? This can significantly limit the design space.
00:08:57.160 - 00:09:46.440, Speaker A: Another common failure pattern is the community waste basket. And this is where, as a result of challenges in designing some part of the system, you just say, we'll offload it to the community, like we're decentralizing anyway. So maybe rationalizing to yourself with a noble goal. If you're expecting unseen forces to pick up the slack, if you're expecting people to just kind of come in and see the problem and fix it, you're taking a very risky bet. Although popular permissionless systems have incredible innovation happening all the time, and people build fascinating things that you would never expect using them. You can't anticipate what they're going to do, and you shouldn't expect that they'll fix the most obvious problems in your system. A few key questions you should ask yourself.
00:09:46.440 - 00:11:06.126, Speaker A: What are we really expecting of the community? Like put that front and center instead of continuously tossing things into the waste basket, just ask yourself, what are we really expecting of them? What are we giving them? I don't mean like are we giving them tokens? Enough tokens. I mean explicitly, what powers are you giving them? What capabilities are you giving them? What ownership over what are you giving the community? Are they being given enough power to balance this responsibility? If you really expect them to fix a thing, and also ask yourself, would you build here? If you expect other people, other ambitious people to come in and add some interesting new extensions or fix some component of the system, would you? If you wouldn't, because it doesn't have enough upside or enough power or enough flexibility, it doesn't make sense to expect others to do so. Next, I wanted to present a little bit of a token taxonomy. This is not complete. I've been talking with members of the team about this, and I'm sure that we'll make modifications soon. But this is just an attempt to enumerate all of the capabilities we've seen tokens exhibit so far, and to connect that with some of the language I was using earlier. Tokens are an instrument in a protocol.
00:11:06.126 - 00:11:48.090, Speaker A: They're a tool in a protocol. They're even more abstractly, they're a data structure. So how have we seen this data structure being used in different protocols? I think you can separate them out into, very generally speaking, five categories. Of these five categories, payment, voting, stakeholding, metadata, and claiming, I'm sure that there will be more resolution in each over time, and this grouping that feels, at least to me, more or less intuitive now will change. But this is how we have it. I'll walk through them really quickly and give some examples. For payment, we have three different noted capabilities.
00:11:48.090 - 00:12:31.466, Speaker A: One is an internal currency that's internal to a community or a project. We haven't seen a ton of these yet, but there are some examples. For example, source cred was an interesting one, FWB maybe trending in this direction. It's different from conventional payments, like dollar payments, because since it lives inside of a specific community, and that community has control over that currency, they could exhibit monetary policy type influences over that internal currency. Maybe that currency is supposed to be stable. Maybe it's supposed to be linked to the value of some other specific asset. Maybe they mint or burn it according to specific community wide goals.
00:12:31.466 - 00:13:20.114, Speaker A: The point is that it just reflects payments internally. A second, probably the most commonly used and the most well understood way to use crypto for a kind of payment is as a network resource. So eth falls under this bucket, even bitcoin falls under this bucket. These are where you're paying for computation or storage or some other crypto network resource. Using this token, we have EIP 1559, and we have staking and liquid state. All these things where we reason about how this token can be used to renumerate different agents within a system, specifically for computational resources. The third kind of payment token is as an arcade token.
00:13:20.114 - 00:14:08.442, Speaker A: This is where there's maybe a game resource or some protocol resource that's meant to be stabilized, meant to be priced more or less consistently, where you're able to use the system. The token's price is meant to be more or less steady because you're getting a consistent amount of that resource, or that opportunity to use that game or something like that. The key differentiating feature is that it's stable. Supply doesn't matter, and you're using it specifically to consume a specific part of an application. You might say, where do stablecoins live in this realm? Certainly a stablecoin could be used to pay for any of these, you could use a stablecoin as an internal currency. You could use a stablecoin to pay for network resources. There's examples of that.
00:14:08.442 - 00:14:35.846, Speaker A: You can use a stablecoin as an arcade token. But what makes a stablecoin a stablecoin is the mechanism for stabilizing it. You'll find that stablecoin examples tend to fall into that last bucket. Claiming loosely speaking, there's two kinds of claiming. There's on chain claims, which we're calling deposits, and off chain claims, which we calling titles. Deposit tokens are tokens that represent a claim on another token. It's purely an onchain thing.
00:14:35.846 - 00:15:36.902, Speaker A: An example would be like a uniswap LP token, which in V two was an ERC 20 and V three is an NFT. Even dai, the stablecoin that comes out of the maker protocol is an onchain deposit because you use it, or vault holder uses it to claim their underlying collateral. So this is just where one token's purpose, the key functionality that we're discussing, is to claim another token in an onchain context. The second type of claiming token is where the token represents a title on some off chain asset. So that could be like a real world asset token, or like a real estate token or something like that. We haven't seen a ton of examples of this take off. A more contemporary example would be what some people call redeemables, where the token represents a claim on a physical thing, like a cool tradable sneaker or unisocks from way back in the day.
00:15:36.902 - 00:16:40.060, Speaker A: There's some cool new contemporary ones where there's like a piece of art that trades with an NFT, and the NFT represents a claim over the art, and you can get the art delivered to you if you want. There's even interesting ones where you can use the physical object to give you control over the NFT. So if you move that object around, that object may have some capability, some digitally enabled capability, like through a chip or something, that allows you to take some control or ownership of the subsequent NFT. The voting capability is one that's been discussed quite a lot and really emphasized over the last couple of years, the so called governance token. There's three key capabilities for voting, though voting is often discussed, but it of course has different specific meanings. You can vote to fund projects, you can vote to allocate a treasury or other resources. So that's where you vote just to make a payment or transfer as a group.
00:16:40.060 - 00:17:16.594, Speaker A: A second is where you vote to upgrade software. This is kind of a key, very crypto native, very interesting one that is often debated. Tokens can be used to directly control the upgrade process for software, which is really interesting. You can also use it as a social consensus measure. Just people signaling what they think, choosing a leader, deciding the future plans for a project. We see a lot of examples of this on snapshot with off chain votes. Then we have stakeholding tokens.
00:17:16.594 - 00:18:16.378, Speaker A: Tokens, of course, could be designed that are entitled to returns through a smart contract. So there's no legal agreement here, but the functioning of the mechanism means that this token will benefit from some kind of on chain activity. An example could be maker, right? Where if maker works and the maker voters, that wide set of token holders, do their job well and the system functions properly, then they will benefit from some returns, because that's the way that the smart contracts, that's the way the protocol was designed to reward good stewardship from the wide maker community. You could also make tokens to be entitled to returns as a result of a legal agreement. This would make it a security. You could make a token that represents an equity portion or equity share of a company. Of course there would be all kinds of legal requirements and restrictions and ways that this token would need to remain compliant with such laws, but you could do that.
00:18:16.378 - 00:19:18.314, Speaker A: There was a time when there were some people that theorized about security tokens being its own interesting category of innovation, although truthfully we haven't seen a lot of interesting development there. You can also have a token that receives returns in exchange for underwriting. Risk maker does this too. It's important to say is that if there is a shortfall in the maker protocol, then more maker tokens are created which dilute the maker holders to make the protocol whole. So by holding maker tokens, you hold some risk, you take some risk in that asset, and that is part of what drives a maker holder. If they want to see their purchase appreciate, that's what would drive them to support the system it creates. Alignment risk is distributed among the token holders, and if they do their job, the system should function and they may make some money, or their asset may appreciate metadata.
00:19:18.314 - 00:20:03.190, Speaker A: This bucket is a little crowded, but I think you'll see why there's membership. Membership is where a token is used to decide, or holding a token is used to decide whether or not you can access a specific space, or whether you're in a specific community, or whether you're in some group. It's deliberately a little bit vague, because a protocol or some third party writing a tool can take advantage of that membership property in any way that they want. Right? It's permissionless. It's interesting. Of course, some NFT community, as an example, could decide that only people who hold the token can join the community group chat, but someone else could do the same thing. Someone else could say, I'd like to read that membership list and I'd like to offer specific functionalities to the people who hold this token.
00:20:03.190 - 00:20:32.978, Speaker A: So the point is to say is that the membership, your status as being in this group or not is an interesting type of metadata that having that token provides. I haven't described whether any of these tokens are transferable or not, fungible or not. I see that as a parallel property. Some of these obviously work a lot better if they're fungible. For example, payments would be a little bit tough if they weren't fungible. Reputation is an interesting one. Some people talk about whether or not reputation should be transferable.
00:20:32.978 - 00:21:11.314, Speaker A: I personally think it probably shouldn't be. But it probably should be fungible for certain cases and non fungible for others. An achievement or a badge, right? Where you have like a discrete measure that you've done something or achieved something, or that you have some specific role, that's a kind of a reputation that's non fungible. Source credit or different types of credit scoring systems are a little bit more fungible just because it's a continuous range. So that's one kind of metadata that a token can bear. Another is an identity or a reference. ENS is an example of this.
00:21:11.314 - 00:21:49.834, Speaker A: This is where the token provides a kind of metadata that simply points to something else. So in this case, an ENS name can point to an address which can be updated. Not unlike the DNS system, it's just a reference to something else within the machine. Off chain data, of course, can be a kind of metadata. An example would be like an off chain kyc or some sort of verifiable credential. Another good example, like a diploma or academic qualification. Someone hands this to you, and now this piece of information is available in public with provable lineage, provable authenticity on chain.
00:21:49.834 - 00:22:47.858, Speaker A: So any kind of off chain data, a more subtle one, different though that we haven't seen a lot of examples of. I think I'm really excited to see more examples of, is ways to represent permissions and capabilities on chain. So this is where some entity explicitly grants you a permission, like an ability to call a function or change a piece of code, or to transfer something on chain, but potentially through levels of indirection. So for example, I could give someone in my dao the capability to grant other people temporary memberships. It might make sense to do this with some type of token, some sort of badge that has this metadata. Another really cool one that I think probably the party Dow team has had the most exciting conversations with me about is tokens that have their interface within them as a kind of metadata. It's a really cool one.
00:22:47.858 - 00:23:35.310, Speaker A: We've seen examples of this where more than just having the SVG data in a token's URI, you could also put a whole HTML web page. You could even put a little javascript if you wanted. You can put an interface and the control to the interface within the NFT, which means that an NFT can bear with it, the means of using it. It's kind of an inversion of the way that we typically think about it, but there's no reason that can't be the case. All the people who talk about and think about rightly decentralized interfaces should think about that. Maybe you can embed the interface in the very object that people own and transfer or have. So that wraps up the tour of tokens capabilities.
00:23:35.310 - 00:24:25.826, Speaker A: I think it's exhaustive so far, actually. Maybe there's a couple of small tweaks I'm already thinking about, but if you have any that you'd suggest that don't quite fit in, I'd love to hear from you about them. Just to make really explicit, I've already talked about Maker a couple times. As a good example, Maker has two tokens, the MKR token, which has the capabilities on the left, and the DAi token, which is chiefly the capability on the right. You can think of any token as having some set of these capabilities. Another cool example I saw, really just neat because it's so different from maker and I think that its creativity along these capabilities. What makes it so delightful this project is called beeper, and you mint an NFT with a text, and then you can broadcast text to other beeper holders only through having it.
00:24:25.826 - 00:25:26.714, Speaker A: And those texts get displayed on the NFT's representation. Like if you went to the Opensea page, it actually renders on the little image of the beeper. When you have a beeper, you can also message other beeper holders directly, like individually using XMTP, which is great. So what are the capabilities of this token? You have this token, you can see the beeps on it. Presumably any wallet interface that can represent the animation URL properly can show you whatever beeps you have on there just by supporting that standard. What are its capabilities? Well, it's definitely a membership token because by being a beeper holder, you receive all the beeper messages and you can message other beeper holders, right? So this is something that only happens within that set. It's also an identity token or reference because they message you using the token id of your beeper NFT, I presume? I actually don't know, but be kind of amusing.
00:25:26.714 - 00:26:00.400, Speaker A: If you traded or sold the beeper NFT, you might start getting someone else's messages, which is funny. And it contains within it an interface for viewing information relating to that NFT, like which messages have been broadcast to it. Pretty cool. So here I'm showing the token capabilities again, but kind of highlighted them in slightly different colors. The darker ones are ones that we've done more work on recently in crypto. I don't feel very, so I'm sure very happy to be wrong about this. It's just kind of my squint taking a quick squint and looking type of view.
00:26:00.400 - 00:27:04.802, Speaker A: As an example, we've thought very deeply, compared to other things, about how to think about a crypto token as a payment token for a network resource. The analysis of EIP 1559 is a great example. All the interesting auctions mav this is an area of deep research, whereas by contrast, interfaces and views, like representing the interface for a token or set of tokens in the metadata, is something that is brand new. I've heard very few projects talk or think about it, even though people do think about decentralizing interfaces. So if you take this view of the world, some capabilities we've gone deeper in, some capabilities we haven't, why is that? Right? And I don't have a super complete answer, but I want to gesture at it a little bit. In part three, where I talk about the tech tree theory of the world and the tech tree theory of protocol design, here's like a little bit of a tree. This is far from complete.
00:27:04.802 - 00:28:23.520, Speaker A: This is just me drawing like a kind of cool image where if you take DeFi as an example, DeFi is this whole interesting field that's been important in crypto and kind of appeared seemingly very suddenly, and has all these different subspecializations and mechanisms that make it up. Why did they appear when they appeared, and why have certain things been around longer than others? Well, take lending protocols as an example. It'd be really hard to imagine a lending protocol that functions without stablecoins. And that's because when you take out a debt in a lending protocol, you want to denominate it in a stable asset whose price you can predict taking out a debt in a volatile asset is going to be very hard to reason about. So we needed stablecoins before we could really have lending protocols. Similarly, we kind of needed amms for lending protocols too, because if you want to take leverage using a lending protocol, especially an early, simple lending protocol, you need to be able to take what you borrow, which might be stablecoin. If you want to have leverage exposure to some other asset, and you want to be able to trade that stablecoin very quickly for the asset you want more exposure to.
00:28:23.520 - 00:29:21.086, Speaker A: In other words, you need an amm to lever up. So we didn't really see lending protocols take off until we had functioning amms and stablecoins. But how do you get functioning amms and stablecoins? I think it would be really difficult to do so without an ERC 20 token, right? Without an interoperable token standard. Because the stablecoins, amms, and all the systems around them need to be able to make presumptions about the ways other projects will interface with them. For there to be ERC 20 tokens, you need fully programmable smart contracts. You probably don't really, really need them, but that's how they emerged for the first time on Ethereum, because Ethereum launched without an ERC 20 token standard, and we needed full programmability to be able to leave the design space open enough so that people could make it. That point could be debated, and I'm willing to concede it.
00:29:21.086 - 00:30:41.994, Speaker A: But you get my idea that there is a little bit of a tech tree, and there are certain technologies that exist as prerequisites to other ones. So here are two questions. What are the key technologies that unlock the applications and protocols of the future? For example, which technologies do we need in order to develop useful reputation systems or decentralized and trustless interfaces? And the second question, kind of by inverting the first, what are the applications and protocols that will be unlocked by nearby technologies? By nearby, I mean technologies that have just been developed, or will be developed very soon. For example, account abstraction, EIP 48 44, vertical trees, zero knowledge, machine learning like clients, all these are really cool. Nearby tech, many projects are thinking about taking advantage of them. What will be the results? One reason I think that these questions are interesting to ask is because technology can alleviate or introduce design constraints. If we anticipate specific technologies coming, how does that change our design? If specific technologies would alleviate constraints we've recognized that may be too restrictive for us, should we spend effort developing them? I think if we think of things as a tech tree, it may help you reason about what's coming or what you need to arrive at a set of constraints that you want.
00:30:41.994 - 00:32:00.506, Speaker A: So to tie it back to my initial constraints point, I think that new technologies alleviate constraints that we had before. To give you a specific example, if there was no ERC 20 standard, then a constraint on any AmM or stablecoin design would be that it would either need to introduce a standard or be able to cope with all kinds of different designs. Imagine designing an amm that is general, but doesn't use a specific token standard for people who want to plug into it. That would be really, really difficult. I think that would be an almost insurmountable constraint. But having that interoperability standard means we can take that for granted and say we're going to support the ERC 20 token, and that limits the design space, which makes it possible to implement such a thing. So if we anticipate specific technologies coming down the line, how does that affect the constraints for our protocol design? If we have specific things, goals we want to achieve with our protocol design, or specific constraints that are limiting, what are the technologies that we need that would alleviate those constraints and make those goals possible again with new mechanisms? I hope these perspectives are helpful, and thank you to everyone who helped me refine these thoughts or participated in discussion at founders summit.
00:32:00.506 - 00:32:00.970, Speaker A: Bye.
