00:00:18.410 - 00:00:44.140, Speaker A: So welcome, everybody. I'm really excited that this school is happening. This is an amazing opportunity. I'm actually really excited to see what kind of apps you guys build. And I'm looking forward to this week seven, where we get to see everything you've designed. So what I wanted to do today in the next hour, basically, is tell you a little bit about the technology behind blockchains. I'm really excited about this technology in that technically, from a technical point of view, it's just fascinating to work in.
00:00:44.140 - 00:01:17.538, Speaker A: The basic issue is that building decentralized applications is just technically much harder than building centralized applications, which makes it very interesting for someone like me. So I teach this stuff. I kind of live this on a daily basis. This is going to be a pretty high level talk. This is a rabbit hole that goes pretty deep. But I'm happy to go kind of to as much depth as you'd like, maybe after the presentation. I should also say that we've been teaching this class at Stanford now for, what is it, five or six years? And pretty much the attendance in the class kind of follows the bitcoin price.
00:01:17.538 - 00:01:34.854, Speaker A: It's pretty normal. On a bad day, students don't show up. On a good day, they do show up. All right, so let's get started. And I want to get started just kind of by explaining my view of what a blockchain is. And so I kind of like to think of it in terms of four layers.
00:01:34.902 - 00:01:35.066, Speaker B: Yeah.
00:01:35.088 - 00:01:53.802, Speaker A: So at the bottom layer, we have the consensus layer, which just makes sure that everybody sees the same thing. On top of the consensus layers, this is layer one. On top of the consensus layer, we have what I would call layer 1.5, which is the compute layer. And here I stole Chris's term, the blockchain computer. I love this term. So thanks for inventing that, Chris.
00:01:53.802 - 00:02:23.862, Speaker A: So it's called a blockchain computer. This is kind of the operating system of the blockchain on which you write applications. And then L2 is basically where the applications run. And typically applications would be written in languages like solidity or move. Move is the Libra language or Motoko and so on. And then on top of the applications, these are applications that actually run on the blockchain computer. And on top of those, you have sort of user facing systems that kind of run in the cloud and talk to the blockchain and talk to end users.
00:02:23.926 - 00:02:24.106, Speaker B: Yeah.
00:02:24.128 - 00:02:50.914, Speaker A: So those are kind of the four layers. I have to say the consensus layer is getting pretty well understood. There's still a lot of work here. But this is kind of not where the most exciting action is. Most of the exciting action actually is in building applications. In fact, these L2 applications are now starting to be called L2 blockchains. And so that's kind of where most of the action is, and I imagine that's where most of you are going to be working in.
00:02:50.914 - 00:03:27.194, Speaker A: Now, when I showed this slide, at some point, somebody asked me, what you blockchain people, you don't know how to count. And the reason it's layer one and layer 1.5 is because often these two are kind of combined together, but I kind of like to separate them because really there's a consensus issue and there's a computing issue, and literally, we could talk about each one of those layers for weeks, but we don't have weeks. So I'm just going to say a few words about each layer, and then we'll move on to more pragmatic advice. Okay, so let's start with consensus. So first of all, the consensus layer, again makes sure everybody sees the same data. So it provides persistence.
00:03:27.194 - 00:04:00.346, Speaker A: So once data gets added to the blockchain, it can never be removed. And there's an asterisk there because there's a caveat. The caveat is a 51% attack. So under certain assumptions about malicious behavior, the data can never be removed. Consensus means that basically all the participants see all the data. The reason there's two stars there is because when we talk about all the participants seeing the same data, we mean that that is true, perhaps other than the last few blocks that were added. So you may have to wait a few blocks for everyone to see everything, but otherwise everybody sees the same data.
00:04:00.346 - 00:04:36.370, Speaker A: Liveness means everybody can add data to the blockchain so it doesn't get stuck. And finally, there's this notion of openness, which means that anyone can be a participant, anyone can write to the blockchain, and there's no authentication that's needed to become a member and write to the blockchain. The reason there's a question mark there is because some blockchains provide openness and some blockchains. Some blockchains are open blockchains and some are permissions where not everyone can write. So that's the consensus layer. I did want to say a little bit about just a few words about what it does. And so this problem, consensus is not a new problem.
00:04:36.370 - 00:04:48.822, Speaker A: This is an ancient, ancient problem. And by ancient, I mean from the 1980s, where you have systems that people run multiple servers in their data centers, and these systems have to see the same data.
00:04:48.876 - 00:04:49.046, Speaker B: Right.
00:04:49.068 - 00:05:15.554, Speaker A: Bank of America has a huge number of machines. They all have to make sure they see the same amount of funds in my account. And so this problem is called what's called state machine replication. Traditionally, it's actually not called a blockchain. It's called state machine replication. The difference is that in the traditional world, there's a known number of servers, and all these servers have been pre authorized. So they've all been given sort of cryptographic material that allows them to authenticate to one another.
00:05:15.554 - 00:05:57.962, Speaker A: The difference with the blockchain world or the open consensus world is, as we said, actually, there's an unknown number of participants who can write to the blockchain and they're not authenticated. Anyone can participate. You don't have to do anything in order to participate. And the surprising thing is that, in fact, people have asked, can we do consensus in these settings? And there's an impossibility proof that says you cannot achieve consensus if you don't have authentication or you don't know how many participants are in the network. And sort of Nakomoto's innovation is a way to get around this impossibility result. And I'll talk about that in just a second. Okay, so now that we understand what the innovation is, let's just talk for, just briefly about how blocks get added to the blockchain.
00:05:57.962 - 00:06:31.734, Speaker A: I'm sure many of you have seen this before, but it's still kind of fun to go through. So we have our acute miners over there and we have our participants. Each participant has a secret key, which goes back to what Chris was saying. This secret key signifies ownership, right? So you own your tokens, you own your data, and no one can take it away from you unless you sign it away using your secret key or someone compels you to give away your secret key. So how does this work? Well, so these users basically sign transactions. They use their secret keys to sign transactions. They send these transactions to the miners.
00:06:31.734 - 00:06:47.514, Speaker A: Now, the consensus protocol basically chooses a random leader among these participants. The random leader orders the transactions into a block, and then the block gets posted onto the blockchain. And importantly, the leader gets paid by a native currency to the blockchain.
00:06:47.562 - 00:06:47.678, Speaker B: Right.
00:06:47.684 - 00:07:27.690, Speaker A: So in this case, they get paid to eth, and then the other miners actually verify that a block is valid. If it's not valid, the block sort of gets discarded. There's one thing that I wanted to point out here, which is kind of important, which is you realize this leader that got elected, the leader is the one who decided the order of the transactions in a block. Just think about that for a minute. The leader, the miner that built the block, decided on the order of transactions. That is an extremely powerful position to be in, because if a certain piece of bad news comes out about the blockchain, you could imagine people are lining up to sell their currencies. And who gets to sell first is determined by the miner.
00:07:27.690 - 00:08:13.094, Speaker A: This is a power that can be sold, right? Which is not a good property we'd like to have. So ideally, we'd like to have a blockchain where in fact, the order is not determined by the miner, but determined by some randomness. But this is not currently supported. So if you're looking for interesting questions to think about, this is really a fascinating one, which is, how do we make sure that no one, not even no single miner, has the power to order transactions as they get put on the blockchain? Yeah, this is kind of an important point. Okay, so we have this mechanism, and then a new set of transactions is generated, a new leader is elected, and the block, and a new block is created. Now you realize, and then this new leader, by the way, also gets paid to eth. Now you see why the impossibility result came about.
00:08:13.094 - 00:08:41.294, Speaker A: Because if there's no authentication and nobody knows how many participants there are, what I'm going to do is, let's say I'm the blue miner over there. What I'm going to do is I'm going to pretend like I'm 1000 different miners. Even though I'm a single entity, I'm going to pretend like I'm 1000 different miners. And then these other two miners will hardly ever get chosen. I'm going to be elected every time, right? There will be 1002 miners overall. I get elected every time. So I always get to collect the two e, the block rewards for creating these blocks.
00:08:41.294 - 00:09:20.474, Speaker A: So that attack is called what? Thank you. That's altogether now. So that's called a Sibyl attack. And the whole point then. But the impossibility result, by the way, said if you don't have authentication, consensus is impossible because you're going to be vulnerable to a civil attack. And the beauty of Nakamoto's innovation is that we can prevent civil attacks by forcing some sort of commitments to constraint, to resources, right? So we're going to force the miners to commit to resources. And you guys know the story that in bitcoin, the resource we're committing to is proof of work, right? So if I want to pretend to be 1000 miners, I have to buy 1000 machines.
00:09:20.474 - 00:09:21.546, Speaker A: And that's expensive.
00:09:21.658 - 00:09:22.320, Speaker B: Yeah.
00:09:23.250 - 00:09:48.774, Speaker A: Of course, proof of work has. This is basically what's been used in the first generation blockchains. I think we're going to be moving away from proof of work. It's proven to be problematic because of it's relatively slow, it burns a lot of energy. So all the criticism that we read about in the press usually criticizes how much energy these things are wasting. And the answer is, well, no, that was just the first attempt at building a blockchain. We're moving away from proof of work.
00:09:48.774 - 00:09:54.346, Speaker A: And actually all the other ideas are much faster and they don't burn energy or hardly burn any energy.
00:09:54.448 - 00:09:54.714, Speaker B: Yeah.
00:09:54.752 - 00:10:19.710, Speaker A: So first thing is when someone complains about energy, you tell them that, well, that was the first experiments. The future is not going to be much more efficient energy wise. So we have a lot of blockchains that are proof of stake based systems. So again, they prevent civil attacks by forcing people to commit to funds rather than to commit to cpus. Proof of space is a beautiful, beautiful idea where you say instead of committing to computing power, you have to commit to disks.
00:10:19.790 - 00:10:19.986, Speaker B: Yeah.
00:10:20.008 - 00:10:25.890, Speaker A: And the nice thing about committing to disks or disk space. The nice thing about committing to disk space is that doesn't take much energy.
00:10:25.960 - 00:10:26.194, Speaker B: Right.
00:10:26.232 - 00:10:49.530, Speaker A: Storing data doesn't take much energy. You just have to show that you're storing certain blocks when needed. And then there are some other beautiful ideas due to avalanche and others. So there's lots of explorations of the consensus space, just so you're aware. But that's actually, again, not quite where the action is. As I said, most of the action is in L2, in building applications on top of blockchains. Okay, so let's talk about that.
00:10:49.530 - 00:11:03.606, Speaker A: But the blockchain computer. So here, I'll go quickly through this. So basically you write applications, you post them on the blockchain, and then these applications basically respond to events from the outside. These events are called transactions.
00:11:03.658 - 00:11:03.826, Speaker B: Right.
00:11:03.848 - 00:11:10.366, Speaker A: So people send transactions to these programs that are running on the blockchain and the applications respond.
00:11:10.478 - 00:11:10.754, Speaker B: Yeah.
00:11:10.792 - 00:11:37.334, Speaker A: So the beauty of running applications on a blockchain is a essentially all the code is open source. And I have to tell you, this is so refreshing, working in the space where I talk to a lot of blockchain projects and nobody ever tells me, we can't tell you what we're doing. It's a trade secret, which is what I usually hear. Everybody's very open about what they do. All the code is open source, all the ideas are out there. Everybody publishes as fast as they can. So it's just so refreshing.
00:11:37.334 - 00:12:11.922, Speaker A: It's so much fun to work in the space. There are really no secrets because everything is based on trust, right? I'm not going to trust you unless you tell me how the system actually works. So everybody's incentivized to share their ideas and share their code. So everything is open source, everything is verifiable. So we have this property, I like to call that transparency, where the world can see exactly how things behave. And then we have also public verifiability, where I can look on the blockchain and see exactly that all the rules are being followed correctly, that the code is actually being executed the way it's supposed to execute, and no one is deviating from the rules.
00:12:11.986 - 00:12:12.262, Speaker B: Right?
00:12:12.316 - 00:12:51.554, Speaker A: So again, in the real world, you think about that we don't have public verifiability, where most of the time we have to trust that banks do what they're supposed to do or the fed does what it's supposed to do. Most of the time it's based on trust. Whereas here you could just look and verify for yourself that things are progressing correctly. So let's go through quickly how you deploy applications on the blockchain. So we'll do that very quickly. So you write your code, you create an application, you write that in solidity, you compile it into the EVM, for example, if you're using ethereum, then you post your code onto the blockchain. With what? So this orange thing is the code, this blue thing is kind of the initial state for the application.
00:12:51.554 - 00:13:35.550, Speaker A: And then somebody sends a transaction to the application, and basically that causes a state change in the application. So maybe some funds moved, or maybe Chris Dixon got to own cdixon.com, right? So that's the type of transaction that is processed, and then another event happens and another state change happens and so on and so forth. Now, in preparation for what's coming, I have to tell you that these, as I think Chris said that the Ethereum network can process something like seven transactions a second. That's way too slow for running all the world's application. So really all the focus today is on scalability and basically touching the blockchain as little as possible. Yeah, and I'm going to talk about techniques for doing that in just a minutes.
00:13:35.550 - 00:13:51.926, Speaker A: But essentially, when you build your L2 apps, part of the goal is to avoid touching the blockchain as much as possible so that things actually scale, or I should say, to be precise, to avoid touching the layer one blockchain. So the L2, blockchains are much more performant. Okay, good.
00:13:52.108 - 00:13:52.454, Speaker B: Right.
00:13:52.492 - 00:14:18.986, Speaker A: So there are different execution environments. These blockchain computers provide different interfaces. So for example, bitcoin provides bitcoin script, which is a very restricted language. So in particular, you don't have loops. If you don't have loops, you can tell exactly how long every program is going to take to run. So that has benefits. So it's good enough for certain things, but at the same time, there are lots of things you'd like to code up that you simply cannot code in bitcoin.
00:14:18.986 - 00:14:33.598, Speaker A: It's interesting, like in our class on payment and lecture on payment channels, I can tell you, we devote about 45 minutes of the lecture to explaining how payment channels work on bitcoin. It's fairly complicated. And then we devote about 2 minutes to explain how it works on Ethereum. Because it's trivial.
00:14:33.694 - 00:14:33.954, Speaker B: Yeah.
00:14:33.992 - 00:14:57.910, Speaker A: Once you have a general computing environment building payment channels, they're called state channels, are much, much simpler to build. It's restricted, but it's amazing in how much it can still do. Ethereum is a general purpose computing environment. Like we said, you program it in solidity. One thing that's really important to remember is that any data you put on the blockchain is really expensive.
00:14:57.990 - 00:14:58.234, Speaker B: Yeah.
00:14:58.272 - 00:15:12.862, Speaker A: You have to pay to put money on the blockchain. And it's kind of remarkable. If you're going to build a blockchain application on Ethereum, you will not believe how much time you're going to spend removing every single byte from the blockchain from your app.
00:15:12.916 - 00:15:13.182, Speaker B: Yeah.
00:15:13.236 - 00:15:27.934, Speaker A: So you're going to do all these tricks, crazy programming tricks, just to reduce the amount of storage on the blockchain. Today, when you want to write data to the blockchain, you have to pay when you write, and that's it. In the future, you're actually going to have to pay continuously for storing data on the blockchain.
00:15:27.982 - 00:15:28.146, Speaker B: Yeah.
00:15:28.168 - 00:16:06.090, Speaker A: So your goal would be to either expire data as quickly as possible or avoid writing it even in the first place. Again, I guarantee you, as you're going to be developing, you're going to be spending most of your time in trying to remove data and not writing it to the chain itself. So far, so good. Okay, excellent. All right, so, yeah, so there are lots of execution environments. One thing that I wanted to point out is Ethereum uses the EVM as a virtual machine, which is kind of an interesting choice for a virtual machine. You can see that many of the modern blockchains actually are moving to Webassembly.
00:16:06.090 - 00:16:20.594, Speaker A: So it's a particular bytecode format. And the beauty of Webassembly is you get to benefit from all the software development tools that were developed for the web where you can write your application in your favorite language, compile it to Webassembly, and it will just work on the blockchain.
00:16:20.642 - 00:16:20.854, Speaker B: Yeah.
00:16:20.892 - 00:16:41.066, Speaker A: So kind of modern blockchains are going to have a much richer development environment to work with. Just keep that in mind. Okay, good. Right. So the application layer is kind of the most exciting part. As I said, there are lots and lots of applications available already today. It's actually really fun to write these applications, I have to tell you.
00:16:41.066 - 00:16:51.870, Speaker A: It's really, really fun. The one thing you have to be careful with is if you make a mistake, if you make a bug in your application, you can easily end up locking up $50 million that no one can get a hold of.
00:16:51.940 - 00:16:52.222, Speaker B: Yeah.
00:16:52.276 - 00:17:28.314, Speaker A: So mistakes here are really, really costly. So the programming language you choose is kind of important. There's a story I like to tell about solidity. Solidity is a wonderful first example of a blockchain programming language. But I can tell you every year in our final exam, we post an example contract where we deliberately put five bugs in the program and we ask the students to find the bugs. That's our final exam question. And I would like to say that I know how to program in solidly, but nevertheless, every year the students find ten bugs in the code.
00:17:28.432 - 00:17:28.954, Speaker B: Yeah.
00:17:29.072 - 00:17:54.642, Speaker A: And so that's just an example of. An example of what it takes to write secure, secure code on these blockchains. So interestingly, more modern languages like move and motoko, they're kind of trying to address that. So move is specifically designed to be easy to verify. So there's a lot of work that goes into building automated verification tools. So hopefully this problem will be solved in the future. Okay, good.
00:17:54.642 - 00:18:36.082, Speaker A: So I think maybe, I just wanted to mention the last thing is effectively the layer four application, the user facing services, what they do is, again, we have our consensus layer here, our blockchain computer, and then we have our apps running. This is running on the blockchain. But it's important to remember that really what the users talk, the users don't talk to the blockchain. What the users talk to are application servers that run in the cloud. So the web servers actually run here in the cloud and they just get their data from the blockchain. So the blockchain is in some sense the ground truth, but really everything is replicated into databases that live in the cloud. And end users just see that.
00:18:36.136 - 00:18:36.306, Speaker B: Yeah.
00:18:36.328 - 00:19:04.010, Speaker A: So again, if you go to handshake and you try to reserve to buy a domain name, it first gets recorded here and then gets pushed onto the blockchain. Okay, good. So you probably all know there's a thriving ecosystem of applications running on the blockchain. Every time I put up this picture, I'm just kind of amazed at how active the space is. And this is, by the way, only the decentralized finance world. It's not even their applications beyond defi. This is just defi.
00:19:04.010 - 00:19:32.946, Speaker A: So I think Chris already pointed. Like, one of my favorite defi applications is makerdao. It's just an amazing idea, like how to build a stable currency using collateral that lives on the blockchain. It's just like when you read it, you just become happy because it's such a beautiful idea that it's a lot of fun to kind of study and analyze how it works. So, yeah, I encourage you to read about Makerdao. It's just a really beautiful idea. And it so far seems to be working quite well.
00:19:32.946 - 00:19:58.714, Speaker A: So that's makerdao effectively. What they did is they took the US Fed policy, the US Federal Reserve, and just implemented it in an algorithm as a short description. Okay. And then you can talk about lending platforms like compound. Those are very interesting, too. And these applications, literally, you can go to the blockchain and just read the code. I stopped actually reading white papers that describe how the code works.
00:19:58.714 - 00:20:27.794, Speaker A: I just literally download the code, read it and see exactly how compound works. It's not that hard, it's not that much code, and you can just understand it best by just looking at the code. So again, I encourage you, try not to read the white papers or maybe read them just as background, but then just go to etherscan and download the code and just read it. It's very clear. Usually it's very nicely commented and you can see exactly how things operate. Very instructive. Okay, so we're going to talk about applications actually, next week.
00:20:27.794 - 00:20:46.838, Speaker A: We're going to talk about lots of applications in the coming weeks even. And so I'm not going to say more about that here. What I wanted to do now is do a digression. How are we doing on time? Okay, fantastic. All right, keep going. And I wanted to switch gears and talk about cryptographic primitives. So I'm a cryptographer.
00:20:46.838 - 00:20:53.642, Speaker A: So for me, I have to say these blockchains are like a godsend because crypto is like so much fun now.
00:20:53.696 - 00:20:53.914, Speaker B: Right?
00:20:53.952 - 00:21:25.762, Speaker A: Everything that we do gets implemented and deployed. And there's some things that we've deployed that are now protecting billions of dollars, which is exciting and frightening at the same time. So what I wanted to do is tell you a little bit about cryptographic primitives that are useful on the blockchain. So I hope these are things that you will put to use in your own projects. And so again, this is a pretty high level description. I'm really happy to go to as much depth as you'd like on these things, but I'm going to try to get through this in like 10 minutes. So these are big topics.
00:21:25.762 - 00:21:33.814, Speaker A: Each one of these circles, literally is a huge topic, but we're going to do it quickly. And if you'd like to talk more, I'm happy to stick around and talk more about that afterwards.
00:21:33.942 - 00:21:34.234, Speaker B: Yeah.
00:21:34.272 - 00:22:04.434, Speaker A: So I wanted to tell you a little bit about digital signatures and particularly aggregating digital signatures. Then we'll talk about Merkel commitments, and finally we'll use those two things to build what are called succinct, zero knowledge proof systems. They're also known as snarks. It's a great name. Okay, so let's start, let's start with digital signatures. So I imagine actually many of you already familiar with digital signatures, so let me go through this relatively quickly. So in the physical world, you know what a signature is, you just sign your check.
00:22:04.434 - 00:22:16.438, Speaker A: But you think about that for a minute and you realize, wait a minute, this can't possibly work in the digital world, because in the digital world, I could just copy the bits, I can just copy the bits into another check, and that would not be cool.
00:22:16.524 - 00:22:16.774, Speaker B: Yeah.
00:22:16.812 - 00:22:43.610, Speaker A: So clearly what we do in the physical world simply cannot work in a digital world. So we have to build signatures slightly differently. And so this actually was, people were stuck when these ideas were developed back in the, wasn't clear how to sign in the digital world because of this problem. And so the idea, it's actually due to Michael Rabin, is to basically make the signature itself be a function of the data being signed.
00:22:43.690 - 00:22:43.934, Speaker B: Yeah.
00:22:43.972 - 00:23:16.234, Speaker A: So it's not like the physical world signature where here in the digital world, you actually look at what you're signing. That becomes an input to the signing algorithm along with the secret signing key. And then these two things together, the signing key and the data being signed, they're the things that produce the signature. So now the signature depends on the data. Then given the signature, you can actually feed it into a verification algorithm. The verification algorithm takes what's called a public key. So that's a matching pair to the private key.
00:23:16.234 - 00:23:36.670, Speaker A: So the signature, the data and the public key go into the verification algorithm. And the verification algorithm says yes, valid or invalid. Okay, so that's how digital signature works. Digital signatures work. The thing that's important to understand is if you don't have the signing key, or if somebody doesn't have your signing key, they cannot sign on your behalf, period.
00:23:36.830 - 00:23:37.250, Speaker B: Yeah.
00:23:37.320 - 00:24:08.806, Speaker A: It doesn't matter how many signatures they see, if they don't have your signing key, they simply cannot generate signatures on your behalf. So that's what a digital signature is. Signatures are used everywhere on the blockchain. So they're used to authorized transactions. They're used in governance votes. I guess there was a Makerdao governance votes, right? So the way that worked is all the folks participating in the governance used their signing key to sign the proposal that was being voted on. And it's also used in consensus protocol and particularly in proof of stake consensus protocols.
00:24:08.806 - 00:24:47.030, Speaker A: All the verifiers basically sign and if enough signed, then the block becomes real. So signatures are kind of used everywhere. You can see that when these transactions get their transactions are signed, they get posted on the blockchain and then all the verifiers have to verify all the signatures. If you think about it for a minute, you realize that's a little crazy, right? If one miner verifies a signature, we know that the miner says the signatures are valid. Why is it that all the other miners now have to repeat the work and verify the signatures for themselves? But this is how it works today. Keep that in mind because we're going to come back to that in a minute. Okay, so that's a digital signature.
00:24:47.030 - 00:25:31.762, Speaker A: I wanted to also mention this space saving idea. So there's something called signature aggregation where you can take for certain signatures, you can take a whole bunch of messages signed by different people and effectively compress all the signatures into a single signature. This is called an aggregate signature. That's a purely compression mechanism. You take a whole bunch of signatures, compress them into one. And now when you want to verify, you need to know all their public keys, you need to know all the transaction data, and you only need this one aggregate signature, and that allows you to verify that all the messages were properly signed. Okay, so the point of this is that you don't need to store all the signatures on the blockchain, you can just compress all them and just store the aggregate.
00:25:31.762 - 00:25:59.040, Speaker A: So again, it's a very useful compression mechanism. So I just wanted to mention there's a blockchain called chia that you can see when you post transactions on Chia. What the miner does is he takes everybody's individual signatures, compresses them into the aggregate, and only stores the data in a single aggregate. Okay, so this is a really nice compression mechanism to reduce the amount of data stored on the blockchain. And remember, our goal is to reduce the amount of data as much as possible.
00:25:59.410 - 00:26:00.174, Speaker B: Okay, good.
00:26:00.212 - 00:26:17.862, Speaker A: So keep that in mind. There's this nice compression trick that everybody can take advantage of. All right, next thing I want to talk about is Merkel commitments. Actually, I am really curious how many of you know how Merkel commitments. Ah, okay, not too. Oh, okay. So I'll explain it at a high level.
00:26:17.862 - 00:26:40.902, Speaker A: So let me explain what a cryptographic commitment is. So what's a cryptographic commitment? So a cryptographic commitment basically functions like an envelope. All right, so imagine we wanted to run a sealed bid auction. How does a sealed Bid auction work in the real world, right? Everybody takes their bids, sticks them into an envelope, seals the envelope, sends the envelope to the auctioneer. The auctioneer collects all the envelopes.
00:26:40.966 - 00:26:41.194, Speaker B: Right.
00:26:41.232 - 00:26:51.646, Speaker A: Once they're all at the auctioneer's hands, he opens up all the envelopes and then decides who won the auction. Yes, well, a cryptographic commitment does exactly that.
00:26:51.668 - 00:26:51.806, Speaker B: Right?
00:26:51.828 - 00:27:01.154, Speaker A: So you can put data inside of an envelope, send it to the auctioneer, and then later on, the auctioneer can open the commitment and recover the data.
00:27:01.272 - 00:27:01.602, Speaker B: Right?
00:27:01.656 - 00:27:40.030, Speaker A: That's basically what a cryptographic commitment allows you to do. Very, very important, primitive in the blockchain world. So let's define it more precisely. Basically, there's an algorithm that will take some data and will produce a commitment string. That's the thing that's going to be sent to the auctioneer, and then there's some opening string that's going to be kept secret. Then there's a verification algorithm that's going to be run by the auction house that allows you to basically say, oh, the data that was in the commitment is this data over here, and the opening string is the proof that the data is correct. Okay, so I can commit, and then later on I can open, but I can only open the commitment in one particular way.
00:27:40.030 - 00:28:08.070, Speaker A: So the properties of a commitment scheme are exactly that. It says a binding property that says I cannot open the commitment in two different ways. Once I've committed to something, I'm bound to that data. And then the hiding property says that if I give you the commitment string, you have no idea what data I committed to. Yeah, it's in the envelope, and you cannot see it. The reason this is such an important primitive is what I can do is I can commit to data on the blockchain. I can literally put data on the blockchain.
00:28:08.070 - 00:28:17.366, Speaker A: I am bound to that data. I can no longer change what it is because of the binding property, but because the commitment is hiding, nobody knows what data I posted onto the blockchain.
00:28:17.478 - 00:28:17.898, Speaker B: Yeah.
00:28:17.984 - 00:28:53.810, Speaker A: So that's why this is such a useful mechanism in this context. Okay, so there's a very famous commitment scheme. Well, actually, there's a Merkel tree commitment, which, as I described it, it's not hiding, but it could easily be made hiding, where what you can do is you can take a whole bunch of values and produce a very short commitment to those values. When I say very short, I mean like 32 bytes. Just 32 bytes. There could be a million elements in the leaves here. So this could be gigabytes of data, and yet you're compressing it to 32 bytes in a way that you're committed to all of these values.
00:28:53.810 - 00:29:09.114, Speaker A: And more importantly, later on, if I want to convince you that element number four is x four, I can produce a very, very short proof. It's like a kilobyte proof that will convince you that x four is really what I committed to.
00:29:09.232 - 00:29:09.466, Speaker B: Yeah.
00:29:09.488 - 00:29:29.154, Speaker A: So I have a huge set of data. I commit to this huge set of data. But now I can prove to you, I can open individual cells and prove to you very efficiently that the cells are correctly, that what I showed you is the correct value in the cell. So this is called a Merkel tree. Very important. Again, very important idea. This is basically deployed in all the blockchains out there.
00:29:29.272 - 00:29:29.602, Speaker B: Yeah.
00:29:29.656 - 00:29:49.426, Speaker A: So I wanted you to see how it works. The one way to use it, for example, is to convince someone quickly that payment was made. So imagine we have a thousand transactions in one particular block. So here's one block. We have a thousand transactions. We actually don't write all the transactions to the blockchain. Instead, we're just going to write a Merkel commitment to the blockchain.
00:29:49.426 - 00:30:10.010, Speaker A: So again, we minimize the amount of data on the blockchain. So we just write this short hash to the blockchain. But now if Alice wants to prove to Bob that she really paid him to ETH, it's really easy for her to do, because she can produce this very short proof that says, yes, this transaction is part of what was committed on the blockchain.
00:30:10.090 - 00:30:10.574, Speaker B: Yeah.
00:30:10.692 - 00:30:29.078, Speaker A: So again, Alice can produce a very short proof to Bob. Bob can check the proof. Bob has all the block headers. He can check the proof and be convinced that Alice really paid him. But you see, again, we're moving data off of the chain, which is kind of what all this game is about. Reduce the amount of data on the chain itself. Okay, good.
00:30:29.078 - 00:30:58.394, Speaker A: So that's one application. Yeah. Easily giving proofs of payments. The other application I wanted to mention is that you can actually keep a whole database off of the chain using this trick. So imagine we have a bank, and the bank actually maintains everybody's balances, right? So Alice has ten coins, Bob has five coins, and so on and so forth. We can commit to this entire database using a tiny commitment string, 32 bytes. That's the only thing that's going to live on the blockchain.
00:30:58.394 - 00:31:11.394, Speaker A: But now if Alice wants to prove that her balance is ten, it's actually quite easy for her to give this proof that just by looking at this hash value, anyone can be convinced that she really has ten tokens in her account.
00:31:11.512 - 00:31:11.938, Speaker B: Yeah.
00:31:12.024 - 00:31:33.590, Speaker A: So again, it's a way to keep an entire database off the chain. The first thing that would come to mind when you try to design a system like this is to write the entire database onto the blockchain. What I'm telling you is you should never ever do that. Yeah, that's kind of not a good design. It's better to keep data off the blockchain. There are some technique. Lots of technical issues come up in making this work.
00:31:33.590 - 00:31:53.694, Speaker A: There's something called a data availability problem that you have to get around. So there's lots of technical issues in making this work. But this is a wonderful way to keep data off of a blockchain. Okay. Now if a transaction actually happens, say Alice paid Bob two tokens, you can see Alice's balance went down and Bob's balance went up. Here, I can show you again.
00:31:53.812 - 00:31:54.046, Speaker B: Yeah.
00:31:54.068 - 00:32:05.326, Speaker A: You can see Alice's balance went up, went down, Bob's went up. And then all we do now we have to update the database. So we just commit again on the next block. We commit to the updated version of the database.
00:32:05.358 - 00:32:05.554, Speaker B: Yeah.
00:32:05.592 - 00:32:30.540, Speaker A: So every time there's a change, we just commit to a new version. And still everybody can prove that their balances are what they're supposed to do. Supposed to be. And the only thing that the program on the blockchain needs to check is that this transition is a valid transition. All right, so that's how Merkel commitments are used. Again, we're building towards a tool that I'm going to mention in a minute. So this is an important component of that.
00:32:31.630 - 00:32:32.138, Speaker B: Great.
00:32:32.224 - 00:33:13.046, Speaker A: So the last primitive I want to talk about is what's called a zero knowledge proof system. So these are kind of things that zero knowledge proof systems are the sort of things that you wouldn't believe are possible if I just told you what they are, you would go, no, surely you can't do that. So maybe the easiest way for me to explain what a zero knowledge proof system is, I'll explain it. Like, I had to give a talk to kindergartners one time about crypto, and I decided, yeah, well, I decided to explain zero knowledge proof systems to them. So the question is how to do that. And the example I came up with was, where's Waldo? Do you guys know the where's Waldo puzzle?
00:33:13.078 - 00:33:13.226, Speaker B: Right?
00:33:13.248 - 00:33:23.446, Speaker A: I give you a picture with a thousand faces. The challenge is find Waldo. So I want to prove to you in zero knowledge that I know where Waldo is in this image.
00:33:23.478 - 00:33:23.674, Speaker B: Yeah.
00:33:23.712 - 00:33:32.334, Speaker A: So I walk into a room, you show me the where's Waldo? Puzzle, and I can see Waldo. And I want to prove to you in zero knowledge that I know where Waldo is.
00:33:32.452 - 00:33:32.926, Speaker B: Yeah.
00:33:33.028 - 00:33:43.886, Speaker A: So that's a puzzle for you. You guys can think about how you would do that, but maybe I'll just tell you. Yeah, so here's one simple protocol for doing this. It requires scissors.
00:33:43.998 - 00:33:44.370, Speaker B: Yeah.
00:33:44.440 - 00:34:27.406, Speaker A: So what I do is you give me the picture with a thousand faces and I find Waldo. And I want to prove in zero knowledge that I know where Waldo is. Can somebody see? How would you use scissors to do it? You can take a blank sheet, paper, cut the hole around the, ooh. But then they could separate the two pages, and then they'll know where Waldo is. That wouldn't be zero knowledge, but you're on the right track. What you would do is you would take the scissors and simply cut Waldo out of the picture, out of the challenge picture with a thousand faces. And then actually you would turn around, right? And then cut it kind of behind your back, and then you would rip the remaining picture so that nothing is left of the, it's shredded.
00:34:27.406 - 00:34:49.766, Speaker A: Nothing is left of the original picture. And then you can give the challenger, you can give them the picture of Waldo, and unfortunately, they have to search your pockets before you do this to make sure you didn't walk in with a picture of Waldo. But if you're okay with that, then that's kind of a zero knowledge proof that you know where Waldo is, and he learns nothing. He or she learned nothing at all about where Waldo is.
00:34:49.868 - 00:34:50.182, Speaker B: Okay?
00:34:50.236 - 00:35:13.642, Speaker A: So the kindergartens, by the way, asked me, well, why do you want to do that in the first place. So that didn't work very well. But anyhow, it gives you an example of what, a zero knowledge. Yeah, that didn't work at all, by the way. They were not impressed. But the point is I can prove that. The amazing theorem says that I can prove anything that can be proved, can also be proved in zero knowledge.
00:35:13.706 - 00:35:13.886, Speaker B: Yeah.
00:35:13.908 - 00:35:20.098, Speaker A: So if a certain fact has a short proof, I can convince you of that fact without telling you anything about what the proof is.
00:35:20.184 - 00:35:20.386, Speaker B: Yeah.
00:35:20.408 - 00:35:44.902, Speaker A: And let me give you an example of that. So here we have a prover and a verifier, right? The prover wants to convince the verifier of a certain fact. So let's imagine what the prover is trying to prove is that he has a signature on a particular statement. So maybe there's a transaction in question. This is called the statement that I'm trying to prove I have a signature on this transaction. And then there's a secret witness, which is the actual signature.
00:35:45.046 - 00:35:45.642, Speaker B: Yeah.
00:35:45.776 - 00:36:18.034, Speaker A: What I'd like to do is prove to the verifier that I know a signature on this transaction in zero knowledge, which means that I leak nothing about the actual signature. Okay, so the statement is. Yes, the verifier says approver has a signature on a transaction. The prover will send a proof to the verifier. The verifier will either accept or reject the proof. If the verifier accepts the proof, he is actually convinced that the prover has a signature, but he learns nothing at all about what the signature is. Yeah, it's an amazing fact that this can be done, but it actually can be done.
00:36:18.034 - 00:36:55.490, Speaker A: This is something that was proved back in the 1980s, but in a very theoretical fashion, in that normally this would be quite inefficient. I have to tell you, because of the blockchain world, in the last five to six years there's been just mind boggling progress in making this work. And now these things are actually implemented, deployed. There's a whole software tool chain that allows you to build these zero knowledge proof systems. There's a system called Circom. This is what we use in our courses, where you can actually program these statements and then build these zero knowledge proof systems automatically. So it's really become a very applied and very practical field.
00:36:55.490 - 00:37:13.622, Speaker A: So it's amazing to see this happen. Okay, so what's a statement? As I said, a statement is just basically a program that's applied to two inputs, the statement and the witness. And you can prove that given a statement, you have a witness that makes the program output one. Yeah, that's kind of what the zero knowledge proof system does.
00:37:13.756 - 00:37:14.246, Speaker B: Great.
00:37:14.348 - 00:37:24.546, Speaker A: So what do we use? Oh, yeah, actually, first of all, so what are the properties of these proof systems, just so you understand what they provide. So first of all, if the statement is true, the proof exists.
00:37:24.658 - 00:37:24.934, Speaker B: Yeah.
00:37:24.972 - 00:37:36.874, Speaker A: There's a way to convince the verifier. That's completeness. The proof has to be short. Okay. So it's very important to proof be short because these proofs are going to go on the blockchain. So we want them to be short because we always try to save bytes on the blockchain.
00:37:36.922 - 00:37:37.134, Speaker B: Okay.
00:37:37.172 - 00:37:53.294, Speaker A: So they have to be short. They have to be fast to verify. Why do they have to be fast to verify? Because all the miners have to verify them. So they have to be really cheap to verify, and then they also have to be relatively easy for the prover to generate. So if you have all these properties, this is what's called a snark.
00:37:53.422 - 00:37:53.714, Speaker B: Yeah.
00:37:53.752 - 00:37:57.626, Speaker A: So snark stands for succinct, non interactive arguments of knowledge.
00:37:57.758 - 00:37:59.190, Speaker B: Yeah, forget that.
00:37:59.260 - 00:38:20.886, Speaker A: Just remember it's called a snark. It's a really cool name. Now, it has to have some security properties in particular, you shouldn't be able to prove a statement that's false. That's called soundness. And then optionally, you could also have a zero knowledge property, which means that you learn nothing about the witness if you have the zero knowledge property. This is called a ZK snark. So there are two types.
00:38:20.886 - 00:38:41.570, Speaker A: There's a snark and there's a ZK snark. And they have different applications. So let me show you one application for a snark, and let me show you one application for a ZK snark, and then I'll stop. Does that work? Okay, let's do it. All right, so the application for a snark is actually kind of a big deal now. It's called roll up. So roll up is now taken.
00:38:41.570 - 00:38:43.202, Speaker A: This is an idea that's taken over the world.
00:38:43.256 - 00:38:43.474, Speaker B: Yeah.
00:38:43.512 - 00:39:09.354, Speaker A: So these are called levels. It's now even called a level two blockchain. And so let me explain the idea behind roll up. So I already complained to you before that the way blockchains work today is somebody posts a transaction, one miner verifies it, posts it on a blockchain, but then all the other miners have to verify it as well. It's a lot of wasted work for all the other miners. You see, everybody's verifying the transaction. So roll up says, let's get rid of that.
00:39:09.354 - 00:39:38.414, Speaker A: Let's make things way more efficient. And so we introduce a central server. It's called a roll up server, but of course anyone can run a roll up server. So it's centralized, but it could be arbitrarily replicated. And then instead of sending the transactions to the miners, all the users are going to send the transactions to the roll up server. What the roll up server is going to do is he's going to verify that these transactions are valid. So he's going to verify all the signatures, verify all the account balances.
00:39:38.414 - 00:39:59.830, Speaker A: Everything is going to be, all the checks are going to be done over in the roll up server. And then what the roll up server is going to do is he's going to generate a snark, proof that all the transactions are valid. Okay, so this proof, PI. Yeah, PI stands for proof. Is a. Is fast to generate, it's convincing and it's super fast to verify.
00:39:59.990 - 00:40:00.266, Speaker B: Yeah.
00:40:00.288 - 00:40:07.946, Speaker A: So you can roll up 1000 transactions into a single proof. And verifying that single proof takes like five milliseconds.
00:40:08.058 - 00:40:08.430, Speaker B: Yeah.
00:40:08.500 - 00:40:39.458, Speaker A: So all the miners have to do now is just verify proofs rather than verify transactions. So this guy does all the work and everybody else benefits from it. Yeah, that's the idea of roll up. This is an amazing way to scale a blockchain because here you can actually have like 1000 transactions, possibly even 10,000 transactions rolled up into a single message onto the blockchain. And by the way, it's called roll up because you also send a summary of the transactions onto the blockchain. So that gets written. The summary gets written to the blockchain.
00:40:39.458 - 00:41:09.154, Speaker A: So if somebody wants to, they can start at the beginning of time and kind of go through all the roll up transactions and rebuild for themselves the current state of the world. Yeah, this is kind of important. This is a primary characteristic of roll up, that the actual transaction data gets written to the blockchain. Just nobody needs to verify this data because the proof proves that it's legitimate. Okay, so that's roll up. Beautiful idea for a snark. You realize we didn't need the zero knowledge property here.
00:41:09.154 - 00:41:36.006, Speaker A: All we were doing is that all we were using is the property that these proofs are efficient to verify. There was no need for zero knowledge. People still do zero knowledge, by the way. It's called a ZK roll up. People still do zero knowledge roll ups just to make sure to provide some privacy so that the miners don't even know what their transactions are. So we can even do provide some level of privacy from the miners, but not privacy from the roll up server. Turns out with a bit more work, you can even provide privacy from the roll up server.
00:41:36.006 - 00:41:50.638, Speaker A: But that's for another day. So that's one application. The other application I wanted to mention is one that right now is a bit of a dream. But this is what we're working towards. Okay. This is still science fiction, but we'll get there. Yeah, we'll get there for sure.
00:41:50.638 - 00:42:03.470, Speaker A: And this is, again, really important to remember, especially in the context of all these central bank digital currencies, it's really, really important to remember that you can have private data on a public blockchain.
00:42:03.550 - 00:42:03.746, Speaker B: Yeah.
00:42:03.768 - 00:42:31.014, Speaker A: Let me explain why this is so important. So today, essentially, all the data that's posted to the blockchain is available in the clear. All these transactions are available in the clear. This basically means that it's not usable for many b, two b applications. For example, if Apple wants to pay Foxconn in a digital currency, everybody could look on the blockchain and just see exactly how much Apple is paying Foxconn, which is not something Apple being Apple, would want public.
00:42:31.152 - 00:42:31.840, Speaker B: Yeah.
00:42:32.210 - 00:43:02.150, Speaker A: What's important to remember is that this is not necessary. You can have private data on a public blockchain. So let me explain what I mean by that. So rather than writing the application code in the clear and the application state in the clear, what we can do is we can write commitments to the application code and commitments to the state onto the blockchain. So we're committed to what the data is, to what the application code is. It's just nobody knows what the application code is. It's inside of a hiding commitment.
00:43:02.150 - 00:43:29.630, Speaker A: Okay. And then when a transaction happens, when we need to move to a new state. So here you can see the transaction is hidden. We only post commitments to the transaction onto the blockchain and we post a commitment to the updated state. What we do is we also update a zero knowledge proof that says that this state transition is valid. State transition is done according to the committed code. Okay, so just again, this is a little bit mind boggling that this is at all possible.
00:43:29.630 - 00:43:47.370, Speaker A: It's kind of an amazing idea that you can have secret code, secret state, and you can have updated secret state, and even though nothing is public, everything is hidden. You can provide a zero knowledge proof that the code was applied correctly to the state and the transition is valid.
00:43:47.470 - 00:43:47.734, Speaker B: Yeah.
00:43:47.772 - 00:44:06.742, Speaker A: So you have this property called public verifiability, where anyone in the world can verify that all the rules are being followed correctly. The code is running correctly even though nobody has any idea what the code does and nobody has any idea what the data is. And yet you can verify that everything was done correctly. It's kind of magical.
00:44:06.806 - 00:44:06.986, Speaker B: Yeah.
00:44:07.008 - 00:44:21.120, Speaker A: That it can be done, but it can be done. I'm telling you it can be done. And I'm happy to actually explain how it's done, but we would have to be here for another three weeks. It's actually really pretty. It's really, really pretty. I would actually be excited to tell you. It's really cool.
00:44:21.120 - 00:44:33.262, Speaker A: Yeah. I don't know. What can I say? It's just tricks with polynomials. Yeah, if you like polynomials. Go look at how this stuff works because it's really, really pretty. How it works. Just tricks with polynomials.
00:44:33.262 - 00:44:44.082, Speaker A: Okay. So then basically all these transactions sort of happen. The state evolves. And every time we have a state evolution, we just provide a $0 proof. Everything is verifiable but the data is completely hidden.
00:44:44.146 - 00:44:44.326, Speaker B: Yeah.
00:44:44.348 - 00:45:13.950, Speaker A: So if anybody tells you we're going to be running a private blockchain because we're worried about privacy, you tell them that's the wrong solution. You should be putting your data on a public blockchain and just use $0 proofs. Yeah, that's much better. It's better for interoperability, it's better for public verifiability and it's just better all around. All right, so that's the whirlwind tour of the crypto primitives I wanted to tell you about. So one thing that I want you to remember kind of drives me nuts. Sometimes I talk to folks who tell me we have some data.
00:45:13.950 - 00:45:16.130, Speaker A: So we're just going to throw it on a blockchain?
00:45:16.950 - 00:45:17.410, Speaker B: Yeah.
00:45:17.480 - 00:45:40.422, Speaker A: That's not what a blockchain is for. Yes, it's not a database. Just remember, a blockchain is not a database. Basically, the question is always to ask. Whenever you come up with an application, you think you have a really cool application for a blockchain. The first question you need to ask is, why can't I just use a centralized system? Centralized systems are a million times easier to build than decentralized ones. They're a million times faster if you can centralize.
00:45:40.422 - 00:45:55.134, Speaker A: Centralize? Yeah, it's just when you cannot centralize, that's when you decentralize. So basically if there's no single party that's trusted by everyone, that's where you have to decentralize. But of course you get complexity and speed issues as a result.
00:45:55.252 - 00:45:55.486, Speaker B: Yeah.
00:45:55.508 - 00:46:10.610, Speaker A: So that's one point to remember. It's not that everyone who has data needs to put that data on a blockchain. That's not quite what it's for. The second thought I want to leave you with is, you guys remember in the early days of social networking, there were like a bazillion social networks out there.
00:46:10.680 - 00:46:11.058, Speaker B: Yeah.
00:46:11.144 - 00:46:38.646, Speaker A: And what happened at the end. Yeah, what happened at the end was that we were left with a relatively small number. Right now we're kind of at the age where people are experimenting with lots and lots and lots of blockchain architectures. So right now we're kind of at the age where there are lots and lots and lots of architectures out there. And. Well, maybe there will still be many blockchains out there in many years, but it's very likely they will converge onto a small number of architectures.
00:46:38.758 - 00:46:39.226, Speaker B: Yeah.
00:46:39.328 - 00:47:10.470, Speaker A: And so which ones those are, I wish I could tell you. It's too early to tell, but, yeah, this is why it's so much fun. And I encourage you to kind of play with these ideas and who knows? Maybe your design will be the one that gets chosen and that's what the world will converge to. Okay, fantastic. So I think I'll stop here. I'm really looking forward to seeing everything that you build and. Yeah, thank you very much for the roll ups.
00:47:10.470 - 00:47:45.300, Speaker A: The server that's hosting the actual. The code and the algorithms for it, is that a centralized server? So the server that's actually building the proofs, that's a centralized server, but it can be replicated. So in other words, the fear is that you might have censorship, right? I mean, the server can't cheat you because it's providing a proof that everything that it does is valid and correct. What the server might do is they might refuse a transaction from you. Yeah, censorship. So the way around that is. Well, there could be multiple servers, multiple entities that provide roll up services and you could choose anyone you want.
00:47:45.300 - 00:47:52.014, Speaker A: They don't need to talk to one another. They come to consensus through the layer one blockchain.
00:47:52.062 - 00:47:52.226, Speaker B: Right.
00:47:52.248 - 00:48:40.926, Speaker A: So they push these hashes to the layer one and then the layer one basically enforces consensus. Let's say if two of them try to post transactions that are conflicting, the layer one basically will resolve. We'll choose one of them and we'll go with that. And the other one will get rejected because the zero knowledge proof will no longer verify. Yeah, it's kind of a pretty cool design, building applications that use snarks. Could you recommend libraries that abstract away the underlying complexity? Yeah, there are many high level primitives look, so, like I said, we use circum because it's the easiest one to come up to speed with so we don't have to spend a lot of time learning them. But there's okrates, there's snarky, there's JSnarc.
00:48:40.926 - 00:48:57.350, Speaker A: Now there's zinc, which is kind of a cool. Zinc is one that you can write in rust. You literally write your program in rust, and zinc will compile that into a. Yeah, circum is the easiest one to learn, but there are lots and lots of options to choose from. Yeah, thank.
00:48:57.420 - 00:48:58.360, Speaker B: Yeah, yeah.
00:48:59.770 - 00:49:06.726, Speaker A: When you got to the slide about private data on a public chain, you said, this is still a why. Why is that still a dream, not a reality?
00:49:06.758 - 00:49:08.330, Speaker B: Like what needs to be built? Yeah. Good.
00:49:08.400 - 00:49:18.782, Speaker A: That's a really good question. So actually, we're almost there. If all you want to do are just simple funds, asset transfer transactions, that we can totally do today.
00:49:18.836 - 00:49:19.054, Speaker B: Yeah.
00:49:19.092 - 00:50:00.410, Speaker A: In fact, that exists today already. If you want to do more complicated transactions, like you want to run an entire EVM program inside of a snark, that's going to take a while. So generating the proof, the proofs will just take a while. The good thing, though, is these proof systems are getting better and better and better in the sense that the bottleneck, the bottleneck right now is the time to generate the zero knowledge proof. That overhead keeps shrinking. Yeah, we have better and better systems and, yeah, basically the time to generate the proof keeps shrinking because the algorithms get better. And eventually the hope is that we'll get to a point where we can run arbitrarily complex programs inside of a snark.
00:50:00.410 - 00:50:30.886, Speaker A: We're not there yet today, but then at the same time, most transactions are just asset transfers and those we can handle already using the existing technology. So we'll get there. I'm confident we'll get there. So that's the goal. This is, by the way, why it's so much fun, right? I mean, this is kind of, I'm a cryptographer. For me, it's like a red cloth dangling in front of my face saying, build us these snarks. And it's like, I can't believe you guys are asking me to do this.
00:50:30.886 - 00:51:25.494, Speaker A: This is like my dream thing that I like to think about. So this is why it's so much fun. You emphasize in your talk importance of not putting data on the blockchain, how you advise to go around data availability problems, like currently, for instance, that you put data not in the state, but in reference as call data call data. Yeah. Are there any more sophisticated ways of doing this? Yeah, so the current roll up solutions, they just put all the data in call data, so at least it's somewhat compressed. But there are other proposals out there. So, for example, one idea is you have a committee that replicates the data, and then you declare that the data is available if all the committee members sign.
00:51:25.494 - 00:51:55.300, Speaker A: So you're kind of relying on 100 parties basically to provide data availability for you. So instead of pushing everything to the blockchain, you just have to push these hundred signatures to the blockchain. And then we say data availability has been done. And if you need the data, presumably you go to any one of those hundreds or a subset of those hundreds, and you can recover the data. So that's a pretty promising, fairly promising technique. But today, basically call data. Pushing call data to the blockchain is basically what you have to do with roll up.
00:51:55.300 - 00:52:22.470, Speaker A: You're right, this is expensive. And over time, my guess is we're going to move to these committees. Yeah, it's a good question. Yeah. So this actually might be related to that question. Recently on Ethereum, someone had written an obituary for the chinese scientist who had, I guess, raised the alarms for coronavirus. And in that case, data is being written onto the chain.
00:52:22.470 - 00:53:09.746, Speaker A: And maybe the goal there was to avoid censorship by the chinese government. Given that, and your comment about keeping data off of the chain question would be maybe, would censorship be a reason to actually to use a blockchain as a database, or is there a better solution? That's a really good question. So could you use the chain as a way to just prevent it from being removed? Yeah, absolutely. Actually, in fact, there are a number of projects that do exactly that. They use a blockchain for replication. In fact, that's kind of what filecoin is doing, so the data can never be removed. So I would say those are chains that are specifically designed for data storage.
00:53:09.746 - 00:53:51.520, Speaker A: So there, the cost of storing data on the chain is not as expensive, and that is a wonderful application for that. So you put the data there, like on Filecoin or any one of these other systems, and because of replication, it's very difficult to get to make the data disappear. So, yeah, that's a perfect application. But those are specific blockchains that are designed for that purpose. So that's a really good point. Thanks. I've met a lot of vcs that talk about the deals that they've passed on that became billion dollar companies and bitcoiners that talk about the keys that they forgot on that old laptop and destroyed.
00:53:51.520 - 00:54:32.430, Speaker A: I find I worry a lot about key management for my users. Is there a way to do it without doing custody? Oh, boy, that's a difficult one. Right? What can I say? So there are some proposals, well, look, there are many proposals to try to address exactly that. So there are some proposals to try to address this using hardware enclaves. So you do custody to a remote party, but the custody lives in a hardware enclave, so they can't abuse it unless you authorize it. Right. So there are ideas floating around.
00:54:32.430 - 00:55:09.080, Speaker A: But what can I say? You're right. I mean, keeping keys yourself, even though it gives you the comfort that no one can take the assets away, there's also a risk that you might lose your keys. Obviously, as you know, there are combinations of the two, right, where you do a two out of three secret sharing, where you keep one share, and there are two servers that keep the other shares. So even if you lose your data, maybe you can use those two servers to recover the assets nevertheless. So there are solutions. So I would call that partial custody. Right? So there are lots of people exploring different ways to do partial custody.
00:55:09.080 - 00:55:40.156, Speaker A: Yeah. And that's quite popular. Of course, full custody is kind of popular, very popular as well. Then I have to say the nice thing about this world, the world of these assets, digital assets, is that the user has a choice, right. Today, with the financial world today, you have no choice. Right. If you think about your car ownership slip, your housing, house ownership slip, all that kind of lives in custody based databases, you have no choice.
00:55:40.156 - 00:56:10.856, Speaker A: That's basically how the world runs. The nice thing about this is you can choose, right? If you are worried about custody and you want to keep the data for yourself, you can just keep the keys yourself. There's risks to that. But if that's what you want, you can do that. If you want to have a custody solution, you can do that too. If you want partial custody, you can do that too. So in some sense, it's kind of nice that we can service more of people's needs and give them whichever level of comfort they want.
00:56:10.856 - 00:56:36.140, Speaker A: So I think that's actually a pretty powerful capability that's not available today. Okay, so thanks, Dan. Yeah, thank you very much. It's.
