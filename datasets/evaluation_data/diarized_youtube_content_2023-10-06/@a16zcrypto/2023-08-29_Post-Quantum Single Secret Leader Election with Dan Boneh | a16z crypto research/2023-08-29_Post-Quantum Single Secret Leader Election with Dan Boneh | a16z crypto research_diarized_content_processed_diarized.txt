00:00:10.310 - 00:00:29.770, Speaker A: It's my pleasure to introduce the inviteer today. Ben is a professor of computer science at Stanford University that's in the field of applied cryptography and security. And he probably doesn't need a lot of introductions. He's one of the most prominent academics working in our space finance, intersection and cryptography and blockchains. So welcome, Dan.
00:00:30.110 - 00:00:30.474, Speaker B: Great.
00:00:30.512 - 00:00:46.726, Speaker C: Thank you, Lara. All right, so I guess this is a pleasure to be here. Thank you all for inviting me. I've been spending a couple of days in the lab. This is like an awesome place to visit. I highly recommend anyone who's watching should apply to visit the lab. Really awesome energy going on here.
00:00:46.726 - 00:01:09.238, Speaker C: So wonderful spot. And also this seminar series is fantastic. It's such a wonderful resource that goes on YouTube. I hope everybody's watching the YouTube videos, whether alive or when they go up on YouTube. Okay, so let's get started. So today what I wanted to talk about is this concept, what's called Single Secret Leader election. It goes by the name of Ssel.
00:01:09.238 - 00:01:41.398, Speaker C: It's gotten some attention recently, and so I wanted to talk about some recent results, in particular how to make post quantum secure Ssel. And this is based on joint work with Pratap and Leor Rotem. Oh, and I should say also this is going to appear in Advances in Financial Technology. Aft is an awesome blockchain conference. Everybody should go to Aft and submit their best work to Aft. We need a blockchain focused conference, and Aft is a good candidate for that. Okay, so let's get started.
00:01:41.398 - 00:02:05.562, Speaker C: So what is the problem with Ssel? So let's start with a quick review of where we come from. Right, so we start with proof of work systems or proof of work consensus. And you guys know in proof of work consensus, there are a bunch of miners that generates blocks. They each work to solve a particular puzzle. And when somebody solves the puzzle, they basically post the solution to the puzzle along with a block.
00:02:05.626 - 00:02:05.902, Speaker B: Yeah.
00:02:05.956 - 00:02:35.378, Speaker C: So in some sense, at the time that the block is posted, there's also a proof that the person that's posting the block is the elected leader. And there's no gap between posting the block and electing the leader. Yeah, that's in proof of work systems. And then when we transition to proof of stake systems, what happens? All of a sudden we introduce a gap. So in a proof of stake systems, typically a leader gets selected. So the system says, you are the leader, you are the block. Proposer for this slot.
00:02:35.378 - 00:03:08.434, Speaker C: And then sometimes later, the leader goes ahead and posts their block. So there's a gap between the leader election time and the time that the block is posted. And this introduces a bit of an issue in that what can happen is the block proposal is known in advance. So the point is that now you know who is going to propose a block. So you can go ahead and attack that particular block proposer, for example, you can Dos them, maybe you can bribe them, you can do all sorts of things to prevent them from publishing the block. And as a result, boom, you get a hole. There's no block published in the system.
00:03:08.434 - 00:03:47.306, Speaker C: And so what does the system do? It moves on to the next leader, but the next leader is also known in advance. So now everybody just shifts their dos attack to the next leader and so on and so forth. And so you get a whole bunch of gaps in the chain and as a result you hurt the liveness of the chain. So that's the problem that we'd like to solve. So by the way, even in Ethereum too, the leaders are kind of known in advance. And so this could lead to kind of a sequence of holds if in fact somebody tries to repeatedly attack the elected leaders. So what do we do? So first of all, I guess I wanted to point to this wonderful survey.
00:03:47.306 - 00:04:14.982, Speaker C: It's a blog post by Chris Lara and Joe that kind of goes through different leader election mechanisms. Everybody should read this blog post. Very, very good survey of this area. And so let's kind of look about, look at what are the options? So one thing we can do is, well, we can try to use a consensus protocol that doesn't have a leader. So it's a leaderless consensus protocol. And one example is Red Belly consensus. It's a paper from 2021.
00:04:14.982 - 00:04:44.334, Speaker C: So that's one option. But most protocols that we use do actually have a leader. And so what else can we do? So the other approach, of course, which many of you might be familiar with is what's called a secret leader election. Sometimes this goes by the name of probabilistic leader election or ple probistic leader election. Sometimes this is called the VRF method. So it goes by a lot of names. And the way it works, I guess this is what's used by Algorand, by OROBOROS Paras and so on.
00:04:44.334 - 00:05:21.102, Speaker C: So the way this works is, again, I'm going to give a very high level description, but the way this works is basically every validator has a number K. We'll call it VK. This number k comes from a VRF. But let's not worry about that. Let's just imagine the Validator has a number k. And then when it's time to choose a leader, basically, to keep things simple, we'll say that a random beacon publishes some 256 bit number R and the leader is the validator that has the closest number to R. Or more precisely, the leader is the validator who is close enough to R.
00:05:21.102 - 00:05:26.010, Speaker C: That the difference is the range divided by the number of validators overall.
00:05:26.090 - 00:05:26.382, Speaker B: Yeah.
00:05:26.436 - 00:06:04.390, Speaker C: So in expectation, you'll expect that there's roughly one leader in expectation, there's exactly one leader elected every time. But you see what the problem with this is. The problem, of course, is that the probability that no leader is elected because we have the strict inequality to satisfy. No leader is elected or multiple leaders are elected. This probability is now negligible and as a result, all these systems have to deal with these corner cases where nobody got elected or multiple people got elected. Somehow often there's a runoff election between the elected leaders and so there's kind of more logic that needs to go into place when we use ple. Yeah, probabilistic leader election.
00:06:04.390 - 00:06:37.122, Speaker C: It's a great way to secretly elect a leader because nobody knows who the leader is until they publish their VK. So we do have a secret leader election mechanism, but it's not a single secret leader election because we might be electing multiple leaders or no leaders at all. Yeah, so that's kind of the problem that we set out to solve. So what we would like to use is actually what's called a single secret leader election mechanism, which has all the properties of ple. The leader is secrets, but you are guaranteed that there's only one leader elected every time.
00:06:37.176 - 00:06:37.442, Speaker B: Yeah.
00:06:37.496 - 00:07:08.266, Speaker C: So let's see, the properties we'd like to have is it should be fair. So all the parties are equally likely to be elected. Or if it's a stake based system, maybe it's weighted by their stake. We'd like the system to be unpredictable, which means that the leader remains secret. You have no idea who got elected until the leader decides to reveal themselves. When will they reveal themselves? Most likely they'll reveal themselves when they publish the block, not before. Yeah, but until they choose to reveal themselves, they should remain secret and then it should be unique.
00:07:08.266 - 00:07:15.458, Speaker C: This is the single property. This should be exactly provably. Exactly. One leader gets elected. Not zero, not two, not three. Exactly one.
00:07:15.544 - 00:07:15.890, Speaker B: Yeah.
00:07:15.960 - 00:07:33.026, Speaker C: So those are the three properties we're trying to satisfy. So let's just look at the trivial protocol to do this. So the trivial protocol would be well, if we have a random beacon that just generates randomness for us, well, why don't we just have the random beacon choose one of the N parties?
00:07:33.138 - 00:07:33.558, Speaker B: Yeah.
00:07:33.644 - 00:08:02.254, Speaker C: And we're done. So let's see. So that is guaranteed to be fair because we're choosing one party at random from the N parties. It's guaranteed to be unique because the beacon is choosing exactly one of the N. But of course it's completely predictable because once the beacon is public, you know exactly who the leader is going to be and then you can go and dos them. So the trivial mechanism using a beacon doesn't actually work. Now, surprisingly, actually, building a secure Ssle protocol, this turns out to be a lot harder than we think.
00:08:02.254 - 00:08:13.854, Speaker C: This is actually not an easy primitive to satisfy. I'll show you some constructions in just a minute, but kind of constructions that for example, don't use a random beacon. They end up using fairly heavy cryptographic tools.
00:08:13.902 - 00:08:14.066, Speaker B: Yeah.
00:08:14.088 - 00:08:48.078, Speaker C: So this is not an easy thing to construct. And we're going to go through a couple of the constructions in just a minute. So one thing that's interesting is there's this really nice paper by Azuvian Capaletti. This paper actually looks at a comparison of doing single secret leader election versus probabilistic leader election, where we might have where it's secret, but we might have more than one leader elected. And what they looked at is particularly private attacks against this proof of stake consensus. This is purely a combinatorial paper. Yeah, it's a combinatorial analysis comparing the two.
00:08:48.078 - 00:09:06.034, Speaker C: In particular, if you look at the impact of these privacy attack in the Longest Chain protocol, consensus protocol, and they're worried about what happens when the block producer keeps some blocks to themselves. And surprisingly, I mean, they show that actually Ssle results in faster consensus.
00:09:06.082 - 00:09:06.390, Speaker B: Yeah.
00:09:06.460 - 00:09:20.958, Speaker C: In particular, what that means is the time until you are confident that the block is really there is something like 25% faster with Ssel versus with Ple when the attacker controls a third of the stake.
00:09:20.994 - 00:09:21.098, Speaker B: Yeah.
00:09:21.104 - 00:09:46.618, Speaker C: So this really Ssle, really not only is it simpler logic, you don't have to worry about the case where you have multiple leaders, it actually leads to faster settlement time, which is pretty interesting. This is specifically for longest chain and their analysis is only in synchronous networks. They kind of leave it to other networks. They leave it as an open problem. It's very cute. It's purely combinatorial. This is not an experiment.
00:09:46.618 - 00:10:04.274, Speaker C: It's like a purely combinatorial analysis of what happens. And I guess I wanted to also mention that there's another aspect of secret leader election which we're not going to talk about. You can kind of go all out on leader election where you can say, well, what if I want even more privacy?
00:10:04.322 - 00:10:04.486, Speaker B: Right?
00:10:04.508 - 00:10:48.402, Speaker C: You guys remember in Ssel what happens is when I publish my blog, I reveal my identity, right? And perhaps even in Ssel I reveal how much stake I have. Well, you can ask, well, what happens if I want to keep the leader's identity private? So nobody knows who published the block or I want to keep every validator's stake, I want to keep it private. Like why should the world know how much stake I put into the consensus? So there's actually some work that focuses on full privacy. So I listed some papers here, some variations of OROBOROS and so on, that focus on complete privacy. But these systems, interestingly, so they hide the stake and the identity of the leader. But these systems basically are primarily their Ple based systems.
00:10:48.466 - 00:10:48.694, Speaker B: Yeah.
00:10:48.732 - 00:11:13.310, Speaker C: So they still use VRF like mechanisms. But for example, some of these papers just focus on what's called an anonymous VRF. So you know that the VRF value is correct, but you don't know which VRF it actually came from. And that's how you hide the identity of the leader. So again, they're not focusing on Ssel, which gives us advantages and consensus. These are just they're focusing primarily on privacy and still staying in the Ple realm.
00:11:13.730 - 00:11:14.142, Speaker B: Cool.
00:11:14.196 - 00:11:33.474, Speaker C: Okay, so we're not going to look at this model. We're going to stick with the Ssel model, where the leader remains secrets until they publish their block and then everybody knows that that's who they are. Okay, so because of these advantages in consensus, in fact, if you look at the Ethereum timeline, maybe this is kind of an old picture, actually.
00:11:33.592 - 00:11:34.098, Speaker B: What is it?
00:11:34.104 - 00:12:10.426, Speaker C: The Merge and the Surge and the plurge and whatever, all the cute names that come up there. In fact, single secret leader election is kind of one of the components that they're looking at. This is kind of a research area for the Ethereum Foundation, but hopefully this is something that we'll actually see deployed in a version soon. So that's interesting that it's actually getting some traction in practice as well. Also, when you look at Aztec, aztec put up an RFP recently. So Aztec wants when they launch, they want to have a decentralized sequencer. And so if they have a decentralized sequencer, they have to have a leader election protocol.
00:12:10.426 - 00:12:46.550, Speaker C: And in fact, in this RFP, they specifically say, we want to allow the sequencer, the option of anonymity during the selection of the leader. Yeah, they might even want to do it during block submission. But particularly during the selection of the leader, they want to have leader privacy. So they're also looking at Ssle type protocols. It's kind of interesting that even L two S are interested in Ssel these days. It's quite becoming kind of an important problem in the blockchain space. Okay, so now that we have our background on Ssel, let's look at some Ssle constructions.
00:12:46.550 - 00:13:04.010, Speaker C: Yeah, so this area really kind of got quite a lot of attention and so let's look at a couple of constructions. So I guess this is something that our original paper from. It's by now ancient history. It's like almost 2020. Like long time ago in the world of blockchains.
00:13:04.090 - 00:13:04.720, Speaker B: Yeah.
00:13:05.090 - 00:13:28.370, Speaker C: We basically gave a construction using Threshold fully homophobic encryption. So no beacon. But as I said, if you don't have a beacon, it turns out you need fairly powerful cryptographic tools. There's a construction, I should say, so using Fhe is one thing in the paper. We also give a construction just to show feasibility. We give a construction from IO. You can also give a construction from functional encryption.
00:13:28.370 - 00:13:56.958, Speaker C: So these are pretty heavy cryptographic tools. You need to construct it from scratch. There's also another, by the way, I should say, like the Fhe Fully Homomorphic encryption based system. If you have N parties, you're trying to elect a leader. Among N parties, it turns out the multiplication depth of the circuit is only around log N. Yeah, and it's actually a fairly simple construction to describe. Maybe I won't do it here, but if you're interested in seeing how it works, it'll take me literally two minutes to describe it's.
00:13:56.958 - 00:14:35.594, Speaker C: A very direct and simple construction. The other approach, which is far more practical, is using what we call re randomizable commitments. And that's actually what I'm going to talk about. So I'll talk about exactly about what re randomizable commitments are in just a second. So this is in the original paper, and then the Ethereum Foundation actually went and optimized that this is kind of what they would like to use, perhaps in a future version of Ethereum. And I'll mention also that there's even a construction due to Catalano at all, that gives stronger security in the sense that they look at adaptive corruptions rather than static corruptions. Then you can build it based on pairings.
00:14:35.594 - 00:15:06.022, Speaker C: You can build it using MPC. And then Sanso in the Ethereum Foundation even looked at constructions for misogyny's. The reason, again, they were interested in post quantum Ssle. And so there is a construction for misogyny's as well, isogenes. Unfortunately, the performance of Isogenes is not as great as we would like. And so the natural question is, if we want to build a post quantum system, what would we like to build it from? Can somebody say, what do we like to build post quantum systems from Latices. Exactly.
00:15:06.022 - 00:15:10.920, Speaker C: So the question is, can we oh, sorry, I skipped a step. I forgot to say that.
00:15:11.610 - 00:15:11.986, Speaker B: Sorry.
00:15:12.028 - 00:15:27.674, Speaker C: Before we get to Latices. Well, fine, I'll say it. So the question is, can we build Ssel from lattices? But if we look at the existing families of constructions, well, Fhe is built from lattices, so it's inherently post quantum. But Fhe is pretty heavy weight mechanism.
00:15:27.722 - 00:15:27.886, Speaker B: Yeah.
00:15:27.908 - 00:15:44.030, Speaker C: So we'd like to use something that doesn't have to rely on Fhe. All these previous constructions were based on discrete log and pairing. They fall apart in the post quantum world. isogenies are post quantum. And the NPC methods. Well, it depends on which NPC you use. So maybe it is, maybe it isn't.
00:15:44.030 - 00:16:24.474, Speaker C: Okay, so that's kind of the state of the world. And the question that was open is, can we have a post quantum Ssle? By the way, the reason we started looking at this, it's also kind of a philosophically interesting question, which also came to us from the Ethereum Foundation. And they said that for every cryptographic primitive they deploy, they would like to have even though it's pre quantum today, they would like to have a post quantum variant. So that know, oh my God, tomorrow we open the New York Times and it says somebody in the world built a quantum computer. The Ethereum Foundation has they know what to do, they know what to deploy. So for everything it's a very good philosophy, actually. For everything they deploy, they want to have a post quantum variant.
00:16:24.474 - 00:17:20.098, Speaker C: Maybe they don't deploy it right away, but they want to have it in their pocket instead, in case they need it in an emergency. So for Ssle, we need to have a post quantum version. All right, so let's go and build one. And the one that I'll focus on, because they kind of chose this approach will focus on post Quantum from re randomizable commitments and that turned out to be kind of an interesting question that's what I want to tell you about. All right, so to explain how to build it, I first of all have to explain what are re randomizable commitments and how do they come up in Ssel? So let's walk slowly through the Ssel construction that uses re randomizable commitments and you'll see exactly what the problem is. All right, so we have our parties so we have our invalidators that we want to choose a leader from. The first thing that happens is called the commitment step so what is the commitment step? Well, everybody basically generates some random number and they commit that number.
00:17:20.098 - 00:17:38.354, Speaker C: So they publish a commitment of their number. They also publish a hash of that number. And the reason we publish that hash is to make sure that all the committed numbers are unique. Yeah, we don't want to have any duplicates. So this doesn't break the commitment. It just reveals enough information to argue that the commitments are unique.
00:17:38.482 - 00:17:39.650, Speaker B: Okay, good.
00:17:39.820 - 00:18:35.334, Speaker C: So that's just the setup step. Now that we've done the setup, what happens? So this happens at the beginning of time this is one time for the entire chain or one time for many, many slots so what happens next is now we have the re randomization phase where a party wakes up. Yeah, so here Alice woke up and what she will do is she will shuffle all these commitments and re randomize them so she literally permutes them under a random permutation but of course, just permuting is not enough because you can just look at the original commitments and the new commitments and figure out what the permutation is. So what she does, in addition to permuting, she also re randomizes the commitments so they don't look anything like the original commitments okay, and we keep doing that oh, sorry. And then she has to produce a proof that the shuffle was done correctly. This is called a proof of shuffle. That this is a zero knowledge proof that she permuted and re randomized.
00:18:35.334 - 00:18:52.046, Speaker C: But she didn't change any of the committed values. So she didn't drop any commitments. She didn't add any commitments and she didn't change any of the existing commitments. That's a proof of shuffle. And then we just do this over and over again. The parties just go ahead and everybody just permutes. And then once they're done permuting, they're happy.
00:18:52.046 - 00:19:17.378, Speaker C: That kind of everything got permuted around. What happens is we're going to use a beacon to randomly select one of these commitments. For example, the beacon says position number two is going to be the leader. And now nobody knows who position number two is because everything got permuted. So the leader is secret at this point. The leader is committed to it, selected. But nobody knows who the leader is because nobody knows what is inside of the commitment.
00:19:17.378 - 00:19:30.618, Speaker C: But when the leader is ready to publish their block, what they'll do is they'll reveal the fact that this is K Three is their commitment and a proof that K Three is, in fact, their commitment. And then now they can publish the block.
00:19:30.794 - 00:19:31.086, Speaker B: Yeah.
00:19:31.108 - 00:19:59.010, Speaker C: Does that make sense? So that's the process of commit and shuffle. Yeah. Right. Commitments hide who. So we select one commitment that doesn't reveal who the leader is, but the leader can later on open the commitment and reveal that's who they are. So that's the general framework for doing it. And so now the question is, what kind of a commitment scheme do we need to make this work? So what we need well, okay, there's a question from Chat.
00:19:59.010 - 00:20:00.414, Speaker C: Go to the chat.
00:20:00.542 - 00:20:00.786, Speaker B: Yeah.
00:20:00.808 - 00:20:11.562, Speaker C: So the question is, what does post quantum alternative mean in practice? Oh, my God. Aline, you want to get philosophical, I see.
00:20:11.616 - 00:20:12.090, Speaker B: Yeah, sure.
00:20:12.160 - 00:20:15.420, Speaker C: I'm just wondering. There are pre compiles, right, that support.
00:20:15.870 - 00:20:23.360, Speaker B: Clearly not post quantum cryptography like elliptic curve arithmetic. So those seem really tough to protect.
00:20:23.810 - 00:21:00.166, Speaker C: Yeah, so I see. Okay. Good question. Okay. This is a philosophical question. Like, what does it mean to be post quantum secure if you have pre quantum primitive pre compiles deployed in the EVM? Well, your guess is as good as mine, but I suppose if somebody comes up with a quantum computer earlier than we expect, presumably these precompiles will continue to exist. But we will also add post quantum equivalent pre compiles so people can migrate their contracts to these new pre compiles.
00:21:00.166 - 00:21:11.306, Speaker C: This is, by the way, a pretty deep rabbit hole because, as you know, there's a way to immunize existing systems against a future quantum computer. But maybe that's a discussion for another talk.
00:21:11.408 - 00:21:12.542, Speaker B: Yeah. So.
00:21:12.596 - 00:21:23.540, Speaker C: Thanks, Elaine. This is a good question, but that's kind of a long and complicated conversation. We can have that debate. Not debate that conversation. Maybe after the talk. Sounds good.
00:21:25.190 - 00:21:26.050, Speaker B: Yeah. Okay.
00:21:26.120 - 00:21:26.930, Speaker C: Excellent.
00:21:27.350 - 00:21:28.130, Speaker B: Yeah. Please.
00:21:28.200 - 00:21:31.300, Speaker C: The whole transcript of the Ssle would go on.
00:21:31.670 - 00:21:32.226, Speaker B: Yeah.
00:21:32.328 - 00:21:52.874, Speaker C: So, of course, the Ssle transcript has to go on chain. And that's an excellent question. And so what happens is, actually, here I'm describing a simplified version of the protocol. So here we permute basically all the commitments. So every time we permute, we would have to write it all on chain. There are optimizations that dramatically reduce the amount of communication. I'll get to that at the very end.
00:21:52.874 - 00:22:02.414, Speaker C: Yeah. We don't have to permute everything. We can use a rapidly mixing shuffle, and then we only touch a few commitments at a time.
00:22:02.532 - 00:22:02.862, Speaker B: Yeah.
00:22:02.916 - 00:22:05.200, Speaker C: So we'll get to that at the very end.
00:22:05.650 - 00:22:06.400, Speaker B: Yeah.
00:22:07.330 - 00:22:11.390, Speaker C: When the first person does the first permute, can they not just associate commitments with identities?
00:22:12.450 - 00:22:12.910, Speaker B: Yeah.
00:22:12.980 - 00:22:28.934, Speaker C: So this assumes one honest party. So as long as one of the parties is honestly shuffling and not revealing what the shuffle is. Then at the end, you break the connection between the commitments and the validators. I know what commit of K one is.
00:22:28.972 - 00:22:29.270, Speaker B: Right.
00:22:29.340 - 00:22:41.526, Speaker C: So now I know a value that is associated with a person. Then at the very end no, you don't know what the key is. I know the commitment. Yeah, but the commitment changes every time. The commitment gets re randomized every time.
00:22:41.628 - 00:22:41.858, Speaker B: Yeah.
00:22:41.884 - 00:22:44.778, Speaker C: So the commitment changes as you walk through this process.
00:22:44.864 - 00:22:45.546, Speaker B: Got it. Yeah.
00:22:45.568 - 00:22:52.202, Speaker C: So at the end, by the time you get here, the commitment is unrelated to the original commitments. Why is the random begin necessary?
00:22:52.266 - 00:22:53.662, Speaker B: Why can't you just say the first.
00:22:53.716 - 00:23:09.780, Speaker C: Commitment is the winner? Yeah. Okay, good. So there are some technical issues with that. So let's see. So if you say that the first commitment is the winner, so the last shuffler basically could always place themselves first and then they win.
00:23:10.550 - 00:23:11.300, Speaker B: Yeah.
00:23:12.470 - 00:23:16.360, Speaker C: Does that make sense? Yeah, right?
00:23:16.810 - 00:23:17.174, Speaker B: Yeah.
00:23:17.212 - 00:23:49.066, Speaker C: So you don't want to do that. Yeah, it's interesting without a beacon, like I said, we need pretty heavy tools to actually build this. Okay, so let's look at the components that we need to make this construction work. Okay, so what are the components that we need for this? So we need re randomizable commitments, which we'll talk about in just a second. We need a proof of correct shuffle and we need a randomness beacon, as we just said. And the properties fairness is guaranteed by the beacon. It's going to choose one element at random.
00:23:49.066 - 00:24:30.442, Speaker C: Unpredictability happens because of the hiding property of the commitment and uniqueness happens because all the committed values are distinct. Okay, so let's talk about re randomizable commitments and see what they are. So what is a re randomizable commitment? You can kind of already visualize what's needed here, but let's go through it carefully. So basically there's a commit algorithm that will generate a commitment to a key and then the key will become available to the committer. So the commitment algorithm generates a key for the committer. Then anyone can go ahead and re randomize the commitment and later on whoever holds the key can prove that this is their commitment. Yeah, so that's kind of at a high level.
00:24:30.442 - 00:25:00.214, Speaker C: What we'd like to achieve the syntax for this is we set up the system with some public parameters. The commit algorithm generates a commitment and a key. There's a randomized algorithm that takes a commitment and re randomizes it. And there's a verify algorithm that takes a commitment and a key and says, yes, this is a valid key for this commitment or not. Yeah, that's the syntax for the system. Let's go through the requirements. So we'll say that this is t randomizable if you can re randomize t times.
00:25:00.214 - 00:25:33.438, Speaker C: Okay, so let's just see what that means. Basically, if I generate a commitment so I have a commitment and a key and I repeatedly randomize t times. So I iteratively randomize again and again and again and again t times until I get a new commitment. Then the verifier will still accept the key k for the re randomizable commitment. That's if we do it up to t times. If you do it t plus one times maybe it doesn't work, but t times we can support. We also needed to be nondegenerate, meaning that if I generate two random commitments, the probability that I get different keys is almost one.
00:25:33.438 - 00:26:32.930, Speaker C: Yeah, if I always got the same key then we'd have a problem but I'm going to get different keys with very high probability. And now let's talk about the security properties. So the first security property is binding, the standard binding property, which means that given a commitment I cannot open it in two different ways, can only open it in one way and the unlinkability property is a little bit more tricky to define. But the unlinkability property goes as follows well, I'm going to ask you to randomize either I zero or I one times. What I'll do is I'll generate one commitment comm zero and I'll randomize it I zero times I'll generate another commitment comm one and I'll randomize it I one times. And the property is maybe you guys can guess, but the property is that if I give you the two commitments so you see the original commitments and you see either the re randomizable zero th commitment or first commitment you can't tell which one you saw. Yeah, that's the unlinkability property.
00:26:32.930 - 00:27:09.246, Speaker C: So once I re randomize a commitment you can't tell whether it came from zero or from one. They both look the same way. And this basically again means you cannot undo the permutation by just looking at the commitments because after you re randomize they all look the same. That's kind of the unlinkability property. All right, that's what we're trying to construct. So the first question to ask is does this even exist at all? Is there any way to construct this thing? And so the first observation is that using discrete log this is a trivial thing to construct. Yeah, under the decision d hellman assumption it's very, very simple to construct this.
00:27:09.246 - 00:27:36.534, Speaker C: So let's just walk through the construction. You'll see it right away. Basically, we're going to fix a group where the decision DfE helman problem is believed to be hard. And the way we commit is basically we're going to choose a random key k and then we're just going to output the generator and the generator to the K g and G to the K. That's going to be our initial commitment. Well, how do we re randomize? If I give you a commitment u comma v you see a commitment is a pair of group elements. So I give you U and V.
00:27:36.534 - 00:27:56.750, Speaker C: How do we re? Randomize. Well, we're just going to choose a random R and we're going to raise both U and V to. The power of R. Now, already looking ahead, anyone who's familiar with decision diffie hellman knows that once I raise things to the R, they sort of become pseudorandom. So you can't connect this to the original thing anymore. So good. We're getting our good unlinkability properties.
00:27:56.750 - 00:28:15.630, Speaker C: And then how do I verify if you reveal k? Yeah, once you reveal K, it's easy to test that k is correct. Simply take the first element, take U and raise it to the K and check if that's equal to V. And you see that a re randomization preserves the discrete log relation between the two values.
00:28:15.710 - 00:28:16.014, Speaker B: Yeah.
00:28:16.072 - 00:28:40.854, Speaker C: So very simple. Like the binding property is easy, the unlinkability property is easy. There's a very simple theorem. This is, in fact, infinitely re randomizable. It's binding and unlinkable. Assuming DDH, what could be easier and simpler to use? Great. Not only that, in fact, this kind of re randomizable commitment also has a very good proof of shuffle.
00:28:40.854 - 00:28:57.726, Speaker C: Yeah, this is what's called the buyer growth proof of shuffle. So this is great. Everything just hums along. And maybe this is why Wisc actually works as well as it does. So everybody's happy with this? The only problem with this construction is it's not quantum resistance.
00:28:57.838 - 00:28:58.114, Speaker B: Yeah.
00:28:58.152 - 00:29:10.694, Speaker C: So we got to build something that's quantum resistant. So the question then is how do we build re randomizable commitments from latices? And this turns out to be a pretty interesting question because the first thing you try doesn't work.
00:29:10.812 - 00:29:12.070, Speaker B: Yeah. Okay.
00:29:12.140 - 00:29:15.474, Speaker C: So with lattices, everything is harder. Everything is harder.
00:29:15.522 - 00:29:15.686, Speaker B: Yeah.
00:29:15.708 - 00:29:32.630, Speaker C: So here it's nice and clean. Very simple construction. Now let's switch gears and talk about the world of latices. And how do we actually build something like this that's post quantum secure? Okay, so a good starting point is well, let's start from a latice commitment scheme.
00:29:32.710 - 00:29:33.386, Speaker B: Yeah.
00:29:33.568 - 00:29:42.174, Speaker C: So here, I'm going to go slowly. Let me just kind of explain how these lattices work. How do we use lattices in cryptography, by the way? I hope people are familiar with what a lattice is.
00:29:42.212 - 00:29:42.366, Speaker B: Right.
00:29:42.388 - 00:30:23.134, Speaker C: A latice is well, technically it's a discrete what is it? A discrete subgroup of R to the n. That's the mathematical definition. The more human definition is I give you a bunch of vectors and R to the N, and you take all integer sorry, n vectors and R to the N, linearly independent vectors and R to the N and you take all integer linear combinations of those vectors. Yeah, that's a latice. And there are lots of computational problems on lattices, and many of those problems are believed to be hard for a quantum computer, which is why we can build cryptography from latices. Okay, so let's talk about how do we build latice commitments. Well, so when we use a latice, we have to, first of all, fix a prime Q.
00:30:23.134 - 00:30:27.434, Speaker C: Okay? So there's some prime, there are parameters because we're going to be dealing with matrices.
00:30:27.482 - 00:30:27.598, Speaker B: Yeah.
00:30:27.604 - 00:30:40.002, Speaker C: So there are matrices of dimensions M by N. And then there's often a noise distribution chi that generates low norm noise. Like the numbers, the noise is going to be like numbers in the range minus five to five.
00:30:40.056 - 00:30:40.226, Speaker B: Yeah.
00:30:40.248 - 00:31:10.906, Speaker C: So it's just some low noise noise distribution. And the way we would generate a commitment in the re randomizable commitment scheme is as follows. What we'll do is we'll choose a random matrix, A. So this is a tall matrix, it's an M by N matrix. We'll choose a random key K and then we'll choose a random noise vector from the noise distribution. E. And the way the commitment will work is K is going to be our secret key and the commitment is going to be very similar to the G comma G to the R.
00:31:10.906 - 00:31:41.480, Speaker C: We're just going to use the lattice equivalent of that. So the matrix is going to be one element and the other matrix, and the other element will be A times K plus some noise. This is an important component, a times K plus some noise. By the way, it's important to realize this is just a vector, right? So we're doing a matrix vector product which gives us a vector, and then we're adding some noise to this vector. So the commitment looks like a matrix and a vector. That's it. Okay, that's a very reasonable place to start.
00:31:41.480 - 00:32:22.386, Speaker C: And so the question is, how do we re randomize this? Yeah, that's the first question. So maybe I should ask if anybody sees here, let me kind of skip ahead. No, how do we verify first of all, so the commitment is going to be a matrix and a vector. How do we verify that the key K is correct? Well, I'm going to reveal the key K and what we're going to check yeah, so here, pay attention. How do we check that the key K is correct? We're going to compute the product B times K. This is a vector. And if K is the correct key for this commitment, what will happen is that B times K is going to be close to the vector B.
00:32:22.386 - 00:33:16.340, Speaker C: Yeah, let me just remind you why that's the case. If we look at the definition of B, b is going to be BK plus the noise vector. So if we take the matrix B and multiply it by K, basically what we're going to get is a vector that's off from B by the vector E and E is a low norm vector, right? So basically, if these two are close, in other words, their difference is a low L two norm vector, then we say that K is correct. So let me ask you, see if anybody can help me here. So how would we re randomize this commitment? So we have a commitment, a matrix and a vector that satisfy that we want to preserve this relation that B times K is close to the vector B. How would we re randomize the commitments inspired by regular encryption multiplied by a Boolean matrix randomly. Yes, exactly.
00:33:16.340 - 00:33:18.258, Speaker C: That's exactly where we're headed.
00:33:18.354 - 00:33:18.902, Speaker B: Perfect.
00:33:19.036 - 00:33:48.640, Speaker C: Thank you. So what we're going to do exactly, we're going to do kind of a thing that comes up in lattices quite a bit. And the way we re randomize is we're going to choose a random sort of Boolean minus one plus one square matrix. It's not a rectangular matrix anymore, it's a square matrix. And what we'll do is we multiply both the matrix and the vector by this low norm matrix, R. Okay, fine. This is all standard lattice stuff so far.
00:33:48.640 - 00:34:20.854, Speaker C: Let's just verify. Why does verification still work? Well, remember this relation? This is how the vector is defined. So why does this relation still work? Well, if we multiply both sides by R, you see, we're multiplying both sides by the matrix R. The noise, the difference between B and B times K becomes R times E, our low norm matrix times the lower norm vector. Well, a low norm matrix times a lower norm vector is still a low norm vector. So they still remain close to one another. Not as close as before.
00:34:20.854 - 00:34:39.120, Speaker C: They got a little bit further apart because we multiplied by a random matrix, but they still remain close. This is, by the way, why I said that we only need t randomizable, because the more we randomize, the further apart they drift, and eventually they're going to drift too far apart and we're going to reject the key. So we can only re randomize T times.
00:34:39.570 - 00:34:40.030, Speaker B: Great.
00:34:40.100 - 00:34:41.342, Speaker C: So it's like we're off to a good start.
00:34:41.396 - 00:34:41.566, Speaker B: Yeah.
00:34:41.588 - 00:34:56.050, Speaker C: This is kind of the first thing that we tried. Surprisingly, this doesn't work. Yeah, good. So, great. We have a scheme. So the question is I guess I gave it away. The question is, is it secure? So let's look at the analysis.
00:34:56.050 - 00:35:14.666, Speaker C: So it's not so hard to prove a theorem that shows that this scheme actually is unlinkable. So if you re randomize, in fact, the commitment you get is unlinkable to the original commitment. And this is based on the standard learning with errors problem, which I'll explain what that is in just a second.
00:35:14.848 - 00:35:15.194, Speaker B: Great.
00:35:15.232 - 00:35:36.990, Speaker C: And the proof I'm not going to go through the proof. It's not a very interesting proof. It's kind of a standard argument using LWE and the leftover hashlemma for a cryptographer. This is like literally bread and butter. Yeah, we do this in our sleep. So not a very difficult proof, but I guess now I have an opportunity to show you. I'm not sure if everybody is up to speed on the world of Latices.
00:35:36.990 - 00:36:04.294, Speaker C: So just to show you what these assumptions look like, let me explain what the learning with errors assumption is. I have an opportunity to explain this. So let me show you what the assumption is. And the assumption I'll describe it in kind of well, I'll describe it the way I like to describe it. So again, we have these parameters, the prime, the dimension and the noise distribution. And just so you see real numbers, the primes tend to be relatively small. So like they're 15 bit primes.
00:36:04.294 - 00:36:19.038, Speaker C: The dimensions are in the hundreds. So these are big, big vectors. And the variance is actually, again, very small. The noise distribution is literally numbers between minus five and five. It's kind of a gaussian between minus five and five with variance of 1.75.
00:36:19.124 - 00:36:19.374, Speaker B: Yeah.
00:36:19.412 - 00:36:54.234, Speaker C: This is from one of the NIST candidates for post quantum key exchange. So you can see, very concretely, by the way, the fact that these primes are so small is why these lattice systems actually work so quickly, because we're not dealing with there's no big NUM arithmetic here. We're just dealing with very, very small numbers. Computers love these things. And so this is why this is so fast. What does the assumption say? The assumption basically says that if I choose a random vector S yeah. So it's an n dimensional random vector S, and I give you two boxes, one box basically will spit out vectors of the form.
00:36:54.234 - 00:37:03.306, Speaker C: Well, a one, a two, a three. These are the vectors. And then scalars of the form, a one times a secret vector plus noise. A two times a secret vector plus noise.
00:37:03.418 - 00:37:04.030, Speaker B: Yeah.
00:37:04.180 - 00:37:09.498, Speaker C: If I give you this output versus if I give you just vectors with random scalars.
00:37:09.594 - 00:37:09.806, Speaker B: Yeah.
00:37:09.828 - 00:37:57.070, Speaker C: So here you can see the definition of what these things are. So random vectors plus well computed scalars or random vectors with random scalars. The assumption says there's no quantum polynomial time algorithm that can distinguish between these two boxes. Yeah, that's the assumption. So it's very interesting, for example, if the noise was zero, if all the noise value were zero, this would be false, right? Because if all the noise values were zero, then after a few samples you'll be able to solve for S and then you'll be able to check that all the results actually look like S. So it's kind of this remarkable thing that by throwing in a little bit of noise into these relations you make the scalars look indistinguishable from random. That's what the LWE assumption says.
00:37:57.070 - 00:38:09.522, Speaker C: And there's this classic result of regev that says if in fact you gave an algorithm for LWE, then in fact this would give us a way to solve a difficult problem, something we believe is hard for a quantum computer.
00:38:09.576 - 00:38:09.746, Speaker B: Yeah.
00:38:09.768 - 00:38:11.586, Speaker C: The approximate shortest vector problem.
00:38:11.768 - 00:38:12.066, Speaker B: Yeah.
00:38:12.088 - 00:38:38.918, Speaker C: So a lot of the NIST candidates are based on variations of this, based on ring LWE. So I think it's actually good if somebody hasn't seen this. I think it's good to stare at this for a little bit because just so you understand, in 15 years, most of well, I should say kind of many of the post quantum candidates that will be deployed in the real world are going to be based on assumptions of this flavor.
00:38:39.014 - 00:38:39.274, Speaker B: Yeah.
00:38:39.312 - 00:38:50.922, Speaker C: So literally, the security of the Internet is going to start depending on these types of assumptions. So it is really kind of important to understand the quantum security of this type of assumption.
00:38:50.986 - 00:38:51.214, Speaker B: Yeah.
00:38:51.252 - 00:39:33.866, Speaker C: So I would argue that it's pretty important in the next couple of years that a lot of the folks who are specialists in designing quantum algorithms think more about what is the best algorithm for kind of resolving the LWE question just because this problem is going to become so important for the health of the Internet. Okay, that's a bit of an aside. Now let's go back to our main story. So the question is, remember we had our Re randomizable commitment example, and it was unlinkable, just like we needed. Once you re randomize, everything becomes random. What was the other property of a commitment scheme that we needed? Need to be unlinkable. What was the other property? Binding.
00:39:33.866 - 00:39:49.022, Speaker C: It needs to be binding. So the question is, is this commitment scheme actually binding? In other words, is it really difficult to find a commitment B and B and two different keys such that B times K is close to B is close to B times K Prime?
00:39:49.086 - 00:39:49.314, Speaker B: Right.
00:39:49.352 - 00:39:58.790, Speaker C: That if we could do this, this would break binding. And in fact, it turns out it's not that difficult to show that, in fact, for a random matrix B, this is difficult. You can't do this.
00:39:58.860 - 00:39:59.142, Speaker B: Yeah.
00:39:59.196 - 00:40:06.882, Speaker C: Just secure. There's just no K and K Prime will be mapped close to one another. The adversary can choose the commitment adversarially.
00:40:07.026 - 00:40:07.334, Speaker B: Right.
00:40:07.372 - 00:40:34.198, Speaker C: The problem is B is not random. It's chosen by the adversary. And actually, if you think about this for a second, you'll see the adversary can choose a matrix B for which this problem is trivial. For example, if the matrix B is made up of lone norm columns, vectors of lone norm, then in fact any lone norm K will collide with any low norm K Prime and boom, we broke binding. And this is not just a theoretical attack. This actually would break the Ssle.
00:40:34.394 - 00:40:34.754, Speaker B: Yeah.
00:40:34.792 - 00:40:59.314, Speaker C: The protocol just stops being secure. So this construction just doesn't work. Yeah. The first thing you try just doesn't work. And what's even worse is you try to kind of hope that you can fix it quite easily, but the trivial fixes don't work. For example, maybe we can fix the matrix B as part of the trusted setup process. Or maybe we can generate the matrix not as a random matrix.
00:40:59.314 - 00:41:22.190, Speaker C: Maybe we can generate it as a random oracle applied to some seed. Yeah, so we generate the matrix, derive the matrix from some seed, so we force it to be random so the adversary can't just choose whatever matrix it wants. But the problem with these two solutions is they break the Re randomization mechanism. So if we do this, either one of these, we can't re randomize the commitment anymore.
00:41:22.610 - 00:41:22.974, Speaker B: Yeah.
00:41:23.012 - 00:42:05.514, Speaker C: So the obvious solutions don't work. So we need to invent something new. And so the first step is solving this problem. And so let me show you the solution. The solution is basically to say, well, there's this observation that it's true that in fact you can cause collisions, but in fact, if you choose random k and k prime, there are very few matrices that will cause these values to collide with one another. Yeah, they exist, but they're very rare. And so what we'll do is if we choose enough random vectors, enough random k one to KL, then in fact you can argue that with very high probability, there is no matrix, there are no collisions among these set of vectors.
00:42:05.562 - 00:42:05.822, Speaker B: Yeah.
00:42:05.876 - 00:42:37.158, Speaker C: So that's kind of the observation and that's going to be our way out. And so the actual commitment scheme, what we'll do is rather than if you remember before, we used a single vector. Now instead of committing to a single vector, we're going to commit to a matrix. We're going to expand this into a matrix away from a vector. And in fact, this matrix that we're going to use as a key is going to look like just basically L random vectors and we force it to be L random vectors by basically using a hash function.
00:42:37.244 - 00:42:37.446, Speaker B: Yeah.
00:42:37.468 - 00:42:53.286, Speaker C: So which will model as a random oracle. So kind of we force the adversary to use a random key. The matrix we have no control over. The matrix can be arbitrarily adversarial, but the key, we can force it to be a random looking vector, a random looking matrix.
00:42:53.398 - 00:42:53.674, Speaker B: Yeah.
00:42:53.712 - 00:43:28.938, Speaker C: And the point is everything works the same. So to verify, you're just going to reveal the seed and you're going to check these L two norm conditions and re randomization works exactly as before. So that's kind of almost the final construction. And now you can prove these two theorems, the scheme is binding, assuming the hash function is a random oracle. And the point is now the scheme is also sorry, it was unlinkable as easy, now it's also binding using H being a random oracle and we still preserve the unlinkability. So now we have the two properties that we want.
00:43:29.104 - 00:43:29.722, Speaker B: Yeah.
00:43:29.856 - 00:43:31.194, Speaker D: How big should I think of l?
00:43:31.232 - 00:43:31.820, Speaker B: As?
00:43:33.310 - 00:43:33.770, Speaker C: Yeah.
00:43:33.840 - 00:43:34.026, Speaker B: Okay.
00:43:34.048 - 00:43:55.902, Speaker C: So asymptotically it's just logarithmic, logarithmic in the security parameters and in reality it's going to be also probably around 100 or so. So not too bad. Okay, yeah, I think I know the question on zoom. So the question is, if you fix b in the setup procedure, the matrix b, can you re randomize? And no, the answer is you cannot re randomize because the re randomization required changing the matrix.
00:43:56.046 - 00:43:56.690, Speaker B: Yeah.
00:43:56.840 - 00:44:02.580, Speaker C: And so yeah, that unfortunately doesn't work. Yeah, cool, it's a good question.
00:44:03.830 - 00:44:04.562, Speaker B: Okay, great.
00:44:04.616 - 00:44:17.734, Speaker C: Are we done? Yeah, but this requires all of these L vectors to be randomly chosen, right? Well, we force them to be randomly chosen by choosing them from choosing them from the hash function. Here we go.
00:44:17.772 - 00:44:18.502, Speaker B: Here. Yeah.
00:44:18.556 - 00:44:26.170, Speaker C: So they're not actually adversary doesn't get to choose the vectors however it wants. It has to choose a seed and then derive them from the hash function.
00:44:26.240 - 00:44:28.140, Speaker B: And you have to prove that as well.
00:44:28.670 - 00:44:35.822, Speaker C: Well, no, you reveal the seed and then the verifier that verifies the key will compute the hash function on its own.
00:44:35.876 - 00:44:36.574, Speaker B: Okay. Yeah.
00:44:36.612 - 00:44:48.020, Speaker C: And that's how it works. And by the way, it's interesting. This is exactly why the binding depends on H being a random oracle, because we do need these vectors to be random looking, and the random oracle will guarantee that.
00:44:48.470 - 00:44:49.074, Speaker B: Yeah.
00:44:49.192 - 00:44:56.130, Speaker A: When you're rearrandomizing, will the rear randomizer need to prove that it's multiplied correctly by a small matrix?
00:44:56.950 - 00:44:59.498, Speaker C: Fantastic question there. Fantastic. That's exactly where we're headed.
00:44:59.534 - 00:45:00.520, Speaker B: Okay, perfect.
00:45:01.370 - 00:45:16.970, Speaker C: You couldn't have asked that at a better time. So the question is, are we done? Well, unfortunately, there are more problems. So it's interesting. There are more problems. These problems don't come up in the DFI Hellman case. In the DDH case, all this stuff is, like, not a problem here. All these problems come up.
00:45:16.970 - 00:45:37.506, Speaker C: It's exactly what Lara was asking. So if you think back to our definition of unlinkability, remember we said that if you re randomize I zero times, it looks the same as re randomizing I one times. Well, that's assuming Re randomization is done honestly. But what if Re randomization is done this honestly? Then it turns out we have a problem.
00:45:37.608 - 00:45:37.970, Speaker B: Yeah.
00:45:38.040 - 00:45:54.758, Speaker C: So it turns out you'll break unlinkability, which, again, breaks the Ssle protocol. So we define, actually, a stronger notion of Re randomizable commitments. We'll say that they're strongly unlinkable if they're unlinkable, even if the Re randomization is done adversarially, which is what you were asking.
00:45:54.844 - 00:45:55.046, Speaker B: Right.
00:45:55.068 - 00:46:13.340, Speaker C: What if you choose a malicious matrix R, right. And it turns out that the DDH construction is strongly unlinkable trivially. This problem just doesn't come up in the DDH world. Whereas what I just showed you is insecure. Yeah, it's not that hard, actually. It's a little tricky, but it's not too hard to show that it's insecure. There's an attack.
00:46:13.340 - 00:46:39.986, Speaker C: What you said, Lara, actually leads to a real attack. Okay, now we're getting short on time, so I'll just say there's one more step we need to take to immunize the construction to make it strongly unlinkable. So there's one more immunization step that maybe I'll leave to the paper. And so we can get actually a strongly unlinkable scheme. Yeah. So now we have a randomizable commitment. We have to marry it with a proof of shuffle.
00:46:39.986 - 00:46:54.134, Speaker C: And so which proof of shuffle works with this commitment? It turns out we can use an adaptation of Buyer Groff to the ring LWE settings, and we get a nice proof of shuffle, which gives us an efficient Ssle overall.
00:46:54.262 - 00:46:54.602, Speaker B: Yeah.
00:46:54.656 - 00:47:22.046, Speaker C: So that's kind of the end of the story. And I'll say, who's asking about posting? Oh, you're asking about posting things on chain. So this bullet addresses that issue. That in fact, when you implement this in practice, like in Wisc and in some other papers, you don't re randomize the whole set. You just re randomize a small set, a small portion, and you use kind of a rapidly mixing process that even if you re randomize a small shuffle, a small set, it very quickly converges to a uniform distribution.
00:47:22.158 - 00:47:22.434, Speaker B: Yeah.
00:47:22.472 - 00:47:29.862, Speaker C: So you don't have to write on chain. You don't have to write that much data every time. Yeah, and maybe I'll leave this also for the paper.
00:47:29.916 - 00:47:30.520, Speaker B: Yeah.
00:47:32.730 - 00:47:51.146, Speaker C: You describe things based on plain LWE. Yeah, we give both. So the paper basically gives constructions from LWE and from ring LWE. The ring LWE is actually more efficient. So probably that's what you'll end up using in the real world. So this gives us this post quantum security. And so, yeah, I think I'll stop here.
00:47:51.146 - 00:48:36.278, Speaker C: Basically, I think there's still a lot to do here in the post quantum setting. So the question is, could we have other Latice based Ssle schemes in particular? Again, there's a very nice pairing based paper for Ssel from the same group, CFG. And one thing, if people are interested in working on this, it'd be nice to look at this construction and convert it to the lattice settings. I showed you the re randomizable plus shuffle construction. There's a whole other path to Ssel that would also be nice to convert to the lattice settings. So there's actually more work to do here, but yeah, that's where we are. So now there's a post quantum alternative to Ssel, so you can feel safe in deploying the beefy Hellman Ssle.
00:48:36.278 - 00:48:50.158, Speaker C: If the world collapses and tomorrow somebody builds a quantum computer, we have a fallback and we're back to our happy states. Okay, so I'll stop here. Thanks for listening. Happy to take any questions.
00:48:50.324 - 00:48:54.880, Speaker B: Great. Yeah, please. One component of this was the randomness beacon. Yeah.
00:48:55.730 - 00:49:03.054, Speaker C: What are like, post quantum solutions for randomness beacon? Yeah, that's a good for the pool thing to be post quantum.
00:49:03.102 - 00:49:04.866, Speaker B: That one also has to be, yeah.
00:49:04.888 - 00:49:08.802, Speaker C: So I guess what you're asking is, do we have a post quantum VDF?
00:49:08.946 - 00:49:09.542, Speaker B: Right?
00:49:09.676 - 00:49:39.626, Speaker C: And so the answer is yes, we do. So the VDF that actually is going to get deployed is a hash chain based VDF. How do you prove that the VDF was computed correctly? Well, you give a Snark proof that the hash chain was computed correctly. So now we just need a post quantum Snark proof and what's that called. So one example is the Stark system. There are other Latice based post quantum systems, but one example of a post quantum proof Stark system is Stark.
00:49:39.658 - 00:49:39.854, Speaker B: Right.
00:49:39.892 - 00:49:47.250, Speaker C: So you could build a VDF by using a post quantum hash function, which is easy, along with a Stark proof.
00:49:48.710 - 00:49:51.982, Speaker D: Lattice based VDF is a pretty interesting challenge.
00:49:52.046 - 00:50:11.258, Speaker C: Yes, absolutely. A lattice based VDF would be awesome. That's a fantastic open problem. Yeah. We have Lattice based Snarks, so I guess you could just take the hash chain one and combine it with a latice based Snark, but like a native lattice based VDF. That's a fantastic question.
00:50:11.344 - 00:50:11.642, Speaker B: Yeah.
00:50:11.696 - 00:50:16.060, Speaker C: So please solve a really, really nice problem to work.
00:50:19.790 - 00:50:20.810, Speaker A: For Lattices.
00:50:22.830 - 00:50:26.698, Speaker C: Oh, that's a great question. So what we would need is a VRF.
00:50:26.794 - 00:50:27.006, Speaker B: Right.
00:50:27.028 - 00:50:29.114, Speaker C: So do we have a lattice based VRF?
00:50:29.242 - 00:50:47.270, Speaker D: There's a construction I could show you later if you're interested. But there's a hash based spotted VR. It's not a VRF, but it's a VRF. It's like a slight relaxation of a VRF that works for probabilistic leader election. And it only uses hash functions. It's really simple. There's like a hash chain.
00:50:49.210 - 00:50:50.230, Speaker B: Yeah. Great.
00:50:50.380 - 00:50:53.910, Speaker D: All you need is hash functions for a probabilistic leader election.
00:50:54.410 - 00:50:57.106, Speaker C: Yeah, good. All hash functions are sufficient.
00:50:57.138 - 00:50:57.494, Speaker B: Yeah. Good.
00:50:57.532 - 00:51:16.410, Speaker C: I see. So you don't even need lasses, you can just rely on hash functions. Yeah, even easier. But if we go back to the VRF question, I guess well, there's a generic answer, because once we have a latice based narc and a latice based PRF, we can convert it into a latice based VRF.
00:51:16.490 - 00:51:22.426, Speaker D: There is a hash based, like, slotted VRF. The restriction is that you can only compute it once per slot.
00:51:22.458 - 00:51:24.046, Speaker C: But that's all you need. That's all you need.
00:51:24.068 - 00:51:24.962, Speaker B: Yeah. Good.
00:51:25.096 - 00:51:31.570, Speaker D: Because you basically reveal your key for that slot, which is the slot in the hash chain.
00:51:33.510 - 00:51:48.322, Speaker C: Just to maybe to summarize what Joe said for the people at home. So Joe is saying that there is a very simple construction for ple probabilistic leader election just from hash functions. You don't need anything other than hash functions. That's great. So then it'll definitely be post quantum secure.
00:51:48.466 - 00:51:55.546, Speaker B: Yeah. Please. Random shuffle. It seems to me that these two.
00:51:55.568 - 00:52:28.626, Speaker C: Things are the same. Oh, a random beacon and a random well, okay, not quite right. So random shuffle, or rather shuffle proof, is married to the commitment scheme we're doing. Right? The shuffle proof you're doing is you're re randomizing the particular commitment scheme that we have. And then you have to argue that the committed values on the input side are equal to the committed values on the output side module of the order. So that's more specific to the exact construction of the commitment scheme. Whereas a beacon is just generic.
00:52:28.626 - 00:52:44.646, Speaker C: It just gives you random bits, doesn't care about the commitment. So what you need is a proof of for permutation. Yes, exactly. So exactly. You need to prove that the output as a permutation of the inputs right. Nothing was added, nothing was dropped, nothing was changed.
00:52:44.758 - 00:52:44.986, Speaker B: Yeah.
00:52:45.008 - 00:53:02.220, Speaker C: And that's what these proofs of shuffle did. So we have very good ones. And that's what gets used here. In fact, the Wisc construction, one of the very cool things they did is they really optimized the proof of shuffle to get it kind of as efficient as possible. That was very, very cool work.
00:53:02.710 - 00:53:03.506, Speaker B: Yeah. Cool.
00:53:03.528 - 00:53:09.940, Speaker C: It's a great question. Yeah, awesome. Thanks. Yeah, this was fun. Yeah.
