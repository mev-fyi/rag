00:00:07.380 - 00:00:07.930, Speaker A: You.
00:00:09.900 - 00:00:34.210, Speaker B: All right, welcome everyone, to Today's, a 16 Z crypto research seminar. Very happy to introduce Andrew Lewis Pi, a professor at London School of Economics who will be visiting all month. Andy actually got his start as a computability theorist, believe it or not, but very luckily for sort of web3 in the blockchains world, he's gotten obsessed with consensus for blockchain protocols, which you want to tell us about today.
00:00:34.580 - 00:00:59.880, Speaker C: Thanks, Tim. So, yeah, I'm going to talk about a joint project with Tim, which is aimed at the developing of a general framework for the analysis of permissionless. Consensus protocols might be the proof of work, proof of stake, proof of space or whatever. So in the talk, I'm going to keep things at quite a high level. So if you're interested in the details, then obviously I encourage you to check out the actual paper, which is the same title. So it's permissionless consensus, and you can find that in the archive.
00:01:00.700 - 00:01:06.692, Speaker B: What's the story with all the hands? Your title slide. Your title slide.
00:01:06.836 - 00:01:33.280, Speaker C: That's the hands. That's right. That's people voting. So, yeah, starting at the beginning. So I guess the most basic question is why do we need a general framework? And the basic answer there is obviously impossibility results play a crucial role in building an ebaldeveloped theory, and you need a formal framework in order to prove impossibility results. So for the permission setting, we've got lots of good examples of that. There are lots of important impossibility results in the permission setting.
00:01:33.280 - 00:01:38.788, Speaker C: So the permission setting is just the classical setting that people have been studying consensus protocols in since the 1980s.
00:01:38.794 - 00:01:38.916, Speaker A: Right.
00:01:38.938 - 00:01:41.776, Speaker C: It just means you have a fixed set of known participants.
00:01:41.888 - 00:01:42.550, Speaker A: Okay.
00:01:43.400 - 00:02:36.112, Speaker C: So, yeah, in the permission setting, we have a lot of good examples of important impossible deer results and results that significantly impact the way that people go about designing protocols. So the FLP theorem is a good example there. So we have this nice theorem by Fisher, lynch and Peterson which says that consensus protocols can't be deterministic if they're going to operate in what we call the Asynchronous setting, whatever that is. So we see that synchronous impacts the way we go about designing protocols, because if we want to design a protocol that's going to work in the Asynchronous setting, then we know some randomness is required. Okay, so that's one example, but there are many more examples I could give you. So for the permissionless setting, though, okay, so some previous frameworks suffice to model proof of work protocols, but not to develop a general theory. So why do I say that? Well, so in particular, we're going to see various results today which can't be expressed, can't be explained in the previous frameworks.
00:02:36.176 - 00:02:36.692, Speaker A: Okay?
00:02:36.826 - 00:02:47.880, Speaker C: And basically the issue is that the previous frameworks don't have the right language for talking about consensus protocols that use what they'll call on chain resources, these resources like stake.
00:02:48.220 - 00:02:48.536, Speaker A: Okay?
00:02:48.558 - 00:03:22.080, Speaker C: So one of the things we want to do is to define the permissionless setting, right? We want to map out the space of permissionless protocols. A point of complexity there is that people often think of some protocols as being more permissionless than others. So in particular people often think of proof of work protocols as being in some sense more permissionless than proof of state protocols. So is there some way we can make that precise? What we'll actually do is we'll define a hierarchy of four different settings from most permissionless, if you like, down to least permissionless.
00:03:22.240 - 00:03:22.950, Speaker A: Okay?
00:03:24.600 - 00:03:43.464, Speaker C: Yeah. So I'll describe those settings, the settings kind of at a high level now and we'll define them more precisely later on. So starting off with the most permissionless setting, I should call the fully permissionless setting. So the basic idea here is at each moment in time the protocol has no knowledge at all about which nodes are currently running it.
00:03:43.502 - 00:03:43.704, Speaker A: Okay?
00:03:43.742 - 00:04:19.380, Speaker C: So proof of work protocols like Bitcoin are typically interpreted as operating in this setting. Of course, in reality you might have some idea about who the players are, but the point is that technically speaking, that's not required for the protocol to operate effectively. As I say. So Bitcoin will operate in the fully permissionless setting and then we consider like a slight relaxation the fully permissionless setting, which you call the dynamically available setting. The thing to have in mind here is longest chain proof of state protocols. So now things are different. Now each moment in time the protocol is aware of a dynamically evolving list of IDs.
00:04:20.200 - 00:04:20.612, Speaker A: Okay?
00:04:20.666 - 00:05:04.900, Speaker C: So the thing to have in mind here, as I say, is it's like a longest chain proof of state protocol. Think about the confirmed transactions and who those transactions say has some stake or stake in Escrowing. So now the protocol is aware of a dynamically evolving list of IDs. Importantly though, so the evolution of this dynamically evolving list of IDs could be like a function of the protocol execution. And it could also be the case that different players have different ideas about what this list is because different people might have seen different versions of the blockchain. Okay, so now we have this dynamically evolving list of IDs. And in the dynamically available setting we're going to allow, we can assume that at least some honest members of that list of IDs are going to be turning up and carrying out the protocol.
00:05:04.900 - 00:05:22.452, Speaker C: We might also assume some bound on most, a broad fraction of those being Byzantine, that sort of thing. Okay? So as I say, so proof of state long distained protocols like auroboros and Snow White, they normally thought of as operating and they should be thought of as operating in this setting.
00:05:22.596 - 00:05:22.964, Speaker A: Okay?
00:05:23.022 - 00:06:03.844, Speaker C: And then we have a further relaxation, which we're going to call the quasi permissionless setting. So in the quasi permissionless setting, again, we have this evolving list of IDs. But now membership list of these IDs is sufficient condition for membership, for participation in the protocol, at least if you're honest. So now we're going to assume that everybody in that list of IDs is turning up and participating in the protocol, if you think about it. So BFT style proof of stake protocols, like Algorand or proof of stake implementations of tendermint or whatever, they operate in this setting, right? They require all of the relevant list of participants to turn up and participate. Otherwise liveness will be violated. Okay, so proof of stake, that's a BFT style proof of state protocols operate in the setting.
00:06:03.844 - 00:06:43.056, Speaker C: But there are also a whole bunch of proof of work protocols such as hybrid, BIZCOIN, solida, they all operate in this setting as well. So we'll talk about them a little bit more later on. There's a number of papers in the classical literature on what are called player reconfiguration protocols. And these are basically protocols which are like permission protocols. But now you're allowed changing sets of players and actually so proof of state protocols can really be seen as like a particular form of player reconfiguration protocols. So player reconfiguration protocols are also seen, should be seen as operating in the QP setting, quasi permission setting.
00:06:43.168 - 00:06:58.020, Speaker B: You should have already said this. Maybe it's worth reiterating. I mean, the key thing about BFT style protocols is they vote. And so if you're taking a vote, you need to know what constitutes a quorum. And so that makes it particularly natural to assume that, okay, I guess we need people to show up if we're going to get a quorum.
00:06:58.100 - 00:07:27.692, Speaker C: Exactly, right? So you got a certain number of people voting and you need to know what that number is that you know, what two thirds of that number is or whatever. Okay, so we've got the QP setting, and then I'm kind of presuming that people may be familiar already with the permission setting. So this is just the classical setting. We have a fixed set of known participants. And also in the permission setting, we generally assume that all participants are always active. So this is a hierarchy going from the harshest setting down to the easiest setting. As we go down the hierarchy, you're allowed to make more assumptions.
00:07:27.836 - 00:07:28.144, Speaker A: Okay?
00:07:28.182 - 00:07:55.660, Speaker C: So that means if we prove any impossibility result for any level of the setting, any level of the hierarchy here, then that impossibility result will automatically hold for all higher levels of the hierarchy, right? So if we prove an impossibility result for the dynamically available protocols, that will automatically hold for fully permissionless protocols. Okay, so here we're defining like a hierarchy of settings rather than the hierarchy of protocols. But then what we'll do is we'll allocate a protocol to the harshest setting in which it's live existent or which it performs the required functionality.
00:07:56.560 - 00:07:57.020, Speaker A: Okay?
00:07:57.090 - 00:08:03.064, Speaker C: So we'll refer to Bitcoin as a fully permissionless protocol, for example, because it operates in the harshest possible setting.
00:08:03.192 - 00:08:03.532, Speaker A: Okay?
00:08:03.586 - 00:08:15.036, Speaker C: And then there's a bunch of other stuff we've got to do to fully define the framework. It's not just about defining the hierarchy of settings, right? There's lots of other stuff we have to do, but once we've formally defined the framework, then we can go about defining general impossibility results.
00:08:15.068 - 00:08:29.056, Speaker D: Yeah. Question on the previous slide, are you considering like a specific type of network model and or is it the case that you can have a protocol that's like, say, quasi permissionless in one network model and fully dynamic in another network.
00:08:29.088 - 00:08:59.260, Speaker C: Model and so on? If you mean by network mode, you mean literally who is connected to who, communicate with who. Okay, no, you're right. So we're going to consider like synchronous setting, partially synchronous setting. Well, we won't talk about the Asynchronous setting today, but you're right. So whether you operate in the DA setting or the QP setting might also depend on your synchronicity setting, like with Ethereum. Okay, so once we've defined the framework, we can prove general impossibility results. And one of the things we're going to be interested in doing in particular is delineating what becomes possible and different levels of the hierarchy.
00:08:59.260 - 00:09:30.184, Speaker C: So here are a couple of taster theorems for you. Now in case you were impatient. So there'll be some more theorems later on and there are more theorems in the paper. Okay, so the first theorem here says that protocol solving consensus in the fully permissionless setting cannot be deterministic and that holds even in synchrony. So you have the FLP theorem, but that's for a much harsher setting in some sense in terms of communication, that's the Asynchronous setting. This holds even in synchrony in case you can sort of see that as an analog of the FLP theorem in a sense, if you like. That's one theorem that we'll see later.
00:09:30.184 - 00:10:10.170, Speaker C: And then a second theorem here says that dynamically available protocols can't solve consensus in the partial synchrony model. So I haven't defined the partial synchrony model yet, but you should have in mind this is just like a standard setting in which most of the well known permission protocols operate. Protocols like PBFT, Hot, Stuff, Tendermint and so on, they all operate in the partial synchrony model. So dynamically available protocols can't solve consensus as this fairly standard model. And as I said, this sort of strict hierarchy here. So we have this impossibility result for dynamically available protocols that then has to hold also for the fully permissionless protocols like Bitcoin. So now let's start looking at how the framework actually works.
00:10:10.170 - 00:11:05.610, Speaker C: So if we're going to be sort of thinking about permissionless protocols, then generally we're going to think about protocols that work relative to what we'll call like resources of some kind. So resources could be stuff, things like stake hash rate memory chips or whatever, right? Just briefly though, before we talk about resources, I want to introduce like a version of the permissionless setting in which we don't yet get to talk about resources. Okay, so as we move from the permission setting to the permissionless setting, there are actually three new challenges that we sort of introduce simultaneously. That's maybe a slightly confusing thing to do, but that's what happens. So now we move to a setting which we have an unknown set of participants and set of participants of also of unknown size. We also assume that now people can be or players, nodes, what do you want to call them, can be active or inactive at different time slots. I could be active and inactive and active again and so on.
00:11:06.540 - 00:11:06.952, Speaker A: Okay?
00:11:07.006 - 00:11:32.544, Speaker C: And we also have to consider a third sort of challenge. We have to now have to consider the possibility of civil attacks. So we introduce these three new challenges simultaneously on a technical level. Now, theoretical level, that's a slightly crazy thing to do if you're studying things theoretically. Generally, you want to introduce one new challenge at a time and see what does that change. And then you introduce another challenge to see what that changes and so on. So here we're introducing three new changes at the same time.
00:11:32.544 - 00:11:49.860, Speaker C: And basically the reason is that there's a change in aim, right? So in the permission setting, we're talking about consensus protocols because we want to develop fault tolerance. Now we have this new sort of vaguely defined aim, which is decentralization. And it seems that in order to have decentralization, we need to meet these three new challenges.
00:11:50.280 - 00:11:50.644, Speaker A: Okay?
00:11:50.682 - 00:12:18.364, Speaker C: So we introduced the three challenges simultaneously, but then when we prove each impossibility result, it's going to be interesting to sort of think about. So which of these three new challenges is actually required to give that new impossibility result? So sometimes, well, we have to ask, is it the case that all three new challenges are required? Or maybe it's just one new one? What are these changes that's driving the new impossibility result? When you say the aim is now decentralization, do you have a technical definition.
00:12:18.412 - 00:12:21.410, Speaker B: Of what decentralization means, or is it just that?
00:12:21.780 - 00:12:29.636, Speaker C: No, if I had that, I might have led with that, I guess. But no, I guess we're sort of defining permissionlessness and where decentralization is remaining a vague term for us.
00:12:29.658 - 00:12:30.230, Speaker A: Okay?
00:12:34.440 - 00:12:45.636, Speaker C: So generally I want to keep everything at a fairly high level. I'm not going to go into the sort of technical details of the framework, but just to make things a little bit more concrete, I'm going to make what I've said there slightly more precise.
00:12:45.668 - 00:12:45.912, Speaker A: Okay?
00:12:45.966 - 00:13:18.236, Speaker C: So I'm just going to say the same thing again, but in slightly more precise language. Okay, so we consider a potentially infinite set of players p, although we don't have a finite number active each time slot, so we have a potentially infinite number of players p. Each player is going to be allocated a non empty and potentially infinite set of Identifiers. So the identifiers you can think of being like a potentially unbounded list of public keys of which P, such that P is aware of the corresponding private keys. Identifier sets are disjoint. We have time divided up into discrete time slots.
00:13:18.268 - 00:13:18.464, Speaker A: Okay?
00:13:18.502 - 00:13:19.840, Speaker C: Time slot one, time slot two.
00:13:19.910 - 00:13:28.020, Speaker B: Second, it may be important to emphasize that the protocol can't know any of those things. So the protocol description is independent of script, p is independent, right?
00:13:28.090 - 00:13:52.776, Speaker C: So these are not inputs of the protocol, unlike the permission set, these are just facts. So in fact about that, that will be stated lower down emphasize. Okay, so we have the time divide into discrete time slots, time slot one, time slot two, and so on up to time slot D. Let's say we call it D. The duration D could be infinite or D could be finite, depending on what you want to consider. Okay, then we stipulate. So each player can now be active or inactive in each time slot.
00:13:52.776 - 00:14:29.080, Speaker C: If a player is inactive, that means they can't send or receive any messages and they carry out no activity whatsoever. If they're active, then they can send or receive messages, and if they're honest, they'll carry out the activity as prescribed by the bridger goal. Okay, then a little bit of terminology. So by a player allocation we just mean a function specifying the Identifier set for each player and the time slots that each player is active. And we assume that the player set and the player allocation are unknown. Okay, so the protocol doesn't know that all the Veriton players I don't know that. Obviously each player knows their own Identifier set, but they don't know the Identifier sets of other players.
00:14:29.080 - 00:14:37.880, Speaker C: Okay, and then just a couple more basic definitions. So by the synchronous setting we mean a setting in which message delivery is reliable.
00:14:37.960 - 00:14:38.204, Speaker A: Okay?
00:14:38.242 - 00:14:46.544, Speaker C: So there's some known bound delta. Such whenever any sends a message at time t, it will always arrive at least by time t plus delta, if not before.
00:14:46.742 - 00:14:47.152, Speaker A: Okay?
00:14:47.206 - 00:15:18.804, Speaker C: And then the partially synchronous setting I'm defining here slightly, vaguely, but it's not that difficult to make it precise. Okay, so in the partially synchronous setting, message delivery is sometimes unreliable. You don't know when it's reliable and when it's not. But there are guaranteed to be long periods during which message delivery is reliable in this sense. And long here means like sufficiently long as long as you need in order to prove the required property. Okay, so that defines a version of the permissionless setting in which we don't yet have resources. Okay, it's not that hard to well, it requires a proof, it's not entirely trivial.
00:15:18.804 - 00:16:04.200, Speaker C: But it's not that hard to see though, that solving consensus isn't possible in this setting. So here's a more formal statement. So we consider the fully permissionless setting without resources yet, and suppose that the player set P is finite. Well then for every row, no protocol sold by Xantine, agreement went up to a row fraction of players may be Byzantine, so for every row, greater than zero. So as long as there are some Byzantine players around, consensus is not possible in this setting. So importantly though, so this result holds even in the synchronous setting, we have entirely reliable message delivery even with a known player set, as long as we don't actually know their Identifiers, even with a known player set and with all players active at all time slots. This possibility of civil attacks that drives this impossibility.
00:16:04.200 - 00:16:56.410, Speaker C: Of the three complexities we introduced, it's only the possibility of civil attacks that's required to get the impossibility here. And in fact, there are some results by Kachandani and Wattenhoffer. So they consider a setting in which you have an unknown player set but where players are always active and there's no possibility of civil attacks and there they are able to get positive results. Consensus is possible. And equally, if you can have a known player set, you can have no possibility of civil attacks and a setting where Pit players can be inactive and active at different time stops and there again, you can get positive results. Okay, so it's the possibility of civil attacks that makes consensus impossible here. Okay, so consensus isn't possible in this setting, but then obviously the innovation of the Bitcoin paper is that if we consider some notion of resource like hash rate and we restrict the resources that the adversary could own, then consensus does become possible.
00:16:57.500 - 00:16:57.864, Speaker A: Okay?
00:16:57.902 - 00:17:09.896, Speaker C: So in our framework we're going to consider resources of two types. We have external resources which you can think of as being things like asics or memory chips, and then we have on chain resources.
00:17:09.928 - 00:17:10.076, Speaker A: Okay?
00:17:10.098 - 00:17:30.188, Speaker C: So Stake is an example of an onchain resource, but there exists other forms of onchain resource and we'll talk about them later on. So external on chain resources have some fundamental differences. So first of all, external resources are generally allocated to players on chain resources to Identifiers. It's also the case that on chain resources can be selectively confiscated.
00:17:30.284 - 00:17:30.544, Speaker A: Right?
00:17:30.582 - 00:17:56.828, Speaker C: So that becomes important when you start thinking about things like Slashing. That becomes important for economic arguments. And then it's also the case that on chain resources are user relative in the sense that different players may see different versions of blockchain and so they have different ideas about who owns what. Okay, and generally it's also the case that on chain resources only change with each consensus decision. Okay, sorry, there are yeah.
00:17:56.994 - 00:17:59.004, Speaker B: Do you also draw a distinction that.
00:17:59.122 - 00:18:01.948, Speaker C: External resources are typically infinite in a.
00:18:01.954 - 00:18:06.510, Speaker B: Sense or you don't know the denominator of them?
00:18:06.960 - 00:18:21.876, Speaker C: Yes, and generally when we're dealing with external resources we'll assume that you don't know the total hash rate and that kind of thing. Although you could potentially consider settings where you do know the total hash rate and see what changes, our basic assumption will be you don't know the total.
00:18:21.898 - 00:18:26.084, Speaker B: Hash rate normally and that distinction plays an important role in proofs, okay?
00:18:26.122 - 00:18:36.280, Speaker C: So they have different properties, so we have to model them differently. So we're going to model external resources using something we'll call permitter oracles, but we won't use Oracles to model on chain resources.
00:18:37.580 - 00:18:37.944, Speaker A: Okay?
00:18:37.982 - 00:18:47.544, Speaker C: So we've got external resources on chain resources. So what I'm going to do now, I'm going to talk about external resources for a bit, then on chain resources for a bit, and then we'll just start defining the different levels of the hierarchy.
00:18:47.592 - 00:18:47.756, Speaker A: Okay?
00:18:47.778 - 00:18:56.220, Speaker C: So I'm fully permissionless downwards, so at a higher level first of all. So for each external resource, we consider what we call a resource allocation function.
00:18:56.290 - 00:18:56.536, Speaker A: Okay?
00:18:56.578 - 00:19:08.580, Speaker C: This is a simple thing, resource allocation function, just allocates each player some balance at each time slot. So you can just think of each player as having some hash rate if you like, or some memory capacity, whatever, at each time slot.
00:19:08.920 - 00:19:09.380, Speaker A: Okay?
00:19:09.450 - 00:19:51.312, Speaker C: And then so players can send requests to the permitted Oracle. So you can think of a request as being something like a request for a proof of work, like that. And then the permitted Oracle will respond depending on their resource balance. So maybe if you've got higher hash rates, you're more likely to get the corresponding proof of work that you've asked for. Okay, so this is a very high level level description, first of all. So to make that a little bit more concrete, I'm going to give an example of how we do it for bitcoin's proof of work, okay? Okay, so bitcoin proof of work to model that, well, suppose a request that any player P sends to the permit at Oracle anytime, plot T, has to be a pair of the form b sigma. So here you can think of B as being some hash rate that's dedicated to this request for a proof of work.
00:19:51.312 - 00:19:57.780, Speaker C: And sigma is the string that we're asking for a proof of work for. So this could be like a block of transactions or whatever, or a hash of a block of transactions.
00:19:59.000 - 00:20:03.216, Speaker B: This R is independent of the consensus mechanism.
00:20:03.328 - 00:20:18.170, Speaker C: So, yeah, the resource allocation function R, if I didn't say it already, I should have done, is this is unknown to the protocol. So the protocol has to operate essentially for arbitrary R and unknown R, although there are some small details there, but yes.
00:20:18.700 - 00:20:24.830, Speaker B: And conversely, the operation of the protocol does not in turn influence script R. Right? Yeah, that's right.
00:20:26.400 - 00:20:34.464, Speaker D: Andrew hello. Hi. How do you think about renting hash rate or buying it from the cloud?
00:20:34.662 - 00:20:35.890, Speaker A: Say again? Sorry?
00:20:37.780 - 00:20:42.480, Speaker D: What about a miner that rents the hash rate buys it from Amazon?
00:20:42.980 - 00:21:12.164, Speaker C: Well, yeah, I guess here we're just assuming that everybody has access to a certain hash rate. We're not particularly worried about how they're getting it at the moment. There are extra details that should be included in the model, but I'll be interested to hear it. But at the moment, we're just assuming that everybody has access to a certain hash rate at each time slot. Okay, so focusing on bitcoin, we can send requests to this pertain to Oracle at each time slot. Each request is a pair of the form b sigma. You can think of B as being the hash rate I'm dedicating to the request.
00:21:12.164 - 00:21:47.844, Speaker C: Sigma is the thing that I'm asking for approval work for. You can make multiple requests so long as you're not reusing hash rate. Okay, so I can make requests b one sigma and up to BK sigma k, so long as, as I say we don't reuse hash rates. So interpreting the BIS here as hash rates devoted to each of the requests, they don't sum to more than my total hash rate at this time slot. Okay, and that's also true for Byzantine pairs. Okay, so those are requests. And then how does the permitted Oracle respond? So to integrate with the bitcoin difficulty adjustment algorithm, we want proofs of work to have a certain quality.
00:21:47.844 - 00:22:19.936, Speaker C: So each proof of work, Oracle response is going to be a 256 bit string tau, and the quality of tau is just the number of zeros that it begins with. Then if P submits the request B sigma at times t, then the permitter Oracle independently samples beam and e 256 bit strings uniformly random responds with tau, which is the let's go back to the smallest of those. And you can think of the response here as in some sense being sort of signed by the permitter. So these proof of works can't be faked by players. Okay, so that gives us a very simple way of modeling bitcoin. Obviously, we want this to work much more generally. It should work also for like cheers, proof of space and so on.
00:22:19.936 - 00:22:44.040, Speaker C: And you can do these things. Okay, I want you to emphasize this point though. So the on chain resources don't work like this in the sense that the Stake you think I have may depend on the version of the blockchain you've seen. So with the external resources I always just have, I have a specific amount of hash rate each time slot. Okay, that's a sort of objective fact. But with Stake it's less objective, it's subjective. Different people may have different views of the blockchain.
00:22:44.040 - 00:23:04.316, Speaker C: Okay, so that's external resources. Now on chain resources in fact, though, okay, so Stake is one form of on chain resources resource. There are other forms which we'll talk about later on. For now, just to keep things simple, I'm just going to focus on Stake. So we'll come to other forms later on. Okay, so we have an initial state distribution. Certain players are allocating on zero Stake.
00:23:04.316 - 00:23:24.512, Speaker C: At the start of the process, we have transactions being issued by an environment fairly standard, and then we need some way of interpreting the transactions. So we have what we call a stake allocation function, which given any set of transactions determined to take that set of transactions said who owns which stake according to that set of transactions.
00:23:24.576 - 00:23:25.652, Speaker A: Okay? Okay.
00:23:25.706 - 00:23:38.740, Speaker C: And then so on. Chain resources like stake don't generally make much sense outside the context of blockchain protocols. So we have to define what we mean by them. So each blockchain protocol specifies a confirmation rule.
00:23:38.900 - 00:23:39.656, Speaker A: Okay?
00:23:39.838 - 00:24:16.576, Speaker C: There's a very simple thing, the confirmation rule, it's just a function that takes any set of messages, including transactions, and returns a subset of those messages. So confirmation rule just takes any set of messages, returns some subset of those any given point in time, any time slot. If M is the set of all messages received by a player time slot for sick with C, then P is going to regard the messages in C of M as confirmed. So it takes all the messages it's received and some of them are confirmed and some aren't. So generally here I'm allowing that you can confirm messages that aren't transactions. Okay, I don't know if the else here is quite standard. Right? We specify standard notions of liveness and consistency.
00:24:16.576 - 00:24:29.240, Speaker C: Okay, so liveness, as I expect people are aware, liveness basically just means that transactions that don't conflict with others eventually become confirmed. Inconsistency says the honest players eventually agree on the sell of confirmed transactions.
00:24:29.980 - 00:24:30.728, Speaker A: Okay?
00:24:30.894 - 00:24:53.360, Speaker C: And we don't actually have to set this up. So we have a total ordering on transactions here. There's a strictly easier task of implementing a payment system. You can consider that as well. Okay, so just one more brief definition before we start considering the hierarchy. So we need to define what we mean by a rowbound adversary. What do we mean by a small adversary? So most of this definition is fairly obvious.
00:24:53.430 - 00:24:53.664, Speaker A: Okay?
00:24:53.702 - 00:25:15.684, Speaker C: So we're going to say first of all, let's talk about executions. We'll say an execution of a protocol is row bounded for some row in zero ones row might be a third or whatever. First of all, we're going to talk about external resources here, okay? So first of all, resource allocations corresponding to external resources. Each allocate the adversary at most a row fraction of the total of the external resources is each time slot.
00:25:15.732 - 00:25:15.944, Speaker A: Okay?
00:25:15.982 - 00:25:33.160, Speaker C: So we're going to assume the adversary always owns like less than a half of the hash rate or whatever. That's quite straightforward. And then for stake, we make the following assumption. So among active players, byzantine players never control more than a row fraction of the stake.
00:25:33.320 - 00:25:33.692, Speaker A: Okay?
00:25:33.746 - 00:26:15.900, Speaker C: So that might that's a sort of informal version. So there's a more formal version stated there. So formally for any honest player P any times T, if Tr is a set of transactions that are confirmed for P at that time T in execution, then the most a row fraction of the stake allocated players active at T by that set of transactions is allocated by Xantine players. Okay, so this might seem like quite a sort. Of a natural assumption, basically saying, okay, look at this set of confirmed transactions. That was always allocate the bursary, almost a third of the stake or whatever. In some sense that's a slightly OD definition though because in some sense it's as much a condition on the protocol as it is on the environment.
00:26:16.240 - 00:26:16.844, Speaker A: Right.
00:26:16.962 - 00:26:51.968, Speaker C: Why is it reasonable to assume for arbitrary protocols that this is the case? You might have OD protocols that purposely try to confirm Byzantine transactions or something. That right. Okay, so what we really like is a condition on the environment. But for now this is a fairly standard sort of notion that people use. So we're going to use this notion and then we're going to come back later on and consider why maybe it's interesting and probabatic in various ways. Okay, so for now though, we're just assuming any sort of confirmed transactions, allocates the adversary, most of row, fraction of the stake, most of the third of the stake, or whatever. Okay, so that was executions.
00:26:51.968 - 00:27:03.928, Speaker C: When we say the adversary is row bounded, we mean that we restrict attention to row bounded executions. And then one more easy definition. We say a protocol is row resilient when it can deal with row bounded adversaries.
00:27:04.024 - 00:27:05.324, Speaker A: Okay? Yeah.
00:27:05.362 - 00:27:39.328, Speaker C: So row resilience just means you can deal with row bounded adversaries. Okay, so that's the end of those definitions. Now we can start defining the hierarchy and see what happens at different levels of the hierarchy. Okay, so let's define the fully permissionless setting first. Now like with resource restrictions, right? So the fully permissionless setting with resource restrictions is the same as the setting we defined earlier on where we had these three new complexities. Players can be active or inactive of an unknown player set and we also have to deal with civil attacks. But now we have the following changes.
00:27:39.328 - 00:27:57.240, Speaker C: So now protocols can make use of a finite set of external resources and combine relative to an environment that sends transactions. So now we have resources around and you're now also allowed to assume that the adversary is row bounded for some row n zero one. So hopefully that seems reasonably natural.
00:27:57.400 - 00:27:57.772, Speaker A: Okay.
00:27:57.826 - 00:28:12.320, Speaker C: And then our first main theorem here is the one that we saw earlier on, but now I'm going to state it slightly more precisely. So we consider the fully permissionless and authenticated setting. So authenticated just means we have signature schemes with no BKI.
00:28:13.620 - 00:28:13.984, Speaker A: Okay?
00:28:14.022 - 00:28:43.068, Speaker C: So consider the fully permissionless and authenticated setting with synchronous communication. Suppose the adversary is row bounded for some row greater than zero. Well then every deterministic protocol for solving a Byzantine agreement has infinite executions in which honest players never terminate. So basically deterministic protocols won't work here. Okay, so I haven't formally defined Byzantine agreement. If you know the Byzantine problem, then good. Otherwise just replace Byzantine agreement with the word consensus there.
00:28:43.068 - 00:29:23.524, Speaker C: That's fine. Okay, so that's an impossibility result for the fully permissionless setting. Okay, so now let's move on to the dynamically available setting. Okay, so the next level down in the hierarchy, slightly easier setting to operate in. Okay, so what differentiates the setting in which proof of state protocols are required to operate from the setting in which proof of work protocols are normally required to operate? Well, basically the difference is that we make stronger assumptions about which players should be active. So if you think about it, with the fully permissionless setting we kind of allow that there was stake hanging around and maybe other forms of one chain resource that we haven't talked about yet. But in some sense they're no good so far because there's no reason that anybody who has stake should be active.
00:29:23.524 - 00:30:04.752, Speaker C: So we can't make use of that fact. So now we need to actually be able to use that assumption, assume we need something that allows us to assume that those players who own stake are actually going to be active and running the protocol. Okay, so well that's just a definition of the rough description of the fully permissionless setting there to contrast with. So here's the definition of the dynamically available setting. So in the DA setting we suppose that if tr is a set of transactions confirmed for some honest player at some times t then at least one honest player allocated non zero stakes by that set of transactions is active. Okay, so you look at the players who have stake, at least some of the honest players are turning up. Then they normally would also add in some row bounded assumption.
00:30:04.752 - 00:30:56.000, Speaker C: So if you assume the adversary is row bounded then we also have at most a row fraction of active players are by Zanti. Okay, so that's very okay, so that's the definition of the DA setting here immediately is an impossibility result for the DA setting. So dynamically available protocols can't solve probabilistic byzantine agreement consensus in the partial synchrony model. So again, as I said before, the partial synchrony model is a very standard model in which most of the standard permission protocols operate. But dynamically available protocols can't solve consensus, even probabilistically in that setting. And again the way the hierarchy works, the fact this is an impossible result for the DA setting means it's also true of the fully permissionless setting. Okay, so we saw before that fully permissionless protocols can't be deterministic.
00:30:56.000 - 00:31:41.300, Speaker C: We can conjecture that dynamically available protocols can be but we haven't written a proof of that down yet. Okay, so that was the DA setting. Now let's move on to the next one, the quasi permissionless setting. So again I said there's stake, there are other forms of on chain resources and we want to define the quasi permissionless setting for on chain resources more generally. But first of all I'm going to state a simplified version just for stake and then I'll talk about other forms of on chain resource and then we'll define the general version. Okay, so this is the simplified version just for stake. So in the quasi permissionless setting, we suppose that if Tr is a set of transactions confirmed for some honest player at some time slot, then all honest players allocated non zero state by the transactions are active.
00:31:41.300 - 00:32:12.632, Speaker C: So for the DA setting, you're expecting that at least some of the honest players are turning up and participating. But in the quasi permissionless setting, we require that they all do. If, you know, that the way most of these protocols, like PBST, Tendermint, et cetera, operate, or even proof of stake implementations of them, they require this sort of condition to operate, otherwise you lose liveness. Okay? So that's a simple version just for stake. So now let's talk about other forms of on chain resource.
00:32:12.696 - 00:32:12.972, Speaker A: Okay?
00:32:13.026 - 00:32:40.912, Speaker C: So as I said, the stake is one form of on chain resource, there are others. So introduce that idea. It's useful to talk about these proof of work protocols as hybrid, solida and BIZCOIN. So these are sort of three slightly different protocols, but at a high level they all operate in a similar sort of way. The basic idea is a proof of work is used to select a rolling sequence of committees. Once a committee is selected. Imagine you're at a certain point, you got a certain version of the blockchain.
00:32:40.912 - 00:32:52.860, Speaker C: We've got a certain committee who's now like a V committee at this point in time, that's fixed for now. Once a committee is selected, they just carry out a standard permission protocol in order to implement the next consensus decision.
00:32:53.520 - 00:32:53.980, Speaker A: Okay?
00:32:54.050 - 00:33:56.892, Speaker C: They're just carrying out a standard permission protocol. That consensus decision has to include the next sequence of transactions to be committed to the blockchain, as well as determining which players are provided sufficient proof of work in the meantime for inclusion in the next committee. So we have one version of the committee. They run a standard permission protocol that determines, okay, what's the next sequence of transactions who's provided enough proof of work to be the next committee, and now we've got our next committee, they then carry out the next consensus decision and so on. In that context, I'm going to say that the on chain record that P is a member of the present committee should be seen as an on chain resource because that resource allows P, allows that player to participate in the protocol, could potentially earn rewards, could be transferable, and so on as well. That these protocols operate in some version of the quasi permissionless had to be previously justifying for stake, basically, right? Because all honest players with on chain resources are required to be active, otherwise the protocol will stall. Basically, the players in the committee are going to carry out a standard permission protocol.
00:33:56.892 - 00:34:36.300, Speaker C: And the way those protocols work is you would require all honest players to be active, otherwise they don't have liveness. So those protocols operate in at least some versions of the QP setting. So to define a general version of the quasi permission setting, we're going to allow protocols to define arbitrary on chain resources. That's quite simple. We're going to say a protocol defined resource is just a function that takes any set of messages and allocates each player some balance. And that's all that says there just takes any set of messages and allocates each player a particular balance. So those are protocol defined resources and by an on chain resource we mean a resource that's either stake or protocol defined.
00:34:36.300 - 00:34:37.164, Speaker C: So then?
00:34:37.202 - 00:34:37.356, Speaker A: Yeah.
00:34:37.378 - 00:35:07.680, Speaker C: So the general version of the QP setting I'm stating it slightly informally here, but it's easy to make formal. So protocol in the quality permissionless setting, protocols are allowed to specify a set of on chain resources s one star up to SK star, and any one of these could be stake. Or maybe none of them are stake. Whatever. And by definition an execution of the protocol is consistent with the quasi permission setting if all its players are active whenever they own on chain resources. Okay, so then we have immediately to compare the other settings. We have a nice positive result for the QP setting.
00:35:07.680 - 00:35:59.300, Speaker C: So for row less than a third, there exists row resilient and deterministic proof of state protocols that are live and consistent in the partial symphony model. So that immediately separates what's possible in the QP and the DA settings and in the fully permissionless as well. It's interesting. Another thing that sort of separates what's possible in different settings is accountability. So I'm not going to go into accountability in any detail, but people probably have some awareness. So the basic idea is that a protocol is accountable if it has this kind of property that Ethereum has, that if there is a consistency violation, then the protocol produces proof of guilt for a significant fraction of the parties. So protocols operating in the QP setting can be accountable, whereas Nusret and others have shown that protocols operating in the dynamically available setting can't be accountable.
00:35:59.300 - 00:36:11.544, Speaker C: It's another interesting separation. Okay, so to finish then, I just want to sort of reexamine a little bit the assumptions that we made here, going back to the sort of comment that I made earlier on.
00:36:11.582 - 00:36:11.796, Speaker A: Okay?
00:36:11.838 - 00:36:24.636, Speaker C: So in order to prove this theorem here, we've assumed that we've assumed that the adversity was rowbounded, right? And as I said before, there's some sort of aspects that definition that might seem a little bit suspect.
00:36:24.748 - 00:36:36.770, Speaker B: Actually, Andy, can we rewind a second? I mean, this theorem resembles statements that are made for very major layer one blockchain protocols that people are aware of. So it's maybe just worth saying a little bit about.
00:36:39.000 - 00:36:56.216, Speaker C: Generally understood as people in communities will think of this as being true. If you actually look for a formal proof of it, there isn't any in existence, at least none that we can find prior to writing one up. Okay, so we've written up a formal proof of this fact, and it's surprisingly much more complicated than you might think it is.
00:36:56.238 - 00:36:56.424, Speaker A: Okay?
00:36:56.462 - 00:37:10.956, Speaker C: So moving from the case of the permission protocols to the proof of stake implementation has a lot of difficulties, a lot of complexities. So, yeah, I encourage you to check out the proof. But it's quite a complicated so, for.
00:37:10.978 - 00:37:20.076, Speaker B: Example, even though the protocol is based on tendermint, somehow the liveness and consistency for the proof of stake extension seems to get quite a bit more complex.
00:37:20.188 - 00:37:20.988, Speaker C: Quite a bit more complex.
00:37:21.004 - 00:37:21.136, Speaker A: Yeah.
00:37:21.158 - 00:37:32.688, Speaker C: This is dealing with the changing player sets is complicated in ways that may not immediately be obvious. For this theorem, we have made this assumption that the adversary is row bounded.
00:37:32.784 - 00:37:33.236, Speaker A: Okay?
00:37:33.338 - 00:38:02.152, Speaker C: So I want to remind ourselves what that definition was. So, first of all, there were sort of two parts. Our definition part of it was kind of entirely natural. First of all, for external resources, it's fairly straightforward. We just say, okay, obviously the adversary will own less than a third of the hash rate or whatever at each time slot. For stake, it was slightly a little bit more interesting. So for stake, we basically assumed that whenever you look at any confirmed set of transactions, that confirmed set of transactions always allocates the adversary and most of row fractions of stake.
00:38:02.152 - 00:38:05.708, Speaker C: And the basic objection is, well, okay, so why is it reasonable to assume that's the case?
00:38:05.794 - 00:38:06.200, Speaker A: Right?
00:38:06.290 - 00:38:41.130, Speaker C: That seems as much as an assumption that on the protocol as it is on the execution issuing the instructions. Okay, so I want to sort of dig down on that a little bit. And to do that, I want to start off by thinking about whether or not proof of work protocols can be live and consistent in the partial synchrony model. That might seem like a slightly OD thing to do. I think it sheds some light. Okay, so in particular, I want to think about what goes wrong with the so I described bitcoin at a high level before. Again, just to remind you what goes wrong with bitcoin if we try and operate it in the partial synchrony model to remind you how the protocol works.
00:38:41.130 - 00:39:20.440, Speaker C: So we start off with a genesis block that specifies an initial committee. Now, so that's not normal for proof of work protocols, but that's what we have. With proof of state protocols, we have initial distribution. Now let's imagine we have an initial distribution even though we're working with a proof of work protocol, okay? And let's suppose that once a committee is selected, they then just carry out this permission protocol. I'm just reminding you how things work before I said this a few minutes ago. So once the committee is selected, they carry out a permission protocol to execute the next consensus decision. That consensus decision includes the next sequence of transactions to be committed to the blockchain, as well as determining which players are provided sufficient proof work in the meantime for inclusion in the next committee.
00:39:20.440 - 00:40:11.860, Speaker C: So why doesn't that work? If we try and operate it in the partial synchrony model, there's no problem with the permission protocol, right? Because permission protocols can definitely operate in partial synchrony. They can be designed so that they work perfectly well, they're live and consistent in partial synchrony. So we start off with our committee. We're doing a permission protocol which we know will function. Then we have our next committee and then just going to do the same again. So what's the problem? So the problem is that the proof of work produced by honest players might not make its way to the committee, right? So the committee that is sitting there executing the next consensus decision, they're looking to see so what proof of work has come in? But during a network partition we might only hear proof of work provided by the Byzantine players. So during a network partition we might end up with the next committee being entirely Byzantine because we've only heard proof of work from the Byzantine players.
00:40:11.860 - 00:40:16.228, Speaker C: So the next question is, okay, can something similar to that happen with proof of stake?
00:40:16.404 - 00:40:24.568, Speaker D: Do you need Byzantine players? Can't you just have a classic network partition and two parts of the network that just work in parallel?
00:40:24.744 - 00:40:41.680, Speaker C: Well, the problem here is that we're going to end up with a Byzantine majority, right? If there are no Byzantine players, then it's going to be fine. The problem is if we don't hear about proof of work from the honest players so the new committee is formed by Byzantine players and then the Byzantine players have taken over the network.
00:40:43.380 - 00:40:57.590, Speaker D: I'm thinking of an impossibility without anybody being Byzantine. Just do a partition of the network where those two different committees that form and make progress without hearing of each other.
00:40:59.240 - 00:41:17.880, Speaker C: Yeah, okay, I'd have to think about it. The main point is it doesn't work whether we require antiin players or not. I think we do, but I'd have to think through the details. Okay, so proof of work, it won't work. Let's look at proof of stake. They were asking, can something similar happen with proof of stake?
00:41:17.960 - 00:41:18.540, Speaker A: Okay?
00:41:18.690 - 00:41:35.568, Speaker C: And the answer is yes. Okay, so why is that? So I want you to consider an example which I call like the payment circle example. So here we have a set of N players. We're going to imagine that P zero, just one of the players is Byzantine. Let's call that p zero.
00:41:35.654 - 00:41:36.290, Speaker A: Okay?
00:41:37.300 - 00:41:45.044, Speaker C: Everybody else is honest and each player has one unit of stake. We're going to imagine that we have N consecutive rounds in which payments will be made.
00:41:45.082 - 00:41:45.284, Speaker A: Okay?
00:41:45.322 - 00:41:52.904, Speaker C: So in the N consecutive rounds, each player pi authorizes a new transfer of a single unit of stake to the next player in the circle, if you like.
00:41:52.942 - 00:41:53.144, Speaker A: Okay?
00:41:53.182 - 00:42:07.150, Speaker C: So in each round of transactions, each player transfers one unit of stake to the next. So each round of transactions changes nothing. Okay, so we've got N rounds of transactions. There are N transactions in each round. We have a total of N squared transactions there.
00:42:07.680 - 00:42:08.140, Speaker A: Okay?
00:42:08.210 - 00:42:23.276, Speaker C: Obviously each round of transactions here leaves things unchanged. So at the end of the story, right, when we look at the total set of all T transactions, the Byzantine player P zero still only has one over N at the total stake. Only still only has one unit at stake.
00:42:23.388 - 00:42:23.664, Speaker A: Okay?
00:42:23.702 - 00:42:27.744, Speaker C: Now though, what we want to do is to choose a particularly problematic subset of that set of transactions.
00:42:27.792 - 00:42:28.004, Speaker A: Okay?
00:42:28.042 - 00:42:35.264, Speaker C: So now then choose T prime, a subset of T to contain the first I transactions issued by player Pi.
00:42:35.392 - 00:42:36.070, Speaker A: Okay?
00:42:36.920 - 00:42:52.680, Speaker C: So if you think about things in the let's be precise, let's imagine we're in the UTXO model so that will then be a valid set of transactions. If you think that through, we end up now with P zero, the Byzantine player owning all the stake.
00:42:53.820 - 00:42:55.116, Speaker A: Okay, so we have a set of.
00:42:55.138 - 00:43:33.528, Speaker C: Transactions T, which allocates the Byzantine player one over N of the stake. We pull out the right subset and we're going to allocate the Byzantine player all the stake. Okay, so the same sort of thing happens in a proof of stake protocol or can happen as in the proof of work example I gave before. If we're doing a network partition we've got a certain set of confirmed transactions. The set of all transactions out there might allocate the Byzantine players, a small proportion of the stake. If we see the wrong subset of those transactions, then we'll end up confirming dishonest majorities. Okay, so this theorem which I'm stating just in rough thorn says sort of more precise version of that.
00:43:33.528 - 00:43:45.324, Speaker C: If we drop the assumption that the Bursary is row bound and assume instead only the set of all transactions issued by the environment, allocates the burst rate, most of row facts in the stake, we're just looking at all the transactions issued by the environment instead here.
00:43:45.362 - 00:43:45.660, Speaker A: Yeah.
00:43:45.730 - 00:44:33.696, Speaker C: Okay, then proof of state protocols can't be row resilient in the parcel synchrony model for any row greater than zero. Okay, so that sounds sort of bad, but then we can save it. So basically what was the issue here? The issue was that we had these sort of long nested sequences of transactions and the honest players were issuing transactions that relied on others before those previous transactions are confirmed. So if we restrict to a scenario where honest players don't do that, then we can save things and we can have proof of state protocols that work in the partial model. So this stops being an issue in the UTXO model, at least in the UTXO model, if no honest player issues any transaction tr until all transactions required for Tr to be valid are already confirmed. Okay, so I'll stop there. Thanks for listing.
00:44:33.828 - 00:45:08.292, Speaker E: I would like to ask about the conjecture regarding that dynamically available protocols could be deterministic. I was inclining more towards the other conjecture that they cannot be deterministic. I mean, there are dynamically available protocols that are deterministic except the leader selection part, but the leader selection part still requires a VRF in those cases. So I feel like the arguments that you could use for the fully permissionless one can apply almost like dynamically available.
00:45:08.346 - 00:45:24.584, Speaker C: Extending the proof to the dynamically available setting, I don't see how to do. My answer there, which is not entirely strong, is I have in mind certain protocols that are actually leaderless protocols or Dag based protocols, which I think will work, but I haven't written down the proof. And so if I try and write down the proof, of course you always come across difficulties.
00:45:24.632 - 00:45:24.796, Speaker A: Right.
00:45:24.818 - 00:45:35.630, Speaker C: But, yeah, I have in mind a protocol that I think will work but could turn out to be wrong conjecture. I'm not entirely sure. Yeah.
00:45:40.380 - 00:45:42.090, Speaker B: What's your favorite open question?
00:45:43.580 - 00:45:46.468, Speaker C: Gosh. Favorite open question? Well, okay, that one's.
00:45:46.484 - 00:45:46.664, Speaker A: Okay.
00:45:46.702 - 00:46:04.770, Speaker C: I guess that would give us a nice formal separation between the FB setting and the DA setting. Yes. Are there maybe questions around accountability? Are there proof of work for protocols can become accountable if you work in the QP setting and that kind of thing. Okay.
00:46:06.420 - 00:46:07.216, Speaker A: Yeah.
00:46:07.398 - 00:46:18.272, Speaker D: So you talked about how accountability is not possible in the DA setting, but it is possible in the quasi permission list. Have you thought about other properties that are possible in one setting but not in another setting?
00:46:18.416 - 00:46:20.836, Speaker C: Well, it gave you a bunch of different examples there.
00:46:20.858 - 00:46:20.996, Speaker A: Right.
00:46:21.018 - 00:46:52.290, Speaker C: So we had three at least there. So we had deterministic. You can't be deterministic in the FP setting, and you can in the quality permission setting, maybe in the DA setting. Also, you can be live and consistent in partial synchrony in the QP setting and not in the DA setting. I said accountability is a third one there, but yeah, it'd be interesting to extend that list. I guess the general conjecture is a lot of the time, the impossibility and possibility results are driven as much by the sort of setting you're operating in as whether you're on, like, a proof of work or a proof of state protocol, for example.
00:46:53.940 - 00:46:56.988, Speaker E: Looks like responsiveness would be one of those properties.
00:46:57.164 - 00:46:57.916, Speaker C: You think that's?
00:46:57.948 - 00:46:58.144, Speaker A: Yes.
00:46:58.182 - 00:47:00.688, Speaker C: So expand on that, because, like, the.
00:47:00.774 - 00:47:13.408, Speaker E: Quasi permissionless ones, because they can operate under partial synchrony, they could perhaps all be responsive, whereas the dynamically available ones require synchrony. So I would doubt if they could be responsive.
00:47:13.504 - 00:47:14.676, Speaker C: I think you might be right about that.
00:47:14.698 - 00:47:14.932, Speaker A: Yeah.
00:47:14.986 - 00:47:22.676, Speaker C: So being responsive in synchrony is fairly similar to just being lively consistent in partial synchrony. So I think that's a good conjecture.
00:47:22.708 - 00:47:23.192, Speaker A: Yes. Okay.
00:47:23.246 - 00:47:31.564, Speaker C: Let's look at that later this week, then. Any other questions?
00:47:31.762 - 00:47:47.520, Speaker B: What are your thoughts on there's this FLP analogy, right? Fully permissionless impossibility to result in synchrony versus sort of FLP asynchronous permissions. What are your thoughts on any possible connection between the two models.
00:47:50.820 - 00:48:11.030, Speaker C: A basic observation there is that there is a big similarity between the proofs. Both proofs have this basic the same basic form as a bivalency proof, where you start off in a bivalent position and you extend one at a time. So I guess there's obviously some sort of connection there, but okay, I guess, yes. We need to think deeper about whether that analogy goes deeper. I don't know.
