00:00:10.190 - 00:00:18.690, Speaker A: Very happy to introduce Zeta Avaria Kyoti, who is visiting us from Ty and will be telling us about payment channels.
00:00:19.190 - 00:00:20.100, Speaker B: Thank you.
00:00:20.950 - 00:00:59.380, Speaker C: Hi everyone. I'm Zeta. I'm a postdoc at the Technical University of Vienna and I'm going to present to you today multiple works that I did last year on payment channel networks. So I will start with brief introduction on scalability and what payment channels and payment channel networks are. I guess you all know that cryptocurrencies cannot scale. And what we mean by cannot scale is that they have a very low transaction throughput. Specifically Bitcoin and Ethereum can process tens of transactions per second, while digital payment systems such as Visa handle thousands of transactions per second.
00:00:59.380 - 00:01:43.310, Speaker C: Now, the question is, can we actually make the cryptocurrencies scale in an amount such as Visa? And there are multiple solutions proposed towards this direction because the problem is inherent in the consensus layer of the cryptocurrencies of the blockchain. And the solutions can be categorized into major categories. The first one is on chain solutions, which increases the layer one throughput. So essentially you are trying to make the blockchain itself to handle more transactions per second. And the second one is called L2. And this is an off chain solution. And what we mean by an off chain solution is that the major part of the transaction workload is handled off the blockchain.
00:01:43.310 - 00:02:31.200, Speaker C: So typical layer one solutions are designing a new consensus mechanism using other structures from a chain. You can go to a Dag or use Sharding, which is using parallel blockchains to parallelize the processing of the transactions. Typical L2 solutions are payment channels, which is going to be the focus of the talk today. And another example is side chains. There are solutions that lie in between layer one and L2, notably commit chains and roll ups. Now, most of you would know roll ups and they're sometimes considered L2 solutions, but given the fact that they have a very high on chain footprint, I would say they lie somewhere in between layer one and L2.
00:02:33.890 - 00:02:40.762, Speaker A: Thinking of like a pure L2 as having a subconstine on chain footprint per transaction kind of thing.
00:02:40.836 - 00:03:30.114, Speaker C: Yes, because the thing is, with roll ups as they are, to have data availability, you need to publish the transactions on chain. So you can have a constant compression, which is fine. But asymptotically you don't really do anything while payment channels or side chains, theoretically you handle everything off chain, just use the blockchain as a dispute resolution mechanism. So I will do a brief introduction on payment channels. If something is not clear, just stop me. So what is a payment channel? Suppose we have Alice and Bob and they want to do multiple transactions on the blockchain, but they don't actually want to use the blockchain because of the low transaction throughput, which eventually leads to very high transaction fees. What Alice and Bob can do is they can create a joint account where they lock their funds and they can use them however they want later.
00:03:30.114 - 00:04:25.460, Speaker C: So to do so, they create this transaction, which is called a funding transaction. The notation I'm going to use, or the names, is from Lightning because we're going to focus more on the Lightning network, which is the implementation of payment channels on Bitcoin. So the fundamental transaction has two inputs, which is one from Alice and one from Bob. It represents the coins they put and the output is something, it's a UTXO that can be spent by the signature of both Alice and Bob. So essentially, to close the joint account, we need both parties to agree. Now, before they open that account on the blockchain, alice and Bob give back, create the first commitment transaction and give back to themselves the original distribution of coins. So if Alice put five coins and Bob four, we create a transaction that spends the output of the funding transaction and says Alice owns four, five coins and Bob four.
00:04:25.460 - 00:05:08.410, Speaker C: The moment they have created and signed this transaction, they can open the join account on the blockchain, which we call a payment channel. Now, from that point on, Alice and Bob can transact arbitrarily many times, as long as there is enough capital to do what they want. What I mean by that is the following. Suppose Alice wants to send three coins to Bob. So what will happen is essentially that Alice and Bob will update the distribution of the joint funds to represent the new state after the transaction. So Alice had five minus three, he will have two, and Bob had four plus three, he will have seven. And Bob may want to send six coins to Alice.
00:05:08.410 - 00:05:47.454, Speaker C: Again, we do the same thing. So essentially, the coins in the payment channel, they move like the balls in a row of an abacus, back and forth. But we cannot move more than what is existing at the moment. So, for instance, in the last eight, if Bob wants to give two coins to Alice, this is not feasible because he does not own two coins. The other important thing is that the money that is locked in a payment channel cannot be used for any other purpose, any other purpose on the blockchain or any other payment channel that Alice or Bob owns. So essentially, this money is locked there until the payment channel is closed. But how do we close a payment channel?
00:05:47.572 - 00:05:54.080, Speaker A: I just want to say that's one of the more helpful previous slide, that's one of the more helpful figures to do.
00:05:57.730 - 00:06:28.826, Speaker C: Yes, because they also can't move right from one light to another. So if you want to close a payment channel, there are two ways. The first way is to do it in collaboration with your counterparty. So let's say Alice wants to close the channel. So she goes to Bob and say, okay, this is the last distribution that we had agreed on. Let's sign a transaction that spends the output of the funding transaction. If Bob agrees, we're fine.
00:06:28.826 - 00:07:11.990, Speaker C: But there is a case where Bob may not be responsive or doesn't want to sign because, for instance, he has zero money in the channel, so he doesn't care anymore. Alice should always be able to get back the money that is locked in the channel unilaterally. So what Alice would do in that case is she would publish the latest commitment transaction. I will remind you that the commitment transactions that we saw before, they're all the same. They all spending the output of the funding transaction. They just have a new distribution, which means that in the eyes of a miner, they're all equivalently valid. And the miners, they don't know how many updates have happened in the channel because only Alice and Bob know if they have done five or ten transactions.
00:07:11.990 - 00:08:03.690, Speaker C: So they cannot tell which is the latest commitment transaction. Why is that important? The reason is because Alice may benefit from publishing an older commitment transaction where she held more coins. And as we said, Bob at the moment is not reactive. So what could happen is that Alice could publish this previous transaction and the channel then would close in an incorrect state in the sense that Alice would steal money from Bob to avoid that from happening. The way commitment transactions are created makes sure that the output of Bob is always Pendable immediately. But the output of Alice, which is the party that publishes the transaction, is time locked for a period that is called the dispute period. The reason this period exists is because we want Bob to be able to go online during that period and challenge Alice in case she commits fraud.
00:08:03.690 - 00:08:22.800, Speaker C: If this happens, if Alice commits fraud and Bob challenges that on chain, then all the money of the channel is awarded to Bob. So his money and Alice's money is awarded to Bob because we want to punish the cheating party. That is a high level description of how lightning works.
00:08:26.530 - 00:08:40.194, Speaker A: Is it helpful to speak mean these days you hear a lot about fraud proofs in the context of optimistic roll ups. This is like the natural conceptual precursor to that. Is that fair?
00:08:40.392 - 00:08:58.122, Speaker C: I think it's much easier because the revocation for the bridge remedy for lightning is pretty much a secret. It's like releasing the pre image of a hash. So that is much easier than proving fraud, I guess, in the rollup, because the roll up wants like merkel proofs and stuff like this.
00:08:58.256 - 00:09:02.810, Speaker A: Right. So TikTok think it was just like a particularly simple fraud proof.
00:09:03.630 - 00:09:36.722, Speaker C: Yes. Generally I think payment channels are the initial idea and rollups were developed slowly from going to like commit chains, which is the predecessor of roll up is pretty much a structure that's like a payment hub. And they said, okay, I don't want to lock that much capital. Let's make the commit chains and then the commit chains became the roll up. So yeah, I think there is much correlation between all of these. And there are trade offs. Pretty much a trade off between a roll up and a payment channel is the onchain footprint versus how much capital you lock.
00:09:36.722 - 00:10:05.658, Speaker C: Because if you lock the capital needed to do all transactions, then you're secure. You don't need fraud proofs in that sense. You don't need that. But then the more you relax the capital, the more information you need to publish on the chain. This is how I perceive that you have zero capital. Yeah. What I described before is a payment channel between two parties.
00:10:05.658 - 00:10:51.070, Speaker C: However, the power of payment channels mainly lies on the fact that they can create a network. And what I mean by that is that if Alice and Bob do not share a payment channel, but they are connected through a path of payment channels, they can still send the transaction to each other. Now, how is this feasible? The important part is that there is a connection, like a path, where the edges are the channels and the nodes that participate in the channel are the nodes in the graph. And that path has enough capital on every edge. So, for instance, if Alice wants to send three coins to Bob, she has to have enough money on her side. Of course, it's five. Here you can see she can send the money.
00:10:51.070 - 00:11:17.954, Speaker C: And the intermediary, let's say Charlie has to have enough coins also. In this case, this is feasible. Now, there are two things that are important in implementing such an idea. The first one is that we need all the transactions in the past to happen atomically. And that means that either all the transactions go through or none of them go through. The second thing is that the intermediary does not do that altruistically. Typically they ask for a fee.
00:11:17.954 - 00:12:16.182, Speaker C: This fee in the lightning network is quite low at the moment, but this opens up a whole dimension, as we will see later for Game Theory applications. Let's see quickly how we can achieve the atomicity of transactions along a payment path. So, the tool that we use in this case, the simplest tool is to use a hash time lock contract, which is a contract that says that Alice will pay Bob a specific amount if Bob can provide the pre image of hash. Else, if the time passes by and Bob doesn't do so, the money is returned to Alice. So essentially you hash lock something and you also time lock it. You say you can take the money if you give me the secret or not take the money if you don't give me the secret during that period of time. The way we use it to achieve automicity is that we ask the receiver, in this case Bob, to create a secret that he only knows.
00:12:16.182 - 00:12:56.774, Speaker C: Send the hash of that secret to the sender. So Alice and then Alice creates that with intermediary with Charlie and says I'm going to give you that. You can take the money if you know the secret that Bob has, but within two days. And then Charlie creates a similar thing with Bob and says you can take the money from the channel as long as you do it within one day. The reason we want a decrease in timelocks is for ensuring security. Like the intermediary will never lose money in that way. So if Bob triggers that, if Bob triggers the dominance of Hdlcs, then everybody will have enough time to claim the money from the previous person.
00:12:56.774 - 00:13:02.710, Speaker C: If Pop doesn't do anything, then for all the channels the money will be returned to the sender.
00:13:03.770 - 00:13:22.960, Speaker A: So the point is the why is the same in all of yes. So as soon as somebody knows they can just copy paste that same solution, unlock the previous one. Right? What like the Y think you can just copy paste the X to get.
00:13:26.790 - 00:13:57.420, Speaker C: So this is a very old image of the lightning network. And at the moment I checked yesterday, apparently we have 85,000 channels, 70,000 nodes, huge increase. Very happy to see that. And there are multiple problems. This seems like a very nice solution, but there are multiple problems that need to be handled from routing from liquidity and we will see some of them in the rest of the talk. Now.
00:13:59.550 - 00:14:02.970, Speaker D: Is there the possibilities extending to more general organizations?
00:14:04.110 - 00:14:25.090, Speaker C: There are these things that called state channels. For instance, Sprites next week Pat McCorry is visiting, he's the author of that. He can tell you much more. In principle, yes. I don't know if it's used anywhere. I mean even payment channels are not really used in some sense. I'm going to discuss about three different directions.
00:14:25.090 - 00:15:07.638, Speaker C: The one is called rebalancing. This is the main focus of today's talk. The second will be a little bit about routing in some specific cases of graphs and a specific business model. And the last work I want to talk about, if there is time, is about game theoretical analysis of the primitive of a payment channel. So the first problem that payment channels have is liquidity. And the reason is that we lock the money in the channel for a very long period of time and this money cannot be used anywhere else. So in payment channels it is very often the channels are depleted.
00:15:07.638 - 00:16:02.910, Speaker C: And if the channel is depleted, depleted means that one edge of the channel has not enough coins. We need to top up the channel and this typically is done by going on the blockchain. Now to avoid this, there was a solution proposed, that is to rebalance channels in a cycle and this can be done off chain. Let me be more specific. Imagine we have that graph and you see the nodes and you see that the channels are you can see the capacities of the channels in both sides and with red you can see what ideally the parties would want in a channel. So for instance, in the channel between A and D, now A owns six coins and D owns zero coins. But they would like to have a more balanced, let's say distribution.
00:16:02.910 - 00:16:59.250, Speaker C: So they would say I would prefer to have three and three. Now, if we have all these preferences then we can find if there are cycles where we can move altogether atomically the money along the channels. As I said before, the money cannot jump from channel to channel. But what can happen is that we can find the minimum amount, let's say two, for which ali A will move the money to D, D to B and B to A and that will create a more balanced payment network. Now, it is important that of course no user loses money. And what do we mean about losing money is that the amount, the sum of the coins each vertex has remains the same. So for instance, a node A in the beginning had 13 coins, six, six and one and at the end again has four, three and six which is again 13.
00:16:59.250 - 00:17:57.446, Speaker C: Is it clear? The idea of rebalancing? Great. Okay, so there is an easy way to model this problem and that is that we assume that the users know how much they want to rebalance and from that we can create a directed graph where the edge capacities now represent the amount, the maximum amount you want to rebalance your channel for. And in that graph now we just need to find circulations which are flows with zero net flow for each vertex. There are two solutions, prepared solutions to our work that do that. The first one is what is implemented in synlightning and it works locally. So it's a local peer to peer search for a cycle. And that means that if somebody wants to do rebalancing, they start and they search if there is a cycle to do.
00:17:57.446 - 00:18:34.354, Speaker C: So that is actually very computationally, this is very slow. So the advantage is that it is lightweight and asynchronous every person can do it on their own, they don't need any coordination whatsoever. But the problem is that during the time that you search to find such a rebalancing cycle, the balances of the channels, because it is very slow, may change because some of the in between channels they may actually do some transactions or do another rebalancing. So what you thought that the cycle existed at the moment might fail and of course, yes.
00:18:34.552 - 00:18:49.766, Speaker D: Did you specify sort of like the goal should be that for every single channel they get closer together when you do this operation or there's some measure that says this graph is more balanced than that graph or like is there a clear specification for what the objective is?
00:18:49.868 - 00:19:22.174, Speaker C: No. So the thing is what we can say is that we want to do as much as possible, like the maximum flow, right? This is the optimal for us. But what is balanced? It depends on the two users, because for someone balanced, maybe you have ten and you have 100, because the A node sends more money, typically to B for another one, maybe 50 50. So you don't know. This is why we say we ask the users what they want to rebalance for and then we create the graph.
00:19:22.302 - 00:19:33.822, Speaker D: So the idea is that every user would say I like this better than this, and if all the users in the cycle like this better than this, then this is what it's like.
00:19:33.976 - 00:19:51.834, Speaker C: Yes, it's not exactly user because it's more like a channel. The two people have to agree in the channel. But yes, the idea is everybody submits their wants and if the wants match, or the minimum amount for which they match can be rebalanced just to follow.
00:19:51.872 - 00:20:02.160, Speaker A: Up, understand the constraints. So you get a number for each payment channel along the direction, sort of the ideal amount to move.
00:20:03.650 - 00:20:04.800, Speaker C: Okay, good.
00:20:05.890 - 00:20:07.722, Speaker A: I was going to say what's the optimization problem?
00:20:07.796 - 00:20:48.330, Speaker C: Yes, exactly. So that goes to the second work, because I told you what is this? The main thing for the local search is that it's not optimal. Also, so Arthur Geverse three years ago proposed Revive, which is an opt in protocol, and they modeled the problem as a linear program. And the optimization is simple. We have the capacities, which are the amount that we want to rebalance, we want the flows that maximize the sum of flows. Let's say we want to maximize the amount of flows through the network. We have to respect the capacities on every edge and we need to preserve the flow on every vertex.
00:20:48.330 - 00:21:15.510, Speaker C: That's it. The problem with this work is that I'll explain first how a high level so the idea was you somehow select a delegate and then this delegate gets all the constraints from every user, computes the solution, returns it to the users, then the users verify it's a correct solution and they agree to execute it or not. And if they all agree, then they do an atomic execution across the whole network.
00:21:16.890 - 00:21:19.510, Speaker D: Sorry, can I ask another question about this?
00:21:19.580 - 00:21:20.246, Speaker C: Yes.
00:21:20.428 - 00:21:34.460, Speaker D: So the capacities are the actual capacities of the channel. So the capacities are input by the channel, they're input by the owners of the channel to say this is the maximum that I would like to got it.
00:21:35.150 - 00:21:44.670, Speaker B: Is it fair to say, like, it's assuming that the utilities for each edge, for each pair of nodes is like linear in how much we balance it if we do?
00:21:44.820 - 00:22:24.138, Speaker C: You could say that, yes, it is an underlying assumption. Yes, I would say so because you want to maximize the flow. If it was not linear, it would be a different function, I guess, because it would be, for instance, more important to have one channel that is more full to the balancing request or a lot of channels that are all of them a little bit. So yes, it is an underlying assumption. So the main disadvantages of the problem is, first of all, you have lack of privacy completely because you have just one delegate. The delegate gets every information and then it returns the whole solution. So everybody sees everything.
00:22:24.138 - 00:23:12.678, Speaker C: Pretty much. The second is you have no robustness. And that is because, as I said, when every user gets back the solution, they can choose or not to take part in the execution. Then if one party, one player disagrees and doesn't want to go through with it, the whole solution is unimplementable. Let's say you can execute it and the third is minor, but it requires smart contracts so it's not compatible with Bitcoin. So in a work that we presented this year on financial crypto called hide and seek, we tried to solve exactly these problems. So the properties that we wanted was to have an opt in protocol that is applicable on Bitcoin and has four major properties.
00:23:12.678 - 00:23:57.850, Speaker C: The first one is security. By balance conservation we mean that no node loses money. The second is privacy. So we wanted the users to know exactly what they would need to know to execute an HTLC. So if you're in a cycle, your predecessor, your successor and the amount that's it any further information should not be revealed by the protocol. Of course we wanted to maintain optimality, so we wanted to maximize again the flow that goes through the rebalancing protocol and we wanted to increase robustness. And by that we mean if have some fault tolerance, if some person doesn't want to participate, to not break down the whole execution.
00:23:57.850 - 00:24:52.262, Speaker C: Now, a high level description of our protocol is as follows we have two phases. The first one is the exploration phase and the second the execution, the exploration phase. We again formulate the problem as a linear program min cosplo problem actually. And then what we do is we select k nodes at random using, for instance, cryptographic sortition. It's not important, it's adaptable how you choose a node and then every user secret shares their constraints to this k node. Then these k nodes run a multipart computation protocol and return later to the users the results that are only relevant, the flows that are relevant for them only. Now, during the execution phase, the execution phase is done with basic HTLC.
00:24:52.262 - 00:25:45.680, Speaker C: And the reason we can use HTLCs is that because before we execute the solution we decompose it to sign consistent cycles. What do I mean about with that? I mean that if we have, for instance, the normal solution that for instance revive would return would be the sum of the blue and the red cycle. So it would be 1010 horizontal, four, six, six. But what we do is we break the flow in same consistent cycles such that we increase the robustness so for instance, if the node C decides to not participate, that does not affect what happens in the red cycle. Right. It only affects what happens in the blue cycle. So our goal is to create as many cycles as possible.
00:25:45.680 - 00:26:15.174, Speaker C: Now, the other advantage is that we need the cycles to be signed consistent, because if they're not so in this example, the node may have incentive to sign the one HTLC go in one direction, but not the other one because it goes against the rebalancing request that the node asked for. But this can be done. It's an algorithm that already exists. So yeah, we just use it.
00:26:15.212 - 00:26:19.750, Speaker A: It's called conformal. Conformal.
00:26:23.310 - 00:27:08.802, Speaker C: Okay. And the last important thing to note is that MPC generally is a very heavy tool. But in our case, we believe we have not run simulations that it can run in a few minutes. And the main reasons are, first, the number of delegates that can be very small, like three, four. And as long as we have one correct, then we have one honest, we have privacy and correctness. The second is we don't use generical P, but we use a Min cost flow formulation, which is apparently is faster. And the last one is that the structure of our problem guarantees that we have an integer solution, which means that we use integer arithmetic, not floating point arithmetic.
00:27:08.946 - 00:27:11.720, Speaker A: So comparing that to the revived thing.
00:27:13.710 - 00:27:17.660, Speaker C: They don't have NPC, I understand there's a couple things.
00:27:18.110 - 00:27:20.614, Speaker A: They clearly don't have privacy.
00:27:20.662 - 00:27:21.274, Speaker B: I agree.
00:27:21.392 - 00:27:30.320, Speaker A: But maybe they do have the energy solution property, I would guess. And I would think they would also have the conformal decomposition property.
00:27:31.410 - 00:27:32.910, Speaker B: They don't.
00:27:34.610 - 00:27:37.962, Speaker A: Or I think you could do it. That's sort of a generic property of flows.
00:27:38.026 - 00:27:50.930, Speaker C: Yes, you could do it because what we did is essentially took Revive and tried to fix the problems one by one. So, yes, if you apply our algorithms to revive, you land up with hide and seek.
00:27:51.270 - 00:27:59.320, Speaker A: So there's some parts that you said revive had it and it's good and you also have it and it's still good. There's other parts that I didn't have.
00:28:00.890 - 00:28:51.314, Speaker C: Yes, that's it. Yes, revive had the optimality now you have privacy and robustness and I don't remember the third point, but yeah. Now I would like to talk about an ongoing work that is building on top of hide and seek. It's with some of the co authors of hide and seek and that is more directed to the people that work on auctions here. I would be happy to have some input because we're stuck. So naturally, when you do rebalancing, you think first to involve the participants that want to rebalance. But since the fees in Lightning, for instance, are very low, it could be that most of the people that want to rebalance would be willing to pay a very low fee to the people that are intermediaries.
00:28:51.314 - 00:29:38.546, Speaker C: Right. So the same way that a transaction can go through and the intermediary asks for a fee the same way the intermediary can enable a rebalancing cycle and that is probably much less costly compared to actually going on chain and topping up the channel. So now this creates a new question. We have the service providers that are willing to get some money by enabling the people to rebalance and we have the people that want to rebalance and are willing to give some money for this purpose. So essentially what we have is users that submit bids that are positive, these are the buyers. So the people that want to rebalance and some that have negative bids which are the sellers that want to get money for this purpose. Now we have an optimality sheet.
00:29:38.546 - 00:29:53.770, Speaker C: So before we wanted to maximize the flow, now we want to maximize the social welfare and we end up with a mechanism design problem. So the questions we want to answer is how to make the users submit their bids truthfully and to do so we need to answer how do we price the cycles?
00:29:54.910 - 00:29:57.530, Speaker A: What's the semantics of a bid? Exactly?
00:29:57.680 - 00:30:11.120, Speaker C: The semantics for bid, okay, it depends on which model. But the simplest would be I would help to do one unit of rebalancing for 0.1 unit of payment.
00:30:11.650 - 00:30:21.860, Speaker A: Even simpler, just like either do this specific rebalance and I'll pay you something or don't do it and I'll pay you nothing. That's kind of just like the two.
00:30:22.470 - 00:30:31.078, Speaker C: I would say it's more like a double auction. I would say like I'm willing to give up to that amount of money. You want at least that amount of money.
00:30:31.244 - 00:30:34.486, Speaker A: Oh, I see. So from the intermediaries you're also taking bids?
00:30:34.598 - 00:30:34.874, Speaker C: Yes.
00:30:34.912 - 00:30:36.250, Speaker A: You're having bids for both?
00:30:36.400 - 00:30:37.100, Speaker C: Yes.
00:30:39.470 - 00:30:45.900, Speaker B: Is it that every node submits a bid and every edge as well?
00:30:46.770 - 00:30:49.770, Speaker C: Yes, every edge. Every edge.
00:30:49.850 - 00:30:53.546, Speaker B: So the intermediaries just think of them as the network.
00:30:53.738 - 00:31:12.770, Speaker C: It's like the intermediary. Yes, it can be. Imagine it's like an edge. Yes. I mean it is a vertex, it is a node, but the node is using a specific channel if that node sends the money. So he's losing capital on his side. He's the only one getting a fee, the other one is gaining, he doesn't need a fee.
00:31:12.770 - 00:31:24.810, Speaker C: So that's the idea. So yes, it is an edge where the sender is only getting a fee. That's generally the idea of providing a service and asking for a routing.
00:31:29.390 - 00:31:52.338, Speaker A: Question. So we should think about like each node is like getting paid interest on whatever capital they have. And so you're saying basically more stuff comes to you, you're also getting paid off just sort of form of additional interest, whereas the other side of the edge is sort of losing the capital and then you're sort of, in effect, refunding them. Lost interest?
00:31:52.504 - 00:32:24.278, Speaker C: Yeah. You're paying the opportunity cost of being able to send that money for someone else, for instance, or doing something for their. Own. Good. So typically what the fees enlightening is one satoshi plus zero point 33% times the value. So it's a base fee plus a constant times the value. So in this auction, pretty much what are the properties that we want? Ideally we want optimality, of course, which is called economic efficiency.
00:32:24.278 - 00:33:06.538, Speaker C: We want incentive compatibility. So we want the users to truthfully tell us their bids. We want rationality, which means we should never charge the players more than the bids and we finally want strongly budget balance and that is what creates the most problems for us. So we want the zero net flow to maintain for every betax. And that is important because at the moment at least I'm not aware of a way to burn money in a channel. So due to the construction, the primitive construction of payment channels, we cannot have a weekly budget balance and we know that these for properties are impossible. So now we go and see what we can do.
00:33:06.538 - 00:33:08.940, Speaker C: Now, the first idea of course yes.
00:33:09.310 - 00:33:13.210, Speaker A: Does budget balance include the fees or is it not including.
00:33:15.310 - 00:33:41.550, Speaker C: Okay, let's ignore the fees. Yeah, typically yes, you have to transmit the whole thing with the fees. Yes, but the fees are very small in comparison typically to the whole volume. Yeah, but yes, you have to transfer the fees around the cycle. For instance, if you're relative to each.
00:33:41.560 - 00:33:44.120, Speaker A: Other right, they have some non zero value.
00:33:44.570 - 00:34:30.978, Speaker C: Yes, but in that aspect we don't require a zero net flow because I mean, you have to take into account what is paid. Yeah, formally yes. And actually we want a property that is stronger even than that because that in a graph. Strongly budget balance would mean that a vertex that can have like three edges, you want these three edges to sum to zero. If we use assigned decomposition, the cyclic decomposition, we want cyclically strongly budget balance. We want every single cycle to sum up to zero. Now, the first idea of course was to use first price auction in the sense that we price someone their bid minus the social welfare divided by the number of questions.
00:34:31.064 - 00:34:48.700, Speaker B: So what are the think of the bidders as the edges on the setup function that the degree of the edges come from? If you're saying truthful, what is my function? Like.
00:34:50.990 - 00:34:57.260, Speaker C: I would say what you rebalance minus what you pay.
00:34:59.070 - 00:35:09.540, Speaker B: It'S a linear function and how some ideal like in the previous world I would have submitted five and now my utility is again.
00:35:10.150 - 00:35:11.700, Speaker C: Okay, let me think.
00:35:15.990 - 00:35:35.610, Speaker A: That term utility is pro rotated with respect to how much was filled is my interpretation. If I declare that its value is ten to me to be filled to move five and then eventually move three, then my utility is like ten times five thirds. Sorry, ten times three fifths?
00:35:36.510 - 00:35:41.530, Speaker C: Yeah, I would say ten times three fifths.
00:35:44.190 - 00:35:47.950, Speaker A: Is a bit both the price and quantity. Two numbers.
00:35:48.100 - 00:36:20.680, Speaker C: Yes. And it is linear? Yes, the function, it is linear. So here, for instance, what did we do? We took the bids and we priced the people with the bid minus what they gained. The social welfare divided by the number of the participants. So we had the same problem as first price auctions? Pretty much. Which is if you want to be included, you are motivated to overbid. But if you have the solution, you want to underbid because you pay less.
00:36:20.680 - 00:36:23.430, Speaker C: No incentive compatibility.
00:36:26.110 - 00:36:39.370, Speaker D: So what you're saying is strongly budget balance. This is referring to kind of like the allocation or like if you forget the fees, you need to do something as strongly budget balance.
00:36:39.450 - 00:36:40.814, Speaker C: You need to solve a problem.
00:36:40.932 - 00:36:52.820, Speaker D: But after doing this you can charge people whatever you want for the solution. Like if for some reason this solution is very valuable to me, you would definitely charge me a whole bitcoin or something.
00:36:53.990 - 00:37:28.078, Speaker C: No. So the way to find the solution, we have no problem because then you can use differential privacy. The problem we end up having is always pricing the one cycle, like you have done. You have a solution, you have the composition and then you have this situation where people have submitted this. For instance, these are the bids, how do we price it? We do not have a way to do that. Incentive compatible and maintaining the zero net flow around removing the fees. Yeah, this is the problem.
00:37:28.164 - 00:37:31.630, Speaker D: I think I'm confused how you charge prices.
00:37:32.850 - 00:37:34.750, Speaker C: It depends on which solution.
00:37:35.570 - 00:37:40.930, Speaker D: In any solution, what are the mechanics by which you charge prices?
00:37:41.590 - 00:38:06.970, Speaker C: This is exactly what we're trying to solve. So given the bits right, for instance, in the first solution, as I said, we used the bits minus the social welfare divided by the number of participants. Here we run the problem multiple times. For instance, we removed some participants, some cycles broke down, we solved the problem again, then we saw how much was beneficial. Typical VCG.
00:38:08.830 - 00:38:25.342, Speaker D: How do I pay? Like, if everything has to be strongly budget balance, then my payment is always zero. How do you charge payments? Or can you charge payments? Or what are the constraints on the payments you charge outside of the channel?
00:38:25.396 - 00:39:02.700, Speaker C: You don't have to be so in payment channels, you can send more. I mean, it doesn't need to be the rebalancing need to be zero flow. The fees that you send are whatever you want as long as there is slack. The slack also we assume it exists because that is also something that is a hidden assumption. We assume that we have the space, the capacity in the real channel to send these fees around but typically they're very low. That's why we assume that. So, yeah, in any solution that we tried, we ended up always having that problem and we don't know how to solve that problem.
00:39:02.700 - 00:39:33.622, Speaker C: No, just what is so these are the bids. So let's say unit flow. Okay. And A to D says, I'm willing to pay up to ten to do that unit flow, then one, then one, then minus one. How do we divide that such that the people will truthfully tell us the bids and the flow will be also zero net. Yeah.
00:39:33.756 - 00:39:36.706, Speaker A: So can you go back to your list of properties?
00:39:36.898 - 00:39:37.640, Speaker C: Yes.
00:39:41.790 - 00:40:07.920, Speaker A: What really drives the impossibility here is one in four. It's just really at equilibrium you're not going to get welfare optimality and posture balance. That's kind of a very robust fundamental possibility result, you're going to relax something. One of those two has to be relaxed for anything to be possible, I think.
00:40:10.050 - 00:40:11.230, Speaker C: Which one? How much?
00:40:11.300 - 00:40:24.130, Speaker A: Because well, so it depends which I mean, it sounds like your application may insist that four cannot be relaxed, in which case the only question in some sense is minimize the welfare loss so fit to all the rest of your properties.
00:40:24.290 - 00:40:27.798, Speaker C: Okay, yes, I like it's convenient and.
00:40:27.804 - 00:40:32.120, Speaker A: It'S truthful, but that's not actually I wouldn't say that's sort of fundamental to the design problem.
00:40:32.650 - 00:40:37.114, Speaker C: If you can find easily how to manipulate the price to gain more or.
00:40:37.152 - 00:41:00.800, Speaker A: Less, you really care about the outcome. You don't really care about the manipulation so much, you just care about add equilibrium. Again, it's convenient if it's very straightforward to figure out how to participate. But if you had it first, price auctions are not truthful, but they're actually very useful. They still do good things. So even if you had like a non truthful but at equilibrium had bounded welfare loss, I think that would be the amazing result. For example.
00:41:02.690 - 00:41:42.110, Speaker C: I'm really not an expert on this topic, trying to understand most of the things while we are writing this. Now I will move on to routing problems. So the first paper, this is wiser, I will explain a bit. So it's motivated by noticing a behavior in payment channel networks where wealthy participants create multiple channels. They are charging fees to route transactions. So this is a way to gain money. So we assume we have a business model where we have payment hubs and these payment hubs are connected to clients.
00:41:42.110 - 00:42:17.020, Speaker C: So the clients, they're not connected any other way with each other, just through the hubs, much like banks. So that structure of course is very beneficial because you have high and reliable transaction throughput. But it has some problems. Again, the first one is that you are bound again by the liquidity of the hubs. So that is the bottleneck for the transaction throughput. Then you have the fees you have to pay in the hubs that ideally at the moment would be proportional to the amounts you're sending. We would like to reduce that.
00:42:17.020 - 00:43:00.898, Speaker C: And the third is that you have no privacy for the users. So in our new work just got accepted at IFT we propose a solution that's called wiser that comes from TransferWise and we try to use transaction Aggregation to solve these three problems. The first one is we want to increase the transaction throughput as much as possible. The second is we want to reduce the fees that the clients pay to the hubs. And the third is to enhance the privacy of the transactions. I mean, all of these properties are done are achieved optimistically. In weird edge cases, you may have zero improvement to doing classic transactions.
00:43:00.898 - 00:44:13.950, Speaker C: And by classic transaction I mean to do transactions sequentially. So the main idea for Transaction Aggregation is that instead of doing every transaction in the payment hub like here, one by one, when they come, you wait for a period of time and then you aggregate all the transactions and you execute them. Atomically to see the benefit of Transaction Aggregation, I will explain the two examples because it's dual. The first part is that Transaction Aggregation allows transactions to happen that in the normal payment network sequentially, they wouldn't be able to happen. Now assume that you have three transactions, one from v one to v three for ten coins, another one similar v one to v three for ten coins and a transaction from v four to v six, again for ten coins. In that payment network where you can see the balances are denoted by the number and where there is none is zero. This is not possible because there is no capacity of ten in each of these paths.
00:44:13.950 - 00:44:59.710, Speaker C: But if you aggregate the transactions, what you notice is that the first or the second is the same and the third transaction are possible. Why? Because when you see the problem in the Transaction Aggregation, you can consider the following what you really want is v one to send ten coins and v three to receive ten coins. You don't really care to route it through the network. Then you want v six to receive ten coins and v four to send ten coins. So what you can do is essentially the same idea as transfer wise does. You can send from v one to v six and from v four to v three where you have the availability and just make sure that these two things happen. Atomically and that demonstrates mostly what is the gain from Transaction Aggregation.
00:44:59.710 - 00:46:12.866, Speaker C: The other part that we gain is that we can use some canceling out effects and that effectively reduces the fees a lot. For instance, in the graph, the left graph, you can see in the bottom that has a transaction vector and it says, okay, that v three wants to send five coins to v five and then v five to coins to v three. If you do it sequentially, you would do two transactions and you would pay seven coins in total for transaction fees if you aggregate them because they cancel out each other, you just send one transaction for three coins from b three to b five. And then the fee that goes proportionally to the amount that you send is reduced more than half. So I think these are the most important examples. What we have open and what is very interesting and wiser doesn't do it, is that theoretically, you could have a transaction vector that says v three sends 20 to v five, and then v five sends twelve to v three. And that in principle is feasible because they cancel out of eight.
00:46:12.866 - 00:46:30.860, Speaker C: However, we have in our protocol, this is not feasible. We have constrained it so that is open at the moment. This problem is also present in finance. It's called netting in the interbanking settlements, and it's a notion of decentralized transfer wise system.
00:46:32.750 - 00:46:36.870, Speaker E: Can you go to the diagram? I actually apologize for the diagram.
00:46:37.030 - 00:46:37.866, Speaker C: For the what?
00:46:37.968 - 00:46:40.366, Speaker E: For this diagram wants to pay v.
00:46:40.388 - 00:46:53.282, Speaker C: 3510 coins in the beginning no, I said five coins from three to five and two coins from five to three. So they cancel out five minus two coins is three.
00:46:53.416 - 00:46:55.938, Speaker E: Five coins from v three to v five?
00:46:56.104 - 00:47:14.850, Speaker C: Yes. So you can see it here. Like this is v three. The third position sends five coins to the last position, which is v five. And then again, v three receives from v five two. So it's just going from three to five and five to three. They cancel out if you aggregate them.
00:47:14.940 - 00:47:18.540, Speaker E: So what is the bottleneck for the payment?
00:47:19.790 - 00:47:20.522, Speaker C: What do you mean?
00:47:20.576 - 00:47:24.074, Speaker E: No, so what was the transaction that was impossible before, but is possible now.
00:47:24.112 - 00:47:26.934, Speaker C: With aggregations that is here?
00:47:27.072 - 00:47:28.634, Speaker E: Yes. So what was impossible?
00:47:28.762 - 00:47:42.500, Speaker C: What was impossible is to send ten coins from v one to v three and then ten coins from v four to v six. This is not feasible in this network because you don't have the capacities. But if you take the four between.
00:47:42.870 - 00:47:47.778, Speaker E: Four the bottom yes, it's the four four four.
00:47:47.864 - 00:47:52.286, Speaker C: Yes, this is the maximum. You can send something more basic.
00:47:52.318 - 00:47:54.690, Speaker A: Are those two diagrams supposed to be equivalent?
00:47:58.790 - 00:48:11.130, Speaker C: No, completely related example? Yes, it's the one to show that it is feasible to the transactions that you couldn't before. The other is to see there can be a canceling out that reduces fees.
00:48:11.790 - 00:48:18.842, Speaker E: So v one and VV one are exchange ten coins, but the bottleneck is four. So how is the aggregation solving?
00:48:18.986 - 00:48:44.120, Speaker C: Okay, so the way you can look at it is that v one must send ten coins, v three must receive ten coins. Equivalently, v six must receive ten coins, and v four sent ten. So what you can do is have v one send it to v six, and then v four send it to v three and do that atomically. And you guarantee that everybody has done what they should, although the paths do not allow. So, and this is interesting, because you can have even disconnected drafts doing it.
00:48:46.250 - 00:48:50.806, Speaker E: The aggregation part is just that you're taking two separate transactions and doing them together.
00:48:50.988 - 00:49:05.600, Speaker C: Yes, not even two, it's multiple. Yes, but that's the main idea, you wait for a time and you take all these transactions and you cancel out all the effects and then you have transaction throughput that is higher because more flow is feasible in that way.
00:49:06.370 - 00:49:10.590, Speaker E: So for the right diagram, what is the bottleneck and what was installed?
00:49:11.650 - 00:50:44.870, Speaker C: Okay, the bottleneck for the right diagram is that in our solution we use a check at some point that the individual amounts are below the capacity of the channel and we use it in the solution, in the algorithmic problem solution. And that forbids something that should be feasible, which would be if node five wants to send to node 320 and the node three wants to send to 512, the canceling out is eight is below the capacity of the channel. That should be pretty visible, but we need it for other purposes. So yeah, that's why it's kind of open again, the high level idea is that we have accumulation of transactions, we solve the transaction aggregation problem, we get the resulting flow, we check that the flow is correct and then we execute it. How do we do that? Similarly to before, we select some nodes from the hubs that have online and they have high computational power with secret share, we solve a problem again with NPC. And the interesting part here is that the problem generically is anti hard for transaction aggregation in a generic network. But due to our structure, we use a fixed parameter linear algorithm that Translinear to the number of constraints and exponential to the number of hubs that we select for the execution, we need to have atomic execution, not like the previous work, but like revive.
00:50:44.870 - 00:51:18.390, Speaker C: So to do so, it's not that easy, but there is fortunately a work we can use, it's called Thora, a very recent paper also that makes sure that we can do that. The gains that we have is that we have computational feasibility for a problem that is generally not feasible. No user loses money, we have maximal throughput, we are cost efficient in the sense that we reduce the fees as much as possible and we are private and we show that by defining an indistinguishability gain.
00:51:19.290 - 00:51:21.350, Speaker A: Sorry, what is FPL?
00:51:21.850 - 00:51:40.878, Speaker C: Fixed parameter linear fixed parameter actable algorithm linear to the in what parameter? It's linear to the users, for us, to the clients, let's say what's the parameter? The exponent, right.
00:51:40.964 - 00:51:42.314, Speaker A: What parameters in the exponent?
00:51:42.362 - 00:52:11.960, Speaker C: It's the number of hubs that we select. Yes. For future work we would be interested if of course we can have a more generic graph. As I said, it's an empty hard problem. But this doesn't say that we cannot have an approximation algorithm that is good enough. So this is open at the moment, we haven't even started working on it. Now I will very briefly go through the high level of what we did in these two left work because I'm running out of time.
00:52:11.960 - 00:53:54.790, Speaker C: Now, the main idea for this paper is that we wanted to find how to find routes in a payment channel network where we don't know the topology and our motivation was taproot. So in Bitcoin so far, if you had a channel opened, everybody could see the creation of the channel but after taproot that is not true. So that means that we can have a private network completely if the users don't want to say that they have a channel so that makes routing much harder, which was anyway hard before and we wanted to have something that is private so it doesn't leak a lot of the topology that is efficient and of course that is optimal in the sense that we find the cheapest route. The very high level idea is that we have both the sender and the receiver propagate information encrypted messages in the network, and we use Bilinear maps in a way that we can have the intermediaries connect the messages if they receive the message that is from the same sender and receiver and that intermediary can then backwards propagate the path discovery to the sender and receiver and they can stop the propagation of the message that is very high level. We want the first phase, the first Propagation phase, to be quite slow so the rest can effectively stop it from happening later. And we assume that the address set is passive and that we demand that the nodes propagate the messages with a delay that's proportional to the speeds so we can find the cheapest path first. That's a high level idea.
00:53:54.790 - 00:54:41.080, Speaker C: We have open problems such as how to quantify privacy leakage. Because if the addresser is positioned close to the sender and close to the receiver, so gets the message from two sides. They can infer a lot of information. About the topology in theory you can do it in topology hiding manner using MPC but that is out of the question for practicality reasons here and of course there is an efficiency, optimality and privacy trade off that has to do with how much you load the network with communication, so to how many people you send the message. So if you send it to every one of your neighbors, you find a solution that is optimal. But if you send it to one of your neighbors, we measure that you on average, find twice as worse solution. And all of this space in between is open.
00:54:41.080 - 00:55:47.950, Speaker C: And for the last part, this work was also published in Financial Crypto this year. And it has to do with a primitive construction of payment channels. As you remember I said in the beginning that if Alice commits fraud she can publish a commitment transaction that's sold and then Bob creates this challenge and goes on chain and says to the miners give me the money because Alice cheated. That would be true if the miners are willing to include the revocation transaction which is the one that gives the money to Bob but eilis in that case can actually bribe the miners to not do so. So what she does is she creates a transaction that says, if you don't include the revocation after my timeout expires, I will give you this amount of money. And that creates a game. So the miner, at every time step, at every block generation, has to decide between including the transaction from Bob that gives him a fee that is small, or wait for a specific period of time and include the transactional files that gives them a higher fee.
00:55:47.950 - 00:56:26.620, Speaker C: And we studied when this is an as equilibrium, we set the parameter space. We proposed a solution where Bob can counter bribe pretty much, and for which amount bob, the channel is still secure because Bob has the slack to counter bribe. And we ended up with two specific cases, but the space in between is again open. So for very small bribes or very large bribes, we have a solution, but for very close, the bribing of one and the other being very close, we don't know what happens.
00:56:31.390 - 00:56:47.946, Speaker D: If Alice is herself a minor. Is it like, does the game change in the sense that if Alice kind of convinces Bob to put a large prize to minors, alice just gets that price because she herself is a minor?
00:56:48.138 - 00:57:21.546, Speaker C: Yes, it changes and also changes in a specific for the case that we discussed, not really, but for the space in between, which is the most probable to happen, it actually changes because you can do other types of attacks. If you have mining power, like feather forking, you can say, okay, I'm not going to mine. On top of that, if you include the revocation transaction, and there are papers that show that this is actually a good attack, miners will not mine the revocation stuff like this. So, yes, this is not studied at all. There is a parameter space that's can.
00:57:21.568 - 00:57:26.154, Speaker D: You clarify the regime where you're saying that the channel actually is secure?
00:57:26.282 - 00:57:59.880, Speaker C: Yeah. So actually the channel is not secure. This is what we find. We say that if the bribe is, as you see, ignore the F. The F is essentially the unrelated transaction fees. So we don't care. So if the bribe is greater than the fee of the revocation transaction divided by the computational power of the weakest mining pool is when you should always wait to get Alice's bribe pretty much.
00:57:59.880 - 00:58:34.130, Speaker C: Then obviously, if you have the fee of the revocation higher than the bribe, so the counter bribe higher than the bribe, you're fine. So like this, our solution for lightning, for instance, was very simple. We said, okay, calculate in the last eight how much money you had. Eight. What's the total money you can get if the revocation is included? 15. So you can bribe for seven. Is that greater or less than what Alice did? Then you know the security of your channel pretty much.
00:58:34.130 - 00:58:37.534, Speaker C: When you sign a transaction, if that is incentive compatible.
00:58:37.662 - 00:59:00.940, Speaker D: For the point is that if Alice could get seven by being honest, and she's trying to cheat to get more, then Alice is losing the seven. And so that creates some spread where it's possible for me that I actually have an advantage over her. And even if she's a minor receiving the bride, that it can still be not good for a good move for her to do.
00:59:02.030 - 00:59:05.800, Speaker C: With this, I conclude my presentation, so feel free to ask any other questions you want.
