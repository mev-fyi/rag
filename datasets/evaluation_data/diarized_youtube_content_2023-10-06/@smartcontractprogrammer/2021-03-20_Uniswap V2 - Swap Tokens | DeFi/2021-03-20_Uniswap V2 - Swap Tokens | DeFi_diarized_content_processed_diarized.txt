00:00:00.490 - 00:00:49.642, Speaker A: Hello everyone. Today I'm going to show you a basic example of how to swap a token for another token using Uniswap. So in this video we'll write some code in here and then we'll also write some test and then run this test against the main network which I've showed you how to do in the previous video. Before we start coding, let's take a look at uniswap. I want to show you what it looks like to trade a token for another token. So let's say that we have some die and we'll trade some die for WBTC which stands for wrapped bitcoin. And let's say that we have 1000 die then this means that if we have 1000 die then we'll be able to trade for 0.178,152
00:00:49.642 - 00:01:18.258, Speaker A: WbTC. Now uniswap is a decentralized exchange. So this means that there isn't a centralized server that figure out the price of one token for another. In other words, the exchange rate that you see over here. In this case the exchange rate from Dai to WBTC is determined inside a smart contract. How the price is calculated is a topic for another video. Today I want to show you how to trade one token for another using smart contract.
00:01:18.258 - 00:02:05.714, Speaker A: Back inside of our solidity code, we first need to import some interfaces. Interface to ERC 20 and interface to Uniswap. Inside the interface for uniswap we're going to need to call a smart contract called Uniswap B two router and the function that we're going need to be calling is called swap exact tokens for tokens. As the name suggests, this will allow us to swap a token for another token. The parameters that we need to pass into this functions are amount in, the amount of token that we want to trade in for amount out mint. The minimum amount of tokens out that we want from this trade path is a list of token addresses that we want this trade to happen. I'll explain about this more later.
00:02:05.714 - 00:03:07.518, Speaker A: Two is the address of the token that we're going to be sending the output tokens to and deadline tells the last timestamp that this trade is valid. All these parameters will become more clear to you when we actually write the code inside here. First, we're going to need addresses to two smart contracts, address of the Uniswap B two router and the address of the wrapped ethereum. We're going to need the first address to do the trade and we're going to need the west address as one of the tokens that we're trading. This is an intermediary token that we need for a trade and this isn't the actual token that we're going to be trading. The function that we're going to be calling to trade one token for another, I'll name it swap. It's going to take in the address of the token that we're trading in for and the address of the token that we want out of this trade, the amount of tokens that we're trading in for and the minimum amount of tokens that we want out of this trade.
00:03:07.518 - 00:03:58.790, Speaker A: And lastly, the address that we're sending the output token to. The first thing that we'll need to do is transfer the token in from message sender into this contract for the amount amount in. So after this function is called, this contract will have amount in amount of token in. Next, this contract needs to allow Uniswap B two router to spend that token. And we do that by calling approve on the token in ERc 21 of the parameters that we need to call swap exact tokens for token is path. So I've declared an array of addresses named path. This path is going to have three tokens and the three tokens that we're going to need for the path is token in with and then token out.
00:03:58.790 - 00:04:57.194, Speaker A: The reason why we have wif in between token in and token out is because for token in we're going to be using Dai, and for token out we're going to be using WBtC and you'll get the best deal for this trade. If we trade first from Dai to wef and then from Wef to WbtC and then finally we'll call swap exact tokens for tokens on Uniswap B two router passing in these parameters and for the deadline we'll pass in block that timestamp. Deadline is the last timestamp that this trade is still valid. And this is useful if you're calling this function from a user interface. But since we're using a smart contract to call this trade, we'll just use block timestamp. Next we'll write the test to do the trade. Since we're running the same mainnet fork, this will not actually send any transactions, it will only simulate the trade against the main net.
00:04:57.194 - 00:06:04.238, Speaker A: First we're going to need some addresses. The address of the DAI, address of the Dai whale and address of WBTC for the address of the Dai whale. Make sure two things so inside ether scan I want to check that this address die whale has enough ether and you can check that by looking at value and you want to make sure that this account has enough ether because we're going to be sending transactions from this account and in order to pay for the transaction fee they'll need to have some ether. The other thing that you want to check is that this address has enough die and you can do that by clicking on token and then search for die. So this account has $30 million worth of die so that should be enough to simulate our trade. We'll set more variables that we're going to be needing for the trade. The whale will be die, whale amount in will be 1 million die since die has 18 decimal places.
00:06:04.238 - 00:06:40.118, Speaker A: So this means that one die is equal to ten to the power of 18. That is what I am doing over here and since JavaScript cannot handle big numbers that is why I'm using a library called BN JS. The amount out we want from this trade, I'll just set it to one. We're trading from die to WBTC. So token in is diet and token out is WBTC. Lastly, we'll send the WBTC to this account. Next we'll initialize some smart contracts.
00:06:40.118 - 00:07:25.590, Speaker A: We'll get the Dai smart contract and the WBTC smart contract and then we'll deploy test to uniswap smart contract that we just wrote. Next we'll approve the test to uniswap contract to spend 1 million die and this transaction will be sent from the whale, the die whale. We'll do the extra trade by calling the swap function that we wrote passing in these parameters that we configured above. And again this transaction will be sent from the whale. After the trade is executed we'll check on the balance of WBTC for the two address. So you'll get the balance and then console log it. Okay, so let's test this out using ganache.
00:07:25.590 - 00:08:44.780, Speaker A: We're going to be calling this command to run Ganache on the main network and make sure to unlock the die whale. Now to set these variables I've created a m file. Put the address in here and I'm going to load these variables into the terminal by using this command source m. And I believe this is a command only available in Linux. So I'm going to copy this command and inside my terminal I'm going to type source emb and this would load up the environment variables and then I'll paste the ganache command. Once ganache is running on the main network I'm going to open another terminal. We'll run our test over here by saying mpx truffle test the network is main network and the test file to execute is under test test uniswap js our test passed and you can see here that this is the amount of WBtc that we got.
00:08:44.780 - 00:09:19.850, Speaker A: For a million dollar worth of die WBtc has eight decimal places to get the actual amount of WBtC that we got I'm going to copy this and then open a node terminal and then I'll divide that number by ten to the eight so for a million dollar we got about 17 Wbtc okay so that's how you use uniswap with your solidity smart contract. Thanks for watching and have a nice weekend.
