00:00:00.400 - 00:00:37.186, Speaker A: Remember when we looked at the example for how struct is stored inside EBM memory, we found out that 32 bytes was always used even if the data type didn't need to use 32 bytes. And for fixed size array, this is also the same. For example, let's say that I have a fixed size array of type UN 32. UN 32 doesn't need 32 bytes to store it. However, when we're dealing with EBM memory, each element in this array will use up 32 bytes. And to show you this, I have a fixed size array of size three of type UN 32. We'll use assembly to get each of these elements and then assign it to the variable a zero, a one, and a two.
00:00:37.186 - 00:01:06.972, Speaker A: So type assembly and the first element, a zero, will be stored in the initial free memory pointer. So this will be at memory location zero x 80 mload to read from memory location zero x 80. The next element is stored 32 bytes after zero x 80. So this will be a one. Let's assign this to a variable. A one is equal to m load. So here we can say add to zero x 800, zero x 200, zero x 20 is 32.
00:01:06.972 - 00:01:31.684, Speaker A: And here we're telling skip 32 bytes. Or we can hard code this if we add zero x 80. With zero x 20 we get zero x a zero. Okay? And let's get the last element. The last variable is a two. This will be 32 bytes after zero x a zero. And again here we can say add to zero x 800 zero x 40, skip 32 bytes and then skip another 32 bytes.
00:01:31.684 - 00:02:01.088, Speaker A: So this will be zero x 40. Or we can hard code this by saying skip 32 starting from zero x 80. So this will be zero x c zero. Okay, this was an example of how fixed sized array is stored in EBM memory. Next I'll show you example of how to write to a fixed sized array that is initialized in memory using assembly. So here I have a function called test write. I'll first initialize the fixed sized array of type Un 32 uint 32 and the size will be three.
00:02:01.088 - 00:02:26.644, Speaker A: This will be initialized in memory. So I'll type memory and I'll call it r. Next, let's use assembly to store some data into this array. Assembly to store the zero for element there are several ways to do it. For example, we can say mstore r and let's say for the zero for element we'll store the number eleven and we can do this since r is a reference. This r will be initialized starting at memory location zero x 80. So instead of saying r.
00:02:26.644 - 00:03:11.732, Speaker A: Here we can also say zero x 80. Next, let's store some number into the element index one m store. Again we can say r add to our 32 so zero x 20 m and store the element 22. And like in the first example, we can replace this r with zero x 80 since we know that this fixed sized array is initialized starting at memory location zero x 80. And we can further simplify this by manually calculating zero x 80 plus zero x 20, which is equal to zero x 80. Okay, and the last element, I'll copy this again, the third element, let's store the number 33. And how about the memory location? Well, again we can say add to r.
00:03:11.732 - 00:03:39.502, Speaker A: The element at the first index had to skip 32 bytes. The element at the second index will have to skip another 32 bytes. So this will be 64 bytes, and in hexadecimal this is direct 40. And again we know that this array starts at memory location zero x 80. So we can replace this r pointer with zero x 82. And lastly, we can simplify this again by manually adding zero x 80 with zero x 40. And this will give us ce zero.
00:03:39.502 - 00:04:13.886, Speaker A: So far we stored at the 0th index eleven. At the first index we stored 22, and at the second index we stored 33. Let's actually check this by using the regular solidity syntax to access arrays. So say r zero and we assign r zero to this variable a zero. A zero is equal to and I'll do the same for the rest of the elements in this fixed sized array. A one is equal to r1 and a two is equal to two reals. And that completes the example of how to store into a fixed sized array in EBM memory.
00:04:13.886 - 00:04:45.026, Speaker A: Let's compile and run these functions. I'll hit Ctrl s to compile a contract. The contract compiles. Let's now deploy this and then we'll first call the function test to read our unit 32 fixed size array of size three has the elements one, two and three, and we use the assembly to read these data. So let's call the function test read and we expect the numbers one, two and three. Next, let's call the function test write. What do we expect? Well, we stored 1122 and 33, so that's what we expect to get back.
00:04:45.026 - 00:04:59.674, Speaker A: Call the function and we get the numbers 1122 and 33. In this video I'll show you an example of how fixed sized arrays are stored in EVM memory. Even when the data type didn't need 32 bytes, each element still used up 32 bytes.
