00:00:00.250 - 00:00:56.462, Speaker A: In this video, I'll show you some gas saving techniques. Some of these techniques are to use call data, loading state variable to memory, shortcircuiting expressions, loop increments, caching array lamp, and loading array elements to memory. Here I have a function called sum if even and less than 99. What this function does is it takes in an array of Uns, and for each unit in the nums array, if the number is even, and if it is less than 99, it adds that number to the total state variable that you see over here. Let's run this function and see how much gas it consumes before we do any gas optimization. So, I'll hit Ctrl s, deploy the contract, and then we'll call the function sum, if even and less than 99. And for the inputs, we will be using this over here, copy this, paste it here, and then call the function from the transaction logs, get the amount of gas that was consumed, and I'll paste it here.
00:00:56.462 - 00:01:40.310, Speaker A: So before we did any gas optimization, it used up 50,908 gas. Let's now start optimizing for gas. The first thing that we can do is change memory to call data. We'll compile the contract again with control s, and then redeploy the contract, delete the previous contract, deploy a new one, call the test function, get the amount of gas that was consumed. Just by replacing memory with call data, we reduced about 1000 gas. What else can we do with this function? Look inside the for loop, and you can see that the state variable total is being accessed for each loop. Anytime you read or write to a state variable, it uses up a lot of gas.
00:01:40.310 - 00:02:28.346, Speaker A: So we can save some gas by first loading total to a variable inside memory. And after we run the for loop, we update the state variable. So the first thing that I'll do is copy the state variable total to memory by typing unint underscore total is equal to total from state variable inside the loop. We will not access the state variable. Instead, we'll access the variable in memory, and then at the end of the loop, we'll update the state variable by saying total, the state variable is equal to total from the memory. Okay, let's run this function again and see how much gas we save. Hit ctrl s, delete the old contract, deploy the new one, call the function again, and get the gas cost.
00:02:28.346 - 00:03:03.078, Speaker A: So this time it used 48,952 gas. The next gas saving technique that I'm going to show you is short circuit. Take a look at this code over here. First, it evaluates if numsa I is an even number and then it checks if nums I is less than 99. Next, inside the if condition, it checks that if is even, n is less than 99 is true, and then it updates the variable total. Notice that we are doing two computations, one over here and one over here. Before we check that both of them are true.
00:03:03.078 - 00:03:32.538, Speaker A: However, we can make this part of the code more gas efficient by not evaluating the second expression. In this case is less than 99. If the first expression is even is false. This is called short circuiting. If the first expression is false, then there is no need to evaluate the second expression. So we exit the computation early and this will save us some guess. So to do that, I'll first remove this part of the code, and then we'll inline these two computation.
00:03:32.538 - 00:04:12.630, Speaker A: So I'll copy this, paste it here, and the next check is is less than 99. So again I'll copy this and then paste it here, and then remove these two variables. So now if the first expression is false, then this part of code will never execute and it will save us some gas. Let's compile the contract and then see how much gas we save. So hit Ctrl s again, delete the old contract, deploy the new one, call the function, copy the gas cost, and this time it saved about 300 gas. Let's move on. And the next gas saving technique that I'm going to show you is loop increments.
00:04:12.630 - 00:04:51.286, Speaker A: If you look at the code over here, it is doing I plus one equals one. However, we can save a little bit more gas by changing this to plus plus I. I'll compile the contract again and then deploy the new contract, call the function, get the gas cost, and this time it used 48,226 gas. We can further save gas by caching array length. So if you look at the code over here inside the for loop, it's always checking nums length. So every time this for loop runs, it's checking nums length. However, we can cache this into a local variable and save a little bit of gas.
00:04:51.286 - 00:05:42.518, Speaker A: So to do that, I'll say un length is equal to nums length, and then replace this nums length with the variable that we just declared. Compile the contract, redeploy it, call the function, extract the gas, and this time we reduced about 30 gas. The last gas saving tip that I'll show you in this video is loading array elements to memory. Take a look at this code over here. Right now it's accessing the nums of I once, twice, and three times. Every time we access an array element, it does some bound checks, but we don't need to check this three times. So we can save some gas by first loading this nums of I into a variable and then replacing this code with the variable that we declared.
00:05:42.518 - 00:06:24.770, Speaker A: So to do that, I'll say un num is equal to numza by and then replace each numza by with the variable num. Okay, let's see how much gas we'll save. Hit Ctrl s to compile the contract, deploy the contract again, copy the input, paste it, call the function, extract the gas, and this time it used 48,029 gas. We started with using 50,108 gas, and after all the gas optimization that we did over here, we ended with 48,029 gas. So that saved us about 3000 gas.
