00:00:00.320 - 00:00:32.904, Speaker A: Remember that state variables are packed in solidity. For example, if we had a state variable Un 256, followed by state variable two Un 32, the last two Un 32 will be packed into a single slot. However, this is not the case for memory. In EBm memory, data is stored in chunks of 32 bytes. So for example, here we have Un 256 x. This will be stored in a single EBM memory slot. The next Un 32 y will also occupy 32 bytes, and the last dn 32 will also occupy 32 bytes.
00:00:32.904 - 00:01:03.262, Speaker A: Let's see an example here. I created a function called test read, and inside the function I've initialized a struct called point in memory. This point has the values one for x, two for y, and three for z. Now, this point will be loaded starting at memory location zero x 80. This is where initially the free memory pointer will point to. From here, one will be stored at zero x 80. But then in the next 32 bytes, two will be stored, and in the next 32 bytes, three will be stored.
00:01:03.262 - 00:01:37.500, Speaker A: To show you this, I'm going to write some assembly code, say assembly. We'll assign the value of point x to this variable x, point y to this variable y, and point z to this variable z. So I'll type assigned to the variable x. Load the 32 bytes that is stored inside zero x 80. M load zero x 80 and again, this value zero x 80 is initially where the free memory pointer points to. It stores the value zero x 80. And this means that we can start writing into memory.
00:01:37.500 - 00:02:01.876, Speaker A: Starting at memory location zero x 80. The value y will be stored 32 bytes after memory location zero x 80. So y will be stored store that m load. One way to think about this is saying add to zero x 82 bytes. This will be zero x 20. What we're doing here is adding 32 bytes. Zero x 20 is 32 in hexadecimal.
00:02:01.876 - 00:02:49.802, Speaker A: So add 32 to zero x 80. To make this part of the code use less gas and to also make it harder to understand, we can just hard code the value of adding zero x 20 to the value zero x 80. So when we add zero x 20 to zero x 80, we get if we add 16 to this value zero x 80, we get a zero x 90, and if we add another 16, then we need to increment this nine to the next value and the next value in hexadecimal will be eight. Remember that the value x is a Un 256, so it will take up 32 bytes. However, the value y is u 32, so it doesn't need 32 bytes. However, when we're dealing with memory data will be stored in chunks of 32 bytes. So the last value z will be stored in 32 bytes.
00:02:49.802 - 00:03:15.646, Speaker A: After zero x 80, this will be m load. Again, we can say add to the previous memory slot zero x 82 and hexadecimal. This will be zero x 20. Again, we can save gas, simplify this equation by saying zero x a zero. We want to add 32. So let's do the math. If we add 16, this will become a b, and if we add another 16, this will become a c c zero.
00:03:15.646 - 00:03:37.038, Speaker A: Okay, so this is an example of how data is stored in memory. First chucks. Next, let me give you an example of how to write into a struct in memory. I created a function called test write. Inside here, we'll initialize the point struct into memory and then store some data. And then at the end we'll return some data. First, we'll initialize a struct, a point into memory.
00:03:37.038 - 00:04:04.546, Speaker A: This struct will be stored starting at memory location zero x 80. This is initially where the free memory starts. And from zero x 80 it will occupy three times 32 bytes or 96 bytes. And I'll also show you that when we initialize a struct in memory, the free memory pointer will be updated. Okay, so I'll first start by writing assembly. Recall that the struct point has three fields, x, y, and z. Let's start by storing some number into point x.
00:04:04.546 - 00:04:27.526, Speaker A: M store at this point. Struct is initialized starting at memory location zero x 80. So I'll start here by typing zero x 80 and let's store the value eleven. In other words, what we're doing here is storing eleven for point x. Okay, let's do the same. For the values y and z. The value y will be stored at 32 bytes after zero x 80.
00:04:27.526 - 00:04:59.254, Speaker A: So we'll need to increment this number by 32 again. To increment it by 16, we increase it by one, so this will be a nine. If we want to increase it by 32, we'll need to increase the eight by two and this will become a zero. And for the value y, let's store the value 22. And then for the last value z, g will start 32 bytes after this zero x a zero. So this will be, we need to skip two values. So this will be b and then c, and the value let's store 33.
00:04:59.254 - 00:05:37.408, Speaker A: And to show you that we actually store the value eleven for point x, 22 for point y, and 33 for point z. What I'm going to do here is assign to this value x. X is equal to p dot x, and I'll do the same for the value y. Y is equal to p dot y and z is equal to p z. And finally, to show you that the free memory pointer is updated, when we initialize a struct to this free memory pointer, we'll say free mem pointer. The free memory pointer is always stored at zero x 40. So here I'll type m load zero x 40.
00:05:37.408 - 00:06:06.606, Speaker A: Initially, this free memory pointer is zero x 80, and what you're going to see when we execute this function is that this free memory pointer no longer points to zero x 80. Okay, let's try executing the functions. I'll hit control s to compile a contract. The contract compiles. Next, we'll deploy the contract, and then we'll first call the function test read. Call the function test read and we get the values one, two, and three. Next, let's try testing the function test write.
00:06:06.606 - 00:06:28.074, Speaker A: Call the function, and for the values we get 1122 and 33. And for the free memory pointer, it points to zero x e zero. If we add 32 to this value zero x c zero, we get the value zero x e zero. In other words, the free memory pointer now points to 32 bytes. After zero x c zero.
