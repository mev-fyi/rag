00:00:00.250 - 00:00:33.478, Speaker A: Let's write a code for a staking reward contract. The first thing that I'll do is import IERc 20 interface which I have defined in another file. So first I'll import the IERC 20 interface by typing import from the current directory. Import IERc 20 Sol we're going to be using this interface both for the staking token and the rewards token. Next, let's define some state variables for let's define with the staking token and the rewards token. So I'll type IERc 20. We'll make this public and this will not change.
00:00:33.478 - 00:01:16.578, Speaker A: The only time that we'll have to set this is when we deploy the contract. So I'll declare this variable as immutable and then I'll name it staking token and we'll do the same for the reward token. So copy paste and instead of staking token we'll name it rewards. Token. Users are going to stake the staking token and in return they get the rewards token. We'll say that only the owner will be able to set the duration of the staking rewards and the amount for the duration. So let's create a state variable called owner address public owner and this will be set during when the contract is deployed, when the constructor is called.
00:01:16.578 - 00:02:34.190, Speaker A: Next, we'll set some state variables that are needed to keep track of the rewards. First, we'll store the duration of the rewards so I'll say un public duration. We also store the time that the reward finishes so un public finish at we'll need to keep track of the last time this contract was updated, so I'll type un public updated at reward rate so this will be the reward that the user earns per second un public reward rate reward per token stored this will be the sum of the reward rate times the duration divided by the total supply. So type un public reward per token stored. We also need to keep track of the reward per token stored per user. So I'll type mapping from user address to reward per token stored of the user so that'll be un public and I'll name it user reward per token paid. Lastly, we'll keep track of the rewards that a user earned by typing mapping from address address to the user to the amount they earned un name it public and name it rewards.
00:02:34.190 - 00:03:09.958, Speaker A: So these are the state variables needed to keep track of the rewards earned by user. Next, let's define some state variables that keep track of the total supply of the staking token and amount staked per user. So I'll type un public total supply and to keep track of the staking token that is staked per user. I'll define a mapping from address address of the user to un the amount that they have staked. Public balance up. Okay, that completes the state variable. Let's move on and write the constructor.
00:03:09.958 - 00:04:12.218, Speaker A: So I'll type constructor, and to the constructor we'll pass in the address of the staking token and the rewards token. So I'll type address underscore staking token and address underscore rewards token. First, we'll set the owner state variable that we defined over here to the address that deployed this contract. So owner is equal to message sender staking token. We'll say staking token is equal to IERC 20 passing in the address of the staking token, staking token and we'll do the same for rewards token, rewards token is equal to IERC 20 underscore address of the rewards token, rewards token and that completes the constructor. Next, let's define some function that the users will be able to call on this contract. The owner of this contract will be able to set the reward for the duration.
00:04:12.218 - 00:04:59.446, Speaker A: So create a function called set rewards duration and it's going to take in a single input of unduration. External. We'll write the code for this function later on. Let's move on. What other function can the owner or the users of this contract call? Once the owner sets the rewards duration, we want the owner to be able to specify the reward rate. So you'll create a function named notify reward amount and it's going to take in a single input the amount of rewards to be paid for the duration. This will again be external once the duration is set and the amount of rewards to be paid for the duration is set, then the users can start staking to earn rewards.
00:04:59.446 - 00:05:54.030, Speaker A: So we'll type function stake it's going to take in a single input un amount amount of tokens to stake. This will be external and likewise user will be able to withdraw the tokens that they stake. Function withdraw un amount of token that they stake to withdraw external once the users have staked tokens, they are earning some rewards. So let's create a public view function called function earned. This will take the address of an account address of a staker. This function will be external and this is a view function and it's going to return the amount of rewards that are earned by the account so it will return un. And lastly, stakers will be able to claim their rewards by calling the function get reward.
00:05:54.030 - 00:06:37.610, Speaker A: This function will be external okay, and that completes the functions that we'll need to implement for this contract. Let's start with set rewards duration. The owner will be able to set the reward duration for the staking contract. So let's first implement a modifier called only owner so that only the owner will be able to call this function. So create a modifier. Modifier, name it only owner and inside it we'll say require message sender is equal to the owner state variable, and if not, we'll say that the error message is not owner. If message sender is the owner, then we'll go ahead and execute the rest of the code.
00:06:37.610 - 00:07:08.802, Speaker A: We'll want to restrict this function. Set rewards duration to only be able to call by the owner, so attach the modifier only owner. Now, this function can only be called by the owner of this contract. Inside this function, we'll set the duration by typing. Duration is equal to duration from the input. Now, once the staking contract is live, we don't want the owner to be able to change the duration while the contract is still earning rewards. The time when the current rewards will end will be stored in the state variable.
00:07:08.802 - 00:07:52.466, Speaker A: Finish at. So we'll need to make sure that the current timestamp is greater than finish. That meaning that the last reward has expired, so we'll type require finish at should be expired, so finish at should be less than the current timestamp. Block timestamp and I'll say that the error message is reward duration not finished. Okay, that completes the function. Set rewards duration next, let's write the function notified rewards amount. The owner of this contract will be able to call this function notified reward amount to send the reward tokens into this contract and set the reward rate.
00:07:52.466 - 00:08:30.590, Speaker A: So this function can only be called by the owner. So the first thing that I'll do is attach the only owner modifier and then we'll set the reward rate. Now there are two cases to set the reward rate. The calculation depends whether the current reward duration is expired or not. So I'll type if current timestamp block timestamp is greater than finish at. This means that the reward duration is expired or has not started. Then we'll set the reward rate to be reward rate is equal to the amount of rewards to be paid divided by the duration.
00:08:30.590 - 00:09:11.610, Speaker A: Else here it means that the reward duration is not finished yet. So this means that there are some ongoing rewards and the stakers are earning the rewards. In this case, we'll first compute the amount of rewards that is remaining and then add it to the amount that is set by the input. So let's first compute the amount of rewards that is remaining. So I'll type uint remaining rewards is equal to the current reward rate. Reward rate this will be the amount of rewards that is earned per second times the amount of time that is left until the rewards ends. So this will be stored in finish at finish at is the timestamp.
00:09:11.610 - 00:10:11.230, Speaker A: When the reward finishes, finish at minus the current timestamp block timestamp. This will give us the amount of rewards that are remaining. To this we add the amount that we're going to be increasing by. So reward rate is equal to the remaining reward remaining rewards plus the amount to increase by divided by the duration. Let's check that the reward rate is greater than zero so require reward rate greater than zero else the error message reward rate is equal to zero. We also check that there is enough reward to be paid out by checking the balance of the reward token that is locked inside this contract. So type require reward rate times duration is less than or equal to the amount of rewards that is locked inside this contract rewards token.
00:10:11.230 - 00:11:10.830, Speaker A: Balance of address this with the error message reward amount is greater than the balance. Once we check that the reward rate is greater than zero and there is enough reward tokens locked inside the contract to be paid, let's store the timestamps. So when does this reward finish finish at will be equal to current timestamp block timestamp plus the duration duration and we also need to update the state variable updated at so updated at is equal to current timestamp block timestamp okay and that completes the function notified reward amount. Again, the owner will be calling this function to set the reward rate. Okay, let's move on. The next function that we'll implement is stake. Users will be able to call the function stake to stake their tokens.
00:11:10.830 - 00:12:28.774, Speaker A: We will require that the amount that was sent from the input require amount is greater than zero with the error message amount equals zero and then we'll transfer the staking tokens stakingtoken transfer from transfer from message sender to this contract. Address this the amount is transfer amount from the input and lastly we'll update the balance and the total supply balance of message sender plus equals amount that was staked and also total amount of tokens staked. Total supply plus equals amount this state variable keeps track of amount of tokens staked by message sender and this state variable keeps tracks of the total amount of tokens staked inside this contract. Now, in the video about the algorithm we said that every time a user stakes a withdrawal, we'll need to update the reward per token stored and the user reward per token paid. We'll come back to that later. We'll define a modifier and then attach it to the function stake and withdrawal, which will update the reward per tokens. Okay, that completes the function stake for now, so I'll close it and let's now implement the function withdraw.
00:12:28.774 - 00:13:08.326, Speaker A: When a user calls this function, they'll be able to withdraw the tokens that they stake. First I'll type require require that the amount is greater than zero and say the error message amount equals zero in sD. We'll transfer the staking token back to the caller by typing staking token transfer to message sender. The amount to transfer is underscore amount and that completes the function withdrawal for now. We'll come back to this function and the function stake later on to update the amount of rewards earned by user. Okay, let's now write the function earned. This will calculate the amount of rewards earned by account.
00:13:08.326 - 00:13:44.610, Speaker A: Now, from the video about the math and algorithm, we discussed that the amount of tokens earned by a user can be computed by multiplying the amount of tokens staked times reward per token minus user reward per token paid. So let's do that. So we'll type return. The amount of tokens staked will be stored in balance of account. This will store the amount of tokens that is staked times the current reward per token. We'll define a function which we will implement later. Say function reward per token.
00:13:44.610 - 00:14:34.222, Speaker A: This will be public view and it's going to return the reward per token returned. Un we'll define this function later. So moving on. Reward per token to get the current reward per token minus user reward per token pay of account. Both reward per token and user reward per token will be scaled up by ten to the 18. So we'll divide this by ten to the 18 and to this we'll add the previous amount of rewards earned by a user that will be stored in the mapping rewards of account. Okay, so this is the function that's going to compute the amount of rewards earned by a user.
00:14:34.222 - 00:15:04.414, Speaker A: Current amount of token staked times the current reward per token minus user reward per token pay for the account. This number is scaled up by ten to the 18. So here we'll scale it down by ten to the 18 by dividing by ten to the 18. To this amount we add the previous amount of rewards that was earned by account by adding rewards of account. Here we have not implemented the code for reward per token. So let's do that now. Now, there are two cases here.
00:15:04.414 - 00:15:53.418, Speaker A: If the total supply is equal to zero, reward per token divides the reward rate by total supply, but we cannot divide by zero. So here we'll say if total supply is equal to zero, then we'll just return the current reward per token reward per token stored, else total supply is greater than zero. So we'll return the current reward per token stored. Reward per token stored. This will store the sum of the reward rates times the duration divided by the total supply. Reward per token store plus reward rate times the duration. Since last updated time, the current timestamp will be stored in block timestamp.
00:15:53.418 - 00:17:30.122, Speaker A: But we will also need to consider if the reward duration is finished, so that will be stored in finish at and we'll need to take the minimum of these two times so min min of current timestamp and the time that the reward finishes minus the last time that the reward per token was updated at. Updated at and we'll multiply this duration times reward rate by ten to the 18 times one E 18 times one E 18 and then after we do the multiplication of rebor rate duration times one E 18, we'll divide this by total supply, total supply. And that completes the function for computing the current rebor per token. Now, if you look at this part of the code, minimum of the current timestamp and finish at in the synthetic staking contract, this part of the code is wrapped in another function called last time reward applicable. So let's create the function function last time reward applicable. This will be a public function view returns returns the timestamp when the last time the reward is still applicable un and what we'll do is we'll return this part of the code. So I'll copy it and say return minimum of block timestamp and finish that.
00:17:30.122 - 00:18:06.358, Speaker A: Now, I just noticed that we have not implemented the function min, so let's do that right now. I'll scroll down and then type function underscore min takes in two inputs, un, x and uny. This function will return the minimum of x and y. So this will be an internal function. So I'll declare as pivot peer returns un and we'll say return if the input x is less than or equal to y question mark, then return x. Otherwise y is the smaller of the two. So return y.
00:18:06.358 - 00:18:48.598, Speaker A: I'll scroll up now. This part of the code is same as the code inside here inside the function last time reward applicable. So let's replace this code by calling the function last time reward applicable and that completes the function for reward per token. Okay, let's move on. Before we implement the function to get rewards, let's now create a modifier. We'll name it update rewards and we'll call it when our user stakes and withdrawals. So by creating this modifier, we'll be able to track the reward per token and user reward per token pay.
00:18:48.598 - 00:19:46.070, Speaker A: So up at top I'll create a modifier. Modifier, I'll name it update reward. This will take in an input of address of the account to update the user reward per token pay. First we'll update reward per token stored by calling reward per token stored is equal to calling the function reward per token. And I'll make sure that the visibility of this function is public so that we can call this function inside this contract reward per token. This will update the reward per token store to the current value. Since we updated the reward per token store, we'll also update the timestamp updated at and we'll say updated at to be last time reward applicable.
00:19:46.070 - 00:20:54.410, Speaker A: If the reward is still ongoing, then this function will return the current timestamp blocked out timestamp. However, if the reward duration has expired, then this function will return the time when the reward has expired. We'll also update the user reward per token paid. So we'll say if account is not equal to address zero, then update the rewards earned by this account by typing rewards of account is equal to we'll call the function earn to calculate the amount of rewards earned by this account. I'll scroll down to the function earned and change the visibility from external to public so that we can call this function earned inside this contract. And lastly, we'll update user reward per token pay for the account to be the current reward per token stored. Reward per token stored and after we do this, we'll execute the rest of the code by typing underscore semicolon.
00:20:54.410 - 00:21:54.890, Speaker A: So once we have a modifier that will update the reward per token store and the rewards earned by a user, let's attach this update reward modifier to the function stake. So update reward for message sender and likewise we will do the same thing when the user withdrawals update reward for message sender. We'll also update reward per token stored when the owner of this contract calls the function notified reward amount. But since the owner is not earning any rewards for the account, we'll pass in address zero so that this part of the code does not execute. So for a modified reward amount, update reward for address zero. Okay, so the last function that we will implement is get rewards. User will be able to call this function to get the reward token.
00:21:54.890 - 00:23:18.378, Speaker A: When the user calls this function, we'll also recalculate reward per token stored and the amount of rewards earned by a user. So we will attach the modifier update reward for message sender the amount of rewards earned by a user is stored in the mapping rewards of message sender. So amount of rewards earned by a user un reward is equal to mapping rewardsofmessage sender and this is up to date. Since we call the modifier update rewards, we will transfer the reward token if the amount of rewards earned by a user is greater than zero. So if reward greater than zero, then before transferring the tokens out, we'll set the amount of rewards earned by the user to be equal to zero. So rewardsof message sender reset it to zero and once we're done with that we'll transfer the rewards token by typing rewards token transfer to message sender the amount of reward to transfer the variable reward and that completes the function get reward and this also completes the code for the contract staking rewards for the function earned here I made a mistake. When you divide this difference of reward per tokens by one E 18, then it rounds down to a zero.
00:23:18.378 - 00:23:55.682, Speaker A: So the first thing that we need to do is multiply this difference by the balance of accounts before dividing by one E 18. So I'll do that by putting apprentices here, taking this parentheses and then putting it here and then I'll remove this parentheses. Let's go through an example of how this contract is used here. I've deployed two ERC 20 contract. We'll say that the first one is a staking token and the second one is the rewards token. We'll first deploy the staking rewards contract. So I'll select staking rewards contract for the address of the staking token.
00:23:55.682 - 00:24:43.490, Speaker A: I'll copy the address of first ERC 20 contract, paste it, rewards the second ERC 20 contract, paste it and then deploy the contract. We'll say that the owner of this contract is the first account and the user the staker is the second account. The owner of this contract will have to call the function to set the rewards duration and notify the reward amount, which will set the reward rate. So let's do that. Scroll down, open the staking rewards contract for the duration we'll say 1000. Next we'll need to call the function notify reward amount. But before we do that, we first need to transfer the rewards token into this contract so we set the second token was the reward token.
00:24:43.490 - 00:25:22.180, Speaker A: Open it and we'll mint 1000 token to be transferred over to the staking rewards contract. We'll say that this token has 18 decimals. So ten to the 18 is one token. Add three zeros and that is 1000 tokens. I'll mint this and then we'll transfer this amount to the staking contract. So paste amount recipient is the staking contract. Paste it and then for this amount we'll call the function notify reward amount.
00:25:22.180 - 00:25:43.078, Speaker A: Okay. Once that's done, the reward rate is set. So let's switch to a staker and stake some tokens. So switch to the second account. This account does not have any staking tokens yet. So we'll first mint some tokens. We'll also say that this staking token also has 18 decimals.
00:25:43.078 - 00:26:25.046, Speaker A: And we'll also mint 1000 tokens. And then we'll approve the staking reward contract. To be able to spend this 1000 tokens amount is 1000 spender will be the staking contract approve and then we'll now stake this token. So open the staking contract and then click stake. Okay so let's check the amount of tokens that is staked by this user. I'll scroll up, copy the address, scroll back down, balance up and that's the amount of tokens that is staked. Let's see how much we have earned so far.
00:26:25.046 - 00:27:02.270, Speaker A: So paste the address, call the function, earn and we have earned some amount of rewards token. So let's call the function, get rewards to actually claim the rewards. Call the function, get rewards and once the transaction is successful let's actually check the amount of rewards that we have earned. So copy the address of this account, scroll up and then open the rewards contract. Scroll down, click on balance up and the amount is greater than zero. This user has earned some rewards. Okay lastly let's withdraw the tokens that we've staked.
00:27:02.270 - 00:27:12.690, Speaker A: So the amount that we staked will withdraw all of it and then call the function withdrawal and the transaction is successful. So that was an example of how to use the staking rewards contract.
