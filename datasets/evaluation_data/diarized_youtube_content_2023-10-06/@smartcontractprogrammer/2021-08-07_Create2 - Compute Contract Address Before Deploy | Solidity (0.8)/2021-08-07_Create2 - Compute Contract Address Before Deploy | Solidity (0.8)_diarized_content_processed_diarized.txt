00:00:00.650 - 00:00:32.278, Speaker A: Here I have a contract that I deploy three times. Every time I deploy this contract, I get a new address. I don't know the address of the contract until I deploy it. How is the address of the Ethereum contract computed? That's the question that I googled. And if I scroll down, the short answer is that the address of the contract is computed. By taking the kit, check 256 hash of the sender and announce of the sender. The specific splitty code can be found here as well.
00:00:32.278 - 00:01:05.630, Speaker A: This is a cumbersome way to find the address of the contract that is going to be deployed. But what if there's a better way to compute the address of a contract to be deployed? This is where create two is used. It deterministically precomputes the contract address. So in this video I'm going to explain create two. I'm going to show you how to code it, and then I'm going to show you a demo on remix. Okay, let's dive in. For this example, we'll be precomputing the address of this contract and then deploy it, and then finally compare it with the address that was precomputed.
00:01:05.630 - 00:01:33.334, Speaker A: Make sure that those two are equal. Here I've defined a contract called factory. We'll be using this contract to deploy this test contract. What is a factory contract going to do? We're going to need to write several functions. First, we'll write a function to get the bytecode of the contract to be deployed. So it'll be the bytecode of this test contract. Next, we'll write a function to compute the address of the contract to be deployed.
00:01:33.334 - 00:02:16.258, Speaker A: And finally, we'll write a function to actually deploy the contract. After we deploy the contract, we'll be able to compare the address of the contract that was deployed and the address which was precomputed before the contract was deployed. They should be equal. When we use create two to deploy the contract, we'll first write the function to get the bytecode of the contract to be deployed. Here, I named this function getbytecode, and it's going to take in two parameters, owner and unfu. These parameters will be passed on to the constructor of the test contract over here. And this function, get bytecode, will return the bytecode in bytes to get the bytecode of the test contract.
00:02:16.258 - 00:02:48.370, Speaker A: We wrap the test contract in type, and then it's stored in the property called creation code. Just a sidetrack. There are two types of bytecode, creation code and runtime code. Creation code is the bytecode that is used to deploy the contract and runtime code is the bytecode that will be actually executed when you call a function on a smart contract. Anyway. So we take this creation code and then assign it to a bytes variable called bytecode. We take this bytecode and append the owners and the foo parameters.
00:02:48.370 - 00:03:33.706, Speaker A: These are data that will be consumed by the constructor of the test contract. We abi encode, pack this whole thing and then return it as bytes. So that is how you get the bytecode of the contract that is going to be deployed with the constructor parameters appended. So let's move on and see how to compute the address of the contract to be deployed using create two. To compute the address of a contract that is going to be deployed using create two. So, meaning that we have not deployed this contract, but somehow we are able to compute the address of the contract. We take the catch Act 256 of this whole thing inside here, which is zero XFF, and then append it by the sender address and then append it by salt.
00:03:33.706 - 00:03:56.598, Speaker A: This will be a random number of your choice. And then we further take the catch Act 256 of the creation code that we just computed from above. Get bytecode. So we take this catch Act 256. This is 32 bytes and we take the last 20 bytes of this. That will be the address of the contract that will be deployed. So let's see this in code.
00:03:56.598 - 00:04:37.510, Speaker A: I've named this function get address. It's going to take in the bytecode that we computed from above and it's going to take in assault of un. This will be a number of our choice and then it's going to return an address as explained above. We're going to take the catch up 256 ABI encode packed passing in zero XFF. The contract test contract will be deployed from this contract, the factory contract. So the sender address here will be address of this factory contract. We pass in the fault and we take the ketchup 256 of the bytecode and that is how you get the hash to get the last 20 bytes and then cast it as an address.
00:04:37.510 - 00:05:37.080, Speaker A: We do this weird thing in solidity. Basically we're casting the hash into an address and that will return the precomputed address. Finally, moving on, let's now talk about how to deploy the contract using create two. The name of this function, I've named it deploy and it's going to take in the bytecode and the salt of our choice. We'll first initialize a variable, the address of the contract that is going to be deployed to use create two to deploy a contract, we're going to be using the assembly and calling a function called create two passing in these parameters bpns. B is the amount of ether to send to this contract, p is the pointer to the memory of the start of the code, n is the size of the code and s is the salt. From here inside solidity here we're going to say that we're going to be using assembly and then call create two passing in these parameters which are explained over here.
00:05:37.080 - 00:06:38.902, Speaker A: Here I want to say message value, but since inside assembly this is an invalid variable, we need to call call value to get message value. In other words, the amount of way to send to the contract to be deployed. To get the pointer to the start of the code in memory, we need to take the bytecode. So this bytecode variable stores a pointer in the memory where this bytecode is actually stored. And since the first 32 bytes stores the size of the bytecode, we'll need to skip the first 32 bytes. And we do that by doing adding to the pointer of the bytecode 32 bytes, and this will land us on the start of the code. To get the size of the bytecode which is stored in the first 32 bytes of the bytecode we can just call embode on the bytecode and that will give us the size of the code we pass in our salt and call create two and we get an address of a contract that was deployed.
00:06:38.902 - 00:07:17.958, Speaker A: We'll do a quick check, make sure that the contract was actually deployed by checking that the size of the contract at the address is not zero. And if it is zero then we'll revert this whole process. And lastly we'll emit the event deployed, logging the address and the salt and this event deployed. I've just declared it right here on top of the factory contract. So that completes the code. We're now ready to run a demo in remix again. So we're going to get the bytecode, pre compute the address and then actually deploy the contract and compare the two addresses using create two.
00:07:17.958 - 00:07:54.850, Speaker A: Those two addresses will be equal from the left. I'm going to click on the solidity icon, make sure that I have solidity compiler greater than 0.8. Here we're using 0.8.4 and then we'll compile this contract. So I'm going to scroll down and then hit compile. Once the contract is compiled we'll deploy it. So we'll deploy the factory contract and then scroll down and then click on the factory contract and we'll get the bytecode so we'll need to pass in an address of an owner and some un for the flu parameter.
00:07:54.850 - 00:08:45.974, Speaker A: So for the owner I'm just going to scroll up, click on this account, copy it, and then scroll back down, paste the address, and for the second parameter I'll just pass in one, one one, and hit get bytecode. That is the bytecode, meaning that that is the creation code appended with these constructor parameters. I'm going to copy this and then we'll call get address. The function get address takes in two parameters, the bytecode and the salt. So I'm going to paste the bytecode and for the salt we'll pass in seven seven seven and then call get address. And that should be the address of the contract that we are going to deploy. So let's now actually deploy the contract again.
00:08:45.974 - 00:09:31.034, Speaker A: I'm going to copy the bytecode, paste it in here, and for the salt we passed in seven seven seven and then hit deploy. The contract was deployed. Let's now look through the logs and find the address of the contract that was deployed. So inside the transaction logs, the event was deployed and the address that was deployed is over here. Starts with B 40 eight and with B four ad. How about the address that we pre computed? Starts with B 40 eight and with B four ad. Now I'm not going to check every character and number to make sure that these addresses are equal.
00:09:31.034 - 00:09:51.810, Speaker A: They're probably equal. So that is how you use create to, to deterministically precompute a contract address. Create two is actually used in uniswap version, two pair contract, and it can also be used to hack other contracts. But that's a topic for another video. Thanks for watching and have fun coding.
