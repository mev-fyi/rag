00:00:00.170 - 00:00:32.838, Speaker A: Let's take a look at a cryptographic hash function that is widely used in solidity ketchup 256. Some of the use cases are to sign a signature, come up with a unique ID, and it can also be used to create a contract that is protected from frontrunning. This is called commit reveal scheme. In this video we'll focus on how to use the ketchak 256 hash function. I'll create a function called hash. That catch Act 256 hash function can take any input. For this example, we'll pass in a string memory text.
00:00:32.838 - 00:01:28.998, Speaker A: We'll also feed in a un num and why not an address address addr. This function will be external peer and the output of a catch Act 256 hash function is bytes 32, so we'll return bytes 32. To call the catch Act 256, we type catjack 256 parentheses, and inside the parentheses we need to put in bytes as input. However, these inputs are not in bytes, so we first need to encode it into bytes by typing in ABI encode. You can use encode or encode packed here. For this example, I'll use encode packed, and later I'll explain the difference between encode and encode packed. Moving on inside the encode packed function, we will pass in these parameters.
00:01:28.998 - 00:02:25.894, Speaker A: So text num addr the function AbI encode packed will return a bytes, and this bytes will be the input of the function catch act 256, which returns a bytes 32. Let's run an example of this hash function. I'll compile a contract and then deploy it, expand the hash function contract, and we'll pass in some parameters. For example, for the first example, we'll pass in aaa. The second input is a num, one, two, three, and the third parameter is an address. So I'll just copy this address over here and then paste it here, and then call the hash function, and that is the 32 bytes hash of these parameters. Now, if I were to change the parameter even by a little bit, for example, replacing the last a with a b, and then calling the hash function again, notice that the output changed significantly.
00:02:25.894 - 00:03:16.694, Speaker A: That is a property of a cryptographic hash function. You change the input a little bit and the output changes a lot. And also, given an output, it is extremely difficult to find what the inputs were. Next, I'm going to explain the difference between Abi encode and Abi encode packed. The reason that I'm explaining the difference between Abi Encode and Abi encode packed is that there is a situation where you can have a hash collision, meaning that the inputs are different, but it hashes to the same output. So first let me explain the difference between Abi encode and Abi encode packed. Abi encode encodes the data into bytes, whereas Abi encode packed also encodes the data into bytes, but it compresses it, the output will be smaller, and it will do some of the information that was contained in AbI encode.
00:03:16.694 - 00:04:06.170, Speaker A: Let me show you an example. So I'll create a function called encode, and it's going to take in a string memory text zero, and also we're going to take in another string memory text one external peer, and returns. Abi encode returns bytes, so return bytes, and then we'll type return ABI encode text zero text one. I forgot to put bytes memory for the output, so I'll do that right now. And we'll also create another function called encode packed passing in the same inputs. But instead of calling Abi encode, we'll call Abi encode packed. I'll copy this function, paste it here, rename the function to encode pact.
00:04:06.170 - 00:05:01.286, Speaker A: The inputs will be the same and the outputs will be the same. The function that we're going to be calling is Abi encode pact, compile the contract, then we'll redeploy the contract, scroll down, expand the contract, we'll call encode, and then encode packed passing in the same inputs. The inputs are string, so for the first input I'll pass in AAA, and for the second input, I'll pass in BBB, call encode, and that is the output that we get. Now we'll do the same for calling encode pack, copy the inputs, paste it into encode pack, and then call encode pack. Scroll down a little bit and notice that the outputs are a little bit different. Here we see four run, four run forerun, followed by 424242. And we also see the numbers four on four run four run over here, followed by a bunch of zeros, and at last says 424242.
00:05:01.286 - 00:05:41.222, Speaker A: So encode just encodes data into bytes, whereas encode packed compresses these data. Now, why am I telling you the difference between encode and encode packed? Well, this is because there is a situation where we can create a hash collision. The output of the hash is the same even though the inputs are different. And this will happen when we pass in two dynamic data types next to each other inside the function in code pack. And to show you this, I'll go back to the example contract and notice that our input so far is AAA and BBB. Now I'm going to add another A and then call encode packed. That is the output.
00:05:41.222 - 00:06:30.940, Speaker A: Now I'm going to do something different. I'm going to take the last A and provide it as an input for the second string a. So we're replacing the last a for the first input and prepending it to the second input. Call encode packed again and notice that the output is still the same since the outputs are the same. This means that if we were to ABI encode, pack two strings and then call catch Act 256. So hashing aa, bbb, and hashing AAA and ABB will output the same hash, two different inputs, but the same output. To show you this, I'm going to create a function called collision, and for the input it's going to take in two string string memory text zero string memory text one.
00:06:30.940 - 00:07:18.674, Speaker A: This function will be external peer returns bytes 32 and we'll return catcheck 256 of ABI encode packed text zero text one. So notice two things. We're using ABI encode packed and we're passing in two dynamic data types next to each other. Compile the contract and then redeploy the contract and we'll call the function collision with inputs AaA and ABB call collision. That is the output. Now we'll change the input a little bit. Take the first A in the second input and append it to the first input.
00:07:18.674 - 00:07:59.830, Speaker A: Call the function collision again and notice that the output has not changed even though we've changed the inputs. So this is an example of a hash collision. To fix this hash collision that occurs when you pass in two dynamic data types into the function ABI encode fact, we can either replace the function ABI encode fact with AbI encode. Alternatively, if you have other inputs to your hash function, you can rearrange the input so that no dynamic data types are next to each other. For example, let's say that this hash function takes in another unit. I'll name it x. Then what you'll want to do here is in between the two dynamic data types, text zero and text one.
00:07:59.830 - 00:08:29.434, Speaker A: Passing the input x. Compile the contract and I'll show you an example of this fix. Deploy the contract again. Again we'll pass in AaA, and the second input is a number. So I'll pass in one, two, three, and the third input I'll pass in abb. Call the function collision that is the output. Next, we'll change the input of the two strings, so we'll put a at the end of the first input and remove the a from the second string.
00:08:29.434 - 00:08:40.410, Speaker A: Call collision again and notice that the hash changed. So that is how you can avoid hash collision when you're using ABI. Encode pact with multiple dynamic data types.
