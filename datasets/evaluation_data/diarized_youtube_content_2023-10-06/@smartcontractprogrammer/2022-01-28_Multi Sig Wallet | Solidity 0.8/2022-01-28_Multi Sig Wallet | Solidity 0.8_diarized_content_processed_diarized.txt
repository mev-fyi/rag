00:00:00.330 - 00:00:32.310, Speaker A: If you can write your own multisig wallet, then that shows that you have a good understanding of solidity. You'll have no problem writing easy to medium solidity contracts. So let's go to multisig wallet. The first thing that we'll need is events. Events that are fired when EF is deposited into this multisig wallet. We'll emit the submit event when a transaction is submitted, waiting for other owners to approve. Other owners will be able to approve the transaction, and once the transaction is approved, maybe they've changed their mind so they might want to revoke the transaction.
00:00:32.310 - 00:01:11.214, Speaker A: Once there are sufficient amount of approvals, then the contract can be executed. Let's first start with the state variables. We want to store some owners, so we'll store it in an array of addresses. So I'll type address bracket public owners only the owners will be able to call most of the functions inside this contract. So we want a quick way to check that message sender is owner. So we'll create a mapping from address to Boolean. This will be public and we'll name this mapping is owner.
00:01:11.214 - 00:01:58.398, Speaker A: If an address is the owner of the multisig wallet, then it will return true, otherwise it will return false. If message sender is one of the owners of this contract, this will return true, otherwise it will return false. Once a transaction is submitted to this contract, other owners will have to approve before that transaction can be executed. The number of approvals that is required before it can be executed, we'll store it in a UN so we'll say Un public required. This will be the number of approvals required before a transaction can be executed. For example, let's say that there are three owners and we set require equal to two. Then that means two out of the three owners have to approve the transaction before it can be executed.
00:01:58.398 - 00:02:27.290, Speaker A: Next, we'll define a struct that's going to store the transaction. So we'll say struct. I'll name this transaction and it's going to store the address of two. This will be the address where the transaction is executed. Un value. This will be the amount of ether sent to the two address bytes data. This will be the data to be sent to the two address and boolean executed.
00:02:27.290 - 00:03:04.642, Speaker A: Once a transaction is executed, we'll set this equal to true. We'll store all of the transaction in a struct, so we'll say transaction bracket. This will be public and we'll name it transactions. Each transaction can be executed if the number of approval is greater than or equal to required. We'll store the approval of each transaction by each owner in a mapping mapping from UN. This will be the index of the transaction to another mapping address. This will be the address of the owner.
00:03:04.642 - 00:03:47.960, Speaker A: To Boolean, this will indicate whether the transaction is approved by an owner or not. So, for example, let's say that there are three transactions and the second owner wants to approve the second transaction. Then UN will be equal to one. Since the first transaction is zero and the second transaction will be index one, the address will be owner number two, and Boolean will be equal to two. We'll also make this state variable public and we'll name it approve. Next, let's write the constructor. Constructor for the input of the constructor, we'll put in two parameters, addresses of the owners and the required that you see over here.
00:03:47.960 - 00:05:19.982, Speaker A: So we'll say address bracket memory, I'll name it underscore owners and the second parameter is un underscore required we'll require that there are at least one owner by saying require owners length is greater than zero. Otherwise, the error message will say owners required. Next, we'll do some check on the required we'll require that this is greater than zero and less than or equal to the number of owners. So we'll type require required is greater than zero and required is less than or equal to owners bench. If this condition is not satisfied, we'll say invalid required number of owners. Next, we'll run a for loop to save the owners to the state variable, and along the way we'll make sure that owners is not equal to address zero and that the owner is unique. So we'll say for un I we'll start at zero, so we'll just say unti without initializing it equal to zero I less than owners length I plus plus we'll get the address of the owner from the array into a variable.
00:05:19.982 - 00:06:28.678, Speaker A: By typing address owner is equal to owners from the input at I, and then we will require that owner is not equal to address zero. If it is, we'll say that the error message is invalid owner. We also require that the owner is unique, and we can know that the owner is unique by making sure that owner is not inserted into this mapping is owner yet. So we'll say require not is owner owner and if it is, then we'll say owner is not unique. After we do some check, we'll insert the new owner into the is owner mapping is equal to true and then push the owner into the owners state variable. By typing, owners push the new owner after we store the owners, we'll say required. The state variable is equal to required from the input and that completes the constructor.
00:06:28.678 - 00:07:09.110, Speaker A: Next, we're going to enable this multisig wallet to be able to receive ether. So we'll do that by typing receive external payable, and when we receive some ether we'll emit the event deposit. The event deposit takes in two parameters, the sender and the amount that was sent. So wheel dog message sender message value. Next, we'll write the function submit. Only the owners will be able to submit a transaction. Once the transaction is submitted and it has enough approvals, then any of the owner will be able to execute the transaction.
00:07:09.110 - 00:07:40.606, Speaker A: So we'll create a function. I'll name this submit. We'll need to create a new struct called transaction. So the inputs will be these parameters that you see over here. So it will be address two. This will be the address that the transaction will be executed on. Un value the amount to be there to send bytes call data data this will be the data to be sent to the address too.
00:07:40.606 - 00:08:28.426, Speaker A: Notice that we're using call data here since this function will be external and instead of using memory, call data is cheaper on gas. This function will be external and only the owner should be able to call this function. So we'll define a modifier called onlyowner and restrict this function to be able to call by the owner. So I'll scroll up and then define a modifier called only owner. So how do we know that message sender is one of the owners of this contract? Well, there are two ways we can either try to find message sender in the owner's array. This is not gas efficient. The quicker way is to use this mapping is owner.
00:08:28.426 - 00:09:36.980, Speaker A: So we'll type require is owner message sender and if message sender is not owner of the multisig, we'll say that their message is not owner. If message sender is one of the owners of this contract, then we'll go ahead and allow execution of rest of the function. Next, we'll push all of these parameters into the transaction array by typing transactions push initialize the struct transaction with the parameters two is equal to the two address value is equal to value, data is equal to data and executed is equal to false. And then we will emit the event submit. The submit event will log one parameter txid. Txid is the index where the transaction is stored. The index where this transaction is stored will be in transactions length minus one.
00:09:36.980 - 00:10:11.600, Speaker A: The first transaction will be stored at index zero the second transaction will be stored at index one, and the third transaction will be stored at index two, and so on. Once the transaction is submitted, other owners will be able to approve the transaction, so we'll create a function called approve. It's going to take in a single parameter untxid. This will be the index of the transaction. To approve. This function will be external. Only the owner of this multisig wallet should be able to call this function.
00:10:11.600 - 00:11:24.082, Speaker A: We also want to make sure that TX exists. This modifier we'll define later. What else do you want to make sure about the transaction that's going to be approved? We want to make sure that this transaction is not yet approved by message sender, so we'll say not approve Txid. And we also want to make sure that this transaction is not yet executed, so not executed Txid. Okay, so let's now go define these modifier TX exists not approved and not executed. So we'll say modifier TX exists passing in uint TxId and how do we know that the transaction exists? Remember that TxID will be the index of the transactions array, so it exists if the index is less than the length of the array. So we'll say that by typing Txid less than transactions length.
00:11:24.082 - 00:12:50.450, Speaker A: And if this condition fails, then we'll say TX does not exist. If the transaction exists, then we'll execute the rest of the code. The next modifier that we'll write is modifier not approved. Again, it's going to take in the Txid. And how do we know that the transaction is not yet approved by message sender? Well, we can know it by checking the mapping approved, so we'll say require not approve the Txid. The second key to pass to this mapping is message sender, and if this condition fails, then we'll say that the error message is TX already approved, and then execute the rest of the function. The last modifier that we'll write is make sure that the transaction is not yet executed, so we'll say modifier not executed untxid and we'll require that transactions at TxId executed is not yet executed, so we'll say not transactionid executed with the error message TX already executed.
00:12:50.450 - 00:13:51.890, Speaker A: If this check passes, then we will execute the rest of the code. So going back to the approve function, we'll store the approval of message sender by typing approved txid of message sender is equal to true, and then emit the event approved. Scrolling back up. We'll need to log two parameters for the event approved, the owner and the txid the owner is message sender, and the txid that was approved is txid from the input. Before the owner can execute a transaction, they'll need to make sure that the number of approved is greater than required. So let's write a function where given a txid, we'll count the number of approvals so we can say function I'll make this function private, so I'll say underscore get approval count. This will take in a single input of txid.
00:13:51.890 - 00:14:35.554, Speaker A: This function will be private. View returns the count so it'll be uint. We will initialize the count by saying uncount. Actually to take some gas. I'll initialize the count as an output over here so that we don't have to initialize it, and then we'll run a loop for each owner. We'll check whether approved is true or not. If it is true, increment the count so you'll say four u into I I less than owners dot length I plus plus if approved txid for owners of I.
00:14:35.554 - 00:15:41.126, Speaker A: In other words, if owners of I has approved transaction with txid, then we'll increment the count plus equals one. Notice that we don't have to return the count since the count is implicitly returned from here, so we don't need this return count statement. Next, let's write the function to execute the transaction. So we'll type function execute it's going to take in a single input untxid this function will be external and we want to make sure that tx exists. Passing in the TxId we also want to make sure that the transaction has not been executed yet, so not executed again, passing in the Txid inside the function. The first thing that we'll do is check that the count of approval is greater than or equal to required. So we'll type require get approval count of TxID is greater than or equal to required.
00:15:41.126 - 00:16:18.200, Speaker A: For the error message, we'll say approvals is less than required. We'll need to get the data stored in the transaction struct and then updated. So we'll first get it by saying transaction storage. Here we're saying storage. Since we'll be updating this transaction. I'll name this transaction is equal to transactions at TxID. The first thing that we'll do is set executed of transaction equal to true.
00:16:18.200 - 00:17:21.930, Speaker A: Transaction executed equal to true. Next, we'll execute the transaction by typing transaction two. This will be the address that we're going to use the low level call to execute the transaction call the amount of ether to send to this two address is stored in transaction value, so we'll type value is equal to transaction value and then to the call. We'll pass the data. By typing transaction data, the low level call returns to the outputs, but for this example we'll only make sure that the call was successful. By typing boolean success, we'll ignore the second output is equal to calling this function and then check that the function executed correctly by checking that success is equal to true. If it is not, then transaction failed.
00:17:21.930 - 00:18:06.840, Speaker A: And lastly we'll emit the event execute. The event execute takes in a single input of txid, so we'll log the txid. The last function that we'll write is revoke. Let's say that the owner approves a transaction, and before the transaction is executed he changes his mind and he wants to now undo the approval. So we'll write the function rebuke so say function rebuke. This will take in a single input of txid. This function will be external only the owner should be able to call this function.
00:18:06.840 - 00:19:20.970, Speaker A: The transaction should exist and the transaction should not be executed yet so not executed TxId for the owner to be able to revoke a transaction, he must have first approved it. So we'll check that the transaction is approved by typing require approved of TxID for message sender, meaning that message sender has approved this transaction. For the error message we'll say TX not approved and then we'll set approve of Txid for message sender equal to false, and then emit the event revoke. The event revoke takes in two parameters, the owner and the transaction id. The owner will be message sender and the transaction that was revoked will be TX Id from the input. This completes the basic multisale wallet contract. If you can write this on your own, then you have a good fundamental understanding of solidity.
