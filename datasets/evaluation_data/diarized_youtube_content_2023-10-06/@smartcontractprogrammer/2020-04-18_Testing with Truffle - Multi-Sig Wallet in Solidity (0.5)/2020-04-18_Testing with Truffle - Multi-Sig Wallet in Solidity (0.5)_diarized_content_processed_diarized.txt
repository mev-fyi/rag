00:00:00.730 - 00:00:51.158, Speaker A: Let's write some tests for our multisig wallet contract. I'll show you two examples using execute transaction, and we'll be writing the test for when the transaction successfully executes. And we'll also write the test case for when the transaction fails, because the transaction is already executed. First, on the top left corner here, inside the test folder, we create our test and we'll name it multisigwallet Js. Inside the test file that we've just created, we'll first import some NPM packages that we're going to be using for this test. We'll import Chai and Chi as promised. And these two lines of code will allow us to easily test for transactions that should fail.
00:00:51.158 - 00:01:35.050, Speaker A: And what I mean by this is back in our contract. You can see here that the transaction will fail if certain conditions are not met. So I'll show you how to write a test for when we call execute transaction and the transaction is already executed, the transaction should fail. All right, so back in our test file, we first need to import the multisig wallet contract. And you can do it like this. We're going to be importing the Multisig wallet contract. So you call artifacts require Multisig wallet artifacts require is a function provided by truffle.
00:01:35.050 - 00:02:17.726, Speaker A: Next, we'll need to put our test inside the contract. And this is just how truffle expects you to write your tests. So we'll be writing our test inside here. Similar to how remix provides you with some accounts to play around with, Truffle also gives us some accounts that we could use in our tests. For each test that we're about to create, we'll create a two out of three multisig wallet. So that means the Multisig wallet will have three owners, and to execute a transaction, they will need to have two confirmations. And for each test, we'll create a new multisig wallet.
00:02:17.726 - 00:03:04.600, Speaker A: So that's what I'm going to show you how to do. Now, first, we'll create a variable called wallet. And we'll create a new multisig wallet for each test, and then bind it to this variable. And the way you will create a new multisig wallet for each test case is by using the before each hook. So before each, we'll create a wallet by calling multisigwallet new. And then we'll pass in the owners and the num confirmations required. All right, so that's the setup that's going to be run for each test.
00:03:04.600 - 00:03:44.980, Speaker A: Let's now move on to the actual tests. I'll be showing you two examples. The first test case is when execute transaction is successful, and the second test case is when the transaction is already executed. Execute transaction should fail to write an actual test. We put our code inside it and we give a quick description of what we're testing. So inside here we'll write our test back in our multisig wallet contract. Before we call execute transaction, you can notice here that certain conditions must be met.
00:03:44.980 - 00:05:01.120, Speaker A: For example, the transaction must exist, it must not be executed, and the number of confirmation must be equal to or greater than the minimum number of confirmations required. So back in our test over here, we'll need to create a transaction and then confirm it by at least two owners before we could call execute transaction. And we'll do that by calling await wallet submit transaction, and we'll submit this transaction for owners zero. We'll send zero ether, and the data that we're going to send will be zero bytes. To make this part a little bit more understandable, I'm going to put these in a variable, so two will be owners zero. The value that we're going to send will be again zero. And the data that we're going to send will be equal to zero bytes, and then replace it with the variables here.
00:05:01.120 - 00:05:56.730, Speaker A: And this line of code will create a transaction that is meant for owners zero. It's going to send zero ether, and it's going to send zero bytes for the data. And this transaction will need to be confirmed by at least two owners. So that's what we're going to be doing now. And you can do that by calling await wallet confirm transaction. And since this is the first transaction, the TX index will be zero, and this transaction must be sent from one of the owners of the Multisig wallet. And we can do that by saying from owners zero we need to confirmation.
00:05:56.730 - 00:07:30.300, Speaker A: So we'll do that again with owner one, and that completes the setup needed to call execute transaction. So let's now call execute transaction, and we'll store the result in a variable called rest, short for response, and then call wallet execute transaction transaction zero from Boners zero. So after we call execute transaction, what are some things that we would like to test? Well, if we look back in our contract, we probably want to test that transaction executed is set to true. And I'll also show you how to test that the event execute transaction was emitted with message sender being one of the owners, and TX index here should be equal to zero. So first from the response we'll get the logs and we'll assert that the first event that was fired is equal to execute transaction. We'll also assert that the owner that was logged for the execute transaction event is equal to owner zero, since owner zero made a call for execute transaction. And we also check that the TX index is equal to zero.
00:07:30.300 - 00:08:28.240, Speaker A: Again, this is because execute transaction was called on transaction zero. Next, we'll check that transaction executed is set to true. So we'll do that by first getting the transaction by calling get transaction zero. And this get transaction is a helper function inside the multisig wallet contract over here. So once we get the transaction, we'll assert that the TX executed is equal to true and that completes the code for testing execute transaction. Let's now test this. So open the terminal and type truffle test.
00:08:28.240 - 00:09:17.230, Speaker A: You can see here that our test passed. Next, I'm going to show you how to test when execute transaction fails. And before we can call execute transaction again, we'll need to do some setup. And to avoid copying and pasting the same exact code from here into here, we will run this setup inside a before each hook. So here I've created another before each hook, and I'm going to take this code and then put it in here. So now this code will run before each of these tests. Now, if you have other tests, such as testing for rebuke confirmation, you might not want to run this setup.
00:09:17.230 - 00:10:47.610, Speaker A: So how can we say that we want to run this setup only for these two tests here, but not for other tests? Well, you can do that by putting this entire code inside the describe like this, and we'll name it execute transaction, take the code and then put it in the describe. So now our code should look like describe execute transaction, run some setup before we test execute transaction and then our actual test. All right, so let's now test that execute transaction fails if the transaction is already executed. When everything is set up correctly, we know that we could call execute transaction on transaction zero. So we'll do that first inside here, and then we'll call the same function again and then check that the transaction fails. So one way to test it is by putting it in a try catch block. So we'll say try and then call the function again and then catch the error.
00:10:47.610 - 00:11:45.520, Speaker A: And we'll check that the error reason is equal to TX already executed. And this error message comes from our smart contract over here when the transaction is already executed. And we also want to make sure that this line of code fails. So if it doesn't, we'll throw an error and say tx did not fail. Let's quickly go over what these lines of code do. So first we call execute transaction and we know that this will pass since we already test it here. But then it should fail the second time and we can check that by calling the function again.
00:11:45.520 - 00:12:46.900, Speaker A: And if this line of code fails, then we'll check that the error reason is equal to already executed. Otherwise, if this line of code succeeds, this line of code will be evaluated and it will throw an error, and the error reason will not be equal to TX already executed. So let's now run the test, open the terminal and type truffle test again, and you can see that both of the tests passed. Now, the way this test is written is a little bit confusing and we can do better back at top. Remember that we imported some NPM libraries and this will help us write the test case for when the transaction fails in a cleaner way. We'll be using Chai expect, and if you're writing a lot of tests, you'll be using this a lot. So we'll bind it to a variable called expect.
00:12:46.900 - 00:13:35.706, Speaker A: Let's now rewrite this code using expect, and I'm going to leave this here, but comment it out so that you can see the difference between this code and the code that we're about to write. Since we're testing a promise, we're going to say await and then call expect. And inside the expect we're going to call this function execute transaction. To test that execute transaction fails, all we have to do is say to be rejected. All right, so let's run the test again and make sure that it passes. So open the terminal again and type truffle test. And our test still passes.
00:13:35.706 - 00:14:02.610, Speaker A: So those were some examples of how to test your smart contract using truffle. Now, when you're actually writing test for your smart contract, you you're probably writing more tests. And if you want to see more examples of how I tested this smart contract, I'll paste the link for the code and the test in the descriptions below. So go ahead and check it out. Other than that, I'll see you in the next video. Bye.
