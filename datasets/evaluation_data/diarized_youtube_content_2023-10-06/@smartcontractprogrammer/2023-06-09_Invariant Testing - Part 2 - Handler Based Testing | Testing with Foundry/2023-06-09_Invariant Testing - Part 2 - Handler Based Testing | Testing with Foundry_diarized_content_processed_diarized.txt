00:00:00.250 - 00:00:37.618, Speaker A: In the previous video, we wrote a simple invariant to test that the total supply of WEF is always equal to zero. We ran the test and the test passed, but we were getting many rebirths. This means that a lot of the function calls to the WEF contract was failing. So in this video, we will improve on our invariant testing by writing another smart contract that will call into WEF. This is called a handler based testing. So I've created a file here, and we'll be writing our handler based testing inside here. The topics of this videos are handler based testing, which means that we're going to be testing functions under specific conditions.
00:00:37.618 - 00:01:14.990, Speaker A: I'll also show you how to target a contract for our invariant testing and also how to target functions to call targeting selectors. So let's get started. We will start with the topic of handler based testing. In the previous video, when we ran our invariant test, a lot of the function calls were failing. This is because foundry would randomly call any function inside the web contract. But what we actually want to do is test the web contract under certain conditions. For example, here I have the WEF contract open, and what we want to test is make sure that when foundry calls the function deposit, it would send some amount of EF.
00:01:14.990 - 00:01:43.818, Speaker A: In other words, message value will be greater than zero. So what we're going to do is first we're going to write a smart contract called handler. That's going to call the function deposit, and we're going to make sure that we send some Eve to the WEF contract. So to write the handler function, first I'm going to import some library from foundry. Here are the contracts that we're going to need to write our handler contract. Next we'll write the handler contract, so say contract. I'll name this handler and it will inherit all of the contracts that we just imported.
00:01:43.818 - 00:02:36.826, Speaker A: Is common base TD sheets, ran std utils. Inside this contract we'll save the address of WEF, so say WEF, private WEF, and inside the constructor. Constructor we'll pass in WEF, underscore WEF, and set wef equal to underscore Wef. We'll also declare a fallback so that this contract will be able to receive ETH when this contract calls withdrawal on Wef, so say receive external payable. Next, we'll write some functions that this handler contract will call. For example, a function to deposit into f function deposit for some amount un amount, and we'll make this public and the function to withdraw function withdraw for some amount un amount public. Now going back to the web contract.
00:02:36.826 - 00:03:19.258, Speaker A: Scrolling up. We can also call deposit on the web contract by directly sending ETH. So we also want to test that over here. So here I'll say function send to fallback for un amount public. Okay, so these are the functions that we'll implement later. We'll write our invariant test, and foundry will call these specific functions send to fallback deposit withdrawal. So when foundry calls the function deposit, how would we want to call the function wef inside here? Well, we'll want to call wef deposit and we want to send this much amount, so say here value amount.
00:03:19.258 - 00:04:08.518, Speaker A: But nothing guarantees that this much amount of beef is locked inside this contract. So what we're going to do is bound the amount of beef that we're going to be sending to the WEF contract to the actual amount that is locked inside this contract. So say amount equals bound amount to the value between zero and the balance of this contract. That will be address this balance. So what's going to happen here is foundry will put in some random number, and on the next line we're going to bound this random amount to a number between zero and the amount of beef that is locked inside this contract. Once this amount is bounded, we'll call weft deposit, sending the amount of beef, and that completes the deposit function. For now, we'll do something similar to send to fallback.
00:04:08.518 - 00:04:43.202, Speaker A: So I'll copy this code, paste it here. When foundry calls this function, send to fallback with some random number, we'll bound this random number between zero and the amount of beef locked in this contract. And then next we're going to call wef. But instead of calling the function deposit, we'll deposit by calling the fallback function. So to do that, I'll say address of wef call. I'm going to be calling the fallback. So the data will be empty and we're going to be sending some amount of beef that'll be value amount, call returns, two outputs.
00:04:43.202 - 00:05:35.590, Speaker A: What we're interested in here is the first output. Boolean whether the call was successful or not, and then we'll make sure that this call was successful by typing require. Okay, else you'll say send to fallback failed. Okay, and that completes send to fallback function. What do we need to do for the withdrawal function? Again, this input amount will be a random input provided by foundry, so we'll need to bound it to some amount similar to what we did for deposit. I'll first paste it here, and instead of bounding it to the amount of beef that is locked in this contract. When we call the function withdrawal on Wef, what we want to bound it to is wef balance of address this, we're bounding the amount of ETH to withdraw from weft to zero and the weft balance of this contract.
00:05:35.590 - 00:06:06.094, Speaker A: And then we'll call weft withdrawal for the amount amount. Okay, that completes the handler contract for now. We'll come back to this contract later. But let's work on the invariant test. So I'll name this contract contract wef handler based invariant test is test. And then first let's write the setup. So say WEF public WEF, and we're also going to deploy the handler contract that we just wrote above.
00:06:06.094 - 00:06:39.642, Speaker A: So say handler public handler. And then next we'll write the setup function. Function setup public. We'll deploy the WEF contract WEf is equal to new WEF, and then we also deploy the handler contract handler is equal to new handler. Going back up, the constructor of handler takes in WEF as an argument. So here we'll provide WEF, and for this test, let's send 100 e to the handler contract. So I'll type deal address of handler 100 E.
00:06:39.642 - 00:07:31.210, Speaker A: So that will be 100 times ten to the 18. Okay, next, let's write our invariant test. So say function invariant. And for this example, let's test that the amount of EF that is locked inside the wef contract is greater than or equal to amount of ETH that was deposited from the handler contract. So here I'll type invariant e balance public. And what we want to do is assert greater than or equal to amount of e inside the web contract address web balance should be greater than or equal to the amount of ETH that is deposited from the handler contract. Now, to keep track of the amount of ETH that was deposited from the handler contract, let's go back up and inside here we'll declare a state variable that keeps track of the amount of beef that was deposited.
00:07:31.210 - 00:08:07.474, Speaker A: So here I'll type un public wef balance. And before we call the function deposit, we'll increase this weft balance. So say wef balance plus equals amount, and we'll do the same for deposit. Now, for withdrawal, we'll decrement the weft balance state variable. So replace this plus with a minus. So when we deposit, either by calling deposit or send to fallback, we'll increase this state variable called WEF balance. When we call the function withdraw on WEF, we will decrease this state variable.
00:08:07.474 - 00:08:56.946, Speaker A: So going back to our invariant test, we're going to assert that the amount of beef that is locked inside the WEF contract, amount of beef that was deposited from the handler handler WEf balance. This is the state variable that we just declared. Now, before you run this invariant test, if we were to run this invariant test right now, foundry will call functions both on WEF and the handler contract. But we want to tell foundry to test the WEF contract by calling only the functions inside the handler contract. So to do that, we'll need to target the handler contract. And that brings us to our next topic, how to target the contract. So, going back to our invariant test, what we'll tell foundry is to target the handler contract and not call any functions inside the WEF contract directly.
00:08:56.946 - 00:09:28.990, Speaker A: To do that, I'll type target contract address handler. So now when we run the invariant test, foundry will only call the functions inside the handler contract. So to show you this, I'm going to open my terminal, and then we'll execute the test for invariant two. T sol execute the test. And notice that our test passes. And also notice that our reverts is now equal to zero. So before, when we were simply testing the web contract, we were getting a lot of function fails.
00:09:28.990 - 00:10:06.698, Speaker A: But now, since we're targeting the handler contract, the number of fails on each test went down to zero. And this is because we wrote the handler contract to test the web contract only under certain conditions. And then we also told foundry to only target the handler contract. Now, similar to target contract, we can also target specific functions inside a handler contract. That brings us to our last topic, targeting selectors. So to do that here I'll say target selector. And this is the function that we need to call to target the selectors.
00:10:06.698 - 00:10:59.562, Speaker A: And for this example, let's target send to fallback, deposit and withdraw. So to do that, first I'll create an array of selectors. Selectors are four bytes, so bytes four memory. I'll call it selectors, and this will be equal to new we will initialize an array of four bytes, bytes four, and we're targeting three functions. So here I'll initialize it to three and then type selectors of zero is equal to one of the functions that we'll allow to call will be handler deposit selector. Okay, we'll do the same for two more functions. Selectors of one should be handler withdrawal, and the last one should be send to fallback and then update the index next to call this target selector.
00:10:59.562 - 00:11:27.538, Speaker A: What we need to do is pass in a struct called FUD selector. The address that we're targeting is address of handler. And the selectors that we're going to be targeting is selectors. Selectors is selectors that we just created above selectors. Okay, let's run the test again. So I'll put my terminal and then execute the test again. And a test still passes.
00:11:27.538 - 00:12:11.254, Speaker A: Okay, but are we certain that foundry is actually just calling these functions to test our idea? What I'm going to do is create a function inside the handler. And what it's going to do is when this function is called, it's just going to fail. So say function fail public. Then inside here, if this function is called, it's going to fail. So rebirth failed. And going back to here, we're going to temporarily remove this. And what I expect is that now we should get a lot of rebirths since some of the function calls will then here to test this, I'm going to open the terminal again, execute the test, and the number of rebirths has gone up from zero.
00:12:11.254 - 00:12:37.120, Speaker A: So it looks like at this point this function fail is being called by foundry. Okay, so let's test that this selector is actually working. What I'm going to do is uncomment it. And what we're telling foundry now is only call the functions deposit withdrawal or send to fallback. It's no longer going to call the function fail. Let's test this. So back inside the terminal, execute the test again.
00:12:37.120 - 00:12:54.330, Speaker A: And again the number of reverts is equal to zero, which means that this function fail is not getting called by foundry. So in this video, I showed you how to write a hamburger based testing. And I also showed you how to target a contract and target selectors for your invariant tests.
