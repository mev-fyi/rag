00:00:00.490 - 00:00:37.366, Speaker A: In the previous video I showed you example of an unsafe delegate call. When you forget that delegate call preserves context. In this video I want to show you another example of unsafe delegate call. When delegate call is used to update storage, the same state variables have to be declared in the exact same order. But what happens if the state variables do not line up? For example, you forgot to declare a state variable, or you declared it in the wrong order. Or you declared the wrong type. In this video, I'm going to show you an example of unsafe delegate call.
00:00:37.366 - 00:01:14.190, Speaker A: When contract a delegates call to contract B to update the storage. But the storage layout is different between contract A and contract B. Let's find out how this can be a dangerous mistake. Here we have two contracts, contract lib and contract hackme. Let's first take a look at the contract hackme. Up at top it has some state variables, an address type called lib, another address type called owner, and a unit state variable called some number. The constructor sets the address for the lib and owner to message sender.
00:01:14.190 - 00:01:56.210, Speaker A: It has a function called do something, which takes a unit as input and then calls the function delegate call. On the lib address inside the delegate call. It makes a request to call the do something function. So this line of code will try to call the do something function at the address of lib. Later, when we deploy this contract, we'll pass in the address of the lib contract above into this constructor. So now let's take a look at the lib contract. What does it do? The lib contract has a single state variable called sum number, and then it has a function called do something that updates the sum number state variable.
00:01:56.210 - 00:03:01.160, Speaker A: Now notice that the hackme contract declares three state variables, but the lib contract only declares a single state variable. So I've told you that if you want to update the state variables inside the hackme contract using delegate call, then the contract that is receiving the delegate call must also declare the same state variables in the exact same order. And in this case, you can see that the state variables in the lib contract and the hackme contract do not line up. So what can go wrong? Well, your challenge here is to update the owner state variable inside the hackme contract. The hint here is that this contract is using delegate call to update a state variable. It's trying to update the third state variable inside the hackme contract, but the actual state variable that is being updated here is the first state variable, which turns out to be the address of the lib contract. Go ahead and pause the video here and give it a try.
00:03:01.160 - 00:03:57.000, Speaker A: All right, so let's think through how we can update the owner state variable. Well, when we call this function do something, it will call the function do something inside the lib contract by using delegate call, and the function do something will update the state variable sum number. Now, inside this contract sum number is the first state variable. So when the function do something is called using delegate call, it will update the first state variable. In this case, the first state variable inside the contract that is making the delegate call is an address to the lib. So by calling this function, this will update the first state variable, which is the address of the lib. This means that we can update the address of the lib by calling the function do something.
00:03:57.000 - 00:04:53.254, Speaker A: Then we can pass in the address of the contract that we want to point the lib state variable to. Now, notice that I said we're going to be passing in an address here, but this function takes in a unit for the input. So here we'll have to be a little clever and cast the address to a uint. Once the address to the lib contract is updated to a contract that we specify, we can call the do something function again. But since the lib now points to the address that we set, it will delegate call to the contract that we specify. So when this delegate call calls the function do something inside our contract, we will be able to update the owner state variable. And this is because delegate call executes the code at the address of Div using the storage of hackme contract.
00:04:53.254 - 00:05:32.680, Speaker A: So we'll be able to update these state variables. That's the basic idea of how we're going to update the owner state variable. Let's now put this in code. We'll name this contract attack. The first thing that we'll do is copy the state variables from the hackme contract. So from the hackme contract, I'm going to copy all of the state variables and then paste it inside the attack contract. The reason why we're doing this here is so that when we write the code to update the state variable, target it at the hackme contract, this will make sure that we are updating the correct state variable that we want.
00:05:32.680 - 00:06:35.706, Speaker A: Next, we'll declare the state variable for the hackme contract, and then we'll set the hackme state variable to the hackme contract above when we deploy this contract. Now, earlier I said that the contract calling delegate call and the contract being called, the state variables have to be the same. So you might have noticed that the state variables in the hackme and the attack contract are now different. Here inside the attack contract we have an extra state variable called Hackme. But this won't be a problem here, since all of the state variable that we want access to inside the hackme contract are declared in the same exact order. So this state variable here, Hackme, will be stored in the storage location where the original contract hackme above does not have access to. Just to clarify what I mean here, the first three state variables are stored in slot zero to slot two.
00:06:35.706 - 00:07:15.906, Speaker A: This is true in both the hackme contract and the attack contract. But the last state variable, Hackme, is stored in slot three. Now, if you look inside the hackme contract, you can see that there is no state variable stored in slot three. So declaring a state variable here will not cause any problems in the original contract. So that was an explanation of why we can have state variables that look a little bit different, as long as the state variables that we are concerned with are the same. All right, moving on. Let's now write the function that will actually hack the hackme contract.
00:07:15.906 - 00:08:00.166, Speaker A: The first thing that we'll do is call the do something function inside the hackme contract. We'll want to pass the address of this contract, but since the function takes in a uint as input here, we'll cast the address as un. On the next line, we'll call the same function again and then pass in some number. It doesn't really matter here, so I'm just going to pass in one. When this liner code is executed, it will delegate call to call the function do something inside this contract. So let's write the do something function inside this contract. The do something function is the function that will be called when the hackme contract delegates call.
00:08:00.166 - 00:08:55.270, Speaker A: First we'll make sure that the do something function here has the same function signature as the do something function above. So the name is the same and the input is the same, and the function visibility is the same. Now, when this function is called, we want to say something like the owner state variable is equal to this contract. But remember that this function will be called using delegate call, so the context will be preserved to the caller. Okay, so let's figure out which contract is going to be calling this function, so that we'll be able to put the correct value here and update the owner state variable to this contract. Our starting point is line 53, hackme do something. Which means that this contract, the attack contract is going to call the hackme contract.
00:08:55.270 - 00:09:43.670, Speaker A: The hackme contract will delegate call to the attack contract, and this function here will be called. This means that inside the hackme contract, message sender will be equal to attack, and when the hackme contract calls the attack contract using delegate call, it's going to preserve the context. So message sender will still be equal to attack. This means that when this function is called, the address of this contract is equal to message sender. So here we can update the owner to this contract by saying owner equals message sender. That completes the code that will update the owner state variable inside the hackme contract. Let's go over how this exploit works.
00:09:43.670 - 00:10:42.780, Speaker A: First eid calls the attack function. This will call the do something function inside the hackme contract above, and we'll pass in the address of this contract, cast it into un. So this line of code will call the function above over here, and here num will be the address of the attack contract, cast it into un. The function will use delegate call to call the do something function inside the lib contract, which means that this function here will be executed and it's going to update the first state variable. Now since here we pass the address of the attack contract, this line of code will update the first state variable to the address of the attack contract back inside the hackme contract. This means that the first state variable which is equal to lib. So this address will be updated to point to the attack contract that completes the execution of line 52.
00:10:42.780 - 00:11:57.566, Speaker A: In line 53 we call the same function again, and this time it doesn't really matter what number we pass in. Now again, this line of code will call the do something function inside the hackme contract. So this will call the do something function again inside the hackme contract. And again it uses the delegate call to call the do something function. But now the state variable lib no longer points to the contract above since the first call to do something updated the bib state variable here, and since it points to the attack contract below, this line of code will call the do something function inside the attack contract, and it will execute this code here, which will update the owner state variable. Now since all of this runs inside the context of the hackme contract, the owner that's going to be updated is not the state variable here, but the state variable inside the hackme contract. And that's how you update this owner state variable by making two delegate calls.
00:11:57.566 - 00:12:47.490, Speaker A: The first one will update the address of the lip contract to point to this contract, and the second one will call this function that's going to update the owner state variable. Let's now see this in action using remix. We'll say that the first account is Alice and she's going to deploy the hackme and the lib contract. Account two is eve and she's going to deploy the attack contract. So first Alice is going to deploy the lib contract and then copy the address of lib. And then she's going to deploy the hackme contract. Next, switching over to Eve, she's going to deploy the attack contract with the address of the hackme contract.
00:12:47.490 - 00:13:33.598, Speaker A: All right, so we're now ready to demonstrate the exploit, but first let's check the owner of the hackme contract. That is the address of Alice. Let's now call the attack function. You can see here that the attack was successful, so let's check back on the owner. So I'm going to click owner again, and you can see here that the owner has changed. You can also see here that this address is equal to the address of the attack contract here. So the attack to take over the owner state variable was successful, and that completes the demonstration of unsafe delegate call.
00:13:33.598 - 00:13:59.540, Speaker A: So when you're using delegate call, you need to keep in mind that delegate call hands over the control of the storage and the ether of a contract to another contract. And if you're updating state variables using delegate call, then make sure that the storage layouts are the same. This video was about what can go wrong using delegate call when the storage layout are not the same. Thanks for watching and see you later.
