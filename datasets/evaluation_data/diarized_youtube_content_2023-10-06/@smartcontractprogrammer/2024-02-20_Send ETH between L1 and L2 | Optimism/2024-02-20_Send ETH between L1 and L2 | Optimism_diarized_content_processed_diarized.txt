00:00:00.330 - 00:00:46.854, Speaker A: In the previous two videos, I covered how to send message from L1 to L two on optimism, and message from l two back to l one. We now have all of the knowledge and the tool to send e from L1 to L two and then back from L two to L1. So in this video, I'll show you how to send e from L1 to L two on optimism, and then send e back from optimism back to L1. Here are the steps that we'll follow. We'll write a wallet contract and then deploy this on L1 and also on L two. We'll first send e from L1 to L two, check the ETH balance on the l two contract, and then we'll withdraw from L two. Next, we'll send e from L two back to L1, check the e balance on L1 contract, and then withdraw e from the l one contract.
00:00:46.854 - 00:01:18.674, Speaker A: So let's start by writing the contract. First thing that I'll do is declare the interface that we'll need to call between L1 and L two. And this interface is the I cross domain messenger. I'll copy this and then paste it into here. This is the interface that we used for the greeter contract. All we have to do to enable sending Ef is to change this function declaration, send message, and declare as payable. And now we'll be able to send ef to the cross domain messenger contract.
00:01:18.674 - 00:01:48.190, Speaker A: Okay, moving on. I declare address as immutable and inside the messenger we'll store the address of the icross domain messenger. So constructor will pass in the address of the messenger address messenger. And we'll set this equal to messenger. Messenger is equal to messenger from the input. We want to enable this contract to be able to receive beef. So I'll declare receive external payable.
00:01:48.190 - 00:02:29.318, Speaker A: This will enable the wallet contract to be able to receive e that was directly sent into this contract. Okay, next we'll write a function that will send e from L1 to L two. And we can also use this function to send e from L two to l one. So say function send. We're going to deploy this wallet contract both on l one and l two. When we send e from L1 to L two, we'll need to pass in the address of the contract that is deployed on l two. And when we're sending e from l two back to l one, we'll need to pass in the address of the wallet contract that is deployed on l one, we'll call this address remote wallet external payable.
00:02:29.318 - 00:03:25.614, Speaker A: Payable because when we call this function we'll also send e and then I cross domain messenger pass in the messenger address send message and when we call this function send message we also send some e so say value we'll send message value whatever amount that was sent. When we call the function send, we'll also send it to the icross domain messenger. Then what are the parameters that we need to pass to send message? Well, scrolling up these are the parameters. I'll copy these parameters. Okay target this will be the address of the l two contract remote wallet message this will be the function that we want to call on the remote wallet contract. Since we're directly sending eve, we'll just leave this as blank. So when the remote wallet is called we're not calling any function.
00:03:25.614 - 00:04:03.398, Speaker A: So the receive external payable function will be executed. Okay, and gas limit let's say 200,000. Okay that completes the function send so now when we call this function send this contract will forward all of the EF that was sent over to the cross domain messenger contract. The cross domain messenger contract will relay our message and then send ETH over to the remote wallet. When the remote wallet receives the ETH, it will execute this code. Okay, next I'll create some helper functions for this demo. First function that I'll create is a function that can query the balance of ef inside this contract.
00:04:03.398 - 00:05:01.542, Speaker A: Say function get balance external view returns un 256 and it will simply return the balance of e locked in this contract return address this balance okay once ETH is sent to this contract, we want a way to be able to withdraw the ETH. So the last function that I'll create is a function to withdraw ETH function withdrawal external and for this demonstration I will not write any authorization code. Anyone calling this function will be able to withdraw the ETH inside this contract. Boolean okay we'll use the low level call to send ETH over to message sender. Message sender call value will be the balance of e in this contract. Address this balance we'll just require that this function call was successful. Require okay call failed.
00:05:01.542 - 00:05:27.794, Speaker A: Let's try compiling the contract. Hit ctrl s and the contract compiles. The next step is to deploy this wallet contract on L1 and on L two. First I'll deploy this contract on L1. So make sure that your wallet is connected to L1. Testnet this will be sepolia. Then click on Deployment tab and then click on injected provider and then scrolling down we will deploy the wallet contract for the address of the messenger for Sepolia.
00:05:27.794 - 00:06:04.306, Speaker A: I'll copy this address, and then click deploy, confirm the transaction once the transaction goes through. Next, I'll switch over to the L two network. So this will be op sepolia. Click on network, click on op Sepolia, and then make sure that inside remix we're connected to op sepolia. And then we'll deploy the wallet contract. The messenger contract is this address. I'll copy this, paste it here, and then call deploy, confirm the transaction, and we now have the wallet contract on L1 and the wallet contract on L two.
00:06:04.306 - 00:06:31.690, Speaker A: I'll copy the addresses into here. And let's start by sending e from L1 over to L two. So need to switch back to L1. Click on sepolia, and inside remix. Make sure that we're back into sepolia. And then to send you from L1 to L two, we'll need to call the function send, and then pass in the address of the remote wallet. The address of the remote wallet is this address.
00:06:31.690 - 00:06:58.078, Speaker A: So I'll copy this, paste it here, and let's send one way. So we're sending one way over to the l two contract from L1. And then call the function send. Okay, the transaction was processed on L1. I'll wait a few minutes for the transaction to be relayed over to l two. In the meantime, I'll switch network over to L two. Click on op supportio.
00:06:58.078 - 00:07:21.846, Speaker A: Okay, I waited about three minutes. Make sure that you're on op sepolia. This is L two. Scroll down and let's check the balance of the wallet contract on L two. Open the wallet contract on L two, and let's call the function get balance, and we get that the balance is equal to one. This is the one way that we sent from l one. Next, I'm going to withdraw this one way from the l two contract.
00:07:21.846 - 00:08:03.042, Speaker A: So call withdrawal, and then confirm the transaction. The transaction was processed. Let's click on the function, get balance, call the function, get balance, and the balance is now zero. The next thing that I'll show you is send eve from l two back to l one. So inside the l two contract, we'll call the function send, and for the remote wallet address, we'll paste in the address of the wallet contract deployed on L1. Paste the address of the l one wallet contract, and let's again send one way. So here, I'll put in one, and then call the function send, confirm the transaction, and the transaction was processed.
00:08:03.042 - 00:08:34.818, Speaker A: Now, remember back in the video when we sent a message from L two over to the L1? We had to do some extra steps. We had to copy the transaction hash and then run a node script. So here we'll do the same. I'll copy the transaction hash from metamask, so click on send. This was the function call that was made, and then I'll copy the transaction id. Remember in the greeter video we wrote a node script that will relay the transaction from L two over to L1. We use this node script to send message from L two over to L1.
00:08:34.818 - 00:09:23.706, Speaker A: This time we'll do the same and send e from L two over to L1. To execute this script inside source, we'll need to call this command now inside m file I have my private key, which I will not show. So first we'll need to set the environment variable l two tx to the transaction hash that we copied inside my terminal. I'll set an environment variable pasting the transaction hash. L two tx equals paste the transaction hash. Next we'll execute this command, say emb cat emb l two tx equals l two tx and the script is node source index js. The script failed with the message cannot estimate gas.
00:09:23.706 - 00:10:13.054, Speaker A: So I executed the script once again, I got a new error message saying with jaw hash already been proven. So what I'm going to do to fix this error is I'll comment this code out messenger prove message, and then we'll try executing the script again, execute the script, and hopefully this time it will be successful. And this time the script failed again with the message. Withdrawal has already been finalized. Okay, so if you go back to our contract now one, then we should have received one way even though the script did not execute successfully. Back inside vmix, make sure that you're on Sepolia and scroll down and let's check the balance of the contract deployed on L1. It's called a function get balance, and surprisingly it has one way.
00:10:13.054 - 00:10:37.380, Speaker A: This is the one way that was sent from l two over to L1. So in this video we sent e from L1 to L two, and then from l two back to L1. To send e from L two back to L1. We executed this script. This script failed multiple times, but by looking at the errors and then commenting out some of the code and then executing the script once again, eventually the transactions went through.
