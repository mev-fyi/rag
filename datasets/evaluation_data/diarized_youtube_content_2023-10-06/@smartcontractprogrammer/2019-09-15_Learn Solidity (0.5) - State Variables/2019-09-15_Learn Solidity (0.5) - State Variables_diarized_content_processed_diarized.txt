00:00:00.250 - 00:00:46.950, Speaker A: Using a smart contract, you can store data permanently on the Ethereum blockchain, but it is very expensive to use the Ethereum blockchain as a data storage. Today, the price of Ethereum is $171, and storing 1 data would roughly cost you $1,100. In this video, I'll show you how to write a simple contract to store arbitrary data on the blockchain and briefly go over an alternative way to store large data. Variables in solidity are stored in one of the three locations storage. This is where data can be permanently stored and these variables are called state variables. This is like your hard drive memory. Variables are only available while function is executing.
00:00:46.950 - 00:01:40.090, Speaker A: This is like your computer memory call data. This is where some function arguments are stored, but we'll ignore this one since we don't need to understand this one for our contract. For example, variables declared here inside a contract, but outside the functions are state variables and they'll be stored onto the blockchain. Variables declared here inside the function are only available during function call, and they won't be stored onto the blockchain. Functions and solidity can be categorized into two types. Functions that create transactions on the blockchain and functions that don't. Functions that create transactions write data on the blockchain, like changing the value of a state variable which changes the state of the smart contract, or sending ether to another account, which changes the balance of accounts recorded on the blockchain.
00:01:40.090 - 00:02:17.890, Speaker A: Functions that don't create any transaction on the blockchain are free to call, and they do not change the state of the blockchain. An example will be a function that reads and returns the value of the state variable inside a smart contract. Now let's put all the concepts mentioned above into code. We'll create a simple smart contract to store text. Let's name it simple storage. Inside the contract, we need to declare a state variable of type string to store the text. We also need two functions, a public function to update the text variable we'll name it set, and another public function to get the text variable.
00:02:17.890 - 00:02:56.990, Speaker A: We'll name this one get to update the text variable. In our contract, we need the set function to take the new string value as input. In solidity, you need to declare the type of function inputs. In our case, we have a single input of type string. For certain data types, including string, you have to explicitly declare the data location. So let's think about which keyword we need to use, either storage or memory. If we use the keyword storage, then we are telling solidity that our input is a value stored somewhere in our contract, but that cannot be the case since we'll be providing a value for the input from outside the contract.
00:02:56.990 - 00:03:27.882, Speaker A: So we'll declare as memory. If you accidentally declare as storage and try to compile it, you'll get an error like this. For public functions, inputs must be declared as memory. Anyways. Let's name this input as text prefixed with an underscore in solidity, it is common practice to prefix function inputs with an underscore. This is done to avoid using the same name as state variables. In this case, we differentiate the text variable with our new text input.
00:03:27.882 - 00:04:10.860, Speaker A: By prefixing with an underscore inside the function, we update the text variable to the new value simply by reassigning it with our input. There are two ways to get variables from a smart contract. One way is to write a function to return the value, and the other way is to let solidity compiler write one for you. So why not let solidity write one for you all the time? Well, there are cases when it's better to write your own. For example, you might want to return multiple values from a single function call instead of calling two separate functions. I will explain this in a future video okay, so let's go over the first way of getting variables. Writing our own function.
00:04:10.860 - 00:05:04.026, Speaker A: We need our get function to return the string value stored in the text variable. So we declare that in our function definition here with the keyword return followed by the type of values we are returning in our case string. Again, we need to declare the data location for our string type. Our text variable is stored in a contract storage, so you might think that we need to declare storage here, but we need the actual value stored in the text variable, not the reference to the variable, so we'll declare it as memory. We also need to tell solidity that this function does not modify any state variables. We do this by using either the keyword view or peer. In short, BU declares that your code does not change the state of the blockchain, and peer declares that your function does not change the state of the blockchain, and it also does not read any state variables.
00:05:04.026 - 00:05:39.622, Speaker A: For our case, we want to read the state variable, so let's put the bu keyword in a future video. I'll go over them in detail, so stay tuned. Inside the function we just return the text variable and our getter function is completed. The second way of accessing variable is to let solidity compiler automatically create getter functions. All we have to do is to prefix our state variables with a public keyword. After we compile and deploy our contract, you'll see that we have access to public state variables by executing the function with the same name as our variable. Now let's compile it and test the contract.
00:05:39.622 - 00:06:09.390, Speaker A: Make sure that the compiler is compatible with the version defined in our smart contract. Compile and then deploy it. You can see here that we have three functions set to update the text variable get to get the value stored inside the text variable. We also have a function with the same name as our text variable. This is the function that was automatically created by the compiler. We can update our text stored in the smart contract by calling set. Notice here that a transaction was created.
00:06:09.390 - 00:06:40.026, Speaker A: Also notice here that our account has spent some ether. If you hold any real ethereum, don't worry, it didn't spend any of it from your wallet. This is just a simulation. We can verify that our text value was updated by either calling get or text. Earlier I mentioned that storing data on the blockchain is very expensive. One way to go around this problem is by using IPFS. In short, IPFS is a peer to peer file storage and anyone can access data by knowing the hash of the data.
00:06:40.026 - 00:07:17.990, Speaker A: So when you upload your data to IPFS, you get a hashbag, which is the location of your data. And in our smart contract we store the ipfs hash. In this way you accomplish two things, store large amount of data for cheap, and use the smart contract to let everyone know where your data is stored. Let me show you a quick example. Here we have an image of a cat that's been already uploaded to IPFS. We copy the hash of this image next in our contract we store the hash. Now anyone can download and see the cat image by first reading the ipfs hash from our contract and then accessing IPFs at the hash.
00:07:17.990 - 00:07:54.266, Speaker A: In this video we talked about smart contract storage. Variables are stored in three locations, storage, memory, and call data. But in most cases you only need to consider storage and memory. Variables stored in smart contracts are called state variables. Functions can be categorized into two groups, ones that create transactions on the blockchain and ones that don't. Functions that don't create any transaction are declared with the keyword view or peer functions that do create a transaction. Write data on the blockchain, like updating the value of a state variable stored in your contract.
00:07:54.266 - 00:08:12.340, Speaker A: Solidity automatically creates functions to return the value of public state variables. Storing data on a smart contract is expensive, and by using IPFs you can effectively save large amount of data on a smart contract. I'm going to wrap up around here. Thanks for watching, and I'll talk to you later.
