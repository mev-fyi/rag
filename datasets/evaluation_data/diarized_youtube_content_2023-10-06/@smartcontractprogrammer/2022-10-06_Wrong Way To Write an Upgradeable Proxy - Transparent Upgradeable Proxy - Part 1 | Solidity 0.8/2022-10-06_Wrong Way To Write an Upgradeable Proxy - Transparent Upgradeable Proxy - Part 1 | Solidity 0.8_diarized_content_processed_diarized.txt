00:00:00.250 - 00:00:29.714, Speaker A: We're going to be recreating the transparent upgradable proxy. This is an upgradable smart contract. So over the next few videos, these are the topics that I'll cover. In this video, we'll go over the introduction. We'll first implement an upgradable proxy contract in the wrong way. Then I'll show you some problems that we have with this wrong implementation. Next we'll talk about how to return data from a fallback, how to write to any slot in the storage of the smart contract, and where to store the address for the implementation and the admin.
00:00:29.714 - 00:00:58.334, Speaker A: Next we'll separate the admin and user interface, and then we'll write a proxy admin contract. And finally we'll go through a demo. So for this video, let's start with the introduction. The wrong way to build an upgradable proxy contract. For this example, we'll start with a contract called counter b one. It has a count and it has a function to increment, and then we'll upgrade counter b one to counter b two. It still has the count state variable, it still has the increment function.
00:00:58.334 - 00:01:48.954, Speaker A: The difference is that we'll be adding a decrement function to counter b two. So we're going to be writing a proxy contract where we initialize our contract as counter b one, and then later we upgrade it to counter b two. Okay, let's write our proxy contract. So I'll say contract, and just to make this clear that this is a wrong implementation, I'll name this buggy proxy, so don't use this contract in production. For the proxy contract, we'll need to store two addresses, the address of the implementation and the address of the admin, where only the admin will be able to upgrade the contract. So I'll say address public implementation, and then address public admin. We'll store the admin when we initialize the contract.
00:01:48.954 - 00:02:18.310, Speaker A: So I'll say constructor, then say admin is equal to message sender. And then we'll have a function where the admin can upgrade the implementation. So I'll say function upgrade. I'll name it upgrade two. It'll take in a single input of the address of the new implementation. I'll say address underscore implementation. This function will be external.
00:02:18.310 - 00:03:29.422, Speaker A: Then we'll require that only the admin of this contract can call this function require message sender is equal to admin with the error message not authorized. And then we'll set the implementation implementation to the new implementation underscore implementation. So we'll be able to upgrade the contract from counter b one to counter b two by calling upgrade two, passing in the address of the counter b two contract. If we wanted to call other function, for example, we want to call the increment function or the count function. Then we'll forward all of the request using the fallback function. So say fallback external payable, and then inside here we'll use delegate call to forward our call to the implementation contract. So say implementation delegate call, and we'll forward all of the call data.
00:03:29.422 - 00:04:07.514, Speaker A: So say message data. This will return two outputs. The first output is whether the delegate call was successful or not. Boolean I'll name it, okay. And the next output will be the bytes of outputs that was returned by calling delegate call by executing some function in the implementation contract bytes memory. I'll call it rest short for a response and then we'll check require that boolean okay is true require okay with the air message delegate call failed. Now for solidity 0.8,
00:04:07.514 - 00:04:57.910, Speaker A: there is the fallback and the receive function, which is kind of like the fallback, except that it is triggered when message data is empty and we want to reuse the same functionality. So I'll put this part of the code inside an internal function. So first I'll declare a function receive external payable. Next I'll create an internal function function, delegate. I'll make the visibility private, and then cut this part of the code, paste it here and inside the fallback, and the receive we'll call delegate. Inside receive we'll call delegate. Okay, this completes our initial version of the proxy contract.
00:04:57.910 - 00:05:29.350, Speaker A: So let's deploy this contract and then upgrade from counter b one to counter b two. So I'll hit Ctrl s, make sure that the contract compiles. Then let's deploy the contract. So first I'll deploy the proxy contract, the buggy proxy. Next I'll deploy counter b one, and I'll also deploy counter b two. Now if you open the buggy proxy contract now and click on implementation. We have not set the implementation contract yet, so the address is zero.
00:05:29.350 - 00:06:08.674, Speaker A: So let's set it to counter b one. I'll copy the address of counter b one and then paste it inside here, and then call upgrade two. Let's check that the address of the implementation is not zero address. Click on implementation, and it is now storing the address of counter b one. Okay, next let's try calling some functions on counter b one. The only function that we can call is increment, so let's see what happens when we call the function increment. To do that, I'll copy the address of the buggy proxy contract, scroll up and then select counter b one, and then build the contract with the interface for counter b one.
00:06:08.674 - 00:07:01.330, Speaker A: At the address of the proxy, scroll down and then open counter b one, and then we'll call the function ink the transaction is successful. So let's check on the count. If we click on count, notice that the count is still zero, we call the function increment, so the count should be equal to one. But notice that the count is zero. So what is going on? Well, recall that when we use delegate call inside the buggy proxy contract, we execute the code for counter b one, but using the storage for buggy proxy contract, inside the storage of the buggy proxy contract, the zero slot stores the address of the implementation. However, if we look at the zero slot for counter b one, it stores the count. So when we call the function ink, it increments the zero slot by one.
00:07:01.330 - 00:07:35.866, Speaker A: So this means that this would change the address of the implementation. It adds one to the address of the implementation. And we can check this by scrolling to our buggy proxy contract. And this was the address of the implementation before. And if we click again, you'll notice that the address has changed. This is because when we call the function increment, it incremented the address of the implementation by one, and it changed the address that we see over here. To fix this problem, we'll need to align all of the storage layout for all of the implementation contract.
00:07:35.866 - 00:08:14.058, Speaker A: So what we'll need to do is copy this and then paste it here. And likewise for version two, we will have to do the same. What we're doing here is saying that for all of the contract, the zero slot will be the address of the implementation. The first slot will be the address of the admin. And this is true for both version one, version two, and the proxy contract. So that is one mistake in our implementation of the upgradable contract. The other problem that we're having right now is that if we try to get the count, notice that it will execute from the fallback, but the fallback cannot return any data.
00:08:14.058 - 00:08:54.930, Speaker A: So this means that we won't be able to get the count from the counter contract. So in this video we try to write our own upgradable contract and encounter two problems. The first problem is that all of the implementation contract will have to have the same storage layout as the proxy contract. We'll need to declare implementation in admin for the first two storage of all of the implementation contract. You can see implementation in admin here. And for version two you can see the same storage layout. The other problem that we are facing now is that when we try to get the count, since the call goes through the fallback function, but the fallback function cannot return any data, we cannot get the count of the counter.
00:08:54.930 - 00:09:07.780, Speaker A: So those are two problems that we faced when we wrote our own implementation. We'll solve these problems one at a time in the upcoming videos. For the next topic, we'll cover how to return data from the fallback. See you in the next video.
