00:00:00.410 - 00:00:38.422, Speaker A: The process of verifying a signature using solidity is in four steps. First you have the message to sign, and then you hash the message. Next you would sign the message. This will be done off chain. This will not be done inside the smart contract, so this will be done off chain using your wallet. In the last step, we can verify the signature inside a smart contract by calling the function ec recover pass in the hash of the message and the signature. This function will return a signer, and you can check that the signer that was returned from this function ecrecover is actually equal to the true signer that signed the message.
00:00:38.422 - 00:01:14.418, Speaker A: I'm going to show you how to verify a signature inside solidity. The first thing that we'll do is create a function called verify, which will take in a message signature and the signer and verify that the signature is valid. Along the way, we'll need to create some internal functions, so we'll do that after we create the main function verify. So let's get started. I'll create the function by typing function verify. It's going to take in several inputs address of the signer. This will be the address that we expect EC recover to return.
00:01:14.418 - 00:01:51.114, Speaker A: Next will be the message that we're signing. For this example, we'll keep it simple and we'll sign a string message. So say string memory message. The last input will be the signature, so it'll be bytes memory sig. We will make this function external peer and it will return a boolean. If the signature is valid and the signer that was returned by EC recover is actually equal to the signer from the input, then it will return true. Otherwise we'll return false.
00:01:51.114 - 00:02:32.826, Speaker A: So, as outlined in the first step, the first thing that we will do is hash the message. For hashing the message, we'll use catch Act 256 and the hash returned by catch Act 256 is bytes 32, and we'll name this variable. Message hash is equal to get message hash. This will be a function that we all write out later. Basically, it will do a catch Act 256 of the input. The input will be the string message that we pass as an input to the function verify. Now when we actually sign the message off chain, the message that is signed is not message hash.
00:02:32.826 - 00:03:20.578, Speaker A: This hash that is actually signed is also bytes 32, and we'll name it e sign message hash is equal to get e sign message hash, and then we'll pass in the message hash from step one. We have not defined this function yet, but we will do it later. For the last step, we'll take this e sign message hash. Verify it with the signature. This will recover the signer. So we'll check that the signer that was returned is equal to the signer from the input. We'll define this function later, but for now we'll say recover passing in the eve sign message hash and also the signature.
00:03:20.578 - 00:03:57.362, Speaker A: And then we'll compare with the signer from the input, and then we'll return this. This completes the function verify and this will be the main function that we're going to be calling to verify a signature of the message. We'll now write the code for get message hash. Geteafsign message hash and the function recover. Let's start with get message hash. A function get message hash will take in a single input a string memory message. We will make this function public.
00:03:57.362 - 00:05:04.086, Speaker A: This function will be peer, and it will return bytes 32 of the hash of the message. Inside this function, we'll simply return the catchack 256 of abi encode packed message. Next, we'll write the function for get e sign message hash. I'll copy this function, paste it here, and then rename this function to get e sign message hash. The input to this function will be bytes 32 of message hash, so also change the input to message hash. Earlier I said that when we actually sign the message hash, this hash will be actually prefixed with some strings and then hashed again, and that will be the actual message that is signed. The string that is prefixed to message hash is some string with the message ethereum sign message followed by the length of the message bytes 32.
00:05:04.086 - 00:05:59.562, Speaker A: So the length of the message 32, we append the actual message hash and then take the catch act 256 of this whole string. So this is the actual message that is signed when you sign a message off chain. Once we have the actual message that is signed the e sign message, we'll now write the function called recover that will take the e sign message and signature and recover the signer from these two inputs. The function recover will take two inputs bytes 32 of eve sign message hash, and bytes memory of the signature. For this example, we'll make this function public. This function will be peer, and it will return the signer recovered from the signature and the e sign message hash. So we'll type returns address from the signature.
00:05:59.562 - 00:06:54.382, Speaker A: The first thing that we need to do is split the signature into three parts, so we'll say bytes 32 r bytes un eight b is equal to an internal function called split, which we will define later. Passing in the signature. The r and s over here are cryptographic parameters used for digital signatures. And the parameter b is something unique to ethereum. We won't need to worry what all of these parameters mean. All we need to do with these parameters is pass it to the function called ec recover, passing in the message that was signed, which will be e sign message hash, and then passing in bRns. This is a function available in solidity, so we will not have to define this function.
00:06:54.382 - 00:07:42.622, Speaker A: This function returns the address of the signer given the signed message and these parameters. So we'll return the signer by typing return, and the last function that we'll write is split. How do we split the signature into these three parameters? So I'll name the function split. It's going to take in bytes memory sig for the input. We'll make this function internal peer, and it's going to return three parameters. So you'll type returns bytes 32 r bytes un eight b. We'll do a quick check on the signature and make sure that the signature length is equal to 65.
00:07:42.622 - 00:08:27.978, Speaker A: Why is it 65? Well, it is because bytes 32 is 32 length. The next bytes 32 is another 32 length, and un eight is one byte, which is one length. 32 plus 32 plus one is equal to 65. So we'll type require sig. Length is equal to 65, and if it is not, we'll throw our message saying invalid signature length. Once we know that the signature length is equal to 65, we'll get the parameters for RSB from the signature sig. And to do that we'll use assembly.
00:08:27.978 - 00:09:00.890, Speaker A: So I'll type assembly. Now, Sig is a dynamic data. This is because it has a variable length, and for dynamic data type. The first 32 bytes stores the length of the data. That's one thing to remember here, and the other important thing to remember here is that this variable sig is not the actual signature. It is a pointer to where the signature is stored in memory. So with that in mind, we can get the value of r by typing r assigned to m load.
00:09:00.890 - 00:09:51.718, Speaker A: This will load to memory 32 bytes from the pointer that we provide into this input. The first 32 bytes of sig is the length of the sig, so we'll need to skip it by typing add to the pointer of sig 32. Again here we're saying that from the pointer of sig, skip the first 32 byte because it holds the length of the array. After we skip the first 32 bytes, the value for r is stored in the next 32 bytes. Next, we'll get the value for s by saying s assigned to m load. So load from memory, add to the pointer of sig, skip the first 32 because it stores the length, and also skip the next 32 because it holds the value for r. 32 plus 32 is 64.
00:09:51.718 - 00:10:22.658, Speaker A: You'll do something similar for the value of b as well. So we'll say b. Assign to load from memory, add to the pointer of sig. We want to skip the first 64 plus another 32, which stores the value of S. So we'll say 96. And then for the value of b we don't need 32 bytes, we only need the first byte. So we'll say byte, get the first byte from the 32 bytes after 96.
00:10:22.658 - 00:10:58.506, Speaker A: Now, notice that I don't have to type return RSMB. This is because the return is implicit. We named our return values here and then we assigned it here. So solidity will implicitly return these values. We're now done with this function, and this completes this contract. Let's now deploy this contract and actually sign some message and verify it. I'll compile the contract by hitting compile sig, then deploy the contract, scroll down, and then open the contract for the message that we're signing.
00:10:58.506 - 00:11:33.450, Speaker A: We'll say it is secret message, and then we'll get the message hash. So this will be the message that we're going to be signing. Using Metamask I'll open my browser console by typing f twelve, and then we'll enable metamask by typing ethereum enable. This will return a promise. I'll open the promise and make sure that it is fulfilled, meaning that there was no error. Opening metamask I'll assign account that I'm going to be using to a variable named account. This is the count that I'm going to be using to sign the message.
00:11:33.450 - 00:12:11.202, Speaker A: The message that I'm going to be signing is a hash equal to it will be this hash over here. And to sign the message inside the browser console, I'll type Ethereum request. The method that I'm going to call is personal sign and the parameters that I'm going to pass is the account and the hash. Then hit enter. I'll sign the message, and this will return a promise again if I open it. I can see here that this is the signature. Once we have the signature, we can now call recover and verify.
00:12:11.202 - 00:13:41.166, Speaker A: To call recover, we'll need to pass in the e sign message hash. So we'll take this hash, copy it, paste it here, and then call e sign message. So this will be the message hash that we'll need to pass to the function recover to recover the signer the function recover takes in two parameters, e sign message hash and the signature. So I'll copy the e sign message hash from here, paste it here, and for the signature we'll copy it from the browser console signature, copy it, paste it here, and then call, scroll down, and the function recover, return this address over here, and if you look at the browser console over here, you can see that the account matches the signer that was recovered. So now if we call, verify for the signer, we'll again paste the address of the signer, the message that we signed was secret message, and the signature, we will get it from the browser console, paste it, call, scroll down, and the signature checks out. Now, just to show you that this function is working correctly, I'm going to change the message a little bit, then call, and it returns false. Likewise, if I fix the message and maybe change the signature a little bit, for example, change the first five to one and then call again, it returns false.
00:13:41.166 - 00:14:26.426, Speaker A: To give you a better idea why it is returning false, we'll call the function recover when we change the message. For example, say secret messages, and then call get message hash. This will change the hash. And if I were to provide this hash into e sign message, and then call e sign message, this will change the e sign message hash. And if I were to put this inside here, then the recovered address will be not equal to the actual signer. And just to show you this, I'm going to change a valid e sign message hash to something else by changing the first nine to a one. And then if I call, notice that the address changed, the signer that was recovered is not equal to the actual signer.
00:14:26.426 - 00:14:48.690, Speaker A: I'll fix the e sign message hash. The other case where the verification fails is if the signature is invalid. Here we have a valid signature. Sure, and I'm going to invalidate this signature by changing some of the input. For example, changing the first five to a one again, then calling call again. Notice that the signer that was returned is not equal to the actual signer.
