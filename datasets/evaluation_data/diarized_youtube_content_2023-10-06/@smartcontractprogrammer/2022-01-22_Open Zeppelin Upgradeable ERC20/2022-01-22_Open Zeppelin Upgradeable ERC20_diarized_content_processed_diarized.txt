00:00:00.250 - 00:00:48.300, Speaker A: Today, I'm going to show you how to turn an ERC 20 token contract into an upgradable contract. Now, if you already have your ERC 20 token deployed onto the blockchain, then you won't be able to upgrade it. However, if you have not already deployed the ERC 20 contract and you're thinking about making it into an upgradable contract, then this video is for you. And just to make this example a little bit more practical, this ERC 20 token is ownable, so only the owner will be able to mint some tokens. Now, let me show you how to turn this regular ERC 20 contract into an upgradable ERC 20 contract. The first thing that I'll do is create a new file. So I'll call this mytokenup gradable Sol.
00:00:48.300 - 00:01:40.970, Speaker A: And then we'll start off by copying the regular ERC 20 token contract and then paste it in here. Next, we'll turn this regular ERC 20 contract into an upgradable contract. The first thing that we'll do is change the imports. Now, if I open package JSON notice that I've imported Openzeppelin contracts, this holds the regular ERC 20 contract, and I also have Openzeppelin contracts upgradable. This library has all of the contracts from Openzeppelin, which are converted to be upgradable. So we'll change our import from the regular Openzeppelin contracts to Openzeppelin contracts upgradable. So we'll change the first import by saying open Zeppelin contracts upgradable.
00:01:40.970 - 00:02:17.518, Speaker A: And the contract that we're going to be importing is not a regular ERC 20 contract, but ERC 20 upgradable. We'll do the same for the ownable contract. So we'll say open Zeppen contracts upgradable. Access ownable upgradable. So now we're importing ERC 20 upgradable and ownable upgradable. So we also change what this contract inherits from saying ERC 20 to ERC 20 upgradable. And the same for ownable.
00:02:17.518 - 00:02:53.330, Speaker A: Ownable upgradable. Now, remember that having a constructor inside an upgradable proxy contract is dangerous code. So we'll have to remove this and then replace it with an initialization function. So to do that, the first thing that we'll do is import the initialization contract from Openzeppen contracts upgradable. And then this contract, my token, will also inherit initializable. Initializable. And then we'll create a function that's going to replace the constructor, we'll name it initialize.
00:02:53.330 - 00:03:46.114, Speaker A: If you need to pass in any parameters, then you pass it in here. For this example, we'll keep it simple and don't pass any parameters. This function will be external, and for safety reasons this function should only be able to call once. So we'll enforce that by putting a modifier called initializer which is imported from the contract initializable. Now notice for the constructor we were calling the constructor of ERC 20 and also the constructor of the ownable contract, but since we removed it, we need to manually call it. So inside the initialize function we need to manually call the initialization function for ERC 20 and ownable. But what function do we need to exactly call? So we're going to go look for the contract ERC 20 upgradable and ownable inside the node modules.
00:03:46.114 - 00:04:50.120, Speaker A: So open node modules, open zeppelin contracts upgradable token ERC 20 ERC 20 upgradable. And if you look over here, this is the function that we need to call which replaces the constructor for the ERC 20. Likewise, if we look for the ownable contract, then this is the function that we need to call to initialize the ownable upgradable contract back inside my my token actually, I'm going to change this mytoken contract to my token upgradable. So back inside the function initialize I'm going to call the initialization function for ERC 20 by typing two underscores. ERC 20 underscore init and then inside here we pass in the parameters like we would have passed in inside the constructor. The first parameter is the name of the token, so we'll say my token, and the second parameter is the symbol. I'll just say my.
00:04:50.120 - 00:05:29.970, Speaker A: We also need to initialize the ownable contract again, so we'll type two underscore ownable, one underscore init. The ownable contract doesn't take any parameters, so we'll just call it without passing any inputs. Now we have successfully converted a regular ERC 20 contract into upgradable ERC 20 contract. Let's make sure that this contract compiles. So I'm going to open my terminal. Then we'll compile the contract by typing MpX hardhat compile. However, we have customized our hard hat configuration a little bit, so we'll need to import some environment variables before we execute this command.
00:05:29.970 - 00:06:10.000, Speaker A: So we'll do that by typing embcat EmB. The first part of the command will load the environment variables, and the rest of the command will be to compile the contract. The compilation failed, and I wasn't expecting this. The reason it failed was because denialization of inheritance graph impossible, meaning that the order of inheritance is causing the error. First, validity inheritance must be from most baselike to most derived. Out of these three contracts, initializable is the most baselike. So we'll move this from the very right to the berry left.
00:06:10.000 - 00:06:31.860, Speaker A: Initializable is the most baselike contract, and then we'll inherit the rest of the contract. Open the terminal, clear the error message, and then we'll try compiling again, and the contract compiled successfully. So this is how you create an upgradable ERC 20 contract. Thanks for watching and see you later.
