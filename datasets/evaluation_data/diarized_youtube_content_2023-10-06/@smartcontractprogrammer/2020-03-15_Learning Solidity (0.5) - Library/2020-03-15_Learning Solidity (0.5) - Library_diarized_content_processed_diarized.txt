00:00:00.570 - 00:00:43.980, Speaker A: Libraries are like contracts, except there's no storage. So that means that you can't declare any state variables inside the library, and also you can't send any ether to a library. The benefits of using a library is that it helps you keep your code dry, which stands for don't repeat yourself. In other words, you'll be able to reuse the code from the library and remove duplicate code. One way this is achieved is because libraries allow you to add functionality to types. So for example, let's say that you have a variable of type Un. By using a library, the UN type can be enhanced to have extra functionalities so that you'll be able to do something like this.
00:00:43.980 - 00:01:41.798, Speaker A: Call the function from the library on the variable x. The other benefit of using a library is that it can save gas. And the way this is done is that you will first deploy the library. And if you have a contract that is going to use this library, then you will first link the contract to the library that is already deployed, and this is done during compilation of the contract, and then you would deploy the contract. If you have another contract that you want to deploy that also uses this library, then you would repeat the same process again, and by doing so, notice that you only deployed the library once instead of deploying it multiple times for each contract that uses the library. And that's how using a library can save gas. Now, if the library has only internal functions, then the library will be embedded into the contract that is using the library.
00:01:41.798 - 00:02:35.746, Speaker A: This means that when a contract is being compiled, all of the code inside the library will be put inside the contract. So I'm going to show you how to write and use a library using two examples, a library that prevents unint overflows and a library that will allow you to delete an element from an array without any gaps. What do I mean by this? Well, in solidity, when you delete the element from an array, it does not shrink the array. So this library will allow us to shrink an array when an element is deleted. To define a library, you first type library, and I'll name this library safemath. And for this example, we'll write a function that will prevent un overflow when two uns are added. So I'll name this function add, and it's going to take in two uns.
00:02:35.746 - 00:03:25.518, Speaker A: This function will be internal peer, and it's going to return the sum of the two inputs. We'll first add the two inputs and to check that there was no overflow. All we have to do is make sure that the sum is greater than the parts, and if it is, return the sum. And to use this safemath library inside this contract, you type using followed by the name of the library that you're going to use. So in this case it will be safemath and we want to extend the un type. So here we say for un. So what does this line of code exactly mean? Well, in general, using a for b means attach functions from library A to type B.
00:03:25.518 - 00:03:59.370, Speaker A: So this line of code means to attach functions from safemath to type un. And if you have a variable of type un, you'll be able to use the function inside the safemath library like this here. Notice that we're only passing one parameter to the add function. Although the function add takes in two parameters. This is because solidity is implicitly passing the first parameter. But if you want to explicitly pass the first parameter, you can do it like this. So these are the two ways of using a library.
00:03:59.370 - 00:04:43.922, Speaker A: And to use a library like the first way, you'll have to enhance the un type with this line of code using safemath for un. Next, let's write a function to actually test this add function. I'll name it test add. It's going to take in the two units to add and it's going to return the sum of the two inputs. So inside the function we'll return x add y. And to test that this line of code will fail if there is an overflow, we'll call this function by adding max un to some other number which would cause an overflow. And this line of code should fail.
00:04:43.922 - 00:05:40.374, Speaker A: Here I've deployed the test safemath contract and let's call the test add function and check that this function is working. So when I add one and two, I get three back and to call the overflow I'm going to add max un and one and call test add function. And as you can see here, the function failed. So that was an example of using safemath. Now, when you're actually writing a smart contract, you'll want to use open source library that's already been tested and used by many people. And personally I use the safemath library from open zeppelin contracts quite a lot. Next, I'm going to show you an example of a library that will allow us to remove an element from an array without any gaps.
00:05:40.374 - 00:06:18.078, Speaker A: Normally when you delete the element from an array, solidity will not remove the element. Instead, it will set the deleted element to its default value. So for an array of un, it will set the value to zero. Now the trick to actually remove the element is to take the last element in the array, copy it over to the place that is going to be deleted, and then remove the last element. So we'll do exactly that and name our function remove. It's going to take in our array of un. The array of un that we're going to be removing elements from will be a state variable.
00:06:18.078 - 00:06:50.362, Speaker A: So we'll declare it as storage and the second input will be the index of the element to remove. And for this example, we'll declare the function as public. This means that this library will have to be deployed and then linked for other contracts to use it. First, we'll copy over the last element of the array into the position that is going to be removed. Afterwards we remove the last element. Next, let's write a contract to actually use this library. First I'm going to declare array of un as state variable.
00:06:50.362 - 00:07:30.346, Speaker A: Next we'll add the functionality of this library to the Un array by writing using array for Un array. So now in this contract we'll be able to do something like this and call the remove function defined in the array library. Next, let's write a function to put some elements into the array and then remove some elements. So we'll run a for loop for three times and then put some numbers into the array. So after the for loop completes, you'll have an array of zero, one and two. And then we'll remove the element at index one. So here we're going to remove one.
00:07:30.346 - 00:08:07.154, Speaker A: When we remove the element at index one, it's going to copy the last element. So index one will now be two and then it's going to pop the last element. So after the function remove completes, we'll be left with zero and then two. And to check that that is the case, we'll assert that the length of the array is equal to two. First element in the array is still equal to zero and the second element is equal to two. When I call test array remove, you can see here that the transaction passed, which means that it passed our test over here. So that was a demo of how to use a library.
00:08:07.154 - 00:08:52.850, Speaker A: So in summary, using the A four B syntax, you'll be able to add functions of library A to type B. The code of the library will be embedded into the contract that is using the library. If all of the library functions are internal, and this will be done when you compile the contract. On the other hand, if some library functions are either public or external, then you'll have to deploy the library first and then link it with the contract that is using the library before deploying the contract. And by linking a contract to a library, you'll be able to save gas. But since this feature isn't available in remix, I wasn't able to show you a demo of this. Thanks for watching this video and have a good weekend.
