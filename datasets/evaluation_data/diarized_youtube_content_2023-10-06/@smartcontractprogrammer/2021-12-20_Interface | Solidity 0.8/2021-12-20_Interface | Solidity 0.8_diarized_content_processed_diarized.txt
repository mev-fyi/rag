00:00:00.410 - 00:00:40.070, Speaker A: Solidity allows you to call other contracts without having its code by using an interface. Here I have a contract called counter and another contract called call interface. Inside this contract I call the counter contract. Notice at the moment that we have the code over here, but actually we can call this counter contract without having the code inside the same file. Or you might not have access to the code, or maybe the code is thousands of lines and you can't be bothered to copy and paste the code. So how can you call another contract without having its code? Well, you would use interface. So to begin with, let's imagine that we don't have access to this code, the counter contract.
00:00:40.070 - 00:01:15.570, Speaker A: Let's imagine that we don't have code for the counter contract. So how do we call the contract counter? Well, you will use interface. Now, you don't have to do this, but usually interfaces start with a capital I followed by the name of the contract. Here we're going to be calling the counter contract curly braces. And inside here we define the functions that we want to call. For this example, we will call two functions, function count, which returns the count stored inside the counter contract. This will be external view, and it's going to return the uint.
00:01:15.570 - 00:01:58.900, Speaker A: And unlike a function declaration, we put a semicolon here. The other function that we're going to be calling is the increment function function ink external. And again, we don't put parentheses, we just put a semicolon saying that for this interface I counter. I want to be able to call the function count and also the function ink. And the next thing that we'll need to do is rename this counter contract to the interface icounter. For this example, we'll call two functions int to increment the count, and then we'll call count to get the actual count. So we'll say I counter at the counter call count.
00:01:58.900 - 00:02:34.154, Speaker A: This will return the current count. So we'll capture it in a state variable. So we'll declare a state variable un public count, and then say count is equal to the call from the count. I'll compile the contract. First we'll deploy the counter contract. Now in this example we do have access to this code, but imagine that we don't have access to this code. For example, this might be thousands of lines of code on the main net, and you don't want to copy and paste all of the code of the contract.
00:02:34.154 - 00:03:13.460, Speaker A: So anyways, let's say that the counter contract is already deployed on the main net, and now we'll deploy this contract and then call some examples. So I'll deploy call interface, open the contract, and then we'll call the examples, and then get the count. To call this function, we'll need to paste the address of the counter contract. I'll copy it from here, paste it here, and then call examples. So at this moment we called increment, and then store the count inside the state variable count. So you'll get the count by calling count, and it is equal to one. In summary, interfaces allow you to call other contracts without having its code.
