00:00:00.330 - 00:00:40.042, Speaker A: The last part of the clam contract is to implement fees. So in this video we'll complete the library tick. We'll start off by completing the function that will calculate the fee growth inside the function. Get fee growth inside will take in these parameters. It's going to take in a state variable, a mapping from int 24 to info struct. It's going to take tick lower, tick upper, the current tick and the state variables for fee growth global zero x one two eight and one x one to eight. And inside here we'll implement the code that will calculate the fee growth inside zero x one two eight and fee growth inside one x one to eight.
00:00:40.042 - 00:01:22.950, Speaker A: The first thing that we'll do is get the info for the lower tick and upper tick. So say info storage lower is equal to self. This self is coming from the input which will be a mapping from the tick to the info shut. Say self tick lower and we'll do something similar for the upper tick. Info storage upper is equal to tick upper. The next thing that we'll do is calculate the fee growth inside zero x one two eight and fee growth inside one x one two eight. Now inside here we're going to wrap our code inside uncheck.
00:01:22.950 - 00:02:20.790, Speaker A: Now this is because if you look inside the unison B three contract, so pay unison b three core contracts libraries tick sol, you can see that the solidity version is specified as less than 0.8. So this means that inside the unison b three tick library it allows overflow in underflows. And you can see here we have a function called get fee growth inside and this is the code that calculates fee growth inside. Recall from the videos about the equations that the fee growth inside can be both positive and negative. Since here we're dealing with un 256, this means that these numbers can overflow or underflow. However, here inside our code we're working with solidity 0.8. So that is why we need to specify that the numbers inside here, the fee growth inside that we will calculate can overflow and underflow.
00:02:20.790 - 00:03:47.094, Speaker A: We'll start off by calculating fee growth below say u int to 56, fee growth below zero X one two eight and we also initialize for fee growth below one X One two eight. Next we'll calculate them. Now recall from the video about the equations that fee growth below is different and it depends whether the current tick is above tick lower or whether it is below tick lower. Say if tick lower is greater than or equal to tick current, then we set this fee growth below zero X one two eight, fee growth below zero X one two eight to be the lower phi growth outside zero X one two eight, and we'll do the same for fee growth below one X One X one two eight. Else, we'll set fee growth below zero X one to eight to be equal to phi growth global zero X one to eight minus lower dot fee growth outside zero X one two eight and we'll do something similar for fee growth below one X one to eight. Okay, next we'll do something similar for fee growth above one X one to eight. So I'll change these to fee growth above zero X one two eight and one X one to eight.
00:03:47.094 - 00:05:45.820, Speaker A: The condition here will be if tick current is less than tick upper, then we set fee growth above to the upper info upper fee growth outside zero X one to eight and fee growth outside one X one to eight. Otherwise, fee growth above zero X one two eight and one X one to eight will be fee growth global zero X one to eight minus upper info this should be outside. Once we calculated fee growth below and fee growth above, we're now ready to calculate fee growth inside. So fee growth inside zero X one two eight is equal to fee growth global zero X one two eight minus fee growth below zero x one two eight minus fee growth above zero x one to eight and likewise, we'll do something similar for fee growth inside one X one to eight, change all the zeros to a one and that completes the function for get fee growth inside. Okay, so let's move on. What is the next thing that we need to do? The next thing that we need to do is inside the function update, we'll need to initialize tick below if the tick to initialize is less than or equal to the current tick. So here say if tick to initialize is less than or equal to the current tick tick current, then we'll need to set info fee growth outside zero x one two eight to be the current fee growth global zero x one two eight, fee growth global zero x one two eight and likewise for fee growth outside one x one to eight.
00:05:45.820 - 00:06:22.162, Speaker A: And that completes the function for update. Let's move on. So the last thing that we'll need to do inside this file is to wrap unchecked inside the function. Cross say unchecked. And why are we doing this? Well, again, going back to the unison B three tick contract. If you scroll all the way down, you can see here that it calculates fee growth outside zero x one two eight. And recall that fee growth global minus info fee growth outside can overflow or underflow.
00:06:22.162 - 00:06:46.506, Speaker A: And again, inside unison B three. The solidity version for this contract is less than 0.8, so by default these math operations can underflow and overflow. However, here we're using solidity 0.8, so we need to explicitly tell that inside here we allow on the flow and overflow. Okay, so that completes the contract for tick. Let's try compiling the contract.
00:06:46.506 - 00:07:02.490, Speaker A: So I my terminal, I'll type forge build, and our contract compiles. So we completed the contract for tick. In the next video, we'll do the same for the library position. Thanks for watching. See you in the next video. Bye.
