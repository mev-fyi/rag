00:00:00.490 - 00:00:45.740, Speaker A: When we or a smart contract calls another smart contract, what is the actual message that is being passed? For example, here I have a contract called receiver and what data is being passed when we call the function transfer to see the actual data that is being sent. When we call the function transfer, I'm going to create an event and then emit the event. And then we'll debug the transaction to see the actual data that was sent. So I'll create an event, I'll name it log, and we'll log the actual data that was sent. So it'll be bytes, I'll name it data. And then when we call the function transfer, we'll emit the event log, and the actual data that was sent to the smart contract will be store. Then message data, we'll compile the contract, deploy it, and then we'll call the function transfer.
00:00:45.740 - 00:01:29.414, Speaker A: The first input is an address and the second input is amount. For the address I'll just copy this account, paste it here, and for the amount I'll just put in eleven and then hit transfer. Open the transaction log, scroll down, and you can see here that this is the event that was emitted. The log event and message data is this long string over here. I'll copy this and then paste it here. For the rest of the video I'm going to explain how this data encodes the function to call and the parameters to pass to the function. The first four bytes encodes the function to call, and the rest of the data is the function parameters to pass to the function.
00:01:29.414 - 00:02:15.270, Speaker A: So this data that you see over here corresponds to the address that we passed. And the last data that you see over here corresponds to the amount that we passed to the function transfer. This data is encoded in hex, so if you decode it, it will turn out to be eleven, the number that we passed in for amount. I mentioned that the first four byte encodes the function to call. But how does the EDM know that this corresponds to this function over here from this function that we want to call? How do we compute this data? Well, you get this data by taking the string of the function signature, taking the hash, and then taking the first four byte of the hash. Let me show you this in code. So I'll create a contract called function selector.
00:02:15.270 - 00:02:41.770, Speaker A: By the way, this four bytes that you see over here is called a function selector. That is why I've named this contract functionselector. To compute this function selector, I'll create a function called get selector. And for the input we'll pass in a function signature. So this will be string call data. I'll name it underscore funk. We'll make this function external peer returns.
00:02:41.770 - 00:03:15.190, Speaker A: The function selector returns four bytes. So we'll return bytes four, and then we'll type return again. The function selector is the first four bytes of the hash of the function. So we'll say bytes four, catch 256. We will need to cast the string as bytes, so we'll type bytes funk. We'll deploy this contract. And for the funk, we'll pass in this function signature.
00:03:15.190 - 00:03:47.966, Speaker A: And we'll compare the function selector that was returned by calling the function getselector with what we see over here. They should be equal. So I'll compile the contract and then deploy it. Open the contract and the function signature that we need to pass over here. We're going to be calling transfer. So it'll be double quotes, transfer parentheses. The first input is an address without any space put in a comma.
00:03:47.966 - 00:04:23.086, Speaker A: The second input is a unit, but here we need to be explicit and say un 256. Close the parentheses and the double quotes, then call get selector. The Selector that we get back is a 9059 CBB. And the function selector that we got when we call the function transfer is also a 900:59 CBB. These two function selectors are equal. So this is how data is encoded. When you call a smart contract, the first four byte encodes the function to call.
00:04:23.086 - 00:04:35.540, Speaker A: How does it encode the function to call? Well, it takes the catch act 256 of the function signature and takes the first four bytes. The rest of the data encodes the parameters to pass to the function.
