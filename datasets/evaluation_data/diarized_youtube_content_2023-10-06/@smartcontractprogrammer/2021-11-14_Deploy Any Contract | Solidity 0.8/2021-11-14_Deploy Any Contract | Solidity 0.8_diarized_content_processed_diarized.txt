00:00:00.410 - 00:00:43.626, Speaker A: How do you write a contract that can deploy any arbitrary contract? Here I have two contracts, test contract one and test contract two. And I want to use another contract. Here I named it proxy. And when I call this function deploy, I want to be able to deploy both test contract one and test contract two and any other contract by simply passing in a bytecode from the input. Notice that for now we can only deploy test contract one. And if I wanted to deploy test contract two, then I would have to change this to test contract two. If I wanted to deploy a contract that is not defined inside here, for example, let's say foo, then I would have to change this to foo, recompile it, and then redeploy it.
00:00:43.626 - 00:01:27.830, Speaker A: I want to be able to deploy any contract by calling this function deploy and then passing in the contract to deploy inside the input. So in this video, I'll show you how to deploy any arbitrary contract and then execute it. Okay, so let's write a function that can deploy any arbitrary contract by simply calling the function deploy for the input it's going to take in the contract that we're going to be deploying. The function is payable so that we can send ether when we deploy the contract. And once the contract is deployed, we'll return the address of the contract. So we'll type returns address for this demonstration, we'll also emit an event called deployed when the contract is deployed. To deploy an arbitrary contract, we're going to need to use assembly.
00:01:27.830 - 00:01:58.500, Speaker A: Inside assembly, we need to call the function create passing in b, p, and n. What are these parameters? Let me explain. B is the amount of ether to send to the contract that we're going to be deploying. P is the pointer to memory, to the start of the code. We have a bunch of stuff loaded onto memory, and we need to tell solidity where the start of the code is and n is the size of the code. So inside here we'll call this function, filling out each of these parameters. So I'll type create.
00:01:58.500 - 00:02:27.446, Speaker A: For this example, we'll send all of the ether that was sent to this function deploy. So for the first argument, I want to put in message value. Now, inside assembly, this does not work. So what we need to do instead is to say call value. This is the amount of ether to send to the contract that we're going to be deploying. The next argument is the pointer. Where in memory does our code start? In memory, this code is loaded.
00:02:27.446 - 00:03:02.662, Speaker A: The first 32 bytes encodes the length of the code. So the actual code starts after 32 bytes. We'll tell solidity to skip the first 32 bytes from code by typing add code zero x 20 x 20 is equal to 32 in hexadecimal. The last parameter that we need to pass is the size of the code. The size of the code is stored in the first 32 bytes of code. So here we'll type m load code. After we call this function, this function will return an address.
00:03:02.662 - 00:03:48.162, Speaker A: So let's assign the output to a variable of type address. Now we're going to be returning the address, so I'll declare the address over here as AddR, and then assign it over here addr. Now, the syntax may look unfamiliar to you. What we're doing here is exactly the same as defining a variable of type address and then assigning it and then returning the address. Here we're just using the shortcut define it inside the return and we don't have to define it and we don't have to return it. Once we define the output of create to the variable AdDR, we'll check that the address that was returned is not equal to the zero address. Zero address means that there was an error creating the contract.
00:03:48.162 - 00:04:43.746, Speaker A: So we'll check that the contract was successfully deployed by typing require addr not equal to address zero. If it is equal to the zero address, then we'll say that the error message is deploy failed. And lastly, we'll emit the event deploy, logging the contract address that was deployed by typing emit deploy ADR. This completes the function that can deploy any arbitrary contract by simply passing in the bytecode of the contract as input. So now we are able to deploy both test contract and test contract two simply by compiling these contract, extracting the bytecode, and then passing in as input. For this example, I'll show you how to deploy test contract one and test contract two. When we deploy the test contract, one owner will be equal to the proxy contract.
00:04:43.746 - 00:05:12.362, Speaker A: And then from the proxy contract I'll show you a demonstration of how to call a function. So we're going to be calling set owner, and we'll set it to a new owner. To be able to call any function from the proxy contract, we'll need to add a function. I've added a function called execute. It's going to take in the target address of the contract to call and some data to send to the target contract. Now, when we call another contract, it might send some ether back. So I've declared a fallback which is payable.
00:05:12.362 - 00:05:46.726, Speaker A: Before I show you a demonstration of these two functions, deploy and execute. I'm going to write a helper contract that can return the bytecode of the contract that is being deployed and the data to send to set owner. This is how you get the bytecode of the first contract. Don't ask me why we need to cast test contract one as type. The important part is that we need to extract the creation code, which we do on this line. Now you don't have to write this contract and then deploy it in order to get the bytecode of the contract. I'm sure you can extract the bytecode by using other tools like web3 Js.
00:05:46.726 - 00:06:25.558, Speaker A: But to make our demonstration easy, I've declared a contract. Now remember that test contract too? It takes in some constructor inputs. So to get the bytecode of this contract, we need to write some extra code. First we get the creation code similar to how we got for test contract one. Once we get the bytecode, we need to append our inputs to the bytecode and we do that by typing Abi encode packed and then Abi encode the inputs. And lastly, here's the function that we're going to be calling to get the data to execute set owner on the first contract. Test contract one.
00:06:25.558 - 00:06:50.382, Speaker A: Okay, so let's see some demonstration. I'll compile the contracts. We'll deploy the helper contract and the proxy contract. Scroll down. Let's start by deploying test contract one and then calling the set owner from the proxy contract. We're going to need to call the function deploy, and then pass in the bytecode of test contract one. So we'll do that by calling the helper, get bytecode one.
00:06:50.382 - 00:07:36.334, Speaker A: So I'm going to open helper and then call get bytecode one. This is the bytecode double tell solidity to deploy test contract one. So we'll copy this, scroll down, open the proxy contract, and then call deploy. Once the contract is deployed from the logs, we'll extract the contract address. So I'll open the log and then you can see here that the event deploy was emitted and the contract address is over here. So I'll copy this, scroll back up, select test contract one, and onto remix. We'll load test contract one deployed at this address, paste the address, load the contract, scroll all the way down and then expand test contract one.
00:07:36.334 - 00:08:09.190, Speaker A: We deploy the contract from the proxy, so the owner should be equal to the proxy. This is the address of the owner of test contract one. And the address of the proxy is this d eight b 33 fa eight. The owner is d eight b 33 fa eight. Okay, so the owner is the proxy contract. Now let's now call set owner to set the owner of contract one to another address. Notice that set owner can only be called by the current owner, which is the proxy contract.
00:08:09.190 - 00:09:06.678, Speaker A: So if I try to call set owner from account one, and we'll try to set the owner to this account, call set owner and notice that the transaction fails. This is because account one is not the current owner of this contract. Test contract one so we need to call set owner from the proxy contract, and we do that by calling the function execute for the target we'll pass in address of test contract one, and we need to prepare the data and tell solidity to call set owner. So we'll get the data to call set owner by calling the helper function, get call data passing in the address of the new owner. We'll set the new owner to this address. So I'll copy this address, and then inside the helper contract we'll pass in the address, and then call get call data. We'll copy this, and this will tell solidity to call set owner, we'll call execute on the proxy contract we need to pass in the target.
00:09:06.678 - 00:09:30.590, Speaker A: This will be test contract one and we need to pass in the data. So I'll copy the address of test contract one, paste it here, and then pass in the data. Paste it as a second argument to execute, and then call execute. The transaction was successful. Let's check back. On test contract one we expect the owner to be different. Now click on owner and the owner has changed.
00:09:30.590 - 00:10:07.982, Speaker A: For the last example, we'll deploy test contract two. And notice that unlike the first example, this is a little bit more complicated. We're sending some ether and we're passing some inputs to the constructor. We'll be calling the function deploy again, and to get the code that we're going to be deploying, we're going to need to call the function, get bytecode to passing in the inputs that we're going to be passing to the constructor of test contract two. So inside the helper contract for the inputs, I'll pass one and two, and then call get bytecode. This is the bytecode of test contract two, which I will copy. And then we're going to call the deploy function again.
00:10:07.982 - 00:10:37.554, Speaker A: On the proxy contract for this example, I'll also send some ether. So I'll scroll back up and the amount of ether that we're going to be sending is one, two, three, and then hit deploy. Open the transaction logs and look for the address that was deployed. Copy the contract address, and then we'll load test contract two that was deployed at this address. So we'll select test contract two and then paste the address. Load the contract. Who is the owner of this contract? It is the proxy contract.
00:10:37.554 - 00:10:48.660, Speaker A: You can see that this address is equal to this address over here. How much ether did we send? We sent one to three ether. For the first input, we passed in one, and for the second input we passed in two.
