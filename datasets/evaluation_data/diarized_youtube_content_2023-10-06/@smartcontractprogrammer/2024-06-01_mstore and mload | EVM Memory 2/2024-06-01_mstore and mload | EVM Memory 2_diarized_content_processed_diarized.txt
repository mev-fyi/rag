00:00:00.280 - 00:00:35.336, Speaker A: To read and write from EBM memory in solidity, we will need to use the assembly, and the opcodes that we'll need to use are called MStore and M load. Mstore will take two inputs, p and b, and it will store 32 bytes to memory starting at memory location p. The value to be stored will be this second input b, and this value must be 32 bytes. To read data from EVM memory, we'll need to call the function mload and pass in the location to start reading from. From this memory location p, it will load 32 bytes. Let me give you an example. I've declared a function called test one.
00:00:35.336 - 00:01:06.900, Speaker A: We'll write data to memory by using mstore and then read data from memory by calling mload. The data that we read by calling mload will return it. So here I'll type returns bytes 32. I'll call this b 32 to call the function mstore and mload. These functions can only be called inside assembly. Let me first give you an example of m store and for this example, we'll store data into the free memory. And to store data into the free memory, we first need to get the free memory pointer, a pointer that points to the free memory.
00:01:06.900 - 00:01:46.858, Speaker A: So I'll say that p is equal to this free memory pointer is always stored starting from zero x 40 and from there 32 bytes. So say m load zero x 40. This would load 32 bytes store starting from memory location zero x 40. This will give us a pointer the location to free memory, a region in memory where we can start writing new data to to the free memory. Let's store zero x Abab. At this point we wrote the value zero x Abab at the memory location p, which is the location of the free memory. Now the free memory is initialized to the location zero x 80.
00:01:46.858 - 00:02:22.586, Speaker A: So at this point this p will have the value of zero x 80. For the next example, let's call the function mload to get the data that is stored at this free memory location. To get the data, we'll need to call mload and then pass in the memory location to start reading 32 bytes from. For this example, we'll pass in the location of the free memory, the free memory pointer. So here I'll pass in p, and then we'll assign the value that was ready into this variable b 32. B 32 equals two. Okay, let's try compiling the contract and then executing this function.
00:02:22.586 - 00:02:50.984, Speaker A: I'll hit control s to compile the contract, and then we'll deploy the contract. Hit deploy, and then call the function test one now to see what's happening inside the memory. We'll debug this transaction. So I'll click on this debug button, and then I'll create a breakpoint over here. So I'll click on this line. Once the breakpoint is created, I'll skip over to the breakpoint by hitting this jump to next breakpoint. I guess we were already at the breakpoint, so let's continue.
00:02:50.984 - 00:03:28.842, Speaker A: What I want to show you is as we execute this code inside here, I want to show you how the memory changes. So scrolling down, you can see here how the memory is used. Right now at the free memory pointer location that is zero x 40, it has the value zero x 80. In other words, the free memory pointer is initialized to zero x 80, which means that we can start writing new data starting from the memory location zero x 80. Okay, so let's continue executing this code over here. I'll click on step into several times. As I click on step into, you can see that the highlighted cursor moves.
00:03:28.842 - 00:04:05.188, Speaker A: Currently we're over here. So after the step at memory location p, which will be at zero x 80, we should have the value zero x abab ab. Okay, so let's keep on stepping into then. Scrolling down now, we can see that at memory location zero x 80, we have the value abab. This is because we said store the value zero x abab at the memory location zero x 80. And then in the next step, it loads the 32 bytes starting from zero x 80, which will store this value. And we can see this by going back to our contract.
00:04:05.188 - 00:04:50.674, Speaker A: When this function returns a value, the value that was returned is the value zero x abab. So in this example, we wrote the value zero x abab at memory location zero x 80. And then on the next line, we loaded the 32 bytes that is stored at memory location zero x 80, which is this value zero x abab. Now, when we call a function mstore and pass in the memory location to store the data, this memory location doesn't have to be a multiple of 32. And to show you this, I've created an assembly block. And inside here, let's say mstore at memory location zero. Let's store zero x eleven and then mstore at memory location one, that store zero x 22.
00:04:50.674 - 00:05:31.144, Speaker A: Mstore at memory location two, store the value zero x 23, and that's the mstore at memory location three, store the value zero x 44. Here, I wrote down the first 32 bytes of EBM memory. Memory location zero will be the first two hexadecimal numbers. So this will be over here, and then the first index will be over here, and the second index will be two hexadecimal after that. So it'll be over here, and the third index will be over here. When we do m store starting at memory location zero, we put in the value zero x eleven. This zero x eleven will be padded with 31 bytes of zero zero.
00:05:31.144 - 00:06:20.212, Speaker A: So what ends up getting stored starting at memory location zero is this value 31 bytes of zeros and then ending with one one after that. When m store one with the value zero x 22 as executed, it will write 32 bytes ending with zero x 22, starting from memory location one. Memory location one will start here, and this will be followed by 31 bytes of zero zeros. And then after 31 bytes of zero zeros, it will write 22. So notice that the value 1132 bytes was overwritten with the value zero zero. Let's see what happens when we execute m store two with the value zero x 33. The memory location two will be over here, and starting from here, we'll need to write 31 bytes of zero zeros and then followed by the value 33.
00:06:20.212 - 00:07:04.164, Speaker A: So what's going to happen is this 22 will be overwritten with zero zero, and then in the next one byte, this zero zero will have the value 33. Okay, let's go over the last example. Memory location three will be the fourth byte, and starting from here, we first need to write 31 bytes of zero zero. So this previous 33 will be overwritten with zero zero, and next to it we will have the value four four. Okay, to show you this, I'm gonna compile a contract again, and then we'll delete the previous one and then deploy a new one. And then call the function test two. And to see what's going on inside the memory, we'll debug this transaction.
00:07:04.164 - 00:07:33.758, Speaker A: I'll create a breakpoint over here, and then we'll click on step into. Also scroll down to see what's going on inside the memory. I'll click step into several more times until memory location zero will have this value. Okay, this command finished executing and starting from memory location zero zero. Notice that we have 31 bytes of zero zeros and ending with one one. Next, let's see what happens when this code finishes execution. Keep on clicking.
00:07:33.758 - 00:08:09.274, Speaker A: Step into okay, and now notice that the one one that was at the end of the first 32 bytes is now overwritten with zero zero. And at the beginning of the next 32 bytes, it starts with two two. Okay, let's keep moving on. After this code is done executing the 22 that was over here is now overwritten with zero zero, and next to it we have the value 33. Then after the last execution, we had the value 33 overwritten with zero zero, and we have the value four four next to it. So those were some examples of mstore and m load.
