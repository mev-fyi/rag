00:00:00.440 - 00:00:29.750, Speaker A: What is a transient storage? How do you use it and what are the benefits of using it? Let's start with a review of storage and memory. When data is stored as a state variable, it is stored in a storage. Data is stored on the blockchain. Your data will persist as long as the blockchain does. Data stored in memory is cleared out after each function call. Transient storage is something in between storage and memory. Data stored in a transient storage is cleared out only after a transaction.
00:00:29.750 - 00:00:54.330, Speaker A: To see the difference between storage, memory and transient storage, let's start with an example here. I have a simple contract. When this function test is called, it's going to set the state variable val to 123. So this 123 will be stored on the blockchain. Once this 123 is stored. Next, it's going to call the fallback function on message sender. To test this code, I'm going to create another contract.
00:00:54.330 - 00:01:49.614, Speaker A: I'll declare interface to call this contract from another contract, and then the contract that's going to call into this contract test storage. So what's going to happen is we're going to call the function test and then for the address of the target, we'll pass in the address of this test storage contract. And going back, it's going to call the function test, which we'll call this function. When this function is executed, it's going to set the state variable bell to 123 and then call the fallback function. The fallback function of message sender will be executed here and inside this fallback, we're going to get the value of val stored inside this test storage contract. This will be 123, and to test this, we will compile the contract by hitting control square and then deploy the contracts. So first I'll deploy the test storage contract.
00:01:49.614 - 00:02:22.661, Speaker A: And then next I'll deploy the callback contract. This is a contract that's going to test the test storage contract. I'll copy the address of test storage and then open callback contract and then call the function test. Okay? And the transaction went through. So what we just did was we call the function test on the callback contract inside it. It called the function test on test storage. Test storage, set the state variable val to one through three and then call the fallback function on the callback.
00:02:22.661 - 00:02:57.424, Speaker A: Inside the fallback of callback, it got the state variable bal stored inside test storage. And then it also stored that inside its state variable. If you call bell, it stores one, two, three, because inside test storage, it also stores one to three. So that's storage. Next, let's take a look at transient storage. Transient storage will allow us to store some data during a transaction. So to see this, first I'm going to copy this code and we'll translate this contract using transient storage.
00:02:57.424 - 00:03:39.422, Speaker A: So I'll paste the same contract and then call this test transient storage storage. To store data into transient storage, we need to specify a slot where we're going to store it. For this example, I'll use the zero slot in transient storage. So I'll declare a constant called slot and then set it equal to zero. Next, we're not going to need this state variable bell. Since we're not going to storing any data inside a state variable, we're going to be storing this data inside a transient storage. And to do that, type assembly and to store data into transient storage, we'll say t store the slot, the slot that we specified over here.
00:03:39.422 - 00:04:21.622, Speaker A: And let's say instead of storing 123, we'll store three, two, one, and then I'll remove the state variable. So when we call the function test, it's going to store 321 inside transient storage at slot zero. And then it's again gonna call the fallback function message sender inside message sender. So you'll call the transient storage from the callback contract. So it's going to execute the fallback and it's going to try to get the bell by calling the function bell. So since we no longer have the state variable, we'll need to implement a function called bell. Say function bell, you'll make this public view returns uint.
00:04:21.622 - 00:05:00.644, Speaker A: Let's call this b. When the fallback is executed and it calls into this function bell, the data 321 will be stored inside transient storage. To get this data, we'll use assembly again and we'll have to call the function tload and then specify the slot where our data is stored. This will be in slot and then we'll assign the data that was loaded into our variable v. So what we just did here was we created a contract similar to our first example. And instead of using the state variable, we're using a transient storage. And the main reason why you might want to use transient storage is because it will save guess.
00:05:00.644 - 00:05:30.354, Speaker A: Next, I'm going to run the demo. But before I do that, remember that I said that transient storage stores data only during a transaction. So when we submit a transaction, the transaction will be executed and afterwards this data that is stored in transient storage will be cleared out. So this is in contrast with state variables. After a transaction is executed, state variables will persist. However, with transient storage, it will be cleared out. And to show you this, first I'm going to compile the contract.
00:05:30.354 - 00:06:34.214, Speaker A: And to do this, make sure to click on EBM version Cancun inside remix click on advanced configuration. Under EBM version make sure that you select the Cancun. And the other thing that you'll need to do is under deployment make sure that you click on remix vm Cancun let's try a demo for test transient storage. I'll hit control s to compile the contract and then I'll clear out all of the contracts and then we'll deploy the callback contract again and the test transient storage contract deploy it and then we'll call this function test on the callback contract. And what it's going to do again is it's going to call the function test on our test transient contract on our test transient storage contract. And inside here it's going to set the transient storage at slot zero to 321 and then it's going to execute the fallback function inside the callback. Inside the fallback it's going to try to get the value called Bell.
00:06:34.214 - 00:07:24.580, Speaker A: This will execute the code over here which will load the data that is stored in the transient storage we've stored 321. So this should return 321 and inside the state variable of callback it was stored 321. Okay, so let's call this test function, I'll copy the address of the transient storage contract and then paste it here, call the function test, the transaction went through and let's now get the result that was stored. If you call bell, we get back 321 and now here's the surprising part. Let's open test transient storage and then call the function bell and it returns zero. Notice that when the function test was called, it stored 321. But this 321 was cleared out when the transaction finished executing.
00:07:24.580 - 00:08:02.950, Speaker A: So that is why you see a zero over here. This is in contrast with our state variable example. So if I deploy this test storage again and then I call the callback and then go back to our test storage example. When the function test is called, it sets the state variable bell to one to three, so that when we call the function bell it still is one to three. So that's the difference. In transient storage, the data that was stored is cleared out after the transaction. However, when we store our data into our state variable, the data persists after the transaction.
00:08:02.950 - 00:08:38.826, Speaker A: So what's a use case of transient storage? One simple example is to rewrite the reentrancy guard. So here I have a reentrancy guard and the lock uses state variable. We can actually use transient storage to make the gas cheaper on the modifier lock. So to do this, I'll first copy this code, then paste it here. I'll call this reentrancy guard transient. And like the example above, we'll first specify the slot that we're going to store our data for the transient storage. And again, I'll use the zero slot and then paste it here.
00:08:38.826 - 00:09:25.528, Speaker A: We won't need a state variable, so I'll remove this and inside the modifier. First we'll rewrite this logic that require not logged to do this in assembly. I'll type assembly and to get the value stored in the transient storage at slot zero, you'll call t load at the slot and to check whether there is any data in here, you'll say if t load slot, then we'll revert. So here we're saying if there's any data inside slot zero of transient storage, then simply revert. This code is the same as this one, so we'll remove it. Okay, the next part is to set the lock equal to true, and we do that by typing t store at the slot. And we'll just simply store our one.
00:09:25.528 - 00:10:04.414, Speaker A: Okay, that completes this part of the code, execute the code inside the function, and afterwards we'll clear out this lock. And to do this, we'll say assembly t store at the slot store zero. Okay, so this assembly code is equal equivalent to this part of the code. And we completed our code of modifying the reentrancy guard example using state variable to one that is using transient storage. Okay, let's actually execute these two contracts and see how much gas the transient storage saves. So I'll hit Ctrl s to compile the contracts again. Then I'll also remove all of the contracts that I had from before.
00:10:04.414 - 00:10:31.188, Speaker A: Then we'll deploy reentrancyguard and reentrancyguard transient. Okay, deploy both contracts. Okay, first let's call the function test on the reentrancy guard. Again, this is using a state variable to lock the contract. Okay, let's call the function test. So, call the function test and then open the transaction logs. And I'll look for the amount of gas that was used.
00:10:31.188 - 00:11:01.014, Speaker A: So that's the amount of gas that was used. Copy this and then I'll paste it here. 35,313 gas. Let's next call the same function inside our reentry guard transient contract. Call the function test, and then get the gas cost. And the gas cost this time is 21,887 gas using state variables. The reentrancy guard used 35,332.
00:11:01.014 - 00:11:26.024, Speaker A: Replacing this lock with a transient storage, it only used 21,887 gas. So that was an example of transient storage. The difference between storage and transient storage is that after a transaction is completed, the data that was stored in transient storage is cleared out, whereas in storage it will persist. And the main use of transient storage is to save guests.
