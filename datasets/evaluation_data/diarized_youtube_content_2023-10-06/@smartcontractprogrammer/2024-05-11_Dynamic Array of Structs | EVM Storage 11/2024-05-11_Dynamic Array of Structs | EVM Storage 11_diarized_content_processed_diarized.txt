00:00:00.280 - 00:00:52.920, Speaker A: How is the data stored inside EVM storage dots when we have a dynamic array of structs? For example, here I have a struct called point inside it. It has three Un 256 x, Un 128 y, and Un 128 z. And I also have a dynamic array of structs, a dynamic array of points named arc. In this video I'll explain how the data is stored inside the EVM storage slot when we have a dynamic array of structs. Remember that in one of the previous videos I mentioned that if you have a dynamic array and each element takes up exactly one slot, so this will be 32 bytes, you can think about it as a dynamic array of unit 256. Then the way we calculate where the slot of an element is is by this equation. Take the catch act 256 of the slot where the array is declared plus the index of the element.
00:00:52.920 - 00:01:16.788, Speaker A: For a dynamic array, we'll need to do something similar. The difference is we'll need to consider the size of each struct. Here's our starting point. Ketchup 256 of the slot where the array is declared. In this example, this is declared in slot zero. So we'll replace this with zero, and then for each element we multiply by the amount of slots the struct will use. So let's count.
00:01:16.788 - 00:01:49.722, Speaker A: Uint 256 will take up one slot. Next we have two uint 128. The first one will take up 16 bytes or half of the slot. One slot uses 32 bytes and then the next one will use up the other half of 16 bytes. So these two fields will be stored in slot two. This will be stored in the first slot and this will be stored in the second slot. So to get the slot of the element in this example, the slot of the element will be equal to the ketchup 256 of zero times the size of the element.
00:01:49.722 - 00:02:15.102, Speaker A: Each element is a point, so it will take up two slots. Size of element times the index of the element. Okay, let me give you some examples. First, I'll put some data into this dynamic array. I'll push three elements. Next, let's write a function to get the data that is stored in this dynamic array. I'll name this test structure r for the input.
00:02:15.102 - 00:02:55.708, Speaker A: It will take in a single input the index of the array to get un 256 I for this example, we will return four outputs, the data that is stored in each struct. So this will be xyz and the length of this dynamic array. So we have un 256 x un 128 y u n 128 z and the length of the array u n 256 length so we'll apply this equation. So I'll copy this equation and then paste it here. Let's start with this part. Byte 32, I'll name it. Start is equal to check 256 of abi dot encode.
00:02:55.708 - 00:03:25.036, Speaker A: You need to encode unt 256 of zero. Zero is a slot where this dynamic array is declared. Next we'll use assembly to read the data assembly. Let's start with the length of this dynamic array length. Recall that the length of the dynamic array is stored in the slot where this dynamic array is declared. In this example, the dynamic array is declared in slot zero. So the length will be stored in slot zero s load zero.
00:03:25.036 - 00:03:59.328, Speaker A: Okay, next let's get the values x, y and z. So we have the fields x, y and z inside the struct point. The first slot will be occupied by x since it is unit 256. The next slots will be occupied by the field y and z. Since they are both uint one to eight. The way they will be stored will be y starting from the right and going left and then to the left of this you'll have the value z stored. So this is how the data is stored inside slots.
00:03:59.328 - 00:04:20.352, Speaker A: For each element, these two data take up two slots. To access the value for x. Let's say x is equal to. We will need to apply this equation. First I'll type slope, then add to start. This start will be the ketchup to 56 of zero. We will need to add the size of element multiplied by the index of the element.
00:04:20.352 - 00:04:51.888, Speaker A: So mole size of the element is two. Each structure will take up two slots to store x, y and z. Then we need to multiply this by the index of the array element that we want to access. This will be adding and this is how you will get the value x. The next slot will store z and y. So let's call this let z and y equal to s load add start. Then instead of doing multiply two by I to this value we need to add one.
00:04:51.888 - 00:05:15.992, Speaker A: So first I'll copy this, paste it here. And to this we need to add one. Add one. Okay, so this will load 32 bytes that represents the value z and y. 16 bytes will be y and the other 16 bytes will be the value z. Inside assembly this zy is 32 bytes. And to get the value y we need to get the right side of the 16 bytes.
00:05:15.992 - 00:06:03.752, Speaker A: And to do this all we have to do is assign the value dynamic. And this works because when this dy 32 bytes is casted into u into 128, the left side of the 16 bytes will be cut off, and we're left with the right side of the 16 bytes. Okay, and to get the value z, since z is on the left side, we will need to shift zy by 16 bytes to the right. 16 bytes is 128, so shift right one to eight. Okay, let's try compiling this contract, and then call the function test struct. Ok, ctrl s contract compiles. Let's now deploy this deploy, and then let's try getting the 0th element, and we get that.
00:06:03.752 - 00:06:21.564, Speaker A: X is eleven, y is 22, z is 33, which you can see over here. And the length of the array is three. Let's try getting the other two elements. The first index, 44, 55, 66, and the last element, 77, 88, 99.
