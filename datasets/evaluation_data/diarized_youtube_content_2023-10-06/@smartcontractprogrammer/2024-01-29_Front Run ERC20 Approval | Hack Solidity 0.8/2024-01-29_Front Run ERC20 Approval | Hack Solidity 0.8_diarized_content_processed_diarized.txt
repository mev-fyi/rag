00:00:00.410 - 00:00:35.058, Speaker A: Many ERC 20 tokens will have two function called safe increased allowance and safe decrease allowance. Here, we're looking at the code inside open zeppelin contracts. These two functions are added to prevent frontrunning ERC 20 approvals. But how does it work? In this video, I'm going to explain how to frontrun ERC 20 approvals and also going to explain how these two functions fix that problem. Imagine this scenario. Let's say that an owner approves a spender to spend 1000 tokens. What the owner went to do was approve the spender to spend 100 tokens.
00:00:35.058 - 00:01:04.106, Speaker A: Here, the owner accidentally approved 1000 tokens. He added an extra zero. To fix this, the owner updates the approval to 100, removing that extra zero. In between these two actions, the spender can front run the approvals to spend more than what the owner wanted the spender to spend. So let's see how this attack will play out. The first step, the owner accidentally approves 1000 token for the spender to spend. Next, the spender will front run the owner's approval.
00:01:04.106 - 00:01:29.446, Speaker A: The owner wanted to update the approval to 100. The spender is going to front run this transaction over here. In step one, the owner approved this spender to spend 1000 token. So by front running the owner's transaction to update the approval, the spender will be able to spend 1000 token. So this is step two. The previous step two becomes step three. The spender is front running this transaction.
00:01:29.446 - 00:02:01.854, Speaker A: The owner wanted the spender to spend up to 100 tokens. However, because the owner accidentally approved 1000, the spender was able to spend 1000 tokens. But it doesn't stop here. Once the owner's transaction to update the approval to 100 is processed. Now the spender can spend the extra 100 tokens. So in total, the spender was able to spend 1000 plus 100 which is equal to 1100. How about the owner? The owner actually wanted this spender to only spend 100 tokens.
00:02:01.854 - 00:02:26.058, Speaker A: So this is how erc 20 approval is front run. Let's actually write this in code. First thing that I do is import the token. This is a standard ERC 20 contract with Mint and burn. So going back to the test function, we'll define the owner and the spender. And then inside the setup function, we will deploy the token contract and let's Mint 2000 token to the owner. Next, we'll write the test.
00:02:26.058 - 00:02:52.462, Speaker A: As mentioned earlier, what we're going to do is have the owner approve 1000 token. The spender is going to front run the next transaction and spend 1000 tokens. The owner's transaction to update the approval is processed. So this will update the approval to 100. And then finally, the spender is going to spend the 100 token. First, we'll simulate the owner approval and then calling token approve Spender for 1000 token. Next, we'll simulate the transaction for Spender.
00:02:52.462 - 00:03:22.374, Speaker A: The spender is going to transfer the token from the owner to the spender for 1000 tokens. Next, we'll simulate the owner's transaction to update the approval. This will update the approval for the spender to 100 tokens. Now, notice that at this step, the spender has already spent 1000 tokens. And here what's going on is the spender is allowed to use additional 100 tokens. This is where the front running is happening. The spender is front running this transaction.
00:03:22.374 - 00:03:59.842, Speaker A: And lastly, once the spender gets an additional 100 tokens to spend, he would transfer that from the owner to the spender. Let's console log the balance of the spender after this front running for the setup, I forgot to declare the token state variable. So say token private token. Okay, let's try compiling this contract inside my terminal. I'll type forge build. Okay, the contract compiled. Let's try running the test forged test BBB and the test passed and noticed that the spender balance after the tag is 1100.
00:03:59.842 - 00:04:48.806, Speaker A: The owner wanted this spender to only spend 100 token. However, by front running the approval, the spender was able to spend 1100 token an additional 1000 tokens. Now in the real world, I don't know any attacks that actually executed this attack. How does safe decrease allowance such as implemented in the open zeppelin contract solve this problem of front running the allowance? The way it solves this problem is by first getting the state of the current allowance and then from there it updates the allowance. For example, here we get the current allowance. If the amount of approval to decrease is greater than the current allowance, then this function will rebirth. Otherwise, it will update the current allowance to be the current allowance minus the amount that was requested to decrease.
00:04:48.806 - 00:05:12.126, Speaker A: Let's run through an example of our case. So the owner will first approve 1000. Next, the spender spent this 1000. Spent 1000. So the current allowance is now equal to zero. Next, the owner's approval transaction to update it to 100 is processed. So say owner approve 100.
00:05:12.126 - 00:05:47.890, Speaker A: Let's examine what happened to this code. When this transaction is executed, the current allowance is zero. The owner is requesting to decrease the current allowance by 100. But what happened is current allowance. Current allowance is zero and the requested amount to decrease is 100. Since current allowance is less than requested decrease, this function will rebirth and by doing so this makes sure that the spender is only allowed to spend 1000 and they won't be able to spend the extra 100 token that the owner tried to approve.
