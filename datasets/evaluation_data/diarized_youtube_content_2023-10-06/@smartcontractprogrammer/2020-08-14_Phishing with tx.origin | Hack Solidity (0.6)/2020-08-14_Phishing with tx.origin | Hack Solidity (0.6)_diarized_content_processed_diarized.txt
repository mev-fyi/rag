00:00:00.890 - 00:00:46.650, Speaker A: Phishing is a cyberattack by which an attacker disguises as a trustworthy entity and deceives a user into doing something they would not want to do otherwise. For example, an attacker can scam a user into sending all of his ether to the attacker's address. So in this video, I'm going to explain how TX origin is vulnerable to phishing. First of all, what is TX Origin? Let's say that Alice calls contract A, and contract a calls contract B. Inside contract B, message sender will be equal to contract A. However, Tx Origin will be equal to Alice. In other words, Tx Origin is the address where the transaction was originated.
00:00:46.650 - 00:01:54.370, Speaker A: In this case, Alice created the transaction, so TX Origin will be equal to Alice. Let's now look at a contract that uses tx origin. Here we have a contract called wallet, and it is a simple smart contract where anyone can deposit ether into this contract, but only the owner will be able to spend ether from this contract by calling the function transfer. Now let's take a look at how this function checks that the caller is equal to owner, and the line where it checks that the caller is owner is here on line 27, and it checks that tx Origin is equal to the owner state variable. And this owner state variable is set to message sender during construction. Now let's say that Alice deploys this contract, so the owner state variable will be equal to Alice, and she'll be able to withdraw ether from this contract by calling the function transfer. When she does call this function, it will first check that tx Origin is equal to Alice.
00:01:54.370 - 00:02:55.410, Speaker A: Now recall that tx Origin points to the address that created this transaction. In this case, since Alice called this function, tx origin will be equal to Alice, so this check will pass and she'll be able to send ether. But what happens if EB calls this function? Well, when she does, tx Origin will be equal to EB, and the owner will be equal to Alice. So this check will fail, and EB won't be able to withdraw ether from this contract. Now recall that tx Origin points to the original address that created the transaction. So if EB can trick Alice into calling this function, then tx origin here will be equal to Alice, the owner will be equal to Alice, and E will be able to trick Alice into withdrawing ether from this contract. Let me explain what I mean by using a diagram.
00:02:55.410 - 00:03:45.490, Speaker A: So if Alice calls the transfer function inside this wallet contract, then tx origin will be equal to Alice. However, if EB can trick Alice into calling her malicious contract, which would then call wallet transfer, then TX origin will still be equal to Alice. And by doing this, Eve will be able to withdraw ethers from Alice's wallet. So that's the idea of how to do a phishing attack on a contract that uses TX origin. So let's now put this phishing attack into code. Our attack contract will store two state variables. The owner of this contract will be the address that will be receiving the ether from this transfer function, and the wallet state variable will be our target.
00:03:45.490 - 00:04:38.150, Speaker A: We initialize these two state variables using a constructor. Now, how are we going to exploit the wallet contract? Well, the only thing that we'll have to do is somehow trick Alice into calling this function. And when Alice calls this function, we'll call the transfer function and then withdraw all of the ether from it. We'll be able to withdraw ether from the wallet by calling wallet transfer. And who are we sending the ether to? We're sending it to the owner of this attack contract. How much ether does EB want to steal from the wallet contract? Well, she'll want to steal all of the ether. So here we'll say all of the balance from the wallet contract.
00:04:38.150 - 00:06:03.060, Speaker A: And that's all we have to do here in order for eve to steal ether from the wallet contract above, let's walk through how this attack works. EB will somehow trick Alice into calling this function, and this will call the transfer function on the wallet contract. The wallet contract checks that the tx origin is equal to Alice, and this check will pass since Alice called this function and all of the ether stored in this contract will be sent to EB. Here, I've deployed the two contracts, wallet and attack. Let's say that Alice is going to deposit one ether into her wallet, and we can check that this wallet has one ether by calling get balance. Now, if e tries to call the transfer function and transfer all of the ether to her from Alice's wallet, you can see here that the transaction will fail. But now let's say that eb tricks Alice into calling the attack function.
00:06:03.060 - 00:07:01.790, Speaker A: You can see here that the transaction was successful. So let's check back on the balance of the wallet, and the balance is zero. So Eve was able to deceive Alice into sending all of her ether in this wallet to Eve's address. So how can you prevent this type of phishing attack? Well, we can prevent this attack by simply changing TX origin to message sender. Now, why would this prevent a phishing attack? Well, this is because message sender always points to the contract or the account that called this contract. So in the case where Alice called Eve's malicious contract which calls wallet transfer message sender here will be equal to eave's contract. So the check over here will fail.
00:07:01.790 - 00:07:20.210, Speaker A: Alright, so that was a video about phishing with TX origin and the lesson to be learned here is that if you're going to use TX origin, then you should keep in mind that your contract might be vulnerable to phishing attack. Thanks for watching and have a nice weekend.
