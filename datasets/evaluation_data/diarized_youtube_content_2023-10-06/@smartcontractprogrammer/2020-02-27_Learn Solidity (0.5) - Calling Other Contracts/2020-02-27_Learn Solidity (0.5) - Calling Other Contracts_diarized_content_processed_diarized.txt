00:00:00.650 - 00:00:45.606, Speaker A: I showed you how to call functions in another contract using the call method, but it's not the best way to call other functions. So I want to show you a better way of calling functions that are in another contract. So I'll show you how to call functions in another contract and how to send ether to a payable function. First we're going to need a contract that's going to get called. So I'm going to name this contract call e and we'll declare some state variables. For this example, the state variable value will be used when we send ether to this contract. And to show you an example of how to call a regular function from another contract, we're first going to declare a function called set x that's going to take a unit as input.
00:00:45.606 - 00:01:35.094, Speaker A: We'll declare the function as public and to show you how to assign the output of this function in the contract that call this function here, we're going to return a new int inside the function. We'll simply reassign the state variable x to the input and then return the value of the state variable x as output. Next, to show you an example of how to call a payable function, which means that the function can receive ether, we're going to first create a function like the function above. Setx and send ether function is going to take a un as input. And since this function is going to be able to receive ether, we need to declare as payable. And for this example we'll return multiple outputs. And later I'll show you how to assign variables from multiple outputs.
00:01:35.094 - 00:02:23.798, Speaker A: And same as the function above, we'll assign the state variable x to the input. And since we're going to send ether to this function, we'll capture the value of the ether in the state variable value and then return the value of the state variable x and value. So that completes the code for the contract that's going to get called. Next, we need a contract that's going to call the callee contract above and we'll name this contract caller. We'll name this function as setx. Later, after we deploy the contracts, we'll call this function from our account, and this function will call the set x function inside the colleague contract above. To call the functions in the colleague contract, we first need to pass the call econtract as input.
00:02:23.798 - 00:03:15.834, Speaker A: Now, when we actually call this function, what we need to pass here as input is the address of the collect. In here we're saying that the type for the first input is the Kali contract and the variable name for this input is Kali. And next we'll pass in a unit as the second input. So how do we call the setx function which is inside the Kali contract? Well, it's pretty straightforward. And you can call the set x function, which is inside the call e function like this, and we'll pass the input x. Now, if this syntax of passing the contract as input seems confusing, you can do it like this instead. Instead of passing the contract as input, you can pass the address of the contract as input, and you can instantiate the contract at the address like this.
00:03:15.834 - 00:03:54.226, Speaker A: Here we're instantiating the contract at the address where we got the address of the contract. From the input, we'll declare the variable name as call e, and the type of the variable is the call e contract. So that's how you instantiate a contract from an address. And you can call functions on the contract in the exact same way as the example above. So these are the two ways of calling a function in another contract. So next I want to show you how to call a payable function and send ether with it. I'll call this function setx and send ether.
00:03:54.226 - 00:04:31.298, Speaker A: And like the example above, it's going to take the call econtract as the first input, and we'll pass a uint for the second input. And since we're going to send ether to this function, we'll declare it as payable. So we already know how to call a function in another contract. So I'm going to copy this example as our starting point. And instead of calling the set x function in the Kali contract, we're going to call the set x and send ether function. And we'll pass the input x. And to send ether to this function, you can do it like this.
00:04:31.298 - 00:05:11.534, Speaker A: You write dot value after the function that you want to call. Here I want to forward all of the ether that was sent to this function. So inside the parentheses that come after the value method, I'm going to pass message value, which means that we're going to forward all of the ether that was sent to this function. And since the setx and send ether function inside the call e contract returns two outputs. Here we need to update our code to assign variables for two outputs. Since the function is going to return two outputs, we first need to start with parentheses. The first output is a un.
00:05:11.534 - 00:05:34.694, Speaker A: So we'll declare a variable of type un. The second output is also a un. So we'll declare the second variable as un as well. So that completes our code. Let's now deploy the contracts. So here I've deployed the collie and the caller contract. And for the first example I'm going to call the function set x, which is here.
00:05:34.694 - 00:06:17.222, Speaker A: When we call this function, it should call the set x function inside the call e contract and inside the colleague contract. It's going to call this function and set the state variable X, which we'll check later. So I'm going to copy the address of the call e contract and then pass it as the first input. And then for the second input I'll pass in the number one, two, three. And to check that everything went through, we'll check the value of the state variable x and inside the call E contract. And it's one, two, three. Next, I'm going to show you a demonstration of set x and send ether function here.
00:06:17.222 - 00:07:36.320, Speaker A: So when we call this function inside the caller contract, it's going to call the same function inside the call e contract. And inside the call e contract it's going to set the state variable x and the amount of ether that was sent. Again, I'm going to copy the address of the call e contract, paste it in here, and this time we'll pass the input four, five, six, and we'll send 1 meter. So now when we check back on the state variable X, it is now four, five, six, and the value that was sent should be one ether. So I just showed you how to call functions in another contract and this is the better way of doing it compared to using the call method. Why is that so? Well, recall that using the call method you would do something like this to call the function set x and send ether, you would pass in the function signature of the function that you're going to call, followed by the input. And if this function does not exist, then the call method would call the fallback function.
00:07:36.320 - 00:08:24.298, Speaker A: Now the advantage of calling a function like this is that if the function does not exist, then solidity will not compile. So for example, if I change the name of the function and then hit ctrl s to compile, you'll notice that it did not compile. So by using this method of calling functions in another contract, you can check for errors before the contract is even deployed. And before we go, I want to warn you about something that you should be aware of. What do you think will happen when we call the function set x and pass in the address of a contract that is not the call e contract. For example, instead of passing the address of the call d contract, we pass the address of this contract. Foo.
00:08:24.298 - 00:09:26.674, Speaker A: Well, surprisingly, the code inside here will call this function when we pass in the address of foo as input, instead of executing the code inside here inside the Kali contract. Let me show you an example. So here I deployed the caller and the foo contracts, and when we call the set x function passing in the address of the foo contract, you'll notice that the code inside the foo contract was executed. So I passed in one, two, three as input the code inside the contract foo was executed, and it incremented one, two, three by one. And we got one, two, four here. So when we call this function and passed in the address of Foo, instead of executing this code here, it executed the code here inside the foo contract. So keep in mind that the contract that you think you're calling might not be the actual contract that is being called.
00:09:26.674 - 00:10:09.580, Speaker A: So in summary, you can call functions in another contract similar to how you call functions in object oriented programming. And this is better than using the call function to call functions in another contract, since if the function does not exist, then solidity will not compile, whereas using the call method it would just call the fallback function, and you won't be able to catch your error until you deploy the contract and actually execute the functions. And keep in mind that the contract that you think the calling might not be the actual contract that is being called. If you have any feedback or questions, let me know in the comments below. Have a good night.
