00:00:00.330 - 00:00:32.040, Speaker A: Let's build an app. We're going to be building a todo list. This isn't something that you should be writing as smart contract, but we'll write it anyways to get some practice inserting, updating, and reading from an array of structs. First we'll define a struct of to do. So I'll type struct to do curly braces, and inside the struct we'll store two fields a string of text. It this will be the description of the to do. Remember the status of the to do whether it is completed or not.
00:00:32.040 - 00:00:59.418, Speaker A: Boolean completed. Next, we'll store the struct in array. So I'll type to do array. It'll be public and then I'll name this to Dos. We'll write three functions. Create to insert a new to do update text to update the text of the to do and the function get to get the data stored inside a to do. Let's start with create to create a new to do, we'll provide a text as input.
00:00:59.418 - 00:01:43.630, Speaker A: So I'll say string. We can declare this as either memory or call data, but here I'll use call data to save gas and then I'll name this input underscore text. We'll insert the new to do into the array of to Dos in one line. So we'll type to dos, push capital t to do, and then I'll initialize this to do struct by typing text is the text from the input, and completed is false. Moving on, let's write the function to update a text inside an existing to do. So it's going to take in two inputs. It's going to take in the index of where the to do is stored in the array of to Dos, and the new text to update to.
00:01:43.630 - 00:02:34.800, Speaker A: So it'll be string call data again to save gas. Input name will be text here there are two ways to update the text of the to do. The most straightforward way is to directly update the text without declaring a variable so it will look something like this. Access the to do array at index and then update the text by saying text equals to underscore text from the input. The other way to update the text is to first declare a variable. So I'll type to do storage and then I'll name this to do equals from the array of to Dos get the to do stored at the index. Once we get this to do assigned to our variable, then we can update the text by typing to do text equals text.
00:02:34.800 - 00:03:22.426, Speaker A: These two code do exactly the same thing, but there are slight differences to the amount of gas that they will use. If you only have one field in the struct update, then this will be the cheaper way to go with. However, if you have multiple fields that you need to update, then this will be cheaper on gas. For example, let's say that we wanted to either update multiple fields in a struct, or maybe we want to update it multiple times. For simplicity, I've updated the text four times over here, and in this case it used over 35,000 gas. And then I ran the same example using this syntax. First store the reference to the struct in a variable named Todo and then update it four times, exactly the same number of times that we did over here, and in this case it used less than 35,000 gas.
00:03:22.426 - 00:04:06.022, Speaker A: Why did it use less gas? Well, for this syntax, notice that every time we're accessing the array at index and then getting the struct and then updating the text. So we're accessing the array four times over here, whereas over here we only access the array once and then update it four times. So this is why this way of coding saves a little bit of gas. You're not accessing the array four times, you're only accessing it once. So when you're writing a function that updates a struct and you need to update multiple fields, then this will probably be cheaper on your gas. However, if you only need to update one field, then this is probably cheaper on your gas. Here we're only updating one field, so we'll stick with this syntax.
00:04:06.022 - 00:04:57.338, Speaker A: The last function that we'll write is get this would get the to do stored in the to DOS array at an index that we put in as input. For this example, we don't need this function, since when we compile it and then deploy the contract. You can see here that solidity provides a function to get the to do from the array of to DOS. However, for practice we'll write the function anyways to the get function we'll pass in the index of the to do that we want to get. So for the input I'll type Un index and we're going to be returning two data, the text and the status completed. So for output we'll type returns string memory and Boolean. First we'll get the to do by typing to do.
00:04:57.338 - 00:05:48.502, Speaker A: We're not going to be updating the to do, so we'll load this to do onto memory. So I'll declare it as memory. I'll name it to do and it is equal to to DOS at the index and then we'll return the data stored in this to do by typing return parentheses to do text to do completed I was curious if I can save gas by changing this from memory to storage. I did an experiment of calling get by changing this keyword from storage and memory. When I declared this as storage, it used about 29 400 gas. However, when I declare this as memory, then it used over 29 400 gas. I'm guessing that when you declare this as storage, then it doesn't have to do a copy.
00:05:48.502 - 00:06:18.322, Speaker A: It only does a copy when it returns. Whereas if you declare this as memory, then it does a copy once over here, and when it returns it does another copy. So that is why memory is slightly more expensive than declaring as storage. So it's up to you to declare this as either memory or storage. I forgot to add one function to this contract. At the moment we cannot toggle completed, so completed will always be equal to false. So let's write a function to toggle the completed.
00:06:18.322 - 00:07:09.810, Speaker A: I'll name this function toggle completed and it's going to take a Un index. This function will be external and to update the completed of the to do store that index we say dot completed is equal to we'll flip the current value of completed. If the current value of completed is true, then we'll flip it over to false. And if the current value of completed is false, then we'll flip it over to true. We can do that simply by saying not to dos of index completed. Here we're setting completed to the opposite current value of completed and this completes the to do list. Let's compile it, deploy it, and call some functions.
00:07:09.810 - 00:07:42.222, Speaker A: I'll hit ctrl s to compile it and then deploy the contract. And then we'll call some functions. We'll create a new to do by saying something like learn solidity, then hit create. The first to do is insert it into the array of to DOS at index Zero. So I'll get it by inserting zero here and then calling get. We can get the same to do by directly accessing the array of to DOS. So to dos of Zero we get the same to do.
00:07:42.222 - 00:08:10.850, Speaker A: I'll update the first to do by saying update the first to do store that index Zero and we'll say learn Viper. Click on Update text check the new to do says learn Viper. We already know Viper, so I'll toggle completed for the first to do store that index Zero, hit toggle completed, call get again and this task is completed.
