00:00:00.400 - 00:00:17.961, Speaker A: This course is sponsored by Siphon. To get the full learning experience, please head over to Siphon Updraft. Links will be in the descriptions below. On Siphon Updraft. Lessons are organized into sections. Here you'll be able to check your progress. There are also exercises and solutions under the written lessons.
00:00:17.961 - 00:01:08.674, Speaker A: You'll also be able to copy the commands and the code that is used in these exercises. So to get the most out of your learning, head over to Siphon Updraft. Welcome to the course for Uniswap B2. In this video I'll answer the questions who is the course for? Why should you take the course? What will you learn? And some best practices for learning effectively. The first question who is the course for? This course is for intermediate solidity developers who are interested in DEFI and who also has some experience working with Foundry. Other than that, having a basic knowledge of high school math will help. Why should you take the course? Well, Uniswap B2 is forked by many protocols, so having the understanding of how Uniswap B2 works will give you some competitive edge if you're participating in an audit contest or a bug bounty that involves some kind of knowledge of Uniswap V2.
00:01:08.674 - 00:01:53.669, Speaker A: Once you learn Uniswap V2, you'll have some background knowledge of how other AMMs should be built and you can extend your knowledge to other AMMs like CURB and Uniswap B3. What will you learn in this course? You'll learn the math of constant product amm. We also do a deep dive of Unisoft B2 contracts and there are several exercises where you will write some tests in Foundry and then execute some transactions on the main network with the Unisoft B2 contracts. So you'll get some experience simulating a transaction with the Unisoft B2 contracts that are on mainnet without paying any transaction fees. And lastly, best practices for learning effectively. The most important thing is to learn by doing so. After you watch the videos you should play around with Foundry and the MainNet fork.
00:01:53.669 - 00:02:39.753, Speaker A: Try simulating some transactions with the Uniswap B2 contracts that are on MainNet and by actually doing this, some of the stuff that I covered in the videos will stick to you. Another thing you can try is to code some app that integrates with the Uniswap B2 contracts or recreate the Uniswap B2 Contracts. This is really helpful in understanding why the contracts of Uniswap B2 are written in that way. Another thing that you can try and this is something that I also do is to take notes and then make it easy to find. For example, take some notes and then push it to your GitHub private repo. Later on when you need to come back to the notes, you can search it and then find some notes about the protocol. And lastly, there's no need to memorize any of the equations or how to call the functions on Uniswap B2 contracts.
00:02:39.753 - 00:03:14.339, Speaker A: Whatever that you need will stick to you. And whatever that you don't need, you already took some notes so you can come back and easily find it later. Okay? With that said, let's get started here. On the right is a graph of a constant product AMM used in unisod B2. On the left we have the equation for this curve X times Y equals L squared. In this video, I'm going to answer two questions. One, how does this curve determine the amount of token that goes out in a trade? And two, what is this L? Does this have any special meaning? And how do we interpret this number? Let's begin with the first question.
00:03:14.339 - 00:04:22.250, Speaker A: How does this curve determine the amount of token that goes out in a trade? Let's say that we have an AMM with tokennext and tokeny. The amount of tokennext in this pool is 200 and the amount of token Y in this pool is also 200. All possible amounts of token that can be in this pool is defined by this blue curve. So for example, 200 for token X and 200 also for token Y is a valid amount of tokens inside this amm. Also, if we wiggle the value of X, for example, if I slide it over to the right, you can see that the amount of token Y also changes. So for example, if I move the amount of Token X to 400, then we can see that 400 for Token X and 100 for Token Y is also a valid amount of tokens and inside this amm. And if we slide this X value over to the left, let's say somewhere around here, then we can see that the amount of token x equal to 113 and amount of token y equal to 353 is also a valid amount of tokens inside this AMM.
00:04:22.250 - 00:04:50.146, Speaker A: But how about let's say 400 400? Well, 400, 400. The point 400400 will be over here. And notice that this point 400400 is not on this blue curve. Hence 400400 will be an invalid amount of tokens in the pool. And another example, let's say Somewhere around here. So this will be, let's say over here 100 x equals 100. So let me wiggle this around.
00:04:50.146 - 00:05:31.598, Speaker A: X equals 100 at x equals 100 and let's say y equals 200. Can this AMM have the amount of token x equal to 100 and the amount of token y equal to 200? Well the point will be here, but this point is not on this blue curve. So this will be an invalid amount of tokens for this amm. All possible amounts of token inside this AMM must be a point on this blue curve. So with that said, let's look at a trade. So let's say that initially our pool has 200200 token amount of token x is 200 and the amount of tokeny is 200. From 200 200.
00:05:31.598 - 00:06:02.201, Speaker A: Let's say that we added 200 tokeny. This will land us on token next equal to 100 and tokeny equal to 400. So if we do a trade and add 200 token y, then the amount of token next must be equal to 400. The difference between these two numbers define how much token that came in and how much token that goes out. So let me explain. We said that 200amount of token Y came in. We started out with token y equal to 200.
00:06:02.201 - 00:06:37.757, Speaker A: When we add 200 to this we get y 400. So this is dy 200 and how much token X will have to go out from this amm? Well let's see what the difference is in the x axis. We started out with x equals 200 and we end up at x equals 100. 100 minus 200 is equal to minus 100. This is the amount of token next that will go out for putting in 200amount of token Y. Let's look at another example. Let's do a trade in the other direction.
00:06:37.757 - 00:07:23.009, Speaker A: So let's say that we start at 200200 and add 100 token next. So this would mean that X1 will be equal to 300. So I'm going to slide this over to 300 and you can see here that the amount of token X that came in is 100 and the amount of token Y that will go out is minus 66. So where does this minus 66 come from? Well, it comes from the difference of the initial value of Y and the new value of Y. The new value of y is 133 minus the old value of y which will be 200. If you do 133 minus 200, you'll get minus 66. So if we put in 100 token next, then we'll get back 66 token y.
00:07:23.009 - 00:08:06.843, Speaker A: And this is how the amount of token that goes out in a trade is determined. Next, I'm going to answer the question, what is this L value? This L, usually referred to as liquidity, tells us how big the AMM is. For example, let's say that we have an AMM pool with the amount of token x equal to 100 and the amount of token y also equal to 100. 100 times 100, and we need to satisfy this equation. So L must also be equal to 100. Now, if I slide this L value to the left, you can see that the curve gets smaller and also you can see that the curvature gets tighter. Another example, let's say that we have an AMM with the amount of token x equal to 300 and amount of token y equal to 300.
00:08:06.843 - 00:08:46.739, Speaker A: I'm going to slide this L value over to the right. And as we slide over to 300, you can see that the curve gets bigger and also the curvature gets smaller, the curve gets more smooth. And if I increase this to 400, you see that the curve gets even bigger. Now, why do we care whether the curve is small or whether it's big? The answer is the bigger the curve, the better price you'll get when you do a trade. For example, let's say that we have l equals to 200. Initially, let's say that the amount of token X and the amount of token Y is also equal to 200. 200.
00:08:46.739 - 00:09:18.869, Speaker A: And let's do a swap of swapping token next for token Y. We'll put in 200 token next and see how much token Y we'll get. So here's the amount of token X and token Y before the trade. And here is the amount of token X and Y after the trade. When L is equal to 200, the amount of token Y that we'll get for putting in 200 token X is 100. Now let's compare this number DY equals to 100 when we have a bigger L. So I'm going to scroll up and then increase this L, let's say to 400.
00:09:18.869 - 00:10:09.118, Speaker A: In our example of L equals to 200, we started out with the amount of token X and the amount of token y being equal 200. 200. So I'll adjust this amount of token x to be 400. So what this tell us is that we're starting out with an AMM that has equal amount of token X and equal amount of token Y And to this amm, let's put in 200 token put in 200. So this will give us X1 equals 600. We started out with 400400 a pool with equal amounts of tokens and then to this pool we add 200 token and what do we get for Dy? Dy tells us the amount of token Y that we'll get and we'll get 133. Notice that before when l was equal to 200 dy was equal to 100.
00:10:09.118 - 00:10:46.717, Speaker A: Over here it says that dy is equal to 133. This is more than before. And what this tells us is that when L is a large number, traders will get a better deal for the same amount of token that they put in. When L was equal to 200, this trader got 100 dy. However, when l is equal to 400 for putting in the same amount of token x 200 this trader was able to get 133 token y. There are three important contracts in Uniswap B2 for it to function as an ammunition. These contracts are called factory, router and pair contracts.
00:10:46.717 - 00:11:26.099, Speaker A: The factory contract is a simple contract that deploys the pair contracts. The pair contract is a contract that holds a pair of ERC20 tokens. This contract also allows users to add or remove liquidity and the traders to swap the ERC20 tokens locked inside the pair contract. For example, we can have a pair contract of ETH usdt. This will allow liquidity providers to provide both ETH and USDT and also remove these tokens. It also allows the trader to swap ETH for USDT or USDT for ETH. Each ERC20 tokens pair will have a pair contract.
00:11:26.099 - 00:11:51.987, Speaker A: So we can also have a pair contract of DAI eth. This contract will allow traders to swap DAI for ETH and ETH for dai. The pair contract doesn't have to be paired up with ETH. It can also be paired up with other ERC20 tokens. For example, we can have DAI MKR. Now a user can directly call into the pair contracts to add or remove liquidity or do a swap. However, because of how the pair contracts are designed, this is error prone.
00:11:51.987 - 00:12:43.247, Speaker A: It's easy for the user to make a mistake and accidentally lock their tokens inside the pair contract. This is why we have the router contract. The router contract is an intermediate contract between the user and the pair contracts. The main job of the router contract is to safely add, remove liquidity from the pair contracts and also safely swap tokens with the pair contracts. Now, a swap can either interact with a single pair contract or with multiple pair contracts. For example, if a user swaps DAI to eth, then the router will interact with the DAI ETH pair contract. And if the user wanted to swap ETH for mkr, then the router contract will first interact with the DAI eth pair, swap ETH for DAI and then interact with the DAI MKR pair, swap DAI for MKR and then send the MKR over to the user.
00:12:43.247 - 00:13:21.987, Speaker A: The user can directly call the factory contract to deploy a pair contract if a pair contract does not exist. Or they can also call the router contract which will call into the factory to deploy the pair contract. The user can also call swap, add or remove liquidity on the router contract and the router contract will call into the pair contracts. So this is it. Three contracts that we need to understand. To understand how Uniswap B2 works, we saw some examples of swaps using a graph. We took two points on this curve and the difference of X component and the Y component told us how much token that we need to put in and how much token that we will get out.
00:13:21.987 - 00:13:55.657, Speaker A: In this video we're going to derive the exact formula for the amount of tokens that go out, given the amount of token that goes in. Here I have the curve X times Y equals L squared. And let's say that this AMM starts out with amount of token x equal to x 0 and amount of token y equal to y 0. Let's also say that Alice swaps dx for dy. This means that she's going to put in dx amount of token X. So this will increase the amount of Token next from x0 to x0 plus dx. When token comes in, the other token must go out.
00:13:55.657 - 00:14:28.475, Speaker A: So when she puts in DX amount of token next, she's going to get back DY amount of token Y. This is expressed here. The new amount of token Y that must be in this pool is y 0 minus dy. Notice that from the original amount of token Y it decreased. So what we're going to do in this video is given dx, we're going to calculate DY before Alice does a swap. This equation is true. If we plug in x0 and y0 to this equation, we'll get that x0 times y0 is equal to L squared.
00:14:28.475 - 00:14:57.635, Speaker A: And this equation must also be true after Alice does a swap. This is called an invariant. So before Alice does a swap, x 0 times y 0 must be equal to L squared. After Alice does a swap, this equation must also be true. So let's write this down before Alice does a swap. The equation x 0 times y 0 must be equal to L squared. When this equation is satisfied, this tells us that this point x 0 y 0 is on this curve.
00:14:57.635 - 00:15:43.089, Speaker A: After we do a swap, remember that we said that the new point must also be on this curve. To express this mathematically, what we want to say is after the swap, the new point must also satisfy this equation. So what is the new point? The new point will be x0 +dx for the x component that you see over here. And for the Y component, it will be y0 minus dy that you see over here. So before we do a swap, the equation X times y plug in x0 and y0 must be equal to L squared. And after we do a swap, the equation X times Y for the X we plug in x0dx, and for the y we plug in y0 minus dy must also be equal to L squared. Notice that we have a DY over here.
00:15:43.089 - 00:16:15.107, Speaker A: So if we relate these two equations, we might be able to solve for dy. So let's do that. What I'm going to do is copy both the equation, paste it here. Notice that both of them are equal to L squared. So what I can do is say x 0 times y 0 is equal to x 0 plus dx times y 0 minus dy. We can divide both side of the equation by x 0 plus dx. So this will bring x 0 dx over to the left side.
00:16:15.107 - 00:16:41.411, Speaker A: Then we'll add dy to both side of the equation. So dy comes over here. So this will be dy plus. And then we'll bring this over to the right side. So this is the equation that we have so far. Now we can simplify the right side. What we're going to do is multiply y0 by x0 plus dx divided by x0 plus dx.
00:16:41.411 - 00:17:12.115, Speaker A: So we're just multiplying by one so it does not change this equation. Now we can simplify the equation. So we have this equation and I'm going to bring this over to the top. So the top will be y 0 times x 0 plus y 0 times dx. And then minus this expression, the bottom is the same. So we can combine these two equations together, bring the negative to the top. Then we have a common denominator of x0 plus dx.
00:17:12.115 - 00:17:53.497, Speaker A: Notice that on top we have y0 times x0 minus x0 minus y0. So these two cancel out Clean up the equation and we're left with y 0 times dx divided by x 0 plus dx is equal to dy. So this is the equation for how to calculate dy. If we know the amount of token X and the amount of token Y in the amm, and then if we also know the amount of token that we're putting in dx, then we can calculate the amount of token that we'll get out. This is dynamic. This equation will calculate the amount of token Y that will come out. However, here we're assuming that the swap fee is equal to zero.
00:17:53.497 - 00:18:20.853, Speaker A: So this equation will give us DY without the fees. In the next video, we'll modify this equation and also include swap fees. Okay, let's talk about swap fees in Uniswap B2. So let's say Alice swaps DX for DY. In Uniswap B2, swap fees are charged on tokenin. A fractional token that comes in is taken out from the calculation of dy. Let's call this swap fee rate F.
00:18:20.853 - 00:18:43.983, Speaker A: F will be a number between 0 and 1. One will mean 100%. So this will mean 100% of DX. And 0 will mean 0% of DX. So we're saying this is swap fee rate. And the way to calculate swap fee is to multiply F by the amount of token that comes in dx. For example, if f was 0.5,
00:18:43.983 - 00:19:22.287, Speaker A: then this will mean swap fee will be half of dx. Now let's calculate DY with fees. We will start out with the equation of DY without any fees. We're going to modify this equation to include the swap Fees in Uniswap B2. Every time a trader swaps, a fraction of dx is taken out of this equation. Since F times dx will be taken out as swap v, the amount that will be used in here to calculate dy will be 1 minus f times dx. So the amount of tokenin that is used to calculate DY will be DX minus the swap phi.
00:19:22.287 - 00:19:53.607, Speaker A: Or we can say this as DX times one minus f. Before we just add DX over here and DX over here. With swap phi, we multiply these DX with one f. So we multiply one minus F over here and one minus F over here. And this is the equation that we will use to calculate the amount of token that comes out, including swap fees. Let's go over an example of calculating Dy with swap fees. Let's say that in this AMM there are 6 million Dai and 3000 Ne.
00:19:53.607 - 00:20:20.351, Speaker A: The swap fee on Uniswap B2 is 0.3%. Or we can write this as 0.003. Let's say that we're going to buy as much EVE as we can for putting in 1000 Dai. To solve for Dy, what we have to do is plug in the numbers into here. Okay, let's start with dx. What is dx? Dx is 1000 Dai. I'll replace the dx with 1000 and do the same over here.
00:20:20.351 - 00:20:40.001, Speaker A: 1000. Next, let's replace 1 f. F is 0.003. So 1 minus f. This will be 0.997. I'll replace the bottom one minus f also with 0.997. Okay, how about x0? X0 is 6 million Dai.
00:20:40.001 - 00:21:12.421, Speaker A: 6 million Dai. Okay, and that's the y0 is the amount of beef. This will be 3000. Okay, so dy will be this number, whatever this is. Plug this into a calculator and we get that DY is approximately equal to 0.49841. Let's go over example of what contract and functions are called inside Uniswap B2 and how the tokens are transferred. When a user calls a function to swap tokens for another token.
00:21:12.421 - 00:21:47.853, Speaker A: In this example, we'll do a swap from ref to die. Now notice that here I am saying ref instead of eth. Here we are trading from an ERC20 token to another ERC20 token. Swapping from eth to a ERC20 token is also possible and the logic for it is similar to swapping from ERC20 to ERC20. So in this video we'll go over an example of swapping from ref to die. The first thing that the user does is call a function to swap on the router contract. Now there are several functions that the user can call swap token for another token.
00:21:47.853 - 00:22:21.793, Speaker A: One of them is called swapexactokens for tokens. What this function will do is it would try to convert all of the tokens that came in for the token that the user wants. In this case, what this function will do is it would try to convert all of the weft that the user sent and then convert it to dai. Another thing that I'll mention here is that if the user wanted to swap eth for dai, then they would call a similar function called swapexacteif for tokens. And this will swap from eth to dai. Notice that eth is not an ERC20 token. So that's the difference.
00:22:21.793 - 00:22:57.983, Speaker A: If you wanted to swap ERC20 for ERC20, then you would call Swap exact tokens for tokens. If you wanted to swap from ETH to ERC20, then you would call swap exact ETH for tokens. Next, WEF is transferred from the user to the pair contract. Once WEF is transferred over to the pair contract, the router will call a function called swap. This function will check the balances of tokens inside this pair contract, calculate the amount of DAI to send over to the user, and then transfer the dai. So this is an example of a swap from ref to dai. This is an example of a single hop swap.
00:22:57.983 - 00:23:30.217, Speaker A: It is only swapping with one pair contract. Next, let's take a look at an example of swapping between multiple pair contracts. For this example, let's say that a user wants to swap ref for mkr. However, if you look over on the right, we see a die WEF pair contract and die MKR pair contract. What we don't see here is a ref MKR contract. So does this mean that this user won't be able to swap ref for mkr? Well, not to worry. The user still can't swap ref for mkr.
00:23:30.217 - 00:24:12.325, Speaker A: And the way this will be done is the user will swap ref for DAI and then from DAI to mkr. Let's go over which contract and functions are being called and how the tokens will be transferred. Again, inside the router, there are multiple functions that the user can call to swap tokens for another token. In this example, we'll call a function called Swap exact tokens for tokens. And again here we're using WEF, which is an ERC20 token. And as mentioned earlier, if the user wanted to swap eth for another ERC20 token, then they can call the function swapexacteaf for tokens. Next, the router will transfer the user's ref over to the die ref pair contract.
00:24:12.325 - 00:24:53.089, Speaker A: And like in the example before, the router will call the swap function on the die ref pair contract. This will calculate the amount of DAI that will go out and then it will transfer over to the DAI MKR pair contract. Now, it might be surprising that this die was not sent over to the router or to the user, but it was sent over to the next pair contract that will be called. The router will call the swap function on the DAI MKR pair contract. The amount of DAI to swap was already sent in the previous step. At step four, this contract will calculate the amount of MKR to send back to the user and then Transfer it to the user. So this is an example of a multi hop swap.
00:24:53.089 - 00:25:29.325, Speaker A: The router first swap ref to die and then from die to MKR. The code for Uniswap B2 protocol is split into two repos, B2 core and B2 periphery. B2 periphery contains the contract called Router Uniswap V2 router 02. This is the contract that we'll take a look at later. Also this router contract will be the contract that we'll be calling to add and remove liquidity and to also swap tokens. The actual contract that blocks liquidity and swap tokens is inside the repo called B2Core. Open it inside the contracts.
00:25:29.325 - 00:26:09.497, Speaker A: The contract is called Uniswap B2 Pair. You might be asking why is the code for Uniswap B2 split into two repos? Why can't we just have a single contract for the amm? One of the reason why the code is split into two parts is because they serve a different responsibility. The main responsibility of Uniswap B2 pair contract is to manage 2 pairs of tokens and also swap tokens. As we saw an example of multi hop swap. If you wanted to do multiple swaps, then we need some other contract other than the B2 pair contract. And this is where the router contract comes in. The router contract is a useful contract if we have to do multiple hop swaps.
00:26:09.497 - 00:26:55.217, Speaker A: And another reason why we have the router contract is for utility. Yes, we can use the Uniswap B2 pair contract to add, remove liquidity and also swap tokens. However, the code inside Uniswap B2 pair contract is not meant for users to directly interact with. So if we were to directly swap with the Uniswap B2 pair contract, you might make some mistake and lose some tokens. The router contract automates some of the function calls that we need to make to the Uniswap B2 pair contract to swap tokens without making a mistake. So those are some reasons why the Uniswap V2 protocol is split into two repos. Over the next few videos I'll explain how the functions swap exact tokens for tokens and the functions swap tokens for exact tokens work.
00:26:55.217 - 00:27:35.517, Speaker A: Now, if you want to simply jump in and start coding or you just want to swap tokens using Uniswap V2, then you don't need to watch this video and some of the following videos. These videos will be for developers who are curious how these functions work. Maybe you need to fork Uniswap B2 to modify some of the code, then keep watching and I'll explain the code for swap exact tokens for tokens and the code for swap tokens for exact tokens. Let's start with the function swapexactokens for tokens. Let's start with a review of what this function does. This function will swap all of the inputs for max output. So let's say that you have 1000 Dai and you want to buy the maximum amount of WEF.
00:27:35.517 - 00:28:15.137, Speaker A: Then you will call this function. So how does it actually work? The way it works is it's going to call our UNISOFT B2 library, a function called getamounts out and it will return the array of UINT called amounts. The first element in this array will contain the amount of input token that went in. So this will be amount in that you see over here. The last element in this amount array will contain the amount of tokens that came out the last swap. If the swap involved multiple swaps, for example from die to left and then from left to mkr, then this amounts array will also contain outputs for the intermediate swaps. We'll look at the code for getamountsout later, so let's move on.
00:28:15.137 - 00:28:52.702, Speaker A: Again, the last element of this amounts array will contain the amount of token that came out from the last swap. And here we're checking that this amount that is stored in this amounts array is greater than or equal to amountoutmin. This is a number that the user specifies and it tells uniswap the minimum amount of token. Now that user wants from this swap. On the next line, the input token is transferred over to the pair contract. The input token will be stored inside path 0, and the pair contract is computed by taking path 0 and path 1. The way it computes the pair contract address is by using Create2.
00:28:52.702 - 00:29:31.567, Speaker A: Here I won't get into the detail of how Create2 is used to calculate the address of the pair contract. And the amount to send is stored inside amount zero. It might be surprising here that we're directly sending the input token over to the pair contract instead of the pair contract calling a transfer from. And this is one of the reasons how the router contract serves as a utility contract. If we were to directly call the pair contract. To call swap, we will first have to directly send the tokens into the pair contract and then call the swap function on the pair contract. Here these two steps are automated by the function swap exact tokens for tokens.
00:29:31.567 - 00:30:10.107, Speaker A: Token is directly transferred over to the pair contract and inside the internal function swap it will call the function swap on the pair contract. Okay, so let's take a look at the internal function called swap. Scrolling up, here's the function and the inputs for this functions are amounts. And this amounts array is exactly the same as the amounts array that we see over here. So it will contain the input amount and all of the intermediate output amounts. And the last element will contain the amount of token that came out from this entire swap path will be the addresses of the tokens to swap. And this path will determine which pair contract to call.
00:30:10.107 - 00:30:56.077, Speaker A: Two will be the receiver of the final output token inside the forward loop. It it gets the address of the pair contract and then it calls the function swap. The for loop iterates from I 0 to I less than path length minus 1. Why is the iteration only going up to path length minus 1? Here I listed the values of index I and then which paths it will access. So when I is equal to 0, path of I will be path 0 and path of i1 will be path 1. Knowing the token address stored inside path 0 and path 1, we will be able to get the address of the first pair contract. When I is equal to 1, path will be path 1 and path of I 1 will be path 2.
00:30:56.077 - 00:31:36.525, Speaker A: And the token addresses stored in path 1 and path 2 will determine the second pair contract where it will call the function swap. When I is equal to two it will access path two and path three. And again this will get the pair address that is associated with the token addresses stored in path two and path three. Let's say that the length of the path is equal to n. Then we will loop this until N2 at N2 we'll need to access path of N2 and path of N minus 1. Path of N minus 1 will store the last token address. So this is why the for loop loops From I equals 0 to I less than path of length minus 1.
00:31:36.525 - 00:32:14.105, Speaker A: Or put it another way, I will be less than or equal to N2. For each iteration it will access path of I and path of i1. The input token will be path of I and the output token will be path of i1. Next it will sort the tokens to determine which is token zero that is stored inside the pair contract. This will be used later in the code to figure out how much amount 0 out and amount 1 out to pass to the function swap. Amount out will be stored in amounts of I plus one. Okay, but how about amount in? Well, the first amount in was transferred over.
00:32:14.105 - 00:33:00.237, Speaker A: If we scroll down over here. We directly transfer the tokens and then call the internal function swap. So the first amount in was already sent before we call the function swap on the pair contract. And how about amount in for the rest of the swaps? For example, if we had to call two pair contracts, then how does the first swap send the token over to the next pair contract? And the answer lies inside this code over here. When I is equal to N2, then we know that this is the last swap. So the address of two will be the receiver address which is specified in the input. And when I is less than Path Bank 2, then we know that for the two address we need to pass the output to the next pair contract.
00:33:00.237 - 00:33:43.113, Speaker A: The next address of the pair contract is calculated over here, which will be output. Output will be path of I + 1 and path of I + 2 once the 2 address is determined. The last part of this for loop is to call the function swap on the pair contract. Okay, the final part that I want to explain for the function swap exact tokens for tokens is the function getamounts out. This function getamount out is inside the library called Uniswap B2 Library. So inside B2 periphery, inside libraries, I'll click on Uniswap B2 Library. And inside here I'm looking for a function called getamount out, which I see over here.
00:33:43.113 - 00:34:24.711, Speaker A: What this function will do is calculate amount out for each swap and it will return that result as an array of uint. The first element in this UINT array, it's called amount, will store the amount in amount of token that came in. The rest of the elements will store the amount of tokens that came out for each swap. For example, if there was only one swap, then amount 0 will be amount in and amount 1 will contain the amount of token that came out from that swap. If there were two swaps, let's say from dai to ref and then From Ref to MKR. Again, the first element, Amount 0 will contain Amount N. Amounts 1 will contain the amount of weft that came out for swapping from die to ref.
00:34:24.711 - 00:34:53.402, Speaker A: And amount two will contain the amount of MKR that came out from swapping ref to mkr. Okay, let's scroll down and look at what the rest of the function does. So it does a for loop and then calls the function getreserves and calls the function getamount out. We'll go over this later. Let's start with over here. It's looping From I equals 0 to I less than path length minus 1. Again, let's say that the length of this path array is equal to some number n.
00:34:53.402 - 00:35:29.801, Speaker A: For i0, path of I will be path 0 and path of i1 will be path 1. For i1, this will be path 1 and path 2. And for i2, the code inside here will access path 2 and path 3 and it keeps looping. And let's see what happens at when I is equal to n 2. When I is equal to n minus 2, it's going to access path of n minus 2 and path of n minus 1. Path of n minus 1 will hold the address of the last token. And path of n minus 2 will hold the address of token that is 1 before the last token.
00:35:29.801 - 00:36:01.341, Speaker A: So that is why inside here the for loop goes From I equals 0 to I less than path of length minus 1. Inside this for loop, it calls a function called getreserves. And what is this? Reserves inside the Uniswap B2 pair contract. Reserves refers to the internal balance of tokens. What this means is that Uniswap B2 pair contracts internally keeps track of the balance of tokens that is locked inside the contract. So that is reserves. Calling this function, we will be able to get reserve in and reserve out.
00:36:01.341 - 00:36:32.789, Speaker A: And then this reserve in and reserve out is passed as an input to the function getamount out. Getamount out will calculate the amount of token that will come out given the amount of token that goes in and the amount of reserves, reserves in and reserve out. So let's take a look at the function getamount out. Scrolling up, here's the function getamount out. First it does some checks which you can see over here. Amount in greater than zero and reserve in reserve out also greater than zero. What's interesting is how it calculates amount out.
00:36:32.789 - 00:37:04.869, Speaker A: This is the number that is returned. Amount out is equal to numerator divided by denominator, which we can see over here. Now recall from a previous video about swap math that we derived that DY is equal to this equation. What I want to do here is check that this code over here is equivalent to this equation. Let's start with a mountain with V. This is amount n multiplied by 997. For this part of the code, let's say that X is token in and Y is token out.
00:37:04.869 - 00:37:45.287, Speaker A: Then amount in with V will be amount in multiplied by 997. And here I'll denote it as DX times 997. Okay. Next it creates a variable called numerator, which is amount in with v times reserve out, amounting with phi, we denote it as dx times997 and reserve out, we will denote it as y0, since over here we say Y is token out. Okay, how about denominator? Denominator is reserve in multiplied by 1000 plus amounting with fee. Reserve in, we'll denote it as x0. Multiply this by 1000 plus amounting with fee.
00:37:45.287 - 00:38:23.719, Speaker A: What is amounting with fee? Amounting with fee is DX times 997. So for the numerator we have this expression, and for the denominator we have this expression. And this code over here says that DY should be equal to numerator divided by denominator. Here I wrote down what numerator divided by denominator is equal to. Notice that this code up here looks a little bit like this code. However, we have a multiplied by 1000 over here. To show you that these two equations are equivalent, all we have to do is divide the top and the bottom by 1000.
00:38:23.719 - 00:39:03.045, Speaker A: On the top we will have dx times 997 divided by 1000 times y0. And on the bottom we'll have x0 plus dx times 997 divided by 1000. And you can check for yourself that this code over here and this code over here are the same. So the math checks out. Getamount out calculates this equation and that completes the code Walkthrough for the function getamountsout. If you want to quickly copy and paste the code for the next part of the lesson, head over to Cyphrain Updraft. Here, under the written lessons, you'll be able to copy the code and then paste it into your code editor.
00:39:03.045 - 00:39:39.951, Speaker A: The function get amounts out inside the library uniswap B2 library. It might be a little bit confusing. So what I want to do is go through example using real numbers to fetch actual numbers from Uniswap V2. We will write a test in Foundry and then execute the test on main network. Copy the numbers over here and then we'll run through the code example using those real numbers at the very bottom of Uniswap B2 router 02 contract. There are two functions, Getamountsout and getamountsin. What these functions do is it just calls the library function uniswaptolibrary getamountout.
00:39:39.951 - 00:40:25.459, Speaker A: So by calling these two functions, you'll be able to fetch the real numbers that I use first. False. Let's write a test inside Foundry to call the function getamount on the Uniswap B2 router contract here, I've initialized some code for a test. It's going to import IERC 20 WEF interface per Uniswap B2 router, some contract addresses like Dai, WEF, MKI, Uniswap B2 router 02 and then we initialize the test by initializing ref, dye MKR and router. We'll write our test inside here. The function that we're going to be calling is inside uniswap b2 b2 periphery contracts uniswap b2 router 02 and I'm going to scroll all the way down. And for this example, we're going to be calling this function.
00:40:25.459 - 00:41:01.325, Speaker A: So I'll copy this and then paste it here inside our test. Okay, so this is the function that we're going to call on the router contract. So for this example, let's say that we wanted to swap from WEF to die and then from die to mkr. We'll need to prepare an array of addresses. Let's call this path. I'll say address Memory path is equal to new address of length three. Why is it length three? Well, because we're going to pass ref die and then mkr, we'll say path zero is equal to ref.
00:41:01.325 - 00:41:34.017, Speaker A: The address of this ref, we import it from here. Path one we said is die, so say die and path two we'll say is MKR. Okay, amount in, let's say amount in is one ref. So say uint256. Amount in is equal to 1e18. 1e18 is the same as 10 to the 18. And why are we saying 10 to the 18 here? Well, this is because ref has 18 decimals.
00:41:34.017 - 00:42:11.111, Speaker A: What we're going to do is we're going to trade one ref for Dai and then for Dai for MKR. And we're asking Uniswap B2 router contract. If we were to do this trade, how much amount of MKR will we get and how much of DAI will we get when ref is traded to dai? Okay, the next part is to actually call this function. So I'll say router.get amounts out. Amount 10 is the input 1 ref and the path will be ref die mkr, which we initialized above. And calling this function will return a UINT array of amounts.
00:42:11.111 - 00:42:38.803, Speaker A: So say uint memory amount is equal to. I'll make this uint256. Okay, the last part of this demo, we'll console log the amount. So say console two Log and where does this console two come from? Well, it comes from foundry test. We import it from test console two. Console two log. Let's console log all of the amounts that were returned.
00:42:38.803 - 00:43:19.625, Speaker A: The path has length three. So the amounts will also have the same length as the path with amounts 0. And as I mentioned earlier, amounts 0 will contain the input amount. So we expect amounts 0 to be 1E18. Okay, let's do the same for die and MKR. Dai will be amounts 1 and MKR will be amounts 2. Amount 0 will be amount of weft that we put in amounts 1 will be the amount of Dai that we get out for putting in one ref and amounts 2 will be the amount of MKR that we will get for putting in this amount of die.
00:43:19.625 - 00:44:00.487, Speaker A: Okay, let's execute a main net fork on this test. So I'm going to open my terminal. First thing that I'll do is set my fork URL as an environment variable. Here's my fork URL, which I got from Alchemy. I'll copy this and then inside my terminal paste it. And then we'll execute the test by running Forget fork URL is the fork URL that we set above fork URL and the path of the test will be match path test Uniswap B2 Uniswap B2 swap amounts test SOL and we'll print out the console log. So say dash bbb and then execute the test.
00:44:00.487 - 00:44:39.517, Speaker A: Okay, these are the logs from console log. Put in one with we got some amount of die. And for this amount of die we get this much amount of mkr. What I'm going to do next is I'm going to copy these inputs and we'll go through a code example of uniswap b2library getamountsout using these actual numbers back inside uniswap b2library contract, we're looking at the function getamountsout. And I pasted the amounts that we got from running the mainnet fork. So for the Inputs we'll pass in 1e18 this is the amount of WEF and for the path we'll do wef. Dimkr when we ran the main network, these are the outputs that we got.
00:44:39.517 - 00:45:00.913, Speaker A: What we'll do here is go through the code and put in these actual numbers. Let's begin. First we initialize amount to a UINT array. Length of the path is three. So what we're initializing here is a UINT array of length three. And this is what you see over here on the next line. It initializes amount 0 to amount n.
00:45:00.913 - 00:45:32.913, Speaker A: Amount n is 1e18. So what we get is amounts array being 1e18 0 and then 0 scrolling down. Let's go over what the for loop does. So for the for loop we'll start with I equals zero. And if we look over here, it gets the address of the paired contract by accessing path of I and path of I +1. What is path of I and path of I +1 when I is equal to 0? Well, path of I will be. Let's see, we say path zero is ref and path one is die.
00:45:32.913 - 00:45:56.773, Speaker A: So path of I I is equal to 0 will be ref. Path of I plus 1 will be 0 plus 1 which will be equal to 1 will be die. So these are the path. Okay, what's next? Once you get the path, it gets the reserves in and reserves out again. These are internal balances of the two tokens managed by the pair contract. It calls the function getamount. This function will take in three inputs.
00:45:56.773 - 00:46:37.207, Speaker A: The amount of token in which is stored in amount of I and the internal balances of the two tokens. Reserve n and reserve out. What I want to focus here is the input amount of I and how it stores amount of I +1. Let's see what is amounts of I and amounts of I +1. Well scrolling up for I equals 0, amounts of I is 1e18 and this is 1e18. Because before the for loop we initialized it as 118 and the output for calling the function getamount out we know is this number approximately 2500 times 1e18. This is the amount of DAI that we get for putting in one ref.
00:46:37.207 - 00:47:10.079, Speaker A: So the output to the function getamount out will be this number. And after the for loop is done executing once for I equals 0, the array amounts will contain 1e18 and 2500.3397 times 1 8. And furthermore, the last element of the array which will store the amount of MKR is still equal to zero. We still have not calculated this amount and this amount is calculated in the next iteration of the for loop. So this is I equal to 0. Let's move on to I equals 1.
00:47:10.079 - 00:47:43.654, Speaker A: When I equals to 1 again we will access path of I and path of I +1. Path of I will be DI and path of I +1 will be MKI. And again we'll call the function getamount out passing in amount of I and what is amount of I for I equals 1. This will be amount of 1. Well this amount of 1 was set to 2500 Dai. So this amount of I will be 2500 Dai. Okay, so using amounts of I as input, it will call the function getamounts out and then store the result in amount of by +1.
00:47:43.654 - 00:48:23.305, Speaker A: And so the amount will be this amount 1.2427 and so on. This is the amount of MKR that we get for putting in 2500 Dai. Once the amount of MKR is stored in amount of i1, our amount array will finally look like this one eth 2500 Dai and 1.2427 MKR. So this was an example of running through the code for get amounts out using actual numbers. Next, let's do a code walkthrough for the function swap tokens for exact tokens for a quick review, what this function will do is it will swap the minimum input for some specified output.
00:48:23.305 - 00:48:58.177, Speaker A: For example, if a user is willing to spend a maximum of 3000 Dai and this user wants to get out exactly one ref, then they will call this function. If getting one ref will result in spending more than 3000 Daisy, then this function will revert. Okay, with that said, let's take a look at this code. First thing it does is it calls a function called getamountin. The last element in this amount array will contain the amount of token that came out. This will be amount out specified by the user. And the first element will contain the amount of token that is needed to get amount out.
00:48:58.177 - 00:49:29.096, Speaker A: And we can see this check over here. Amount zero. The amount of token that is needed must be less than or equal to amount in max. The rest of the elements in this array will contain the amount of tokens for the intermediate traits. We'll look at the details later when we look at the code for getamountin. Okay, moving on. Next, it transfers the input token path0 to the first pair contract, which is calculated by calling a function pair4 and passing path0 in path1.
00:49:29.096 - 00:50:07.893, Speaker A: Path0 and path1 will contain the first two token addresses, and this will determine the address of the pair contract. And the amount to transfer is stored in amount 0. Again, it might be surprising that it directly transferred the tokens before calling the swap function on the Uniswap B2 pair contract. Next, it will call the internal function swap. And what this function will do is for each pair contract it will call the function swap inside the for loop. The last swap will send the output token to this toaddress. All other intermediate swaps will send the output token over to the Next pair contract to call the function swap.
00:50:07.893 - 00:50:42.733, Speaker A: So this is a function for swap tokens for exact tokens. Next, let's take a look at the function uniswap b2library getamountin. Okay, here's the function getamountin inside the library uniswap b2library. What this function will do is calculate the amount of tokenins that is needed to get amount out. The last element in this amount array will contain the amount out specified by the user. And for this array elements that is less than the last one. It will calculate a mountain by running a for loop and then calling the function getamountain.
00:50:42.733 - 00:51:19.085, Speaker A: Now the for loop starts from I equals path of length minus 1 and it will keep on iterating until I is greater than zero. So why is this doing this? Well, we can understand what's going down here by looking at this table. Let's say that the length of this amounts array is equal to some number n. On the left we will list out the for loop indexes. The for loop runs from n minus 1 all the way up to I equal to 1, which you can see over here. N minus 1, n minus 2 and all the way down to 2 and then 1. For each iteration of the for loop it's going to call the function getamount in.
00:51:19.085 - 00:52:06.403, Speaker A: And for the input it's going to need the amount out and the reserves in and reserves out. And what this function will do is calculate the amount of token that needs to come in to get back out amount out. So over here on the middle column I listed out the amount out. And on the very right column I listed out the amount in. This will be the output of the function getamount in before the first iteration on this line over here we initialize the last element of amount array to be equal to amount l. On the first iteration, given the amount out which we set over here, this will be used as an input to the function getamount in which will calculate the amount of token in that is needed to get amount out. The amount of token out we already know is stored in here.
00:52:06.403 - 00:52:36.169, Speaker A: And then it will call the function getamount out to calculate the amount of token in that is needed. And it will be stored in amounts of N2. On the next iteration it will do the same thing. We know that the output amount that is needed is stored in amounts of N2. And given this amount we want to calculate the amount of tokenin that is needed. Call the function getamount n and then store the result inside amount of n minus 3. We keep looping this until we get to amount 0.
00:52:36.169 - 00:53:09.539, Speaker A: Once we know the amount out for the first pair, then we can calculate amount in for the first pair and store it in amount 0. So this is what's going on inside this for loop. Let's now take a look at the function getamount in. How does it calculate amount in given amount out and the token reserves. Okay, here's the function getamount in. Now recall from the swap math that we derived the equation for dynamic. And the way we derived it is by using this equation.
00:53:09.539 - 00:53:45.677, Speaker A: We set up an equation where it said that the l square after the swap must be equal to l squared before the swap. And then solving for dy, we got this equation. However, we can also solve for dx. And if you do the math, you'll get this equation. What I'm going to do here is check that this amount in numerator divided by denominator is equal to this equation. Okay? The numerator is reserve in times amount out multiplied by thousand. You'll say that token in is equal to x and token out is equal to y.
00:53:45.677 - 00:54:15.822, Speaker A: So reserve in will be x0 and amount out will be dy. Multiply this by 1000 denominator reserve out minus amount out. And then we multiply this by 997. So reserve out will be y0 minus dy. Multiply this whole expression by 997. Okay, let's now evaluate numerator divided by denominator. The numerator over here is x2 times dy times 1000.
00:54:15.822 - 00:54:46.425, Speaker A: How about the denominator? The denominator is y0 minus dy times 997. This is what we get when we evaluate this code. And this equation over here is what we expect this code to equal to. So let's double check. We have x 0 times dy, which we see over here. And we also have y 0 minus dy, which see over here. Now on this side we have one divided by one minus F.
00:54:46.425 - 00:55:23.549, Speaker A: So recall that one minus F is equal to 0.997. Well, when we evaluate this expression, you'll see that this is equal to 1000 divided by 997. So these two equations are equivalent. And that completes the code walkthrough for the function getamounting. The function getamounting Inside the library Uniswap B2 library is also a confusing function. So let's run through an example using actual numbers similar to what we did for the function getamount. What we'll do Is write a test in foundry and we'll call the function getamounts in on the router contract to fetch actual numbers.
00:55:23.549 - 00:55:53.635, Speaker A: Using that actual number, we'll come back to run through the code example. We'll continue writing our code inside the foundry test called Uniswap B2 Swap Amounts Test. Previously, this code contained the code to execute router getamountceout and then we console log the amounts. We'll do something similar and call the function router getamounts in and we'll write our test inside. Here test getamount in again. For the example, you'll use the same path. So wef MKR.
00:55:53.635 - 00:56:28.225, Speaker A: The function that we'll call is inside Uniswap B2 B2 periphery contracts Uniswap B2 router 02. And if we go all the way down, we have the function getamountsint. This is the function that we'll call. So copy the function signatures and then paste it here. So the function that we'll call is router getamount. You'll need to prepare these inputs amount out and path and it's going to return the array of uint. Okay, so let's prepare the input amount out and path.
00:56:28.225 - 00:57:23.039, Speaker A: Recall that the function getamountin will return the amount of token that needs to go in to get a specific amount of token out. The token out will be MKR and let's say we wanted exactly one MKR. So say uint 256amount out is equal to 1e18 calling getamount in will return amounts and this amount will contain the amount of die that we'll need to get one mkr and the amount of weft that we'll need to get this specific amount of die. Let's call this function amount out will be 1 MKR and the path will be with DIAMKR. Calling this function will return an array of unit unit 256 memory amount. Like what we did in this example above, we'll console logs. This should be uint.
00:57:23.039 - 00:58:11.487, Speaker A: Okay, let's run the test and see the output for calling this function inside my terminal. Again, the first thing that I'll do is set my fork URL as an environment variable. Here inside my env file I have the fork URL. So I'll copy this and then paste it inside my terminal. This will set the environment variable for qrl to this value, which is the URL that I got from Alchemy. Then again, we'll run the test forget for qrl for QRL set from above and the path of the test test uniswap B2 uniswap B2 swap amounts, test SOL and then BBB to see the console logs. Okay, so here is the output for calling the function test getamounts in.
00:58:11.487 - 00:59:00.109, Speaker A: I'm going to copy this and then paste it over to Unisoft B2 library contract inside the function getamounts in and we'll go through a code example using these actual numbers inside the contract uniswap b2 library we looking at the function getamountsin, I pasted the actual outputs of calling a function getamountin by running Foundry's mainnet fork. So these are the actual outputs. And let's go through an example of this code using these outputs. First, amounts will be initialized to a UINT array. For this example, we said that the length of the path will be 3 WEF MKR. So amounts will be initialized to a UINT array of all zeros having the length three. On the next step, it initializes the last element of this amounts array to amount out.
00:59:00.109 - 00:59:26.572, Speaker A: Amount out will be one MKR. So this will be 118. So after this part of the code, the UINT array amounts will look like this. 0010 1E18 okay, so next let's go through what happens inside the for loop. The for loop starts from I Equals path of length minus 1. The length of this path is 3. So length 3 minus 1 will be 2.
00:59:26.572 - 01:00:13.979, Speaker A: We start from I equals 2 and what does it do next? It's gonna Access path of I -1 and path of I. For I equals 2, path of I will be the last path will be which will be mkr and the one before that which will be die. Path of I minus 1 will be die amount of I will be the last element in the amounts array which will be 1e18. And then next it's going to call the function getamount in passing in amounts of I as input and then storing the result into amounted by minus one. Let's see what's going on here with the actual numbers. So for I equals to 2, amounts of I is 118. Use this as an input to the function getamount in and then store the output into amounts of I minus 1.
01:00:13.979 - 01:01:04.858, Speaker A: Amounts of I minus 1 will store this number approximately 2011 DAI. So what this is telling us is to get one MKR, we need approximately 2011 DAI. And after the execution of this iteration of the for loop for i2, the amount array will look like this starting from the last element, it will be 1e18amount of NKR and approximately 2011 die and the first element is still equal to zero. This stores the amount of weft that is needed to get 2011 die. And this amount will be calculated in the next iteration of the for loop. So next iteration will be i1. When I equals 1, we'll call the function getreserves again and we'll need to access path of I minus 1 and path of I.
01:01:04.858 - 01:01:45.858, Speaker A: For I equals 1, path of I will be die and one before that will be with amount I will store the output from the previous iteration. So amount of I equals 1 and what does amounts look like at this moment? It's going to look like this. For I equals 1, amount of 1 will be this number the amount of die that is needed to get one mki. So amount of I will be this. And then it's going to use this as an input to call the function getamount10 to calculate the amount of weft that is needed to get this much amount of die. And the function returns this. This is approximately 0.8
01:01:45.858 - 01:02:18.239, Speaker A: ref and the output is stored in amounts of I minus 1 I is equal to 1. So amounts of I minus 1 will be amounts of 0. And our final array of amounts will look like this 0.8 eth 2011 DAI and 1 MKR. So this was an example of getamounts in with actual numbers. We did a code walkthrough for the function swap exact tokens for tokens and the function Swap tokens for exact tokens. In both cases it calls an internal function called swap.
01:02:18.239 - 01:02:54.373, Speaker A: And if you scroll up, here's the internal function swap. And inside this for loop it calls another function called swap on the pair contract. The pair contract is located inside the B2 core repo under contracts Uniswap B2 pair contract. I'm going to open this Uniswap B2 pair Contract and scroll down and find the function called swap. So in this video I'm going to do a cold walkthrough of this function swap. As the name suggests, what this function will do is swap tokens. The pair contract manages two pairs of tokens and it is referred to as token zero and token one.
01:02:54.373 - 01:03:31.859, Speaker A: When this function is called, it will swap one of the tokens for the other token. Now the input is a Little bit interesting. Amount 0 out, amount 1 out, address 2 to send the token out to and some data. Notice that inside the input there is no input for amount of token that comes in the amount of token that comes in into this swap function is implied by taking the difference of the actual balance of the token and the internal balance of the token. I'll explain this more later. So moving on, the first thing it does is calls the function getreserves. Again, remember that reserves is the Internal Balance of Token 0 and Token 1.
01:03:31.859 - 01:04:04.905, Speaker A: Why would this contract keep an internal balance of tokens? Why can't they just query the balance of tokens by calling the function erc20 balanceof the reason is probably for security. Many things can go wrong when you rely directly on the actual balance of the tokens. For example, tokens can directly be sent into this contract. And this might mess up the price of tokens or the amount of tokens that come out from a swap. So this is probably why it keeps an internal balance inside this contract. So Reserve 0 and Reserve 1 are internal balance of tokens. Let's move on.
01:04:04.905 - 01:04:41.755, Speaker A: The next interesting code is inside here. Notice that it has our curly braces, and inside the curly braces there's a code. The first time I saw it, I didn't know what these curly braces were doing. It turns out that when you have too much variables declared inside a function, then the solidity contract will not compile. Inside the compilation error, you'll see something that says stack to deep error. By wrapping some of the code in between these curly braces, we can avoid this stack to deep error that comes from compiling the solidity contract. And the way it works is say that you have some variable that you declared.
01:04:41.755 - 01:05:19.027, Speaker A: If you know that this variable is only used inside here, then what you can do is wrap this whole thing inside the curly braces. And when this part of the code is done executing these two variables will be popped out of the stack. That's the general idea of how wrapping your code inside curly braces will allow you to suppress the stack to a deep error. Now, even with this trick, it might not work. And there are other tricks that you can also do to avoid Stack two deep. For example, you can put a lot of the variables inside a struct. Okay, I think that's enough info for stack 2 deep error and why this code is wrapped inside 2 curly braces.
01:05:19.027 - 01:06:18.695, Speaker A: Okay, let's move on. So notice that after some initial checks, the first thing that this pair contract does is transfer the token out by calling the internal function SafeTransfer. You might be surprised that this function does not transfer the token in before transferring out the token out. What this code over here does instead is it Transfers the token out first. So how does it pull in the token that's supposed to come in? Well, the token that's supposed to come in is directly sent over to this pair contract before this function swap is called. So recall inside the Uniswap B2 router 02 contract and if you scroll over here, for example inside swap exact tokens for tokens, it directly transfers the token in and then calls the internal function swap which will call the function swap on the pair contract. Inside the B2 pair contract, it doesn't call transfer from since it already assumes that the token in was already sent before the function swap was called.
01:06:18.695 - 01:07:03.915, Speaker A: So this is why you don't see a transfer from inside the function swap. Next it calls if data dot length data is this bytes over here? If this is greater than zero. So if this data is not empty, then it will assume that the receiver of this token now is a contract. And it will also assume that this contract has a function called uniswap b2 call and then call this function. This part of the code is a feature that is used for flash swaps which we will cover in a later video. Okay, so moving on, next it will query the balance of token zero and token one. Okay, moving on, the next part of the code is calculation of amount of token zero and amount of token one that came in.
01:07:03.915 - 01:07:43.905, Speaker A: The way it does this is a little bit tricky. So let me explain what's going on here. Let's start with the question, what is the actual balance of token zero at this moment? Well, it is balance zero, which we got by calling the function ERC20 on token zero, calling the function balance of balance of this contract. Okay, how about the Internal Balance of Token 0 inside this pair contract? The internal balance before is the value reserve zero and amount zero out. This is the input amount that was transferred out, which you can see over here. The input amount 0 out. And if amount 0 out was greater than 0, it transferred this token out.
01:07:43.905 - 01:08:16.703, Speaker A: So this is the actual balance. This is the new internal balance. So what this code is saying here is if the actual balance is greater than the new internal balance, then the difference must be the amount of token that came in. The difference will be the actual balance minus the new internal balance. This is how amount 0in and amount 1in is calculated. Let's go over a simple example of what this code is doing. Let's say that amount in is token 0 and amount out will be token 1.
01:08:16.703 - 01:08:54.701, Speaker A: And for the inputs, amount 0 out will be 0 and amount 1 out will be 100. Let's also say that before this swap function was called 10, token 0 was transferred directly into this contract. So this will be amount in amount in will be equal to 10 token 0. Let's also say that balance 0, the actual balance of token 0 is equal to 1010. And let's say that the reserve 0, reserve 0 will be equal to 1000. So the actual balance will be 1010. And reserve 0 will be the internal balance which will be 1000.
01:08:54.701 - 01:09:27.932, Speaker A: And the amount of token in that was sent we'll say is 10. So if we put this over here, this will be 1010. This value will be 1000 and amount 0 out. Amount 0 out is 0. So this will be minus 0 is 1010 greater than 1000 minus 0? Yes, it is. So we will calculate amount 10 by evaluating this part of the code. So this will be 1010 minus the internal balance 1000 minus the amount of token 0 that went out, which is 0.
01:09:27.932 - 01:10:13.483, Speaker A: So 0 10, 10, minus 1000, this will be equal to 10, which is the amount of tokens that we sent before we call this function swap. So this is an example of how these two part of the code calculate the amount of token that came in. Okay, let's move on. The code inside here checks the invariant that x times Y after the swap is greater than or equal to x times y before the swap. What I mean here is, let's say X0 and Y0 are amount of tokens inside this contract before the swap. What I'm trying to say here is X0 plus DX times 1 minus F. This is the amount of token that came in minus the fees times y 0 minus dy the amount of token Y before the swap minus the amount that went out.
01:10:13.483 - 01:10:58.196, Speaker A: So this is the L squared value after the swap must be greater than or equal to the L squared value before the swap. And this is what this protocol is doing. Let's double check. So Here we have balance 0 adjusted multiplied by balance 1 adjusted and then it multiplies reserve 0 and reserve 1 and then it multiplies by 1000 square. So what is this 1000 square doing over here? Let's start by looking at balance 0 adjusted. This is balance 0, the actual balance of token 0 times 1000 minus the amount of token 0 that came in multiplied by 3. This is balance 0 adjusted is equal to balance 0 times 1000 minus amount 0 in times 3.
01:10:58.196 - 01:11:59.017, Speaker A: If we divide both sides of this equation by 1000, we get that balance 0 adjusted divided by 1000 is balance 0 minus amount 0 in times 3 divided by 1000, 3 divided by 1000 is 0.003. So what this code is doing is it's getting the actual amount of token zero and then minusing the swap fee, which is exactly the same as this part of the code. So if we take balance 0 adjusted divided by 1000 that we see over here and multiply this by balance 1 adjusted divided by 1000, then we will get this part of the expression balance 0 adjusted times balance 1 adjusted divided by 1000 square. And if we multiply both side of this equation by 1000 square, then this will be equivalent to this part of the code. So what this part of the code is doing is checking this inequality. The X times y after the swap is greater than x times y before the swap. Okay, let's move on.
01:11:59.017 - 01:12:39.931, Speaker A: Let's look at the code for the internal function update. What this function does is it updates the internal balance, reserve zero and reserve one. And it also has some code that keeps track of two state variables called price zero cumulative last and price one cumulative last. These are state variables that are used for the time weighted average pricing, which we will discuss in another video. And that completes the code walkthrough for the function swap. As an exercise, I want you to write some code that will swap E for MKR using Uniswap B2. Here I've imported some interfaces and then I've initialized ref, die and mkr.
01:12:39.931 - 01:13:16.945, Speaker A: I've also initialized the interface for Uniswap B2 router and for this exercise we'll have a user that's given 100 ref. This user has already approved the Uniswap B2 router to spend all of its tokens. And inside here I want you to write a code where the user will swap his wef for mkr. The amount of wef that this user will send is 1 ETH. This user expects a minimum of 1 mkr. The function that you'll need to call is swapexactokens for tokens. Amount in will be the amount of tokenin.
01:13:16.945 - 01:13:46.339, Speaker A: Amount min will be the minimum amount of token that must come out. Path specifies the tokens that will be swapped. Here we'll need to swap from ref to die and then from die to MKR2 will be the address that's going to receive the MKR. This should be the user's address. And lastly, deadline is the last timestamp this swap is valid. This is used when a signature is involved. However, since we're sending it from a smart contract, you can Set this deadline to block that timestamp.
01:13:46.339 - 01:14:27.525, Speaker A: Okay, so I want you to simulate a transaction where the user is going to call the function swapexact tokens for tokens on Uniswap B2 router contract, the user is going to send in one with and expects minimum of one MKR out. Okay, let's go over the solution. So we said that we need to simulate a transaction by the user. So say BM prank user. This user is going to call the router contract which we can see over here. So here I'll say router and the function that we'll need to call is called swapexactokens for tokens. So I'll copy this and then paste it here.
01:14:27.525 - 01:14:54.933, Speaker A: Calling this function returns an array of uint. Let's assign this to a variable. The reason why I'm assigning this to a variable is that I'm going to console log all of the intermediate trades. Okay, let's fill in the inputs. Amount in. We said amount 10 will be 1 18, so we just use the variable from the top amount out min will be one path. What is path? Path I've already initialized over here.
01:14:54.933 - 01:15:44.899, Speaker A: And the path is it's going to take from reference to die and then from die to nkr for the two, we will send this over to the user. So the user will be the recipient of MKR and deadline deadline will be block dot timestamp. Now, when there are multiple inputs, it's kind of hard to understand what this code is doing. So instead of passing input as position arguments, what I'm going to do is pass it as key value arguments. So I'll put a curly basis here, then paste it here and then say amount in mountain amount out min Path to will be user and deadline will be blocked out timestamp. Okay, so this is a solution. But before we execute this test, I want to console log the amounts.
01:15:44.899 - 01:16:37.925, Speaker A: So we'll console log amount in with amount of die that we get for swapping ref to die and then the amount of MKR that this user gets for swapping from die to mkr. And lastly, it's going to check that the balance of MKR for the user is greater than or equal to amount help min. Okay, let's try running the test. We will run the test on mainnet fork. So first I'll declare a variable, declare a variable called fork URL and set it to an RPC that I got from Alchemy. Next I'll execute the test. So I'll type forge test dash dash fork URL fork URL match path dash dash match path test Uniswap B2 exercises Uniswap B2 swap test SOL and then we'll console log some logs.
01:16:37.925 - 01:17:13.849, Speaker A: So say bbb. Okay, and our test passed. We put in one ref, got some DAI back, and then from that DAI it was swapped over to Sumki. We looked at the function Swap exact tokens for tokens on Uniswap B2 contract. This function will try to swap all of your token in and then give as much as possible a token out. There's another function in Uniswap B2 contract called swap tokens for exact tokens. This function will try to spend the minimum amount of token in to give the user some amount that the user specified.
01:17:13.849 - 01:17:47.783, Speaker A: So if you look at the inputs, amount will be the amount of token that the user wants. Amount in max will be the maximum amount of token in that the user is willing to spend. Path will be the tokens. If we're only dealing with one pair contract, this path will contain address of the two tokens. If the swap involves two pair contracts, then this path will contain three token addresses. Two will be the receiver of the token out and deadline will be the last timestamp that this swap is valid. And this function will return amounts.
01:17:47.783 - 01:18:22.873, Speaker A: The first element of this array will contain the amount of token that went in, and the last element will contain the amount of token that was sent over to the to address. As an exercise, I want you to write some code that will call swap tokens for exact tokens. So here I have the exercise set up again. For this exercise, we'll swap from WEF to die and then from die to mkr. And we'll say that the amount of MKR that we want is 0.1 times 1 e18 MKR has 18 decimals. The amount of weft that we're willing to spend is one ref.
01:18:22.873 - 01:18:57.793, Speaker A: So here I want you to write a code that will simulate the user calling swap tokens for exact tokens. Okay, let's go over the solution. So we'll simulate a transaction that the user calls, so say BM prank user. Then we'll call the router contract router dot. The function that we're going to be calling is swap tokens for exact tokens. So copy this and then paste it here. We'll take this return value and then assign it to a variable called UN256.
01:18:57.793 - 01:19:31.781, Speaker A: Memory amount is equal to the output from calling swap tokens for exact tokens. Okay, let's fill in the inputs to make this code more understandable, I'm going to use the curly braces and then we'll put in the key value pairs for the inputs. So amount out. What is amount out? What do we want? We want 0.1 MKR. So amount out will be amount out amount in max. What is the maximum amount of weft that we're willing to spend to buy 0.1
01:19:31.781 - 01:20:01.115, Speaker A: mkr? Here we set one ref amount in max path. So this specifies both the tokens that come in and the token that comes out. Path will be path and the path that we're taking is from ref to die and then from DAI to mkr. Who is going to receive the mkr? The user. And the deadline for this swap, you'll set it to block that timestamp. Block dot timestamp. Okay, so this is a solution.
01:20:01.115 - 01:20:40.589, Speaker A: Furthermore, I want to console log the amounts. So we'll console log ref amount, die amount and MKR amount. Okay, so let's run the test as before. I'm going to set for URL to this RPC URL that I got from Alchemy and then we'll execute the same test again. Forge test, set the fork URL and the test file will be Uniswap B2 exercises Uniswap B2 swap test SOL and our test passed. Notice that here inside the logs we set, the maximum was 1 ref, but this number looks like less than 1 ref. For that amount we got some die.
01:20:40.589 - 01:21:15.471, Speaker A: And lastly, we said that we wanted 0.1 MKR, which we got over here. Let's say that there is a Uniswap B2AMM that holds two tokens. And if I were to ask this AMM, what are the prices of tokens, then what would the answer be? Well, it turns out the prices of the tokens are related to the slope of this orange line. Let's say that the current amount of tokens inside this AMM is this point over here. 154 for token X and approximately 259 for token Y. And this orange line is a line that passes through this point.
01:21:15.471 - 01:21:58.145, Speaker A: And it's also a line that touches this blue curve only in one place exactly at this point. In other words, this orange line is the tangent line to this blue curve. In this video, I'm going to explain why the slope of this orange line will give the prices of the two tokens. Imagine that we do a swap on this amm, we put in some token X and we get back some token Y. This will bring the amount of token X and amount of token Y from here to this point over here. For putting in this much amount of token X, we got back out this much amount of token Y. The slope of this red line is DY divided by DX and it will tell us the amount of token Y that we got for each DX that we put in.
01:21:58.145 - 01:22:51.329, Speaker A: In other words, the slope of this line will give us the exchange rate of token X to token Y. What I'm going to show you next is that as we make this DX smaller and smaller, the slope of this red line will approach the slope of this orange line. The current price of the two tokens are given by the slope of this orange line. If we know the slope of this orange line, then we can calculate the prices of the two tokens as the slope of this red line approaches the slope of this orange line. What this will mean is that we can get an estimate of the slope of this orange line by making the size of our trade smaller and smaller. So as I make the size of this trade smaller and smaller, you can see that the red line rotates and gets closer to the orange line. And when the size of the trade is zero, the orange line and the red line are an exact match.
01:22:51.329 - 01:23:45.383, Speaker A: So, in summary, a swap will give us DY and dx. DY divided by DX will give us the slope of this red line. As we make DX smaller and smaller, it will approach the slope of this orange line and this orange line will give us the current price of the two tokens. In the previous video, I used the graphing calculator to show you that the current price of the tokens are given by the slope of this orange line. The current price, also called a spot price, and in Uniswap B2 it's also referred to as the mid price. But is there an exact formula for this spot price? Well, it turns out that the spot price is a simple equation. The slope of this orange line which will give us the spot price is equal to minus y 0 divided by x 0, where y 0 is the amount of token Y in the amm and x0 is the amount of token next in the amm.
01:23:45.383 - 01:24:32.785, Speaker A: Divide the amount of token Y in the AMM by the amount of token next in the amm and this will give us the spot price of token next in terms of token y. Now, if you wanted the spot price of token Y in terms of token x, then all you have to do is flip this equation, bring x0 to the top and y0 to the bottom. I'LL give you a quick example. Let's say that Token X is ETH and X0 is 3000 ETH. Let's also say that token Y is DAI and there are 6 million DAI. Then the spot price will be 6 million DAISY divided by 3000 ETH and this will turn out to be 2000 DAI per ETH. In this video, I'll show you how to derive this equation that the slope of this orange line is equal to minus y 0 divided by x 2.
01:24:32.785 - 01:25:11.369, Speaker A: And the way we will derive this equation is exactly the same approach that we did in the graphing calculator. So let's say that we do a trade, put in DX and get out minus dynamic. The slope of this green line will give us the exchange rate of token X to token y. We put in DX amount of token x and we got back out DY amount of tokeny. If we take the ratio of DY divided by dx, this will tell us how much amount of token Y that we got for each DX that we put in. This is the execution price token received divided by token sent. This will be equal to minus DY divided by dx.
01:25:11.369 - 01:25:58.049, Speaker A: And this ratio is expressed in the slope of this green line. Now from the swap equation, we can rewrite DY DX in another way. Recall from a video about swap math that we derived that dy will be equal to dx times y 0 divided by x 0 plus dx. To get an equation for dy dx, all we have to do is divide both sides by dx. So this DX will come over to the left and we have the equation dy divided by dx will be equal to y 0 divided by x 0 plus dx. As we saw in the graphing calculator. Let's see what happens to this equation as we make the amount of trade smaller, make DX smaller and smaller, and let's see what happens to this equation.
01:25:58.049 - 01:26:53.005, Speaker A: So as we make DX smaller and smaller, we can see that this equation will approach y 0 divided by x 0. And when dx is equal to 0, we see that this equation will be equal to this equation. And we also saw in the graphing calculator that as DX got smaller, the slope of this green line approached the slope of the orange line. So we conclude that y0 divided by x0 will be equal to the negative of the slope of orange line. If it's a little bit confusing, to clarify a little bit more why this negative is here, I'm going to multiply this equation by minus 1 and remove the minus from the slope of orange line and we get this equation. Minus DY divided by DX will be the slope of this green line. And as dx approaches 0, this will approach negative y 0 divided by x 0 which is the slope of the orange line.
01:26:53.005 - 01:27:42.373, Speaker A: And from the slope of this orange line that we see over here, which is equal to minus y0 divided by x0, we can get the spot price of token X in terms of token y. In summary, what we found out here is that we can approximate the spot price y0 divided by x0 by doing a small trade for some small amount of dx. For some small amount of dx, y0 divided by x0 is approximately equal to dy divided by dx. We can take the same approach that we did here. Do a small swap to approximate the spot price to also approximate spot price for more complicated amm such as curb. But that will be a topic for another video. Oftentimes when you trade on an amm, the price that the AMM gives you is not the price that you'll get when the trade is executed.
01:27:42.373 - 01:28:11.523, Speaker A: This is called slippage. So in this video, I'll explain what slippage is and I'll explain the main cause of slow slippage. Slippage is the difference between the price you expect to receive versus what you actually receive. For example, let's say that you wanted to Swap dai for eth and you asked the amm. I want to put 2000 dai. How much eth can I get out of this? The AMM will give the answer one EV. So you put in 2000 Dai and the AMM calculated that it will give you back one EV.
01:28:11.523 - 01:28:35.031, Speaker A: In this case, the price of one eve will be 2000 daisy. 2000 dai per one YIF. This is the price you expect to receive according to the amm. At this current moment, let's calculate the actual price of EVE that you got after the swap. Amount sent will be 2,000 Dai. This amount is the same as before the swap. We wanted to send 2000 Dai and we actually did send 2000 Dai.
01:28:35.031 - 01:29:01.895, Speaker A: Okay, how about the amount of ETH that we received? Let's say that the amount of ETH that we received is 0.99 ETH. And here, for simplicity, let's assume that the swap fee is equal to zero before the swap AMM calculated that it can give us one eth back. However, when we actually executed the swap, we only got 0.99 ETH. And this 0.99 ETH is without any swap fees? Let's calculate the price of 1 ETH.
01:29:01.895 - 01:29:26.087, Speaker A: We sent 2000 DAI and we received 0.99 ETH. In this case, the price of 1 ETH is approximately 2020 DAI. So this is an example of a slippage. Before we executed the swap, the AMM told us that if we put in 2000 DAI, it can give us back one ETH. But when we actually executed the swap, it only gave us 0.99 ETH.
01:29:26.087 - 01:30:03.073, Speaker A: The difference between the price that we expect to receive and the actual price that we receive is slippage. What is the cause of slippage? The main cause of slippage is market movement and the fact that there is a time delay between the time you sent the transaction and the time the transaction is executed. Let me explain how market movement causes slippage. Here we have Alice and Bob, and here we have the AMM. Let's say that the AMM says that 1 eth is equal to 2000 Dai. If you send 2000 Dai into this AMM, it will be able to give you 1 eth. Both Alice and Bob sees that 1 eth is equal to 2000 Daisy.
01:30:03.073 - 01:30:44.155, Speaker A: So let's say that both of them send the same transaction to swap 2000 Dai for 1e around the same time. After their transactions are submitted, let's say that their transaction ordering will be Alice's transaction will be executed first and then Bob's transaction will be executed. So this ordering, let's say, was determined by the block builder. These two transactions can be in the same block, or it can be that Alice's transaction is in one block and then Bob's transaction is in another block after the block where Alice's transaction was included. It doesn't really matter. What we're concerned here with is the transaction ordering. Alice's transaction was executed first and then Bob's transaction was executed afterwards.
01:30:44.155 - 01:31:16.709, Speaker A: So Alice's transaction is executed first. As the AMM calculated, If you give 2000 Dai to this AMM, it can give you back 1 ETH. Alice's transaction is executed first, so she'll get 1 ETH. Now let's say that after Alice's transaction is executed, because the balance of the tokens inside this AMM are now different from before. Let's say that the AMN calculates that if you send 2000 Dai, it will give back 0.99 ETH. And now let's see what happens when Bob's transaction is executed.
01:31:16.709 - 01:31:41.675, Speaker A: So at this point, Bob still thinks that if he sends two dozen die, he'll get back one Ethnic. But what's actually gonna happen is the AMM is quoting that if you send 2000 DAI to the AMM, it will get back 0.99 ETH. Bob's transaction is executed and he gets back 0.99 ETH. So notice that Alice did not experience any slippage. She expected 1 ETH and she got 1 ETH.
01:31:41.675 - 01:32:09.599, Speaker A: However, Bob did experience a slippage. He also expected 1 ETH, but he only got 0.99 ETH. Okay, but why is it that Alice was able to get 1 eth for 2000 Dai, but Bob was only able to get 0.99 eth for 2000 Dai? Both of them sent 2000 Dai. But why did Bob receive less ETH than Alice? Well, this is because of the way AMM calculates the amount of token that goes out. So let's say that this is the AMM curve.
01:32:09.599 - 01:32:53.495, Speaker A: X times Y equals L squared on the Y axis, we'll say that this represents the amount of DAI in this amm. And on the X axis, we'll say that this represents the amount of ETH in this amm. So Alice's transaction is executed. First, let's say that the AMM before the swap had this much amount of dai in eth. And after putting in 2000 dai from Alice, this will move the DAI and ETH balance to over here on this curve. So this length in orange represents 2000 Daisy, and this Dai in blue represents 1 ETH. Next, Bob's transaction is executed, 2000 Dai comes in, and for this 2000 Dai, the balance of EVE must be here.
01:32:53.495 - 01:33:22.385, Speaker A: The difference will be the amount of ETH that he gets, 0.99 ETH. Notice that when Alice sent her 2000 DAI, the amount of ETH that she got is the length of this blue line. And the amount of ETH that Bob got is this blue line. And notice that this blue line is shorter than the amount of EEF that Alice got. What's happening here is that you'll get a diminishing return of the amount of beef that you'll get. Because of the way this AMM curve is curved.
01:33:22.385 - 01:33:50.457, Speaker A: The first 2000 Dai will give out 1 ETH, the next 2000 Dai, let's say only gave out 0.99 ETH, and then the next 2000 Dai will give less than 0.99. Let's say 0.98 ETH, and so on. And this is why Bob received less ETH than Alice, even though both of them sent 2,000 Dai. There are two ways to deploy Uniswap B2 pair contract. The first way is to call the contract Uniswap B2 router 02.
01:33:50.457 - 01:34:26.941, Speaker A: And the other way is to call the Uniswap B2 factory contract. Here we're inside Uniswap B2 Router 02 contract. And if you scroll down, you can see over here that when we call the function add liquidity, this will call internal function called add liquidity. And inside here it calls the function create pair on the factory contract. The factory contract is located inside B2 core under contracts and inside here unisoft B2 factory contract. In this video, I'll explain how the function create pair works. I'll explain what this function does, and I'll also explain the confusing parts in this code.
01:34:26.941 - 01:34:58.779, Speaker A: So let's begin. The function CreatePair inside the Uniswap B2 factory contract will deploy a Uniswap B2 pair contract. Remember that Uniswap B2 Pair contract is the contract that holds a pair of tokens and it will manage the swapping of tokens and adding and removing liquidity. The factory contract will deploy this Uniswap B2 pair contract. For the input we pass in token A and token B. And for the output, it will return the address of the pair contract that was deployed. First, it checks that token A and token B are not the same.
01:34:58.779 - 01:35:27.493, Speaker A: On the next line, it sorts token A and token B. If token A is less than token B, then it will return token A and token B. Otherwise it will return token B and token A. When I first looked at this code, I was curious how addresses are sorted. Well, it turns out that addresses are sorted as their numerical values. But how are addresses converted into numerical values? Addresses are 20 bytes of data that is encoded as hexadecimal. One byte is 8 bits.
01:35:27.493 - 01:36:00.405, Speaker A: So these 20 bytes can be converted into a 160 bit number. And we can also go the other way around. If we have a 160 bit number, we can convert it into 20 bytes of hexadecimal, and then we have an address. Now, whether this address that we converted from a 160 bit number is a valid address or not is another story. So, for example, here we have an address, and if we converted this into a number, we get this number over here on the right. And we can also go the other way around. If we have this number, we can convert it into this address.
01:36:00.405 - 01:36:34.167, Speaker A: So addresses can be converted into numbers and numbers can be converted into addresses. And now we can understand how the addresses are sorted. They're converted to numbers and then they're sorted just as regular numbers. The smaller of the address will be assigned token zero and the bigger address will be assigned token one. We check that token zero is not equal to address zero. And we also checked that Uniswap B2 pair contract that is associated with token zero and token one have never been deployed yet. Once they are deployed, they will be registered into this mapping called get pair.
01:36:34.167 - 01:37:10.390, Speaker A: Next it gets the creation code of Uniswap B2 pair contract. What is creation code? The quick explanation of what creation code is is that it is the runtime code plus constructor arguments. The runtime code is the smart contract code that is compiled down into bytecode and it is the code that is executed when you send transactions. Creation code will be this runtime code plus constructor arguments. And what do we use this bytecode for? Well, take a look at here. Inside the assembly block. It calls a function called CreateTo and then uses the bytecode of Uniswap B2 Pair Contract.
01:37:10.390 - 01:37:46.207, Speaker A: What it's doing here is it's deploying the Uniswap B2 Pair contract using CreateTo. And why is it using CreateTo to deploy a contract here? Well, it's because CreateTo allows us to easily calculate the address of the contract before it is deployed. The way it calculates it is over here. It takes Kechak 256 of 0xff, the address of the deployer and some random bytes 32. This is usually called a salt. And it also takes the hash of the creation bytecode. This creation bytecode is the bytecode that we see over here.
01:37:46.207 - 01:38:41.863, Speaker A: So now we understand that this bytecode is used to deploy the Unisoft B2 pair contract using Create 2. And also notice that here we said it takes the catch Act 256 of the creation bytecode. And we also said that the creation bytecode is the runtime code plus the constructor arguments. In other words, the create2 address is dependent on the catch256 of the creation bytecode, and the creation bytecode changes if we change the constructor argument. Uniswap B2 pair contracts are designed so that we can calculate the address of the pair contract whether the pair contract is actually deployed or not, just by looking at the address of the factory contract token zero and token one addresses. In other words, there is no constructor argument when we deploy Uniswap B2 pair contract. And we can see this if you go to the Uniswap B2 pair contract and then inside the constructor, you can see that it doesn't take any arguments.
01:38:41.863 - 01:39:29.603, Speaker A: Okay, but if it doesn't take any constructor arguments, then how are parameters like token zero and token one set? Let's go back to the factory contract and scroll down. So once it deploys the pair contract using create to, and again here it doesn't take any constructor arguments. So at this point token 0 and token 1 are not set to set the address of token 0 and token 1. Next, it calls the function initialize, passing in token 0 and token 1. So let's check this code out for the function initialize inside uniswap B2 pair contract. Here is the function initialize further input, it takes in token 0 and token 1, and then the state variables token 0 and token 1 are set from the input. What's going on here is that Uniswap B2 pair contracts are deployed using Create2.
01:39:29.603 - 01:40:35.001, Speaker A: If we pass in some kind of argument into the constructor, then the address of the Uniswap B2 pair contract will be dependent on the parameters that we pass into the constructor. To avoid this, and to make sure that the Uniswap B2 pair contract is only dependent on token 0 and token 1, that it can be calculated from token 0 and token 1, for the constructor argument, it passes nothing. To make sure that the address computed from create 2 is only dependent on token 0 and token 1, and then to do some setup that is usually inside the constructor, it will call a function called initialize. So this is how the factory contract is able to Deploy the Unisoft B2 Pair contract using Create 2, which only depends on the address of token 0 and token 1. And then afterwards call some setup functions by calling the function initialize. Once uniswap B2 pair contract is initialized, it will store this address of the pair contract in the get pair mapping and it will store the Same address for token 0 and token 1 and token 1 and token 0. They are associated to the same pair contract.
01:40:35.001 - 01:41:13.759, Speaker A: And that completes the code walkthrough for the function createpair. As an exercise, I want you to deploy a pair contract using the Uniswap V2 factory contract. The tokens to use are the token that is deployed here and WEF. So here I've deployed a new ERC20 contract called Token. And the other token that I want you to use is the WEF contract, which is imported here inside the test contract. The contract for ref and the factory contract are initialized. So all you have to do Is call the function on Uniswap B2 factory contract, call the function createpair and then pass in the token and refcontract.
01:41:13.759 - 01:41:50.037, Speaker A: Calling this function will return the address of the pair contract that was just deployed. Write your code to deploy the pair contract on this line and don't change the rest of the code. Okay, let's go over the solution. So I'll type address pair is equal to call the contract factory and then the function that we will need to call is create pair passing in address of the two tokens, say create pair. Here the ordering of the tokens that we pass in does not matter. So I'll type address token. This is the token that is deployed here.
01:41:50.037 - 01:42:25.453, Speaker A: And the other token will be ref. Okay, calling this function will deploy a new Uniswap B2 pair contract and it's going to return the address of the pair contract. The rest of the code will check that token 0 and token 1 are address of token and ref or ref and address of token. Over here we're saying if address of token is less than the address Of Ref, then token 0 must be address of token and token 1 must be the address of ref. Otherwise the address of token is greater than ref. So we check that token 0 is ref and token 1 is the address of the token. Okay, let's run this test.
01:42:25.453 - 01:43:15.417, Speaker A: I'm going to copy the fork URL from my env file. This is the RPC URL that we'll use to run the test on mainnet fork inside my terminal. I'll paste the fork URL and then we'll execute the test by typing forge test. Fork URL is the fork URL that I've set above fork URL and then the path of the test match path test. Uniswap B2 exercises Uniswap B2 factory test solution and then we'll execute the test end our test passed. In Uniswap B2, users can deposit two tokens into the Uniswap B2 pair contract to become liquidity providers. The tokens that these liquidity providers provided will be used for swaps.
01:43:15.417 - 01:44:06.375, Speaker A: Swaps collect fees and later these fees can be claimed by the liquidity provider. When liquidity providers add liquidity to the Uniswap B2 pair contract, how will we measure the amount of liquidity that they provided and how much shares should the Uniswap B2 Pair Contract Mint to the liquidity provider? Also, when the liquidity provider removes liquidity, how much tokens should the AMM give back to the liquidity provider. To answer these questions, first I'm going to step back and make this problem into a simpler problem. Imagine a case where we have a smart contract that accepts a single token. Users will be able to deposit this token into this smart contract. Over time, the smart contract will increase the amount of tokens locked in this smart contract. For example, this smart contract may take user's deposit and then invest it into another DEFI protocol.
01:44:06.375 - 01:44:55.519, Speaker A: Or it might lend out the user's deposit to some other users and then collect interest. Here we'll keep it simple and just assume that the amount of tokens locked in the smart contract increases over time. And now I want to answer two questions. When a user deposits token into this pool contract, how many shares should the pull contract mint to the user? And the other question is, when the user decides to burn the shares to get back some token, how many tokens should this user receive? Now what makes this problem difficult to answer is that the number of tokens locked in this pool is always changing. This will change when a user deposits and when a user withdraws. And also when the pool makes some kind of profit which will increase the amount of tokens locked in the pool contract. So there are two moving parts to this problem that makes the answer not so obvious.
01:44:55.519 - 01:45:27.271, Speaker A: But the answer to our questions will be two simple equations. I'll start by explaining what this smart contract does and what the users can do. So we have a smart contract that accepts a single token. Let's say USDC Users deposit USDC into this smart contract. This smart contract will take user's deposit, invest it into another smart contract to earn some yield and then split the profit between the depositors. So let's say user 1 deposits 300 USDC. Let's say that this user gets back 300 shares.
01:45:27.271 - 01:46:04.717, Speaker A: User 2 deposits 500 USDC and gets back 500 shares. User 3 deposits 200 USDC and gets back 200 shares. At this moment there are 1000 USDC locked in this port contract and the amount of shares. The total amount of shares will be 300 plus 500 plus 200 which will be 1000 shares. So one share will equal one USDC. At this moment, if a user gives back one share, they'll get back one USDC. Let's say that this smart contract took this 1000 USDC and invested into another DEFI protocol and over time it made a profit.
01:46:04.717 - 01:46:29.591, Speaker A: And now the USDC balance locked in the spool contract let's say is equal to 1100 USDC. Let's do a quick math. So we have 1000 shares and there are 1100 USDC. So if a user gives back one share, they'll be able to get back 1.1 USDC. Let's introduce another depositor. Let's say that this user deposited 110usdc.
01:46:29.591 - 01:47:19.801, Speaker A: So now the amount of token locked in this pool contract is is the previous 1100 plus the 110 that was deposited by this user. So it will be 1,210 USDC. Now the question that I want to answer is how many shares to mint to this user who deposited 110 USDC? When the amount of tokens locked in the sport contract matched the amount of tokens that were deposited by the users? The math was easy. It was one share for one deposit. When a user deposited one usdc, they got back one share. However, the amount of shares to mint to a depositor becomes less obvious when the amount of token locked inside the pool contract does not match the amount deposited by all users. So Here we have 1,100 USDC and a user deposits 110 USDC.
01:47:19.801 - 01:47:52.755, Speaker A: And the amount of shares to mint to this user is not so clear. But it turns out that the amount of shares to mint to this user can be calculated by using this equation. S will be the amount of shares to mint to this user. T will be the amount of current total shares. L1 will be the amount of tokens after the user deposits and L0 will be the amount of tokens before the user deposits. When a user deposits USDC into this pool contract, the amount of shares to mint to this user is given by this equation. Let's see how we would derive this equation.
01:47:52.755 - 01:48:25.449, Speaker A: Okay, let's start by defining the variables. We'll say capital T is equal to total shares. The current total shares S will be equal to the shares to mint L0. We'll define it to be the value of pool before the user deposits and L1 will be the value of pool after the user deposits. Notice here that I didn't say the balance of tokens locked inside the pool here. I made it a little bit big by saying value of the pool. The reason why I'm saying this is because for Uniswap B2 pair contract, there are several ways to measure the value of pool.
01:48:25.449 - 01:49:00.128, Speaker A: For one, we can measure the value of the pool for a Uniswap B2 pair contract by saying that the value of pool is equal to the balance of token locked inside the Uniswap B2 pair contract. And there are other ways to Measure the value of a pool for a Uniswap B2 pair contract. I'm being a little bit vague by saying value of pool. But for the math that we're going to derive, you can think about the value of pool as being the balance of tokens locked in the pool. Contract. To solve for S the amount of shares to mint, we'll set up an equation. We'll say that the amount of shares to mint should be proportional to the increase of L0 to L1.
01:49:00.128 - 01:49:36.243, Speaker A: In other words, whatever percentage we increase from L0 to L1, that should be the amount of shares that we're going to mint. Okay, so let's start by setting up this equation. How can we express using math increase of L0 to L1? Well, we can say L1 divided by L0. This will give us the increase from L0 to L1. Okay. How would we express the amount of shares to mint proportional to increase of L0 to L1? This equation will express the increase in shares before it was T. Afterwards it should be T plus the amount of shares to mint.
01:49:36.243 - 01:50:08.303, Speaker A: And here we're saying these two should be proportional. The increase in L0 to L1 should be equal to the increase from T to T s. And here we'll assume that T total shares is greater than 0. Here I'll mention that when t is equal to 0, the amount of shares to mint is equal to the amount of tokens that was deposited. We saw this in the previous video. The first user deposited 300 USDC and he got back 300 shares. Okay, with this equation we can now solve for S.
01:50:08.303 - 01:50:40.607, Speaker A: Let's start by copying this equation to over here. And our goal is to solve for S. First I can bring the T over to the right by multiplying both side of the equation by T. And then I can bring this T over here by subtracting both side of the equation by T. Next, I'm going to clean up the right side of this equation to get that S is equal to l1 minus l0 divided by l0 times t. So this is the equation that we'll use to calculate the amount of shares to mint when a user deposits. Let's take a look at an example.
01:50:40.607 - 01:51:13.473, Speaker A: Let's say that the value of pool before a deposit is made is 1,100 USDC. Here we're measuring the value of pool by the amount of token. The amount of USDC that is inside this pool contract. So l0 will be 1100 USDC. Let's say that a deposit of 110 USDC was made. So now l1 will be 1210 the previous 1100 USDC plus the 110 USDC that was deposited. The portion of this pie that is colored in purple will represent L0.
01:51:13.473 - 01:51:47.227, Speaker A: And the portion of this pie that is colored in green will be the amount of tokens that came in L1 minus L0 L1 is 1210. L0 is 1100. So L1 minus L0 will be 1210 minus 1100 which will be equal to 110. 110 USDC came in. The value of the pool increased by 10%. So we want to increase the amount of shares to mint also by 10%. Let's say that there are 1,000 total shares before the deposit.
01:51:47.227 - 01:52:15.009, Speaker A: After the deposit, we'll mint S shares. And we want T s to be 110% of t. So what is the amount of S that this pool will have to mint? Well, we need to plug in numbers into this equation. Let's start with total Shares. Total shares is 1000. Okay, how about L0? L0 is 1100 USDC. How about L1 minus L0? This will be the amount of USDC that was deposited.
01:52:15.009 - 01:52:47.715, Speaker A: Okay, and now we're ready to calculate S. S turns out to be 1001000 shares before plus the amount of shares that we'll have to mint 100. So T +S will be equal to 1100 shares. Pool contract has 1210 USDC and it has issued 1100 total shares. User 1 deposited 300 USDC and got back 300 shares. User 2 deposited 500 USDC and got back 500 shares. User 3 deposited 200 USDC and got back 200 shares.
01:52:47.715 - 01:53:29.717, Speaker A: And finally user 4 put in 100 and 10 USDC and got back 100 shares. Next, user 1 burns 100 shares. So the total shares is now 1000. And how much of USDC should this pool give back to user4? Next, user3 decides to claim its USDC. So he burns his 200 shares. The total shares will go from 1000 down to 800. And again, how much USDC should the pool give back to user3? How many USDC should user4 receive for burning 100 shares? And how many USDC should user3 receive for burning 200 shares? The answer is given by this equation.
01:53:29.717 - 01:54:13.175, Speaker A: The amount of USDC to receive will be the shares that is burnt divided by the total shares times the amount of token locked in the pool contract. This equation tells us how many USDC the user will receive for burning S amount of shares. Let's See how we would derive this equation. We'll let T be equal to the total shares, S equal to the shares to burn, l0 the value pool before the token is sent back to the user, and L1 the value pool after the token is sent to the user. Again, I'm being a little bit vague here by saying value of pool. There are several ways to define a value of pool for a Uniswap B2 pair contract. But for this example you can think about the value of pool being the amount of tokens inside the pool contract.
01:54:13.175 - 01:54:51.931, Speaker A: Similar to the math for minting pool shares, here we'll say that the decrease from L0 to L1 should be proportional to the decrease of shares. For example, if burning S shares decreases the total shares by 10%, then L0 to L1 should also decrease by 10%. The decrease in shares is expressed by this equation. The total shares after burning S shares will be T S. The total shares before burning will be T. So T s divided by T will be the ratio of total shares after and total shares before. This ratio will tell us how much total share has decreased.
01:54:51.931 - 01:55:24.873, Speaker A: And we want this to be equal to L1 over L0, the value of the pool after tokens are withdrawn and value of pool before tokens are withdrawn. Okay, to find out the amount of tokens to send back to the user, we'll take the difference of the value of the pool. So this will be L0L1. This will give us the amount of tokens to send back to the user. So let's solve for L0L1. First I'll copy this equation over to the right over here. And then to solve for L1, I'll bring this L0 over to the left.
01:55:24.873 - 01:55:53.915, Speaker A: And then next expand this left side of the equation. So this will be equal to l 0 times t - l 0 times s divided by T. We can split the fraction into two parts. The T's cancel out for the first term. And then next I'll bring this over to the right and then bring this over to the left. And then we have our final equation. L0 minus L1 is equal to L0 times s divided by T.
01:55:53.915 - 01:56:36.090, Speaker A: Rearranging this, this is equal to S divided by t times l 0. And this equation tells us that the value of pool before and after withdrawing this is L0 minus L1 is equal to the percentage of shares that we're burning. This will be S divided by T times the value of the pool before the tokens are withdrawn. This is L0. And now we can use this equation to calculate the amount of USDC that the user will receive for burning S shares. Let's go over an example of the amount of USDC that a user will receive for burning S shares. Let's say that the total share is equal to 1100 and the amount of share that we're burning is 100 shares.
01:56:36.090 - 01:57:20.681, Speaker A: Burning 100 shares, the total shares will be 1000. From total shares equal to 1100 to total shares equal to 1000, this is a decrease of 9%. We require that this 9% of decrease of share should be reflected in the 9% decrease of the amount of tokens in the pool. So before burning the shares, the pool had 1,210 USDC and the amount of USDC inside this pool contract should decrease by 9%. And the difference in the amount of tokens in the pool before decrease and after decrease will be the amount of tokens that is sent to the user. This is expressed as L0 L1. To solve for L0 L1 we apply this equation.
01:57:20.681 - 01:57:55.095, Speaker A: L0 minus L1 is equal to S divided by T times L0. S is the amount of shares to burn, T is the Total shares and L0 is the value of the pool before the tokens are withdrawn. In our case, this value of the pool is equal to the amount of tokens inside this pool contract. Okay, let's plug in numbers into this equation and calculate L0 minus L1. Okay, what is L0? L0 is the amount of token inside the pool contract. This is1210. How about S? S is the amount of shares that is being burnt.
01:57:55.095 - 01:58:24.324, Speaker A: This is 100. And how about total shares before the shares are burnt? This is 1,100. This turns out to be 110. So L0 minus L1 is 110. By burning 100 shares, the total shares decrease by 9%. Further pull to decrease by 9% from 1210, we'll need to withdraw 110 USDC. This 110 USDC is given back to the user.
01:58:24.324 - 01:59:20.591, Speaker A: If we -110 USDC from 1210 the pool will have 1100USDC after the token is withdrawn to the user. When you add liquidity to Uniswap B2 you can add an arbitrary amount of tokens. If you wanted to provide some amount of token next, then there is an equation that tells us how much token Y that we must also provide. And likewise, if we wanted to provide some amount of token Y, then using the equation it will tell us how much token next. That we must also provide this equation to calculate the amount of token next and amount of token Y that is needed to provide liquidity is based on an equation that says that the price of the AMM before adding liquidity and after adding liquidity must be the same. In this video, I want to visually explain what it means for the price of the AMM to be the same before adding liquidity and after adding liquidity. So let's say that we have a constant product amm, X times Y equals L square, where L is equal to 100.
01:59:20.591 - 02:00:19.647, Speaker A: If we add liquidity to this AMM curve, then this will shift the curve over to the top right? And you can also notice that as we add more liquidity, the curve becomes more flat. So what does it mean that the price of the AMM before adding liquidity must be equal to the price after adding liquidity? Let's say that before adding liquidity, the amount of tokens inside this AMM is described. By this point, we will have some amount of token X and we will have some amount of token Y. And remember from the video about the spot price of a constant product AMM that the spot price of token X in terms of token Y is simply given by the ratio of the tokens Y divided by X. And when we calculate Y divided by X in this case, it will give us that the price is equal to 0.4. Okay, so let's say that we add liquidity and then we get this new purple curve. On this curve, the amount of token X and amount of token Y where the price is equal to 0.4
02:00:19.647 - 02:00:57.301, Speaker A: will be here. So if the current price was equal to 0.4 and if we added liquidity, then the amount of token X then the amount of token Y must be over here. You'll need to add some amount of token X and some amount of token Y so that starting from here, the amount of tokens will end up being over here. Okay, so the question is how much token X do we need to add and how much token Y do we need to add so that starting from here, we'll end up at this point. To answer this question, let's take a step back. Earlier I mentioned that the price of the AMM before adding liquidity must be equal to the price of the AMM after adding liquidity.
02:00:57.301 - 02:01:45.435, Speaker A: And we also know that the spot price of a constant product AMM is simply given by Y divided by X. This will give the spot price of token X in terms of token Y. Another way to state that the price of the AMM before and after adding liquidity is the same is to say that the ratio of tokens before adding liquidity and after adding liquidity must be the same. If I draw a straight line from the origin to this blue point that describes the amount of tokens inside the AMM before adding liquidity, this slope is exactly equal to Y divided by X. If we draw a straight line from the origin to this point, this ratio must also be the same to the screen slope. I drew an orange line from the origin to this point over here. Notice that the slope of this orange line is the same as the slope of the green line.
02:01:45.435 - 02:02:49.153, Speaker A: What this visually tells us is that if we were to add liquidity, then the resulting amount of token X and token Y in the pool must be along this orange line. And to show you this, as I decrease liquidity, you can see that the purple point stays on top of the orange line. And if I increase liquidity, you can also see that the purple point stays on the orange line again. So one way to think about on the constraint of amount of tokens to add when we're adding liquidity is that the resulting amount of token X and tokeny must be along this line. And the straight line is constructed simply by drawing a line from the origin to the point that describes the current amount of token next and token Y following this straight line. This will tell us how much token next and how much token Y we'll need to add. For example, when price is equal to one, and if you wanted to increase liquidity from this blue curve to this purple curve, and let's also say that we know that the amount of token X that we want to add is 280.
02:02:49.153 - 02:03:43.135, Speaker A: Then to get from here to here, then we'll need to add the same amount of token Y as the amount of token x dx is equal to 280, so dy must also be equal to 280. If the price was a little bit higher, then to get from here to here, and if you were to add some amount of token x197, then we'll need to add more of token Y than token X. Here we added 197 token X. And for the point to go from here to here, we'll need to add 395amount of token Y. And lastly, if the price was less than 1, then we'll need to add more token X than tokeny. And you can see visually that the amount of token X that we'll need to add is more than the amount of token Y that we'll need to add. So in summary, when we add liquidity to a constant product AMM such as Uniswap, the amount of tokens to add is determined by following this orange line.
02:03:43.135 - 02:04:44.073, Speaker A: And the resulting amount of tokens must be on this orange line. Let's derive the exact equation for the amount of token X and amount of token Y that is needed when we add liquidity. Lets say we added some amount of token X and token Y, DX and dy. What are the constraints that we'll need to follow? For example, if I wanted to add DX amount of token X, then how much amount of token Y will I need to add? And likewise, if I knew the amount of token Y that I wanted to add dy, then how much DX would I need to provide? In this video, we'll derive that when we add liquidity, the amount of token Y to add and the amount of token X to add must Follow this equation. Y0 is the amount of token Y before adding liquidity and x0 is the amount of token X before adding liquidity. This ratio, y0 divided by x0 must be equal to the amount of token Y that we add over the amount of token X that we add. Okay, so let's see how we would derive this equation.
02:04:44.073 - 02:05:49.573, Speaker A: As a quick review, we saw in the previous video that when we added liquidity, the prices after adding liquidity must be equal to the price before adding liquidity. And one simple way to remember this is that if we draw a straight line from the origin to the current amount of tokens in the AMM and then keep extending this line, then the new amount of token X and the new amount of token Y must also be on this line. For example, if we start out with x 0amount of token x and y 0amount of token Y, then the resulting amount of token in the pool must be a point on this straight line. So if you know that we wanted to add some amount of token X, then the amount of Y that we can add must be amount such that it will be on this line. We saw in the example of the graphing calculator that when we followed this rule, the price before adding liquidity and the price after adding liquidity was the same. Let's put this into an equation that the price after adding liquidity is equal to the price before adding liquidity. Y0 divided by x0 describes the price before adding liquidity.
02:05:49.573 - 02:06:17.269, Speaker A: Again, as a reminder, the spot price of a constant product AMM is a simple equation. Y0 divided by X0. So this is the price before adding liquidity. And the price after adding liquidity is also a simple equation. We just take the amount of tokens and then divide them. So the price after adding liquidity will be y0. This will be the previous balance plus some amount of dy over x0 plus the amount of token X that we're going to be adding.
02:06:17.269 - 02:06:54.327, Speaker A: Price after adding liquidity must be equal to the price before adding liquidity. And now if we simplify this equation, we'll get this equation. Okay, to get this equation, what I'm going to do is copy this equation and then I'll bring over the x0 over to the left and x0 plus dx over to the right. We will get this equation. And the next thing that I'm going to do is expand both sides of the equation. So on the left side it will be x 0 times y 0 plus x 0 times dy. And on the right side I'll have y 0 times x 0 plus y 0 times dx.
02:06:54.327 - 02:07:43.391, Speaker A: The x 0 y 0 cancels out with the y 0 x 0 on the right and we're left with x 0 times dy is equal to y 0 times dx. And lastly, I can bring this x 0 over here to the right side and dx over to the left side. And finally we get that dy divided by dx is equal to y0 divided by x0. This tells us that when we add liquidity, the amount of tokens that we add must follow this equation. The amount of token Y that we add DY divided by the amount of token that we add DX must be equal to the spot price, which will be y0 divided by x0. Now I want to combine two of the equations that we've been working on. One was about the pool shares, amount of pool shares to mint for providing some amount of value to a pool.
02:07:43.391 - 02:08:33.923, Speaker A: And we also derived that when we add liquidity to a constant product amm, the ratio of amount of tokens that we provide DY divided by DX must be equal to the spot price. So now I want to combine these two equations to derive the amount of shares to mint when we provide some amount of token X and some amount of token Y. So let's say S is the shares to mint and T is the total shares. And L1 is equal to liquidity after liquidity after providing liquidity. And L0 is liquidity before adding liquidity. Recall in the video about pool shares that we defined L1 to be the value of the pool after Adding some amount of token and L0 was the value of the pool before adding tokens. Here we're replacing the value of the pool by saying liquidity after and liquidity before.
02:08:33.923 - 02:09:10.181, Speaker A: We derive that the amount of shares to mint is equal to L1 minus L0 divided by L0 times t. Over the next few videos, I'll explain how to derive that. This L1 minus L0 divided by L0 is simply equal to dx divided by x0 and it's also equal to dy divided by y0. Here I have not exactly defined what liquidity is. We'll come back to this in a later video. Here. What this equation is saying is that the increase in liquidity must be equal to dx, the amount of token next that we provide divided by the amount of token next in the amm.
02:09:10.181 - 02:10:06.331, Speaker A: And this is also equal to dy, the amount of token Y that we will provide divided by the amount of token Y in the amm. Once we derive this equation, we can put this back into this equation and get that the amount of shares to mint S is equal to dx divided by x 0 times t and it is also equal to dy divided by y 0 times t. And this equation will tell us the amount of shares to mint for providing dx and dy amount of token to the Uniswap B2 pair contract. In the previous video I mentioned that L1 minus L0 over L0 is equal to dx divided by x0, which is also equal to dy divided by y0. We have not derived this equation yet. And furthermore, I also have not defined what L0 and L1 are. All I said was L1 is liquidity after adding dx and dy amount of token as liquidity and L0 is liquidity.
02:10:06.331 - 02:10:38.029, Speaker A: Before adding these tokens, I came up with three ways to define liquidity so that this equation is true. So we'll define a function to measure pool value. We'll say this is F and it's going to take in two inputs, the amount of token X and the amount of token Y in the amm. And it's going to output a single number. Let's call this L. This L that you see over here is the same L that you see over here. One way to define this function F is to say F of X and Y is equal to the square root of X times Y.
02:10:38.029 - 02:11:11.909, Speaker A: In other words, the geometric mean of X and Y. Another way that I found out that we can measure the pull value is to define F of XY to be equal to 2 times X. And the last way is to define it as 2 times y. I'll explain in the later videos how I came up with these functions. When we define liquidity in any of these ways, then this equation will be true. Let's define a function that measures the value of the pool as the following. This function takes in the amount of tokens in the bowl X and Y, and it takes the square root of X times Y.
02:11:11.909 - 02:12:02.467, Speaker A: What is the motivation for saying that the value of a constant product AMM is the square root of X times y? Well, let's start with the equation X times Y equals L squared. If we take the square root of both sides, then we get that the square root of x times Y equals L. And we saw in the example of graphing calculator that this single value L determines how big the curve was. When L was small, the curve X times Y equals L squared looked like the letter L with a rounded corner. As we increased the value of L, the curve became more flat like a straight line. With that said, let's now derive the equation that L1 minus L0 over L0 is equal to DX divided by X2. Okay, what is L1? We said that L1 is liquidity after adding liquidity after adding DX and DY amount of tokens.
02:12:02.467 - 02:12:31.549, Speaker A: So this will be equal to this function F. And inside. Here we plug in the amount of tokens after adding liquidity. The amount of token next after adding liquidity will be x0 + dx and the amount of token y will be y0 + dy. Okay, how about l0? We defined l0 to be the liquidity before adding these tokens dx and dynamic. So this will be simply f of x0 and y0. And then we'll need to divide this by l0.
02:12:31.549 - 02:13:08.879, Speaker A: Okay, we can expand this equation by simply applying the definition that F of XY is equal to the square root of x times y. And we get this equation. Recall that we said that dy divided by dx when we're adding liquidity must be equal to y0 divided by x0. The ratio of tokens to add must be equal to the spot price. Using this equation, we can solve for DY and then replace this DY over here. Replacing this dy, we get this equation. Next, I'll simplify this equation by multiplying both the top and the bottom by the square root of x2 and we'll get something simpler.
02:13:08.879 - 02:13:35.581, Speaker A: Notice that inside the first term we have x0 plus dx times x0. Plus dx followed by y0. The second term is x0 divided by the square root of y0. And the term on the bottom is x0 times square root of y0. Here we have a multiplication of x0 plus dx by itself. There are two of these terms and they're inside a square root. So we can simplify this part of the term.
02:13:35.581 - 02:14:46.201, Speaker A: So this part simply becomes x0 +dx, and then the rest of the terms are the same. And now we have x0 times the square root of y0 minus x0 times the square root of Y0. These two terms cancel out and we're left with dx times the square root of y0 over x0 divided by the square root of y0. The square root of y0's both on top and bottom cancel out, and we're left with DX divided by X2. So what I showed you in this video is that when we define the value of a pole to be equal to f of xy equal to the square root of xy, and then when we evaluated this expression l1 minus l0 over l0, then we got that this is equal to this dx divided by x0. Now once we have this, we can also use this equation to get that this term is also equal to dy divided by y 0. The other way to define the value of the pool is to say that the function F which will take in the amount of tokens in the pool X and Y and set this equal to 2 times x, 2 times the balance of token X in the pool.
02:14:46.201 - 02:15:21.273, Speaker A: What we're trying to measure here is the amount of token X in the AMM and the amount of token Y in the pool when we convert it into terms of token X. For example, let's say that we have an AMM with 6 million DAI and 3000 ETH. We will measure the value of this pool in terms of Dai by first saying X0. This is the amount of Dai in this pool plus Y0. Now, Y0 is the amount of beef in this pool. So we will somehow need to convert this number in terms of die. We call that the spot price of token X in terms of token Y is equal to y divided by x.
02:15:21.273 - 02:15:56.473, Speaker A: So if we flip this around, X divided by Y will be the spot price of token Y in terms of token x. And now we can use this to convert this y0 in terms of token x. We multiply y0 by the spot price of y0 and this expression will convert y0 in terms of tokennex. The y0 here and the y0 on the bottom cancel out. And this turns out to be 2 times x 0. So this is the motivation for saying that f of xy is equal to 2x. We're measuring the value of this AMM in terms of token X.
02:15:56.473 - 02:16:33.000, Speaker A: The first term simply comes from the amount of token next that is inside the pool. And the second term comes from converting the amount of token Y in terms of token X. Let's go over an example. X0 is 6,000,000 Dai and Y0 is 3,000 YIF. The spot price of ETH in terms of DAI will be 6 million DAI divided by 3000 YIF. The 3000 YIF over here and the 3000 ETH over here cancels out and we're left with 12 million DAISY. Next, using this definition as the value of the pool, let's calculate L1 minus L0 over L0.
02:16:33.000 - 02:17:02.795, Speaker A: Let's start with L1 again. L1 will be the value of the pool after adding liquidity after adding DX and DY amount of tokens. By definition, this is equal to F dx. X 0 + dx is the amount of token in the pool after adding liquidity and y0.dy is the amount of token Y after adding liquidity, and L0 is liquidity before adding liquidity. This is Simply f of x0 and y0. We divide this by l0.
02:17:02.795 - 02:17:42.281, Speaker A: By definition, the first term is equal to 2 times x0 plus dx and the second term is minus 2 x0. And then we also have a 2 x0 on the bottom. The 2's cancel out and the x0's on top cancel out. And we're left with dx divided by x2. So this shows that when we define the pull value function as 2x, then l1 minus l0 divided by l0 is equal to dx divided by x0. Now we can do something similar and define f of xy to be two times y. And we'll get that l1 minus l0 over l0 is equal to dy divided by y0.
02:17:42.281 - 02:18:19.961, Speaker A: Let me summarize all of the equations that we have so far about pool shares and liquidity. So we said that the amount of shares to minus is described by this equation. And we said that this L1 minus L0 divided by L0. We show that this is equal to dx divided by x0 which is equal to dy divided by y0. And there were three ways we defined this pull value function in all three cases. This equation is true. And now replacing this L1 minus L0 divided By L0 we get this equation that the amount of shares domain is equal to dx divided by x 0 times the total shares t.
02:18:19.961 - 02:19:00.429, Speaker A: And this is also equal to dy divided by y 0 times total shares t. Before we dive into the code of Uniswap V2, I'll give you a quick overview of the contracts and the functions that are called when we add liquidity. So let's say that a user wants to add liquidity to the DAI ref pool. The first thing that he'll do is call a function called add liquidity to the router contract. The router contract will check if the die ref pool exists. If the die ref pair contract does not exist, the factory contract will Deploy this using Create2. Next, the router contract will transfer ref and DAI from the user directly over to the pair contract and then call the function mint.
02:19:00.429 - 02:19:43.255, Speaker A: Similar to the interaction between the router and the pair contract when a swap is called. Notice here that the tokens are directly transferred over to the pair contract before some other function is called. In this case, the router contract directly transfers die and ref before it calls the function mint on the pair contract. So by the time the function mint is executed inside the pair contract, it already assumes that the tokens were sent. And lastly, it calculates the amount of shares to mint for providing DAI in with and sends this amount of shares back to the user. Let's look at the code for add liquidity inside Uniswap B2 router contract. Again, the contract Uniswap B2 router deal 2 contract is inside the repo B2 peripheries.
02:19:43.255 - 02:20:20.959, Speaker A: When a user adds liquidity, they're going to call the function addliquidity. Now, if this user wanted to send some ERC20 paired with ETH, then they can call a function addliquidityeaf. If you look at the function inside add liquidityeaf, it's going to execute code similar to the function above liquidity. The only difference is it's going to convert eth into ref. So those are the only difference. Let's go back to the function add liquidity. So this function handles the k sub erc20 and erc20 pair for the function inputs, it's going to take in the address of the two ERC20 contracts, token a and token B.
02:20:20.959 - 02:20:57.165, Speaker A: Next, amount A desired and amount B desired. These are the amount of tokens that the user is willing to put inside the pair contract. Since the price of the AMM is always moving, it might not be possible to put in the exact amount of tokens that the user specified. So this is why it's called amount A desire and amount B desired. And to make sure that some amount of minimum token is put inside as liquidity. The next two parameters specifies this amount A minimum and amount B minimum. The minimum amount of token A and minimum amount of token B that must go in for this function call to succeed.
02:20:57.165 - 02:21:36.133, Speaker A: The next input 2 will be the address that will receive the pool shares. The address that will receive the pool shares that is minted by Uniswap B2 pair contract and the last input is deadline. This specifies the last timestamp that this function call is valid. If this deadline is expired, then function call to add liquidity will fail and this check is done inside the modifier ensure. So if you take a look at this modifier in sh, you can see over here that it requires that deadline is greater than or equal to block that timestamp. Okay, going back to the function add liquidity. This function will output amount A, amount B and liquidity.
02:21:36.133 - 02:22:04.739, Speaker A: Amount A is the amount of tokens that was actually sent to the Uniswap B2 pair contract. And likewise amount B is the amount of other token that was sent to the pair contract. And finally, liquidity. This is the amount of pool shares that was minted to the address 2 for providing amount A and amount B amount of liquidity. Okay, so these are the inputs and the outputs. Let's take a look at the code inside the function. It's going to call an internal function called Add liquidity.
02:22:04.739 - 02:22:44.085, Speaker A: And this internal function will return the exact amount of token A and token B that will be sent to the pair contract. Next it gets the address of the pair contract. And then notice here it transfers token A and token B to the pair contract for the amount amount A and amount B, which is calculated over here. And lastly, it calls the pair contract and calls the function mint. Calling the function mint will return the amount of pool shares that was minted. As mentioned earlier, note here that it directly transferred the two tokens before calling the function mint on the pair contract. Okay, next let's look at the internal function Add liquidity.
02:22:44.085 - 02:23:09.811, Speaker A: Scrolling up, here's the function add liquidity. First thing to note is that it checks whether the pair contract exists or not by calling get pair on the factory contract. And if it returns address zero. So this means that the pair contract has not been deployed yet. Then it will call Create pair on the factory contract. This will deploy a pair contract for token A and token B. Okay, moving on.
02:23:09.811 - 02:23:52.662, Speaker A: The next part of the code calculates the amount of token A and token B that will be sent over to the pair contract. If the amount of token A and token B inside the pair contract is equal to 0, you can see over here reserve A equal to 0 and reserve B also equal to 0, then the amount of token to send is exactly the amount that user specified, amount they desired and amount B desired. Otherwise, the pair contract already has some tokens in it. So we'll need to do a little bit more to figure out the amount of tokens to send. First, it calculates the amount of token B that is needed if we were to send amount a desired of token name. Let's take a quick look at this function uniswap b2library.quote inside the repo uniswap b2 periphery.
02:23:52.662 - 02:24:25.357, Speaker A: Under libraries, I'll open uniswap b2library and then look for a function called quote. Okay, here it is. So what this function will do is given some amount of asset impaired reserves, it will return an equivalent amount of the other asset. Basically what it does is it calculates the spot price. Remember from the math video, this is Y0 divided by X0 and then multiplies it by X0. Okay, going back to Uniswap B2 router 02 contract. So we left off over here.
02:24:25.357 - 02:25:14.131, Speaker A: Given amount A desired, it calculates the equivalent amount of token B. This is amount B optimal. If this amount B optimal is less than amount B desired, this is the amount of token B that the user is willing to add as liquidity, then it checks that amount B optimal. The amount of token B that is needed is greater than or equal to amount B minimum. And if all of these check paths, then the amount of a token that will be sent will be amount A desired and amount B will be the amount of token B that is needed. If the amount of token B that is needed is greater than the amount of token B that the user specified, then we will need to look at this part of the code. So similar to the code above, next it will calculate the amount of token A that is needed, given the amount of token B that will be provided.
02:25:14.131 - 02:26:12.786, Speaker A: At this point we know that the amount of token B that is needed is greater than the amount of token B that the user specified. So here we'll need to check that the amount of token A that is needed is less than or equal to amount of token A that the user specified. And this check is done over here it also checks that the amount of token A that is needed is greater than or equal to the amount that the user specified as the minimum. And once all of these check passes, then it specifies that the amount of token A and amount of token B that will be sent to the B2 pair contract is amount A optimal, which is the amount of token A that is needed and amount B desired. So this part of the code will return the amount of token A and Amanto token B that will be sent over to the pair contract going back to the function add liquidity. After that calculation is done, it directly transfers the tokens and then call the function mint on the pair contract. Next, let's take a look at the function mint inside Uniswap B2 Pair contract.
02:26:12.786 - 02:26:46.141, Speaker A: The Uniswap B2 Pair Contract is inside B2 Core Repository under Contracts and Uniswap B2 Pair Project. So I'll look for the function called mint. The function mint will take in a single input address 2. This will be the address where the pool shares will be sent to and liquidity. This is the amount of shares, the amount of pool shares that was minted to the address to. First it gets the internal reserves, reserve 0 and reserve 1. Next it gets the actual balance of tokens, balance 0 and balance 1.
02:26:46.141 - 02:27:13.379, Speaker A: And then the amount of tokens that were sent to this pair contract is implied. It is calculated by taking the difference, the actual balance minus the internal balance. Next it will call an internal function called Mint fee. This function will mint fees to the protocol if protocol fee is enabled. We will take a look at this function later. Moving on, it stores the state variable total supply into memory. This is done for gas saving.
02:27:13.379 - 02:27:48.111, Speaker A: If total supply is equal to zero, then it calculates liquidity as the following. Take the square root of amount of token 0 that came in, multiply this by the amount of token 1 that came in and then there's subtraction of minimum liquidity. I'll get to this later. First, notice that square root of amount 0 times amount 1. This is exactly what we discussed when we talked about the pull value function. Setting this equal to F of XY equals the square root of X times y. As a quick reminder, we said that pull value function can be defined as the square root of xy.
02:27:48.111 - 02:28:37.893, Speaker A: And this is because if you take a look at the function X times Y equals L squared, you take the square root of both sides and you get that the square root of XY is equal to a number called L which represents the liquidity of a constant product ammunition. So that was the explanation of this Part of the code, moving on, it subtracts some minimum liquidity. Now, the reason why it's subtracting some minimum amount of liquidity from the shares to be minted. And this is done to protect against attack called the bolt inflation attack. I won't go into the details of what a bolt inflation attack is. A quick explanation is that when the total supply is equal to zero, there's a lot of room to manipulate the amount of shares to mint, which can hurt later users when they mint their shares. And one of the ways to protect against the bot inflation attack is to mint the shares to address zero.
02:28:37.893 - 02:29:22.563, Speaker A: By doing this, we guarantee that some of the tokens are locked inside address zero. Okay, moving on. If total supply, the total amount of liquidity that was minted, is not equal to zero, then we'll execute this part of the code. So this part of the code says take the minimum of dx times the total shares t divided by x 0, reserve 0. And the other part to consider for the minimum is dy times the total shares t divided by y 0. And you can see over here amount 1 multiplied by total supply divided by reserve 1. This is the exact equation that we derive for the amount of shares to mint when we provide DX amount of token x and DY amount of token Y.
02:29:22.563 - 02:29:49.669, Speaker A: Here we're taking the minimum because there might be some rounding error. So we round down in favor of the pair contract. Next, it checks that this amount of shares to mint is greater than zero and then actually calls the internal function to mint the pool shares. And then it calls the internal function update. What this function does was already discussed in the code walkthrough for the function swap. So we'll just move on. Okay, so that completes the function for mint.
02:29:49.669 - 02:30:28.775, Speaker A: Let's take a quick look at the internal function mint fee. So scrolling up here is the internal function mint fee. What this function basically does is it will collect swap fees for the protocol. And the way it does this is by calculating how the pool has increased from the swap fees and minting shares to the protocol for the increasing pool. Now, I've checked the factory contract and protocol fee is disabled, so I won't go into the details of the amount of shares that is minted to the protocol. If you're curious about the math for the amount of pool shares to mint to the protocol, you can check the Uniswap B2 whitepaper. The equation inside the whitepaper is implemented here.
02:30:28.775 - 02:31:01.985, Speaker A: OK, so that's a quick explanation of the internal function mint fee. And that completes the code walkthrough for the function mint inside Uniswap B2 pair contract. As an exercise, I want you to add liquidity to the die ref pool using Uniswap B2 router contract. So the function that you need to call is inside Uniswap B2 router contract. Call the function add liquidity for token A and token B pass in ref and dai. And for the amount it doesn't really matter. The test will check that the user has received some shares of the pool.
02:31:01.985 - 02:31:48.575, Speaker A: So after this line I want you to write some code to add liquidity to the DAI ref pair contract. For the setup, it's calling BM prank user and whatever contract call that you make immediately after this line will be simulated as if it was sent by this user. If we take a look at the function setup, you can see over here that this user was funded 100 WEF. And you can see over here that this user has 1 million Dai. You can provide any amount of ref and DAI to the DAI ref pair contract as long as ref is less than or equal to 100 ref and Dai is less than or equal to 1 million daisy. What I'm going to check here inside this test is that the pair contract minted some shares to the user. After you call the function add liquidity.
02:31:48.575 - 02:32:26.371, Speaker A: Okay, let's go over the solution. So we'll need to call the router contract. The router contract is initialized over here. So over here I'll call router dot and then I'll go over to Uniswap B2 router 02 contract and then I'll copy this function signature and also the output and then I'll paste it here. Then I'll clean up the code a little bit. So you'll need to call the function add liquidity on Uniswap B2 router contract and it's going to return these outputs amounta amount B and liquidity. So the next thing that I'll do is fill out these inputs.
02:32:26.371 - 02:32:58.549, Speaker A: Now I'll use a key value pair so that it is easy to understand what the inputs are. Okay, let's start with token A. The order of the tokens to pass not matter. So for token A I'll pass dai, and for token B I'll pass left. Okay, Amount A desired and amount B desired Amount A desired amount of DAI that I'm going to send to add liquidity inside the setup function. I know that this user has 1 million DAI and 100 WEF. So let's send all of this.
02:32:58.549 - 02:33:43.445, Speaker A: And I forgot to mention that inside the setup, the user already has approved the router contract to spend these tokens. So over here the user does not have to call approve on the router contract for the router to transfer ref and DAI from the user over to the pair contract. Okay, so amount a desired 1 million Dai 1e6 times 1e18 Dai has 18 decimals and ref 100 weth 100 times 1 8. Okay, amount a minimum, let's set this equal to 1 and amount b minimum. For this exercise, let's just set it to one. These are the minimum amount of weapon die that the pair contract must receive. Otherwise this function call will revert.
02:33:43.445 - 02:34:19.703, Speaker A: And two, this is the address that will receive the pool shares. Let's set this to user and deadline last timestamp that this function call is valid. If you're calling for a smart contract, setting this to block timestamp is good enough. However, if you're calling this from a user interface, then you'll need to set the deadline in the future. And also considering that your transaction may be delayed. Okay, that completes the code that you'll have to write to add liquidity to the Daiwef Uniswap B2 pair contract. Now for this demo, I also want to print out amount A.
02:34:19.703 - 02:34:42.063, Speaker A: Amount B. Amount A will be the actual amount of DAI was sent over to the pair contract. And amount B will be the actual amount of weft that was sent over. And liquidity will be the amount of pool shares that was minted. Let's console log this. So say console.console2.log. I'll say die will be token A.
02:34:42.063 - 02:35:24.795, Speaker A: So this will be amount A and next will be referred with amount B and liquidity. Let's say LP liquidity Liquidity. Okay, that completes the test. Let's execute this test inside my terminal. First I'll set an environment variable called fork URL and we'll use this fork URL to execute our test against the main net fork. So fork URL equals the URL that I got from Alchemy. Next we'll execute test by typing forge test and we'll specify that we want to execute this test on the mainnet fork fork URL fork URL that we set above.
02:35:24.795 - 02:36:38.445, Speaker A: And then the test will be match path test Uniswap B2 exercises Uniswap B2 liquidity test solution and then we'll print out the console logs BBB and our test executed successfully. So it looks like we added 100 weth and for adding 100 wef we also added this much amount of Dai, let's see what this amount is. I'll copy this and inside my terminal I'll open a Python shell, copy the number the amount of DAI that was sent to the pair contract and then divide this by 118. The amount of DAI that was sent is approximately 292,818. So if we take this number and then divide it by the amount of WAF that was sent 100, then this will give us that one WAF at the moment is roughly 29, 28 DAI. When we add liquidity to a constant product AMM, the amount of token X to add and the amount of token Y to add must follow a simple rule. The price after adding liquidity must be equal to the price before adding liquidity.
02:36:38.445 - 02:37:20.077, Speaker A: For example, here we have two constant product AMM curves. The one in blue is before adding liquidity and one in purple is after adding liquidity. Before adding liquidity, we have that the price is equal to 1.4. And after adding the correct amount of token X and the correct amount of token Y, we have that the price is still equal to 1.4. We discussed that. One way to visualize that the price after adding liquidity is equal to the price before adding liquidity is to draw a straight line from the origin to the current price and then extend this line to increase liquidity from this blue point. The only valid amount of token next and amount of token Y that we can add must also be on this green line.
02:37:20.077 - 02:38:08.855, Speaker A: In this case, we see that after adding liquidity we get this purple curve and the point where the price after adding liquidity is equal to the price before adding liquidity is over here, exactly on the green line. Now, when we remove liquidity from the constant product amm, we again follow the same rule that the price after removing liquidity must be equal to price before removing liquidity. So let's say that our current AMM is described by this purple curve. After removing liquidity, the price must remain the same. The price before removing liquidity is P 1.4. So after removing liquidity, the price must remain the same 1.4. And the only way to do this is to have the balance of token X and token Y inside the constant product AMM be a point on this green line.
02:38:08.855 - 02:39:10.431, Speaker A: For example, as we remove liquidity, you'll see that this purple curve approach this blue curve and at every point you'll see that the point where it corresponds to price equals 1.4. Be exactly on the screen line so as I decrease liquidity, you can see that the point where the price is equal to 1.4 remains on the screen line. And if I decrease all the way to the blue curve, it still remains on the green line. Okay, so after we remove liquidity from constant product amm, the price after removing liquidity must be equal to the price before removing liquidity. So the next question is how much amount of token X and how much amount of token Y do we need to take out from this pool so that when we decrease liquidity, the price remains the same when we remove liquidity from constant product amm, we said that the price after removing liquidity must be equal to the price before removing liquidity. And we want to figure out the amount of token X and the amount of token Y to remove so the price remains the same.
02:39:10.431 - 02:39:53.429, Speaker A: Well, recall from the math about adding liquidity, we also have this same rule. We said that the price after adding liquidity must be equal to the price before adding liquidity. Well, the math to find out the amount of token X and the amount of token Y to remove so that the price remains the same is exactly the same math as the math for add liquidity. When we add liquidity, we said that the price after adding liquidity must be equal to the price before. And this was expressed using this equation. Now all we have to do to figure out what DX and DY are when we're removing liquidity is to consider when DY and DX over here are both negative. And do the same math for what we did for add liquidity and you'll get this equation.
02:39:53.429 - 02:40:37.193, Speaker A: And this equation tells us that when we remove liquidity, the amount of token Y to remove and the amount of token X to remove must follow this equation. In other words, the ratio of amount of tokens to remove must be equal to the spot price before removing. When we add liquidity to a Uniswap B2 pair contract, it mints shares. And now if you burn the shares, how many token X and how many token Y should it withdraw so that the price remains the same before removing liquidity and after removing liquidity. The equation to calculate this DX and DY turns out to be simple equations. But first let's start with a review of the math for pool shares. So let's say S is equal to the shares to burn and T is the total shares.
02:40:37.193 - 02:41:25.471, Speaker A: You'll say L0 is liquidity before burning the shares and L1 is the liquidity after burning the shares. We saw in the video for pool shares that if you were to remove s amount of shares, then the amount of liquidity to decrease must satisfy this equation. The liquidity to decrease from L0 to L1 must be proportional to the amount of shares to burn multiplied by the current liquidity. That's what this equation says. Now, in the next few videos, I'll work out the equation that says l0 minus l1 divided by l0 is equal to dx over x0. And this is also equal to dy over y0, where dx is the amount of token to remove and dy is also the amount of token to remove. And x0 and y0 are amount of tokens in the pool before removing liquidity.
02:41:25.471 - 02:42:06.297, Speaker A: Once I show you how to get to this equation, we can easily calculate DX and DY and they turn out to be these two equations. So given that this equation is true, we can get to this equation by starting from this equation. What I'm going to do is copy this equation and then I'll paste it here. So L0 minus L1 over L0. This is I can transform this equation by bringing this L0 over to the left. And now we know that this L0 minus L1 over L0 is equal to dx over x0, which is equal to dy over y0. So I'll copy this and then set them all equal.
02:42:06.297 - 02:42:35.358, Speaker A: I'll actually move the equation a little bit. So I'll move this over to the right. So now the equation looks like this. All I did was took this equation, rearranged it, and then applied this equation and we get this equation. Now from here, to derive these two equations, all I have to do is simple algebra. For example, if I take this part of the equation, I don't need this. We have S divided by T is equal to dx divided by x 0.
02:42:35.358 - 02:43:05.379, Speaker A: And now we can simply solve for dx. DX is equal to x 0 times s divided by t. This is equal to dx. And likewise we can solve for dynamic. So taking the same equation, we'll get S over T is equal to dy divided by y0. And now dy will be simply be equal to y0 times s divided by t. And these two equations are the same exact equation that we see over here.
02:43:05.379 - 02:43:55.575, Speaker A: So in the next few videos we'll derive this equation. This equation tells us that when we decrease the liquidity from L0 to L1, then we will have to remove DX amount of token X and DY amount of token y. This equation is true whether we define the pull value function F of XY to be equal to the square root of x times y, or set it equal to 2x, or set it equal to 2y. When we set the pull value function to 2x and 2y, this equation is straightforward. So I'll leave that as an exercise for you if you're curious. In the next video, we'll go over the case when we define the pull value function F of XY to be equal to the square root of x times Y and then derive this equation. Let's say that we define the value of the pool of a constant product AMM to be equal to the square root of X times Y, where X and Y are the amount of tokens in this amm.
02:43:55.575 - 02:44:34.749, Speaker A: And now let's calculate this expression. L0 minus L1 divided by L0. L0 is the value of the pool before removing liquidity. So this is f0 and y0 and l1 is the value of the pool after removing liquidity. So this will be f of x 0 minus dx.dx is the amount of token X that we're removing, and y 0 minus dy, where dy is the amount of token Y that we're removing. The first term f of x0, y0 is simply the square root of x0 times y0 and f of x0 minus dx y0 minus dy is the square root of x0 minus d times y0 minus dy.
02:44:34.749 - 02:45:19.999, Speaker A: Next, I'm gonna replace this dy. Earlier we said that when we remove liquidity, it must follow this equation that the amount of tokens to remove must be equal to the spot price. Solving for dy, we get that dy is equal to y0 divided by x0 times dx, we plug this equation back into the equation over here and we get this equation. Next, I want to simplify this part of the equation by multiplying this whole equation by the square root of x2. So we multiply the top part of the equation by the square root of x0 and also multiply the bottom part of the equation by the square root of x0. For the first term, we have a square root of x0 times the square root of x0. So they simply become x0 for this term.
02:45:19.999 - 02:45:56.237, Speaker A: It's a little bit more complex. So I'll copy this equation and then paste it here, and then I'll copy the square root of x0. So what I'm going to show you is that square root of x 0 times this term will be equal to this term. So what's going to happen Here is that we multiply square root of x0 by this complicated term. We can bring the square root of x0 inside and the square root of x0 will go inside. Now all of these terms are inside a square root. Now I see that I have a y0 here and y0 here.
02:45:56.237 - 02:46:32.745, Speaker A: So I can pull this out, pull the y0 out, and then I can remove this. And now we will have a 1 over here and a 1 over here. And lastly, we multiply this x 0 by this term and we'll have 1 times x 0 will be x 0. X 0 times 1 over x 0. This will be simply be equal to 1. So I can just remove this. And now what we have are these terms x 0 minus dx times x 0 minus dx times y 0, which is the same term that you see over here.
02:46:32.745 - 02:47:16.665, Speaker A: Now I'm going to simplify this equation. So this will be equal to notice that inside the second term I have x 0 minus dx times x 0 minus dx inside the square root. So we can pull this x 0 minus dx outside of the square root. So now our equation will look like this and we can further simplify this equation. I'll copy this equation and then paste it here. The first term x0 times the square root of the y0 will cancel out with the second term of minus x0 times the square root of y0. And then on top you have a minus minus dx times the square root of y0 minus minus will make the dx positive.
02:47:16.665 - 02:48:00.369, Speaker A: And we need to multiply this by the square root of y0. So this is what we have. And now the square root of Y0 on top will cancel out with the square root of y0 on the bottom. And we're left with dx divided by x0. What we've shown here is that l0 minus l1 divided by l0. When we define the pull value function to be the square root of X times y, then we get that this expression is Simply equal to dx divided by x2. Furthermore, we can use this equation to say that since dy divided by dx is equal to y0 divided by x0, we can say that bring this dx over here and then this dy over here.
02:48:00.369 - 02:48:52.341, Speaker A: And then I'll bring this dy divided by y0 to the right side and we have dx divided by x0 is equal to dy divided by y0. And finally we can combine these equations and we get that dx divided by x0 is equal to dy divided by y0 and these two are also equal to l0 minus l1 divided by l0. To remove liquidity from a Uniswap b2 pair contract, the user will first call a function called Remove liquidity on the Uniswap B2 router contract. For example, let's say that this user wants to remove liquidity from the daiwef pair contract. Remember that when a user adds liquidity, they are minted some pool shares from the pair contract. This pool shares is a ERC20 contract. And when this user removes liquidity, he'll have to transfer this pool shares back to the pair contract.
02:48:52.341 - 02:49:37.545, Speaker A: And here when the user calls the function Remove Liquidity, the router will call transfer from this user over to the pair contract. And for the router to be able to successfully call transfer from, this user will have to approve the router contract to spend the pool shares. After the pool shares is transferred back into the pair contract, the router contract will next call function burn on the pair contract. This will burn the shares and then transfer ref and DAI back to the user. Let's do a cold walkthrough for the function Remove liquidity. This function Remove liquidity is inside the contract uniswap B2 router 02. And again this contract is inside the repository called B2 Peripheries.
02:49:37.545 - 02:50:06.909, Speaker A: I'll scroll down and look for the function called Remove liquidity. Okay, here it is. So when a user wants to remove liquidity from a pair contract, they'll call this function called Remove liquidity on the router contract. The inputs are the two tokens that determine the pair contract. In our example, let's say ref and dai. Now note here that the order of the tokens does not matter. You can pass in DAI and then ref, or you can pass in WEF and then dai.
02:50:06.909 - 02:50:34.733, Speaker A: Either way, it will call the same pair contract and then liquidity. This is the amount of pool shares that you're going to burn. Next, amount A, min and amount B. These are the minimum amount of tokens that you expect to get back for burning this much amount of liquidity and address 2. This is where the tokens are sent. And finally, deadline the last timestamp where this function call is valid. If the deadline is expired, then this function call will fail.
02:50:34.733 - 02:51:06.307, Speaker A: Okay, moving on, let's look at the outputs. The outputs are amounta and amount B. These are the actual amount of tokens that were withdrawn to the address 2 for removing this much amount of liquidity. Okay, first thing it does is computes the address of the Pair contract. So if you go to Uniswap B2 library and then look for the function Pair4, it's inside. Over here look for the function called Pair4. You can see how it calculates the address of the pair contract.
02:51:06.307 - 02:51:37.711, Speaker A: This code over here uses Create2 to calculate the address of the pair contract. When I looked at this code, I had a question. Well, what if the pair contract does not exist? What if the pair contract was never deployed? Well, my question was answered in the next line of the code. So if you look at the next line of code, it says Uniswap B2 Pair Transfer from. So let's imagine the case where the pair contract does not exist. And if we call transfer from, then this line of code will fail. So at this point we can assume that the pair contract exists.
02:51:37.711 - 02:52:05.695, Speaker A: If it does not, then this line of code will fail. Remember that I said that the pair contract is also our ERC20 contract. And when you add liquidity, it mints pool shares. And when you remove liquidity, it will burn your pool shares. What this line of code is doing is it's transferring the pool shares from messagesender over to the pair contract. And then next it calls the function burn on the pair contract. There's two things that I want to mention here.
02:52:05.695 - 02:52:47.609, Speaker A: First of all, it's calling a transfer from messagesender to the pair contract. And the pair contract is an ERC20 contract. So before the user calls the function remove liquidity, they'll have to approve this router contract to spend this pair ERC20. And the other thing that I'll mention here is that similar to the function swap, in the function swap tokens were directly transferred over to the pair contract before the swap function was called on the pair contract. And here we see something similar. The pool shares is transferred over to the pair contract before the function burn is called. We'll take a look at what's going on inside the function burn later.
02:52:47.609 - 02:53:26.529, Speaker A: So let's move on. When we call the function burn, it's going to return two outputs, amount 0 and amount 1. This is the actual amount of token 0 and token 1 that was returned to the user when the user specified token A and token B. Here we set that the ordering of the tokens does not matter, but over here it does. It says amount zero and amount one. But at this point we don't know if Token A is amount 0 or token A is amount 1. And to figure this out, we will have to sort the tokens, token A and token B and whichever one Comes first is token zero.
02:53:26.529 - 02:54:20.509, Speaker A: And once we know what token zero is, we can now figure out what amount A and amount B should be equal to. If token A is equal to token 0, then amount A will be amount 0 and amount B will be amount 1. Otherwise, amount A will be equal to amount 1 and amount B will be equal to amount 0. Once we figure out what is amount A and amount B, the last thing that this code does is check that this amount that was sent is greater than the minimum amount A greater than or equal to amount a min and amount B greater than or equal to amount B min. Okay, so this is a quick walkthrough on the function remove liquidity. Next, let's take a look at the function burn inside the pair contract. The function burn inside uniswap B2 pair contract burns the pool shares and then sends the token to to the address specified by the input 2.
02:54:20.509 - 02:54:55.295, Speaker A: The actual amount of token that was withdrawn is returned in the output amount 0 and amount 1. Notice that when this function burn is called, it doesn't specify the amount of tokens to burn. And this is because this is implied over here. The amount of shares to burn is whatever amount of shares that was given to this pair contract. So you can see over here it queries balance up address. This and this is stored as a variable in liquidity. And if you scroll down further you can see over here that it burns this liquidity.
02:54:55.295 - 02:55:36.975, Speaker A: So that is why we don't see an input for the amount of shares to burn. Over here it is implied by the amount of shares given to this pair contract. Now it makes sense why inside Uniswap B2 router 02 contract that it first transfers the pool shares over here and then calls the function burn. Okay, going back to the pair contract, the first thing it does is gets the actual balance of token 0 and token 1. And then next it calls an internal function called mint fee and this will mint protocol fees. This was covered when we looked at the code for mint. So I'll skip over this and then next we calculate the amount of token 0 and amount of token 1 to send to the to address.
02:55:36.975 - 02:56:32.989, Speaker A: So if we do the math over here says liquidity multiplied by balance 0 divided by total supply. Recall in the math video about pool shares about the amount of tokens that is withdrawn when we burn S shares. We said that the amount of token next to withdraw dx is equal to x 0. This is the amount of token next in the pool divided by total shares t that's times x 0 divided by t. And this is the exact same math that we see over here. And likewise, for the amount of token y to withdraw, it has a similar equation and we also see the same exact equation over here. Okay, Next it checks that amount 0 and amount 1 are both greater than 0, burns the shares, transfer the tokens, gets the balance of token 0 and token 1 after transferring, and then updates the internal balance to match the actual amount of tokens inside the spare contract.
02:56:32.989 - 02:57:10.331, Speaker A: And that completes the code walkthrough for the function burn inside the contract. Uniswap B2 pair contract. For the next exercise, if you want to quickly copy and paste the code into your editor, or you might have some question, head over to CyberNT Updraft here, under the written lessons, you'll be able to copy the code and then paste it into your editor. And furthermore, if you have questions, you can scroll down and then head over to GitHub Discussions or to our Discord channel. As an exercise, I want you to remove liquidity from Uniswap B2 pair contract. The pair contract is Dai Ref. The router contract is already initialized in the setup above.
02:57:10.331 - 02:57:42.795, Speaker A: And here the setup is that the user added liquidity to the DAI ref pair and he got back this much amount of pool shares. And here we're pranking the user. So we're simulating a transaction. If it was called from the user, this user has this much amount of liquidity. And as discussed in the cold walkthrough, this user has approved the router contract to spend all of his liquidity. So for this exercise I want you to remove all of this liquidity from the diwef pair contract. Okay, let's go over the solution.
02:57:42.795 - 02:58:22.561, Speaker A: So what is the function that we need to call to remove liquidity inside the B2 periphery contract? The contract that we will need to call is UNISOFT B2 router 02. And this is the function that we need to call Remove liquidity. Copy this and then inside the exercise, I'll first paste it over here. The router contract is already initialized inside the test, so we'll be calling this contract router dot Remove liquidity. And these are the inputs that we'll need to pass. And the output is this over here. So the output is amounta and amount b and I'll clean up the code a little bit.
02:58:22.561 - 02:58:46.441, Speaker A: Okay, let's fill in the inputs. I use key values for the inputs so that it's easier to read Token A, token A, let's say DAI and token B say ref. Now this Custard here. It doesn't matter if token A is DAI and token B is ref or if token A is ref and token B is dai. Okay, liquidity. This is the amount of pool shares to burn. Liquidity will be.
02:58:46.441 - 02:59:22.485, Speaker A: Well, what is the amount of liquidity that this user has? We know that this user added liquidity and got back this much amount of pool shares. And here we're going to burn all of his pool shares. So liquidity will be stored in this variable. Liquidity will be liquidity. Okay, next, amount a min and amount be min, the minimum amount of tokens to receive from burning this much amount of liquidity. For this exercise, we will keep it simple and just put a one. Now in production, it's probably not a good idea to put a one or a zero to user.
02:59:22.485 - 02:59:58.149, Speaker A: So when we remove liquidity, token A and token B, DAI and ref will be sent to the user and deadline. Let's set this to a block timestamp. Block timestamp. Okay, for this demonstration, I also want to console log, amounta and amount. So over here I'll type console2.log die will be amount A and wealth will be amount B. Okay, and that completes the code for testing remove liquidity.
02:59:58.149 - 03:00:38.251, Speaker A: But before we execute this test, I'm going to remove the code for testing add liquidity. So I'll just remove this. Okay, and let's try running a test for remove liquidity. Inside my terminal, I'll first paste my fork URL and then to execute the test I'll type forge test dash dash fork URL Fork URL. The test will be match path test. Uniswap B2 exercises Uniswap B2 liquidity test SOL BBB okay, and our test passed. In defi, there is something called a flash known.
03:00:38.251 - 03:01:15.969, Speaker A: If a defi protocol supports a flash node, then this will allow a smart contract to borrow large amount of tokens from this defi protocol as long as the token is repaid in the same transaction. Uniswap B2 also has a flash node, but here it is called Flash swap. When a smart contract borrows tokens using a flash swap, it will have to pay the amount that it borrowed plus some fee. The equation to calculate this fee is not so trivial to understand. So in this video I'll explain how this fee is derived. So let's say that we have a Uniswap B2 pair contract with token X and tokeny. And we also say that we're going to borrow DX0amount of token X.
03:01:15.969 - 03:02:03.351, Speaker A: Now the math for Borrowing tokeny is exactly the same. So for this example, we'll just borrow token X. We borrow DX amount of token x and in the same transaction, once we borrow this amount of token, we will have to pay dx1amount of token next. This dx1amount of token next is dx0, the amount that we borrow plus some fee. We also say that this pair contract has x 0amount of token next inside the contract before we do a flash swap. According to the official documentation for Uniswap B2, when a smart contract does a flash swap, this is the equation that must be satisfied. From this equation solving for phi, we'll get that phi is equal to 3 divided by 997 times DX0.
03:02:03.351 - 03:02:39.785, Speaker A: It's easy to understand that the fee will be some fraction of the amount of tokens that we borrowed. The amount of tokens that we borrowed is DX0. But why is it 3 over 997? In this video, I'll explain how we get this equation. Now, to actually write a smart contract that does flash swap, all you need to know is that fee is calculated by this equation. So feel free to skip this video if you don't need to know how to derive this equation. To understand the motivation for this equation, I think it's best to put it into analogy. Let's first consider a fee when we do a swap for token X to tokeny.
03:02:39.785 - 03:03:03.887, Speaker A: So let's say that we do a swap for token X to token Y. We put in dx amount of token x and we get back out dy amount of token y. Amount in will be dx. Amount in minus fee will be 0.997 times dx. Remember that in Uniswap V2, fee is collected on the token that is coming in. This amount is used to calculate the amount of token Y that comes out.
03:03:03.887 - 03:03:23.787, Speaker A: And the amount of token that comes out is Dy. In this case, the fee will be 0.003 times dx. Difference between the actual amount that the user sent minus the amount that was used to calculate dy. This is 0.003 times dx. Okay, let's now compare this with when we do a flash swap.
03:03:23.787 - 03:03:54.051, Speaker A: When we do a flash swap, the amount that goes out is the amount that we borrow DX0 and the amount of token that comes in is the amount of token that we repay. Let's call this DX1 and this will be equal to DX0. This is the amount of token that we borrow plus some fee. Again, in Uniswap V2 fee is collected on amount of token that comes in. We set amount in is dx1. So the amount in minus fee will be 0.997 times dx1.
03:03:54.051 - 03:04:23.333, Speaker A: And the flash swap fee is equal to 0.003 times dx1. Here we see some similarities between regular swap and flash swap. In both cases, fee is collected on the token that's coming in. For a swap, this is dx, and for a flash swap, this is the amount of token that we pay DX1. Okay, with that said, we're now ready to understand the motivation for this equation. So I'll copy this equation and then I'll paste it here.
03:04:23.333 - 03:04:52.199, Speaker A: And now let's break this equation into parts so that we can understand what this equation is trying to achieve. Let's start with x0. We said that x0 is the amount of token next in the pair contract before a flash swap. DX0 is the amount of token that we borrow. So doing the minus dx0 here, we're saying that this amount of token went outside of the pair contract. This is the amount of token that we borrowed. The actual amount of token that came back in is DX1.
03:04:52.199 - 03:05:20.265, Speaker A: However, similar to the calculation for a regular swap, the amount of token that came in that is used to calculate the amount of token that goes out is 0.997 times the actual amount of token that came in. And likewise, we're doing the exact same thing over here. The actual amount of token that came in is dx1. However, the amount that we'll be using to calculate is 0.997 times DX1. This is amount 10 minus the fee.
03:05:20.265 - 03:06:02.787, Speaker A: Okay, on the other side of this equation, we have a X0. Again, this is the amount of token next in the pair contract before a flash swap. So this part of the equation is easy to understand. Next, we have a greater than or equal to sign. And finally, what does this part of the equation describe? Well, it describes amount of token next before a flash swap minus the amount of token that went out plus the amount of token that came in minus the fee. This will be the amount of token next in the pair contract after a flash swap. So what this equation is describing is that the amount of token next in the pair contract after a swap must be greater than or equal to the amount of token next in the pair contract before a flash swap.
03:06:02.787 - 03:06:27.545, Speaker A: And we consider that the amount of token that came in is 0.997 times the actual amount of token that came in. This is similar to the calculation for a regular swap. So this is the motivation for why the equation is set up like this. Next, let's solve for DX1. And once you know what DX1 is, we can also know what the fee is. Okay, so we'll solve for flash swap fee.
03:06:27.545 - 03:07:05.325, Speaker A: To begin with, we know two equations. The first one is the one that I explained above, that the amount of token x in the pair contract after a flash swap must be greater than or equal to the amount of token x in the pair contract before a flash switch. The other equation, DX1, the amount of token that was repaid is equal to the amount borrowed plus some fee. And with these two equations, we can now find the exact equation for fee. So to start off with, I'll copy the first equation over to the right and then I'll copy again. And I notice right away that I have an X0 over here and a X0 over here. They cancel out.
03:07:05.325 - 03:07:25.711, Speaker A: Next I see A minus DX0. So I'll bring this over to the right side and then remove the minus. Okay, so now we have 0.997. DX1 must be greater than or equal to DX0. Now we know what DX1 is. Copy this. All we have to do is divide both side of the equation by 0.997.
03:07:25.711 - 03:07:50.287, Speaker A: Next, I'll replace DX1 using this equation over here. DX1 is equal to DX0 + PHI. So what I'm going to do is just put DX0 + PHI over here. Okay, Next I'll copy this equation again. Paste it here. I'm going to remove this DX1. And now we have an equation for phi phi is equal to DX0 divided by 0.997
03:07:50.287 - 03:08:17.045, Speaker A: minus DX0. Okay, let me simplify the right side of this equation. I can factor out the DX0. So this will be a one over here and I'll have a one over here. So I have one divided by 0.997 minus one times DX0. This term inside here, I can rewrite it as one minus 0.997
03:08:17.045 - 03:08:37.842, Speaker A: over 0.997. Okay, one minus 0.997. This will be equal to 0.003. On the denominator we have a 0.997 and we have DX0. So our final equation will be the fee that we repay must be greater than or equal to 0.03 divided by 0.997
03:08:37.842 - 03:09:20.871, Speaker A: times dx0. Now I can multiply this equation by 1000 on top and 1000 on bottom and we'll get 3 on top. If we multiply the bottom by 1000, we'll get the 99 7. Okay, and this is our final equation for the fee. Let's scroll back up and we can see over here that we said that fee is equal to 3 divided by 997 times DX0. Scroll back down and we have the same exact equation. When we use a flash swap in uniswap b2 and borrow dx0amount of token next, then the amount of fee that we'll have to repay must be greater than or equal to this equation.
03:09:20.871 - 03:09:56.877, Speaker A: 3 divided by 997 times dx 0. The sequence of functions that are called when we initiate a flash swap can be a little bit confusing. So let's go over an example of what functions are called when a user initiates a flash swap. Here we have a user and we have a smart contract that will do a flash swap with the uniswap B2 die with pair contract. Let's say that the user initiates a flash swap by calling some function inside this FlashSwapSmartcontract. This contract will have to call the function swap on the pair contract. Next, the pair contract will send the amount of tokens that were requested.
03:09:56.877 - 03:10:32.999, Speaker A: We can borrow both tokens simultaneously. Notice here that the FlashSwap contract called the FunctionsWap into the pair contract. And before we did that, we didn't have to send any tokens and we got back some tokens out. So this is how uniswap b2 pair contract lets another smart contract borrow tokens. It allows another smart contract to borrow token by sending the tokens out before we send any tokens in. After the tokens are sent out, it calls a function uniswap b2 call. So here the pair contract assumes that the contract flashswap has a function called uniswap b2 call.
03:10:32.999 - 03:11:11.659, Speaker A: Any custom code that you want to execute after borrowing the tokens will be inside this function uniswap b2 call. For example, once you borrow these tokens, you might want to do an arbitrage and then later repay the pair contract. After your custom code is executed inside the function uniswap b2 call, you'll have to repay the tokens that you borrowed. And when you repay, you'll also have to pay fee. If you borrow REF and dai, then you'll have to pay a fee both on WEF and dai. If you only borrow a single token, then you only have to Pay a fee for that single token that you borrowed. The function call to swap will terminate successfully if you pay the correct amount of tokens.
03:11:11.659 - 03:11:54.535, Speaker A: This is the amount of token that you borrow plus the fees. If you fail to do this, then the function call to swap will fail. So this is how you would borrow tokens from a Uniswap B2 pair contract and then repay it in the same transaction. Let's do a quick walkthrough of the code functionswap Inside the contract Uniswap B2 Pair this is the function that is called when we do a flash swap and it is exactly the same function that we call to swap one token for another token. Here we'll focus on the code that is executed when we do a flash swap. Let's start with the inputs amount 0 out and amount 1 out will be the amount of token 0 and amount of token 1 that we want to borrow. The next two inputs, address 2 and data, are important.
03:11:54.535 - 03:12:42.969, Speaker A: When we do a flash swap, the address 2 specifies where the tokens are sent and it also specifies the smart contract that is called. With the function Uniswap B2 call, it will execute some custom code inside that smart contract at the address of two and after it's done calling, it must repay the amount that was borrowed plus the fees. And to trigger this niner code data must not be empty. This data comes from the input. So to trigger a flash swap on uniswap b2 pair contract, we will need to call the function swap, specify the amount of tokens that we want to borrow. For the to address, we'll need to specify the smart contract that can handle the function Uniswap B2 call and repay the amount of tokens borrowed plus the fees. And the other condition is that this data must not be empty.
03:12:42.969 - 03:13:10.727, Speaker A: For this exercise, I want you to complete this contract. This contract Uniswap B2 flashswap will do a flash swap with a Uniswap B2 pair contract inside the constructor. It will set the address to the pair contract and the tokens token 0 and token 1. There are two functions that you'll need to complete. The function called flashswap and the callback function called uniswap b2 call. Let me first explain the first function flashswap. This function will take in two inputs.
03:13:10.727 - 03:13:52.872, Speaker A: The address of the token. This token will either be token 0 or token 1 and the amount of token to borrow. Inside this function, you'll need to prepare some inputs and then call the function swap on the pair Contract the first part of this exercise is to determine amount zero out and amount one out. And these are parameters that are to be passed to the function swap. This amount 0 out and amount 1 out can be determined by the inputs token and amount. For example, if we're borrowing token 0 for amount 100, then amount 0 out will be 100 because we want to borrow 100 of token 0 and amount 1 out will be 0. Otherwise, let's say that this input token is token 1.
03:13:52.872 - 03:14:37.597, Speaker A: And again, let's borrow 100 of token 1. In this case, amount 0 out will be 0 and amount 1 out will be 100. Next, you'll need to encode the data as bytes and this bytes will be passed to the function swap on the pair contract. Remember that when we looked at the Uniswap B2 pair contract and inside the function swap, the way we trigger a flash swap is that this data must not be empty. You can see over here, when the data is not empty, it will call the Uniswap B2 callee at the contract to call the function Uniswap B2 call. So to trigger a flash swap, we need to make sure that we pass in some kind of data. And for this data, I want you to encode the token from the parameter and message sender.
03:14:37.597 - 03:15:13.525, Speaker A: Later, when the function Uniswap B2 call is called by the paired contract, we'll decode this message sender and then have this message sender pay for the fee on FlashSwap. And the last part to complete this function is to call the function swap on the pair contract. Once the pair contract is called, the pair contract will call back into the function Uniswap B2 call. And this will be the second part of the exercise. The second part of the exercise is to complete this function. Now, we don't want anyone to be able to call this function uniswap b2 call. So the first part of this exercise is authorization.
03:15:13.525 - 03:16:11.131, Speaker A: First you want to check that message sender is the paired contract. Only the paired contract can call into this function. And the other check is a little bit confusing, but is to check that the sender from this input is this contract. Now why would we want to check that this input sender is this contract? Imagine a case alice calls into this FlashSwap contract and the FlashSwap contract calls into the Uniswap B2 Pair contract. The Uniswap B2 Pair Contract will call the contract at the to address here, since we specified as FlashSwap, it will call back into the flashswap contract when the function Uniswap B2 call is called for the sender. If you go to the Uniswap B2 pair contract, we can see that the sender is message sender. Okay, so going back to our contract, who will be the message sender if a flashswap contract calls into Uniswap B2 pair contract? Well, Messagesender will be the flashswap contract.
03:16:11.131 - 03:16:48.341, Speaker A: Messagesender is the first input that you see over here, sender. So in this case your sender will be the flashswap contract. So in this case, the flashswap contract calls into the Uniswap B2 pair contract, and then the Uniswap B2 Pair contract calls back into the flashswap contract. Now let's see what can go wrong if we omit this. Second, check that the sender must be equal to this contract. So imagine e calls directly into the Uniswap B2 Pair contract. And for the contract to call 2, E specifies this Flashswap contract.
03:16:48.341 - 03:17:27.981, Speaker A: Uniswap B2 Pair Contract will call the flash swap contract. Okay, let's go Back to the Uniswap B2 pair contract inside here. The first input will be the sender, and for the input it's going to pass messagesender. Okay, going back to our contract, so in this case the sender will be messagesender. And whose message sender? Well, message sender is eap. So here the input sender will be eap, and it's going to call the flashswap contract for the function uniswap b2 call. What just happened here is that eave called into a Uniswap B2 Pair contract and then the Uniswap B2 Pair Contract called into the flash swap contract.
03:17:27.981 - 03:18:07.291, Speaker A: So just by having this check that messagesender is a pair contract is not sufficient. We also need to check that this flashswap was initiated by the flash swap contract. And the only way to do this is to have these two checked. Messagesender is the pair contract, and the sender that was passed as the input is this contract. These two check will make sure that the flash swap was initiated by this flash swap contract and not someone else targeting to execute the flash swap contract. Okay, for the next step, I want you to decode token and caller from data. The data is the data that we encoded over here.
03:18:07.291 - 03:18:33.320, Speaker A: And this data was passed over to the function uniswap b2 call and you can see the data over here. So I want you to Decode this data. Remember that we encode it as token and caller. So here, here I want you to decode it as token and caller. You'll be using these input to pay for the fee on the flash swap. Next, I want you to determine the amount that we borrowed. And if you look at the input, we see amount 0 and amount 1.
03:18:33.320 - 03:19:03.189, Speaker A: When we requested to borrow, here we specify that one of them is greater than 0. So as a hint to determine the amount borrowed, only 1 of the amount 0 or amount 1 will be greater than 0. Once you determine the amount of tokens that you borrow, the next step is to calculate the fee. The fee to repay will be the borrowed amount times three divided by 997. And we need to be safe and round up. So we add +1. This is the fee that we'll need to pay.
03:19:03.189 - 03:19:34.755, Speaker A: And then the amount to repay will be the borrowed amount plus the fee. Get the flash swap fee from the caller, the caller that we decoded over here, and the token that we decoded over here. So call token transferfrom transfer from the caller to this contract for the amount fee. And the last step is to Pay the Uniswap B2 pair contract. Transfer the amount of token that you borrow plus the fee back to the Uniswap B2 pair contract. Okay, for the last part, let's take a quick look at the test. Here I have Uniswap V2 flash swap test SOL.
03:19:34.755 - 03:20:13.319, Speaker A: For the setup, we deploy the flash swap contract and then we'll fund this user with 10,000 Dai. This 10,000 Dai will be used to pay for the fee on the flashswap. So this means that the user approves the flashswap contract to spend tokens inside the test. This user will call the function flashswap on the contract flashswap. And this user will try to borrow one million dai. The test only checks that the balance of DAI inside the pair contract after the flash swap is greater than the balance of DAI in the pair contract before the flash swap. Okay, let's go over the solution for Uniswap B2 flash swap.
03:20:13.319 - 03:20:52.296, Speaker A: Let's start with the function flash swap. So again, this function will initiate a flash swap on uniswap B2 pair contract. The first thing that we'll need to do is determine amount 0 out and amount won out. Now these amounts, amount 0 out and amount won out can be determined by the inputs token and amount. And the way we do this is to compare this Input token with token 0 and token 1. If token is equal to token 0, then we know that this amount from the input refers to amount zero. So say amount and then for amount one we don't want to borrow this, so we put a 0.
03:20:52.296 - 03:21:26.859, Speaker A: Otherwise, if token is not equal to token 0, then we know that token is equal to token 1. So the amount of token 0 to borrow will be uint 2560 and the amount of token 1 to borrow will be the input amount. That completes step 1. Step 2 is to encode the data. So we'll need to encode the token and message sender. This is equal to abi, encode token and messagesender. Ok, the last step is to call the function swap.
03:21:26.859 - 03:21:53.702, Speaker A: On the pair contract I'll say pair dot swap and let's go back to the pair contract and see what parameters we need to pass. I'll just copy this as reference, then paste it here. We need to pass amount 0 out. This will be amount 0 out that we declared over here. Amount 0 out. The next input will be amount 1 out. Amount 1 out.
03:21:53.702 - 03:22:16.315, Speaker A: Amount 1 out. Okay, address 2. This will specify the contract to call the function UNISWAP B2 call. And we want the pair contract to call back into this contract. So for this we'll say address this. Okay, data. Again, remember that to trigger a flash flop, this data must not be empty data.
03:22:16.315 - 03:22:45.859, Speaker A: Okay, that completes the function for bash swap. Let's move on. The next function that we need to write is Uniswap B2 call. Okay, first check require messagesender is the pair contract. Require message sender is equal to the pair contract. Here the pair contract is initialized as the interface. So we'll need to cast it as address address and for the error message, I'll say nothing.
03:22:45.859 - 03:23:26.181, Speaker A: Pair. Once we know that the caller is a pair contract, the next thing that we'll need to do is check that this input sender is this contract. Require sender is equal to address this and for the error message I'll say not sender. Okay, the next step is to decode token and caller. So here I'll say abi decode decode the data that's coming in from the input. And the way we want to decode it is as address and address. Okay, Next determine the amount borrowed.
03:23:26.181 - 03:24:11.577, Speaker A: So how would we do this? Well, the amount that we borrowed is amount 0 and amount 1. These are the amounts that Uniswap B2 pair contract sent over to this contract. And from this we need to determine what is the amount that we borrowed. So there are two ways to do this, we can simply check whether amount zero is greater than zero or amount one is greater than zero. And here we can do this, because over here, when we specify the amounts to take out from the pair contract, we know that one of them is always going to be zero. So by checking that the other one is greater than zero, we know what amount borrowed. Another way to check what is the amount that we borrowed is to compare this token with token 0 or token 1.
03:24:11.577 - 03:24:53.317, Speaker A: For example, we can say token, is this Token equal to token 0? If it is, then we know that the amount that we borrowed is amount zero. Otherwise, we know that the amount that we borrowed is amount one. Okay, the next step is to calculate fees. Fee is borrowed amount times three divided by 997 and plus one to round up. So say amount times three divided by 997 plus one and the amount to repay will be the amount borrowed plus the fee. Okay, the next step is to have the caller pay for a flash swap fee. So say IERC20 token.
03:24:53.317 - 03:25:41.161, Speaker A: This token is decoded from the input data token.transfer from transfer from caller. This caller is also decoded from the data and this data is passed as an input for the function use B2 call, which was passed from the function flashswap. We encoded the data as token and message sender. So over here the caller will be the account that called into the function flashswap. And we're having the caller of the function flashswap to pay for the fees, pay to address this for the amount fee. And the last step is to transfer the amount borrowed plus the fee to the pair contract.
03:25:41.161 - 03:26:52.297, Speaker A: IERC20 token transfer to address pair for the amount amount to repay. Okay, let's try running the test inside my terminal. I'll first paste my fork UIO environment variable and then to execute the test, I'll type forge test dash dash fork URL fork URL match path test uniswap B2 exercises uniswap B2 flashswap test SOL BBB okay, and our test passed for the Flash swap fee for borrowing 1 million Dai, we pay this much amount to die. Let's check what this amount is. Copy this, open a Python shell, paste the number and then divide this by 1:18. So for borrowing 1 million Dai, we have to pay pay roughly 3,009 Dai for the flash swap fee. It's easy to get the USD price of ETH using programming languages like JavaScript or Python.
03:26:52.297 - 03:27:35.715, Speaker A: All you have to do is call some kind of API to fetch the price. However, it is not easy to get the USD price of ETH in solidity without using a price Oracle. Price Oracles are special smart contracts that can give you the price of tokens, for example eth. Now you might have a brilliant idea to use Uniswap B2 pair contract as the price Oracle get the spot price of eth from a Uniswap B2 pair contract that holds WEF and some other stablecoin like Dai. However, in this video I want to explain the danger of using Uniswap B2's spot price for a price Oracle. The danger of using Uniswap V2AMM's spot price as a price Oracle is that the spot price is very easy to manipulate. So let me give you an example.
03:27:35.715 - 03:28:14.187, Speaker A: Let's say that there's a lending protocol. This lending protocol allows you to borrow DAI if you lock ETH as collateral. The maximum amount of DAI that this user can borrow is 80% of the collateral value in Dai. And the way that this lending protocol calculates the collateral value in DAI is by getting the spot price from Uniswap B2 pair contract from the Pair Dai ref. So for example, let's say that this user locks 1 ETH as collateral. The lending protocol will get the spot price of ETH by creating the DAI ref pair contract in Uniswap B2. Let's say that the current price of eth is roughly 2000 Dai per eth.
03:28:14.187 - 03:28:49.549, Speaker A: The user locked 1 eth and 1 eth is worth 2000 Dai. So the collateral value in Dai will be 2000 Dai. And then 80% of that will be 1600Dai. So the user can borrow a maximum but of 1600 Dai. So let's say that this user borrows 1000 Dai. Now I'm going to show you how to manipulate the spot price of EIF given by the DAI with pair contract to exploit the lending protocol. The way that a hacker can exploit this lending protocol is by manipulating the spot price of ETH and then borrowing a lot of Dai.
03:28:49.549 - 03:29:39.777, Speaker A: So let's say that this hacker has 10 million Dai and 100 ETH. The hacker will first make the spot price of ethical expensive. The way he will do this is by buying ETH from the DAI ref pair contract, put in 10 million Dai that he has and then buy 832ref. At this point the spot price of ETH has spiked. Up next, the hacker will borrow DAI from the lending protocol, put in 100 ETH that he has as collateral and then he's going to borrow as much of DAI as possible from the lending protocol. The lending protocol will get the spot price of ETH by querying the DAI ref pair contract. And since the hacker has artificially spiked up the spot price of beef by buying a lot of EIF before borrowing, now the spot price of beef is 71,819 Dai per eth.
03:29:39.777 - 03:30:13.339, Speaker A: And now this hacker is going to borrow the maximum amount of DAI that he can borrow. The maximum amount of DAI that he can borrow is 80%. So 0.8 times the spot price of beef, 71,819 Dai times the amount of collateral that he locked 100 ETH. And this is equal to 5,745,599 Dai. And the last step is to undo the artificially inflated spot price of beef. The hacker will put back in 132ref and then get back 9,989,964.
03:30:13.339 - 03:30:47.823, Speaker A: Daisy. The reason why the hacker does not get back 10 million Dai that he put in is because some of the DAI was taken out as swap fee. Let's calculate how much money this hacker made by borrowing over 5 million DAI. First, the hacker put in 10 million DAI into the Uniswap B2 pair contract. And at the end he got back 9,989,964 DAI. Next, the hacker locked up 100 ETH as collateral into the lending protocol. And let's say that the spot price of eth is roughly 2000 Dai.
03:30:47.823 - 03:31:21.417, Speaker A: Now, because this hacker locked 100 ETH as collateral and he took out a loan of over 5 million Dai. And after the hacker does his second swap to bring the spot price back to around 2000 Dai. Now he has borrowed more DAI than the amount of collateral that he locked. So we assume that this hacker cannot take out the collateral that is locked inside the lending protocol. So he lost 100 ETH, which he cannot take out. It's locked inside the lending protocol. And we also say that the spot price of eth is around 2000 Dai per eth.
03:31:21.417 - 03:31:56.513, Speaker A: So 100 eth times 2000 Dai. This is the amount of ETH that he lost since it's locked inside the lending protocol. And then he borrowed 5,745,599 Dai. When we add all of these up, we get that the hacker made a profit of 5,535,563 DAI. So this was an example of how easy it is to manipulate a spot price of amm. And how if another protocol was relying on the spot price of AMM, how it can be exploited. Inside the contract Uniswap B2 pair, there's a function called update.
03:31:56.513 - 03:32:45.173, Speaker A: This internal function is executed whenever we call swap or add or remove liquidity. And inside this function there are two state variables called price 0 cumulative last and price 1 cumulative best. What these two state variable do is it sums up the current spot price and then multiplies it by the time elapsed, where time elapsed is the last time that this function update was called. Using these two state variables, we can create a price oracle. The price will be calculated using Time Weighted Average price. But hold on, what is Time Weighted Average price? And how do we use these two state variables to calculate Time Weighted Average price? Over the next few videos, I'll explain what time Weighted Average price is and how to use price cumulative to calculate this Time Weighted Average price. Okay, let's start with definitions.
03:32:45.173 - 03:33:20.193, Speaker A: Let's say P of I is the price of token X in terms of token Y between the time T and less than T. So there are two parts to this definition. Let's start with the first part. Price of token X in terms of token Y. In the video about spot price, we said that this is equal to Y divided by X the amount of token Y in the Uniswap B2 pair contract divided by the amount of token next in the Uniswap B2 pair contract. Okay, and the second part between time t less than T. So you see this I over here.
03:33:20.193 - 03:33:54.213, Speaker A: It tells us that this price only applies for time between T and t. And to keep the equations concise, we'll also define delta of t. Delta of T will be the time difference between T and t. And here's an example of P and T. On the horizontal axis we have some timestamps T, T and so on all the way up to t. And we also say that the current time we will have a special label for this. Let's call this T.
03:33:54.213 - 03:34:29.153, Speaker A: And we also have a special notation for the current price P. And for each T we have a P of I. For example, for T we have P of 0. So the price between T and less than T will be p of 0. The price between T and time less than T will be t, and the price between T and T will be P, and so on. There are two things that I want you to remember here. The first thing that I want you to remember is that the time in between these two T is not regular.
03:34:29.153 - 03:35:13.405, Speaker A: For example, we can see visually that the time difference between T And T is smaller compared to the time difference between T and T. What we're saying here is that the time interval between T and the next one, T, is irregular. And the other thing that I want you to notice is that the price jumps at each T. For example, at T we have the price over here. And at time t of 3, the price jumps up to P. The reason why I am graphing the price and time like this is to model the transactions that are sent to the Uniswap B2 pair contract. Transactions to the Uniswap B 2 pair contracts are are sent at an irregular time.
03:35:13.405 - 03:35:47.545, Speaker A: For example, let's say that a transaction was sent at T1 and then another transaction was sent at T2. And let's also say that in between T1 and T2 there are 10 seconds. The next transaction that is sent after T2 is not guaranteed to be 10 seconds after. For example, there might not be any users that's going to call the Uniswap B2 pair contract for the next minute. So that is why the time is modeled as irregular intervals. And every time a user sends a transaction, the price on the Uniswap B2 pair contract will change. So that is why you see a jump in prices.
03:35:47.545 - 03:36:29.541, Speaker A: Okay, so with that said, let's now talk about time weighted Average price. How do we calculate a time weighted average price of this graph? The big picture of how to calculate the time weighted Average price is to calculate the average of these prices. And each price will be multiplied by some kind of weight. And this weight will be calculated by the fraction of time that this price was in divided by the whole duration. Let me give you an example. Let's say that we wanted to calculate the time weighted average price from time T0 all the way up to TN. We'll need to take an average of the prices P0, P1, P2, P3, and so on, all the way up to p to the N minus 1.
03:36:29.541 - 03:37:02.515, Speaker A: So we're going to add all of the prices from time t 0 all the way up to time t. This is p 0, p 1, p 2, and all the way up to price p to the n minus 1. Next, for each of these prices, we will calculate a weight. The way we will calculate this weight is by calculating how long the price was at P0. So this will be T1 minus T0. And then divide this by the hold duration Tn minus T0. So the duration that the price was at P0 will be T1 minus T0.
03:37:02.515 - 03:37:33.165, Speaker A: And we defined over here a short way to say T1 minus T0. This will be delta of T0. And you can see over here we divide this by the whole duration that we're taking. The time weighted average price. The duration here we set as tw from t0 to tn. So the whole duration will be t minus t0. This fraction delta of t0 divided by tm minus t0 represents the percentage of time that the price was at P0 in the time between 10 and T0.
03:37:33.165 - 03:38:00.171, Speaker A: And then we do the same for price P1. The price was at P1 from the time T1 to T2. Again, we will use this notation to write it concisely as delta of T1. And again we divide this by the whole duration that we're taking. The time weighted average price of this is TM T0. And again we do the same for price P2. The time duration that the price was at P2 is T3 minus T2.
03:38:00.171 - 03:38:29.111, Speaker A: We'll use this notation again to write it as delta of T2. Then divide this by the whole duration T minus T0. We continue doing this until the last price, the last price that is less than the time T is P. The time interval is T and T, the time in between T and T minus 1. We write it as delta of t. And then we divide this by the whole duration t minus T. We'll go through an example later.
03:38:29.111 - 03:39:17.531, Speaker A: But if we calculate this, you'll get the time weighted average price from time T0 to 10. Let's modify this equation a little bit. What if we wanted to take the TWAP from time TK to tn. So if I scroll up, this equation describes the example for the time weighted average price from time T0 to to TN. But what if we wanted to take a different time weighted average price? What if we wanted to take the time weighted average price from time TK to tn? Well, once we understand how the time weighted average price from T0 to TN is calculated, it will be a simple modification of this equation to get the time weighted average price from TK to tn. So let's do that to calculate the time weighted average price of sometime TK to tn. We'll start with this equation.
03:39:17.531 - 03:39:53.575, Speaker A: And all we have to do is replace the 0 with a k and then add k to each index. So this zero will turn into a K same as bottom. And the duration will be from t to tk. And instead of having delta of t1, this will be delta of tk plus 1. Price will be pk plus 1. The third term will be delta of t k plus 2, price will be pk plus 2 and so on until the last term. We can write this term more concisely.
03:39:53.575 - 03:40:30.413, Speaker A: You can see that each term has a delta of T and then some index and then a price and then some index. And on the bottom they all have T of N minus T. First thing that I'll do is I'll copy this and then paste it here. And then instead of this K being a specific index, we'll generalize this to say t. And lastly, this index I will go from I equals k to I n minus 1. You can see over here that when I is equal to K, we get the first term. When I is equal to K plus 1, we get the next term.
03:40:30.413 - 03:40:56.135, Speaker A: When I is equal to k plus 2, we get the third term, and so on. And the last term. When I is equal to M minus 1, we get the last term. We will simplify this equation one more step. So what I notice is that for all of these terms inside this summation, they have a T minus T of K. So we can pull this out from inside the summation N to outside. So what we will get will be this.
03:40:56.135 - 03:41:37.851, Speaker A: Inside the summation we will have a delta of T of I times P. Once we take this summation, we divide it by the whole duration t minus T. And for now, this will be the final form of equation for how to calculate the time weighted average price from time TK to tn. In the next video I'll introduce cumulative price and how to rewrite this equation using cumulative price. In the last video we came up with an equation for the TBOP runtime TK to tn and it is described by this equation. And using this equation to calculate the twap, we'll need to know the price at each time t and the duration delta of t. So you can imagine that inside solidity.
03:41:37.851 - 03:42:23.723, Speaker A: If we store this delta of T and this price P of I inside our array and then run a for loop, then we can calculate this equation. However, there is a shorter way to calculate this equation. We won't need a for loop and we also won't need an array. We only need one state variable and this is done by storing a single state variable called cumulativeprice. So in this video I'll explain what cumulative price is and how to use this cumulative price to calculate the T waf from time TK to tn. Let's first start by defining what cumulative price is. We'll name it C and C will be equal to the cumulative price up to time tj and this will be equal to the sum From I equals 0 to J1.
03:42:23.723 - 03:43:06.089, Speaker A: And inside the summation, we'll do delta of t T. This equation that you see over here is similar to this equation. This equation describes the t from time TK to tn. The only difference is over here the summation starts from I equals to k, Whereas over here the summation starts from I equals zero. Now, with this cumulative price, we can now rewrite this top part of the equation. So what I'm going to do is I'll copy this top part of the equation and then paste it here. Our goal is to rewrite this equation in terms of cumulative price c of j.
03:43:06.089 - 03:43:37.033, Speaker A: We will start by expanding this equation. The first term will be delta of t of k times p of k. And the last term will be for I equals to m minus 1. So we'll have delta of t of n minus 1 multiplied by p of m minus 1. Again, the next step is to rewrite this in terms of cumulative price. We can rewrite this top equation by taking the sum from I equals to 0 all the way up to I equals to n minus 1. And now we have some extra terms.
03:43:37.033 - 03:44:24.275, Speaker A: The extra terms are delta of t of 0 times times p of 0 and all the way up to delta of t of k minus 1 times p of k minus 1. And these terms delta of t of k times p of k and all the way up to delta of t of n -1 times p of n -1. These terms are the exact same terms as these terms. So we have some extra terms over here. So we'll need to subtract these terms. And we do that on the next line, we subtract delta of tr0 times p0 plus all the way up to delta of trk minus 1 minus pk1. So what you're seeing over here is that the first k terms, all of these will cancel out with all of these terms.
03:44:24.275 - 03:44:58.177, Speaker A: The terms on the first line is C. We're taking the sum From I equals 0 all the way up to I equals M minus 1. The terms on the second line are cumulative price c of k. So if you plug in k over here, this would mean that c of k is the cumulative price up to time tk. And you can check for yourself that if you replace this j with a k and then unpack this equation, then you'll get these terms. So the terms in the first line are cn. And then from here, we're subtracting c of k.
03:44:58.177 - 03:45:32.811, Speaker A: So we get c of n minus c of K. So now we can rewrite this equation the 12th from time Tk to Tn using cumulative prices. I'll copy this and then paste it here. And here is our original equation for twop from time TK to tn. And we're going to rewrite this using cumulative price. So what we did over here is that we said that this top part is equal to CN minus ck. So I can just remove all of this and then put a CM minus CK over here.
03:45:32.811 - 03:46:13.531, Speaker A: And this equation tells us how to calculate the twap from time TK to TN using cumulative price. This cumulative price is a single state variable stored inside Uniswap B2 pair contract. By taking the price cumulative at two different times, let's say at time Tn and at time Tk. Then we will be able to calculate the time weighted average price from time TK to tn. Let's go over an example of calculating a twap from time tk to tn using this equation. Let's say that at time t1, the price of token x is equal to 1000. At time t3, the price increases to 1100.
03:46:13.531 - 03:46:50.004, Speaker A: At time t4, it increases to 1300. And at time t7, the price drops to 1200. And at time t11, the price jumps back up to 1500. For this example, let's calculate the twap from time t4 to time t11. So we're taking the price average from time t4 over here to time t11. The way we will do this is we'll fill out this table on the very left. We'll fill out with the time that the price changed 1, 3, 4, 7, 11.
03:46:50.004 - 03:47:12.969, Speaker A: Next, we'll fill out the prices. At time T1 it was 1000. At time T3 it was 1100. And at time T4, the price was at 1,300 and so on. Next, we'll calculate this delta of t of I times P of I. And afterwards we'll calculate the cumulative price. Okay, let's begin by calculating delta of t of I.
03:47:12.969 - 03:47:35.471, Speaker A: Multiply by P. ABY. To calculate delta of t ABY for time t1, we need to know how long the price was at 1,000. And we only know this when the price changes at time T3. So our first calculation will be inside here. The duration that the price was at 1000. This will be from time equals 1 to time equals 3.
03:47:35.471 - 03:48:09.227, Speaker A: So the duration will be 3 minus 1. Okay, so that's delta of ti for the first term. And during this duration, from time t1 to 3, the price was at 1000 so p for the first term will be 1003. One is two times 1000 is equal to 2000. And we'll initialize price cumulative as zero. So now the price cumulative is 2000. Again, as a reminder, what price cumulative does is we're going to sum up all of these delta of T times P of I.
03:48:09.227 - 03:48:39.097, Speaker A: This is the first term, so it equals this term. Okay, let's move on to the next term. From time t equals 3 to 4, the price was at 1,100. So the duration will be 4 minus 3. And for that one second, the price was at 1100. One times 1100 is equal to 1100. And now to calculate the current price cumulative, we take the previous price cumulative and then add this new term.
03:48:39.097 - 03:49:00.446, Speaker A: So this will be 2000 plus 1100. And this is equal to 3100. Okay, moving on. From time t equals 4 to time t equals 7. The price was at 1,300. So this delta of t of I, the Duration will be 7 minus 4. And the price was at 1300.
03:49:00.446 - 03:49:30.131, Speaker A: 7 minus 4 is 3 times 1300 is equal to 3900. And now we need to add this 3900 to the current cumulative price, which is equal to 3100. 3100 plus 3900. This is equal to 7000. Okay, we'll do the last term. From time 7 to 11, the price was at 1200. So the delta time will be 11 minus 7.
03:49:30.131 - 03:50:02.865, Speaker A: And the price was at 1200. 11 minus 7 is 4 times 1200. This will be equal to 4800. And now we add this 4800 to the current cumulative price, which is equal to 7000. 7000 plus 4800 is equal to 11,800. Now we know all of the cumulative prices, so it's easy to calculate the t wop from time T4 to time T11. To calculate this twop using cumulative price again, we'll use this equation.
03:50:02.865 - 03:50:25.149, Speaker A: I'll copy this and then paste it here. And then we'll replace these numbers. T will be 11. T will be 4. This is the duration that we're taking the time weighted average price up. Now we need to figure out what CN is and what CK is. CN will be the latest cumulative price.
03:50:25.149 - 03:51:07.211, Speaker A: So this will be 11,800. And from this cumulative price, we need to subtract all of the cumulative price that is less than or equal to time t equals 4. So at time t 4, we have the cumulative price equals 3,100. So we need to subtract 3,100 for from here, 3,100. And we can visually see that we're on the right track at time t equals 4. Over here, we've taken the price cumulative of this 1000 and this 1100. And this 11,800 is the cumulative price from time t1 all the way up to time t11.
03:51:07.211 - 03:51:45.954, Speaker A: We're taking the price cumulative of 1000, 1,100, 1300, and 1200 to get the twap from time t4 to 11. From this price cumulative from time t1 to 11, we need to subtract the price cumulative from time t1 to 4, and this price cumulative is equal to 3100. So we're on the right track. The last step is to actually calculate this. And this turns out to be approximately 1200 42. And this number sort of makes sense. We're taking the average price from time T4 to 11.
03:51:45.954 - 03:52:28.265, Speaker A: And in between these times, the price was at 1,300 and at 1200. So we can expect that the price will be somewhere between 1,200 and 1300. Furthermore, the price was at 1,300 for 3 seconds, and the price was at 1200 for 4 seconds. This is 1 second longer than the price at 1,300. So we can expect this time weighted average price to be a little bit below than 1,250. And what we see over here is that this twap is less than 1,250. And this is because the price was at 1,201 second longer than the price was at 1,300.
03:52:28.265 - 03:53:09.631, Speaker A: So far, I've explained how to calculate the time weighted average price from time TK to tn. To calculate this twap, we use the cumulative price. And to calculate this cumulative price, we need to know the duration that the price was at some value. However, for the last term, this is still undefined. So if you look at the graph, we can see that the price is at P and it started at time t, but this price is still at P and it still has not ended. So the duration that the price is at P is still unknown. So it looks like we cannot calculate the twap from some time TK to the current time t.
03:53:09.631 - 03:53:53.227, Speaker A: However, we can. So in this video, I'll explain how to calculate the twap up to current time. To calculate the twap from sometime TK to the current time t, we imagine that the price was at P from 10 up to T. And then we replace this current time T with a T to the N plus one. So this T, we set this equal to T to the N plus 1, and we treat this current price P as P to the N. So we set the current time T to T to the n plus one and the current price P to P to the N. We don't know how long the price will be at the current price, but up to the current time we know that the price is at P.
03:53:53.227 - 03:54:38.141, Speaker A: So we replace the current time T and and the current price P, like the timestamps before and the prices before. And now, by setting T equals to T to the n plus one and the current price P equal to P to the N, we can use the equations that we've been using. Here's the equation that we've been using to calculate the twap from time TK to t. And now to calculate the twap up to the current time, we will replace this T of n with t1. Now, again, remember that T is equal to the current time t and C of N will be C of N +1 and T will be T. Next, we'll simplify this equation. Let's start with C of N +1.
03:54:38.141 - 03:55:07.035, Speaker A: So by definition, C will be this. The cumulative price up to time T. I'll paste it here. So C of N +1. I'm going to replace this J for N +1 will be equal to summation from I equals 0 up to J1. We replace this J with N +1 minus 1. So simply N.
03:55:07.035 - 03:55:35.695, Speaker A: Next, I'm going to expand this equation. We can rewrite this equation as a summation up to M minus 1. And for the last term, we'll just simply write it as delta of T of N + P of N. We're just pulling out the last term from the summation. The first term, the summation up to N minus 1 will be equal to C of N. This is the cumulative price of the time t. And then next we'll expand this term.
03:55:35.695 - 03:56:24.077, Speaker A: So, scrolling back up, I'm going to copy the definition of delta of t and then paste it here. So, delta of t, this is the definition. So how about delta of t of n? Delta T of N will be equal to T of N + 1 minus T of N. Over here we said that t of n +1 is equal to the current time t. So delta of t of N will be equal to the current time t minus the last time that the price updated T of n. And now we can rewrite this part of the equation as plus delta T of N. We will replace this with this term and we get this equation.
03:56:24.077 - 03:57:18.279, Speaker A: This equation tells us that if we wanted to approximate the current cumulative price C of N plus 1, then what we have to do is take the previous cumulative price c and then to this we add the last time that the cumulative price was updated t of n and then the current time so t minus t of n and then multiply by the current price p. And now we can rewrite this equation so this will be equal to. Here we rewrote C of N +1. So we'll replace the C of N +1, C of N +1 is equal to this term. The latest cumulative price c of n plus the approximation using the current price minus the price cumulative of the time tk. And then we'll need to divide by the whole duration. Again, T is equal to the current time t.
03:57:18.279 - 03:58:09.933, Speaker A: So we get this equation and when we implement a twop using Uniswap B2 pair contract, we will use this equation to get the time weighted average price. This will be the last video about math for twap in Uniswap V2. Here I want to explain about a misconception that if you know the twap of token x, then you can get the twap of tokeny by doing one over the twap of tokenx. This is not true, and in this video I want to quickly explain why this is not. First of all, if we look at the spot price of token X in terms of token y in Uniswap B2, we can write this as Y divided by x. And if we flip this Y divided by X, we get X divided by Y and this is spot price of token Y in terms of token X. In other words, if we know the spot price of token X in terms of token Y, let's call this P.
03:58:09.933 - 03:58:55.381, Speaker A: Then if we take one over P, then we get the spot price of tokeny in terms of token nets. However, we cannot apply this same logic to say that the top of token Y is equal to one over the t of token x. And here's Y as we discussed in the previous videos, the T of token X from time TK to TN is given by this equation. The equation for the TP of token Y is almost similar to this equation. The only difference is is that we need to take a spot price of token Y in terms of token X. This is given by 1 over P of I. And it's hard to imagine that taking one over the t wap of X, so taking one over this equation will be equal to this equation.
03:58:55.381 - 03:59:40.083, Speaker A: If you're curious, you can do the math and check that taking one over this equation will not be equal to this equation. Let's take a look at the code that is relevant to twop. The part that is relevant to twop is inside the contract uniswap b2 pair. And the function that we'll have to take a look at is the internal function called update. And inside this function, the code that we'll need to take a look at is over here, the part that updates price zero cumulative last and price one cumulative last. This internal function update is called whenever we do a swap, add or remove liquidity. So when a user swaps, adds or removes liquidity, price 0 cumulative last and price 1 cumulative last will be updated.
03:59:40.083 - 04:00:13.037, Speaker A: Let's see how these two state variables are updated. Let's start with price 0 cumulative last. Here. What this code is doing is to the current value of price 2 cumulative last. It's adding some uint and then multiplying it by the time elapsed. Where time elapsed is the last time that this internal function update was called. And we can see here that time elapsed is block timestamp minus block timestamp last, where block timestamp is the current block timestamp casted into uint32.
04:00:13.037 - 04:01:06.698, Speaker A: And block timestamp last is updated to the current block timestamp every time this function update is called. So time elapsed is a difference in time since the last time this internal function update was called and the current block timestamp. Okay, so going back to this line of code, we see here that it's multiplying time elapsed by something more complicated. What this part of code is doing is it's calculating the spot price of token zero in terms of token one. And this is done by dividing reserve one by reserve zero. Now, as you know, if you divide a small number by a large number in solidity, the division will return a zero, since solidity does not support decimals. To represent this spot price as decimals, Reserve 1 is encoded as UQ112/112.
04:01:06.698 - 04:01:48.745, Speaker A: And what this UQ112/112 does is it can represent a number as decimal. And the way it does this is it splits the number into two parts. The first 112 bits represents decimals, and the next 112 bits will represent whole numbers. Let's take a look at this library. UQ 112 times 112. This library is inside the repo B2 core under libraries and I'll open this library called UQ 112 times 112. Remember that back in our Uniswap B2 pair contract, the first thing it does, it calls a function called encode on reserve 1.
04:01:48.745 - 04:02:41.166, Speaker A: If we check the library, the function encode what it will do, it will first cast this input into uint 224, and then it multiplies by Q112, and this Q112 is equal to 2 raised to the power of 112. And this number is the same as shifting 1 to the left 112 times. So what this part of code is doing is it's taking the number y and then it's shifting this number Y to the left by 112 bits. And this is how the first 112 bits will represent the decimal part and the next 112 bits will represent the whole number part. Okay? So going back when this function is called uq112times112. Encode encode reserve1. So it's encoding reserve1 as a whole number.
04:02:41.166 - 04:03:19.928, Speaker A: And again, the last 112 bits represents decimals to this number we call uqdiv with reserve0. Let's go back to the library uqdiv. For the first input, this will be Reserve 1 multiplied by Q112. And for the second input, we're passing in Reserve 0. So when this function UQDIB is called, what it's going to do is again we said X, let's say is Reserve 1 times Q1, 1, 2. And then for the next input, we'll pass in Reserve 0. Reserve 0.
04:03:19.928 - 04:04:09.968, Speaker A: Now, it's easy to see that what this Nino code is doing is that it's multiplying Reserve 1 times some large number 2 raised to the power of 112, and then dividing it by Reserve 0, Reserve 1 divided by Reserve 0. We know that this is a spot price of token 0 in terms of token 1. And since solidity cannot support decimal numbers, we multiply this spot price by a large number and then say that the first 100/12 bits represents the decimal part and the next 100/12 bits represents the whole number part. Okay, so let's go back to uniswap B.2 pair contract. So that's this part of the code. It calculates the spot price of token 0 in terms of token 1 and then multiplies it by Q1, 1, 2.
04:04:09.968 - 04:04:43.213, Speaker A: And the next line does something similar. Price 1 cumulative last to the current price 1 cumulative last. Add the spot price of token 1. So this will be reserve 0 divided by reserve 1. Encode it as UQ 112 times 112. So this would mean that we will multiply reserve 0 by 2 raised to the power of 100 and 12 and then dividing it by reserve 1. This will give us the spot price of token 1 in terms of token 0 multiplied by 2 raised to the power of 112.
04:04:43.213 - 04:05:25.777, Speaker A: And then to this number we multiply time elapsed and that is how price 0 cumulative last and price 1 cumulative last are updated. Now the last thing that I want to mention here is this comment. Multiplication never overflows and addition overflow is desired. Let me first explain what this comment means, that multiplication never overflows. What this is saying is that when we multiply this UINT by time elapsed, this number will be less than or equal to the maximum of uint256. And to see this, we see that time elapsed is uint32. So this will take up 32 bits.
04:05:25.777 - 04:06:00.999, Speaker A: And then we have over here that the result of UQ Div. Let's take a look at this. The result of UQ Div returns uint224.uint224 will take up 224 bits. Okay, so going back, this part of the code will use up 224 bits at most. And this part of the code will use up 32 bits at most. If we add 224 to 32 bits, this will be equal to 256 bits.
04:06:00.999 - 04:06:38.339, Speaker A: So the first part will use up maximum 224 bits and the next part will use up maximum 32 bits. So when we multiply this, it will use up maximum 256 bits. And 256 bits is contained inside uint 256. And that is what it means over here that multiplication never overflows. Okay, and let's move on to the next part that addition overflow is desired. This is a little bit surprising. Why is it that overflow is desired here? Usually when numbers overflow, it will introduce some kind of bug.
04:06:38.339 - 04:07:31.925, Speaker A: However, over here, why is it that overflow is desired? And the answer is, the way we calculate time weighted average price, we need to take the difference of the two cumulative prices. So this means that even if the current cumulative price, these state variables overflow, when we take the difference of the two cumulative prices to calculate the time weighted average price, the difference will give us the correct time weighted average price. Whether these cumulative prices overflowed or not. If that explanation of why overflow is desired here didn't make sense, don't worry, I'll explain more when we write the code for twap. And that completes the code review for the cumulative prices. For this exercise, I want you to write a price Oracle using Uniswap B2 time weighted average pricing. This exercise was modified from the example in this link over here.
04:07:31.925 - 04:08:09.825, Speaker A: And please do not use this contract in production. The reason is it's importing a library called Fixed Point from over here. Now, this Fixed point library, I copied it over from Uniswap B2. Here's the original code for Fixed Point library. You can see over here that this code was written for Solidity compiler version greater than 0.4. However, to make this code work with Foundry, I had to change the solidity version to 0.8. And when I did that, I had to wrap some of these advanced math using unchecked disabling the overflow and underflow.
04:08:09.825 - 04:08:46.025, Speaker A: So there might be some bugs that was introduced by changing the compiler version. And that is why I don't want you to use this code in production. Okay, so with that said, let's take a look at the contract. First, it's going to import Fixed point, and you'll be using this to store the twap of token zero and token one. Okay, so there are four exercises to complete this contract. The first exercise is to initialize the constructor. The second exercise is to complete the internal function that will calculate the cumulative price up to the current timestamp.
04:08:46.025 - 04:09:21.649, Speaker A: Next, the third exercise will be a function to update the cumulative prices. In the last exercise is a function that will return the equivalent amount of other token given. Tokenin and amount in. Let's scroll back up and I'll explain what the contract does and also explain the exercises. Minimum wait time is the minimum time in seconds before the function update can be called again. Next, we have some immutable variables that you'll need to initialize inside the constructor. Okay, moving on.
04:09:21.649 - 04:10:31.825, Speaker A: Price 0 cumulative last and price 1 cumulative last and timestamp updated at the units for price deal, cumulative last and price 1 cumulative last are the price, which is encoded as UQ112 times 112. And then we multiply this by the seconds which will be uint32. And this is because if you go to Uniswap B2 pair contract and inside the internal function called update, let's check the units for price 0, cumulative last and price 1 cumulative last. When we do this operation, the Price, the spot price will be encoded as UQ112/112. And then when we multiply this by time elapsed, time elapsed is unit 32. So these cumulative prices are encoded as UQ112 times uint32. And to keep this the same inside our t contract, remember that the units for these State variables are UQ 112 times 112 of the price multiplied by seconds, which will be in uint32 every time these cumulative prices are updated.
04:10:31.825 - 04:11:08.997, Speaker A: We'll store the timestamp when the cumulative prices above are updated. Okay, moving on. Price 0 average and price 1 average. Price 0 average will be the TAUP of token 0 in terms of token 1, and price 1 average will be the top of token 1 in terms of token 0. And both of them will be stored using the encoding of UQ 112/112. And again, what UQ 112/112 means is that the first 112 bits will represent decimal part and the next 112 bits will represent whole number part. Okay, let's move on.
04:11:08.997 - 04:11:45.415, Speaker A: For the first exercise, the first few instructions are easy. Set the pair contract, get token 0 and token 1 from the pair contract. Store price deal, cumulative last, and price one cumulative last. And these can be retrieved by calling the pair contract. And then afterwards, I want you to sync up this state variable updated at with the timestamp that is stored inside Unisoft B2 pair contract. So inside Unisoft B2 pair contract, there's a state variable called block timestamplast. This stores the last timestamp that these cumulative prices are updated.
04:11:45.415 - 04:12:26.517, Speaker A: I want you to get this and then also sync it in here and then store it inside a state variable updated at. This can be done by calling the function getreserves on the pair contract. Okay, moving on for exercise two is to complete the internal function get current cumulative prices. Okay, so this function will calculate the cumulative prices up to the current timestamp. For the first part of this exercise, I want you to get price 0 cumulative last, and price 1 cumulative last from the paired contract. Next, we'll need to do some additional math. If the current block timestamp is greater than the last timestamp, then the reserves and the cumulative prices were updated.
04:12:26.517 - 04:13:25.935, Speaker A: So first of all, we need to get the last timestamp that the reserves were updated. And you can do this by calling the pair contract and calling the function getreserves. Once you get the last timestamp that the reserves were Updated, we'll need to compare with the current timestamp since the block timestamp last is unt32. Here you'll need to cast block timestamp as a unit 30. And if they're not equal, then first I need you to calculate the difference in time the time elapsed since the last time the reserves were updated. And then I want you to calculate price tier cumulative last and price 1 cumulative last. As discussed in the video about the math for twop, the way we will calculate price, yield, cumulative last and price 1 cumulative last for the current time is to multiply the spot price by the time elapsed and then add this to the price dual cumulative last and price one cumulative last.
04:13:25.935 - 04:14:22.175, Speaker A: Now, price zero cumulative last and price one cumulative last are in units of UQ 112 times 112 times seconds. So you'll need to keep this in mind and you'll need to call the function fixed point fraction to calculate the spot prices. So if you look at the library fixed point and inside the function fraction, we see that it takes in two UN256 and then returns a UQ 112 times 112. Back inside the exercise. Once we have the spot price by calling fixed point fraction, we'll need to multiply by elapsed time. Elapsed time is uint32, and the data that is returned by calling the function fraction is UQ 112 times 112. This is a struct, and the struct has a single field called x.
04:14:22.175 - 04:15:04.585, Speaker A: We cannot multiply a struct by a number. So we'll need to access this internal data and then multiply it by the elapsed time. So that's the second part of this task is to cast the UQ 112 times that is returned by the function fraction, get the internal data and then cast it into UN 256. And once we have the UN 256 of the spot price, you'll need to multiply this by the time elapsed dt. Okay, let's move on to the third exercise. For the third exercise, I want you to complete the function update. This function will update the cumulative prices by calling the internal function get current cumulative prices.
04:15:04.585 - 04:16:01.237, Speaker A: Again, for the first part of this exercise, I want you to cast the current timestamp as un32. And the next part of the exercise is to calculate the time elapsed since the last time this function update was called. And the second part of this exercise is to calculate the time Elapsed since the cumulative prices that is stored inside this contract was updated. When the contract is deployed, it is updated over here, it will be updated over here, and the timestamp will be stored in the state variable updated. The other part that the price cumulative will be updated is inside the function update. And when this function is called, the state variable update should also be updated once we figure out what the time elapsed is. The next part of this exercise is to make sure that this time elapsed is greater than or equal to the minimum wait time.
04:16:01.237 - 04:16:58.413, Speaker A: This is to make sure that the prices that is used for the average pricing is taken over some duration. If we did not have this checked, then we can call the function update every block and have the time weighted average price close to the spot price. And to avoid this, we have this checked. Okay, the next part of the exercise is to call the internal function getcurrentcumulativeprice to get price 0 cumulative and price 1 cumulative. The next part of the exercise is to calculate the TWAP price 0 average and price 1 average. The way we will calculate the average prices is by taking the current cumulative price which we will get from here and here, and then minusing it with the last cumulative price. This will be stored in the state variables price till cumulative last and price one cumulative last and then dividing this difference by the time elapsed dt, which you computed over here.
04:16:58.413 - 04:17:57.617, Speaker A: And as A reminder again, price 0 average and price 1 average are stored as UQ112 times 112. Now notice that this part of the code is wrapped inside the unchecked which disables the check for overflow and underflow. The reason why we're disabling overflow and underflow here is that because the current cumulative price can overflow and then when we minus it with the last cumulative price, this whole part might underflow. However, inside here this is not a problem. This is because even if the current cumulative price overflows, when we subtract the current cumulative price with the last cumulative price and we get a difference using that difference, we still get the correct time weighted average price. And if you wanted to know more about this, go ahead and click on this link. And the last part of this exercise is to update the state variables price deal, cumulative last, price won, cumulative last and the timestamp updated at.
04:17:57.617 - 04:18:45.977, Speaker A: Okay, for the last exercise I want you to complete this function. Consult this function will return the amount out corresponding to amount in for a given token for the input it's going to take in Token in and amount in. And for the output, it's going to return the equivalent amount of token. Now, for example, let's say token 0 is ref and token 1 is USDC. We also say that for the input we passed in ref and amount in is 2, we will need to return the equivalent amount of 2 ref. In terms of USDC, let's say that the average price is 2000 USDC per 1 ref and then for the output it's going to be the price average. This will be 2000 USDC per one WAF times the amount of WAF2 we and this will be equal to 4000 USDC.
04:18:45.977 - 04:19:28.813, Speaker A: The first part of the exercise is to require that token in is either token 0 or token 1. The second part of this exercise is to calculate amount out. To calculate amount out, you'll need to take the twap of token in and then multiply it by amount in. Amount in comes from from the input and twap of tokenin will either be price 0 average or price 1 average. The TWAP's price 0 average and price 1 average are encoded as UQ112 times 112. And we'll need to multiply this by amount int. So to do this you'll need to use the function multiply inside the library fixed point.
04:19:28.813 - 04:20:05.148, Speaker A: So if you take a look at this library, here's the function multiply. For the input, it's going to take in UQ 112 times 112 and UNINT 256. Now it's going to return UQ 144 times 112. This means that the first 112 bits is decimals and the next 144 bits is the whole number. We'll only return the whole number part. So once we have UQ 144 times 112, we will need to decode this into UINT 144. And we can do this by calling the function decode 144.
04:20:05.148 - 04:20:27.439, Speaker A: Calling this function will return a UINT 144. Okay, so that's exercise four. Let's go over the solution for Uniswap B2 twap. The first exercise is inside the constructor. Set the pair contract from constructor input the input pair. So inside here I'll replace this with the input pair. Okay.
04:20:27.439 - 04:21:19.495, Speaker A: The second part, set token 0 and token 1 from the pair contract. So this will be the pair contract was initialized in step 1. So say pair token 0 and the next one will be token 1. The next step is to store price 0 cumulative last and price 1 cumulative last from the pair contract. So say price 0 cumulative last is equal to pair dot, price 0 cumulative last and price 1 cumulative last is paired at price 1 cumulative last. Okay, and for the fourth part of this exercise is to call pair getreserves to get the last timestamp the reserves were updated and then store it into the state variable updated at. We'll call the function pair dot get reserves inside unisoft b2 pair contract.
04:21:19.495 - 04:21:53.609, Speaker A: The function getreserves returns three outputs, reserve zero, reserve one and block timestamp last. So over here it's going to return three outputs reserve zero, reserve one, which we don't need. And the last one is block timestamp last. And then we'll store it to our state variable updated at. Okay, let's move on to exercise two. This is an internal function that will calculate the cumulative price up to the current timestamp. The first part is to get the latest cumulative price from the para contract.
04:21:53.609 - 04:22:26.267, Speaker A: And we already know how to do this. So I'll just copy this and then paste it here. This function is going to return the latest cumulative price as price, the accumulative and price. So instead of storing it into the state variable, we'll return it as a variable as price till cumulative and price form cumulative. Okay, the next part of the exercise is to get reserves in the last timestamp. The reserves are updated from the pair contract. We already know how to do this.
04:22:26.267 - 04:22:56.663, Speaker A: What we need to do is call the function pair dot get reserves. Okay, the next part, cast block timestamp to uint32. You can do this by saying uint32block.timestamp. Okay, next part, calculate elapsed time. Elapsed time will be the current timestamp block timestamp minus the last timestamp. Block timestamp last. Okay, moving on.
04:22:56.663 - 04:23:57.815, Speaker A: Price zero cumulative. So what this part of code is doing is that it first gets the latest price till cumulative and then if the last time that the cumulative prices were updated is not equal to the current timestamp, then we approximate it by calculating how long the current price has not changed and then adding this to price to accumulative. So to calculate the spot price, we'll say fixed point dot fraction. The spot price of token zero in terms of token one will be reserve one divided by reserve zero. And then let's go check the code for fixed point dot fraction inside the library fixed point and inside the function fraction. Calling this function will return UQ112 times UQ112. And this is a struct with a single field called underscore x.
04:23:57.815 - 04:24:41.387, Speaker A: We'll need to multiply this by dt. And obviously we cannot multiply a struct by a number. So to get the internal value we'll need to say dot underscore x. When we do this underscore x, we get a Uint 224 back. We'll cast it into Uint 2256 first say Uint 256 and then multiply by dt. Okay, we'll do something similar for calculating price 1 cumulative uint256 fixed point dot fraction here. To calculate the spot price of token 1 in terms of token 0, we will need to flip the division.
04:24:41.387 - 04:25:26.255, Speaker A: The numerator will be reserved 0 and the denominator will be reserve 1. Again, we get the internal value by saying underscore x, cast this into uint256 and then multiply by dt. Okay, that completes exercise 2. Moving on to exercise 3. Cast block timestamp to uint32uint32 block dot timestamp. Okay, again, the next part is to calculate dt. The current timestamp casted as UN32 is block timestamp and the previous time this function update was called or the cumulative price were updated is stored in a state variable updated at.
04:25:26.255 - 04:26:09.757, Speaker A: Okay, the next part is to require that this time elapsed is greater than or equal to min time. Require DT greater than or equal to min weight. Then for the error message I'll just say dt less than min weight. Okay, next call the internal function get current cumulative prices to get the current cumulative prices. So we need to call the function get current cumulative prices and for the input of get cumulative get current cumulative prices doesn't take any inputs and it returns the current cumulative prices price OR cumulative and price 1 cumulative. The next part is over here. Calculating the twap.
04:26:09.757 - 04:27:10.218, Speaker A: Let's start with calculating the twap of token zero. So twap will be price zero cumulative, the current price zero cumulative that we get by calling the internal function getcurrentcumulativeprices and then minus it by the previous one that is stored in the state variable price 0 cumulative. Last and now taking this difference, we need to divide this by the duration DT and then store it as a struct WQ 112 times 112. We will need to cast this whole thing into uint224uint224 and then we'll do the same for price one average. I'll copy this, paste it here and then change the zeros into a one, one over here and a one over here. Okay, and the last part of this exercise is to update the state variables. Price 0 cumulative last is equal to price 0 cumulative.
04:27:10.218 - 04:27:45.215, Speaker A: Price 1 cumulative last is price 1 cumulative and updated at is block timestamp. Okay, that completes the function update. The last exercise is consult. Require Tokenin is either token 0 or token 1. Require tokenin is equal to token 0 or tokenin is equal to token 1. Error message say invalid token. Okay, the next part is to calculate amount out.
04:27:45.215 - 04:28:18.337, Speaker A: Okay, let's start with if token n is equal to token zero. So if token name is token zero, then the way we will calculate amount out is by taking price 0 average multiplied by amount n. Now, price 0 average, if you look up, is stored as UQ112. So we'll need to use the library fixed point math. Fixed point math. And then inside here we'll need to call the function multiply. So say fixed point.mo
04:28:18.337 - 04:28:59.565, Speaker A: price zero average with amount in. And then calling the function multiply will return UQ144, which is a struct. And we'll need to decode this into a number uint144. We can do that by calling another function called decode144. So here I'll type decode144. Okay, we'll do the same for if token in is equal to token 1, amount out will be fixed point. Multiply the average price of token one by amount in and then decode it by calling decode144.
04:28:59.565 - 04:29:50.109, Speaker A: Okay, so that completes the exercise. Let's try running the test. I'll first initialize an environment variable for my fork URL, and then I'll execute the test by typing forge test fork URL fork URL matchpath test uniswap b2 exercises uniswap b2 twap test SOL VBB okay, and our test passed. For the last part of this video series on Uniswap 2, I'm going to show you two ways to do arbitrage with Uniswap B2 contracts. So let's say there are two Uniswap B2 contracts. We have Uniswap B2 and a fork of Uniswap B2 called Sushiswap. On Uniswap, let's say that one WAF is 3,000 Dai.
04:29:50.109 - 04:30:31.353, Speaker A: It is selling for 3,000 Dai on the fork of Uniswap V2 on Sushiswap, one ref is selling for 3,100 Dai. Here is a risk free opportunity to make some money. This user will buy ref from a place that is selling it for cheap and then sell it at another AMM that is willing to buy for a higher price. In our example, this user is going to buy ref from Uniswap B2, put in Dai and get back some ref and then sell this WEF on sushiswap, put in WEF and get back dai. Now to execute an arbitrage, this user had to have DAI to begin with. But what if this user did not have any daisy? Well, not to worry. We can borrow DAI from somewhere else and then execute this arbitrage.
04:30:31.353 - 04:31:08.397, Speaker A: So for example, let's say that we have another Uniswap B2 pair contract. Let's say that this pair contract is Dai MKR. Well remember flash swap. Flash swap allows other smart contracts to borrow token as long as the token and some fee is paid in the same transaction. So what we can do Here is Use FlashSwap to borrowdai, execute the arbitrage and then after the arbitrage repay the DAI MKR contract for the DAI that we borrowed. Let me go over this one more time. So to begin with, we'll say that this user sees an arbitrage opportunity but doesn't have any DAI to execute this arbitrage.
04:31:08.397 - 04:31:47.437, Speaker A: So what he can do first is borrow DAI using a flash swap from dai mkr uniswap b2 pair contract the next step is to execute the arbitrage. This user is going to buy ref an AMM that is selling ref for a cheaper price compared to other AMMs. In our example, this is uniswap buy ref by putting in DAI and then getting back some whef. And the next step is to sell this WHEF in an AMM that is selling for a higher price. In our example, this is sushiswap sell with by putting in WEF and then getting back dai. The last step is to repay the flash swap from the DAI that this user got back. He will repay the flash swap.
04:31:47.437 - 04:32:29.794, Speaker A: Let's go over an example of how to calculate the profit for an arbitrage. The basic idea of calculating the profit is subtracting the DAI that came out minus the DAI that went in, then minus all of the fees. The DAI that came out is the DAI that was transferred to the user. In step five, let's say that this user put in one ref and then got back 3,100 Dai in this case, the DAI that came out would be 3,100 Dai. Next, we need to minus all of the fees, let's say that this user borrowed 3000 Dai. And then when this user repays the flash swap, he'll have to pay for the DAI that he borrowed plus the flash swap fee. Let's say that this flash swap fee is 9 Dai.
04:32:29.794 - 04:32:55.877, Speaker A: So 3000 plus 9 is the amount of DAI that this user will have to pay for the flash swap. This is all included in step six. And the last fee to consider is the gas fee. The gas fee is denominated in ev. So to do the calculation, you'll need to convert the gas fee from EV to DAI. Let's say that this gas fee is approximately 20 DAI. We will add all of these up.
04:32:55.877 - 04:33:36.195, Speaker A: So 3100 minus 3000, that's 100 minus 9, so that's 91 and then minus 20. So that would be 71. The profit be 71 DAI in this example. In this video, I'll show you another way to execute an arbitrage between two Uniswap B2 contracts. So in the last video, we went through an example of arbitrage, and the way it worked was we first did a flash swap to borrow dai, took this DAI to swap for eve, and then we sold this eve on sushiswap and got back dai. And the last step was to take this DAI and then repay the flash swap. After this, whatever DAI that was left is the profit.
04:33:36.195 - 04:34:11.227, Speaker A: Now, in this video, I want to show you an alternative way to execute arbitrage between two Uniswap B2 contracts. The way it's going to work is we'll do a flash Swap to borrow Eth, do a swap from Eth to Dai, and then repay the flash swap not with Eth, but with Dai. So we will first use Uniswap B2 to do a flash swap to borrow Eth. Next, we'll take this ETH and then sell it on sushiswap to get some dai. And the last step is to repay the flash swap. Now, we started the flash swap by borrowing eth. However, we don't have to pay ETH back.
04:34:11.227 - 04:34:48.829, Speaker A: We can pay it with dai as long as the value of DAI that we're repaying is equivalent to the amount of ETH that we borrowed. The first step and the last step is a little bit weird to understand, but what's basically happening is that we're doing a swap in a reverse order. We're first getting the token now, and then afterwards we're putting in the token in. Let me explain further how this arbitrage will work. Again, we'll say that WEF is cheaper on Uniswap B2 than Sushiswap. On Uniswap B2, WEF is selling for 3000 Dai. And on Sushiswap, WEF is selling for 3100 Dai.
04:34:48.829 - 04:35:30.363, Speaker A: Again, the user is going to buy ref from Uniswap B2 and then sell it on Sushiswap to make some profit. The first step is to do a flash swap to borrow WAF from Uniswap B2. The next step is to take this wef and then sell it on sushiswap, get back some DAI and then repay the flash Swap. On Uniswap V2 with Dai, we borrowed Wath, but we repaid with Dai. This is possible because what we're doing here is we're just doing a regular swap, but in the reverse order. In a regular swap, we put token in and we get back another token out. But by using FlashSwap, what we can do is get the token out and then afterwards put the token in.
04:35:30.363 - 04:36:03.437, Speaker A: So I showed you two ways to do arbitrage with different Uniswap B2 contracts. The next step is to actually implement these in a smart contract. There are two exercises for Uniswap B2 arbitrage. For this exercise, I want you to write a smart contract that will do a flash swap and then do two swaps. The first swap will buy tokens from a Uniswap B2 contract, that is selling tokens for cheap. And then the second swap will sell the tokens to another Uniswap B2 contract that is selling the same token for a higher price. There are two parts to this exercise.
04:36:03.437 - 04:36:38.810, Speaker A: The first part is to complete the function swap and the second part is to complete the function flash swap. For the first part, I want you to complete the function swap. This function will execute an arbitrage between two router contracts. The token to start the arbitrage will come from messagesender. So you have to pull the tokens in from message sender into this contract. And after the arbitrage is completed, this function should return amount in plus the profit back to message sender for the input. It's going to take in a struct called swapparams which is defined over here.
04:36:38.810 - 04:37:17.925, Speaker A: The first parameter, router 0 is an address of the Uniswap B2 router contract that we will call to execute the first swap. The first swap will take in token N that is specified over here and then it will get back token out that is also specified over here. Router one will be the address of the contract to execute the second swap. And this time the tokens will be reversed. Token in for router 1 will be token out and token out will be token in. Okay, the next parameter tokenin will be the address of the token that's going to go into the first swap. And then token out will be the address of the token that's coming out from the first swap.
04:37:17.925 - 04:37:54.553, Speaker A: Amount in will be the amount of tokenin to be used for the first swap. And then that's the min profit. This will be the minimum profit that the arbitrage should make or else the function should revert. Okay, so that's the first part of this exercise. The second part is to implement the function for flash swap. Now, this function flashswap, is similar to the first one called swap, except the difference is we're pulling the initial tokens from message sender. But for this exercise, flash swap, instead of pulling the token in from message sender, we're going to borrow token from a pair contract.
04:37:54.553 - 04:38:31.282, Speaker A: So we're going to borrow token in from this pair contract and then execute an arbitrage with the same parameters that you see over here. Okay, let's go over the inputs to this function. Flash swap pair will be the address of the pair contract to borrow token in. The next parameter is token zero is a boolean value. And it is true if the token to borrow is token zero of the pair contract. For example, let's say that we'll borrow DAI from the DAI MKR pair contract. And let's also say that DAI is equal to token zero on that pair contract.
04:38:31.282 - 04:39:07.445, Speaker A: Then is token zero will return true. Okay, and the last parameter params is a swap params struct that I explained earlier. Okay, so going back to our function flashswap, this function will initiate a flash swap to borrow tokens from the pair contract. The pair contract will call back into this function uniswap B2 call. So inside here you'll execute an arbitrage, repay the flash swap, and then send the remainder of the token to Message sender of FlashSwap. Okay, so this is the first exercise. Let's take a look at the test.
04:39:07.445 - 04:39:42.641, Speaker A: This contract will test an arbitrage between uniswap and sushiswap. And what this test will execute is it will buy ref from uniswap and then sell on sushiswap. And then for the flash swap, it Will borrow DAI from DAI MKR pair contract inside the setup function. It will create an arbitrage opportunity by making ref cheaper on Uniswap than Sushiswap. And then if I scroll further down, it will test two functions. The first one will test the function swap and the second one will test the function flash swap. Let's go over the solution for the first exercise.
04:39:42.641 - 04:40:13.395, Speaker A: The first part we'll implement the function swap. The first thing that I'll do is I'll complete this task. Pull token in from message sender. So I'll type IERC20 token in. Where can I get this token in? Well, it's encoded inside the struct swap params. You can see token in over here. So over here I'll say params token in dot transfer from transfer from message dot sender to this contract.
04:40:13.395 - 04:40:36.681, Speaker A: Address this. And for the amount, how much do we need to pull in? Well again this is encoded in the struct params. Over here you can see amount in. So over here I'll type params.amount in. Okay, the next part you'll need to execute an arbitrage. I'll later write an internal function called swap.
04:40:36.681 - 04:41:15.545, Speaker A: For now I'll just type swap and then pass in the params. We're going to use this internal function swap also inside the function flash swap. So maybe I'll declare this internal function first. So I'll say functionswap. It's going to take in swap params, memory params and we'll make the visibility of this function private. Okay, so we'll call the function the internal function swap and we'll return a single output the amount of token that came out after doing two swaps. So say uint amount out is equal to.
04:41:15.545 - 04:41:52.023, Speaker A: And then also over here I'll say this function that we will implement later returns uint256amount out. So let's say that this function executes an arbitrage with the parameters passed from the input. The last part of this code is to send amount in plus the profit back to message sender. Amount out should contain the amount in plus all of the profit. So I'll say ierc20passams.token in.transfer to message.sender
04:41:52.023 - 04:42:30.151, Speaker A: for amount out. Okay, for the last part, remember back inside the structure we have what's called min profit. And if the profit from the arbitrage is less than this min profit, the function swap should revert. So we'll say require. We need to require that the profit is greater than or =topassams.min profit and I'll say the error message profit less than min. Okay, but how do we calculate this profit? Well, the profit will be the amount that came out minus the amount that was put in.
04:42:30.151 - 04:43:08.631, Speaker A: Say amount out is the amount that came out and the amount that went in is params amount in. Okay, so that completes this function. Let's now go implement the internal function swap. What you'll need to do here is swap on router 0 and then swap on router 1. To begin with, we'll send token in and then we'll get back token out. In the next swap, we'll send token out from the previous swap and then we'll get back token in. Now to call the router, we'll need to approve the token.
04:43:08.631 - 04:43:56.445, Speaker A: So say IERC 20 params token in dot approve the router params router zero for the amount params amount in. Okay, Next we will call the function swap exact tokens for tokens on Uniswap B2 router contract. So to call the router contract, I'm going to open source interfaces Uniswap B2 and then Uniswap B2 router 02 contract. And if I scroll up, I'm looking for the function called swap exact tokens for tokens. I don't see it here, so I'll go check this contract. Next, Uniswap B2 router 01. I'll open this and again I'm looking for a function called swap exact tokens for tokens.
04:43:56.445 - 04:44:35.113, Speaker A: So I see this over here. So I'll copy this and then we'll paste it here. So you need to call I Uniswap B2 Router 02 and the address that we need to call is params.restercer0. And the function that we'll call to execute our first swap is swap exact tokens for tokens. As a reminder, what this function will do is it will take all of the token that came in and then try to swap all of that token for the other token. Okay. For the amount in, you'll pass in params amount in for amount out minimum.
04:44:35.113 - 04:44:56.330, Speaker A: It doesn't really matter here. So we'll put a zero and we'll need to prepare path. So let's do this. Now the path will be an array of address. So say address memory path is equal to this. Path will contain token in and token out. So say new address will have length of 2.
04:44:56.330 - 04:45:24.875, Speaker A: Then say path 0 will be token in. Token in will come from the input params token in and Token out will be path one. And this will come out from also from params token out. Okay, Next, the address that will receive the tokens. Address this and that's the deadline. Block dot timestamp. This function will return an array of uns.
04:45:24.875 - 04:46:00.095, Speaker A: The first element in this array is the token that came in, and the last element is the final amount of token that came out. So we say uint 256 memory amounts is equal to. And then call the function swap exact tokens for tokens. Okay, so that completes the first swap. And then to execute the second swap, I'll copy the code again and then paste it here. Okay, and the second swap will be doing something similar, except we'll be swapping from token out and and then getting back token in. So we approve router one for token out.
04:46:00.095 - 04:46:43.235, Speaker A: Approve router one and amount. How much should we approve here? Well, in the previous step we put in amount in and the amount out that we got back will be contained in the last element of this UINT array called amounts. And we know that this amounts array will have a length of two. This is because the first element will contain amount in and the second element, which is also the last element, will contain the amount of token that came out. So the amount of token that came out will be amounts of one. Okay, for the path we already declared it, let's reuse the variable so we don't have to declare again. Path zero will be token out and path one will be token in.
04:46:43.235 - 04:47:18.741, Speaker A: And then we'll recycle the amounts array again so we don't need to declare it. We call the function swap exact tokens for tokens. Again, except on router one. And the amount that will go in is the amount that came out from the first swap. This is contained in amount one, minimum amount out. Let's say the minimum amount that we want out is the amount that we initially put in params amount in, say params.amount in and again, the address that will receive the tokens is this contract.
04:47:18.741 - 04:47:52.825, Speaker A: And that line will be block timestamp. And the last part to complete this function is we'll need to return amount out that came from the second flop. So say amount out is equal to amount of one. Okay, that completes the first function swap. Let's move on to the next function, flash swap. What this function will do is borrow tokens from the pair contract and then execute an arbitrage and then repay the tokens that were borrowed. To execute a flash swap, we need to directly call the function swap on the Pair contract.
04:47:52.825 - 04:48:38.827, Speaker A: I don't exactly remember what inputs to pass, so I'll first look for the interface for the pair contract inside source interfaces. Uniswap B2 I'll open I Uniswap B2 pair and then I'm looking for a function called swap. I see it over here. I'll copy this and then I'll paste it here. Okay, so we need to call I Uniswap B2 Pair at the pair address, call the function swap and these are the inputs that we will need to pass. Calling this function will initiate a flash swap. And we're initiating a flash swap to borrow the first token that will be used for the arbitrage question is how much token do we need to borrow and which token should we borrow? The answer to the first question is easy.
04:48:38.827 - 04:49:11.665, Speaker A: How much token we need to borrow is already encoded in the struct params. This will be params amountin. Okay, how about which token do we need to borrow? Well, if this Boolean variable is token 0 is true, this means that we need to borrow token 0 from the pair contract. So say is token 0. If it is true, then we need to borrow params amount in. Otherwise if is token 0 is false, then we need to borrow token 1. So the amount 0 out will be 0.
04:49:11.665 - 04:49:35.457, Speaker A: Okay. Likewise we can do the same logic here is token zero. If it is token zero, then we don't need to borrow token one. So this will be zero. Otherwise is token zero is false. So we need to borrow token one to say params.amount in okay, the to address the address that's going to borrow the tokens will be address this, address this and that's the data.
04:49:35.457 - 04:50:10.239, Speaker A: So recall that we need to have this data not empty to execute a flash slot. So what data should we encode? What's obvious that we'll need to encode abi. Encode we will need to encode this swap params to execute arbitrage. So say params and we need to repay this pair contract. So also encode this pair and we also need to send the profit back over to message sender. So also encode message sender. Okay, and then once we encode this data, we'll set this over here.
04:50:10.239 - 04:51:01.809, Speaker A: This part of the code will initiate the flash flop. We'll need to execute our arbitrage here and then repay the flash swap. I'll start by decoding the data over here. So again, remember that data we encoded, message sender, pair and swap params say address, caller, address, pair and swap params memory acquired params is = to abi dot. Decode the data and this will be addressed address and swap params. So once we have the params, we can call the internal function that we wrote swap to execute the flash swap. So I'll call the internal function swap passing the params.
04:51:01.809 - 04:52:02.603, Speaker A: This will execute an arbitrary charge between router 0 and router 1 and this will return amount out. Okay, the next part is to repay the flash swap. So say uint 256 fee is equal to. So recall that when we repay the flash swap it had a weird formula so which was dependent on the amount that came in params amounting. And the weird formula was we need to multiply this by three and then divide by 997. And considering rounding down errors, we'll add one and the amount to pay UN 256amount to repay is equal to params amount in the amount that we borrow plus the fee. We'll also calculate profit here and then check that the profit is greater than or equal to this min profit say uint256 profit is equal to the profit will be amount out minus the amount that we will need to repay.
04:52:02.603 - 04:52:59.891, Speaker A: This will be amount to repay to the flash swap require profit greater than or equal to params min profit with the error profit less than min. The next step is to repay the flash swap IERC 20 params Tokenin transfer to address of the pair. This we decode it over here and then further amount amount to repay. And then the last step is to transfer the profit to message sender transfer to caller which we decoded over here. Again transfer to this caller further amount profit. Okay, so that completes the function flash from up. Note here that this function UNISWAP B2 call can be called by anyone.
04:52:59.891 - 04:53:34.107, Speaker A: So if you want to increase your security of your smart contract, then you'll need to implement an authorization over here. Make sure that this function can only be called by the pair contract. For this exercise, we'll keep it short and say that anyone will be able to call this function. And we can do this as long as there's no tokens locked inside this contract after an arbitrage. When the arbitrage is executed, we're sending all of the profit back to the caller. So I think we can get away here without writing any authorization code. Okay, so let's now try testing this contract.
04:53:34.107 - 04:54:30.659, Speaker A: We will execute an arbitrage between Uniswap B2 and Sushiswap. The first thing that I'll do is set My environment variable inside my terminal. And then to execute the test I'll Type forge test dash dash fork URL fork URL matchpath test uniswap b2 exercises uniswap b2 arb1 test SOL BBB okay, and both of our tests passed the function flashswap made a profit of this much amount. Let's try checking what this amount is. Open Python Shell paste it divided by 118 and it made a profit of 831 Dai. How about function swap? Paste the number divided by 118 and it made a profit of 861 Dai. This is the second exercise in UNISOFT B2 arbitrage.
04:54:30.659 - 04:55:11.951, Speaker A: In this exercise I want you to implement a smart contract that will execute an arbitrage between two Uniswap B2 contracts. This time to execute an arbitrage, this contract will first do a flash swap and then swap with another pair contract. In this exercise, we will need to directly call the pair contract instead of calling the router contract. So it will be a good exercise in working with the pair contract at a low level. There's two functions that you'll need to complete for this exercise. The function flashswap to initiate a flash swap and then the function uniswap b2 call which will be the callback of the flash swap. And you'll need to implement your arbitrage inside here.
04:55:11.951 - 04:55:59.215, Speaker A: Now, to help you complete this code, I created a helper function getamount out which will calculate the amount of token out, given the amount in reserve in and reserve out. This is a code that I copied over from Uniswap V2 library. And the other thing that might help you out is is the struct that I declared over here. You don't have to use this struct, but this struct encodes all of the data that you need to execute an arbitrage. The address caller will be the caller of the function flashswap. So inside the function flashswap, the value of message sender should be stored inside here. Pair 0 is the address of the pair contract to execute the flash swap and pair one is the address of the pair contract to execute a regular swap.
04:55:59.215 - 04:56:42.143, Speaker A: The next data is a Boolean called is 041. This will be true if during flashswap token 0 is the token that goes in and token 1 is the token that goes out. In other words, if you're borrowing token 1 and then repaying back token 0 then is 041 will be true. Otherwise, if you're borrowing token 0 and then repaying token 1, then is 041 will be false. Next, amount in will be the amount to repay the flash swap, and amount out will be the amount to borrow from the flash swap. And lastly, min profit. If the profit is less than this min profit, then the arbitrage should fail.
04:56:42.143 - 04:57:15.053, Speaker A: Okay, so for this exercise I want you to implement the function flashswap. Here are the inputs that will be passed in and let me go over them one at a time. Pair 0 is the pair contract to execute the flash swap. Pair 1 is the address of the Uniswap B2 pair contract to execute a regular swap is 0, 41 is a boolean. And this is true if the token to borrow is token 1 and the token to put back in is token 0. Otherwise is 041 will be false. Amount in is the amount to repay the flash swap.
04:57:15.053 - 04:57:46.859, Speaker A: And then min profit is the minimum profit that this arbitrage must make or else the arbitrage should fail. Okay, so as a hint, notice that for the input it passes in amount n. And we can calculate amount out the amount to borrow from the flash swap by calling this function getamount out. Okay, let's go over the solution for the second exercise. Uniswap v2 arb2. The first function we'll implement is flash swap. And what we'll need to do is initiate a flash swap.
04:57:46.859 - 04:58:23.951, Speaker A: And to do this we'll need to call the function swap on Uniswap B2 Pair contract. So from the interface of Uniswap B2 Pair, I'll copy the function definition for swap and then I'll paste it here. We'll call I Uniswap B2 pair. And here there are two address for the pair contract. Again, the inputs are that the first pair pair contract is the one that we need to call to initiate the flash swap. So over here you'll call pair zero and then call the function swap to initiate a flash swap. Next, we will figure out amount zero out and amount one out.
04:58:23.951 - 04:58:56.847, Speaker A: We're borrowing a single token, so one of them will always be equal to zero. To figure out amount out, let's use this hint over here to call the function getamount out. So you'll call this function getamount out. For the inputs to this function, we'll pass in amount in, reserve in and reserve out. So we'll first need to get the amount of tokens locked inside the Uniswap B2 pair contract to be able to call this function. So the function that we'll need to call. Inside the Uniswap B2 pair interface is a function called getreserved.
04:58:56.847 - 04:59:31.075, Speaker A: This function will return Reserve 0, Reserve 1 and the last timestamp that these reserves were updated. So I'll paste it here. This is the function that we need to call on. I uniswap b2 pair on pair zero dot get reserves and this is the output that it will return. And the last output is a timestamp that the reserves are updated, which we do not need. Okay, Once we have Reserve 0 and Reserve 1, we can next call this function getamount out. Calculate amount out.
04:59:31.075 - 05:00:08.391, Speaker A: I'll say uint 256amount out. This is the amount that we're going to borrow from a flash swap. So we'll call the function getamount out. For the first input is amount in, which will be amount in that comes from the input. Okay, how about reserve in and reserve out? Well, this depends on on the Boolean variable is 041. Again, is 041 refers to the first pair 0. Contract is 041 will be true if token 0 is token in and token 1 is token out.
05:00:08.391 - 05:00:52.099, Speaker A: So say is 041. If we're borrowing token 1 and then later repaying back token 0, then is 041 is true. So the token that's coming in is reserve 0 and the token that's going out is reserve 1. Otherwise if 041 is false, then amount n is amount 10 and we need to flip reserve 1 and reserve 0. We borrow token 0 and then later we pay back token 1. Okay, once we figure out what amount out is, we can now fill out this part of the input amount 0 out amount. The token 0 to borrow if is 0 for 1.
05:00:52.099 - 05:01:21.184, Speaker A: If this is true, this will mean that we're borrowing token 1 and then repaying token 0. Since we're borrowing token 1, then this will be 0. We don't need to borrow token 0 when we want to borrow token 1. Otherwise then this will be amount out. And likewise we can do the same Logic over here is 041. If it is 041 again, we're borrowing token 1 and then later repaying back token 0. So we're borrowing token 1.
05:01:21.184 - 05:01:43.393, Speaker A: So we type amount out. Otherwise if 041 is false. In this case we want to borrow token 0. So we don't want to borrow any token 1. So here we'll pass 0. Okay, next, the parameter 2. Who are we sending the token to? We'll send it to this contract and then data.
05:01:43.393 - 05:02:15.230, Speaker A: What data should we encode well, I will fill out this struct data over here. So I'll copy this and then paste it here and then type bytes. Memory data is =toabi. Encode flash swap data and then we'll fill out this input. So the caller will be message sender. Next is pair 0 and pair 1. Pair 0 will be pair 0 from the input.
05:02:15.230 - 05:02:40.331, Speaker A: Pair 1 will be pair 1 from the input is 04. One will also come from the input. Amounting will also come from the input. Amount out is the amount that we calculated above and main profit. This will also confirm the input min profit. Then once we encode the data, we'll pass it over to the flash swap. Okay, and that completes the function flash swap.
05:02:40.331 - 05:03:08.289, Speaker A: This will initiate a flash swap. So the second part of this exercise is to complete the callback function uniswap B2 call inside. Here we'll execute the arbitrage and then repay the flash swap. First thing that I'll do is decode this data over here. We encode it as a struct of flash swap data. So we'll decode it by saying flash swap data memory. I'll call it params is equal to abi.
05:03:08.289 - 05:03:43.561, Speaker A: Decode data into flash swap data. And the next thing that I'm going to do is call the function swap on pair one. So copy this function call and then paste it here. We'll call pair one. Then for the data we'll pass in an empty data to call swap on pair one, we'll need to figure out how much amount of token to put in and how much amount of token that we can get out. And we also need to figure out token in and token out. I'll start by figuring out what token in and token out are to get the address of tokenin and token out.
05:03:43.561 - 05:04:19.326, Speaker A: I'll first start by querying token0 and token1 on Uniswap B2. Pair0. Say address token0 is equal to Uniswap B2 pair on params, pair0.token0 and then token1 will be address1. On pair0, query token1. Okay, once we know token0 and token1, we can figure out what is token in and token. Now address token in address token now is equal to params is 0 for 1.
05:04:19.326 - 05:05:00.229, Speaker A: If it is, then it will be token 0 and token 1. Otherwise it will be token 1 and token 0. And once we know what token in and token out relative to pair 0 is, then we can figure out what token to send over to pair one from pair zero. We did a flash swap to borrow token out and we'll need to send this Token out to pair 1. So say IERC20 token out send to transfer to pair 1. For the amount, amount will be encoded inside. Destruct amount out.
05:05:00.229 - 05:05:33.229, Speaker A: So over here I'll say params.amount out. Remember that when we directly call the pair contract and call the function swap, before we can call this, we will need to directly send the tokens in. So that is why I'm sending tokens in before calling the function swap. So once we send the tokens and then call the function swap, you'll be able to take out some tokens out. And we still haven't figured out if it is token 0 or token 1 and how much token that we can pull out. So let's do that now.
05:05:33.229 - 05:06:15.605, Speaker A: Uint amount out is equal to. For now, I'll just set it to zero again to figure out what amount out is, we'll call the function getamount out. And to do this we'll need to figure out reserve in and reserve out for pair one. What I'm going to do is I'll copy this part of the code and then I'll paste it here and reserve zero and reserve one for pair one. This should be params pair one. So I'll change all of these pair ones to params pair one. Okay, Once we know the reserves, we can figure out what amount out is.
05:06:15.605 - 05:06:44.031, Speaker A: If params.is041, the amount to put in is params amount out. So let me change that first. Params dot amount out. This is the amount that we borrow from the flash swap. If the flash swap is a deal for 1, then we borrow token 1. So to swap on pair 1, token in, reserve in will be token 1 and reserve out will be token 0.
05:06:44.031 - 05:07:26.250, Speaker A: Otherwise, if the flash swap is a 1, 4 0, then we borrow token 0. So for pair 1, token in will be reserve 0 and token out will be reserve 1. Okay, so now I can remove this amount out and let's now figure out what amount 0 out and amount 1 out are. If params is 041, if it is 041, then we borrow token 1 and we want token 0 back. So amount 0 out will be amount out. Otherwise, if it was 14 0, then we borrow token 0 and we don't want token 0 from the second pair contract. So the amount will be 0.
05:07:26.250 - 05:08:58.655, Speaker A: Okay. Likewise params is 041. If it is 041, then token that we borrow is token 1. Then we don't want token 1. Out coming out of pair 1 so this will be 0 otherwise it will be amount out okay, once we execute a swap on pair one, the next step is to repay the flash swap. So say IERC20 we borrow token out and we'll need to repay with tokenin so here I'll say tokenin transfertoparams pair 0 for the amount params amount int next we'll calculate the profit uint256 profit is equal to the profit will be the amount that came out from pair one minus the amount that we paid to the flashswap amount out -passams.amount in require profit greater than or equal to params min profit error message profit less than min okay, and then lastly we'll transfer the profit over to the caller I ERC20 token in dot transfer to params caller Again params caller is messagesender for the function flashswap in other words, the account that executed flashswap transfer to the caller for the amount profit.
05:08:58.655 - 05:10:07.887, Speaker A: OK, that completes the function Uniswap B2 call let's now execute the test inside my terminal. I'll start by setting up the fork URL Then we'll execute the test forge test fork URL Fork URL match path test uniswap b2 exercises uniswap b2 arb2 test SOL BBB okay, and our test pass. I'll copy this profit and inside my Python shell paste it divided by 1018 and it looks like we made a profit of 861 Dai what is the optimal amount of token to put in into two Uniswap B2 contracts to maximize an arbitrage opportunity? There's actually an exact formula for this. So in this video I'll explain what it is and how to derive it. Let's begin by imagining that there are two Uniswap B2AMMs, AMMA and AMMB. Both of these curves are the constant product X times Y equals K. Now let's also say that Both of these AMMs are selling the same tokens.
05:10:07.887 - 05:10:49.811, Speaker A: And we observe that on AMMA the price is cheaper than on ammb. On AMMA we have P of A and on AMMB we have peer B. Here we have another charge opportunity. What we'll do is buy some token from Amma. This will bring the price up to let's call this P start and then taking the same token that we just bought, we will sell it on ammb. This will bring the price of token on AMMB from POB to P When the prices match On AMM A and ammb, this means that there is no more arbitrage opportunity. Okay, to execute an arbitrage here, what we'll do on AMMA is we'll need to bring the price up from P to this P of start.
05:10:49.811 - 05:11:14.411, Speaker A: And to do this, we'll put some token Y in, call this DY of A, and then we'll get back out token X. Let's call this minus dx. Next on ammb, we will sell the same exact amount of dx. On ammb. When we sell this token X, we get back token Y. Let's call this dyb. To summarize here, what we did was we put in DYA of token Y.
05:11:14.411 - 05:11:46.923, Speaker A: Then at the end of the I recharge, we got back DYB of token Y. The profit from this arbitrage will be the final amount of token Y that came out minus the initial amount of token Y that we put in. Let's write this as an equation. We'll define a function that will represent the profit from this arbitrage. Let's call this capital F. And for the input it's going to take in DY the initial amount of token Y to put in to execute this arbitrage. And the profit will be the final amount that came out minus the initial amount that we put in.
05:11:46.923 - 05:12:41.835, Speaker A: Now we can rephrase our question of what is the optimal amount of token to put in to maximize arbitrage profit? We can rephrase this as what is the DYA that we need to put in here to maximize this function? F? Let's call this DY of star. This will be the amount in that maximize F. When we maximize this F, this also means that we're maximizing this value which is the arbitrage profit. There's actually an exact formula for this DY of star and it turns out to be this complicated equation where A is equal to this, B is equal to this, C is equal to this, and then K is equal to this. When you plug these numbers in and then calculate this equation, you'll get the optimal amount of token in to maximize arbitrage profit. For the rest of the video, I'll explain how to derive this equation. And I'll start by explaining what these variables mean.
05:12:41.835 - 05:13:09.993, Speaker A: First, I'll define what F is. F is the swap fee. We'll assume that on Amma and on AMM B we have the same swap fee. This swap fee will be a number between 0 and 1. Xa will define it as ama reserve out. Here, reserve out means the balance of the token that is coming out that is locked inside amma. For our example on amma, token that is coming out is token next.
05:13:09.993 - 05:13:46.581, Speaker A: So in this case, XA will represent the token balance of tokenx in amma and YA will be amma's reserve in. Again going back here, the token that is going in inside this amma is tokeny. So ya will be the amount of token Y locked inside amma. And we'll define similar variables for ammb. XB will be equal to AMMB reserve in. YB will be AMMB reserve out. Okay, going back to our example.
05:13:46.581 - 05:14:27.645, Speaker A: In our example, XB is AMNB reserve in. So the token that is coming in in this example is token next. The balance of token next locked inside AMMB will be XB and the token that is going out in AMMB is token y. So the balance of token Y inside AMMB is yb. Now with these variables defined and using this equation, you can plug in the numbers to calculate what DY of a of star is. For the next part of the video, I'll explain how to derive this equation. I'll start by writing out the equation that calculates the amount of token that comes out in a constant product amm.
05:14:27.645 - 05:15:13.093, Speaker A: So when you put token in the amount that comes out, we'll call this swap amount out and we'll define it as A About is given by this equation where ain is the amount in, R in is the reserve in and rout is reserve out. This is the same exact equation that you'll see in Uniswap B2 contracts. Okay, using this equation, let's calculate the amount of token that comes out on amma. The token that is going to come out from the first swap is dx and the token that's going to go in is DY of A. So we'll rewrite this equation in terms of dx, dy, x and Y. Okay, we'll start with A out, A out. The token that is coming out from the first swap is dx.
05:15:13.093 - 05:15:40.371, Speaker A: Then next I'll replace A in the amount of token that's going in. So remove this and then also remove this. Ain will be dy. Okay, how about rout? Rout is reserve out. The token that is coming out from the first swap is token X. So reserve out will be X of a reserve of token X on amma. Okay, lastly we'll replace R in reserve in.
05:15:40.371 - 05:16:03.429, Speaker A: The token that is coming in is token Y. So this will be Y of A. Next we'll do the same. First swap on AMMB. On ammb, the token that is coming in is token next and the token that is going out is token Y. So first again I'll copy this equation then paste it here. Let's start with A out the amount of token that is coming out.
05:16:03.429 - 05:16:29.055, Speaker A: We define this as dyb. The amount of token that is going in is the amount of token that came out from the first swap. So this will be dx. So I'll put DX over here and I'll put DX over here. Okay, next let's replace our out reserve out. The token that is coming out on AMMB is token Y. So reserve out on AMMB is yb and reserve in will be xb.
05:16:29.055 - 05:16:52.129, Speaker A: We're putting in DX token. So the token that's coming in is token X. The reservoir token X on AMNB is represented as xb. So now we have some equations. The next thing that I'll do is I'll replace this DX with this equation over here. So I'll start with the top part. I'll bring this over here and then replace this DX with this equation.
05:16:52.129 - 05:17:11.835, Speaker A: So on the top we will have this equation. And then next I'll replace this dx. So I'll bring this over here and then copy this equation. Again, paste it here and we have this equation. So our equation will look like this. Next let's simplify this equation. So I'll copy this.
05:17:11.835 - 05:17:52.145, Speaker A: Then I'll paste it here for now this equation is the same as doing this, having a one here and then I just brought this over to the left and now I see that for the top part I can just put this then on the bottom. I'll need to multiply this term by these terms. When I multiply by the first term, I'll get this multiplied by x of B. And then when I multiply this again with the second term. So I need to multiply this with this. Notice for the second term that these terms cancel out with these terms on the bottom. They are the same.
05:17:52.145 - 05:18:20.187, Speaker A: So I can just simply remove them. Okay, so this term is equal to this term. And I can further simplify the terms. I see 2, 1F on the top, so I can just replace it with 1 minus 2F squared. And then on the bottom I'll do the same. I see two one minus F. So this will become one minus F squared.
05:18:20.187 - 05:18:58.757, Speaker A: Next I'll simplify the bottom terms. So this is equal to. I'll expand the first term. So this will be ya multiplied by xb plus dy times 1 minus f multiplied by xb and then plus these terms. And the last thing that I'll do for this equation is I'll group all of the terms that have a DY of A. I'll copy this and then paste it here. And what we have here is dy of a times 1 minus f plus x of b plus dy of a times 1 minus f squared times X of A.
05:18:58.757 - 05:19:26.689, Speaker A: And I'll put these terms inside the parentheses. And now we can replace this term. Okay, so that completes D y of B. What we did here was we rewrote DY of B in terms of DY of A. And now, so going back. And now we can rewrite this equation to find DY of A. So I'll copy this equation and then paste it here.
05:19:26.689 - 05:20:12.275, Speaker A: So now we know what d y is in terms of D y of A. Now we're ready to tackle the question, what is DY of A of star? Which is the amount that will maximize F. To find this answer, we'll use calculus to take the derivative of F with respect to DY of A and find where the derivative is equal to zero. We'll call this point where the derivative of F is equal to 0, Dy of A of star. So if you remember in calculus, if you find a point where the derivative is equal to zero, this means that the function either reached a maximum or a minimum with our function. This point where the derivative is equal to zero is the point where the function reaches its maximum. Okay, so the next step is to find the derivative of F.
05:20:12.275 - 05:20:48.925, Speaker A: Here's the function F. Again, when we take a derivative of this function F, let's call this F prime. Then we'll need to take the derivative of dy, which is this equation over here. And taking the derivative of Dy with respect to Dy of A, this will be equal to 1. But what is the derivative of Dy of B? What we need to do is take the derivative of this complicated equation with respect to DY of A. So I'll start by copying this equation over to here. Furthermore, I'll break this equation down into two parts.
05:20:48.925 - 05:21:20.391, Speaker A: The top part, I'll define it as F, and the bottom part, I'll define it as G. Next, to find the derivative of DY of B using the quotient rule of derivatives, this is equal to F prime times G minus F times G prime divided by G squared. So the next step is to find all these terms F prime, G prime and G squared. Let's start with F prime. We said that the F is the top part of this equation. So I'll copy this. So this is F.
05:21:20.391 - 05:21:50.835, Speaker A: And we need to take the derivative of this with respect to dy. When we do that, we're treating this part as a constant and this will be the derivative. Okay, Next we'll do the same for G prime. The derivative of G with respect to DY of a G is equal to this term. Next we'll take the derivative of this equation with respect to DY of A. When we take it respect to DY of A, the first term is just a constant, so it disappears. The next term we have a DY of A.
05:21:50.835 - 05:22:16.173, Speaker A: When we take the derivative, this will become one, and we treat this part as a constant. Next we have a dy of a. We take the derivative of dy. This will be equal to 1, and we're left with these terms. Okay, the next step is to calculate F prime G minus F times G prime. So this will be equal to F prime G is this term. Next we multiply this by G.
05:22:16.173 - 05:22:46.367, Speaker A: G is equal to these terms. Next we'll have A minus and F is equal to these terms. And G prime will be equal to these terms. This is equal to. I'll first expand the first term. Then next I'll expand the second terms. Next, a lot of the terms that you see over here will cancel out.
05:22:46.367 - 05:23:15.205, Speaker A: This term over here will cancel out with this term. And to see this, we have a one minus F square over here. And we also have one over here. The same over here. Same over here we have a XA XA dya, Dya over here and XA times yb, which we also have over here. So all of these terms cancel out with all of this term. Next, this term will cancel out with this term.
05:23:15.205 - 05:23:59.305, Speaker A: And to see this we have a dy of a times 1 minus f. We have a dy of a 1 minus f times xb times xb. And we multiply this term by 1 minus f squared times xa times yb, which we have over here. So what we're left with is just the first term, which is 1 minus f squared times xa times yb times ya. And this ya will be multiplied by this xb. And this is our result for F prime times G minus F times G prime. We'll come back to this equation later.
05:23:59.305 - 05:24:20.549, Speaker A: Okay, the next step is to find G squared. We said that this is equal to G. So G squared will be squaring these terms. I'm going to rearrange this equation so that all of the terms that Have a DY of a will be in one place. So I'll copy this again. First we have this term. I'll bring this over here.
05:24:20.549 - 05:24:50.567, Speaker A: And then we also have a DY of A over here. This is equal to DY of A times 1 minus F times XB. So I'll bring this over here and then remove this DY of a. Then wrap these two terms in a parentheses and then I can remove this term. So now we have ya times xb plus these terms. So this is the inside part of this square. So we need to square this again.
05:24:50.567 - 05:25:21.249, Speaker A: And to simplify the equation, I'll relabel this part. You'll say that this part, I'll redefine it as K. K will be equal to this terms underlined in orange. The reason why I relabel these terms as K is so that the equation will be short. Now we can simplify this equation. The first term will be k squared times dy of a squared. The second term will be 2k times ya times xb that you see over here times dy of a.
05:25:21.249 - 05:26:08.535, Speaker A: And the last term will be ya times xb squared. Okay, we did a lot of calculation and we're finally ready to find D y of A of star. This will be the optimal amount that will maximize the function F which is also equal to where the derivative of F is equal to zero. First I'm going to scroll back up and I'll copy this equation and then paste it here. Next, I'll take this equation and then paste it here. Next I'm going to combine these two equations so that we'll be able to find DY of a star where the derivative is equal to zero. First, I'll start with this.
05:26:08.535 - 05:26:40.937, Speaker A: So from this we're trying to find DY of star where this is equal to zero. And then I'll remove this. This is the same as finding the derivative of DYB where it is equal to 1. And we know that DYB is given by this equation. So I'll replace this with this equation. And now this condition is the same as finding where F prime times G minus F times G prime is equal to G squared. Okay? And we already know what all of these terms are.
05:26:40.937 - 05:27:26.779, Speaker A: The first term, the term on the left is equal to this. And we also know the term on the right, G squared, G squared is given by this term. And to find a place where this is equal to zero, we can use the quadratic formula to find the root. And to find where this equation is equal, we can use the quadratic root formula to find where DY of A is equal to zero, so this is equal to. I'll flip the equation first so these two equations are the same and this will be equal to saying that this whole equation is equal to zero. We relabel this k square the first term. The first term that's multiplied by dya of square.
05:27:26.779 - 05:28:24.553, Speaker A: We relabel this as A, we relabel the second term that's multiplied by DY of A as B and we relabel the last terms that doesn't have any multiplication by D y of A as c. With these ABC terms defined, we can now use the quadratic root formula to find where dy of a is equal to 0 and here is one of the quadratic root formula minus b plus square root of b squared minus 4ac divided by 2a where abc are defined over here. Plug all of this in and this is equal to Dya of star. When you plug ABC into this equation, this will give us where this equation is equal to zero. And when this equation is zero, we know that this condition is true. And when this condition is true, we found dy of a where the derivative is equal to 0 and where this derivative is equal to 0. This is where the function F is maximized.
05:28:24.553 - 05:28:31.665, Speaker A: In other words, this tells us the optimal amount of token lend to maximize profit. For a Uniswap B2 contracts.
