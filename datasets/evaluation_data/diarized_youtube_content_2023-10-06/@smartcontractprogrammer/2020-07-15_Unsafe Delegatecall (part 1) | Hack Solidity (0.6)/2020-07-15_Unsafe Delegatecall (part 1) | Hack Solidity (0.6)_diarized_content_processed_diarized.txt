00:00:00.730 - 00:00:38.460, Speaker A: I'm going to show you how to misuse delegate call. In other words, I'm going to show you how to shoot yourself in the foot by showing you examples of smart contracts that misuse delegate call. Hopefully you'll recognize how to use it in a safe way and how to use it in an unsafe way. In this video, I'll quickly explain what delegate call is, and then I want to show you two examples over the next two videos. This video is part one. We'll explore a simple example of unsafe delegate call. In part two, we'll look at a more sophisticated example.
00:00:38.460 - 00:01:18.326, Speaker A: All right, let's briefly go over what delegate call is when contract a calls contract B. Using delegate call. It's basically telling contract B to run your code inside my context. So the code inside contract b will be run using the storage of contract A, message sender, message value, message data, and et cetera. This means that when you're using delegate call, there are two things that you should keep in mind. One, delegate call preserves context, which I explained above. And the second thing to keep in mind is that storage layout must be the same for both A and B.
00:01:18.326 - 00:02:03.294, Speaker A: What I mean by this is that both contract A and contract B must declare the same state variables in the same exact order. So what can go wrong when we don't keep these two things in mind? Well, that is what we'll be exploring in this and the next video. And in this video, we'll go over an example of how to misuse delegate call when we forget that it preserves context. Here is a contract called hackme. It has a state variable called owner, which is set inside the constructor. When this contract is deployed, the challenge is to change the owner. In other words, hijack this contract even though this contract doesn't have any functions to update the owner.
00:02:03.294 - 00:02:44.794, Speaker A: So the owner is set inside the constructor. And the other function that we have here is a fallback function which doesn't look like it updates the owner state variable. Now, if you look inside the fallback function, it uses the delegate call function. And who does it delegate the call to? Well, it delegates the call to the state variable lib, which is another contract that is set inside the constructor. So what does the contract lib do? Let's take a look. Contract lib declares a single state variable called owner and it has a single function called pone. When this function is called, it sets the owner state variable to message sender.
00:02:44.794 - 00:03:47.650, Speaker A: With these two contracts, how can we change the ownerstate variable inside the hackme contract? Go ahead and pause the video if you want to figure out how to update the owner state variable inside the hackme contract. I'll give you a hint. Delegate call preserves context alright, let's walk through how to update the owner state variable inside the hackme contract. In other words, we're going to be hijacking this contract by updating the owner. Now the only way to interact with this contract is by invoking the fallback function. And we know that the fallback function is triggered when a function that does not exist inside this contract is called, which means that here we can call this fallback function by calling a function that does not exist inside the hackme contract. When the fallback function is called, it delegates the call to the lib contract, which forwards message data to the lib contract inside message data.
00:03:47.650 - 00:04:50.330, Speaker A: We can craft the data so that it will call any function that we want inside the lib contract. Inside the lib contract the function that we want to call is poem, which will set the owner state variable to message sender. In this case, message sender will be us, the person who is trying to hijack the hackme contract above. Now why would calling the function pone inside the bib contract update the state variable owner inside the hackme contract? Well, this is because delegate call runs the code inside bib using the storage of hackme. So here the code that will update the owner state variable will be executed using the storage of Hackme, and this will update the owner state variable inside hackme contract. Let's write this exploit in code. We'll create a contract called attack, and we'll store the address of the hackme contract in a state variable called hackme.
00:04:50.330 - 00:05:58.938, Speaker A: Now, the actual address of the hackme contract will be set when we deploy this contract. So we'll pass the address of the hackme contract into the constructor and then set it to the state variable hackme. We'll create a function called attack and this will be the function that we're going to be calling in order to update the owner's state variable inside the hackme contract. So what is it that we have to do here? Our goal here is to call the poem function inside the lib contract, which we can do by calling the fallback function inside the hackme contract and then passing in the function signature of poem for message data. That is what we'll do inside the attack function. So here we'll say hackme call. And recall that call is a low level function where we can pass our message data inside here and the message data that we need to pass in here is the function signature of poem which we can easily create by calling Abi encode with signature.
00:05:58.938 - 00:06:48.858, Speaker A: And the function signature that we want to create here is poem that completes the code for the function attack. Let's quickly go over how this attack will work. When we call the attack function, it will call the hackme contract, and the function that it will try to call inside the hackme contract is poem. But since the function poem does not exist inside the hackme contract, it will call the fallback function. Instead. The fallback function will delegate call to the lib contract and forward the message data. Delegate call calls the lib contract and since we sent message data to match the poem function, the function poem inside lib contract will be executed which will run the code to update the owner state variable.
00:06:48.858 - 00:07:28.570, Speaker A: And since delegatecloud runs its code using the storage of hackme contract, we'll actually update the owner state variable inside the hackme contract. Now I want to demonstrate this exploit in remix. We'll say that the first account is Alice and she is going to deploy the hackme contract. The second account is Eve and she is the person that is going to deploy the attack contract and call the attack function. Here I've deployed three contracts. First, Alice deployed the lib contract. Next she took the address of the lib contract and then deployed the hackme contract.
00:07:28.570 - 00:08:09.370, Speaker A: And then e deployed the attack contract with the address of HackMe contract. First let's check the owner of the hackme contract and make sure that it belongs to Alice. So I'm going to click the owner and that is the owner. I'm going to scroll up and make sure that the owner is Alice. Next, EB is going to call the attack function. So we'll switch account to EB, scroll down and then call the attack function. And you can see here that the transaction to attack was successful.
00:08:09.370 - 00:09:00.920, Speaker A: So let's check back on the owner of Hackme contract and make sure that the owner is no longer Alice. So I'm going to click the owner again and you can see here that the owner has changed. And who is this owner? Well, it's going to be the person or the contract that called the fallback function inside the hackme contract. And in this case it was the attack contract. So you can see here that the address of the attack contract is the new own owner of the hackme contract. So that was an example of what can go wrong when you forget that delegate call preserves contacts. In the next video I'm going to show you what can go wrong when the storage layout for a contract A and B are different.
00:09:00.920 - 00:09:03.300, Speaker A: Thanks for watching and see you later.
