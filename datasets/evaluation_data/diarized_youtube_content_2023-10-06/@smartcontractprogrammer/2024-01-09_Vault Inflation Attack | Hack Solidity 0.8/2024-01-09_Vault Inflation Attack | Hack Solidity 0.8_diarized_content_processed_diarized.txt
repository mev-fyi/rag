00:00:00.250 - 00:00:49.990, Speaker A: Here's a simple bulk contract that I showed you how to write in one of the earlier videos. What this contract does is if you deposit a token into this contract, it will mint you some shares and later on you'll be able to redeem your token by putting in the shares. However, this contract is vulnerable to an attack called inflation attack. In this video, I'll explain what inflation attack is, how to exploit this bulk contract, th and what kind of protections that you can put to protect your contract from inflation attack. First of all, what is an inflation attack? An inflation attack is when the attacker deposits token into the contract to inflate the value of the shares. For example, by sending 100 token into this contract, each share will be worth 100 tokens. An example of an inflation attack on this contract will be the following.
00:00:49.990 - 00:01:22.466, Speaker A: First, let's say that user one is about to deposit 100 token into this contract. User Zero sees that transaction and front runs user one's transaction. User Zero front runs the transaction by first depositing one token into this contract. Now, if you look at the code, initially, total supply will be go to zero. When user zero deposits one token, this user zero will get shares, which will be go to one. So user zero will get one share. Next, the same user, the attacker, will donate 100 token into this contract.
00:01:22.466 - 00:01:49.258, Speaker A: Here. By donate, I mean that user zero will directly send token into this contract. This will simply increase the balance of the token locked in this contract without affecting the total supply. Here, the attacker is inflating the value of the share. Next, user one's transaction is processed. So user one deposits 100 token into this contract by calling the function deposit. Now, we'll work out the math later, but this will give user 10 shares.
00:01:49.258 - 00:02:23.222, Speaker A: And finally, user zero will withdraw 200 tokens plus the one that he initially deposited. Okay, so this is the step that the attacker will perform in order to steal user one's deposit. Let's dig into the details and see how this actually works. We'll map out the balance of token locked in this contract. User zero share, user one's share, and total supply. After each of these steps, the first step is user zero deposits one token. So the balance of token locked in this contract will be equal to one user zero shares.
00:02:23.222 - 00:02:50.302, Speaker A: Well, if you look at the code, so user zero deposits one token. At this point, total supply is equal to zero. So the amount of shares to mint will be equal to the amount that was deposited, which will be equal to one. So user zero will receive one share. User one has not deposited yet, so this person will have zero shares. And in total, the total shares will be one. In step two, user zero donates 100 tokens.
00:02:50.302 - 00:03:27.502, Speaker A: So user zero will directly send 100 token into this contract without calling any of the functions. So the balance of tokens locked in this contract will be 100 times one E 18. Here we're assuming that this token has 18 decimals and plus one which was sent in step one, the shares has not changed. So User zero will have one shares, user one will have zero, and the total supply is still equal to one. Okay, how about in step three? In step three, user one deposits 100 times one E 18 tokens. And here we said that this user will receive zero shares. So let's see why this is.
00:03:27.502 - 00:04:15.726, Speaker A: So let's calculate user one shares and this will be equal to the way the share is calculated in this case will be by executing this part of the code. The amount of tokens that user once sent will be 100 times one E 18. Total supply will be equal to one at this moment divided by the balance of token locked in this contract. The balance of token locked in this contract at this point is 100 times one E 18 plus one. Notice that 100 times one E 18 times one is equal to 100 times one E 18. And on the denominator, 100 times one E 18 plus one is greater than the numerator. So when we do this division, this will round down to zero user one's share.
00:04:15.726 - 00:04:49.110, Speaker A: When user one deposits 100 token will receive zero shares. Since user one received zero shares, total supply has not changed, so total supply will still be equal to one. And the last step is for user zero to withdraw all of his shares. At this point, the total supply of share is one. User Zero has all of the shares, which is equal to one. So when user zero calls withdrawal, he'll be able to withdraw all of the tokens locked in the contract, which will be 200 times one E 18 plus one. So after user zero withdraws his share, the balance of token will be zero.
00:04:49.110 - 00:05:23.874, Speaker A: User zero shares will be zero. User one's share will be zero and the total supply will be zero. Next, I'm going to show you a demo of this code by writing a test in foundry. So I'm going to scroll all the way down and we'll name this contract bolt. Test is test. And for the setup we're going to need the bolt bolt private bolt and the token token private token. And we'll have two users address private users is equal to, let's say, address eleven and address one.
00:05:23.874 - 00:06:08.622, Speaker A: Two, address eleven will be user zero and address twelve will be user one. For the setup, we will deploy the token in the vault. Token is equal to new token and vault vault is equal to new vault. For the constructor of the vault we will need to pass in the address of the token, address token. And then for each user we'll mint some tokens and approve the vault to spend the tokens from the user. Four un I equals zero I less than users length I plus plus and then say token mint two users of I let's mint 1000 token 1000 times one E 18. Next, each user will approve the vault to spend the token.
00:06:08.622 - 00:07:03.806, Speaker A: So say Bm prank users of buy and then say token approve address of vault to spend max un type un 256 max. Next, let's write the attack so say function test public. And what we're going to do is user zero will deposit one and then user zero will donate 100 tokens and then user one will deposit 100 tokens. And at each step we'll print the amount of tokens that each user can redeem. So to do this, first I'll write a function called function print. And inside here we'll console log some stuff, including the balance of the token, total supply, shares of each user, and how much each user can redeem. So to do this, first I'm going to go back up to the vault contract, and here we have a function called withdrawal, which calculates the amount of token that a user can redeem.
00:07:03.806 - 00:07:53.758, Speaker A: For this test, I'm going to create another function called function preview redeem. And it's going to take in the amount of shares un 256 shares external view returns. And it's going to return the amount of token that can be redeemed for the shares that was passed as input returns un to 56. And I'm going to copy this part of the code, paste it, and then return it. Now, I also have to handle the edge case of when the total supply is equal to zero. So say if total supply is equal to zero, then return zero. Okay, so this function, instead of actually calling the function withdrawal, we'll just call this function to calculate the amount of tokens that a user can withdraw, given the amount of shares.
00:07:53.758 - 00:08:49.666, Speaker A: So going back down inside here, we will log some status, we will log the total supply of the vault, we will log the balance of tokens locked in the vault, shares of user zero and shares of user one, amount of tokens that user zero can redeem, and amount of tokens that user one can redeem. So we'll call this print function after each of these actions. So say print, print, and print okay, and the final step is to actually write the code for these actions. Okay, so the first step is user zero deposits, say Bm prank user zero bolt deposit one. The next step is for user zero to donate, say Bm prank users zero, and then call token transfer to bolt address bolt. We'll transfer 100 tokens. So say 100 times one E 18.
00:08:49.666 - 00:09:24.382, Speaker A: And the last step is for user one to deposit 100 token. So what I'm going to do is copy this code, paste it here, change user zero to user one, and he's going to deposit 100 token 100 times one E 18. Okay? And that completes the code for this attack. Let's try compiling the contract inside my terminal. I'll type forge build. I need to go fix the function print. So going back up private, try compiling the contract again and our contract compiles.
00:09:24.382 - 00:10:02.506, Speaker A: So let's try running the test forge test matchpathest vault test Sol BBB. Okay, the test ran successfully and let's examine the last log. So we want to check the status after user one deposits. Total supply. Total shares of the vault is one amount of tokens. Locked inside the vault is 200 times one E 18 plus one. User zero has one share and this means that user zero will be able to redeem all of the tokens inside this contract, which will be 200 times one E 18 plus one.
00:10:02.506 - 00:10:43.858, Speaker A: And user one will be able to redeem zero tokens. There are several ways to protect against the inflation attack. The first way is for user to pass some kind of mint shares so that when they deposit after it mints the tokens, it would check whether the amount of share that was minted was greater than or equal to the minimum share that the user specified. So this will protect against front running. Another protection is to have an internal balance. Instead of querying the token balance, instead of querying the token balance over here, we will have some kind of internal state variable that keeps track of amount of tokens locked in this contract. And this will prevent the attacker from donating to this contract and then inflating the shares.
00:10:43.858 - 00:11:08.410, Speaker A: Another way to protect against the inflation attack is to have some kind of debt shares. This means that the first depositors portion of the shares will be burnt and this will guarantee that the contract is the first depositor. This is the approach that uniswap B two took. And the last approach to protect against inflation attack is a decimal offset. This is done inside the open Zeppelin ERC 4626 contract.
