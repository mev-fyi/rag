00:00:00.330 - 00:00:45.702, Speaker A: You oftentimes you want your function to fail when something is not right. In solidity, there are three ways to throw an error which will stop the further execution of the function being called. The three ways to throw an error are assert, require, and rebirth. In this video, we're going to go over how to use each of them and see how they are different from the other ones. You when a function throws an error, it will undo all of the changes that were made in the current call. Similar to programming language like Python and JavaScript, errors bubble up. This means that if you call a function that calls another function which fails with an error, then the function you called also fails with the same error.
00:00:45.702 - 00:01:42.030, Speaker A: Before I show you examples of assert, require, and rebirth, first we're going to write a simple contract that stores the balance of an account. To store the balance, we're going to need a public state variable, and we're also going to need a function to deposit into this contract, and a function to withdraw from it. The deposit function will take in the amount to deposit and increment the balance by the amount. The withdrawal function will take in the amount that you want to withdraw and subtract it from the balance. Now that we have a simple contract that simulates a bank account, let's add validations using assert, require, and rebirth. Assert is used to check for conditions that should never be possible. If your code reaches a failing assertion, then there's a serious bug in your code that you need to fix.
00:01:42.030 - 00:02:16.950, Speaker A: So correct code should never throw an error from an assertion. When we make a deposit, we want to make sure that the balance went up. After updating the balance, we'll assert that the current balance is greater than or equal to the old balance. This expression should always evaluate to true. If it does not, then this assertion will throw an error and our transaction will fail. And when we withdraw, we want to make sure that the balance went down. So we'll assert that the updated balance is less than or equal to the old balance.
00:02:16.950 - 00:02:38.350, Speaker A: These two assertions should always evaluate to true. However, we can make these assertions fail. Let's see how. First, we're going to need a very large number. So let's store the largest number possible for the data. Type un inside our contract. Next, compile and deploy the contract.
00:02:38.350 - 00:03:14.390, Speaker A: Deposit one and check our new balance. It should be one. Next, deposit this very large number, and you'll see that the transaction fails. Click on the transaction log. You can see that we sent 3 million gas and we used up all of it. Furthermore, you can see here that the balance did not change since the transaction failed. So I just showed you that when assertion fails, it will use up all of the gas that you send, and state changes will be undone.
00:03:14.390 - 00:04:04.120, Speaker A: So why did this assertion fail? It failed because numbers and solidity can overflow and underflow. So let's talk about overflow and underflow, and then we'll come back to add extra validations so that these two assertions will not fail. Imagine a clock. The hours ranges from one to twelve, and any number greater than twelve will make circles around the clock and eventually land on a number between one and twelve. For example, 13 will make a circle around the clock once and stop at one. And if you add 12 hours from a position on the clock, you come back to the same exact position. So for example, starting at seven, if you add 12 hours, you come back to seven.
00:04:04.120 - 00:04:58.598, Speaker A: In solidity, the data type Un, which stands for unsigned integer, is similar to a clock, similar to a clock which ranges from one to twelve. Un ranges from zero to two to the 256 minus one, and instead of starting at twelve, it starts at zero. Like a clock, any number greater than two to the 256 minus one will wrap around and eventually fall in the range between zero and two to the 256 minus one. And like adding 12 hours to a time will get you back in the same position of the clock. Adding two to the 256 to a number will get you back to the same number. So let's say that x and Y are two uns. There is a possibility that the sum of x and y is greater than two to the 256 minus one.
00:04:58.598 - 00:05:39.922, Speaker A: In that case, the sum wraps around and starts counting from zero. This is called overflow. So let's think through how we could prevent our contract from overflowing. First, we know that adding two to the 256 to x will give us back the same number. Second, we know that all numbers are less than or equal to two to the 256 minus one. So this means that x plus Y can overflow, but it can never reach back to x, since y is less than two to the 256. Therefore, if x plus Y is greater than or equal to x, then there was no overflow.
00:05:39.922 - 00:06:15.870, Speaker A: And if x plus Y is less than x, then we know that an overflow occurred. Underflow is the opposite of overflow. A number overflows when it is greater than the maximum range. Likewise, a number underflows when it is less than the minimum range. In the case of unsigned integers, this happens when the number is less than zero. So x minus y will underflow when y is greater than x. Now that we know when numbers overflow and underflow, let's go back to our code and add extra validations.
00:06:15.870 - 00:07:13.410, Speaker A: We know that x plus y does not overflow if x plus y is greater than or equal to x, replacing x with balance and y with amount, we have balance plus amount does not overflow if balance plus amount is greater than or equal to balance. In other words, there was no overflow if the new balance is greater than or equal to the old balance. So that's the extra validation that we need to make sure that our balance does not overflow. But we shouldn't use assert since assertions should always evaluate to true. So this is where we use require. Require is used to validate inputs, state conditions before execution, and to check outputs of other functions. In this case, we're going to check that the new balance is greater than or equal to the old balance before updating the balance state variable.
00:07:13.410 - 00:08:09.810, Speaker A: When this condition is not true, require will throw an error and the transaction will fail. Require accepts an optional error message that will be shown when it throws an error, so we'll pass in the message overflow for the error message. If this condition passes, then we'll update the balance to our new balance. Now this assertion should always evaluate to true, since by the time the code reaches its bind, there was no overflow. Next, let's add some validations to our withdrawal function so that the assertion never fails. We know that x minus y does not underflow if x is greater than or equal to y, replacing the variables. The condition that we need to check for is that the balance is greater than or equal to the amount that we're going to withdraw.
00:08:09.810 - 00:08:48.100, Speaker A: If the code reaches this line, then we know that there was no underflow. So this assertion should always evaluate to true. Let's deposit again and make sure that our assertion does not throw an error. Compile and redeploy the contract. Again, deposit one and check that the balance is correct. Next, deposit this very large number again. You can see here that the transaction failed with the message overflow.
00:08:48.100 - 00:09:21.244, Speaker A: This means that there was an overflow and our required statement failed. It also means that the assertion below it never executed. When you check the transaction log, you can see that not all of the gas were used. This shows that the assertion was never executed. If it did, it would have used up all of the gas. The way you use rebirth is similar to the way you use require. However, rebirth only takes in one argument, the error message to be thrown.
00:09:21.244 - 00:09:58.620, Speaker A: So the way you will use rebirth is to write if statements for invalid conditions. When the invalid condition evaluates to true, we call the rebirth function. In this case, the invalid condition is when the balance is less than the amount to be withdrawn. When that evaluates to true, we call the rebirth function. This revert statement does exactly the same thing as the require statement above. Revert might be a better choice to use when the condition to check becomes more complex. That covers how to use assert, require, and revert.
00:09:58.620 - 00:10:41.396, Speaker A: In this video we talked about the three ways to throw an error assert, require, and revert. Assertion should never evaluate to false. If it does, then that means there's a bug in your code. Failing assertion would use up all of the gas that you sent with your transaction. Require is used to validate inputs, preconditions, and other function outputs. When a require statement fails, it does not use up all of the gas. In situation where you use a require, you can also write an equivalent code using rebirth, but rebirth is more useful than require when checking complex conditions.
00:10:41.396 - 00:10:45.750, Speaker A: That's all I got for this video. Thanks for watching and have a nice week.
