00:00:00.250 - 00:00:36.162, Speaker A: Hey everyone, how's it going? In this video, we'll take a look at a contract that is vulnerable to a denial of service. In particular, we'll look at an example of denial of service by a contract that rejects to accept ether. And then we'll write some code and then a demo. Lastly, we'll see how to turn a contract that is vulnerable to this denial of service into a contract that is not. And in the process, we'll touch on a design principle called push versus pull. All right, let's jump in. First of all, let's go over what I mean by denial service by rejecting to accept ether.
00:00:36.162 - 00:01:25.090, Speaker A: Let's say that there's some contract, and when you call this function foo inside it, first of all, it will send one ether back to you and it will make sure that that one ether was sent to you. So if it fails to send one ether back to you, then this whole function fails. After it sends one ether, it does something else below contract a. Let's say that we have another contract called contract B. And what it does is when you call this function, call Foo, it will call the foo function inside contract A. Now, contract a would try to send one ether back to contract B. But notice that since contract B does not have any fallback function, it won't be able to accept any ether sent to this contract.
00:01:25.090 - 00:02:21.450, Speaker A: So what this means here is that this function over here inside foo will fail and the code after it will not be executed. So this is a rough idea of denial service by refusing to accept ether. In this case, contract B is performing a denial service on contract A by refusing to accept the ether that is sent from contract A, and so that the rest of the code inside contract a cannot execute. So how can this cause a problem? Well, let's take a look at another contract and this attack will become more clear to you. King of ether is a contract where you can become the king of this contract by sending more ether to this contract than the previous king. And how do you become the king? Well, you can do that by calling this function claim throne. So let's take a look at what this function does.
00:02:21.450 - 00:03:15.014, Speaker A: First, it checks that the amount of ether that was sent is greater than the previous amount. And this is done by checking message value is greater than balance, where balance will store the amount of ether that was sent by the current king. If the amount of ether that was sent to this contract is greater than the previous amount, then we move on to the next line where the current king gets a refund of amount of ether that he sent, it checks that the ether was sent to the current king. And finally, it updates the balance to the amount of ether that was sent and the king to the caller of this function. For example, let's say that Alice sends one ether to become the king. So the king state variable will be equal to Alice and the balance will be equal to one ether. Now, Bob wants to become the new king, so he'll have to send more than one ether.
00:03:15.014 - 00:03:49.480, Speaker A: In this case, he'll send two ethers. So on line 17, message value will be equal to two ether. Balance will equal to one ether. This is the amount that was sent by Alice, and we can see that two ether is greater than one ether. So this check will pass on the next line. The current king is equal to Alice, so it will send one ether back to Alice. Check that the transfer of one ether to Alice was successful, and we update the balance to message value.
00:03:49.480 - 00:04:38.650, Speaker A: In this case, it will be two ethers. And finally, we update the new king to Bob. So if someone else wants to become the king after Bob, then that person will have to send more than two ethers. This is how this king of ether contract works. Let's now examine how we can perform a denial service on these two lines so that the code after it will now execute. What this means is that if we can perform a denial service here, then this code here can never execute, so the new king can never be set. We can perform a denial service to this contract by simply having a contract that does not have any fallback function and then have that function call this function claim throw.
00:04:38.650 - 00:05:07.706, Speaker A: Let's put this idea into code. Our starting point is a function called attack, and it's going to take in a single input. The input will be the address of the king of ether contract above. In order to claim the throne, we'll need to send ether to the function claimthharone. So here we'll declare this function as payable. And when we call this function, we'll send some meter. This contract will become the new king by calling claimthrown and then sending some meter.
00:05:07.706 - 00:06:03.630, Speaker A: When we call this function, we'll have to make sure that the amount of ether that is sent to this function is greater than the amount of ether that is stored over here inside balance. So if the balance is equal to one ether, then we'll have to send more than one ether. That is all the code that we have to write here in order to perform a denial service on the king of ether contract. Let's now walk through how this attack can make Kingabeather contract above unusable. Here I've deployed two contracts, kingabeather and attack contract. First, Alice sends one ether to become the king. By calling claim throne, we can check that Alice is the king, and in order to become the new king, the sender will have to send more than one ether.
00:06:03.630 - 00:06:46.350, Speaker A: So let's say that e is going to perform a denial service on the king of ether contract. So she'll have to send more than one ether. So we'll send two ether, and then she's going to call the attack function. So we'll copy the address of king of eater, paste it here, and then call the attack function. We can check back at the new king. And you can see here that this address is equal to the address of the king. Now, let's say that Bob wants to become the new king of king of ether contract, so he'll have to send more than two ethers.
00:06:46.350 - 00:07:48.332, Speaker A: But let's now see how Bob cannot become the new king even though he sends more than two ethers. So Bob is going to send three ether and then call the function claim throne. And you can see here that the transaction failed, so the attack to make this contract unusable was successful. How does it work? Let's walk through how this contract is performing a denial service. On this contract, we know that the king is equal to the attack contract, and the amount of ether that needs to be sent to become the new king is greater than two ethers. So when Bob sends three ethers, it passes this check, and then it sends two ethers back to the current king, which is the attack contract. But since the attack contract does not have any fallback function, it cannot receive ether.
00:07:48.332 - 00:08:33.710, Speaker A: So what this means here is that this transfer will fail and this whole transaction will fail. So Bob cannot become the new king, even though he sent more ether than the previous king. That is how this contract attack performs a denial service on the contract king of Ether. Let's now examine how this contract king of ether can avoid denial of service. The simple strategy here is instead of sending ether, we'll let the caller withdraw ether from this contract. And this is called push versus pull. In smart contract designs, when a contract sends an ether, it's pushing the ether to another address.
00:08:33.710 - 00:09:17.948, Speaker A: On the other hand, when we allow a caller to withdraw from the contract, then we are asking the caller to pull ether from the contract. So that is push versus pull. And here we'll remove the denial of service by, instead of pushing ether, requiring the caller to pull ether from this contract. Since we're going to require the caller to withdraw from this contract. We'll need to keep a track of how much ether that a caller has sent. So we'll store this amount for each caller in a mapping from address to unit and then name it balances. Next, we'll remove the code that sends the ether and then replace it with this code.
00:09:17.948 - 00:10:27.430, Speaker A: So here, instead of sending the previous balance to the king, we're saying that the king will be able to withdraw the amount stored in this balance plus the amount that we were going to send. Once you are no longer the king, you can call the function withdrawal to withdraw ether. So we'll require that message sender is not equal to the current king. Store the current amount of ether that message sender can withdraw in a variable called amount, and then we'll set the amount that message sender can withdraw from this contract to zero, and then send the ether to message sender. The reason why we're setting the balance equal to zero before we send the ether is to protect against rengency. Although this line of code is sending ether, we don't have to worry about denial service here, since the only person that will be affected by performing a denial service here is message sender. In other words, by performing a denial service here, this will have no effect on the rest of the code above here.
00:10:27.430 - 00:10:58.090, Speaker A: So while you can perform a denial service to yourself, everyone else can keep on playing the game. That is how you protect against this type of denial service by using a smart contract design of polling instead of pushing. Push versus pull is a really important smart contract design that you see often in solidity. Be I hope the example below help you understand push versus pull. Thanks for watching and see you soon.
