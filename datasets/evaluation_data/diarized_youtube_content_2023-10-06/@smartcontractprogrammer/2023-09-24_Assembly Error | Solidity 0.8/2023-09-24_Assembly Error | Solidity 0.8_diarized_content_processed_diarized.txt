00:00:00.330 - 00:00:34.706, Speaker A: Let's see how to throw an error using assembly. For this example, we'll pass in an input x and do some check, and if the condition fails then we'll throw an error. The way to throw an error inside assembly is to call the function called reverb, passing in parameters p and s. Just like in solidity, when there is an error, all state changes that were made up to that point will be undone. So what is this parameter? Pns. Pns tells EbM which part of memory to return with the rebirth. P will be the start of the memory and p plus s will be the end of the memory.
00:00:34.706 - 00:01:10.814, Speaker A: And this is usually used to encode some kind of error message when we call the function rebirth. But for our example, we will just keep it simple and rebirth from p equal to zero and s also equal to zero. In other words, we're going to rebirth without any error message. For our example, we'll rebirth if x is greater than ten. So I'll type if greater than. If x is greater than ten, then we'll throw an error by typing rebirth, and for the memory location to return we'll pass in zero zero, meaning that we're not going to return any error message. And this is how you would throw an error using assembly.
00:01:10.814 - 00:01:42.782, Speaker A: Let's try compiling this contract. I'll hit ctrl s inside my remix and the code compiles. Okay, so let's now deploy this, deploy the contract, and then let's call this function. So if we pass in an input of x less than or equal to ten, then we expect this function to pass. There will be no errors that will be thrown. So let's say we pass in ten, call the function, and the function passes without any errors. Okay, so next, let's pass edabin for x.
00:01:42.782 - 00:01:53.130, Speaker A: We expect this function to fail, call a function, and the function fails. So this is how you would throw an error inside assembly, by calling the function rebirth.
