00:00:00.490 - 00:00:37.746, Speaker A: Let's build a contract to crowdfund the ERC 20 token. Users will be able to launch a campaign stating their goal. This will be the amount of tokens that they want to raise, the time when the campaign will start, and the time when the campaign will end. The campaign creator will be able to cancel a campaign if the campaign has not yet started. If someone accidentally creates a campaign, they will be able to undo it by calling this function cancel sole. Once a campaign starts, users will be able to pledge to a campaign specifying the amount of tokens that they're going to send to this campaign. When this function is called, the token will be transferred over to this contract.
00:00:37.746 - 00:01:10.414, Speaker A: Perhaps the user wants to change their mind on the amount of token that they pledged. Then they will be able to call the function unpledge. Users will be able to call these two functions pledge and unpledge while the campaign is still going. Once the campaign is over, let's say the amount of tokens that were raised is greater than the goal. Then the campaign creator will be able to claim all of the tokens that were pledged. On the other hand, let's say that the campaign was unsuccessful. The amount of token pledged by all users is less than the goal.
00:01:10.414 - 00:01:44.090, Speaker A: Then users will be able to call the function refund to get their tokens back. Let's write all of this in code. Let's first define a struct. What data do we need to store in the struct campaign? I'll declare the struct, I'll name it campaign, and we'll store the address of the campaign creator. By typing address creator, we also want to store the goal. So Un goal this will be the amount of tokens that needs to be raised for the campaign to be successful. We also store some timestamps.
00:01:44.090 - 00:02:18.454, Speaker A: UN 32 start at and UN 32 end at. Notice that here I'm using UN 32 instead of UN since UN 32 is about 100 years from now. So these two timestamps are sufficient. Let's say that the campaign is over and the campaign creator has claimed the tokens inside this campaign. We want to store our data saying that the tokens for this campaign has been claimed by the creator. So we'll create a boolean and call it claimed. Next, let's declare some state variables.
00:02:18.454 - 00:02:53.022, Speaker A: For security reasons, each crowdfunding contract will only be able to handle one token. Imagine that this contract was able to support multiple tokens and one of the tokens has a vulnerability. Then this would put all of the tokens locked in this contract at risk. So to minimize the risk, we will only support one token per contract. We will store the token in IErc 20. This will be public, and since the token will not be changing, we will make it immutable and then we'll name it token. Next we'll start mapping up the campaign.
00:02:53.022 - 00:03:35.570, Speaker A: So say mapping from UN will be the id of the campaign to campaign. This will be public and I'll name it campaigns. Now, to generate a unique ID for each campaign I'll create the variable called Un public count. Every time we create a new campaign, this count will increment. Here you can use array instead of a mapping, but we don't really care about the ordering so instead we'll be using a mapping. The last state variable that we're going to need is how much amount of token has each user pledged to a campaign. So we'll create a mapping from campaign ID.
00:03:35.570 - 00:04:14.106, Speaker A: This will be un to another mapping from address. This will be the user address to Un. This will be the amount of token that is pledged public. I'll name this pledged amount. Next we will write a constructor to initialize the state variables. So I'll say constructor, it's going to take in the address of the token and we'll set the token to IERC 20 from address of the token from the input. And that is the only variable that we need to initialize for this contract.
00:04:14.106 - 00:05:04.462, Speaker A: So next we'll write the function for lunch. We'll first check that the inputs are valid. Start at should be greater than or equal to the current block timestamp and end at should be greater than or equal to start at. And lastly, we'll bound end at to say that it must be less than or equal to 90 days from the current block timestamp. So we'll type require start at should be greater than or equal to the current timestamp. Block timestamp with the error message start at less than now we'll require that NDAT is greater than or equal to start at. So require NDAT greater than or equal to start at with the error message.
00:05:04.462 - 00:05:54.430, Speaker A: End at is less than start at. And lastly we'll bound end at to say that it must end 90 days from now by typing require end at must be less than or equal to block timestamp plus 90 days with the error message and that is greater than max duration. Next, we'll store these input into a new campaign struct. The first thing that we will do is increment the ID which is stored in count. So I'll say count plus equals one. And then we'll type campaigns of count is equal to the campaign struct. The creator is message sender.
00:05:54.430 - 00:06:29.398, Speaker A: The goal is goal from the input, the total amount pledged is zero. I think I forgot to add pledge to the struct. So I'm going to scroll back up and then inside here say un pledged. This will store the total amount of tokens that are pledged to this campaign. Okay, scrolling back down. Start at will be start at from input. Likewise for end at will be from input and lastly, claimed will be false.
00:06:29.398 - 00:07:18.486, Speaker A: And then we'll emit an event. I'll name this launch with the campaign id creator, the goal and the timestamps start at and end at. Scroll up and then we'll define the event launch. Event launch. And then we'll say Un ID address indexed creator. Here we are putting indexed on the creator so that we can find all campaigns that are launched by the same creator. Un goal, Un 32 start at and UN 32 end at.
00:07:18.486 - 00:08:13.626, Speaker A: So that completes the launch function. Let's now write the function for cancel. To be able to cancel a campaign, the campaign must exist. Only the campaign creator should be able to cancel it, and the campaign should not have started yet. So we'll type campaign memory. Campaign is equal to campaign from the mappings at the id, and then we'll require that message sender is equal to campaign creator with the error message not creator. We will also require that the current block timestamp is strictly start at, meaning that the campaign has not yet started with the error message started.
00:08:13.626 - 00:09:00.330, Speaker A: So if these two conditions are met, we'll go ahead and delete the campaign by typing delete campaigns of ID. Lastly, we'll emit the cancel event by typing emit cancel ID, scroll up and then we'll define an event called cancel event. Cancel event ID of the campaign. The next function that we will write is pledge. Once a campaign starts, users will be able to pledge tokens into the campaign. First we'll get the campaign by typing campaign storage. Here we're declaring this variable as storage because we're going to need to update the campaign struct.
00:09:00.330 - 00:10:12.106, Speaker A: Campaign is equal to campaigns of ID. First we'll require that the campaign has started by typing require block timestamp is greater than or equal to campaign start at with the error message not started. We also require that the campaign has not yet ended. Block timestamp should be less than or equal to campaign end at error message ended here. Notice that if the campaign does not exist, meaning that user is pledging to a campaign that's not been launched, then end that will be equal to zero, so this statement block timestamp will not be equal to zero, so this condition will fail so users won't be able to pledge to a campaign that does not exist. And then we'll update the campaign struct by typing campaign pledged plus equals the amount of token to be transferred. Again, remember that pledged holds the total amount of tokens that's been transferred for this campaign.
00:10:12.106 - 00:11:45.898, Speaker A: Once the campaign ends, and let's say that the campaign was unsuccessful, then the users will need to be able to withdraw their tokens that they pledged. So we'll need to store the amount of tokens that's been pledged for this campaign by this user in the mapping pledged amount of Id for message sender plus equals amount. Then lastly we'll transfer the token by calling token transfer from message sender to this contract. Address this for the amount amount and lastly we'll emit the event emit pledge. We'll log the campaign Id, message sender and the amount that was pledged. Scroll up and then we'll define event pledge, and then we'll log the campaign ID un indexed ID here I'm putting indexed on the id pledge because many users will be able to pledge to the same campaign address indexed caller a caller is indexed because the same caller can pledge to many campaigns and then un amount and that completes the function to pledge. Let's now write the function to on Pledge first I'll get the campaign by saying campaign storage.
00:11:45.898 - 00:13:17.530, Speaker A: Again, we're declaring this variable as storage because we're going to be updating the campaign struct campaign is equal to campaigns from the id. User shouldn't be able to unpledge from a campaign that ended, so we'll type require the current timestamp is less than or equal to campaign end at with the error message ended. Once we know that the campaign is still active, we'll transfer the token back to the user. Then we'll also deduct the amounts from the campaign strip by typing campaign pledged minus equals amount, and then we'll also deduct from the mapping pledged amount for the id by message sender minus equal amount. And lastly we'll transfer the token token transfer to message sender amount, and then we'll emit the event on pledge. We'll log the id, message sender, and amount scroll up and then we'll define the event for unpledge. The unpledge event will be similar to this pledged event, so I'll copy it, paste it, rename it to unpledge and the rest of the parameters, we'll keep it the same.
00:13:17.530 - 00:14:29.858, Speaker A: Two more functions to go let's now write the function for claim once the campaign is successful, meaning that the total amount that was pledged is greater than or equal to goal, then the campaign creator is able to claim the tokens for the campaign. Again, we'll start by getting the campaign as a storage variable, since we're going to be updating it, and then we'll require that message sender is equal to campaign creator with the error message not creator. We also want to make sure that the campaign has ended by typing require block timestamp is strictly greater than campaign end at with the error message not ended. We also want to make sure that the amount pledged is greater than or equal to the goal. So we'll type require campaign pledged is greater than or equal to campaign goal. For the error message, we'll say pledged is less than goal. And lastly, we want to make sure that claim has not been called for this campaign yet.
00:14:29.858 - 00:15:53.870, Speaker A: By typing require not campaign claimed error message claimed, we'll first set the claim to true by typing campaign claimed is equal to true. Notice that for each campaign, the function claim can only be called once, and then we'll transfer the token out. By typing token transfer to campaign. Actually, I'll use message sender here since we know that campaign creator is equal to message sender, and accessing message sender is cheaper on gas than accessing the state variable, campaign creator. So message sender, campaign pledged pledge will hold the total amount of tokens that were transferred in for this campaign. So here we're transferring to campaign creator the total amount that was pledged. And lastly, we'll emit the event emit claim campaign Id scroll up and we'll define event, event claim, un ID, and the last function that we'll write is refund.
00:15:53.870 - 00:17:45.134, Speaker A: If the campaign was unsuccessful, meaning that the total amount that was pledged is less than the goal, then users will be able to get a refund transfer their token out of the campaign. We'll using a similar logic to this, so I'll copy this, then paste it here. We'll get the campaign we don't need to require that message sender is the creator campaign should be ended, and the amount that was pledged should be strictly less than the goal. In this case, we'll refund message sender by typing unit Dow is equal to pledge amount for the ID for message sender, get the balance and then reset the pledged amount for ID. Message sender is equal to zero and then we'll transfer the token out. Token transfer to message sender Val now the reason why we're resetting the balance before retransuring the token out is to prevent reentry effect. Once all of the tokens are refunded, we'll emit the event refund for campaign id message sender for the amount Val scroll up, and then we'll define event for refund event refund un ID there can be multiple refunds for the same campaign, so I'll make ID indexed and then address indexed caller un amount we'll compile the contract, deploy it, and run some examples.
00:17:45.134 - 00:18:42.734, Speaker A: For this example, I've already created an ERC 20 contract which I've copied and pasted into here from soliditybyexample.org. So first we'll deploy the ERC 20 contract, so I'll compile it, and then we'll deploy ERC 20 contract, and then next we'll compile the crowdfunding contract, and then deploy it. The crowdfunding contract needs an address for the token, copy the address of the ERC 20 contract, paste it here, and then hit deploy. We'll say that the campaign creator is the first account, and the user that's going to pledge the campaign is the second account. So we'll mint some tokens to the second account, click on the ERC 20 contract, and then we'll mint 100 token to the second account. Next we'll launch the campaign. So I'll switch back to the first account, this will be the campaign creator, and then we'll call the function launch.
00:18:42.734 - 00:20:06.330, Speaker A: We'll say that the goal is 100 and for the start at we'll put a timestamp that is close to now. So I'll put my JavaScript console and type new date gettime divided by 1000, and to this number we'll add an extra 100 seconds, copy this, paste it here, and we'll say end that in another 100 seconds, hit transact transaction is successful, so the campaign now started. We'll switch back to user two, and he's going to pledge to campaign one, but before he does that he needs to approve this contract to be able to spend the token. So I'll copy the address, open the contract, Spender will be the crowdfunding contract for the amount 100 hit approve, scroll down, and then the user will pledge to campaign one for amount 100, and then hit pledge. The campaign has not yet started, so I'll wait a few seconds and then hit pledge again, and the transaction is successful. Now I'm going to wait a few more seconds for the campaign to end. In the meantime, I'll hit campaigns one to get the data for the campaign and you can see here that the goal was 100 and so far we have 100 pledged so once this campaign ends, this campaign will be successful.
00:20:06.330 - 00:20:56.890, Speaker A: We can also see that the pledged amount for campaign one for the address account, the second account, copy it, paste it here and the pledged amount is 100. This account has pledged 100 token to campaign one. I've waited a few seconds and we know that this campaign is going to be successful so let's try calling the function claim. The function claim can only be called by the campaign creator so we'll have to first switch the account to the campaign creator which is account number one. Scroll down and then we'll call claim on campaign one and the transaction is successful. So this campaign in debt and it transferred 100 tokens from account number two to account number one the campaign creator.
