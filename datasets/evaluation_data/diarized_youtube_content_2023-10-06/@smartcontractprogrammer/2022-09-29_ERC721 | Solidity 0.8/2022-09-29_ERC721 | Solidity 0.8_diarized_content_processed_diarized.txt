00:00:00.250 - 00:00:28.614, Speaker A: Let's write our own ERC seven two one contract, also known as NFTs. First, we'll need to declare some interfaces that we're going to be needing for this contract. The first interface is an IERC one six five. We're also gonna need an interface IERC seven two one, and this will inherit IERC one six five. Our contract. ERC seven two one will implement IERC seven two one. So here I'll say erc seven two one is Ierc seven two one.
00:00:28.614 - 00:00:55.594, Speaker A: Now, the functions inside here, we'll implement it later. The last interface that we're going to need is called IERC seven two one. Receiver. Inside this interface we'll need to call this function on ERC seven two one received. When we call the function safe transfer from inside ErC seven two one. Okay, let's now write the code for ERC seven two one. We'll first copy and paste some events that we need to implement.
00:00:55.594 - 00:01:27.058, Speaker A: The events that we're going to need is transfer approval and approval for all. Next, let's declare some state variables. We're going to need to store the owner of each NFt. So I'll create a mapping from UN to address. Un will represent the NFT ID and address will represent the owner of the NFT. I'll make the visibility of this mapping internal and then I'll name it underscore owner of. Next, we'll need to keep track of the amount of NFT that each address owns.
00:01:27.058 - 00:02:14.594, Speaker A: So I'll create a mapping from address to UN. The address will be the count and UN will be the count of NFT owned by the address. Again, I'll declare this as internal and then I'll name it underscore balance of the owner of the NFT might approve another address to take control of his NFT. So we'll store it in a mapping mapping from UN to address. UN will be the NFT ID and the address will be the address that was given approval to spend the NFT on behalf of the owner. This will be internal and I'll name it underscore approvals. Let's say that Alice owns NFT ID code one and approves ball to spend the NFT on her behalf.
00:02:14.594 - 00:03:07.638, Speaker A: Then UN will be NFT id go to one and the address will be address of ball. This will tell that Balb has permission to spend NFT ID go to one. Perhaps the owner owns many NFTs. In that case, instead of getting approval for each NFT, we can give approval to a single address. So we'll say mapping from address this will be the address of the owner of the NFT to another mapping and then address this will be the address that was given permission by the owner to spend the NFT and then boolean. True means that this address, the operator will be able to spend the owner's NFT, and false means that the address that is stored here does not have permission to spend the NFT owned by this address. We'll make this mapping public and then name it is approve for all.
00:03:07.638 - 00:04:28.994, Speaker A: Now the reason why I made this mapping public is because if I scroll up and expand the interface for IRC seven two one and then scroll down, you can see that one of the function that we'll need to implement is called is approved for all which we've implemented here. Okay, so these are the minimal state variables that we'll need to store inside the ERC seven two one contract. Next, let's move on to functions. The first function that we'll need to implement if I open the interface for ierc seven two one is since this interface is Ierc one six five, let's implement this function. So I'll copy this function, then scroll down and then paste it here and here. We'll need to return true if the interface id passed from the input matches the interface id for either ierc seven two one or rec one six five. So here I'll type return interface id from input is either equal to type rec seven two one interface id or interface id is equal to type ierc one six five dot interface id.
00:04:28.994 - 00:05:38.154, Speaker A: Okay, let's implement the next function. What is the next function that we'll need to implement? Let's start with the easy ones, balance up and owner up. So actually I'll copy all of this and then paste it here. And the function that we'll implement is balance of and owner of the balance of function returns the amount of NfT owned by the owner. And the requirement here for erc seven two one is that owner cannot be equal to address zero. So I'll type require owner not equal to address zero with the error message owner is equal to zero address and then return balance of brackets owner okay, let's implement owner of according to the specs, call to function must fail if owner of token ID is the zero address. So I'll say owner, notice that the variable owner I declared it here so I don't have to declare inside here owner is equal to owner of token ID.
00:05:38.154 - 00:06:30.022, Speaker A: Next we'll check that this owner is not equal to the zero address. So I'll type require owner not equal to address zero and the error message owner is equal to zero address. Okay, the next function that I'm going to implement is setapproval for all. So I'll cut this and then paste it here. By calling setapproval for all, you are setting the permission for operator to either take control of all of your NFDs or to revoke that permission and this permission is stored in the mapping is approved for all so I'll say is approved for all of the address. For the first mapping will be the address of the owner. The next address represents the operator and the last boolean represents the permission.
00:06:30.022 - 00:07:24.470, Speaker A: True means that the owner has given the operator permission to take control of his NFT and if it is false, this means that the owner has not given access or has revoked the permission for the operator to take control of his NFT. So is approved for all. The first address will be message sender. The next address that you see over here will be the operator and then the last parameter is approved. If this is true, this means that message sender has given permission to operator to be able to spend his NFT and if this is false, this means that message sender has revoked all permissions for operator to spend his NFT and then we'll emit the event. Emit approval for all. What are the parameters that we need to log? Owner, operator, and approved.
00:07:24.470 - 00:07:56.718, Speaker A: So owner, message sender, operator, operator, and approved. Okay, that completes the function. Set approval for all. Next, let's work on a similar function called approve. So I'll cut this scroll up and then paste it here. The approve function gives permission to the two address to take control of token iD. The caller of this function will either have to be the owner of token id or has permission to spend the token.
00:07:56.718 - 00:08:45.442, Speaker A: So first we will get the address of the owner. Address owner is equal to underscore owner of token ID. Next we will check the permissions so say require either message sender is equal to owner or the owner of the token has given message sender permission to spend the token. So is approved for all owner from the owner to message sender. If both of these conditions are false, then we'll say that the error message is not authorized. Next we'll set the approval for the token iD. So type approvals of token ID is equal to the two address.
00:08:45.442 - 00:09:13.018, Speaker A: Here we're saying this two address has the permission to spend token ID and then lastly we'll emit the event approval. Let's scroll up and see what parameters we need to log. Approval owner spender and the token id owner spender will be the two address and token id. Token id. Okay, that completes the function approved. Let's move on. The next function that I want to implement is getapprove.
00:09:13.018 - 00:10:00.242, Speaker A: So I'll copy this and then paste it here. This function will return the address of the approval assigned to token id. So what we're returning is the address stored for approvals for token id. Now there is an additional requirement for this function that the owner of token id must exist. So we'll say require owner of token id should not be equal to address zero, else the error message token does not exist and then we'll return underscore approvals of token id. Okay, the next function that we're going to be working on is transfer from. Now, notice that there are two variations and inside it there's going to be some code logic that we'll be able to reuse.
00:10:00.242 - 00:10:49.718, Speaker A: So first I'll implement an internal function. I'll implement an internal function called function underscore is approved or owner. This function will take in three inputs, address of the owner, address, spender, and un token id. This function will be internal view returns, Boolean. What this function does is check whether spender is owner of token id or whether the spender has permission to spend the token. So we'll type return. Either spender is equal to owner or the spender is an operator is approved for all from owner to spender or spender is approved.
00:10:49.718 - 00:11:48.990, Speaker A: Spender is equal to underscore approvals of token iD. Okay, that completes the internal function is approved or owner. The next function that I'm going to implement is transfer from and then later we'll use this transfer from function inside safe transfer from. So paste the code here. Since we're going to be calling this function inside safe transfer from I'll change external to public this function will transfer the ownership of NFT from to the address for the token id. So first we'll require that from is equal to owner of token id with the error message from is not equal to owner. We also need to check that the address two is not the zero address require two is not equal to address zero with the error message two equals zero address.
00:11:48.990 - 00:12:41.646, Speaker A: Next we'll check the permissions, so we'll be calling this internal function is approved or owner, so require underscore is approved or owner. I'm going to score up from the first check. We know that the owner is equal to the from address, so owner will be from the spender will be message sender. So message sender and the token ID will be the same token ID token ID. If this check fails, we'll say not authorized once it passes these checks. Next, we'll actually transfer the ownership of NFD, so we're transferring from to so first I'll update the balance of balance of from. We'll need to decrease the balance of from by one so minus minus and then we'll need to increase the balance of two by one.
00:12:41.646 - 00:13:38.046, Speaker A: Underscore balance of two plus plus we'll need to update the owner of so owner of Token ID. The new owner will be equal to the two address. Next we'll delete the approvals by typing delete underscore approvals of token ID and then lastly we'll emit the event transfer. I'm going to scroll up and see what parameters we need to log for the event transfer from to token id. Scroll down from token id okay, that completes the function. Transfer from next let's implement safe transfer from so this is a function similar to transfer from. The difference is if two is a contract, then we'll need to call the function rec seven two one receiver on Erc seven two one received.
00:13:38.046 - 00:14:19.166, Speaker A: So scroll down. First thing that we'll do is call transfer from transfer from from to token id and then we'll need to check whether the two address is a contract. If it is a contract, then we'll need to call this function. So I'll copy this function and then paste it here. This is the function that we'll need to call. I'll put a comment for now, then we'll call this function if the two is a contract, so I'll type require two code length is equal to zero. This means that the length of the code stored at the address two is zero.
00:14:19.166 - 00:15:07.038, Speaker A: So this will mean that the two address is either not a contract or it is a contract that was just deployed in this transaction. If two co length is equal to zero, then we won't need to call this function. Otherwise, if the length is greater than zero, then we'll need to call this function. So if it is not zero, then we'll need to call IERC seven two one receiver on the two address. You'll need to call this function on Erc seven two one received. The address of the operator will be message sender from token id will be token id from the input and call data. Since we're not passing any call data, we'll pass in empty bytes and this will return four bytes of interface id.
00:15:07.038 - 00:16:04.914, Speaker A: So we'll need to check that the interface id that was returned is equal to IERC seven two one receiver on ErC seven two one received selector. If either of these check fail, then we'll say that the error message is unsafe recipient and that completes the function. Safe transfer from next, let's implement safe transfer from this is almost the same as the function that we just implemented, except that now as input it is passing some data. So I'll copy all of this, paste it here, and instead of passing empty data I'll pass in data. Okay, I think I implemented all the function for erc seven two one let's try compiling it. I'll hit ctrl s and then I see some errors. So I'll open the compilation logs and the first error I see is on line 68.
00:16:04.914 - 00:16:58.046, Speaker A: Line 68. So as input I passed an interface id with a capital d, but inside the function I'm using a lowercase d. So I'll fix this by lowercasing the d in the input. Okay, let me scroll down and see the other error is it's also on 968, so I think we fixed error. Let's try compiling again and the contract compiled. Now before we move on, let's implement some functions that are useful but are not required for erc seven two one the two function that I want to implement is mint and burn and these will be internal function. So I'll say function underscore mint it will take in two parameters, address two the address to mint the new NFT two and un token id the id of the NFT to mint this will be internal.
00:16:58.046 - 00:18:01.894, Speaker A: Then we'll require that the two address is not the zero address not equal to address zero. Error message two is equal to zero address and we also require that the token Id to mint is unique. So we'll say require underscore owner of Token ID is equal to address zero if it is an existing token, then owner of Token iD will not be equal to address zero. Otherwise, if it is new, then the owner of this new token id will be equal to address zero with the error message token exists once it passes these checks. Next we'll update the balance of and owner of underscore balance of two incremented by one. Then owner of two token id is equal to two. Then we'll emit the event transfer this is similar to ERC 20 transfer transfer from address zero to two token id token id okay, let's implement the burn function.
00:18:01.894 - 00:19:19.886, Speaker A: Function underscore burn un id internal first we'll check that the token exists. So I'll say address owner is equal to owner of token id and then check that the token exists by checking that the address owner is not equal to address zero. Require owner is not equal to address zero with the error message token does not exist. Once we know that the token does exist, first thing that we'll do is update the balance of decrease it so balance of owner minus minus since we're destroying this token, we'll delete the owner of delete underscore owner of Token ID and then also delete all approvals associated with this token. Delete approvals of token id and then we'll emit the event transfer from owner to address zero token id token id the last part of this video is to create a custom NFT using this contract as the base contract. So scroll down and then say contract. My Nft is erc seven two one.
00:19:19.886 - 00:19:56.518, Speaker A: To mint a new token, we will create a function called mint and then address to un token id. This function will be external and then we'll simply call the internal function underscore mint that we just put over here. So underscore mint two token id. Next we'll implement a function to burn the NFT. So function burn un token id external. Then we're going to be calling the internal burn function. But before we do that, we want to check that message sender is the owner of token iD.
00:19:56.518 - 00:20:17.210, Speaker A: So say require message sender is equal to underscore owner of token id error message not owner and then call internal function burn with token iD. And that completes the simple contract for ERC seven two one and a custom mynfd.
