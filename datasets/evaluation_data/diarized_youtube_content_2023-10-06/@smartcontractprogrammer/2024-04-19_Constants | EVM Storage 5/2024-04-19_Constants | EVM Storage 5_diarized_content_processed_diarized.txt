00:00:00.360 - 00:00:31.124, Speaker A: Constants and immutable variables that are declared inside. Oscillating smart contract does not use storage slots. For example, let's say that we have a state variable, uint 256 public. I'll name it s two and we'll set this equal to one and we'll create another state variable, unit 256 public. I'll call this one s one equals to two. And let's say that in between these state variables we have a constant and an immutable variable. For example, let's say unit 256 public constant.
00:00:31.124 - 00:00:56.382, Speaker A: I'll name this x and I'll set this equal to one to three. I'll also create an immutable variable. Let's call this address public immutable and I'll call this owner. Then inside the constructor I'll initialize this immutable variable. Constructor owner is equal to message sender. The first slot slot zero in EBM storage is taken up by the first state variable. S zero.
00:00:56.382 - 00:01:29.972, Speaker A: S zero will be stored in slot zero. The next state variable that we have is this one s one. This will be stored in slot one. Okay, but how about this constant next and this immutable variable owner, where are they stored? Starting with constants. Constants will be hard coded inside the code of the smart contract. And for immutable variables they are also hard coded. But when the code is compiled, the code will have a placeholder and when the contract is deployed, that placeholder will be replaced by the actual value.
00:01:29.972 - 00:02:13.578, Speaker A: In both cases, constants do not use any slots. They are stored as bytecode inside a smart contract. And to show you this, I'm going to create a function to read slot zero and slot one function. Get slots public view returns uint 256. You'll get the first value stored in slot zero. I'll name this b zero and then we'll get the next value that is stored in slot one. I'll call this b one and then you'll use assembly assembly b zero, get the data that is stored in slot sload zero, get the data stored in slot zero, and for b one get the value stored in slot one.
00:02:13.578 - 00:02:56.594, Speaker A: We will call this function to get the value stored in slot zero and to get the value stored in slot one. And what we want to confirm is that inside slot zero this value one is stored and inside slot one this value two is stored. So let's compile a contract and then deploy it and then call the function test get slots and we get the values b zero is one. This is because in slot one we have this state variable and b, one is two. And this is because in slot one we have this value, these two constant and immutable values that are declared in between. These two state variables are hard coded inside the smart contract and therefore they don't take up any slots.
