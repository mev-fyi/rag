00:00:00.330 - 00:00:37.878, Speaker A: Let's look at examples of how to write loops using assembly. We'll look at how to write for loop, we'll look at how to write while loop, and I'll give you examples using two functions. The first function will use a for loop to sum the numbers up to n, and then for the next example, we'll write a function that will calculate a power of two. So first, let's start with the basics. To write a for loop inside assembly, we will start with four, and then we need three open and closing curly braces. Inside the first curly braces, we'll write some code that will initialize a local variable. So let's say that I is equal to zero.
00:00:37.878 - 00:01:19.894, Speaker A: We're saying that we're going to start this for loop from I equals zero. In between the two curly braces, we will write our condition. We will run the for loop ten times, so less than I less than ten. And then inside the second curly braces we'll write a code that will execute after the for loop, what we're going to do is increment I by one, I is equal to add to I one. So what's going on here is we're running a for loop from I equals zero while I is less than ten, and then after one iteration, we'll increment I by one. Inside the last curry braces, we'll write our code. For this example, we have a variable named z initialize over here.
00:01:19.894 - 00:01:42.602, Speaker A: Let's just increment z by one. Z is equal to add to z one. Okay, so this is an example of a for loop. Let's take a look at an example of a while loop. We'll first initialize the while loop by declaring a local variable. This will be the variable that keeps track of the number of iterations in the while loop. Let I equals zero.
00:01:42.602 - 00:02:17.670, Speaker A: Now, surprisingly, to write a while loop inside assembly, we're going to use the same syntax as over here. So I'll copy this and paste it here. Since we're going to be using the while loop, we're not going to need this. And we'll increment this variable I inside the while loop. So we're also going to remove this, and let's run the while loop five times, starting from zero. And inside the while loop, let's increment this counter variable. Say I is equal to add to I one, increment it by one, and then we also increment z by one.
00:02:17.670 - 00:02:51.122, Speaker A: Z is increment z by one, add to z one. Okay, so these are two basic examples of for loop and while loop, let's move on. Let's use a for loop to write a function that will sum the integers from one all the way up to n minus one. So say four. Then we're going to prepare the curly braces. We're going to sum all the integers from I equals one all the way up to n minus one. So for the initialization code we'll say let I start from one.
00:02:51.122 - 00:03:29.886, Speaker A: We will run the loop while I is less than n, less than I less than n, and after each iteration we will increment I by one. I equals add to I one. The variable z keeps track of the sum. So to this z we'll add I to z add to z I. Okay, so this is an example of using a for loop to find the sum of integers from I equals one all the way up to n minus one. Okay, let's move on. For the last example, we will write a function that will calculate x raised to the power of n, where n is a power of two.
00:03:29.886 - 00:04:05.978, Speaker A: So n takes on the form n is equal to two to the k, where k is some other number. And for this example we'll keep it simple and assume that x is greater than zero, and that no overflow will occur. We'll approach this problem in two steps. We'll first write the algorithm in the ideal case, and then in step two we'll handle the edge cases. The cases that we'll need to handle are when n is equal to zero and when n is greater than zero. And we'll also check that n is a power of two. So in the ideal case, n will be greater than zero and n will also be a power of two.
00:04:05.978 - 00:04:35.042, Speaker A: So for now we'll assume that n is greater than zero, and we'll initialize z to equal to x. And we can do this since we're assuming that n is greater than zero. Next, we'll use the for loop syntax to calculate x to the n. Say four curly braces. Curly braces. And then inside the last curly braces we will write our code that will calculate x to the n. For now, we're going to assume that n is a power of two, and let's say that n is equal to two.
00:04:35.042 - 00:05:13.326, Speaker A: Then how will we run one iteration, we initialize z equal to x, and this algorithm somehow needs to return x raised to the power of two. We can do this by simply saying z multiply by mo, z by itself. The z that we're going to be returning is multiply z by z, since we initialize z to x. This z will be x raised to the power two. Say n is equal to div n by two. Now, if we started out with n equal to two, and then we divide n by two. Now n is equal to one.
00:05:13.326 - 00:05:45.514, Speaker A: So how can we end this? For loop n is equal to one and we want to end this loop so we can say greater than n one. Let's check that this algorithm is correct for n equal to two. So for n equal to two, we initialize z to x. And then this condition is true. So we run the for loop z is equal to x, x multiplied by itself. We get z is equal to x square, and then the new n will be the current n, which is equal to two divided by two. So the new n will be equal to one.
00:05:45.514 - 00:06:18.946, Speaker A: On the next iteration, n is equal to one. So the for loop ends and the final output z will be equal to x square. So this code is correct when n is equal to two. How about when n is equal to four? When n is equal to four, on the first iteration, we will get z equal to x squared and n will be equal to two. On the next iteration, we have x squared multiplied by x squared, which is equal to x to the fourth. And since n is equal to two, the new n will be equal to one. And then on the next iteration, this part of the condition will fail.
00:06:18.946 - 00:06:48.990, Speaker A: So we exit the loop and we end up with z equals to x raised to the four. And you can also check for yourself that this code is correct for n equal to eight and for all n of the form two raised to some power of k. Okay, next, I want to handle some edge cases. We assume that n is greater than one. But how about the case for n equals zero? So we'll type switch n. There are two cases to handle. When n is equal to zero case zero.
00:06:48.990 - 00:07:18.578, Speaker A: Then to z we'll simply return one, assign to z one. Otherwise default. We assign z to be equal to x and then remove this code. When n is equal to zero, then this part of the code will execute. Z is set to one, and since n is equal to zero, this for loop will not execute. So we simply return z equals one. When n is greater than zero, then this part of the code will execute.
00:07:18.578 - 00:07:51.378, Speaker A: Okay, so this handles one edge case. Next, I want to handle a case where n is not a power of two. What we're going to do is at each iteration we're going to check that n divides by two. If n does not divide by two, then we know that n is not of the form two raised to the power of k. So first we'll check here. If mod n two, then we owe rebirth zero zero. What this code over here is doing is that if n is an even number, if n divides by two, then this part of the code will return a zero.
00:07:51.378 - 00:08:12.330, Speaker A: So the code inside the curly braces, this part will not execute. In other words, it will continue executing the rest of the code. However, if n is an OD number, then this part of the code will return a one. And then we throw an error over here. So the code will finish execution over here. And then we'll do the same inside the for loop as well. So copy this and then paste it here.
00:08:12.330 - 00:08:34.122, Speaker A: At the beginning of each iteration we check that n divides by two. If it does not, then we know that n is some od number. So we'll throw an error. If n does divide by two, then we'll continue executing the rest of the code. And this is how you would check that n is of the form two raised to some power of K. Okay, let's try compiling this contract. Hit Ctrl s contract compiles.
00:08:34.122 - 00:08:59.270, Speaker A: Let's deploy this contract. Let's call the function sum. Let's sum all the numbers up to five, and this will exclude five. So we're summing one plus two plus three plus four. One plus two plus three is equal to six, plus four is equal to ten, so we should get a ten back. And we do. Next, let's call this power two k function.
00:08:59.270 - 00:09:29.340, Speaker A: Let's compute two raised to the power of eight, and then we get 256 back. How about for n, we put in some number that is not of this four n equals two to the k. For example, let's put in three, and then let's call the function, and as expected, the function fails. And lastly, let's put in another number. Let's say three raised to the power of four. We expect it to be 81. Call the function, and we get an 81 back.
