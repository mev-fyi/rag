00:00:00.250 - 00:00:28.118, Speaker A: We're gonna build a simple smart contract that will always return the number 42. And we're using bytecode to build this contract. So in this video I'm gonna talk about runtime code, creation code and then we'll write a factory contract that will deploy this contract that always returns 42. So to start off with let's talk about runtime code we want this contract to always return the number 42. No matter what function you call it. It would just return the number 42. To do this we'll use the opcode return.
00:00:28.118 - 00:01:00.174, Speaker A: This takes in two parameters, P and S. And this opcode will end the execution of the code and return the data from memory from p to p plus S. So what we're going to do is craft sequences of opcodes so that it will return 32 bytes from memory. And inside this memory we will store the number 42. So let's start off by crafting the opcodes for returning 32 bytes from memory. So the last step will be return. And before that on the EBM stack we'll need to store the inputs p and S.
00:01:00.174 - 00:01:47.950, Speaker A: We'll store 32 bytes starting from memory zero. So for p we'll do push 10 and starting from memory zero we'll return the next 32 bytes. So we'll push 32 push 10 x 20 x 20 is 32 and hexadecimal. So this is the sequence of opcodes that will return 32 bytes from memory starting at memory zero. So the next thing that we'll do is we'll make sure that the number 42 is stored in memory zero and it has the size 32 bytes. To store the number 42 to memory we're going to be using the opcode M store this opcode will consume two inputs, P and B. And what this opcode does is it's going to store the value B at memory p to up to p plus 32.
00:01:47.950 - 00:02:18.986, Speaker A: In other words, it's going to use 32 bytes starting from memory P and store the value B at p. Let's write this as a sequence of opcodes we're going to be using M store. And before we call this opcode we'll need to prepare two inputs onto the stack p and then b. We'll store the number 42 starting at memory zero. So we'll say push one, push to stack the number zero. Next we'll store the value v onto the stack. The value that we're going to be storing is 42.
00:02:18.986 - 00:02:54.930, Speaker A: So I'll say push one and then I'll put 42. Now to avoid confusion with hexadecimal and numbers I'll convert this 42 into hexadecimal. In hexadecimal, this will be zero x two a. Let's quickly go over what this sequence of upcodes do. First, onto the EBM stack it will push zero x two a, which is 42. Next it would store zero onto the stack and then it would call mstore. Mstore will consume two inputs from the stack, so it will first consume what is on top, which is zero, and then consume the next one, which is zero x two a.
00:02:54.930 - 00:03:22.138, Speaker A: When this part of the opcodes finish executing, we have executed this part of the code. Mstore mme zero store 42. Okay, next I'm going to translate this sequence of opcodes and this sequence of opcodes into bytecode. Here is the translation of these opcodes into bytecode. This is our runtime bytecode which will simply return the number 42. So that is runtime code. Next I'll talk about creation code.
00:03:22.138 - 00:03:46.290, Speaker A: Creation code is the code that will deploy the smart contract and the runtime code. When the contract is deployed for the first time, it will first execute the creation code. And inside the creation code we must return the runtime code. For this example, we'll simply return the runtime code. So let's write the creation code. The first part of the creation code is to store the runtime code to memory. This is our runtime code.
00:03:46.290 - 00:04:20.526, Speaker A: So I'll copy this and then paste it here, and then we'll store this to memory. So again we'll be using m store. We'll store this runtime code to memory at zero. So you'll need to push 10. And if you check this runtime code, it has 20 characters divide by two and ten bytes. So what we're going to do is push ten bytes to the stack by typing push ten and then pasting the runtime code. So what this part of opcode is doing is that it's storing the runtime code at memory zero.
00:04:20.526 - 00:04:42.582, Speaker A: The final part of the creation code is to return this runtime code. Now, the runtime code is stored as 32 bytes in memory. Starting at zero. The opcode mstore stores 32 bytes. So this runtime code is padded with zeros on the left. So what we need to figure out is the offset which turns out to be 22. Let me explain.
00:04:42.582 - 00:05:38.070, Speaker A: To be clear that this is not a number and it is a bytecode, I'll put a zero X first. Now when we execute this part of the opcode inside memory, what's actually being stored is this. Since mstore stores 32 bytes, our runtime code is padded with zeros on the left. If you count all of the zeros on the left, it turns out that this is 22 bytes. So to return ten bytes, this part of the code, which is our runtime code, we'll need to tell EBM to return this part of the code by saying start at memory 22 and then read the next ten bytes. So the opcode that we're going to be using is return next on the stack we need to store the position to start reading from memory the offset 22. So you say push 122 22 in hexadecimal is zero x 1616 plus six is equal to 22.
00:05:38.070 - 00:06:19.442, Speaker A: And the last opcode that we'll prepare is to push ten on the spec. So we'll type push 10 x ten and hexadecimal is eight. This sequence of opcodes will end the execution of the code and then return the bytecodes starting at zero x 16, which is 22 from here, the next ten bytes or zero x eight, this will return our runtime code, which is this part of the code. Okay, so that completes the creation code. Let's now write a factory contract that will deploy this creation code. So to do that, I'll create a contract called factory. Then I'll create a function called deploy.
00:06:19.442 - 00:06:47.786, Speaker A: This function will be external. And let's first prepare the creation code that we just created. So I'll say bytes memory, I'll call it bytecode is equal to hex. And inside the double quotes we'll paste our creation code. So scrolling down, I translated these two opcodes into bytecode and this is what we get. So I'll copy this, this is our creation code. And then scroll up and then paste it in here as a reminder.
00:06:47.786 - 00:07:13.782, Speaker A: What this bytecode will do is it will deploy a smart contract that simply returns the number 42. Next I'll initialize address, variable address. I'll name it Addr. And then we'll use assembly to deploy this contract. So, assembly, the opcode that we're going to be using is called create. This function will deploy the smart contract and it's going to take in three inputs. The first input is the amount of ether to send.
00:07:13.782 - 00:07:42.686, Speaker A: We're going to be sending zero ether. And the next two inputs are where the code that we're going to be deploying is located in memory. This is the code that we want to deploy. Since bytes is a reference type, the first 32 bytes of this variable stores the length of this data. So to get to the actual code, which is this, we'll need to skip the first 32 bytes. So we'll do that by typing add to bytecode. Skip the first 32.
00:07:42.686 - 00:08:17.926, Speaker A: 32 in hexadecimal is zero x 20. What is the size of this bytecode? As a string, this has 38 length, so divide by two, and that is the size of the bytecode. 38 divided by two is 19. So here we'll need to put in the size, which is 1919 in hexadecimal is zero x 1316 plus three is equal to 19 to the variable AdDR. We'll assign the address of the newly deployed contract Addr equal to and then call create. Okay, that deploys the contract. Let's check that the address is not equal to zero and make sure that there was no error.
00:08:17.926 - 00:08:58.150, Speaker A: So we'll say require Addr not equal to address zero, and then say deploy failed. And lastly, we'll log the address that was deployed. So I'll create an event called log that will log the address address addR, and once the contract is deployed, we'll emit the event emit log addR. Okay, let's try compiling the contract. I'll hit Ctrl s and the contract compiles. Once we deploy the contract, we'll test out this contract, make sure that it returns the number 42. So I'll declare an interface, I'll say interface icontract.
00:08:58.150 - 00:09:36.862, Speaker A: And let's say that the function we're going to be calling is called getmeaning of life. This will be external, let's say that it's view and it will return a unit returns un. Okay, let's deploy the factory contract, and once this contract is deployed, we'll load it with this contract and then call the function getmeaning of life. We should get the number 42 back. So click on the deployment tab and then deploy the factory contract. Scroll down and then call the function, deploy, open the transaction logs, and then look for the address that was deployed. This will be included in the event logs.
00:09:36.862 - 00:10:07.050, Speaker A: So I'm looking for the logs, and that is the address of the new contract. So I'll copy it and then select the icontract interface. Load the contract with this interface, scroll down, and let's call the function getmeaning of life. We expect the return value to be 42, and it is equal to 42. So in this video I showed you how to create a smart contract. Just using bytecode, we learned about creation code, runtime code, and also how to deploy the bytecode.
