00:00:00.250 - 00:00:37.302, Speaker A: Today I'll be solving the 9th Teams challenge on Ethernol called ADN codex. This is a fun challenge where you will need to have some knowledge about older versions of solidity and how state variables are laid out inside a smart contract. The goal of this challenge is to claim ownership of the contract below. So I'll copy this code over to my code editor and then deploy a new instance for this challenge. I I copied the code over from Eterna over to my code editor. Again, the goal of this challenge is to claim ownership of the contract below. First thing to notice is that this contract inherits another contract called ownable, which we do not have access to.
00:00:37.302 - 00:01:35.626, Speaker A: To make this challenge a little bit easier for you, I'll give a hint that the first state variable inside this contract is an address type called owner and it is declared inside the ownerable contract. So the goal of this level is we need to set the owner state variable to message sender. But notice that we don't have any write access to the state variable owner, so how can we override it? Let's take a look at some public functions that we have access to. Scrolling down, I'll highlight the keyword public has a function called make contact has a function called record that pushes something to an array called codex. Array of bytes 32 there's a function called retract which will decrease the length of the array codex by one. In solidity zero eight, we use the pop to remove the last element from an array. However, if I remember correctly, one way you can remove an element from an array before solidity zero eight was by this syntax, decreasing the length of the array by one.
00:01:35.626 - 00:02:13.782, Speaker A: So that is why you see a codex length minus minus. And if I scroll up, I can see that the solidity version for this contract is 0.5. So that is why this syntax works. Editing the length of the array is the same as removing the last element from array. And then lastly we have a function called revise. This function will allow us to update the if element of codex and set it equal to content from the input. But before we can call this function revise, there is a modifier called contacted, and if I scroll up the modifier contacted checks that contact is equal to true.
00:02:13.782 - 00:02:54.654, Speaker A: How do we make this equal to true? It's simply by calling the function make contact. So we first need to call this function make contact, and then we'll be able to call this function revise. Okay, with that in mind, how can we update the owner state variable? Again, the owner state variable will be the first, state variable inside this contract stored at the zero slot. How can we update this? Remember, before solidity 0.8 numbers overflowed and underflow without any errors. So what does this mean? Well, what happens if we call the function retract when the length of codecs is equal to zero, when this array is still empty, and then we call the function retract, it will do a minus on zero. So that will be an underflow.
00:02:54.654 - 00:03:27.818, Speaker A: When you decrease zero by one, you get minus one, or this is equal to two to the 256 minus one. And what this means is that we now have an array of length two to the 256 minus one. And recall that how state variables are like an array of length two to the 256 minus one. In other words, by calling this function, we'll have write access to all of the state variables inside this contract. Okay, let me put this in code and further explain what I mean over here. So I'll call this contract hack. Then we'll execute all of our code inside the constructor.
00:03:27.818 - 00:04:14.250, Speaker A: Constructor, the contract 80 in codex inherits a contract called ownable, which we do not have access to. So if we just copied all of this code into remix, then it will not compile to make this code work. Also, for remix, I'm going to declare interface here and then copy all of the code inside here over to remix the rest of the code. I will not copy. So I'll say interface, I'll name it IADN codex. And then whatever function that we need to call for ADN codex, I'll also declare here and inside this hack contract, I'll use the IADN codex, constructor, IADN codex, I'll name it target. And then what we're going to do is call retract, but it has a modifier called contacted.
00:04:14.250 - 00:04:51.530, Speaker A: So first thing that I'll do is call the function, make contact. So I'm going to copy this and then paste it here inside the interface. And this will be external. So the first function that we'll need to call is target, make contact. Once we call this function, we now can call the rest of the function, record, retract, and revise. Now remember that I said that on an empty array, on an empty codex array, we're going to call retract, and this will set the length of this array to two, to the 256 minus one. So I'll say over here, target, retract.
00:04:51.530 - 00:05:27.118, Speaker A: Let's go over how the state variables inside the ADN codecs are laid out before we call the function retract and then afterwards, what does the storage layout look like? Before we call the function retract on slot zero, we'll have the owner. This will be 20 bytes. And since every slot can take up to 32 bytes, we still can fit another state variable. If it is less than 20 bytes, owner is 20 bytes. What is the next state variable? The next state variable is contact. It's a boolean, so that will only take up one byte. So contact takes up one byte.
00:05:27.118 - 00:06:06.866, Speaker A: Okay, what is inside slot one? Slot one will be, it is a dynamic array of bytes, 32, called codecs for arrays. It would store the length of the array on slot one, on the slot where it is declared. So here will be length of array codecs. So where are the array elements actually stored? Well, the array elements are stored starting from the ketchup 256 hash of the slot where the array was declared. So the array is declared for slot one. So the starting position of the array element, let's call it h, will be catch 256 of one. So at slot h, this will be codex zero.
00:06:06.866 - 00:06:57.250, Speaker A: At slot h plus one, this will be codex element one. At slot h plus two, this will be codex element two, and slot h plus three, this will be codex element three, and so on. Now, when we call the function, retract on an empty array, this will set the length of this codex array to two to the 256 minus one. So starting from H, the last slot will be slot H plus two to the 256 minus one. This will be codex of two to the 256 minus one. In a smart contract, there are two to the 256 slots. However, notice that codex takes up two to the 256 slots, but we're already using two of them, slot zero and slot one.
00:06:57.250 - 00:07:31.638, Speaker A: This means that some parts of this slot will have to overlap with slot zero and slot one. So if we can find the index that will be h plus I, where it lands on slot zero, then we can overwrite slot zero. What we're looking for is an index I, such that slot H plus I will be overlapped with slot zero. Let's do some math. So H plus I is equal to zero. So we're solving for I. So I is equal to zero minus H, and that will be the index of the array codecs that we'll need to overwrite.
00:07:31.638 - 00:08:04.886, Speaker A: To overwrite slot zero, which contains the owner state variable. Okay, so let's write this in code. Let's first compute the slot H. This will be ketcheck 256 of ABI, encode Un 256 of one. Since we're dealing with index, we'll need to make this into UN 256, and then we'll name this UN 256 h. This will be the index of slot zero. Then we'll say un I is equal to the slot that overrides slot zero.
00:08:04.886 - 00:08:59.302, Speaker A: And what is this index equal to? This index is equal to zero minus h, or simply minus h. Since we're going to be doing this inside solidity 0.8, we're going to have to disable the underflow. So I'll say unchecked and then say I is equal to minus h. Okay, once we computed the index that will overwrite slot zero, what is the next step? The next step is to call the function revise and for the second input bytes 32, we'll need to pass in message sender. So first I'll copy this function signature and then paste it here inside the interface external, and then we'll call the function target revise on index I. And then for the second input we want to pass message sender and then we'll need to cast this into bytes 32.
00:08:59.302 - 00:09:55.814, Speaker A: So to do that we first need to cast message sender into UN 256, and to do that we first need to cast it to Un 160. So un 160 message sender. Next cast this to Un 256, and then lastly cast this to bytes 32, and that should overwrite the owner state variable. But let's double check. So here I'll declare a getter function for the owner function owner external view returns address, and then over here we'll say require target owner is equal to message sender, else hack failed okay, that completes our contract. The next step is I'm going to copy this code over to remix. I'm inside remix and I copied the code over from my code editor.
00:09:55.814 - 00:10:24.046, Speaker A: Let's try compiling this contract. Hit ctrl s and the contract does not compile. If I scroll down I see an error over here. If I scroll back up, I have not defined this function. Retract inside the interface so say function retract external okay, let's try compiling the contract again. Hit ctrl s again and the contract compiles. The next step is to get the address of the contract for adn codecs back inside ethernet.
00:10:24.046 - 00:11:08.122, Speaker A: I'll type f twelve and then get the contract address from the browser console. Paste it here inside remix and let's now deploy the hack contract. So click on deployment tab, make sure that you're connected to the testnet and then we'll deploy the hack contract. So I'll copy the address of the ADN codecs and then make sure that I've selected the hack contract and deploy this hack contract with the address of the ADN codex, click deploy and then confirm transaction. The transaction was successful. So this means that we were able to successfully overwrite the state variable owner. And you can see that this is failed since at the last step of the constructor we checked that the owner is now equal to message sender.
00:11:08.122 - 00:11:15.940, Speaker A: The last step of this challenge is to submit our instance. Once you beat this level, you'll see the button change to ah, go to next level.
