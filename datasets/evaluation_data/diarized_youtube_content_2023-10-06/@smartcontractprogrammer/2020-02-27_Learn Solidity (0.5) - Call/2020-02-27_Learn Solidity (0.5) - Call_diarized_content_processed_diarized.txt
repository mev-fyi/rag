00:00:00.570 - 00:01:03.760, Speaker A: Call is a low level method that is available on all address types and one way to use it is to send ether, which we already seen in a previous video. In this video, I'm going to show you how to use the call method to call existing functions and to call nonexisting functions which would trigger the fallback function. The examples that I'm about to show you are not the recommended way to interact with other contracts, but knowing how to use the call method will be a good skill to have under your tool belt as a smart contract developer. So let's get started. First, we're going to need two contracts. The contract that's going to be receiving the calls, and we're going to call this one receiver and the contract that's going to be making the calls, and we're going to call this one caller inside the receiver contract, we're going to define a function called foo, and this will be the function that we're going to call from the caller contract below. Using the call method, the function foo will take in an input of string and a un.
00:01:03.760 - 00:01:36.666, Speaker A: The type of inputs here are not important. I just picked in for this example. And to show you that we can send ether to this function, we're going to declare this function as payable. And to show you that the call method can capture the return value. Here we're going to return a new end after we deploy the contract and actually execute the functions. We want a way to be able to track code execution. So we're going to create an event that will help us track which functions were called and we're going to emit this event.
00:01:36.666 - 00:02:28.566, Speaker A: When the foo function is called inside the event, it's going to log message sender message value and the message that we pass from the foo function. And just a quick reminder, message sender will hold the address that called this contract, and message value will hold the amount of ether that was sent. And to show you that the call method can receive the output of the function that was called here, we're going to add one to the input x and then return it. So that completes the function that's going to be called when we use the call method on a function that exists. Now, when we try to use the call method on a function that does not exist, solidity will call the fallback function. So let's define the fallback function inside the receiver contract. Recall that the visibility of the fallback function must be external.
00:02:28.566 - 00:03:15.110, Speaker A: And for this example, we're going to make it payable so that the fallback function can receive ether and similar to the function foo for debugging purposes, we're going to emit the received event inside the fallback function. The first two values will be the address of the caller and the amount of ether that was sent. And the message that we're going to log here will be fallback was called. So that completes our code for the contract that's going to get called by the call method. So next, let's write some code for the contract that's going to call the receiver contract above. First, let's create a function that will call the foo function above using the call method. Later, after we deploy the contract here, we're going to pass in the address of the receiver contract.
00:03:15.110 - 00:03:58.620, Speaker A: And since we're going to send ether, we're going to declare the address as payable. And we're also going to declare the function as payable since we're going to forward the ether from our account to this function and to the receiver contract above. In a previous video I showed you how to send ether to an address using the call method like this. By default, the call method will forward all of the gas, but if you only want to send a certain amount of gas, you do it like this. Here I'm telling solidity to send only 5000 gas. Now, if you want to call a function other than the fallback function, you will need to pass in the parameters here inside the parentheses. And the way you would do it is like this.
00:03:58.620 - 00:04:30.318, Speaker A: First we need to call a special function called ABI encode with signature. And inside the ABI encode with signature function we need to pass in some parameters. The first parameter is the signature of the function that we want to call. And the way to create a function signature is similar to how you would declare a function, with some minor differences. First you start with the function name. In this case we're going to call the foo function. So here we're going to start with foo.
00:04:30.318 - 00:05:04.570, Speaker A: Next we declare the type of inputs that this function is going to take. Since the foo function above takes a string and a un as inputs. Here we're going to declare a string followed by a un. First, note that there is no space between the comma and this is important. Next, note that instead of un you need to declare the full name since Un is an ads for un 256. Here we need to declare un 256. And finally, notice here that we don't declare the type of output.
00:05:04.570 - 00:05:42.874, Speaker A: The next parameters that we need to pass are the actual inputs that are going to be passed to the function that we're calling. Since the function foo takes a string and a un as inputs. Here, for the first input, I'm going to pass a string value of call foo followed by a un input of one, two, three. The call function will return two outputs. The first output will tell us whether the function call was successful or not. The second output will be the output of the function that was called encoded in bytes. So when we call the foo function, it returns a un.
00:05:42.874 - 00:06:14.594, Speaker A: So here the variable data will contain the un encoded in bytes. Now we want to see the output of calling the function foo by the call method. So here we're going to log the output and we're going to log both the outputs, success and data. So that completes our function. That's going to call the foo function using the call method. So next, let's write a function that's going to call a function that does not exist. We'll start by copying and pasting this existing code and then modify it.
00:06:14.594 - 00:06:55.666, Speaker A: First we're going to change the name to test call does not exist. And just to show you that we don't have to send ether when using the call method here we're going to remove the payable keywords. Recall that specifying the amount of gas is optional. So here we're going to remove this also, and we're not going to send any ether. So we're going to remove this as well. And we're going to call a function called does not exist, which as you can see from here, does not exist anywhere. And we can remove the parameters here since these parameters will be passed as an input to the function that we're calling.
00:06:55.666 - 00:07:45.780, Speaker A: And the function that we're calling does not exist does not take any inputs. So when this code is executed, since the function that we're trying to call does not exist, it will call the fallback function. And since the fallback function does not return any outputs, this data variable will be zero bytes. So that completes the code to call existing function and a function that does not exist using the call method. Let's now deploy the contract and actually call these two functions. So here I've deployed the two contracts, caller and receiver, and I'm going to execute the test call foo function, which will call the foo function in the receiver contract. So I'm going to copy the address of the receiver contract and paste it in here.
00:07:45.780 - 00:08:27.146, Speaker A: So when we executed the test call foo function, it called a function foo. In the receiver contract with the parameters call foo and one, two, three. Inside the function foo, it emitted an event of received and you can see here in the transaction log that the event received was emitted. Function Foo returned the output of x plus one. This output was captured here in this data variable. And since we logged the data variable in the response event, you can see down here that the response event was logged and it logged the data. This data is in hexadecimal notation.
00:08:27.146 - 00:09:10.474, Speaker A: And down here I opened the JavaScript console in the web browser and decoded the hexadecimal data, and you can see that it returned 124. We passed 123 as input and the function foo returned 123 plus one, which is equal to 124. And this data down below here is equal to 124 in hexadecimal notation. Next, I'm going to walk you through the code execution. When we call test call does not exist. So again, I'm going to copy the address of the receiver contract, paste it in here, and call test call does not exist. And let's check the transaction log.
00:09:10.474 - 00:10:14.238, Speaker A: As you can see from the event log, the fallback function was called and it returned a data of zero bytes. So what happened was when we called a test call does not exist function, it tried to call a function that does not exist, and since the function does not exist, does not exist inside the receiver contract solidity called the fallback function and it logged the event with the message fallback was called. After the fallback was called, it returned zero bytes, and we saw in the transaction log that zero bytes was logged inside the response event. So in summary, you can use the call method to call other functions. If the function being called does not exist, then the fallback function will be called. Now, this function is not the recommended way to call other functions since it's very easy to mess up the function signatures. So for example, even though if you know that the function flu exists, if you mess up the function signature, then the fallback function will be called.
00:10:14.238 - 00:10:22.940, Speaker A: Well, that's all I got for this video. If you have any feedback or questions, let me know in the comments below. Have a good night and I'll see you in the next video.
