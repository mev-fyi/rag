00:00:00.250 - 00:00:32.818, Speaker A: Flashbots protect transactions from sandwich attacks. What is a sandwich attack? And how does flashbots protect against sandwich attacks? Let's take a look. Here we have Alice, and she wants to send a transaction to the Ethereum network. Now, there are other users that have already submitted their transaction and waiting for their transaction to be mined. On this block over here, the place where these pending transactions, the transactions that are yet to be mined, are still is called mempool. And everyone can see all of the pending transactions inside the mempool. Alice submits her transaction.
00:00:32.818 - 00:01:06.438, Speaker A: Her transaction gets included in the mempool. Now, because the mempool is public, anyone can see all of the pending transaction inside the mempool. A bad actor. Eve can look at all of the pending transactions and try to submit her transaction in the same block to exploit Alice's transaction. For example, Eve can try to submit her transaction before Alice's transaction to make some profit. This is called a front run, or there might be a transaction where Eve submits transaction right after Alice to make some profit. This is called a backrun.
00:01:06.438 - 00:01:48.874, Speaker A: And maybe it makes sense for Eve to submit a transaction in between Alice's this is called a sandwich attack. This is a common attack used on dexers like uniswap. Eve sends two transactions on uniswap, sandwiching Alice's transaction to make some profit. And of course, Eve is not the only actor that is looking for sandwich opportunities, and nothing is stopping them from doing a sandwich attack on a sandwich attack. Sandwiching a sandwich using flashbots. How can Alice protect herself from sandwich attacks? Instead of sending her a transaction to the Ethereum network, Alice sends her transaction to the flashbots relayer. Flashbots relays her transaction to a set of miners that are running flashbots.
00:01:48.874 - 00:02:36.458, Speaker A: These miners also have a mempool where pending transactions are stored. However, unlike the Ethereum mempool, which is public, so anyone can see all of the pending transactions, the Mempool of flashbots are private. Only the miners that are running flashbots can see the pending transaction. EB and Rob can see all of the pending transactions inside the public mempool, but they won't be able to see the pending transactions inside the mempool maintained by flashbots. Alice's transaction gets included in the mempool of the flashbots, and because her transaction is private, Eb and Rob cannot see her transaction, so they cannot perform a sandwich attack. This is how flashbots protect transactions from getting sandwich attacked. The user who sends a transaction to the flashbots is called a searcher.
00:02:36.458 - 00:03:11.126, Speaker A: The transaction that you send is called a bundle. Actually, you can send multiple transactions at once, so this is why it's called a bundle. The server that you're sending the bundle is called a relayer, and the relayer broadcasts your transaction to the miners running flashbot. Let's build a simple script that will send a transaction to flashbots. The package that you'll need to install are here ethers and a plugin called flashbots Ethers provider bundle. And we'll also install some typescript libraries. And be sure to fill the file m with an Ethereum RPC URL.
00:03:11.126 - 00:03:56.786, Speaker A: For this example, we'll send our transaction to the Gorely testnet. And for the ethereum rpc URL, I'll use a URL from Infira IO and then also paste in a private key of your account. The contract that we're going to be calling for this example is called contract waste gas, and as the name implies, what it does is just burn gas. Now, for the flashpots to include your transaction in the block, there is a minimum amount of gas that you need to use, and that minimum amount is 42,000 gas. So this is why we have a contract that simply burns gas and inside source index ts. This is where we will write our script to send our transaction to the flashbots. First we'll import providers and wallet from ethers js, and we also import some stuff from the flashbots library.
00:03:56.786 - 00:04:20.814, Speaker A: For convenience we'll declare some constants. Guay is ten to the nine and ether is ten to the 18. Notice that here we're not using any big number library. Javascript now supports big int, and these are the syntax for using big int. This script will run on the Gorely testnet so the chain id is equal to five. We'll send our transactions to the flashpot at relaygorly flashbots. Net.
00:04:20.814 - 00:04:54.518, Speaker A: Initialize the provider so that we can connect to the ethereum network. For the URL we're passing an etherpC URL from the environment variable, which you will specify inside the m file. Remember, we'll initialize a wallet where the private key also comes from the environment variable m file. Next we'll write the script that's going to submit a transaction to the flashbot. I'll name this function async function main. We'll write our code inside here, and we'll execute it by calling main. The first thing that we need to do is create a wallet.
00:04:54.518 - 00:05:30.866, Speaker A: This is a wallet different from the wallet that we imported from the private key. The purpose of this wallet is to establish identity when we're submitting a transaction to flashbot. You can either create this wallet by pasting in a private key, or you can also call the function wallet create random. For this example, I'll initialize a wallet with this private key, and then we'll initialize a flashbot providing the provider, the signer. This is the wallet that we just created here, and the flashbots endpoint. We'll send the transaction to the flashbots on every block until our transaction is mined. To do that, we type provider on block.
00:05:30.866 - 00:05:58.654, Speaker A: So this is the function that will be executed on every block, and then we will put our code inside here. First thing that we'll do inside this code block is log the block. Log the current block. Next, we'll sign a transaction by calling flashbot signbundle. And notice that we're passing in an array, which means that we can sign multiple transactions. But for this example, we'll submit one transaction passing in the signer. This is the wallet that we initialized with our private key.
00:05:58.654 - 00:06:24.082, Speaker A: And inside the transaction object, we'll put the details of the transaction. The chain id is equal to the constant that we define, which is equal to five. This is the goalie testnet transaction type. We'll set it to two. This is EIP 1559 transaction. We'll set max fee per gas, max priority fee, gas, and gas limit to these numbers. I got these settings from another tutorial, which I'll put the links in the descriptions.
00:06:24.082 - 00:07:02.722, Speaker A: Moving on. The amount of ether that we're going to be sending is zero. The data that we're going to be sending is empty data, so just zero X. Now, if we were to call another function, then this data will be ABI encode of the function and the inputs, and the contract that we're going to be calling is this contract. This is the address of the waste gas contract that is deployed on the Gordine network. When this transaction is executed inside the waste gas, it's going to call the fallback function and just burn some gas. Once the transaction is signed, we'll target the block to be the next block from the current block by saying target block is equal to the current block plus one.
00:07:02.722 - 00:07:48.046, Speaker A: We'll run a quick simulation on the transaction that we're about to submit by calling flashbot. Simulate passing in the signed transaction and the target block. If there is an error in the simulation, then we'll log the error. Browse wheel console log simulation is successful. If you want to take a look at the full detail of the simulation, then comment out this code and you'll be able to see all of the details stored in the sim. Once the simulation is successful, we'll actually send our raw bundle passing in the sign transaction and the target block, and then we'll check that there is no error in the bundle that we just sent. Now we don't want to be keep on sending a transaction that fails on every block, or send a transaction that's already been mined.
00:07:48.046 - 00:08:32.346, Speaker A: To either stop sending a transaction bundle if there's an error, or if the transaction is mined. To do that on the rest object that we assigned over here, we call the wait function, and if this response bundle resolution is equal to flashbots bundle resolution bundle included this means that our transaction was mined. So we'll console log some details of the transaction and exit the script. Else, if the bundle resolution is equal to block passed without inclusion, this means that our transaction was not included in the target block. Then we want to continue running this script. So we'll just log not include it in target block, or else. If there's an error with the account nouns, then we'll just exit the script.
00:08:32.346 - 00:09:32.620, Speaker A: And this completes a simple script that will submit a transaction to the flashbot. Let's now run the script and make sure that you have already filled out the m file. Open the terminal, and then type emb dollar sign parentheses cat emb this command will read the content of emb file, and the emb command will load the content of emb file into the environment variable, and then followed by the actual command to execute the script. Mpx tsnode source index TS notice that after several tries, our transaction was mined. When you submit a transaction, you would usually see that a transaction is pending, but using a flashbot, this transaction will appear instantly again. This is because flashbots use a mempool that is private. Because the transactions are not public, your transaction sent to the flashbot is protected from sandwich attacks.
