00:00:00.250 - 00:00:41.270, Speaker A: Let's code an ERC 1155 contract. First I'll import some interfaces that we'll need to implement. Here's an interface for IERC 1155 and we also need an interface for IERC 1155. Token receiver this will be a contract that will be called when a token is transferred from to another contract and the receiver is a contract. I'll explain more about it later. I'll start off by writing contract. I'll name this ERc 1155 and we'll implement our ERc 1155 inside here, a function to mint and burn tokens are not part of ERC 1155, so I'll create another contract.
00:00:41.270 - 00:01:40.152, Speaker A: Contract, I'll name it my multitoken and this will be ERC 1155 and inside here we'll implement the function to mint and burn tokens. And here are the functions that we will implement later. Mint batch, mint burn and batch burn. Okay, so let's start with the base contract, Erc 1155 so this will be is IERc 1155 and of course we haven't implemented any of the functions inside here. So first I'll copy all of the functions inside here inside the interface and then paste it inside our contract. And to remove the compilation error I'll make all of these declaration into functions. Okay, once that's done, next I'll declare the events that we need for IRC one one five pipe.
00:01:40.152 - 00:02:30.924, Speaker A: Here are the events that we'll need transfer single transfer batch approval for all and URI. We'll go over what these mean later as we implement the functions. Okay, so next let's declare some state variables. So the first state variable that I'll declare is the balance of token for a user. So ERC 1155 can manage multiple tokens. So you'll need a nested mapping, a mapping from owner to some token ID and then from the token Id to the balance of the token. So this will be mapping owner address and then to another mapping mapping id will be un 256 un 256, and then lastly the balance of the token Un 256 public and I'll name this balance of.
00:02:30.924 - 00:03:03.700, Speaker A: Now I see a compilation error over here on the bottom. This is because we need to implement the function balance of and by declaring the state variable balance of we no longer need this. So going back up, the next state variable that I'll declare is some kind of approval to transfer tokens. So this will be a mapping from the owner to the operator. Operator is an account that will be able to spend the tokens from the owner and then from the operator. Whether this operator is approved or not. So this will be a boolean.
00:03:03.700 - 00:03:43.920, Speaker A: So mapping address owner to another mapping mapping address operator or the spender. And boolean whether this operator is approved to spend owner's token or not. Public I'll name this is approved for all. And again, there's a compilation error down here. We need to implement this function and we already did that by declaring the state variable so we no longer need this. Okay, going back up, the next functions that I'm going to implement are metadata information. So scrolling down the first function for the metadata that I'm going to declare is called supports interface.
00:03:43.920 - 00:04:21.808, Speaker A: And it basically tells other contract that this contract supports the interface for ERC one, six, five, ERC 1155 and ERC 1155 metadata uri. And I've also declared another function for the metadata, ERC 1155 metadata uri. These two functions are not that interesting. So let's move on. So the first function that is interesting is the function to mint. Now, this is not part of the ERC 1155 standard. So I'll make this mint function an internal function and then later we'll call it inside our my multitoken so say function.
00:04:21.808 - 00:04:57.950, Speaker A: Just to remind us that this is an internal function. I'll name this with underscore mint. And the parameters that's going to take are address two un 256 id of the token, un 256 the amount of token to mint value. And if the receiver of this token, if the two address is a contract, then we'll have an optional data that we'll pass. So say bytes, memory data. This function will be internal. So inside here what we're going to do is update the balance of two for token id.
00:04:57.950 - 00:05:40.140, Speaker A: And if two is a contract, then we'll call some callback. So first let's require that this two is not a zero address. Require two is not equal to address zero error message two is zero address. Next we'll update the balance of two. So how do we do this? Let's go back up and we set that the state variable balance of is a mapping from owner Id to balance. So I'll copy this and then paste it here for a reminder. So we need to update the balance of balance of owner will be two, the token ID will be ID, and then we'll increment it by value.
00:05:40.140 - 00:06:16.372, Speaker A: Okay, next we'll emit the event transfer single. So what are the parameters that we need to emit? Copy all of this, scroll back down, paste the event. So we'll emit this event and the parameters the operator will be the caller that called this function. So I'll say message sender from when we mint we usually say address zero. So say address zero. Two will be the two from the input Id will be ID and value will be value. Next we'll need to check whether two is a contract or not.
00:06:16.372 - 00:06:59.568, Speaker A: And if it is a contract we'll need to call callback to check whether two is a contract or not. You'll say if two code length is greater than zero. If there is a code at the address of two, then we know that it is a contract. So we'll need to call a callback. The callback that we'll need to call is going up is on ERC 1155 received. Let me copy this and then going back down I'll paste the interface and say IERC 1155 token receiver at the address two. And then the function that we need to call is on ERC 1155 received.
00:06:59.568 - 00:07:54.084, Speaker A: And these are the parameters that we'll need to pass. Operator is message sender from will be address zero, id will be id, value will be value. And the data that we will pass to this callback will come from the input over here. So calling this function on ERC 1155 receive we expect to receive an output of bytes four, and this bytes four must match the selector of IERC 1155 token receiver UNERC 1155 receive selector. So these must match or else we'll have to throw an error so say require calling this callback. The selector that was returned should match this selector. If it does not, we'll throw an error message unsafe transfer.
00:07:54.084 - 00:08:25.872, Speaker A: Okay, that completes the function. The internal function to mint the next function that I'll write is an internal function called batch mint. So here I'll type function, underscore batch mint. This function will be internal. What this function does is basically the same thing as mint, but we'll be able to mint multiple tokens to some single address. To this address we'll be able to mint multiple tokens for different amounts. And lastly we'll pass in data.
00:08:25.872 - 00:09:16.928, Speaker A: First we'll require that two is not equal to zero address. And to do that I'll just copy this code over here and then paste it over here. Next we want to make sure that the length of ids and the length of values are the same. So say require ids. Length is equal to values length error message let's say ids thing not equal to values length. And then next we'll run a for loop to mint multiple tokens to address up two. So to do that, first I'll copy this, paste it here and we'll have to do something like this inside of for loops say four un I equals zero, I less than ids length I plus plus and then we'll update the balance of two.
00:09:16.928 - 00:09:50.750, Speaker A: The id will be stored in Ids of I and value will be stored in values of I. And then after we do this we'll emit the event. Scrolling up the event that we'll emit is this event. Paste the event say emit operator will be message sender from will be address zero. We're minting from address zero. Two will be two. From the input, Ids will be Ids and value will be values.
00:09:50.750 - 00:10:21.866, Speaker A: And again, if two is a contract then we'll have to do something similar to this code over here. So I'll copy this code first and then paste it here. But the callback that we need to call is slightly different. The callback that we need to call is this one over here. It's called on ERC 1155 batch receive. So I'll copy this function, go back down. Then I'll paste the function over here.
00:10:21.866 - 00:11:05.190, Speaker A: So this is the function that we'll need to call. So the function that we'll need to call is called on ERC 1155, batch received. Operator will be message sender from will be address zero, Ids will be Ids, values will be values, and data will be data. And again, calling this function should return a selector of on ERC 1155 batch received and the error message will keep it the same. Okay, so that completes the function for the internal functions for mint and batch mint. Let's call those internal functions inside our my multitoken. So inside my multitoken the function, the internal function to mint.
00:11:05.190 - 00:11:36.862, Speaker A: I'll copy this so that I remember what parameters I need to pass in what order. We'll call the internal function mint address to let's say message sender. Id will be id, value will be value and data will be data. Okay, and we'll do something similar for batch mint as well. So going back up I'll copy the parameters so I know how to call this internal function. Scroll down, paste a function. We're going to be calling the internal function batch mint.
00:11:36.862 - 00:12:18.202, Speaker A: Two will be message sender. Next parameter will be Ids, the next parameter will be values and the last parameter will be data. And that completes the function for mint and batch mint. These two functions are not part of ERC 1155, but the code inside these functions tell us how we need to update the balance of and what other functions that we'll need to call. For example, when we do a transfer, we'll need to call the callback on ERC 1155 received or batch received. So next I'm going to declare some internal functions for burn and batch burn. Let's start with burn function underscore burn.
00:12:18.202 - 00:13:13.838, Speaker A: The parameter that we'll pass is address from the count that we're burning the tokens from token id un 256 id and the amount to burn un 256 value. This will be internal. Let's recycle some of the code inside the internal function mint. So I'll just copy this, then go back down, paste it here. We'll require that from is not equal to address zero error message from is equal to zero address. Next we'll need to update the balance of so it'll be balance of from instead of adding we'll minus and then lastly we'll emit the event and we don't need this callback operator will be message sender from will be from two will be address zero and id and value will be the same. Let's write a similar function for batch burn.
00:13:13.838 - 00:14:06.830, Speaker A: What I'm going to do is copy the internal function for batch mint and we will modify this to create an internal function for batch burn. So I'll call this batch burn parameter will be from ID values. We don't need data. So since we don't need data, we're not going to need the callback and we'll require that from is not equal to address zero with the error message from is equal to zero address. And then next we'll check that the length of IDs is equal to the length of values. Next we'll run a for loop to update the balance of from for IDs minus it by values of byte and lastly emit the event transfer batch operator message sender from to OB as zero and the rest of the parameters are the same. Okay, so that's batch burn.
00:14:06.830 - 00:14:58.098, Speaker A: Next let's call those internal functions inside our my multitoken here we'll call the internal function burn from message sender tokenid amount value and we'll do something similar for batch burn, say underscore batch burn from message sender. IDs will be IDs, values will be values. Okay, so that completes the internal functions for mint batch mint burn and batch burn. Later we'll be writing similar code for safe transfer from which is part of BRCA 1155. But before we do that, I want to implement some other functions. The first function that I want to implement is batch balance up. So I'll copy these two functions and then move it up here.
00:14:58.098 - 00:15:34.682, Speaker A: And let's start with batch balance up. What this function will do is get the balance up owners for the token Ids. First thing that I'll do is initialize a u into 256 array. This will be an array of balances that we'll be returning balances. Okay, next we'll check that the length of owners and IDs are the same. So say require owners length is equal to IDs length. Error message owners length not equal to IDs length inside solidity when we initialize an array of memory, we need to tell the length of this memory array.
00:15:34.682 - 00:16:37.038, Speaker A: So to do that we'll say balances is equal to new un bracket and the length of this array will be the same length as the owners array owners length. Next we'll get the balance of owners so say four un I equals zero I less than owners length I plus plus and then say balances of I is equal to we need to get the balance from the state variable balance of from the owner owners of I for the token Ids of I and that completes the function for balance of. Now notice that we then have to say return balances. This is because we initialized an array over here for returns and then we just put some values in inside here. So that completes the function for balance of. Next, let's write a function setapproval for all. So this function will either give or revoke approval for operator.
00:16:37.038 - 00:17:31.218, Speaker A: The state variable that we'll need to update is this one over here is approved for all. I'll copy this comment over here, paste it here. You'll say is approved for all message sender that will be the owner approves the operator operator from the input either approves or revokes by the boolean input approved and then we'll need to emit the event approval for all. Copy this event, paste it here, emit approval for all owner will be message sender operator will be operator from the input operator, then approve. Okay, that completes the function set approval for all. We have two more functions that we'll need to implement, safe transfer from and safe batch transfer from. Let's start with safe transfer from.
00:17:31.218 - 00:18:45.146, Speaker A: So I'm probably going to reuse some of the code from the internal function mine, I'll copy this and then paste it over here and we'll modify this code. When we call the function safe transfer from. We want to check that either message sender is equal to from. In other words, message sender is the owner of token to be transferred or we want to make sure that message sender has approval from the address from. So to do that I'll say require either message sender is equal to from or is approved for all from operator message sender and then the error message not approved. Next we'll check that two is not equal to azure zero and then we'll update the balance of so the balance of from should decrease and the balance of two should increase and we'll emit event from to id value and then lastly we'll call the callback on ERC 1155 received. If two is a contract operator will be message sender from will be from from the input Id value data.
00:18:45.146 - 00:20:16.290, Speaker A: Rest of it is the same and that completes the function for a safe transfer from and the last function that we'll implement, it's safe batch transfer and again we'll start off by copying the code from batch mint. I'll copy this code and then paste it here just as what we did for safe transfer, we want to make sure that either message sender is the owner or message sender is approved by the address of from and then we'll check that two is not equal to address zero. We also check that ID's length is equal to Valley's length. And then next we will run a for loop to update the balance of two and also the balance of from. So I'll copy this, paste it here, balance of from for Ids of I decremented by values of I and then increment the balance of two, emit the event transfer batch for from to id values and then lastly call the callback. We'll just need to update this input from and that completes the function for safe batch transfer from and we've now implemented all of the functions for ERC 1155 contract let's try compiling this contract and make sure that there is no error. So open my terminal, clear the logs and then type forge build and our contract compiled successfully.
