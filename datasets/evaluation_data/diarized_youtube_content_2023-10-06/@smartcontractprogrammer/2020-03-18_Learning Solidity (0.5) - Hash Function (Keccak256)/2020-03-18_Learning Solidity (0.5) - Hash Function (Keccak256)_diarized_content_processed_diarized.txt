00:00:00.410 - 00:00:50.910, Speaker A: You. Let's talk about the cryptographic hash function in solidity. It's called ketchak 256. In this video, I'll explain what a cryptographic hash function is, and I'll show you an example about guessing game using the pseudorandom nature of a cryptographic hash function. So first off, what is a hash function? A hash function is a function that takes in arbitrary size input and outputs data of fixed sized. Some properties of a hash functions are that it is deterministic, which means that if hash of x is equal to h, then every time you compute the hash of x, then it will always equal to h. The cryptographic hash function should be quick to compute.
00:00:50.910 - 00:01:46.670, Speaker A: It's irreversible. This means that given some hash h, it is hard to find x such that hash of x is equal to h. A small change in input changes the output significantly, and it is collision resistant, which means that it's hard to find x and y such that hash of x is equal to hash of y. Now, there are several cryptographic hash functions available in solidity, but the one that is used the most often is the catch Act 256. And to call this function, you pass in bytes as input. And one way to pass bytes as input to catch up 256 is by calling Abi encode packed. Abi encode packed takes in all types of data and any amount of inputs.
00:01:46.670 - 00:02:54.100, Speaker A: So for example, we could pass in a string, some un, and address it will take in all of inputs and turn it into bytes. Catch Act 256 will take the output of Abi encode packed and turn it into a 32 byte hash. Later, I'm going to show you an example that a small change in the input of the hash function would change the output by a lot. So I'm going to create a function called hash. For this example, it's going to take in some string, an un, and an address, and it's going to return the 32 bytes of hash. And inside the function we'll call the catch app 256 and pass in the text num and the address I've compiled and deployed the contract. Let's now call the hash function and see what the output looks like.
00:02:54.100 - 00:03:56.002, Speaker A: So for the input I'm going to call hello world for the first input, for the number I'll put in one, two, three, and for the address, I'll just copy the address of the contract and paste it here. Now I'm going to show you that a slight change in the input is going to change the hash a lot. So first I'm going to copy this and paste it here. And then I'll call the same function, but from the hello world I'll remove the h and it says hello world. And you can see that we changed the input by only one character. But the hashes are totally different because of the property that given a hash, it is almost impossible to find the input that produced the hash. We can create a game where you try to guess the word that computes to a certain hash.
00:03:56.002 - 00:04:57.260, Speaker A: For example, here we have a hash, and the goal of the game is to find the word that equals this hash. So we'll create a function called guess, and for the input it's going to take in a word that's going to be hashed, it's going to return true. If the hash of the input is equal to our target hash over here inside the function, we'll hash the input, compare it with the answer hash, and then return true or false. Here I've compiled and deployed the guessing game contract, and I'll make a guess that the word hello hashes to the target hash over here, and it returns false. I'll try Ethereum and it also returns false. So the magic word is solidity with a capital s, and you can see that it returns true. So this is how you can create a simple guessing game.
00:04:57.260 - 00:06:13.650, Speaker A: Now, catch Act 256 is collision resistant, but there is one easy way that you can create a collision, and it involves using Avi encode packed. And the way you can create a collision is by passing more than one dynamic data type to encode packed. So here to encode packed I'm passing in two strings. And what encode packed does is it will concatenate the two strings so that if you pass in AAA as your first string and BBB as your second string, Abi encode that packed will return AAABB. And if you pass in AA as your first string, and for the second input pass in ABbB, Abi encode packed again will return AAabB. So notice that we have two different inputs, but what's being passed to the catch app 256 is the same. So this will mean that we have different inputs but the same output, which is going to create a hash collision.
00:06:13.650 - 00:07:08.374, Speaker A: To show you an actual example, I'm going to type in AAA followed by BBB and get the hash. And next for the first input it's going to be AA, and for the second input it's going to be ABB. And when you call the function again, you'll notice that the hash didn't change. So when you're encoding more than one dynamic data type. What you need to do here is instead of calling encode packed, you'll need to call encode and this will prevent a hash collision from occurring. Well, that's all I got for this video. Any feedback or question, let me know in the comments below and see you in the next video.
00:07:08.374 - 00:07:08.930, Speaker A: Bye.
