00:00:00.330 - 00:00:20.350, Speaker A: Today we'll finish up the clam contract. So we'll complete the positions sole contract and clam sole contract. First, I've defined a constant inside fixed .128 sol. So if you look over here, it defines a constant called q one two eight. What this is is just one. Shift it over to the left 128 times.
00:00:20.350 - 00:01:08.866, Speaker A: We're going to be multiplying this number by the liquidity and also dividing it by the liquidity. So moving on to the positions sol contract. We'll finish this contract by scrolling down and completing these to dos. So if you look at the function update, let's first go back to the clam contract and see where this function is called. So if I go back to the clam contract and inside the function update position, we can see here scrolling down that position update is called inside here. So this means that when we modify a position, when we add or remove a liquidity, this function update position will be called and the library function position update will be called. We'll complete this library by calculating the amount of tokens own and then updating it inside here.
00:01:08.866 - 00:01:47.054, Speaker A: The input for this function is self, which will be the information about the position. So what we're going to do is increment tokens owed for this self variable. Okay, so first let's calculate the amount of tokens owed, say un one to eight. Tokens owed zero is equal to un one to eight. And then we'll use a library called Maldib. Full math Maldib. What this function moldib will do is it will multiply two to the 256 bit numbers and then divide by another two to the 256 bit number without any overflow here.
00:01:47.054 - 00:02:40.526, Speaker A: What we want to multiply is the difference of fee growth now and before, which will be contained inside self. Then we multiply this by the liquidity of this position, and then we'll divide it by q one to eight, which we defined over here. So going back here now, the reason why we're dividing by q one to eight is because liquidity is multiplied by q one to eight, say fee growth inside zero x one to eight. This will contain the latest fee growth inside zero x one to eight minus the previous one, which will be for the position self dot fee growth inside zero. Last x one to eight. We multiply this by the liquidity of the position, which will be self dot liquidity, and then we divide by q one to eight fixed .128 times q one to eight.
00:02:40.526 - 00:03:30.298, Speaker A: Okay, so this is token zero owed. Let's also do the same for tokens owed one tokens owed one will be fee growth inside one x one two a fee growth inside one vast x one two eight multiply by liquidity divided by q one to eight. Okay, and the next step is to update the position here. I'll say if tokens owed zero is greater than zero or tokens owed one is greater than zero, then we'll update the tokens owed for this position. So say self dot tokens owed zero incremented by tokens owed zero. Then we'll do the same for tokens owed one. Now notice that for the code above here we have an underscore self whereas here we don't have an underscore.
00:03:30.298 - 00:04:01.880, Speaker A: This is because at the beginning of this function we loaded the self storage into memory and this is done to save gas. Okay and that completes the function for position I'm going to fix the spelling here. Liquidity and liquidity. Okay let's move on to the clam contract. So going back up I'm going to make sure that the position and the tick libraries are imported and I'm also going to make sure that full map and fixed 0128 libraries are imported. Okay scrolling down. Let's see what we need to do.
00:04:01.880 - 00:04:41.158, Speaker A: First thing that we'll need to do is inside the function update position we'll need to load fee growth global zero x one two eight and one x one two eight from the state variables here. I'll type fee growth global zero x one two eight and fee growth global one X one two eight. Okay, moving on. I'm going to scroll down. Okay. The next thing that I'll need to do is get the fee growth inside and then pass it into this function position update. So first you'll say un 256 fee growth inside zero x one to eight and un 256 fee growth inside one x one two eight.
00:04:41.158 - 00:05:23.460, Speaker A: This will be equal to ticks. Get fee growth inside and let's go check the ticks library to see what parameters we need to pass inside this function. So go back to ticks library then search for the function get fee growth inside. The first parameter is the state variable ticks tick lower, tick upper, tick current and fee growth global zero x one to eight and fee growth global one x one to eight. So tick lower, tick lower, tick upper. The current tick will be tick and the fee growth global that we just loaded above over here. So I'll just copy these then paste them here.
00:05:23.460 - 00:06:13.662, Speaker A: And the next step is to pass these fee growth global inside into this function. So this will be fee growth inside zero x one to eight and fee growth inside one x one to eight. Let's see what else we need to do. The next thing that we need to do is update global fee tracker if state liquidity is greater than zero. So where is this? This is inside the function swap. What we're doing here is we're updating the fee growth global inside the swap when it collects some fees. So say if state liquidity is greater than zero, then state fee growth global one to eight, we'll increment it plus equals full math modiv.
00:06:13.662 - 00:06:41.866, Speaker A: And here, what we're going to multiply is the fee times q one to eight, and then divided by the current liquidity in this tick. So say step fee amount, multiply this by 6.128 times q one, two, eight, and divided by the current liquidity. State liquidity. Okay, so we completed all the to dOs. Let's try compiling the contract inside my terminal. I'll type forge, build it so there's an error.
00:06:41.866 - 00:06:56.250, Speaker A: So I'll go fix it. Line one, eight, three, remove a comma, then try compiling the contract again. And our contract compiled. And this completes the code and the video series for the clam contract.
