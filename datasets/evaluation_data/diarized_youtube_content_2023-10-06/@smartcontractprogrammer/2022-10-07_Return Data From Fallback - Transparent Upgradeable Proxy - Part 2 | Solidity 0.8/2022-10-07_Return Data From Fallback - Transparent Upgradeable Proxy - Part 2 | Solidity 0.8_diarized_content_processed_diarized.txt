00:00:00.250 - 00:00:28.214, Speaker A: Let's go over how to return data from a fallback function. In the previous video, we set up a buggy proxy contract, and for the implementation we set up counter b one. But when we tried to get the count back, it did not return the data. This is because inside the fallback function it cannot return any data. So in this video, we will learn how to return data so that we can get the count from the implementation. First, let me show the problem. The problem is that we cannot get the count.
00:00:28.214 - 00:01:04.362, Speaker A: So I'll deploy all of the contracts. I'll deploy the buggy proxy contract and our first implementation, counter b one. Scroll down, then open the buggy proxy contract, and we'll first set the implementation to counter b one. So copy the address of counter b one, paste it here, and then call the function upgrade to let's check that the implementation was set. I'll click on implementation and we have a contract address from b one. Next, let's call the ink function on counter b one. So we're going to be using the storage for the buggy proxy contract.
00:01:04.362 - 00:01:43.866, Speaker A: So I'll copy the address of the buggy proxy, scroll up, and then select counter b one. And we're going to be loading the interface for counter b one using the address and the storage of buggy proxy. Paste the address of buggy proxy here, and then click add address, scroll down, and we have the buggy proxy with the counter b one interface loaded here, we will call the function ink to increment the count. So maybe I'll call it a couple of times. One, two, three. Open the transaction logs, make sure that the transaction went through, and you can see here that the transactions were successful. Let's also check that it did not overwrite the address of the implementation.
00:01:43.866 - 00:02:11.462, Speaker A: So if I scroll up, we can see here that the address of the implementation is this. If we click on it again, it does not change. So it did not change the address of the implementation. So we have something working correctly here. However, if we try to get the count, notice that it returns zero even though we clicked on ink several times. So let's go fix this. Let's go fix the fallback function so that it returns some data.
00:02:11.462 - 00:02:45.360, Speaker A: So that when we click on the function count, it returns some number. Now, inside the buggy proxy contract, both the fallback and the receive function calls an internal function called delegate. So we'll be modifying this code to call delegate call. But after calling delegate call, it somehow returns the data, even though the function signature doesn't say that it will return any data. To return data we'll need to use assembly. So first I'll remove this code. Next, I've copied the code from the Openzeppelin's transparent upgradable proxy, and I'll paste it here.
00:02:45.360 - 00:03:24.910, Speaker A: Okay, once the code is pasted, let's go through what each of the line of the code does. Now, when I hit Ctrl s to try to compile it, you can see here that there is an error. It says only local variables are supported. However, we're using implementation from the storage variable. So the first thing that I'll do is declare a local variable saying address implementation, and then change this state variable to a local variable. Underscore implementation, and then inside delegate that's called for a fallback. And for receive I'll pass in the state variable implementation.
00:03:24.910 - 00:03:54.790, Speaker A: The same for receive implementation. Okay, let's try compiling the contract again. I'll hit Ctrl s and the contract compiles. So let's go over the code inside assembly. The basic idea for the code inside the assembly is that we're going to be copying the data and then manually calling delegate call. And once we call delegate call, we'll have our data stored in return data. So we'll copy this return data into memory and then manually return it.
00:03:54.790 - 00:04:23.854, Speaker A: So let's go through the details. So inside assembly, the first thing that we do is call data copy call data size. Let's go over what this part of the code is doing. So according to the documentation call data copy tfs will copy s bytes from call data at position f to memory at position t. The first zero is a t. The t will be memory at position t. So this will be at memory position zero.
00:04:23.854 - 00:04:53.898, Speaker A: The next input is A-F-F will be the starting position of the call data to copy. So we're saying from zero and then s will be the size of the data to copy. So what this command is doing here is copy the call data into memory at memory zero. Starting from the call data from zero to call data size. Basically we're copying all of the call data into memory at zero position. Okay, let's see what it does next. Next it calls delegate call.
00:04:53.898 - 00:05:40.086, Speaker A: Let's go over what each of these inputs mean. G is gas, so we're forwarding all of the gas implementation. That is the address of the implementation to execute delegate call on zero will be in and then the next parameter will be input size. So these two parameters are saying to call a contract at address a address. A is the implementation with input at memory stored from int to in plus in size. In the previous command, we store the call data into memory from zero, and then over here we are saying use the call data as input, and the call data is stored from memory inside the memory from zero to call data size. Basically, we're passing all of the call data that we receive.
00:05:40.086 - 00:06:12.018, Speaker A: The next parameter is out and out size. Here we're saying store the output. Store the result of delegate call to memory from out to output size. But since we don't know the size of the output before we execute delegate call, we are simply ignoring the output. So here we're saying zero and then zero, and in the next line we'll handle the output. So in the previous line we ignored the output, and on this line we copy the data that was returned the output. So let's go over what return data copy does.
00:06:12.018 - 00:07:00.050, Speaker A: Return data copy copies s bytes from return data at position f to memory at position t. So what this means is that we're going to be copying the data that was returned to memory zero, starting at the zero position of the memory, and the size of the data to copy is stored under return data size. The function return data size returns the size of the last return data. This will be the data that was returned when we call the function delegate call. So once we have the result of calling delegate call onto memory zero, the last step is to handle whether the delegate call was successful or not. If the result, the result that's over here is zero, then this means that there was an error. So we'll rebirth, and we'll return all of the output that was returned from delegate call.
00:07:00.050 - 00:07:28.842, Speaker A: Return all of the data from starting from zero to return data size. Otherwise, if the result is not equal to zero, then that means that the delegate call was successful. So we'll store the data that's stored in memory from memory zero to return data size. In the previous step, return data copy. We copy the data that was returned into memory, and then here we're returning that data. And that is how you return a data from a fallback function. So let's try this out.
00:07:28.842 - 00:08:08.650, Speaker A: I'll hit ctrl s to compile the contract. Next, I'll click on this button, and then we'll clear out all of the contracts that we deploy, and then we'll deploy them again. So I'll deploy the buggy proxy contract. Next, I'll deploy counter b one, and I'll also deploy counter b two, and then open the proxy contract. Copy the address of counter b one, set the implementation. Next, we'll call the function ink on counter b one using the proxy contract. So copy the address of the proxy contract, select counter b one, paste the address here, and then load it.
00:08:08.650 - 00:08:42.340, Speaker A: Scroll down, open the interface for counter b one, load it for the proxy contract, and then call the function ink. Maybe we'll call it several times. And let's try getting the count. So I'll click on count and it returns two. Okay, so we now know that this fallback function, this fallback function can return some data. Let's try upgrading our contract to version two. So I'll copy the address of counter b two, paste it here, and then click on upgrade two.
00:08:42.340 - 00:09:14.542, Speaker A: Once the contract is upgraded, I'll first delete the interface that we loaded. And then we'll load the interface for counter b two using the proxy contract. Copy the address of proxy, paste it here. Make sure that we select counter b two and then deploy and then load it. Scroll down, open interface for counter b two, and let's check the count should be still be two. And notice that we now have a function called deck. Deck will decrement account by one.
00:09:14.542 - 00:09:33.662, Speaker A: So let's try calling it. I'll call deck. The count before was two. We decremented by one. So if you call our function count again, it will be equal to one. In this video, I'll show you how to return data from a fallback function. And we went through a demo of upgrading from counter b one to counter b two.
00:09:33.662 - 00:09:46.740, Speaker A: Now notice that for both counter b one and counter b two, we need to declare the state variables for implementation in admin. In the next video, we'll remove these state variables and then store it somewhere else by.
