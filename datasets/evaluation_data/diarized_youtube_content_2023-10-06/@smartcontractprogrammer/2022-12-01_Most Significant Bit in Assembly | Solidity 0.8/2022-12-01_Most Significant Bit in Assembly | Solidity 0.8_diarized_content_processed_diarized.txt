00:00:00.330 - 00:00:28.770, Speaker A: Most significant bit is a function that returns the most significant bit of a number. Imagine a number in its binary representation, a sequence of ones and zeros. This function most significant bit will return the position of the leftmost one. For example, if we take the number eight, eight is equal to two, to the three. So in the third position, starting at zero, we will have a one. So if you feed an eight into this function, we will a three bag. In this video we're going to convert this function using assembly.
00:00:28.770 - 00:00:57.294, Speaker A: And by using assembly we can save about up to 1500 guests. So to start off with, we'll start with the simple part. So scroll down and then first we'll convert this part into assembly. I'll comment this code out and then we'll start with assembly. Let's start with the easy part. Let's start with this part of the code. Is x greater than or equal to two? Now inside assembly, we don't have any operations to say greater than or equal to.
00:00:57.294 - 00:01:35.018, Speaker A: So instead we'll use the opcode greater than. So you'll type, is x greater than zero x one, is x greater than one? If x is greater than one, then this is the same as asking, is x greater than or equal to two? Now this opcode will return a one if x is greater than one. Otherwise it will return a zero. We'll assign the result to a variable. We'll name it f, short for a scaling factor that we'll use in other parts of the code. So I'll say that f is equal to now inside assembly to say equal to. To assign something to a variable, we'll have to put a colon and then an equal sign.
00:01:35.018 - 00:02:00.050, Speaker A: So we'll store the result of this comparison. Is x greater than one. If x is greater than or equal to two, then we say MsB. Msb is the result that we're returning from this function. Most significant bit. We add one to this. How can we write this part of the code Msb plus equal to one using assembly? Well, what we can do is say Msb, assign it to.
00:02:00.050 - 00:02:26.186, Speaker A: So say colon equals to add, add to Msb, we want to say one if this part of the code is true. Otherwise we want to say zero. Now, luckily we can do this by adding the f. Why does this work? If x is greater than one, then this will return a one. So this part of the code will be adding one to MsB. Otherwise, if this is zero, then we're adding zero to MSB. In other words, MSB does not change.
00:02:26.186 - 00:03:09.558, Speaker A: Now, the other modification that I'll make is instead of using add, we'll use the bitwise operator or the bitwise operator, or takes two sequence of bits and it returns a sequence of new bits. It compares each bits of the inputs and returns a one. If either of the inputs is a one. Otherwise, if both are zero, then it returns a zero. For example, if the first sequence is 1010 and the second sequence is 0110, then taking the bitwise or of the first two inputs, for the first position we have a one and a zero, so it returns a one. For the next position there's a zero and a one, so it returns a one. For the next one it has a one and a one, so the return value is a one and for the last position both are zero.
00:03:09.558 - 00:03:33.722, Speaker A: So the result is a zero. And this is the result, the new sequence that is returned one 10. So that is an example of the bitwise operator. Or. Now in this case we can replace the opcode add with or because there won't be any overlap of ones between Msb and F. So simply taking an or is just like addition. Okay, so we replaced this part of the code using assembly.
00:03:33.722 - 00:04:13.270, Speaker A: So let's now replace this part of the code using assembly. So first I'll comment this code block, and then again we'll start with assembly again. Let's start with the easy part. Let's first write this part of the code. Is x greater than or equal to four? We can do that using upcode by typing greater than x zero x three. Is x greater than three? That is the same as asking, is x greater than or equal to four? Now if x is greater than or equal to four, then we'll need to shift x to the right by two, and then to Msp we'll need to add two. So our next step is to create this two inside the opcode.
00:04:13.270 - 00:04:53.850, Speaker A: Now, the result of executing this opcode, if x is greater than three, then this will return a one. Otherwise it will return a zero. So if this is true, how can we create this number two? Well, we can do this by shifting the result of this opcode to the left by one. And we can do that by typing shl shift to the left by one. The result of evaluating is x greater than three. If x is greater than three, then this will return a one, and shifting one over to the left by one we will get a two. Otherwise, if x is less than or equal to three, then this code will return a zero, and shifting zero over to the left by one, we still get a zero back.
00:04:53.850 - 00:05:29.158, Speaker A: And then we assign the result to a variable named f. So I'll say let f equal to this variable f will be equal to two if this part of the code evaluates to true, otherwise it is equal to zero. So now we can shift x by two. If x is greater than or equal to four by saying x assigned to x equals two, shift it to the right by f. The number x f is equal to either two or zero. If it is equal to two, then it's the same as executing this part of the code. If it is equal to zero, then x remains as x.
00:05:29.158 - 00:06:15.394, Speaker A: So these two part of the code are equivalent to these two part of the code. And then again we'll update msp by adding two. If x is greater than or equal to four by typing Msb, assign it to or we can use an add here again, but instead we'll use an or so or MSBF. We now converted this part of the code into assembly. Let's do the same for this part of the code. Now notice that from this part of the code to this part of the code, the only difference, the logic remains the same, and the only difference are the number that's being compared, the number that is being shifted, and the number that is being added to MSp. So the code that we're going to be writing will be similar to this, except it will be different in numbers.
00:06:15.394 - 00:06:56.558, Speaker A: So first I'll paste the code and what we're going to be doing is just changing the numbers around. Let's start with the comparison again. Is x greater than or equal to zero x 10 zero x 10 is equal to 16 written in hexadecimal notation. Since we cannot do greater than or equal to, we'll need to resort to greater than. So we'll need to do a comparison of one less than 16. What is one less than 16 and hexadecimal? One less than 16 is 15 and hexadecimal, this will be zero xf. So we'll ask, is x greater than 15? The result of this opcode returns a one or a zero.
00:06:56.558 - 00:07:25.866, Speaker A: If the result is a one, we'll need to shift it by some amount so that we get a four. Starting from one. How many times will we have to shift it to the left to get four? If we shift it by once, we get a two. So if we shift it by twice we'll get a four. And notice that for the rest of the code we don't have to make any change. Okay, so let's do one more. Let's convert this part of the code into assembly again, the only thing that will change is the numbers.
00:07:25.866 - 00:08:00.822, Speaker A: So I'll copy this code, paste it here, and then what we're comparing is, is x greater than or equal to two to the eight, one less than this will be two to the eight minus one. Or in hexadecimal we can put two f's. If we add one to this, we'll get zero x 10 zero. So if this is true, then it will return a one. And let's ask the question starting from one. How many times do we need to shift it to the left so that we'll get the number eight? When we shift it by two, we got a four. So if we shift it to the left one more time then we'll get an eight.
00:08:00.822 - 00:08:31.578, Speaker A: So shift this to the left by three and the rest of the code remains the same. I've updated the rest of the code to use assembly. The only changes that I made are the numbers that being compared and the number of times that I have to shift over to the left. Otherwise the code is the same. So let's deploy this contract and give it a try. I'll call most significant bit with two examples, calling it with zero and calling it with max unit two to the 256 minus one. So I'll hit Ctrl s to compile the contract and then deploy the contract.
00:08:31.578 - 00:08:59.894, Speaker A: And then let's call it with zero and we expect the result to be equal to zero. Okay, next let's call it with max un. We expect the result to be 255. Paste max un and then call most significant bit and the result is 255. How much gas does it save? Here I have two contract, both have the same functions. Most significant bit. This is the function that we had before we rewrote it in assembly.
00:08:59.894 - 00:09:39.970, Speaker A: And this is the assembly form of the same function which I have deployed over here. So let's call most significant bit using the function form and then later we'll call the assembly form and then compare the gas cost. So open the function form and we'll call most significant bit with max un which I've commented out here. Paste it, call it, and let's get the gas cost. The gas cost of calling this function is 24,067. I'll copy this and then paste it here. Function used up 24,067 gas.
00:09:39.970 - 00:10:06.250, Speaker A: Next let's call the same function with the same input using the assembly form. So open the assembly form, paste it, call it, and then get the cost of the gas. 22,488 so assembly used up 22,488 gas. Just estimate, you can see that the assembly farm saved about 1500 gas.
