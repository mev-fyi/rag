00:00:00.410 - 00:00:44.614, Speaker A: Let's write the code for constants on amm. First we'll define three functions. Function swap, add liquidity, and remove liquidity. So I'll type function swap external the inputs and the return value. We'll define it later. For now we'll just name the functions function add liquidity again external all and that's the function remove liquidity again. Next terminal recall that swap is used to trade token for another token, add liquidity is used to add tokens, and remove liquidity is used to remove tokens.
00:00:44.614 - 00:01:30.326, Speaker A: Okay, next, let's define some state variables. This constant sum amm will have two tokens, so I'll say IERC 20 public token zero. Now, token zero will never change inside this contract, so we can make this immutable and we'll do the same for token one. We'll copy the line above and then change this token zero to token one. Now we have not defined the IERC 20 yet, so let's do that right now. I'll create a new file called IERC 20 sol. Open it, copy the headers, paste it, and then I'll copy the interface for ERC 20 that I got from the Internet.
00:01:30.326 - 00:02:11.734, Speaker A: And then we'll go back to the CSAM contract and then import the IERC 20 that we just defined. So here I'll say import IERc 20 sol. Okay, we'll continue defining the state variables. We'll define two state variables that keep track of the balance of the tokens that are locked inside this contract. We'll say un public reserve zero. This will keep track of the amount of token zero that is inside this contract. And likewise we'll define another state variable, un public reserve one.
00:02:11.734 - 00:02:55.350, Speaker A: This will keep track of the balance of token one. We also need to keep track of total shares and shares per user. Total shares. We'll define a state variable called un public total supply, and for shares per user we'll store it in a mapping called mapping from address address of the user to Un. This will be the amount of shares public balance up, and that completes the state variables. Next, let's write some constructor, so I'll type constructor. We'll initialize the two immutable variables, token zero and token one.
00:02:55.350 - 00:03:49.426, Speaker A: So for the input of the constructor I'll pass in address token zero, address token one, and then we'll initialize these immutable variables by saying token zero is equal to IERc 20, token zero from the input, and likewise for token one. So I'll copy this, paste it, and then rename token zero to token one same for the input and that completes the constructor and the state variables. Let's try compiling this contract. I'll hit ctrl s and the contract compiles, so let's move on. The next thing that I'll do is write two internal functions. One function to mint shares and another function to burn shares. So I'll name this function underscore mint.
00:03:49.426 - 00:04:31.982, Speaker A: It's going to take in two parameters. Address of the account to mint shares two I'll call it underscore two and the amount of shares to mint un I'll call it underscore amount. This function will be private, so I'll say private, and inside it we'll increment the balance for two by the amount by typing balance of two plus equals amount, and then we'll increment the total supply. So we'll type total supply. This will be the total shares. We'll also increment it by the amount. Next we'll write an internal function to burn the shares.
00:04:31.982 - 00:05:13.786, Speaker A: So I'll copy this, paste it here, and then we'll name the mint function to burn. It's going to take in two parameters, the account to burn the share from I'll name it underscore from and the amount will be the same. And then from the balance of from we'll subtract amount, and from the total supply of shares we will also subtract amount. I'll hit ctrl s to see if the contract compiles and the contract compiles. Okay, let's now write the function for swap. When a user calls this function swap, they'll be able to trade one token for another token locked inside this amm. For the input.
00:05:13.786 - 00:06:13.474, Speaker A: This function will take two parameters. The address of the token I'll call it address underscore token in. This will be the address of the token that the user is selling and un amount in the amount of token in that the user is selling, and we'll return the amount of the other token that was returned to the user. So I'll type returns un amount out. First we'll require that token in is either token zero or token one. So here I'll type require token in is equal to address of token zero or token in is equal to address of token one, and if it is not then we'll throw an error message saying invalid token. Okay, before we write any code, let's put some comments in and try to figure out what this function needs to do.
00:06:13.474 - 00:06:58.418, Speaker A: The first thing that we'll need to do is transfer the token in into this contract. So I'll say transfer token in and then it will need to compute the amount that it's going to go out. So I'll say calculate amount out and we'll include fees. So including fees. Now recall that we said that these two state variables, reserve zero and reserve one, will keep track of amount of tokens locked in this contract. So we'll need to update these state variables. So here I'll say update reserve zero and reserve one.
00:06:58.418 - 00:07:29.820, Speaker A: And lastly, we'll transfer the other token to the user. So you'll say transfer token out. Okay, we now have some comments. Let's write some code. So the first step is to transfer token in. Now notice that at this point we don't know if token in is token zero or token one. So we already if condition statement saying if token in is equal to address of token zero else.
00:07:29.820 - 00:08:07.270, Speaker A: So if tokenin is token zero, then we'll say token zero. Dot transfer from message sender to this contract. So that will be address this for the amount amount in. And likewise, we'll do something similar if token in is token one. So I'll copy the code above and then replace token zero with token one. Okay, next we'll calculate amount out. But to do this, we'll need to calculate the amount that was actually transferred in.
00:08:07.270 - 00:09:03.660, Speaker A: So I'll type un amount in and then we'll say that amount in is the difference of the actual balance of token locked in this contract minus the reserve. So if token in is token zero, then we'll say amount in is equal to token zero. Balance of address this minus reserve zero. Anytime the balance of token zero changes inside this contract, reserve zero will be updated. So here we're saying the current balance of token zero minus the last balance of token zero that we observed inside this contract, and the difference is the amount that came in. Likewise, we'll do for token one. If token in is token one, then amount in is equal to token one.
00:09:03.660 - 00:09:38.034, Speaker A: Balance of address this the current balance of token one minus reserve one. Okay, now we can calculate amount out, including fees. So first of all, let's assume that the fee is zero. Recall that we said that dx the amount of token in must equal dy the amount of token out. For simplicity, if the fee is zero, then amount out. We'll define amount out as a return value so we don't have to declare a event over here. Anyways.
00:09:38.034 - 00:10:00.566, Speaker A: Amount out. If the fee is zero, then this will simply be equal to amount in. However, we'll say that the trading fee is 0.3% in every trade. For the amount that comes in, we'll consider that the amount that came in was 99.7% of the actual amount that came in. So we'll say trading fee is 0.3%
00:10:00.566 - 00:10:34.438, Speaker A: fee and from the actual amount that came in, we'll calculate the amount out to be 99.7% of amount in. So here we'll type amount in times 99.7 divided by 1997 divided by 1000 is 0.997, which is 99.7%. So this final code is saying amount out is equal to 99.7% of the actual amount that came in.
00:10:34.438 - 00:11:21.078, Speaker A: Okay, next, before we transfer this amount out of token, let's update reserve zero and reserve one. So first I'll create an internal function that updates reserve zero and reserve one. I'll type function, I'll name it underscore update, and it's going to take in two parameters. The new reserve zero, un underscore. I'll name it rest zero and un underscore rest one. This function will be private and then we'll update the state variables. Reserve zero, reserve zero is equal to underscore rest zero and likewise for reserve one, reserve one is equal to underscore rest one.
00:11:21.078 - 00:12:20.262, Speaker A: I'll scroll back down and we'll update reserve zero and reserve one. Again, we'll need to consider two conditions. If the token in is token zero, and if the token in is token one. So if token in is equal to address of token zero, then reserve zero increased and reserve one decreased by amount out. So I'll type update reserve zero plus amount in and reserve one minus amount out. Else token in is equal to token one. So we'll need to call the function update, token one is going out, so it'll be reserve zero minus amount out and reserve one is increasing.
00:12:20.262 - 00:13:06.694, Speaker A: So say reserve one plus amount in and then lastly we'll transfer the token out. Again. We'll need to consider two conditions. If token in is token zero, or if token in is token one. So I'll copy this logic, paste it here, remove this code, and likewise remove this code, and then we all write the code to transfer token out. If token in is token zero, then token out is token one. So say token one transfer to message sender, the amount is amount out, and if token in is equal to token one, we'll copy this.
00:13:06.694 - 00:13:40.414, Speaker A: Then token out will be token zero. So I'll replace token one with token zero and that completes the function. For swap, let's try compiling this contract. So I'll hit ctrl s again and the contract compiles. Now, before we move on to the other functionality, add liquidity and remove liquidity. Notice that inside the function swap there is a lot of repetition checking whether token in is equal to token zero or token one. So let's refactor this code so that it'll be more gas optimized.
00:13:40.414 - 00:14:48.330, Speaker A: The first thing that I'll do to refactor this code for the function swap is to check that whether token in is equal to token zero or not and then store it in a variable. So I'll create a boolean variable called boolean is token zero and then say token in is equal to address token zero. And then next we'll define the token that's coming in and the token that is going out by typing IErc 20 token in and IErc 20 token out is equal to if is token zero is true, meaning token in is token zero. So I'll type is token zero. Question mark here we're using the ternary operator, which is a shortcut for the if else condition statements. So if is token zero, then token in will be token zero and token out will be token one. Otherwise it will be the other way around.
00:14:48.330 - 00:15:35.094, Speaker A: So token in is token one and token out is token zero. Now, since we declared what token in and token out is, we can now refactor this part of the code and this part of the code. Let's begin with this part of the code. We know what token in is now, so we can remove this if statements and replace token zero with token in that we defined over here. And also change the code for amount in as well. So token in and then un amount in and then remove this decoration. Now notice that here we still have reserve zero.
00:15:35.094 - 00:16:08.802, Speaker A: So let's add some code over here to also declare what reserve in is and what reserve out is. So inside here reserve in. So I'll say rest in and reserve out. Un rest out. If token in is token zero, then reserve in is reserve zero reserve zero, and the reserve out will be reserve one. And the opposite. If token in is token one, then reserve in will be reserve one, and reserve out will be reserve zero.
00:16:08.802 - 00:16:41.750, Speaker A: Then we can replace this reserve zero over here with rest in. Next, let's refactor the code for transferring the token out. Since we already know what token out is. So I'll remove this check, then this else statement as well. Then we'll say token out transfer to message sender amount out. How else can we refactor this code? Well here we're also checking again if token in is token zero or token one. So let's try to refactor this part of the code.
00:16:41.750 - 00:17:22.490, Speaker A: Since we already know whether token in is token zero or token one, which we checked over here, let's use this variable, and then like the code over here, let's compute the new reserve in and reserve out before calling the function update. So we'll say that the new reserves will be un rest zero and un rest one is equal to is token zero. Question mark. Actually, I'll move the question mark over here. Then the new reserves will be the code over here. So I'll type. But remember that we cached reserve zero and reserve one up over here in this code.
00:17:22.490 - 00:18:02.294, Speaker A: So we'll just use these variables instead of the state variables. Reserve zero and reserve one. This will save us a little bit of guess. So first of all, I'll copy this code, paste it here, and then replace reserve zero with the cached version of rest zero. Reserve one with rest one. If token in is not token zero, so this is token zero is false, then we'll return this part of the code. So I'll copy this and then paste it here, and then replace the state variables again with the cached local variables rest here.
00:18:02.294 - 00:18:51.190, Speaker A: I made a mistake. Instead of saying rest zero and rest one, if I scroll up, they're declared as rests in and rests out. So we'll replace this with rest in and rest out. And likewise over here we'll say rest out minus amount out and rest in plus amount in. Let's double check our code to make sure that the new reserves match the old code. If token in is token zero, then this part of the code will be executed, so that the new reserves will be rest in plus amount in and rest out minus amount out. If we scroll back up, if it is token zero, then rest in is reserve zero, and rest out is reserve one.
00:18:51.190 - 00:19:22.702, Speaker A: So I'll scroll back down and double check that rest n is reserve zero and rest out is reserve one. So this part of the code checks out. Let's check this part of the code. If is token zero is false, then let's check what rest out and rest n is. So I'll scroll back up and we see that rest n is reserve one and rest out is reserve zero. So scroll back down, rest n is reserve one, and rest out is reserve zero. So this part of the code also checks out.
00:19:22.702 - 00:20:12.470, Speaker A: So we're getting the correct values for the new reserve zero and reserve one. So the final step is to call the internal function update rest zero, rest one, and then we'll remove this code and that completes the function for a swap. Next, let's write the function for add liquidity. Recall that the user can call the function add liquidity to add tokens to this amm to earn some fees, we'll say add liquidity takes in two inputs the amount of tokens to put inside this amm. So I'll type un underscore amount zero and un underscore amount one. This function will return the shares back to the users. So we'll type returns shares.
00:20:12.470 - 00:20:59.370, Speaker A: The first thing that we'll do is transfer token zero and token one into this contract. So say token zero, transfer from message sender to this contract. Address this further amount amount zero and we'll do the same for token one as well. So copy the code above, paste it. Replace token zero with token one and amount zero with amount one. Like what we did over here inside the swap contract where we calculated the actual amount that came in by calling transfer from and then checking the balance and then comparing it with the reserves in. We'll do something similar over here to calculate the actual amount of tokens that came in inside this contract.
00:20:59.370 - 00:21:55.890, Speaker A: So the first thing that we'll do is get the current balance of token zero and token one. I'll type event bal zero is equal to token zero. Dot balance of address this and I'll do the same for token one as well. Copy the code, replace bow zero with bow one, token zero with token one, and then we'll next get the actual amount of tokens that came in. I'll say un d zero is equal to bal zero minus reserve zero, and I'll say un d one is equal to bow one minus reserve one. So d zero and d one is the actual amount of tokens that came in when the user called the function add liquidity. The next step is to mint shares to the user and then update the reserves.
00:21:55.890 - 00:22:35.360, Speaker A: So recall from a previous video that a is the amount in L is the total liquidity, s is the shares to mint, and t is the total shares. Then the amount of shares to mint is equal to s is equal to a times t divided by L. So let's implement this part of the code now. Notice that when the first user adds liquidity, total shares is still equal to zero. So we'll have to handle it a little bit differently. What we'll do is say if total share is equal to zero, then we'll mint the same amount of shares as the amount of tokens that came in. So we'll say if total supply is equal to zero.
00:22:35.360 - 00:23:07.234, Speaker A: Then shares is equal to the total amount that came in d zero plus d one. Else total supply is greater than zero. So we'll implement this part of the code. Shares is equal to d zero plus d one multiplied by total supply. Total supply and then divide this by total liquidity. Reserve zero plus reserve one. So that calculates the amount of shares to mint.
00:23:07.234 - 00:23:45.606, Speaker A: Next, let's mint the shares. So first, I'll require that the amount of share that was calculated is greater than zero by typing require shares greater than zero. And if not, we'll throw an error message saying shares is equal to zero. So once we know that the share is greater than zero, then we'll call the internal function that we defined earlier underscore mint two message sender the amount of shares shares. And then lastly, we'll update the reserves. So say update. The new reserves will be bow zero and bow one.
00:23:45.606 - 00:24:42.210, Speaker A: And that completes the function. For add liquidity, let's write the last function. Remove liquidity. When a user calls remove liquidity, they're burning their shares, and in return they're getting some tokens locked in this contract back for the input we'll pass in the amount of shares to burn, so un shares, and then we'll return the actual amount of tokens that was transferred back to the user, so returns und zero. D zero will be the amount of token zero that was returned and un d one the amount of token one that was returned to the user. Now again, recall that from a previous video we set that a is the amount out, l is total liquidity, s is shares of the user, and t is total shares. Then the amount of tokens to return must satisfy this equation, and this turns out to be reserve zero plus reserve one times the shares divided by the total shares.
00:24:42.210 - 00:25:20.478, Speaker A: Okay, so let's implement this code to calculate the amount of tokens to return. So we'll say d zero. Now, notice that we define d zero here, so we don't have to put a un in front of this. D zero is equal to reserve zero multiplied by the shares divided by total supply. And likewise, d one is equal to reserve one multiplied by shares divided by total supply. When you add d zero and d one, then it satisfies this equation. Next, we'll burn the shares.
00:25:20.478 - 00:26:18.838, Speaker A: So I'll type burn from message sender for the amount shares, and before transferring the tokens out, we'll update the reserve by calling the internal function underscore update from reserve zero. The amount that is going out is d zero. So I'll type minus d zero. Then from reserve one the amount that is going out is d one. So I'll type d one and the last step is to transfer the tokens out. I'll type if d zero is greater than zero, then we'll call token zero transfer to message sender for the amount d zero, and likewise we'll do the same for token one. So I'll copy this, paste it here, and replace d zero with d with d one and token zero with token one.
00:26:18.838 - 00:27:11.282, Speaker A: And that completes the function for remove liquidity, and that completes the code for constant sum amm. Let's double check our code by hitting Ctrl s to compile the contract and there is an error. So let me fix the code. I forgot to declare that shares is unint, so I'll fix that, hit Ctrl s and I misspelled reserve one, so I'll fix that, hit Ctrl s again and the contract now compiles. Okay, so the last part of this video, let's deploy this contract and then try and calling these function swap, add liquidity, and remove liquidity. For this example, I copied and pasted our ERC 20 contract, and we'll deploy two of these and then initialize the constants from AMM contract. So first let's deploy two of ERC 20 contracts.
00:27:11.282 - 00:27:45.806, Speaker A: I'll compile this contract and then we'll deploy this ERC 20 contracts. Select ERC 20, and we'll deploy two of these contracts. So hit deploy, and then we'll deploy another ERC 20 contract. So hit deploy again. If I scroll down I see two ERC 20 contracts. So next let's deploy the constants on AMM contract, select the contract, and then make sure that constants on AMM appears here. And to deploy this contract, we'll need to pass in the address of the two ERC 20 contracts.
00:27:45.806 - 00:28:33.890, Speaker A: So scroll down, copy the address of the ERC 20 contract, and then copy the address of the other ERC 20 contract. Paste it here, and then click on transact, scroll down, and make sure that constants on AmM is deployed. So I'll open the contract now and let's now try calling add liquidity swap and then remove liquidity. To add liquidity, the user must have both token zero and token one. So for the first user, which will be the first account, let's mint some tokens. So I'll open the first token, we'll call it token zero, and then we'll mint 100 token to the first user. Then we also mint 100 token of token one to the first user.
00:28:33.890 - 00:29:24.690, Speaker A: To add liquidity to the constants on Amm. Notice that it's calling transfer from. So this means that user one will have to call the function approved for both token zero and token one on the contract constants on Amm. So I'll copy the address of constants on Amm, scroll up and then we'll call this function approved. The spender will be the constants on Amm and for the amount we'll put in 100, and we'll do the same for the other token as well. So I'll scroll up. This is for token zero, paste the address of CSAM, and then for the amount 100 now that the two tokens are approved to be spent by CsAM.
00:29:24.690 - 00:29:56.794, Speaker A: Next we'll call the function add liquidity. We'll add 100 tokens of both token zero and token one and then hit transact. You can see here that the transaction was successful. Let's check the balance of user one. I'll scroll up to copy the address of user one and then paste it here. Balance of we put in 200 tokens in total. And notice that the balance of user one is 200.
00:29:56.794 - 00:30:46.826, Speaker A: Let's check reserve zero 100, reserve 1100, and also the total supply 200. So next let's call the function swap. We'll say that another user is calling the function swap, so I'll switch accounts. Now since this account does not have any token zero in token one, we'll mint some tokens for this user as well. So token zero we'll also mint 100, and for token one we'll also mint 100. Now if we check the function for swap, this is also calling transfer from. For this example, let's say that user two will sell token zero for token one.
00:30:46.826 - 00:31:12.130, Speaker A: So token in will be this token over here and token out will be this token. Transfer from is called on token in. So this will be this contract. So we'll need to approve the CSAm to spend our tokens. Let's trade ten tokens. So I'll replace approve with ten and then hit transact. And again, remember that we're now calling functions from user two.
00:31:12.130 - 00:32:02.190, Speaker A: So I'll scroll down and then we'll call the function swap from user two. The function swap needs to be passed in, token in, and amount in. I'll scroll up to get the address of token in. This will be token gel, copy it, paste it here, and the amount will be ten and then hit transact and the swap is successful. Okay, so the last function that we'll call is remove liquidity since user one is the only user that added liquidity, we'll switch back to user one. We'll remove all the liquidity, so we'll get the balance of user one from the contract constants on amm. So click here, get the balance of shares, and then we'll call remove liquidity.
00:32:02.190 - 00:32:24.450, Speaker A: Since all of the liquidity was removed, we expect that reserve zero to be zero, reserve one to be zero, and total supply to be zero. And that completes the demo for the constants on ammunition.
