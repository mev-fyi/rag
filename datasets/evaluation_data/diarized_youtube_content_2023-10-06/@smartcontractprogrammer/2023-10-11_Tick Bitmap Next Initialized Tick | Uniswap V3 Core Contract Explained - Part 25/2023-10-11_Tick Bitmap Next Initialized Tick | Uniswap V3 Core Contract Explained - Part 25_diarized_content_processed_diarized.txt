00:00:00.330 - 00:00:36.674, Speaker A: Let's finish the library for tick bitmap. So in the previous video we worked on position and flip tick. In this video we'll work on the function called next initialize tick within one word. This is a function that will return the next tick for the input it's going to take in the state variable, the tick bitmap mapping from int 16 to un two five, six. It's also going to take in the current tick tick spacing and the direction that want to find the next tick less than or equal to. And then it's going to return two values, the next tick and whether this next tick is initialized or not. Okay, first we'll divide tick by the tick spacing.
00:00:36.674 - 00:01:11.170, Speaker A: So I'll say int 24 compressed is equal to tick divided by tick spacing. What this is doing is instead of jumping the tick by one, instead of incrementing the tick by one, we're incrementing by tick spacing. Next we're going to round down this compress to negative infinity. What I mean here is when we divide tick by tick spacing. Here we're doing integer division. So it will cut off the decimal parts it will round down and this is true for positive numbers. However for negative number when it rounds down it's actually going to increase the number.
00:01:11.170 - 00:01:57.806, Speaker A: So what we need to do is check when the tick is less than zero and when it doesn't divide evenly by tick spacing. Then we'll round down by one. So say if tick is less than zero and tick does not divide by tick spacing evenly, tick mod tick spacing is not equal to zero so it doesn't divide evenly. Then we'll round down to negative infinity by decrementing by one compressed minus minus. The next part is to find the next tick and this would break down into two parts if less than equal to else. Now to search for a tick that is less than or equal to the current tick. This means that on the tick bitmap we'll need to search for one to the right of the current tick.
00:01:57.806 - 00:02:37.006, Speaker A: So first we'll get the position by calling this function over here position. So say int 16 word position and un eight bit position. This is equal to call a function position on the compressed tick. Okay, next we'll need to create all ones at or to the right of the bit position. So I'll type un to 56 mask is equal to. The way we can create all ones to the right of the bit position is by first creating a one at the bit position. So I'll type one move one by bit position.
00:02:37.006 - 00:03:26.570, Speaker A: So now at this point we have a one at the bit position and if we minus one from this we have all ones to the right of this bit position. And then finally to add a one at the bit position, you just need to add one at the bit position bit position. Okay, so this mask will create all ones at and to the right of the bit position. Next we'll use the and operator on the tick bitmap using this mask, say uint to 56. Masked is equal to the tick bitmap is self and to get the actual bitmap we'll need to access it by word position. And then we'll apply the bitwise and with the mask and mask. And what this will do is we'll get all the ones at or to the right of the bit position from the tick bitmap.
00:03:26.570 - 00:03:58.914, Speaker A: And by doing this we get some information on where the next tick is. We'll know that the next tick is initialized or not by checking whether masked is equal to zero or greater than zero. If mask is equal to zero, then there is no next tick. So initialized will be equal to false. Otherwise initialized will be equal to true. Initialize is equal to check whether masked is not equal to zero. To get the next tick, what we're going to do is take compressed, remove the current bit position and then add the rightmost bit of masked.
00:03:58.914 - 00:04:35.894, Speaker A: This is what we will do if the tick is initialized. However, if the tick is not initialized, what we will return is compressed minus the current bit position. I'll say next is equal to is this initialized? Initialized? If it is, what we'll do is compressed minus minus the bit position. Bit position and after we minus this bit position we'll add most significant bit. Or we can simply write minus bitmap. Most significant bit of masked. Now bit position is un eight.
00:04:35.894 - 00:04:59.718, Speaker A: However compressed is int 24. So we'll need to cast this part into int 24. So to do this, we'll first cast this part into Un 24, say Un 24. And then we'll cast this into int 24. Int 24. So this part is this part. The last part is to multiply by tick spacing.
00:04:59.718 - 00:05:28.550, Speaker A: Tick spacing. Okay, so this is the case if the tick is initialized. How about if the tick is not initialized? What we're going to do is again start from compressed and then minus the current bit position. The current bit position is bit position. Again, this is un eight and we'll need to cast it into int 24. So first I'll cast it into un 24. And then once we have un 24 we'll cast it into int 24 int 24.
00:05:28.550 - 00:05:58.890, Speaker A: Then that's the multiplied by tick spacing. Tick spacing. Okay, and that completes the condition when we're searching for a tick that is less than or equal to the current tick. Now I'm going to go up and check if we imported bitmap library. So I'm going to scroll up and we have bitmap library imported. So inside this library we'll have the function most significant bit which will return the index of the most significant bit. And that completes the part for searching for the tick that is less than or equal to the current tick.
00:05:58.890 - 00:06:30.782, Speaker A: Let's handle the other case. What we're looking for is a tick that is greater than the current tick. What I'm going to do is copy this first. So we're going to break down the current tick current compressed tick into two parts word position and then bit position. Since we're searching for a tick that is greater than the current tick on the tick bitmap, we'll be looking for a one to the left of the current bit position. So to do this we'll first create a mask that is all ones at or to the left of the current bit position. I'll say un 256 masked.
00:06:30.782 - 00:07:10.066, Speaker A: And how are we going to create all ones to the left of the current bit position? Well, we'll start off by creating a one at the bit position. So say one at the bit position. Now recall from earlier that if we minus one from this we get all ones to the right of the bit position. This is the opposite of what we want to get all ones to the left of the current bit position. All we have to do is negate this by using not bitwise operator. Okay, once we have our mask, we'll apply this mask to the tick bitmap. So un 256 masked.
00:07:10.066 - 00:07:44.970, Speaker A: So this was mask. Masked is equal to self of word position and apply it in the bitwise. And again to check whether the next tick is initialized or not. All we have to do is check whether masked is equal to zero or not. Initialized is equal to whether masked is not equal to zero or not. To get the next tick we'll increment the current compressed tick by one and to this add the least significant bit of mask and then minus the current bit position. And lastly we'll multiply by tick spacing.
00:07:44.970 - 00:08:30.606, Speaker A: Say next is equal to. Again, we will have to handle two cases whether this is initialized or not initialized. When it is initialized we'll do some math inside here and then multiply by tick spacing. And what are we multiplying by tick spacing? Well, we'll start with compressed and then add one. Here we're adding one because we're searching for the next tick to be greater than the current tick. By adding one we guarantee that the next tick is greater than the current tick. And to this we'll add the least significant bit of mask bitmap, least significant bit of masked and then from this we will minus bit position bit position now again, we'll need to cast this into int 24.
00:08:30.606 - 00:09:22.174, Speaker A: So you'll first cast it into un 24 un 24 and then cast it into int 24 int 24 if the tick is not initialized, what we're going to do is take compressed, add one and then fill all the bit position with ones. And then minus the current bit position we'll say compressed plus one plus again we'll need to cast this into int 24 int 24 Un 24 the bit position is un eight, so we'll get the max of un eight type un eight max. You can imagine that this is a sequence of all ones of length eight. We're maxing out the bit position by filling it up with all ones and then minus the current bit position bit position, okay. And then lastly multiply this by tick spacing. Multiply by tick spacing. Okay, that completes the function.
00:09:22.174 - 00:09:51.250, Speaker A: Next, initialize tick within one word. Let's try compiling this contract. So I'm a terminal type forge build. There's an error so I'll go fix it. Line 53 semicolon and semicolon fix the typo initialized in show and a contract compiled.
