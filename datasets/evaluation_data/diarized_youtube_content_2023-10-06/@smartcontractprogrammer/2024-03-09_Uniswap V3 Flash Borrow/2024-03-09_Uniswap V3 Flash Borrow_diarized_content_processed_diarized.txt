00:00:00.330 - 00:00:33.554, Speaker A: Flash swap in unisoft b three allows you to borrow tokens as long as you pay the token in the same transaction and with some fees. So in this video, I'll show you a simple example of flash swap. We will start by defining some interfaces. We will borrow tokens, so we'll need an interface for erc 20, and then we also define an interface for unisoft b three pool contract. The functions that we'll call is token zero and token one. To get the address of the tokens and to do a flash swap with the unison b three pool, we'll call the function called flash. This function takes in four parameters.
00:00:33.554 - 00:01:16.222, Speaker A: Recipient this will be the address where the tokens are sent to. Amount zero and amount one are amount of tokens that we want to borrow, and any other data that we want to encode will go under data. We'll call this function flash from our contract called unisoft b three flash swap. And when we do this unisoft b three pool contract, we'll call into a specific function inside this contract. This function that unisoft b three pool will call back into is called unisor b three flash callback. So this contract is going to call the function flash on unison b three pull contract. And inside this code, unison b three pull contract will call into a function called unison b three flash callback.
00:01:16.222 - 00:01:45.450, Speaker A: This is where the tokens are borrowed. We'll execute some custom code, and at the end we'll have to pay the amount that we borrowed plus the fees. So as a function input, it has three parameters, the fees that we'll need to pay for token zero and token one. These fees are calculated by the pool fee times the amount requested. So for example, if the unisop b three pool contract pool fee is 0.5%, then we'll have to pay 0.5% of the amount that we borrowed.
00:01:45.450 - 00:02:19.542, Speaker A: And then this data will be the custom data that we specified. When we call the function flash, the code that we'll need to implement for our contract is in three parts, some initialization code inside the constructor, a function to initiate the flash swap, and the flash callback called by the unison b three pool contract. So let's start with the constructor. First, I'm going to declare some immutable state variables. We'll store unisoft b three pool contract. So I'll type I uniswap b three pool private immutable. I'll name this pool.
00:02:19.542 - 00:02:50.466, Speaker A: And we also store token zero and token one. So say irc 20 private immutable token zero and token one. We'll initialize this inside the constructor. For the input of the constructor we'll pass in the address of the pool. So say address underscore pool. And then inside here we will initialize the pool by saying pool is equal to I unisoft b three pool pass in the address of the pool. Next we'll get the address of token zero and token one.
00:02:50.466 - 00:03:11.878, Speaker A: Say token zero is equal to pool token zero. This will return an address, so you'll cast this into IERc 20. IErc 20. Then we'll do the same for token one. Okay, so that completes the constructor. Next, let's move on to the function flash. This is the function that we'll call to initialize the flash swap.
00:03:11.878 - 00:03:46.534, Speaker A: For the input we'll pass in the amounts of token zero and amount of token one. To borrow Un 256 amount zero and un 256 amount one. And inside here we'll call this function flash. So I'll copy this and then paste it here. So we'll call pool flash, and for the recipient this will be the address that receives the token. We'll send the token to this contract. So say address this and amount of tokens to borrow comes from the input amount zero and amount one.
00:03:46.534 - 00:04:28.894, Speaker A: And lastly data. This is any custom data that we want to pass over to this function. Unified b three flash callback. For the data to pass, we'll create a struct, fill the data inside a struct and then encode it as bytes. So I'll declare a struct called struct flash callback data. And inside here we'll encode amount zero, un 256 amount zero, and un 256 amount one. And the other thing that I'll encode is the address message sender that calls into this function fresh I'll call this caller, and when we fill out this caller, this will be message sender.
00:04:28.894 - 00:05:20.526, Speaker A: Okay, so over here you'll say bytes memory data is equal to abi encode. You'll encode fresh callback data. For amount zero we'll pass in amount zero from input, amount one from input, and for the caller we'll encode message sender. The reason why we're encoding caller over here is so that when unisoft b three pull contract calls this function unisoft b three flash callback. Inside here we'll decode this data and know who called into the function called flash. And the same goes for amount zero and amount one by encoding it here and then decoding it here we know how much amount we borrowed. Okay, so that completes the function flash.
00:05:20.526 - 00:06:01.086, Speaker A: We will call the function flash and then call unisoft b three pull contract to initiate the flash swap. We'll call the function flash. When we call this function unisoft b three pool contract will call back into this function called unison b three flash callback. And inside here, we'll write our custom code and we also have to pay for the amount that we borrow plus the fees. The first thing that we'll do is we'll make sure that only the pool contract can call into this function. Just here say require message sender is equal to address of the pool with the error message not authorized. Next, we'll decode this data.
00:06:01.086 - 00:07:00.420, Speaker A: So here I'll say flash callback data memory decoded is equal to ABI decode, decode the data from input and decode it as flash callback data struct. The next part is that we'll write our custom code here, right? Custom code here. And at the end, we'll have to repay the borrowed amount plus the fees. For this example, we'll keep it simple. And for the custom code, we'll just ask this caller over here to pay for the flash swap fee. So here I'll say if fee zero is greater than zero, then we'll transfer fee zero from the caller over to this contract. Say token zero transfer from decoded caller to address this for the amount fee zero.
00:07:00.420 - 00:07:59.586, Speaker A: Then we'll do the same for fee one, fee one token one transfer from caller to this contract for the amount fee one. So we'll keep this custom code simple, but if you wanted to do an arbitrage, then you would write your custom code inside here. The last part is to repay unisoft b three pool contract. So say if e zero is greater than zero, then token zero transfer to address of the pool for the amount amount will be stored inside this struct. So remember over here that we decoded the amount that we borrowed for token zero and token one. So over here say decoded amount zero plus fee zero, and you'll do something similar for token one. If fee one is greater than zero, transfer token one for the amount decoded.
00:07:59.586 - 00:08:21.286, Speaker A: Amount one plus fee one. Okay, and that completes the contract for our unison b three flash swap. Let's try compiling this contract inside my terminal. I'll type forge build. Okay, our contract compiled. Let's now try running the test. So I created a simple test to do a flash swap from the die wef pool contract.
00:08:21.286 - 00:09:31.822, Speaker A: In this pool, token zero is die and token one is wef we'll borrow 1 million die from the pool contract. So over here I call the function flash for 1 million die and we'll need to pay for the flash swap fee. So for this example, I've used foundry's cheat code to give this user 1 million die and this user has approved the flash swap contract to be able to spend infinite amount of die when this user calls the function flash on the contract unison b three flash swap it's going to initiate a flash swap and then borrow 1 million die from unisoft b three pool contract and this user will pay for the flash swap fee. To execute the test, I'll first initialize a fork URL environment variable and then type forge test forkurl fork URL match path test unisoft b three flash swap test sol and then bbe. Okay, and our test passed. So we borrow 1 million die and the user had to pay this much amount in flash swap fee. Let's check how much this is.
00:09:31.822 - 00:09:44.370, Speaker A: I'll open a python shell, paste the number, and then divide this number by one year 18 and it comes out to be 3000. For borrowing 1 million die, this user had to pay 3000 die.
