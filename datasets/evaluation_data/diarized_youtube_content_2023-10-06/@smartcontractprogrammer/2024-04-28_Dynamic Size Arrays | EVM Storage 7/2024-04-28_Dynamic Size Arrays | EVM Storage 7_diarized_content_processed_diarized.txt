00:00:00.240 - 00:00:49.216, Speaker A: For state variables of type dynamic array, the stored slot where the array element is stored is catch Act 256 of the slot where the state variable array is declared plus the size of the element times the index of element. For example, here I have a state variable of type dynamic array dynamic array of unit 256. The 0th element will be stored at getcheck 256 of the slot where the array is declared. The array is declared in slot zero, so this will be zero plus size of element. Each element is Un 256. Un 256 will use up all of 32 bytes, so it will use up one slot, so this will be one and then times the index of element. The 0th element will be index zero, so this is where the 0th element will be stored.
00:00:49.216 - 00:01:19.068, Speaker A: Okay, how about the first element? Well, the first element we start with catch Act 256 of the slot where the array is declared again catch act to 56 sub zero. Size of element will be one because it will use up one slot and index of element will be one. So this simplifies to one and the second element 33 will be stored in. Again. We start with catch act 256 of zero. This is where this dynamic array is declared in slot zero. To this we add the size of the element.
00:01:19.068 - 00:01:56.274, Speaker A: This will take a one slot times the index of the element two. So this will be equal to catch up to 56 of zero plus two. Okay, let me give you another example. Let's say that we have a Uint 128 dynamic array private, I'll name it r two equals to one, two and three. So we have a dynamic array of type Uint 128 and it stores one, two and three. Let's list out where each element is stored inside the EBM storage slots. So again we start off with ketchup 256, okay, slot where the array is declared.
00:01:56.274 - 00:02:39.296, Speaker A: The slot where this array is declared is slot one. The size of the element is uint one to eight or 16 bytes filling each slot. This means that we can put in two elements. Since one element will only take up 16 bytes, two elements will take up 32 bytes, and that will fill up the slot. So the first element will be dorigan, size of the element will be half of the slot, and then the index of the element will be zero. So the first element will be stored in catch Act 256 of one. Okay, the next element we start off from catch act 256 of one and in this slot we use up 16 bytes and we can still fill up the next 16 bytes which will be occupied by this first element.
00:02:39.296 - 00:03:10.480, Speaker A: So the first element will also be stored in ketchup 256 of one and finally the last element, the second element. We start off with ketchup 256 of one. This slot is occupied by these two elements and this one will be stored in the slot after this one. So this will be one. Another way to think about this is the size of the element. Each element will take up 0.5 slots and the index of this element is two times two.
00:03:10.480 - 00:03:58.694, Speaker A: So this is equal to one. Okay, next let's write some function to actually get these elements using assembly. Let's say function test r. It's going to take in two inputs. U 256 slot this will be the start where the array is declared. For example, for this array it will be zero and for this array it will be one. Then let's also put in another input uint 256 I this I will be the slot to get after we take the ketchup 256 of the slot, we'll return three outputs uint 256 value that is stored in the slot 32 bytes representation of the same value b 32 and then we also return the length of the array uint to 56 min.
00:03:58.694 - 00:04:49.794, Speaker A: We'll first compute the ketchak 256 of the slot bytes 32 start is equal to catch up 256 abi dot encode slot and then we'll use assembly to get the value and the 32 bytes representation and the length of the array. Let's start with the length of the array. The length will be stored in where the dynamic array is declared. For example, for r, the length of this array will be stored in slot zero because this array is declared in. The length of the second dynamic array will be stored in slot one because this array is declared in slot one. So to get the length we do sload and then the slot where this array is declared slot. Next we will get the value that is stored in start plus I.
00:04:49.794 - 00:05:34.604, Speaker A: To get the value we'll need to call slope. The slot we'll need to load will be start plus I add start. I also return the same data in 32 bytes. B 32 equals bell. And the reason why I'm returning the same value in two different data formats, Un 256 and bytes 32, is because when we load 32 bytes from a slot to see how the data is stored for the second array, two reals, it's easier to understand how this data is stored when we look at 32 bytes instead of Un 256. Okay, so let's try calling this function testart. We'll compile the contract, deploy it, and let's call the function testart.
00:05:34.604 - 00:05:53.796, Speaker A: Let's start by getting some elements from the first dynamic array r. The slot where this r is declared is in slot zero. And let's try getting the zero element. Hit call. And, and I get the value is eleven. The length of the array is three. And here is the 32 bytes representation.
00:05:53.796 - 00:06:14.704, Speaker A: Let's try getting the first element, get a 22. The length is still three. And try getting the second element. We get a 33. Okay, next let's try getting the first 32 bytes where two elements one and two are stored. The slot where this two reals is declared will be slot one. And from there we'll get the first slot.
00:06:14.704 - 00:06:51.228, Speaker A: And now I get the length of this array is three. This length will be stored in where the array is declared. This array is declared in slot one, so the length will be stored in slot one. If you look at the 32 bytes representation, we can easily see how the data is packed. It uses up the first 128 bits to store one, and then it uses up the next 128 bits to store the number two. However, if you look at the number, it gives us a large number, and it's difficult to understand that this number is equal to this in 32 bytes. Okay, let's try getting the next slot for I.
00:06:51.228 - 00:07:00.524, Speaker A: I'll put in one and then call, and we get that three is stored in the first 128 bits and then followed by zero for the next 128 bits.
