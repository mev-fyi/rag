00:00:00.730 - 00:00:44.006, Speaker A: You can verify the code for a contract that's been deployed on the blockchain using a block explorer. Here I have a block explorer called etherscanned open. And what you're looking at here is a contract by uniswap. If I scroll down, you can see all of the code that was deployed and you can see here that the contract's been verified. So what this means is that the code code at this address is the code what you're seeing here. And this will allow you to check that the code over here is not doing anything malicious. However, there's a way to hide code so that the code that you see on Etherscan is not the actual code that is executing.
00:00:44.006 - 00:01:25.750, Speaker A: So in this video, I'm going to show you how a smart contract can hide malicious code. Here we have a contract called bar. And anyone can call this function called log, which will emit an event called log with the message bar was called. Next we have a contract called Foo. And when this contract is deployed, it takes in the address of bar. We initialize the bar contract above with the address of bar and then save it to a state variable called bar. So that when anyone calls the function call bar, it will call the log function inside the bar contract.
00:01:25.750 - 00:02:09.938, Speaker A: So when someone calls this function callbar, it should emit event called bar was called. Now, let's say that EB deploys this contract proof and then publishes the code on Etherscan. So the user will see that these two codes are verified. And they would think that when they call the function callbar, it would call this function log inside contract bar. And there's nothing harmful about calling the function log. Now I'm going to show you how to hide code so that when a user calls this function, the code that will be executed is not this function over here. So let's say that e publishes these two code on Etherscan.
00:02:09.938 - 00:02:58.040, Speaker A: How is she going to hide the malicious code that will be executed when a user calls the function callbar? So here's what Eve will do. In a separate file, she'll create a contract with the malicious code. We'll say that the name of the contract is Mao. So imagine that this contract Mao will be in a separate file from the contracts above foo and bar. And inside the contract Mao, she'll put her malicious code. When an innocent user calls the function callbar, the function will call the log function inside bar. But instead of calling the log function inside the bar contract, we want this to call a function inside the malcontract below.
00:02:58.040 - 00:04:03.980, Speaker A: So inside the malcontract we'll copy the function signature of log from contract bar, paste it in here, and our malicious code will go inside here. Now, for simplicity, we'll just log event called malchalled. But if this contract actually had malicious intent, then we'll be writing our malicious code here. And that completes the code for the malicious contract that we're going to be using for this example. Now, how are we going to actually execute this code instead of this code inside the bar contract? So this is what Eve will do. She'll first deploy the malcontract, and then she'll deploy the food contract for the address of the bar. Instead of giving the address of the bar contract above over here, e will put in the address of the malcontract so that when the user calls the call bar function, it will call this function instead of this function.
00:04:03.980 - 00:04:51.446, Speaker A: This is surprising, since if you look at these two code, then it looks like calling this function will call this function. But by deploying this contract with the address of the MAO contract, the code that's going to be actually executing here is this code here. This is possible since solidity calls other contracts using the call method. So what this code is doing here does not promise that the function log inside contract bar will be called. What solidity does instead is try to call the function log at the address bar. So as you can see, there is no guarantee that this code will be executed. All right, so that's the exploit.
00:04:51.446 - 00:05:40.060, Speaker A: Let's now see a demo in remix. So EB is going to deploy first of all the mal contract, and then she's going to deploy the foo contract with the address of Mal. And then let's imagine that e publishes this code on ether scan. So now Alice sees these code on Etherscan, and she can review that there is no malicious code over here. So she's going to decide to call the function call bar. So we're going to switch account to Alice, and then she's going to call the function call bar. Let's now check the transaction logs, and you can see here that it logged mal was called.
00:05:40.060 - 00:06:31.174, Speaker A: In other words, this code was executed instead of this code over here. So that was a demonstration of how to hide malicious code. Let's now talk about how you can protect yourself from a contract that is hiding malicious code. And the one signal that should raise a red flag for you is that a contract is using unverified address. For example, in the case of contract foo, this contract is using an unverified address of bar. So in order for you to fully trust this contract, you'll have to look at the code that is deployed at the address of bar and make sure that it matches the code of contract bar. And if it doesn't then that might mean that there is something fishy going on.
00:06:31.174 - 00:06:46.890, Speaker A: The key takeaway here is that you should never trust an external address, and if a contract is being initialized by an external address us then make sure to verify the code at the address. Thanks for watching and have fun coding.
