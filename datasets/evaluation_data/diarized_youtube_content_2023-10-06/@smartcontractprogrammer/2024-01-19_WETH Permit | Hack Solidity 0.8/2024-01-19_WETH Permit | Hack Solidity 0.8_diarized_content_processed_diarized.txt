00:00:00.570 - 00:00:30.354, Speaker A: If a contract uses permit to pull tokens in, and that contract uses WEF, then that contract may be vulnerable to an attack. Let me explain. Imagine that we have some kind of contract that's going to pull WEF into this contract. Here I have a contract name ERC 20 bank. For simplicity, what this contract does is when a user is called deposit, it will pull in WEF and then credit message sender. For the amount that was sent in. The user will also be able to withdraw.
00:00:30.354 - 00:00:58.634, Speaker A: By calling withdrawal, it would deduct from the balance and then transfer the token over to message sender. These two code deposit and WEF do not have any bug. However, there is a bug inside deposit with permit. What this function does is similar to deposit. When a user calls deposit, they'll first have to approve this contract. To transfer tokens with deposit with permit, this approval is skipped. It is done in a single transaction.
00:00:58.634 - 00:01:37.740, Speaker A: First it calls permit on WEF. This will approve the spender to spend tokens from the owner for the amount if the signatures BRs are valid. Once the approval is given to the spender, the tokens will be transferred from owner to this contract, and then the balance of spender is increased. For most ERC 20 tokens, this is a perfectly fine code. However, when we're handling with WEF, there is a bug. The bug will allow an attacker to steal funds from users who have given approval to this contract. If you wish, pause here and take a moment to see if you can figure out what the hack will be.
00:01:37.740 - 00:02:03.534, Speaker A: Okay, let me explain how the attack is going to work. So you have two users, Alice and the attacker. And let's imagine that Alice is a normal user. She's also a lazy user. So she did an infinite approval on this contract, which means that this contract will be able to pull all of Alice's wef balance into this contract. So she gave infinite approval. However, let's say that she only deposited one Wef.
00:02:03.534 - 00:02:38.126, Speaker A: Now, what can the attacker do to steal Alice's funds? Well, the attacker can call deposit with permit to steal Alice's funds. Let's see how this will work. What happens when the attacker calls deposit with permit for the owner set to Alice Spender will be the address of the attacker. The amount will be the balance of weft that Alice has. Rest of the parameters that are relevant to signatures, we will just ignore for now. So what happens when we call permit on Wef? Here's what the WeF contract looks like. Notice that there is no permit function in here.
00:02:38.126 - 00:03:17.558, Speaker A: So going back to the ERC 20 bank contract. This code over here will rebirth because a simple ERC 20 contract does not support permit. However, let's take a look at the web contract if we call the function permit on the web contract. Although there is no permit function inside here, notice that the web contract has a fallback function. And recall that fallback functions are functions that are called when a function to be executed does not exist. So when token permit is called, the fallback function will be executed. The fallback function will call the function deposit and it will mint to message sender.
00:03:17.558 - 00:03:55.122, Speaker A: Here, message sender will be the ERC 20 bank contract and message value will be zero. So this part of the code will execute without any errors. The fallback will return without any errors. So what we just saw over here is that we were able to call weft permit without any errors and without passing any valid signature. The next step will transfer WEF from Alice to this contract for the amount, the amount of weft that Alice has. In the last step, remember that we set that spender reset this equal to the attacker. So this would credit the attacker for Alice's WEF.
00:03:55.122 - 00:04:29.166, Speaker A: Once the attacker is able to pull WEF into this contract and credit himself for the WEF, he can just simply call withdraw to steal Alice's fund. So that's the attack. Let's write a test for this. So inside ERC bank test, we'll import the two contracts, ref and ERC 20 bank. We'll initialize WEF and bank. Inside the setup function, we'll say that Alice user will be address eleven and the attacker will be set to address twelve. Inside the function setup, we'll deploy ref.
00:04:29.166 - 00:05:03.818, Speaker A: Ref is equal to new ref and the bank contract bank is equal to new ERC 20 bank and then pass in the address of Web. Next we'll simulate Alice's transaction. Let's say that she has 100 Web 100 e, deal to user 100 E 100 times one E 18. And then we'll convert this into web. So we'll prank Alice BM start prank per user. At the end, we'll have to call BM stop prank. So say BM stop prank.
00:05:03.818 - 00:05:36.418, Speaker A: Okay. And inside here, Alice is first going to deposit 100 e and convert it into WEF. WEF deposit value 100 E. Next, she's going to give an infinite approval to the bank contract WEF approve address of the bank for the amount infinite. Type Un 256 max. And then she's only going to deposit one E. Bank deposit one ye 18.
00:05:36.418 - 00:06:02.390, Speaker A: She's going to deposit Weft. Okay, so this is the setup let's now write the exploit to say function test public. The attacker will first get the balance of WEF that Alice has. Un 256 bow is equal to WEF balance of user. User will be Alice. And then let's simulate the transaction that the attacker will send. Bm.
00:06:02.390 - 00:06:30.522, Speaker A: Start prank for attacker. The attacker will call deposit with permit. Bank deposit with permit. Okay, what are the parameters that we need to pass here? I'm going to copy this and then paste it here. Owner will be Alice. So this will be user spender. This will be the address that's going to be credited for the tokens that was sent in.
00:06:30.522 - 00:07:02.574, Speaker A: So this will be attacker, amount will be Alice's balance of WEF. And for the cryptographic inputs it doesn't really matter. So just pass in zero, zero. And for the signatures, empty signatures. So once this part of code executes, the bank contract will pull WEF from malice and then credit to the attacker. All the attacker has to do now is call withdrawal to withdraw the WeF bank withdraw for the amount balance of WEF. BM stop prank.
00:07:02.574 - 00:07:37.182, Speaker A: So this simulates the attacker's transactions. And finally, we'll console log the weft balance of user and the weft balance of attacker. Console two log say weft balance of user Wef balance of user, and weft balance of attacker. Attacker weft balance of attacker. Okay, let's try compiling this contract type forge. Build the contract, compile. Let's now execute the test.
00:07:37.182 - 00:08:02.722, Speaker A: Clear the logs. Forge test BBB. Okay, and the test executed successfully. Let's check the logs. The log says that the Wef balance of user, this will be balance of Alice. She started out with 100 WEf and she now zero. How about the attacker? The attacker started out with zero ref and was able to get 99 ref from Alice.
00:08:02.722 - 00:08:11.090, Speaker A: So in this video I explained how calling permit on WEF does not fail and this allows an attacker to steal users funds.
