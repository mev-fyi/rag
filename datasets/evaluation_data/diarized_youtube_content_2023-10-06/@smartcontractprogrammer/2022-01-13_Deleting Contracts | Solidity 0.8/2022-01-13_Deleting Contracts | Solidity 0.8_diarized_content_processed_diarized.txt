00:00:00.810 - 00:00:46.330, Speaker A: In solidity, there's a function called selfdestruct where when you call it, you can delete the contract from the blockchain. Also, when you call selfdestruct, other than deleting the contract, you'll also be able to send ether to any address. Even if that address is a contract, then it doesn't have a fallback function. So to show you this, I'm going to first show you how to use self destruct. I'll name the contract, kale, and the function to execute self destruct, I'll call it also kill. This function will be external, and we'll call self destruct. Now, self destruct takes in a single input, an address to force all of the ether that is stored in this contract too.
00:00:46.330 - 00:01:42.266, Speaker A: For example, inside here, if we say message sender, and let's also say that there is one ether locked in this contract, then when we call the function kill, it will execute self destruct. This would delete this contract from the blockchain. And since we said that this contract stores one ether, it's going to send that one ether to message sender. Let's also say that message sender is a contract without a fallback function, meaning that we shouldn't be able to send one ether to that contract. But by calling self destruct, we can force that ether to this contract. This is one way self destruct can be used to hack other contracts by forcing ether to the target address. Later on, to show you that we can actually force send ether to another contract without a fallback function, we'll fund this contract with one ether when we deploy this contract.
00:01:42.266 - 00:02:15.000, Speaker A: And to do that, we'll create a payable constructor so that we can send ether to this contract when we deploy the contract. So I'll type constructor payable. And the other thing that I'm going to demonstrate is that once we call self destruct, this contract no longer exists on the blockchain. So if we try to call some functionality, then that should fail. So we'll create a function to call. I'll name it test call, and it will be external. This function will be peer, and we'll return something.
00:02:15.000 - 00:02:47.474, Speaker A: We'll return un and say return. One, two, three. I forgot to mention that the address that you pass in here has to be payable. So we'll cast message sender as payable address by typing payable and wrapping message sender. For the first example, I'll show you that this contract is deleted when we call the function kill. So we'll deploy this contract. Call test call that will return one to three, and then we'll call the function kill.
00:02:47.474 - 00:03:26.318, Speaker A: And after we call the function kill, we'll try to call test call again, and the function call should fail. So let's give it a try. We'll compile the contract and then deploy it. For now, we'll deploy it without sending any ether. And for the next example, I'll show you how to force send ether to another contract. For this example, I want to illustrate that once we call a kill function, calling a function inside this contract will fail because the contract no longer exists. Okay, so we'll deploy the contract, scroll down, and then call, test call, and as expected, it returns one, two, three.
00:03:26.318 - 00:04:16.666, Speaker A: We'll call the function kill. This would delete the contract, and if we call test, call again, it returns zero. For the next example, I'll show you that using self destruct, we can force send ether to any contract and any address. So to do that, first I'll create your contract, and I'll name it helper. For this helper function, we'll create two function, a function to get the balance of either stored in this contract and the function to call kill on the kill contract. So we'll type function, get balance. This will be external view returns un, and we'll return address this balance.
00:04:16.666 - 00:04:59.078, Speaker A: This will return the amount of ether that is stored in this contract. Helper. The next function that we'll create is a function to call kill on the kill contract. So we'll say function. We'll also name this kill, and we'll pass in the address of the kill contract that we deploy. So we'll say the contract type is kill, and the name is underscore kill external, and we'll call underscore kill contract, and call the function kill. We'll deploy these two contracts, kill contract, and then the helper function, and then call the function kill, which will call this self destruct.
00:04:59.078 - 00:05:48.102, Speaker A: Since message sender will be the helper contract, this will force send all of the ether inside the kill contract over to the helper contract. Now, notice that helper contract does not have any fallback function, so we shouldn't be able to receive any ether. But by calling self destruct, this contract will have some ether afterwards, and we'll be able to check that by calling get balance, and we should get a number that is greater than zero. So we'll compile the contract, and then delete the previous contract. We'll deploy the kill contract funding with one ether, and then we'll deploy the helper contract. Scroll down and then open the helper contract. When we call, get balance, we get zero.
00:05:48.102 - 00:06:07.610, Speaker A: As expected, there is zero ether in this contract. We'll copy the address of the kill contract, paste it in here, and then call kill. Next, we'll call the function, get balance, and now it is equal to one ether. By executing self destruct, we were able to force send ether to another contract.
