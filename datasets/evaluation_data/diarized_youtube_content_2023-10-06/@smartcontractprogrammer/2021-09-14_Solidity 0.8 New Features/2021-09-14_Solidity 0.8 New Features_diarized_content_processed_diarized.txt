00:00:00.410 - 00:00:43.722, Speaker A: In this video I'm going to show you some new features of solidity zero Eight. Now this video won't cover everything that's new in Solidity zero Eight. I'll just highlight some, and over the next few weeks I'll cover Solidity zero eight in more details. So in this video I'll talk about Safemath, custom errors, functions outside contract, and a new syntax for import, and a new way to use create two let's get started. The first topic is safe math before solidity zero eight numbers overflowed and underflowed without any errors. This means that when a number goes out of range, then it wraps around. So if it goes below the minimum number, then it wraps around to the maximum number.
00:00:43.722 - 00:01:24.642, Speaker A: And if it goes over the maximum number, then it overflows to become the minimum number. Here we have an example of an underflow. We start with un x and then subtract one from x. This will cause an underflow and before solidity zero eight this will return a maximum for un. However, starting with solidity zero eight, this will cause an error. Now this isn't a recommended practice, but if you want your numbers to overflow and underflow without any errors, then you can wrap this operation in unchecked. To show you that safemap is enabled by default on solidity zero eight, I'm going to call this function and this will throw an error.
00:01:24.642 - 00:02:07.794, Speaker A: The function name is called test on the flow, and when I click this function, you can see here that the function failed. However, for this example, I've disabled on the flow by wrapping the operation in unchecked. So when I call this function test unchecked on the flow, then this function will not throw an error and it will return a number. So I'm going to click this function and notice that we started with zero and it gave us back a really big number. So that's safe math in solidity zero eight. The next cool feature about solidity zero eight is called custom error. What this means is that you'll be able to define a custom error and then use it with the revert function.
00:02:07.794 - 00:02:59.234, Speaker A: And now why would you want to do that instead of using the string for the error message? Well, let me show you why the custom error is a better option than to return a string for the error message. When we use a string as an error, the amount of gas that this error is going to use depends on the length of the string. For example, if I call this function and when the function fails, it used up 23 642 gas. However, if the error message is bigger, then it's going to use up more gas. And to show you this, I made the error message longer than it was before, and then when I call the function withdraw again, it used up 23,678 gas. So you can see that the longer the error message is, the more gas it's going to consume. However, by using custom errors, we can reduce the amount of gas.
00:02:59.234 - 00:04:03.814, Speaker A: So here I've created a custom error called unauthorized, and to use this custom error inside rebirth, what we'll have to do is replace this message with the custom error, and that is it. Now, when I call the function withdraw and the function fail, the amount of gas it used was 23,388 gas, which is slightly cheaper than using the string as an error message. Now, similar to events, we can log some parameters with this custom error. For example, if I wanted to log the message sender with this error, then I'll say address caller, and then inside the error message I'll put in message sender, I call the function withdraw and the function failed. You can see here that the error that was thrown is called unauthorized. The parameter it logged was caller and the address of the caller is over here. So that is how you can log some parameters with the custom error.
00:04:03.814 - 00:04:43.842, Speaker A: The syntax is very similar to events. Now, this custom error doesn't have to be declared inside the contract. Actually, it can be declared outside of a contract like this, and this contract will still compile. Now, why would you want to declare a custom error outside of the contract? Well, by declaring it outside of the contract now you can import it in other contract as well. I'll show you an example of this when we talk about imports later on. Similar to how we declare custom errors outside of the contract, we can also declare functions outside of the contract. There are restrictions to the function that you can declare outside of a contract.
00:04:43.842 - 00:05:33.510, Speaker A: For example, it doesn't make sense to have any state variables inside of function that is declared outside of a contract. So if you have a state variable inside a contract, and the function declared outside of the contract tries to use the state variable, then it doesn't make sense. So this will not compile, and for the same reason it doesn't make sense to reference the contract inside the function over here. For example, if I try to use address this inside this function over here, then it will not compile. So we've seen that in solidity zero eight we can declare custom errors and functions outside of the contract. Why would you want to do this? Well, this is because then you can import it inside other contracts. Here we have a custom error that is declared outside of a contract and a function that is declared outside of the contract.
00:05:33.510 - 00:06:19.974, Speaker A: Now, in another contract I can import the unauthorized custom error and the helper function by using a syntax like this. So we say import, and then inside the curly braces we import the custom error and the function that we want to import, and you'll be able to use these custom error and functions inside the contract here. Now let's say that I have a function also named helper with the same function signature. I'm trying to import a helper function, and I've also declared the same function over here. If I try to compile this, it will throw error. Here we can avs this function, in other words, rename this function so that there will be no name conflicts. And to do that we can rename the helper function.
00:06:19.974 - 00:07:06.430, Speaker A: As for this example, I'll just say h one, and when I compile it, the error goes away. The last topic that I'll talk about is create two. Now, before solidity zero eight, the only way to do this was to use assembly. The code looks a little bit overwhelming, but in solidity zero eight we can do the exact same thing with less effort. The new syntax is we start out with new followed by the name of the contract that we want to deploy. For this example, we're going to deploy this contract name D, which is defined over here. Now, to deploy this contract using create two, we'll need to specify a salt and then pass in the salt and then pass in any arguments to the constructor of the contract.
00:07:06.430 - 00:08:16.754, Speaker A: To show you the new syntax for create two, I've deployed a contract over here on the left. The first thing that we'll do is compute the salt. For this example, we'll feed in a random number which turns that number into bytes 32. For this example, I'll pass in one through three and get the number in bytes 32 to get the address of the contract that is going to be deployed, I'm going to copy this salt and then call this function get address passing in the salt, and the constructor argument we'll pass in later will be seven seven seven, going to hit get address when we deploy the contract by calling create D salted, the address that you see over here, and this address should match. Okay, so let's now deploy the contract and compare the addresses that will be deployed and the one that we computed. So I'm going to copy all of the arguments inside here, passing here, and then deploy the contract. Once the contract is deployed, I'm going to check the deployed address by clicking on this function, and you can see here that these two addresses are equal.
00:08:16.754 - 00:08:30.060, Speaker A: So that is a new syntax for create to a available in solidity zero eight. Over the next few weeks, I'll be creating videos about solidity zero eight, so stay tuned. Thanks for watching and see you later.
