00:00:00.170 - 00:00:25.026, Speaker A: Today we'll go over the example of decreasing liquidity in unison B three. And we'll be following the code from the official documentation. So inside the documentation, I'll scroll down and then copy this code inside the code editor. We've been using the contract called liquidity examples. So I'll paste the code inside this contract. I'll scroll down and then paste the code. Next I'll remove some of the comments.
00:00:25.026 - 00:00:53.578, Speaker A: You okay? For our example, we will be decreasing all of the liquidity. So I'll rename this function to decrease liquidity token id. We're storing it in a state variable so we don't need to feed it as input. Instead, for the input we'll feed in liquidity. This will specify the amount of liquidity we're going to decrease by. We're not going to need the output amount zero and amount one. This is the actual amount of tokens that were decreased.
00:00:53.578 - 00:01:36.346, Speaker A: However, we'll just keep it as is. Okay, we'll scroll down and we're not going to need these. Okay. The thing that we need to do to decrease liquidity in unison B three is to prepare a parameter, prepare a struct called decreased liquidity params and then call the function decreased liquidity for token id. We stored it in a state variable, so we'll just leave it as is liquidity. We'll pass it from the input amount zero min, the minimum amount of token zero that we will be able to withdraw after calling decreased liquidity amount one min, the minimum amount of token one that we can withdraw after we call the function decreased liquidity. For this example, we'll keep it simple and set it to zero.
00:01:36.346 - 00:02:16.934, Speaker A: Now in production, you would probably not want to set this to zero and deadline the deadline of this transaction. We'll set it to block timestamp and then we call the function decreased liquidity on the nonfungible position manager. And this will return amount zero and amount one. These are the amount of tokens that we can withdraw. Notice here that I set the amount of tokens that we can withdraw when we call the function decreased liquidity. It doesn't actually transfer the tokens back to this contract. To actually withdraw the tokens from unison b three after you call the function decreased liquidity, we'll have to call the function collect on unison b three.
00:02:16.934 - 00:03:06.200, Speaker A: So after you call decrease liquidity, we'll call the function collect all fees and this will call collect. And this will actually withdraw the tokens from unison Bt. I'll show you this later in the test. Anyways, scrolling back down to our code we're not going to need send to owner. So I'll remove this and then for this example I'll just console log amount zero and amount one. Console log amount zero, amount zero and likewise for amount one. Console log amount one, amount one now before we call this function decreased liquidity, how do we know how much liquidity we can withdraw? To answer this question I'll scroll up and there is a function where we can get the liquidity from the token id.
00:03:06.200 - 00:04:19.610, Speaker A: So inside the function, the internal function create deposit. You can see here that we can get the liquidity by calling nonfungible positionmanager position passing in the token id. So I'll copy this code and then we'll create a new function. Scrolling down we'll create a new function called function get liquidity and for the input we'll pass in the token id. Un underscore token id since we already have a state variable as well. This will be external view returns un one to eight we're returning un one to eight because liquidity is represented as un one to eight and then we'll paste the code that we copied and then we're not going to need this whilst not going to need the address token one here, we're only going to need liquidity, then return liquidity. Okay, that completes the function get liquidity and we're now ready to call the function decrease liquidity first let's try compiling this contract.
00:04:19.610 - 00:05:30.040, Speaker A: Open my terminal and then compile the contract by typing mpx hard hat compile okay, the contract failed to compile, so let me go fix this error here. Liquidity has to be unit one to eight. So I'll change un 256 to one two eight, save it, and we'll try compiling again and our contract compiled successfully. The next step is to write the test to execute the function decrease liquidity so inside the test folder we'll continue working on liquidity test js open it and to get ourselves started, first I'll copy this code and then scroll down and then paste it. I'll remove the dot skip and I'll name this test to decrease liquidity. So what we're going to do here is get the token id, get the liquidity, and then call the function decrease liquidity passing in the liquidity so we first get the token id. Next we'll need to get the liquidity by calling const.
00:05:30.040 - 00:06:10.382, Speaker A: Liquidity is equal to await liquidity. Examples get liquidity mempassing in the token id. So once we have liquidity next we can call the function liquidity example decrease liquidity. And here we pass in the liquidity that we just got from above. Liquidity. Now, earlier I said that when we call this function decrease liquidity, it doesn't actually transfer the tokens. And to show you this, I'll console log the balance of die in USDC.
00:06:10.382 - 00:06:53.694, Speaker A: I'll put some logs so that we'll be able to easily identify what we're logging. Console log decrease liquidity and then we'll actually log the balance of die in USDC. Console log. Here, I'll use string interpolation. Say die, dollar sign, curly braces await die balance of liquidity examples address and we'll do the same for USDC. USDcawae USDC balance of liquidity examples address okay, that completes the test for calling decreased liquidity. When this test runs, the balance of die in USDC should be zero.
00:06:53.694 - 00:07:39.120, Speaker A: Now, to actually withdraw the tokens, we said that we'll need to call collect on Unisa B three. And one way we can do it is by calling collect all of these. So what I'll do is I'll take this code and then paste it after calling decreased liquidity, and then remove the skip. So what's going to happen when we execute the test is it's going to execute decreased liquidity and afterwards this test will run to collect all fees. After calling collect all fees, let's log the actual amount of die and USDC in the contract. So this will be collect fees and then get the balance of die and USDC. Before we run the test.
00:07:39.120 - 00:08:16.540, Speaker A: Let's not run this test for increased liquidity current range. So I'll put it skip, and we're now ready to run the test. So I'll open my terminal, clear the logs, and then we'll run the test by typing MpX hard hat test. The name of the test is test liquidity test JS. I'm getting the error. Get liquidity is not a function. So let me go fix that inside my contract, fix the misspelling, get liquidity, and then I'll run the test again.
00:08:16.540 - 00:08:51.940, Speaker A: Okay, our test passed. Let's take a look at the logs. First, the test for decreased liquidity passed. And let's take a look at the log for decreased liquidity. Notice that after we call the function decreased liquidity, the balance of die inside the contract and the balance of USDC is still equal to zero. However, after we call decreased liquidity, and then we call collect all fees, then our balance of die and USDC changed. This was an example of how to call decreased liquidity and then actually withdraw the token by calling collect on unison b three.
