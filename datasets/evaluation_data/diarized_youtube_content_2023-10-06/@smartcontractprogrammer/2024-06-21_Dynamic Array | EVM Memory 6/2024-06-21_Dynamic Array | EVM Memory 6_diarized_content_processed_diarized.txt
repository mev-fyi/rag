00:00:00.240 - 00:00:35.858, Speaker A: In this video I'll explain how a dynamic array is stored in EBM memory. I'll give you two examples. For the first example, we'll initialize a dynamic array in memory and then use assembly to get the pointer for this dynamic array, the length of this dynamic array, and we'll also fetch three elements from this dynamic array. And for the second example, we'll initialize a dynamic array and then use assembly to store some elements. Let's start with the first example. Test read let's say that we have a dynamic Un 256 array with five elements, 1122, 33, 44 and 55. We'll use assembly to get the pointer for this array.
00:00:35.858 - 00:01:10.958, Speaker A: This pointer will tell us where this dynamic array starts in memory. We also get the length of this dynamic array and we also get three elements from this dynamic array. So to start off with I'll write assembly and then to get the pointer for where this dynamic array is initialized, all we have to do is say p is equal to r. R refers to this dynamic array. And for dynamic arrays, data is not passed as values, they're passed as reference. So we can just assign to p the reference of this dynamic array. This will tell us where this dynamic array starts in memory.
00:01:10.958 - 00:01:45.206, Speaker A: In this example, you'll see later that this dynamic array points to the memory address zero x 80. Next we'll get the length of this dynamic array. The length of the dynamic array is stored at the pointer of this dynamic array. So this will be, let's call this len is equal to m load. The pointer of array is stored in r. For this example, the pointer r points to memory location zero x 80. So what we're doing here is loading 32 bytes from zero x 80 and this will store the length of this dynamic array.
00:01:45.206 - 00:02:22.816, Speaker A: Okay, next let's get three elements. A zero is equal to. The first element will be stored 32 bytes after this pointer r. So we can write this as m load add two r zero x 20. The next element will be stored 32 bytes after this one. So this will be a one is equal to m load add to r zero x 40, skip 64 bytes starting from the pointer r and the last element, a two, will be skipping another 32 bytes. 64 32 is 96 bytes m load add.
00:02:22.816 - 00:02:51.864, Speaker A: The starting position is stored in r and from here we skip 96 bytes. This will be zero x 60. Okay, so this is an example of how to read dynamic array elements using assembly. Next, let's use assembly to write elements inside the dynamic array. First, I'll start by initializing a dynamic array in memory uint 256 memory r. And first we'll get the pointer of this r assembly. Again, the pointer will tell us where the dynamic array starts.
00:02:51.864 - 00:03:23.694, Speaker A: In memory. P is equal to r. Now you can play around later, but when we initialize the dynamic array like this, this pointer will be at zero x 60. However, if we were to initialize it like this, then this pointer will point to zero x 80. Currently this points to the pointer points to zero x 60. And if you were to initialize it, new uint 256 dynamic array of size zero. And now this pointer will point to zero x 80.
00:03:23.694 - 00:03:51.140, Speaker A: Remember in the previous example that at the pointer of this array the length of the dynamic array is stored. So let's store the length of this dynamic array. We'll store three elements into this dynamic array so the length will be three. M store at our three. Notice that we initialize this dynamic array to have length zero, but using assembly we can change the length to three. Okay, and let's actually store three elements. M store the first element.
00:03:51.140 - 00:04:15.400, Speaker A: We can store it at 32 bytes after this pointer. For r, add to r zero x 20 and then let's store the value eleven. Okay, let's store another element. M store add to r. This will be the element at index one or the second element. For the element at index zero, we skip 32 bytes. For the element at index one we'll need to skip another 32 bytes.
00:04:15.400 - 00:04:48.672, Speaker A: So this will be zero x 40 or 64 bytes. Let's store the value 22. Okay, and for the last element that's storm store add to our again, we'll need to skip another 32 bytes. The last one was 64 bytes, so the next one will be 96 bytes zero x 60. Let's store the value 33 and then we'll return this array. So here I'll type return r and I also need to return the pointer. So here I'll say P and R, but we're not done yet.
00:04:48.672 - 00:05:32.734, Speaker A: If we were to deploy this contract and then execute test right, you'll notice that the array does not return 1122 and 33. This is because we still have not updated the free memory pointer. If we forget to update the free memory pointer, when this part of the code is executed, solidity will ABI encode this dynamic array. And when it ABI encodes this dynamic array, it will access the free memory pointer and do some stuff with the memory. So if we forget to update the free memory pointer here, solidity will abi encode the wrong region of the memory. So that is why we need to update the free memory pointer at this point. We used up 32 bytes to store the length of this dynamic array and an additional 96 bytes to store three elements.
00:05:32.734 - 00:06:18.154, Speaker A: 32 96 is 128 bytes, so we used up 128 bytes of the memory. We need to tell the free memory pointer that the free memory starts 32 bytes after over here. So let's say mstore. The free memory pointer is always stored at zero x and update it to add to zero x 80. Okay? And that completes the example for test, right? Let's now call the function test read and test write. I'll hit ctrl s to compile the contract, and then we'll deploy this contract and then call a function test read and we get the values. The length of this array is five, and the three elements are 1123 and 33.
00:06:18.154 - 00:06:34.794, Speaker A: We also store the pointer for the array and it points to the memory location zero x 80. Next, let's call the function test rate. We store the elements 1122 and 33, and that is exactly what we get back. Also, the pointer for the array points to zero x 80.
