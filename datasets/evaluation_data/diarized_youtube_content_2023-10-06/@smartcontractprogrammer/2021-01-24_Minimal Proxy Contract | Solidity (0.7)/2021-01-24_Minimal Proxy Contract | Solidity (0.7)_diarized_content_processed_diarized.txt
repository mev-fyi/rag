00:00:00.730 - 00:00:40.246, Speaker A: Let's review how the createforther two function in biper works. Here Alice has a contract that she wants to deploy multiple times using Createforder two. She will first deploy this contract. Next, she'll deploy the bipart contract that is going to call the function create forwarder two. Now, to create multiple copies of the clone me contract, she will call the createforder two function pass in the add address of the clone me contract. This will create a cheap copy of the original contract, and Alice can do this multiple times. Now, when Alice calls a function inside the clone contract, this will execute the code inside the original contract.
00:00:40.246 - 00:01:31.242, Speaker A: That is how the create forwarder two deploys new contracts and how the copied contracts execute their code. That leaves us with several questions. Why is it cheap to deploy a contract? Why was the constructor not called when we used create forwarder two? And why is the original contract not affected when the copied contract executes its code? The answer to the first question is because it uses delegate call. The answer to the second question is because it uses delegate call. And the answer to the third question is because it uses delegate call. So in this video, I'm going to unpack how delegate call is used to implement minimal proxy contract, also known as create forwarder to in Byper. First of all, what is delegate call? Let's take a minute to review how delegate call works here.
00:01:31.242 - 00:02:30.310, Speaker A: Contract A will delegate call to contract B. What this means is that when Alice calls a function inside contract A, contract A will delegate call to contract B, execute code inside contract B, and instead of updating stuff inside contract b, it updates the stuff inside contract a. For example, it might update the state variable inside contract A, even though the code that was executed lives inside contract B. And this is exactly how the contracts deployed using create four or two works. They use delegate call to execute code inside the original contract, and then make any updates inside the copied contract. This answers our question, why is the original contract not affected? The answer is because it uses delegate call, and because it uses delegate call, the copied contract does not have to have any code inside. So there is very little code inside the contracts that were cloned.
00:02:30.310 - 00:03:35.182, Speaker A: And this answers our other question, why is it cheap to deploy clones? And the answer is because there's minimal code inside the clones. All right, now I'm going to answer that third question. Why is the constructor not called when we use create folder two to create new contracts? Recall from the viper videos that after we called create folder two, we had to manually set up some parameters inside the new contract. By calling the function setup we declared this setup function inside the clone me contract, and this function will be different for different contracts. The answer is because it deploys a simple contract that forwards all calls using delegate call. So create forwarder two inside viper will deploy a contract like this. It would store the address of the master copy, and the only function inside this contract is forward, which will forward all the function calls using delegate call, and if the function is successful then it will return the output as bytes.
00:03:35.182 - 00:04:24.640, Speaker A: Notice that nowhere in this code is the constructor called on the master copy contract. To summarize, when we create a contract using createforder two, it deploys a contract where the only functionality inside the contract is to delegate all calls. The actual code for the minimal proxy contract looks like this, which looks totally different from this contract above. To understand how this is similar to this contract above, we first need to understand bytecode. Here is a simple contract and it's very easy for us to understand. We can easily read what the code does. However, if I were to give this code directly to the EBM, the Ethereum virtual machine, it would not understand what the code is supposed to do.
00:04:24.640 - 00:04:54.666, Speaker A: In order to create a code that the EBM can easily understand, we first need to compile it. This is called the bytecode. We give this bytecode to EBM and now EBM understands what the contract is supposed to do. This is the actual bytecode for the minimal proxy contract. There are three parts to this bytecode. The part in orange and pink says to delegate call to this address. The blue part tells the EBM to return the bytecode in white.
00:04:54.666 - 00:05:33.400, Speaker A: But why do we have to return the bytecode in white? To understand this, we first need to talk about creation and runtime code. The creation code is the part that calls the constructor initial setups and then it returns the part in orange. But for the minimal proxy contract it does not call any constructor. There is no initial setup. The runtime code is the actual code that is taped to the blockchain. So when we call functions on a smart contract, this orange part is the part that is being executed. For the minimal proxy contract, the actual code that is being executed is to delegate call to this pink address.
00:05:33.400 - 00:06:14.530, Speaker A: When we deploy this contract, we'll need to replace this pink address with the actual address of the master copy. So now let's see how to do this. In solidity. The part in blue and orange will not change. However, we need to write solidity code to replace the address in pink. Here inside remix I have a contract named minimal proxy, and it has a function called clone which takes in the address of the master copy, and it will programmatically replace the address of the minimal proxy contract. So you'll be writing code to replace this address with the address of the target.
00:06:14.530 - 00:07:02.542, Speaker A: The first thing that needs to be done is to convert the address of target to 20 bytes. The next thing that we need to do is create this code and load it into memory. So the first thing that we need to do is get a memory address where we could store this code. And we do that by calling m load at zero x 41st of all. M load is a function available inside assembly, and what it does is it would read the next 32 bytes stored at the memory address inside here. So here we're saying read the next 32 bytes from memory at the memory slot at zero X 40 in solidity. This is a special slot.
00:07:02.542 - 00:07:51.460, Speaker A: It contains the free memory pointer. Basically it gives us a pointer where we can load our code into memory. So this will give us back a pointer to where we can load the rest of our code. On the next line, we use mstore to store the next 32 bytes to memory, starting at the memory location stored in the variable clone. And the code that we're going to be storing starting here is this. This is the first part of the minimal proxy contract that we see over here on the next line, we call mstore again to store the address of the master copy. Now, because the first part of the minimal proxy contract takes up 20 bytes, we'll need to move the pointer by 20.
00:07:51.460 - 00:08:53.766, Speaker A: And this is how it's done from the start where the code is stored, we add 20 bytes and zero X twelve is 20 in hex. Basically we're moving the pointer by 20 and then storing the address of the master copy using mstore. After this line of code, we will have stored something like this inside the memory. The first part of the minimal proxy contract code followed by the address of the master copy. And to store the rest of the minimal proxy contract code we will need to move the pointer by 20 bytes again. So we do that over here we say add to the start of the pointer, 400 x 28 is 40 in hex, and here we add 40 because we have 20 bytes from the first part and then followed by another 20 bytes from the second part. So in total we will need to move the pointer by 40.
00:08:53.766 - 00:09:33.422, Speaker A: After we move the pointer by 40, we load the rest of the code of the minimal proxy contract. So after all of this, we will have something like this inside the memory. So I'm going to zoom out a little bit. And that is the minimal proxy contract code. In total, the code is 55 bytes, and at this moment the code is loaded onto memory. We need to deploy this contract by calling the function create sending zero ethers. The code starts at the pointer stored in the variable clone, and the size of the code is 55 bytes, or zero x 37.
00:09:33.422 - 00:09:58.900, Speaker A: In hex, the function create returns the address of the contract that was deployed, and we return that for the function output of the function clone. That is how the minimal proxy contract is implemented. If you want to understand what each of these bytecode is doing, I'll put a link in the description below explaining how each of these bytecode work. Thanks for watching.
