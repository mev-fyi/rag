00:00:00.490 - 00:00:38.838, Speaker A: In the previous video, I showed you the math for how to calculate twap time weighted average price. In this video, I'll show you how to actually calculate it in Uniswap B two using solidity. Here, I've already created a hard hat project and installed some packages. Notice that for this contract, we're using solidity 0.6.6. This is because the two uniswap MPM packages that we're going to need is targeted for solidity 0.6.6. So that is why we're going to be using the older version of solidity to write this contract. The first thing that we'll need to do is import some solidity contracts from the Uniswap NPM library.
00:00:38.838 - 00:01:21.042, Speaker A: I'll name this contract contract Uniswap B two t WaP in Uniswap B two, the numbers are represented in decimals, but splitity does not have any decimal data types, so they've created their own called fixed point. So to use decimals in this contract, we'll have to declare using fixed .4 star. Next, we'll define the minimum time that we need to wait before we can update the tWap. I'll call this uint public constant. All caps period is equal to ten. This means that we'll have to wait a minimum of 10 seconds before we can update the twap.
00:01:21.042 - 00:02:03.486, Speaker A: Now, if you're writing a twap in the main net, this will usually be something like 30 minutes, 1 hour or more. But for this example, I don't want to wait too long, so I'll just make it 10 seconds. The pair contract is a contract that holds the two tokens and does the swaps. So you'll say I uniswap b two pair. I'll make this variable public immutable since it does not have to change, and I'll name it pair. We also store the two tokens by saying address public immutable token zero, and likewise address public immutable token one. To calculate the tWap, we need to store a variable called price cumulative.
00:02:03.486 - 00:03:29.386, Speaker A: So I'll type un public price zero cumulative last and likewise for price one, cumulative last and we'll store the timestamp of when these two price cumulatives were last updated by typing Uint 32 public block timestamp best. Next, we'll store the TBop for token zero and token one. So I'll type fixed point UQ one one two times one one two this variable will be public and I'll name it price zero average and likewise for price one average this data type fixed point UQ one one two times one one two is not a data type that is available in solidity. It is a data type that is defined by uniswap B two and we've imported over here what this data type does is it represents a decimal number. The range for this decimal number is from zero to two to the 112 minus one, and the resolution is one over two to the 112. So this data type, the first 112 bits represents the decimal part, and the next 112 bits represents the whole number part. Next, we'll write the constructor and initialize some of these variables.
00:03:29.386 - 00:03:55.238, Speaker A: So I'll type constructor for the input we need to pass in the address of the pair. So I'll type I uniswap B two pair. I'll name it underscore pair and this constructor is public. Notice that since we're using solidity 0.6, we need to declare the constructor as public. If you're using solidity 0.8, then you don't have to declare the constructor as public.
00:03:55.238 - 00:04:43.566, Speaker A: And then we assign the pair from the input to the pair of the state variable pair. If you're confused by this syntax over here, then this code is the same as passing in an address and then passing in the address to the interface. The top code over here is shorter, so this is the code that we'll be using. We also set token zero and token one by typing. Token zero is equal to pair token zero and likewise for token one. We also record price zero and price one cumulative last and the last time that these variables were updated. Block timestamp last so I'll type price zero, cumulative last is equal to pair price zero, cumulative last.
00:04:43.566 - 00:05:32.226, Speaker A: Likewise for price one cumulative last. Get it from pair price one cumulative last, and then we'll update the block timestamp by calling pair getreserves. Getreserves returns three outputs, reserve zero, reserve run, and block timestamp last. We only need the third output, so we'll ignore the first two output and assign the last output to block timestamp last, and that completes the constructor. For this contract we'll write two functions function called update. This will update the price zero average and price one average and the function consult for the input a user will pass in the token either token zero or token one and amount in. This will calculate the amount out using either price zero average or price one average.
00:05:32.226 - 00:06:44.906, Speaker A: Let's write the function update first. When the function update is called, we'll first get the current price zero cumulative, and price one cumulative. So we'll type un price zero cumulative, un price one cumulative, and un 32 block timestamp is equal to uniswap b two oracle library current cumulative prices and we'll need to pass in the address of the pair. So we'll say address pair. Notice that since we define the pair as an interface here, we'll need to cast this pair as address once we get the current price zero cumulative and price one cumulative and the last time that this pair contract was updated, which is stored in block timestamp. Next, we'll calculate how much time has elapsed since the last time we called update and this block timestamp. So we'll say un time elapsed is equal to block timestamp minus block timestamp last, which is the state variable that we define.
00:06:44.906 - 00:08:11.142, Speaker A: We'll require that the time elapsed is greater than the minimum duration before we can call update, and this is stored in period. So here we'll say require time elapsed is greater than or equal to period with the error message time elapsed is less than min period. Next, we'll calculate the price averages by taking the current price cumulative, subtracting it from the last price cumulative, and dividing it over the time elapsed. So we'll type price zero average is equal to price zero cumulative minus price zero cumulative last divided by time elapsed. Now, since price zero average is a fixed point, we'll need to cast this into a fixed point. So you'll type fixed point dot UQ one one two x one one two parentheses this UQ one one two x one one two is actually a struct, and the input for the struct must be a un two two four. So we'll cast this expression as un two two four by typing un two two four wrap this whole expression and that completes price zero average.
00:08:11.142 - 00:09:02.614, Speaker A: Notice that this expression over here, the current price zero cumulative minus the previous price yo cumulative divided by the time elapsed is the exact same equation that we derived for how to calculate twap in the previous video. We'll do the same thing to calculate price one average. So we'll type price one average is equal to fixed point UQ one one two price one cumulative minus price one cumulative last divided by time elapsed. Notice that for this expression over here, we're subtracting two numbers, but in solidity zero six, there is a possibility for overflow and underflow. This is a desired behavior. We do not care if the numbers overflow let's say that we have two numbers, the previous price cumulative and the current price cumulative A and b. When we do a subtraction, we get this distance.
00:09:02.614 - 00:09:44.754, Speaker A: For this example, the distance between b and a is five of these dashes. Now imagine a case where the current price cumulative overflows so that the previous price cumulative is greater than the current price cumulative. However, when we subtract b from a, notice that the distance is still preserved. Before we said the distance was five of these dashes. Even after the number b overflows, the distance between b and a still remains the same, five dashes. So this is why we're not using safemap over here to subtract these two numbers. Once we get the two price averages, we'll finally update these state variables.
00:09:44.754 - 00:11:12.946, Speaker A: So I'll scroll down and then type price zero cumulative vast is equal to the current price zero cumulative. So that will be price zero cumulative and likewise for price one cumulative last and lastly, we'll update block timestamp. Last is equal to block timestamp from uniswap, and that completes the function. For update, call this function once, wait for a minimum of period, call it again, and you'll be able to compute the two time weighted average prices. Let's now write the function for consult given a token, either token zero or token one, and the amount of token put in this function will calculate the amount out using the price zero average and price one average. So the first thing that we'll do is require that the token from the input is either token zero or token one. By typing require token is equal to token zero or token is equal to token one with the error message invalid token if token is equal to token zero, then amount out is equal to price zero average the average price of token zero multiplied by amount in.
00:11:12.946 - 00:12:08.342, Speaker A: And since price zero average is not a unit, it is a custom data type called UQ one one two times one one two. We'll have to put it back into un and we can do that by using a function called decode one four four. We'll do something similar if token is equal to token one, so we'll type else amount out is equal to price one average multiplied by amount in decode one four four. In this case, the amount out is the amount of token one that you'll get for putting in amount in of token zero that completes this contract. Let me try compiling it and fix any errors. I'll open my terminal and try to compile the contract by typing MpX hard hat compile and I get some error. The first error is time elapsed which I've misspelled it over here.
00:12:08.342 - 00:12:42.874, Speaker A: So I'll fix that and try to compile the contract again and the contract compiled successfully. I've deployed the twap contract onto the Robson testnet. Let's try calling some function. So I'll scroll down and then we'll call consult for the token we'll pass in token one. So I'll copy this address, paste it here and then for amount ten I'll paste in ten to the 18 and that is the average price. For token zero. We can observe a change in the price average by doing a swap and then calling the function update twice.
00:12:42.874 - 00:13:21.248, Speaker A: We'll do a trade on the Unisoft V two router on the Robson test network. We will trade one token zero for any amount of token one. Once the trade is successful this would have some effect on the prices of the two tokens. So we'll call update on the TWAP contract. We'll call the function update once to update price zero and price one cumulative last. After the first update I'll call update again. Price Zero and price one cumulative last will reflect the prices from about five minutes ago and then I called update now.
00:13:21.248 - 00:13:39.420, Speaker A: Now. So when we get the price averages it should be close to the current price. The second call to update was successful so let's now call the function console again. Hopefully we'll see some change in the price average. So I'll hit query and you can see that the price average changed.
