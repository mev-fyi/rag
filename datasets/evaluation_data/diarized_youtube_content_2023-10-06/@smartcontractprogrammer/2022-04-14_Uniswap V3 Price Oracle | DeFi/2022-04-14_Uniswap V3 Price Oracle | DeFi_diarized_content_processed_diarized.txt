00:00:00.250 - 00:00:37.602, Speaker A: In this video I'll show you how to build a simple price oracle using prices from unisop B three. For this example, we're gonna need some contracts from Unisop B three core and Unisop B three periphery. The contracts that we're gonna need are I, Unisoft B three factory, and Oracle library. These can be imported by installing these packages in package JSON. So if I open my package Json, you can see them over here. Also notice that for this example we're going to be using solidity 0.7.6. This is because the contracts we import from Uniswap also uses this solidity version.
00:00:37.602 - 00:01:12.350, Speaker A: So we're going to be using 0.7.6. And make sure that you also configure this in your hard hat config. So inside hard hat config you can set the splitty version to 0.7.6. Okay, let's get started. We'll set some addresses for the contracts that we need to call on UnisoP inside the constructor, and to get the price of the token we'll call the function estimate amount out. This function will take in token in, amount in, and the duration of the twap, and it will return the amount out. Let's start off by declaring some variables that we'll store in this contract.
00:01:12.350 - 00:02:05.326, Speaker A: We'll store the address of the tokens and the address of the pool. So we'll say address public immutable token zero and likewise for token one. And we'll also store the address of the pool contract address public immutable pool inside the constructor. We'll first initialize token zero and token one, so we'll pass that as an input to the constructor. Address token zero and address token one. And then inside the constructor, I'll say initialize token zero to token zero from the input, and likewise for token one, initialize token one to token one from the input. Next we will get the address of the pool by calling the Unisoft B three factory contract.
00:02:05.326 - 00:03:12.618, Speaker A: And to get the address of the pool we need to pass in three parameters the address of the tokens, so token zero and token one, and also the fee. So inside here we'll say address of the factory and un 24 c. Next we will get the address of the pool by saying address of the pool is equal to I uniswap b three factory at the address of the factory that we passed in from the constructor dot get pool and the pool is determined by three parameters. The address of the two tokens token zero, token one, and the fee. We will check that this pool is a valid pool by requiring that it is not equal to address zero. So we'll type require pool not equal to address zero with the error message pool doesn't exist. And once we know that this pool is a valid pool, then we'll set this pool to the pool over here.
00:03:12.618 - 00:03:56.742, Speaker A: So we'll type pool is equal to underscore pool. The constructor is now done, so we'll next write the function for estimate amount out. Using this function we'll be able to get the time weighted average price of token out. In terms of token in, we'll first require that token in from the input is either token zero or token one. By typing require token in is equal to token zero or token in is equal to token one. If it is not, we'll throw an error message saying invalid token. Next, we'll figure out what token out is by comparing it with token in.
00:03:56.742 - 00:04:47.990, Speaker A: So we'll say address token out is equal to if token in is equal to token zero, then token out will be token one, else token out will be token zero. The next step is to get the average tick and then convert that tick into price. This is easy in unisoft b three. To get the average tick we simply need to call oracle library. So we'll type oracle library consult the first parameter takes in the address of the pool so that will be stored in pool and the second parameter takes in the twap duration here. This will be stored in seconds ago. Now calling this function will return two outputs.
00:04:47.990 - 00:05:53.470, Speaker A: The first output will be the time weighted average tick, so it will be int 24 tick and the second output will be the harmonic mean of the liquidity for this video. We're not going to be needing that, so we'll just simply ignore it. Once we have the time weighted average tick, we can compute the amount out by typing amount out is equal to oracle library, get quote at tick and passing in the tick the amount in, token in and token out and that completes the function estimate amount out. We now have a uniswap b three price oracle. Now remember that I said that we're going to ignore the second output. If you want to make this function more gas optimized, then we can copy some of the code inside consult and strip out the parts where it computes the second output. To do that, I'm going to copy all of the code inside the oracle library, the function consult.
00:05:53.470 - 00:06:23.538, Speaker A: We'll comment this code out and then paste the code here. And then we'll strip away some of the code that we don't need. The part of the code that we're going to need is the part where it computes arithmetic mean tick. And the part of the code that we're not going to need is the part where it computes harmonic mean liquidity. So I'm going to remove all of the code that is not relevant to getting the arithmetic mean tick seconds ago is used to call unisoft b three. Observe. And by calling that we get tick cumulative.
00:06:23.538 - 00:06:41.710, Speaker A: So it looks like we're going to need this part of the code seconds per liquidity cumulative. This sounds like we're not going to need it, so I'll remove it. Tick cumulatives delta. We probably going to need it. Seconds per liquidity cumulatives delta. We probably won't need it. So that means we probably don't need this part of the code.
00:06:41.710 - 00:07:05.726, Speaker A: And this code. Next, I'll rename the variable arithmetic mean tick. Since we're calling it tick. Over here, I'll rename this to tick. And tick tick is int 24. So I'll declare as int 24. Now, instead of calling the function consult, we save a little bit of gas by excluding the code that computes harmonic mean liquidity.
00:07:05.726 - 00:07:43.786, Speaker A: Now, before you run a demo, notice this part of the code. To get the time weighted average tick, it subtracts tick cumulative one from tick cumulatives zero stores the difference in tick cumulatives delta. And then tick cumulatives delta is divided by the t wap duration seconds ago. This is the same equation that we saw in the previous video. Okay, so let's now run a demo. So I've already created a file, and for this demo, we'll get the price of beef in terms of USDC. We deploy the contract on Mainnet fork and then get the price of beef in terms of USD by calling estimate amount out inside the terminal.
00:07:43.786 - 00:08:18.100, Speaker A: I'll paste my alchemy API key and then spin up a mainnet fork. Next I'll open a new terminal and then we'll run the test by calling MPX hard hat test dash dash network localhost, and we get that this is the price of beef in terms of USDC. USDC has six decimals. So I'll paste the results and divide this by ten to the six. And we get that the price of beef in terms of USDC is 3112.
