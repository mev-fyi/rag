00:00:00.250 - 00:00:30.066, Speaker A: Okay, today we will finish up the swap function. So inside the file called tick sol, we'll first finish the function called cross. When we do a swap and a tick is crossed, we'll call this function called cross and update some variables. This function is going to take four inputs, a mapping from int to four to info. Info stores the information about this current tick. So this will be a mapping. It's going to taking the current tick and it's going to take in some variables that are needed to calculate the fees.
00:00:30.066 - 00:01:06.434, Speaker A: Fee growth global zero X one to eight and one x one to eight and it's going to return a number called liquidity net. This number is used to update the current liquidity. Okay, first we'll get the info by typing info storage. Since we're updating this, let's call this info equals self at tick. Now when a tick is crossed we need to update the fees. So what we're going to do is update this two fields called fee growth outside zero X one two eight and fee growth outside one x one two eight. Why are we updating this? I'll discuss this in another video.
00:01:06.434 - 00:02:11.254, Speaker A: So going back down, what we're going to do is update fee growth outside zero and one X one to eight. So say info fee growth outside zero x one two eight is equal to every time a ticket is crossed. We'll update fee growth outside zero x one two eight to be the current fee growth global zero x one two eight minus the current info fee growth outside zero x one two eight and why are we doing this again? I'll discuss this in another video. So say fee growth global zero x one two eight minus the current fee growth outside info fee growth outside zero x one two eight and we'll do the same for fee growth outside one x one two eight. Change a one here, change a one here and change this to a one. And for the last step, we'll return liquidity net which will be the current liquidity net stored inside info. So say liquidity net is equal to info liquidity net.
00:02:11.254 - 00:02:59.250, Speaker A: Okay, so that completes the function cross. We'll be calling this function inside the swap function when a tick is crossed. Okay, so let's go back to our clam contract and I'm inside swap function and we're finishing up the code inside the while loop. So inside this while loop we're doing a single swap from a tick to another tick. At the end of each iteration of this while loop, we'll either need to call the function tick cross that we just wrote or update the current tick. If the current square root price x 96 after the swap is equal to the next square root price x 96, so this square root price next x 96 is the price for the next tick. When these are equal, then we know that the swap caused the current tick to cross over to the next tick.
00:02:59.250 - 00:03:33.918, Speaker A: So inside here, what we'll need to do is call the function tick cross. I'll say if step initialized, initialized, then we'll call the function ticks cross and for the tick we'll pass in the next tick. Step tick next. Since the current square root price x 96 and the next square root price x 96 are equal, in this case, the current tick must be equal to the next tick. So here that's why we're passing tick. Next. Okay, the next inputs are fee growth global zero X one two eight, and one x one two eight.
00:03:33.918 - 00:04:17.150, Speaker A: Now, if we're doing a trade from 00:41, 00:41, then for the fee growth global, we'll need to pass in the fee growth global that is tracked by the state. Since we're doing a swap from 00:41, token zero is coming in and fees are accrued on token in. So here we'll pass the fee state fee growth global zero X one two eight. This should be fee growth global X one two eight. Otherwise, if the trade is a one 40, then fee growth global zero X one two eight does not change. So we'll pass the state variable, fee growth global zero X one two eight. And likewise, if this trade was a zero for one, again, fee is taken out from token in.
00:04:17.150 - 00:04:48.230, Speaker A: Token in is token zero, so there is no fee on token one since there is no fee on token one. If it is a 00:41 trade, then we'll pass fee growth global one X one two eight. This is the state variable. Otherwise, if this trade was a one 40, this means token one is coming in and token zero is going out. So we're collecting fee from token one. So we'll be passing state fee growth global X one to eight. Okay, calling the function ticks cross will return liquidity net.
00:04:48.230 - 00:05:32.150, Speaker A: Liquidity net is int one to eight. Liquidity net is equal to okay, once we have liquidity net, the next step is to update the current liquidity. Now, recall from a previous video that depending on the direction of the trade, we need to either add a plus or a minus to this liquidity net. So say if 00:41 then we'll say liquidity net is equal to minus liquidity net. The way to remember this is if the trade swings the price to the right, then liquidity net should be positive. On the other hand, if the trade moves the price to the left, then we add a minus to liquidity net. When we do a trade for 00:41 then the price decrease so the price moves to the left.
00:05:32.150 - 00:06:09.938, Speaker A: So we put a minus here. Okay, the last step is to update the current liquidity. So say state liquidity is equal to now, liquidity net can be either be positive or negative. So we'll say liquidity is this less than zero. If it is two state liquidity we'll minus and then cast liquidity net into UN 28. Un one two eight minus liquidity net. Otherwise, we'll say state liquidity plus un one to eight cast liquidity net into un 28.
00:06:09.938 - 00:06:59.614, Speaker A: Okay, the last step is to update the current tick. So say state tick is equal to now we'll need to handle two cases whether the trade is a 00:41 or not. If now going back up going back up to here when we're doing a 00:41 trade next, initialize tick within one word for tick next, it may return the current tick. So what we need to do over here is make sure that the next tick is less than the current tick by saying step tick next. So this tick next right now may be equal to the current tick. So to make sure that it is less than the current tick, we will do the minus one. Otherwise, if it is a one 40 trade, then we know that the next tick is greater than the current tick.
00:06:59.614 - 00:07:51.778, Speaker A: So say the next tick is step tick next. Okay, so this completes the condition when after the swap, the current square root price X 96 is equal to the next square root price x 96, let's handle the other case. So say else if state square root price x 96 is not equal to the next one over here we know that the current square root price x 96 is not equal to the next square root price x 96. So here we don't have to check with the next square root price X 96. However, we should check with the square root price X 96 that was set at the beginning of the swap. They'll say step square root price start X 96. What we're checking here is that we're making sure that the current price changed a little bit.
00:07:51.778 - 00:08:15.158, Speaker A: Then we'll say state tick. We'll recompute the current tick. Tickmath git tick square root ratio, state square root price X 96. Okay, and that completes the function swap. Let's try compiling the contract. Open my terminal and type forge build. Okay, I'll go fix this error line.
00:08:15.158 - 00:08:26.302, Speaker A: Four or five. Nine. Four or five. I'll need to change this to a colon. And I also don't need this comma. And I also need a semicolon here. Also need a semicolon here.
00:08:26.302 - 00:08:42.220, Speaker A: This should be initialized. Going back. Let's try compiling the contract again and our contract compiled. Okay, so that completes the swap function. Starting from the next video, I'll start explaining how the fee is calculated in unison. B three.
