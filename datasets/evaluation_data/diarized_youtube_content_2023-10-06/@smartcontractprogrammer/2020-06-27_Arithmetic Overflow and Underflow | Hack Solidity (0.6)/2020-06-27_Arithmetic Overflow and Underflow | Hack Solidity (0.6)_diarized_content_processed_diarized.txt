00:00:00.650 - 00:00:30.822, Speaker A: Hey everyone, in this video we'll learn about overflow and underflow. First of all, I'll explain what it is. And then we'll examine a smart contract that is vulnerable to overflow and underflow. And lastly, I'll show how you can protect your smart contract code from overflow and underflow. Alright, so what are overflow and underflow? Overflow occurs. A number is too big. The part that exceeds the maximum range is count from zero again.
00:00:30.822 - 00:01:15.838, Speaker A: So you end up with a number that is smaller than what you started with. Underflow is similar to overflow, and it happens in the opposite direction. When a number is smaller than the minimum range, it starts counting back from the maximum number, and you end up with a number that is greater than what you started with. Let's look at an example using Un, which stands for unsigned integer. Now, the data type Un is a short name for UN 256. And what does this 256 tell us? Well, it means that it can represent two to the 256 numbers ranging from zero to two to the 256 minus one. So let's look at overflow.
00:01:15.838 - 00:01:56.754, Speaker A: What happens when a number is greater than two to the 256 minus one? So over here on the right, we have x, which is beyond the maximum range. How does solidity handle a number that is beyond the range? Well, it wraps around and then starts counting forward from zero. For example, let's say that the number x is three greater than the maximum range. And now let's calculate where this number is going to end up. Well, one beyond the maximum number will get us back to zero. Two beyond the maximum number will land at one. And finally, three beyond the maximum number will land at two.
00:01:56.754 - 00:02:27.500, Speaker A: So if the number is three plus the maximum number, then it wraps around and we end up at two. So this is overflow. And when a number overflows, solidity does not give you any warnings or errors. It just doesn't care. Underflow happens in the opposite direction of overflow. So here we have a number that is less than zero, which is the minimum range. In this case, what will happen is that the number will be counted backwards from the maximum number.
00:02:27.500 - 00:03:09.590, Speaker A: Let's see an example using the number negative two. Where would negative two end up on the range between zero and two to the 256 minus one? Well, minus one will give us the maximum number which is two to the 256 minus one, and negative two will be one less than that, which is two to the 256 minus two. This is underflow. And again, solidity will not give you any warnings or errors. So when you're dealing with numbers and solidity. You got to be careful of overflow and underflow. Let's now examine a contract that is vulnerable to this behavior.
00:03:09.590 - 00:03:49.542, Speaker A: Timelock is a contract where you can deposit ether and you have to wait at least one week before you can withdraw. The amount of ether that you deposit into this contract is kept in a mapping called balances. The time at which you can withdraw is kept in a mapping called lock time. When you deposit ether into this contract, it does two things. It first updates your balance and then it updates lock time to one week from now. So this means that you won't be able to withdraw from this contract for at least one week. And you can see how this mapping is used in the withdrawal function.
00:03:49.542 - 00:04:30.900, Speaker A: So let's take a look. So you've deposited some ether into this contract, waited one week, and now you want to withdraw from it. The function withdrawal will first check that you have some ethers deposited into this contract. And this is done by checking that the balances mapping of your address is greater than zero. Next, it checks that the current time is greater than the lock time. So if you try to call this function before one week has passed since you deposited this check will fail and you won't be able to withdraw. After the two checks above pass, we update the balance and then send the ether back to you.
00:04:30.900 - 00:05:15.120, Speaker A: That's how the withdrawal function works. Now if you want to increase the lock time, say one month, then you can do that by calling this function, increase lock time for the input you pass in the seconds to increase the lock time by, and then it will add the seconds to increase to the current lock time. So this is how the contract time lock works. It allows you to deposit, but you have to wait a minimum of one week before you can withdraw. And you can also increase the time lock by calling increase lock time. This contract is vulnerable to un overflow. I'm going to show you how you can withdraw from this contract without waiting one week.
00:05:15.120 - 00:05:51.286, Speaker A: And the basic idea behind this hack is to update lock time with a very huge number. The contract that's going to hack the time block contract above, we'll name it attack. We'll store the contract that's going to be exploited in a state variable called timelock. And using a constructor, we'll set our target here. We're going to need a payable fallback function so that we can receive the ether withdrawn from the timelock contract. To initiate the attack, we'll create a function called attack. We're going to be sending some ether to the timelock contract.
00:05:51.286 - 00:06:40.860, Speaker A: So we'll declare this function as payable. And when we call this function, we'll send some ether to this function, then send the ether that is sent to this function to the timelock contract. We'll first deposit ether into the time lock contract by calling timelock deposit. And this will set the timelock to one week from now so that if you try to withdraw it immediately then it will fail. So before we can call the withdrawal function, we'll increase the log time by some huge number which will cause un to overflow and then we can call withdrawal. So what's the huge number that we need to pass in here to cause a unit overflow? Well, let's do some math. We'll say that t is the current lock time.
00:06:40.860 - 00:07:40.560, Speaker A: What we need to do is find x such that x plus t is equal to two to the 256 and two to the 256 is equal to zero. Since the overflow causes the number to wrap back to zero, we do some simple algebra minusing t from both sides of the equation and we get x is equal to minus t. So this means that if we pass minus t to this function here, then this will cause an overflow and the current lock time will equal to zero. We can get the current lock time by calling timelock log time and then pass in the address of this contract. And we'll put a negative sign up in front and then cast it into a unit by wrapping it in un. Now this doesn't look like a big number, but it is over here. We're using underflow to create a real big number.
00:07:40.560 - 00:08:32.670, Speaker A: And what this number represents is two to the 256 minus t where t is the current lock time. And this completes the function that's going to be able to deposit and then immediately withdraw by exploiting un overflow. Let's see this in action here. I have the time lock contract and the attack contract deployed. The attack contract was deployed using the address of the timelock which was passed in by copying the address of the timelock contract and then pasting it in here and then hitting deploy. Let's say that account one is Eve and she's going to deposit one ether into the time lock contract. So we'll call the function deposit with one ether.
00:08:32.670 - 00:09:26.862, Speaker A: And now if you try to withdraw, you can see here that the transaction fails with lock time not expired. So you'll have to wait at least one week before you can withdraw from this contract. But using the attack contract that we wrote here, we'll be able to deposit and then immediately withdraw. So we'll send 1 meter again and then call attack. And you can see here that the transaction was successful, so we were able to withdraw without waiting one week. And this is because we caused the overflow on the log time. And we can check that the log time did indeed overflow by copying this address and then checking the log time of the attack contract.
00:09:26.862 - 00:10:27.842, Speaker A: So over here we'll pass in the address of the attack contract and then hit lock time. And you can see here that this is equal to zero. So that's unit overflow. Let's now see how we can prevent this exploit. The way you prevent unit overflow is by using math libraries like safemath by openzeppelin. The library works by throwing an error when there is an overflow or an underflow. We'll import the safemath library from GitHub and inside the time lock contract we'll say using safemath for un and this will add extra functions to the un data type so that you'll be able to do something like myunt add one, two, three inside the function increase lock time we'll update this line by saying the new lock time is equal to the current lock time plus the seconds to increase.
00:10:27.842 - 00:11:07.280, Speaker A: And this add function over here will take care of unit overflow. If the addition of these number results in a unit overflow, then this function will throw an error and call to this function will fail. So that's how you use safemap to prevent un overflow and underflow. Let's check that this works by using the attack contract again. So I've recompiled the time valve contract and attack contract and then redeploy them here. So we'll call the attack function. So we'll send one ether and then call attack.
00:11:07.280 - 00:11:37.140, Speaker A: And you can see here that the transaction failed with safemap addition overflow. So in summary, using safemath we were able to prevent attacks from un overflow and underflow. That's all I got to say for this video. I'll put the link to this code here in the descriptions below. If you have any questions or comments, you can comment below, or you can send me a message on discord. Have a nice weekend and see you later.
