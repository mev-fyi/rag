00:00:00.490 - 00:00:21.918, Speaker A: English auction is an auction that we're all familiar with. A seller sets a starting price and ending time. At the end of the auction, the highest bidder wins. Let's write this in code. First, we'll declare some state variables for this auction. We're going to be selling an NFT, so we're going to need to store that somewhere in this contract. So I'll say Ierc seven, two, one.
00:00:21.918 - 00:00:57.146, Speaker A: This will be a public state variable and this NFT will not change during the duration of the auction. So I'll make this immutable and I'll name it NFT. That will be the contract of the NFT. We're also going to need to store the ID of the NFT that we're selling. So I'll say un public immutable immutable because the NFT id will not change and name it nft id. Next, let's declare some state variables about the auction. So the first thing that we'll declare is the seller address public immutable seller.
00:00:57.146 - 00:01:26.306, Speaker A: We also store the timestamp when the auction ends. Now, to store the timestamp, we won't be using un. Instead, we'll be using the smaller data type called UN 32. UN 32 can store up to 100 years from now, so this is sufficient for this contract. If it was greater than 100 years, we probably won't be alive for the auction to end, so UN 32 is sufficient. Make it public. I'll name this end at and this variable is not immutable.
00:01:26.306 - 00:02:10.066, Speaker A: We'll set end at when the seller calls a function called start. We also need to keep track of the state of the auction. So we'll say boolean public started and boolean public ended. Started will be set to true when the auction starts, and ended will be set to true when the auction ends. Next, we'll declare some state variables relevant to the bidders. We'll need to keep the address of the highest bidder, so I'll say address public highest bidder and amount Un public highest bid. And if you're no longer the highest bidder, then we want to be able to withdraw our bid.
00:02:10.066 - 00:02:50.302, Speaker A: So if you're not the highest bidder, then we'll store the total amount that you bid so that you can withdraw your ETH. I'll type mapping. It'll be from address to un. I'll make the state variable public and I'll name it bids. This mapping will store the total amount of bids that you made that is not the highest bid and it will allow you to withdraw your ETH if you're not the highest bidder. Next we'll code the constructor. So I'll type constructor, and inside the constructor we want to pass the address of the NFT NFT and also the NFT id, un NFT iD, and the starting price of the NFT.
00:02:50.302 - 00:03:40.094, Speaker A: I'll name a uint starting bid and then inside the constructor we'll set the state variables. NFT is equal to IERC. Seven, two, one, nFt from the input nFT id is equal to nFT id. The seller will be equal to the deployer, so we'll type seller is equal to message sender. Now, later on when the auction ends, we'll need to send ETH to the seller. So we'll modify the state variable seller to be payable address payable public, immutable seller. And then likewise over here we'll cast message sender to payable by typing payable message sender, and we'll set the current highest bid to the starting bid.
00:03:40.094 - 00:04:15.118, Speaker A: By typing highest bid is equal to starting bid. Next we'll write the function to start the auction. So I'll type function start. This will be external only. The seller should be able to start the auction, so we'll type require message sender is equal to seller and the error message not seller. We also want to make sure that this function can only be called once. So that is, if started is not yet equal to true.
00:04:15.118 - 00:04:59.338, Speaker A: So we'll type require not started and if it is already started, their message will be started. The first thing that we'll do is set started to true and then we'll set the timestamp for end at. We call that end at is UN 32. So we'll say UN 32 block timestamp. Because block timestamp is UN 256. We'll have to cast it to UN 32 and UN 32 is sufficient since it is about 100 years from now. And for this demo I'll set it to 60 seconds since I don't want to wait seven days.
00:04:59.338 - 00:05:56.670, Speaker A: But if you wanted to go ahead and set it to like seven days for this example, I'll just set it to 60 seconds. Once we set some state variables, we'll transfer the ownership of NFT from the seller to this contract so that this contract will own the NFT. By typing NFT transfer from we'll transfer the ownership of the NFT from the seller to this contract and the NFT that we're going to be transferring is stored in NFT ID. And then lastly we'll emit the event we'll name it start emit start and I'll scroll up and then define an event called event start. Once the auction has started, users will be able to bid. So we'll write a function called bid. They'll be sending ether for their bid, so this function will be external payable.
00:05:56.670 - 00:06:41.130, Speaker A: We want to require that the auction has started by typing require started the error message not started. We also want to make sure that the auction has not ended yet. Ended at is set over here. So we'll say that the current timestamp block timestamp is less than end at and the error message ended. The last check that we want to make is that the amount of beef that was sent is greater than the current highest bid. So we'll type require message value is greater than the current highest bid. There message value less than highest bid.
00:06:41.130 - 00:07:36.190, Speaker A: Once the above checks passes, we'll set some state variables. We'll say highest bid is equal to message value and the highest bidder is equal to message sender. Now this function call will work correctly for the first bidder, but if a second caller outbids the first bidder, then we need a way to refund the first bidder which is no longer the highest bidder. So you'll do that by keeping track of total amount of ETH that a user has bid which are no longer the highest bid. So we'll do that by typing bids of highest bidder plus equals highest bid. When the first bidder calls this function, highest bidder will be address zero. So we'll make sure that this line of code only executes if highest bidder is not equal to address zero.
00:07:36.190 - 00:08:34.238, Speaker A: So we'll type if highest bidder is not equal to address zero, then store the current highest bid before we override it. What this line of code does is it keeps track of all the bids that were outbid, so that later on they will be able to withdraw their ETH. Lastly, we'll emit the event from this function. So we'll type emit bid and then we'll log message sender with message value. Scroll up and then we'll declare event bid address sender un amount we might want to create for all bid by a particular sender. So I'll make this sender param indexed. We now have a way for users to bid.
00:08:34.238 - 00:09:17.146, Speaker A: Let's now write a function for users that are not the highest bidder to withdraw their ETH. So I'll scroll down and I'll name this function withdraw. This will be external. The total amount of bids that are not. The highest bid is stored in bids of message sender. So we'll declare a variable saying unbow is equal to bidsof message sender and before we send ETH out to message sender, we'll reset the bids mapping by typing bids, message sender is equal to zero. The reason why we're doing this is to protect from reentrancy.
00:09:17.146 - 00:10:17.410, Speaker A: If we transfer the e before we reset the balance, then this contract will be vulnerable to reentrancy. So that is why we're resetting the state variable bids and then only after that we are transferring the e file and then we'll type payable message sender transfer bell and lastly we'll emit the event emit withdraw message sender for Bell. Scroll up and we'll declare event similar to bid. We will rename this event to withdraw instead of sender I'll rename this to bidder and amount I'll keep it the same. The last function that we'll write is for anyone to end the auction when the timestamp has surpassed end at. So I'll declare a function called end. This will be external.
00:10:17.410 - 00:11:25.960, Speaker A: The reason why this function can be called by anyone is because if we were to restrict this function call to the seller and let's say that the seller doesn't call end, then the highest bidder has their ETH stuck in this contract and the ownership of the NFT belongs to this contract. By making this function be able to call by anyone after the auction ends, the seller will receive his ETH and the highest bidder will be able to claim his NFT. To be able to call this function, the auction had to be started. So we will require that auction is started and the error message not started. We also require that the auction has not ended, so not ended and the error message ended and we also require that the current timestamp has surpassed ended that by typing require current timestamp block. Timestamp is greater than or equal to end at. With the error message not ended, the first thing that we'll do is set the state variable ended to true.
00:11:25.960 - 00:12:43.730, Speaker A: So this means that this function end can only be called once and then we'll transfer the ownership of the NFT to the highest bidder by typing NFT transfer from address this this contract is the owner of the NFT to the highest bidder. The NFT that we're transferring is nFT id. After the NFT is transferred, we'll transfer the highest bid to the seller by typing seller transfer highest bid now there is a case where no one bids on the NFT, maybe no one wants the NFT or the price is too high. In that case, the highest bidder will be address zero and we obviously don't want to send our NFT to address zero. So we'll write a check here by saying if highest bidder is not equal to address zero and this will mean that someone bid on the NFT. Then we'll put this logic over here. If there is a highest bidder and the auction has ended, then transfer the ownership of the NFT to the highest bidder and to the seller, Sandeef, for the highest bid.
00:12:43.730 - 00:13:37.140, Speaker A: Else, if highest bidder is equal to address zero, this means that no one participated in the auction. So we'll transfer back the ownership of the NFT from this contract back over to the seller. By typing NFT, transfer from address this to the seller. The NFT will be NFT iD. And lastly, we'll emit the event end emit end. What are some parameters that we might want to log? Maybe the highest bidder and the highest bid. We'll scroll back up to define the event and define event and address highest bidder unit amount.
00:13:37.140 - 00:14:09.222, Speaker A: Notice that we don't have to index the highest bidder because there's only going to be one highest bidder and that completes the english option. I'll hit Ctrl s to compile the contract. We'll deploy the contract and I'll show you a demo. First we'll deploy the NFT contract, Erc seven two one contract, which I copied and pasted from soliditybyxample.org. I'll hit Ctrl s to compile the contract. Select ERc seven two one and then hit deploy. First we'll mint some tokens.
00:14:09.222 - 00:14:59.302, Speaker A: So we'll scroll down and we'll call the function mint. We'll mint to this contract, I'll copy it, paste it here and the token ID. I'll say 77. Once the token is minted, we'll next deploy the english auction contract. So I'll hit Ctrl s on the english auction, make sure that I've selected the english auction contract and for the deployment parameters we'll pass in the address of the NFT. The NFT that we're selling is 77 and the starting price, we'll set it to one weight. Before we start the auction, we'll need to approve this english auction to be able to transfer the ownership from us over to the contract.
00:14:59.302 - 00:15:37.590, Speaker A: So I'll click on ERC seven two one and we'll need to call the function approve. We'll need to approve the english auction contract to be able to transfer the ownership from the seller, which will be us, over to the contract. The token ID will be 77 and then hit transact. So now we can start the auction. I'll hit start. And we now have 60 seconds for the auction to end. So let's say that the second account, Bob is going to bid for ten way and then calls bid.
00:15:37.590 - 00:16:13.940, Speaker A: Next, Charlie. The third account bids for 30 way and then calls bid. Bob sees that Charlie bid for 20. So now Bob is going to bid for 30 way and we'll wait for the auction to end. Okay, so once the time for the auction has passed, we'll call the function n. But before we do that, let's check some state variables. The highest bidder should be Bob for 30 ways.
00:16:13.940 - 00:16:38.422, Speaker A: 30 ways. And that is the highest bidder. Scrolling up. That's the address of Bob. So the highest bidder is Bob for 30 ways. How much ETH can Bob refund? He bid for ten, which he was outbid by 20. So the bid for Bob should return ten and it does likewise for Charlie.
00:16:38.422 - 00:17:13.874, Speaker A: He was outbid, he bid 20 and then he was later outbid by 30. So if we call the function bids pasting in the address of Charlie, we get 20 back. We'll end the auction by calling end and the transaction is successful. We'll check the owner of the NFT ID 77 and it is equal to Bob. And clicking on ended. The auction has ended. Lastly, Charlie has 20 e locked in this contract which he was outbid and Bob has ten e that is locked in this contract.
00:17:13.874 - 00:17:34.410, Speaker A: So we'll call withdrawal to withdraw all of the ETH in this contract. Scrolling up. Bob will call withdrawal and the transaction is successful. And also Charlie will call withdrawal and the transaction is also successful.
