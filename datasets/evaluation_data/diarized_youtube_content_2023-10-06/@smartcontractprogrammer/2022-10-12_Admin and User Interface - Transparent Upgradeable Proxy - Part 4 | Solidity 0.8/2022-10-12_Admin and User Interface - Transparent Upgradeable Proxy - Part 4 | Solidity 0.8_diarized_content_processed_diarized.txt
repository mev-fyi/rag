00:00:00.250 - 00:00:47.542, Speaker A: We're now storing the address of the implementation and the admin in a slot that is not the zero for the first slot. The next thing that we'll do is separate user and admin interface. What we're going to be doing is if the caller is an admin, then we'll let the admin execute some function on the proxy contract. Otherwise, if the caller is a user, then we'll forward all of the calls to the implementation. First of all, let's see what problem we have with our current implementation. So if I scroll down to the proxy contract, notice that we have some public function, public implementation slot, public admin slot. And if I scroll down, we also have a public function for upgrade to and for admin and implementation.
00:00:47.542 - 00:01:37.834, Speaker A: Now the problem is if we were to have these function also inside the implementation contract, then even though we might want to call the function inside the implementation contract, these function will always be executed. The functions inside the proxy contract. And worse, it doesn't have to be this exact same function. As long as the function selectors are the same, the functions inside the proxy contract will be executed even if we wanted to call some function in the implementation contract. So let me show you an example. So I'll copy this function and then we'll paste this function into the implementation contract. So we'll paste this in the counter b one contract, and for this function, let's say we'll return address one and we'll do the same.
00:01:37.834 - 00:02:29.610, Speaker A: For implementation, we'll return, let's say return address two. Then we'll deploy the contract. So hit the deployment tab, then deploy the proxy contract and the counter b one contract, scroll down and then from the proxy we'll set the counter b one. So upgrade to let's check the implementation contract and it is set. Now let's load the counter b one at the proxy address. So I'll copy the address of the proxy and then select counter b one, paste it here, and then load the contract, scroll down and then let's try calling the address of the admin. If we look at the implementation, the counter b one contract, we expect it to return an address one.
00:02:29.610 - 00:03:40.322, Speaker A: However, if we scroll down to the proxy contract, scroll down, it says that if we call the function admin, then it will get the admin of the proxy contract. If we click on this admin button, then it returns the address of the admin. If we click on the implementation, then it returns the address of the implementation instead of these addresses that you see over here, address zero, address one and address two. What's going on here is that we're calling the proxy contract and we're trying to call the admin and the implementation function inside counter b one. But since the function selectors are the same, this proxy contract will first look for a function called admin or implementation in the proxy contract, and it sees that it has a function for both admin and implementation, and these are the function that gets executed. The problem here is that if we have a function that we wanted to call inside implementation, in this case inside the counter b one contract, these function can never be called. Let's go fix this.
00:03:40.322 - 00:04:15.914, Speaker A: So inside the proxy contract, what we're going to do inside the proxy contract is remove the public functions and make them private. So I'll make this private. And likewise for admin slot, I'll make this private. However, there are some functions that we cannot make private. For example, if I scroll down, we need this function upgrade to and we cannot make it private. So we'll only show it if message sender is the admin. First I'll create a modifier called modifier if admin.
00:04:15.914 - 00:05:01.594, Speaker A: And what we're going to do here is if message sender is the admin, then we'll let it execute any of the function where we put this if admin modifier. Else if the caller is not an admin, then we'll forward the request to the fallback function, the function over here. Okay, so say if message sender is equal to get admin. Notice that here we're calling the internal function. Get admin to get the admin, because the admin is not a state variable anymore, it is stored in this admin slot. So if admin, then execute the function. Else we'll forward the request to a fallback function.
00:05:01.594 - 00:05:49.450, Speaker A: Now notice that the fallback function is external, so we cannot directly call it here. And also notice that both fallback and the received functions are calling the same function. So first we'll create an internal function function. I'll name it underscore fallback, and this will be private. And what we're going to do here is call this function. So I'll cut it out from the fallback function, paste it here, and inside the fallback function we'll call the internal fallback function. Likewise for receive call the internal fallback, and inside the if admin modifier, we'll call the fallback.
00:05:49.450 - 00:06:45.934, Speaker A: If message sender is not the admin of this contract, and then we'll expose this upgrade to function. If the caller is admin, so say external. If admin and then since we know that this function can only be called by the admin, we can remove this check and let's scroll down and search for other public functions. So I see another public function here. So we'll also show this function if the caller is admin, say external if admin, and likewise for implementation, external if admin. Okay, so we're now done with showing some public functions that we need for the proxy contract and only showing it if the caller is admin. Otherwise we'll just redirect all of the calls to the fallback function.
00:06:45.934 - 00:07:26.300, Speaker A: So let's give it a try. What we're going to try is deploy the contracts again and if message sender is not the admin of this contract, then it should forward the request to these functions. Otherwise, if the caller is the admin of the proxy, then we should be able to get the address of the admin and the address of the implementation. I'll hit ctrl s to compile a contract and I see an error. So let's fix this. If I hover over the error, I see an error saying function cannot be declared as view because this expression potentially modifies the state. So I'll have to remove this view.
00:07:26.300 - 00:08:07.350, Speaker A: Then I'll hit Ctrl s again and the contract compiles. So let's deploy these contracts. Click on the deployment tab, then I'll clear the old contracts. Okay, I'll deploy the proxy contract and the counter b one contract. Scroll down, open both the contracts, then copy the address of the counter B one, and then we'll upgrade to set the implementation contract. Also open the logs so that we can see the transactions. Okay, let's now load the proxy contract with the counter b one interface.
00:08:07.350 - 00:08:48.930, Speaker A: Paste it here, then call that address. Scroll down, open the contract. If message sender is not the admin, then this code will forward all of the requests to the fallback function. I'll scroll up and then switch account to an address that is not the admin of the proxy contract and then scroll down. Then if we call the function admin, then we expect it to return address one and it does. Likewise, if we call the function implementation, we expect it to return address two and it does. Okay, scrolling back down to the if admin modifier.
00:08:48.930 - 00:09:27.882, Speaker A: If message sender is the admin, then it will let us execute the function inside the proxy contract. So I'll scroll up and then switch back to the admin account. Scroll down, then we call the admin and we get an address that is not equal to address one. This is the admin of the proxy contract. If we call the function implementation, then we get the address of the implementation. In this video, we modify the proxy contract to forward the function calls to the implementation contract. If the caller is not the admin of the proxy contract.
00:09:27.882 - 00:09:57.570, Speaker A: If the caller is the admin of the proxy contract, then we let that admin call some functions inside the proxy contract. It now what if the admin of the proxy contract wants to call a function inside the implementation? At this moment he cannot. So in the next video we'll write a contract called proxy admin. This will be the admin of the proxy contract, and using the proxy admin contract, the owner of the proxy admin contract will be able to call the admin functions inside the proxy contract.
