00:00:00.250 - 00:00:36.358, Speaker A: Let's learn how to write to any storage inside the solidity smart contract, and we will apply that knowledge to store the address of the implementation in admin somewhere else besides the zero and the first slot. Previously, we store the address of the implementation admin for counter B one, counter B two, and also the proxy contract. We store it in the zero slot. We store the address of the implementation, and the first thought we store the address of the admin. However, we will store these addresses in somewhere else so that we can remove the code from the implementation. So let's do that. 1st.
00:00:36.358 - 00:01:04.926, Speaker A: 1st, we'll remove the address of implementation and admin from the implementation contract. So that will be from counter B one and from counter B two. We'll remove these two addresses. Later, we'll store the address of the implementation and admin in another slot other than the zero and the first slot. Okay, so next, let's learn how to write to any storage. To write to any storage inside the solidity smart contract. First we'll create a library, and then we'll create a separate contract to test the library.
00:01:04.926 - 00:01:55.114, Speaker A: The library, I'll name it library I'll name this storage slot, and then inside here we'll write our code to test the library. We'll write a contract contract, test slot. The storage of a solidity smart contract ends an array with a length two to the 256, and to each slot we can store up to 32 bytes. Now to use this trick, we cannot simply pass in our address. We'll need to wrap the address in a struct. So first I'll declare a struct, struct, I'll name it address slot, and inside the struct we'll store our address, so address, I'll name it value. Next we'll write a function to get the pointer of the storage, so I'll say function, get address slot.
00:01:55.114 - 00:02:38.362, Speaker A: This will take in a single input that will specify the pointer that we want to get. This will be in byte 32, and then I'll name it slot. This function will be internal and then view, and then we will return the pointer to the address slot. So I'll say returns address slot. We're returning the pointer of the storage variable, so say storage, and then I'll name it R. So what this function will do is return the pointer to storage r located at slot from the input. To do this, we'll use assembly say assembly, and then we'll type R slot, assign it to slot from the input.
00:02:38.362 - 00:03:09.350, Speaker A: Basically we're saying get the storage pointer at the slot from the input. Now if I hit ctrl s, you can see here that a warning pops up. It says that the state mutability can be restricted to peer. Since we're getting storage slot, I thought this must be a view function, but I guess we can turn it into a peer function. So I'll replace view with peer and you can see that the warning is gone. Okay, so this is how you get the pointer to any slot you want. So let's test this out by writing some code inside test slot.
00:03:09.350 - 00:04:12.490, Speaker A: We'll first declare the slot that we'll write to bytes 32 public constant and then I'll name it capital slot and this will be the hash of catchack 256 and then I'll just say test slot. So we're going to be storing an address located at this value, the hash of test slot. Let's write a getter in a setter. Let's start with getter, so function get slot, this will be external view returns address, and to get the address stored at this slot, we'll say return the name of the library. We named it storage slot, so say storage slot, get address slot slot at the slot that we're going to be testing uppercase slot, and this will return a pointer that is storing this address. Slot struct. So to get the address we'll say dot value.
00:04:12.490 - 00:05:00.486, Speaker A: This value over here is the field of the struct that you see over here. So this is how you can get the address stored at this slot. Next, let's write a function where we can store the address in this slot. So say function write slot. It will take in a single input address addr. This is the address that we're going to be storing external and to store this address we'll first have to get this pointer by calling this function. So we'll call this function, this will return a pointer and to save it we assign it like a struct value is equal to addr, hit Ctrl s to compile it and let's test this contract.
00:05:00.486 - 00:05:52.510, Speaker A: So I'll open the deployment tab and then we'll deploy test slot contract, scroll down, open it, and first we have not stored any address, so if we call the function get slot, it returns a zero. And what is the value of the slot that we're going to be storing? The value of the slot is this we're going to be storing an address located at this slot. Let's store an address for this example. I'll just use this contract address, so copy it, paste it here, call write slot, and let's check that this address was stored at this slot. So I'll call get slot again and you can see here that the address changed. Okay, now that we know how to store an address in any slot that we want, let's go apply this to our buggy proxy contract. First, I'll rename buggy proxy to proxy contract.
00:05:52.510 - 00:06:56.042, Speaker A: Then since we're not going to be storing the address of implementation admin in the zero and the first slot, we'll first remove this. Okay, next let's decide on the slot that we're going to be storing these addresses. I'll be following the open zeppelin transparent upgradable proxy contract. In it, they store it in a special place so say bytes 32 public constant. I'll name this capital implementation slot and this will be stored as bytes 32 UN, and then catch 256 of EIP 1967 proxy implementation. And then taking the catch 256 hash of this string, we turn it into un and then minus one. Now, why are we subtracting one by casting this hash into Un? Well, if we were to just use ketchup 256 of this string, then the pre image is known.
00:06:56.042 - 00:07:16.850, Speaker A: We know the hash and the input that was used to get that hash. It will be this string. However, if we minus one, then it will be a random string. We don't know what the pre image of this hash will be. So that is why we're using minus one here. By doing this, we are making some kind of hash collision attack difficult to pull off. Okay, next let's define the admin slot.
00:07:16.850 - 00:08:00.962, Speaker A: So I'll copy this and then paste it here. I'll rename this to admin slot. It'll be again byte 32 Un catch Act 256 eip 1967 proxy admin cast it to un, then minus one, minus one for the same reason as implementation slot. If we were to just use the catch Act 256 of this string, then we would know what string was used to get the bytes 32 for the admin slot. However, if we do a minus one, then we don't know the pre image that was used to compute the admin slot. Okay, so these are the slots that we're going to be using. Next, let's write some getter and setter functions for the implementation slot and the admin slot.
00:08:00.962 - 00:08:53.926, Speaker A: So I'll scroll down, then over here I'll write my functions function underscore get admin. This will be private view returns address. To get the admin, we'll use this same code as that we did for the test contract copy paste, and then the admin slot will be admin slot, and let's do the same for the implementation slot. Get implementation get implementation. The slot will be stored in implementation slot. Next, let's write some internal function to set the admin and set the implementation. So to do that, I'll start off by copying this code, then paste it here.
00:08:53.926 - 00:09:42.418, Speaker A: We'll call this underscore set admin. It will take in the address of the admin admin. This function will be private, and we're going to be storing an admin slot, the new admin address, and we'll check that the new admin address is not equal to the zero address. Require new admin not equal to address zero with the error message admin is zero address. Next, let's write a setter function for the implementation. So I'll copy this, scroll down, paste it, and then rename this function to set implementation. It will take in the address of the new implementation.
00:09:42.418 - 00:10:45.158, Speaker A: The function will be private, and the check that we're going to do is make sure that the implementation is a contract by typing underscore implementation code bank is greater than zero. Otherwise we'll say not a contract. If the code stored at the address implementation is greater than zero, then this means that this address implementation is a contract. Otherwise, the address can be an externally owned account, or it can be a contract that is deployed in the same transaction when this function is called. Okay, so once we check that implementation is a contract that is deployed, we'll store it in the implementation slot. The value will be implementation. Okay, the next thing that we'll do is we are still referencing the admin and the implementation state variables, so we'll replace those with get admin and set admin.
00:10:45.158 - 00:11:28.942, Speaker A: So first, inside the constructor we're saying that the old state variable admin is message sender. To do the same thing, we'll say underscore set admin to message sender. Next, we are referencing the state variable implementation here. So you'll say underscore get implementation, and likewise over here get implementation. Okay, the function upgrade to requires that message sender is admin. So we can get the admin by calling get admin and we're setting the implementation state variable. The variable no longer exists.
00:11:28.942 - 00:12:08.562, Speaker A: To do the same thing, we'll have to call underscore set implementation, passing in the address of the implementation, and then we'll remove this code. Okay, let's try compiling the contract. I'll hit Ctrl s and the contract compiles. Now, before we move on, let's write a public function to get the admin and get the implementation. So I'll type function admin. This will be external view returns address. To get the admin, we'll return underscore get admin, and we'll do something similar to get the implementation.
00:12:08.562 - 00:12:36.622, Speaker A: We'll rename this to implementation and the function to call is get implementation. Let's deploy this contract and try to get the address for admin and the implementation. So I'll open the deployment tab, we'll clear out the old contracts and then I'll select the proxy contract. Deploy it. Scroll down, open the proxy contract. The admin is this address. Let's check that.
00:12:36.622 - 00:12:54.962, Speaker A: This is the account that was used to deploy the contract. Scroll up, starts with five b three. Scroll down, starts with five b three. Okay, let's check the implementation. We didn't set the implementation yet, so it must be a zero address. And it is. Next, let's try calling upgrade two.
00:12:54.962 - 00:13:29.146, Speaker A: We're going to set the implementation. So I'll deploy the counter b one contract. Scroll down, copy the address of counter B one, and then paste it here, call upgrade two. Then afterwards let's try getting the address of the implementation again. And you can see here that this address that was returned is the address of the counter B one contract. In this video, we went over how to store an address in any arbit cherry slot inside the solidity smart contract. And then later we store the address of the implementation and the admin at these slots.
00:13:29.146 - 00:13:38.650, Speaker A: This proxy contract is not yet complete, so in the next video we'll go over how to separate user and admin interface for this proxy contract.
