00:00:00.810 - 00:00:45.660, Speaker A: Over here I have a contract deployed on the Robstone test network at this address. Inside the contract it has a private state variable called password. Private means that other contracts cannot access this state variable. So if you look over here on the left, you can see that there is no way for us to get the password. But just because you declare a state variable as private, it doesn't mean that we don't have access to this data. So in this video I'm going to show you how to get private state variables, even though at first glance it doesn't look like we are able to get the data. The vulnerability here in this contract is that private state variables can be read.
00:00:45.660 - 00:01:36.826, Speaker A: When you declare a state variable as private, that means that other contracts cannot access that data. But since everything on the blockchain is public, declaring a state variable as private is not going to stop us from reading that data. So the lesson to be learned here is to never store sensitive data on the blockchain. In other words, if you don't want the whole world to know, then don't publish it on the blockchain. Before we can access private data, we first need to understand how EVM stores state variables. So that is what I'm going to explain first, and then I'll quickly go over the setups that you'll need to do if you want to follow along. And then I'll give a little explanation about the code and then we'll see a demo where we will retrieve private data from the contract below.
00:01:36.826 - 00:02:10.386, Speaker A: And then lastly we'll talk about preventative techniques. Okay, first let's see how the ethereum virtual machine stores the state variables. So let's say that we have a contract with some state variables. It has a bytes 32 state variable called Foo, and then a bytes 32 state variable called bar. Next we have a un called num and then an address type. And then lastly we have a boolean state variable. So let's see how these state variables are stored inside the EBM.
00:02:10.386 - 00:03:00.230, Speaker A: The EBM stores these state variables in a huge array with a length of two to the 256. So you can imagine that the storage of a contract is an array with two to the 256 slots, and each of these rectangles here represents a slot. Now in each slot you can store up to 32 bytes, and these state variables here will be stored in the order that they are declared in. So since Foo is declared first, it will be stored in the first slot. Each slot can store up to 32 bytes. And since foo is 32 bytes, it's going to use all of slot zero. The second state variable bar will be stored in slot one.
00:03:00.230 - 00:03:45.140, Speaker A: And here again, the state variable bar has a size of 32 bytes, so it's going to use up all of the slot. The third state variable un, will be stored in the third slot and it will be stored in a hexadecimal notation. So for example, if this num state variable is equal to one, two, three, then in hexadecimal it will equal to seven B. And since Un is equal to two to the 256, if you do the math, it turns out that it's going to need 32 bytes. So here again it's going to use up all of the capacity of this slot. The fourth state variable address will be stored in the fourth slot here. Notice that it didn't use up all of the space.
00:03:45.140 - 00:04:30.034, Speaker A: Since the address type is only 20 bytes, we still have space to put other state variables. So if the next state variable can fit under here, then solidity will do. So in this case, the next state variable is a boolean type which only needs one byte. So solidity will store this state variable over here right after the address. So in summary, EBM stores state variables in slots. There are two to the 256 slots and each slot can hold up to 32 bytes. State variables are stored in the order of declaration, so the first state variable will be stored in slot zero.
00:04:30.034 - 00:05:18.446, Speaker A: The second state variable will be stored in slot one, the third state variable will be stored in slot two, and so on. Lastly, if neighboring state variables fit into a single slot, then the EBM will pack these state variables from right to left. And that's the basics of how the state variables are stored. Let's now jump into some code and see some examples. Here we have a contract called bolt and inside it we have some state variables declared up. At top we have some primitive data types, so calculating the slot for these state variables will be straightforward. Next, we have some arrays struct dynamic arrays and mappings.
00:05:18.446 - 00:05:57.498, Speaker A: There will be some calculations involved in order to find the slot for these state variables. All right, so first let's start with the easy ones. The first state variable count is a data type of un, and the Un data type will take up 32 bytes. Since it's the first state variable that is declared inside this contract, this state variable will be stored in slot zero. Next we have the address data type. This is the second state variable that is declared in this contract. It will be stored in slot one and it will use up 20 bytes.
00:05:57.498 - 00:06:53.966, Speaker A: So this means that there are still twelve bytes that we can store inside slot one, the next state variable is oftype boolean and it only takes one byte. Since we still have some space inside slot one, this state variable will be stored after the owner state variable. The next state variable is Un 16 and the data type Un 16 only takes up two bytes. Now inside slot one we can store still eleven bytes and two bytes fit inside eleven bytes. So this state variable will be stored in slot one to the left of the state variable above, which is is true. Now the next state variable is uptype bytes 32. Since 32 bytes does not fit inside slot one, it will be stored in the next slot that is available, which is slot two.
00:06:53.966 - 00:07:43.370, Speaker A: And notice that this state variable is declared as private and this means that other contracts will not be able to access this state variable. But for us we know that this state variable is stored in slot two and we will later get this state variable. Now a constant variable is not stored inside the storage. This will be hard coded into the contract bytecode. So how about an array of fixed size? Here we have a bytes 32 array of size three and EBM will store these state variables sequentially so that the first element will be stored in slot three. The second element will be stored in slot four, and the third element will be stored in slot five. Moving on, let's see how a dynamic array of struct is stored.
00:07:43.370 - 00:08:21.538, Speaker A: For dynamic arrays it's going to store the length of the array in the next slot that is available. So here we used up slot three, four and five. So the next available slot is slot six. So this is where the length of the array users will be stored. And where is the element of the array stored? Well, the array elements will be stored starting at the hash of the slot. So here the length of the array is stored in slot six. So if you take the catch act 256 of slot six, then that is where the array elements are stored.
00:08:21.538 - 00:09:29.460, Speaker A: So at the slot where corresponds to the hash of six, that is where our first user struct is stored. Now each user struct is going to take up two slots. This is because un takes up one slot and then bytes 32 takes up the next slot. So the first user will be stored at the hash of six and the second user will be stored at hash of six plus two since each user struct takes up two slots and the third user will be stored at hash of six plus four and so on. How about for mappings? How are the values of mappings stored? Well, it turns out that the value of the mapping are stored at the hash of the key and slot. And what does this mean? Slot here is equal to seven since this is the next available slot, and the key here is equal to the map key. So if you want to get the slot where the user ID is equal to one, you'll take the hash of one and then seven.
00:09:29.460 - 00:10:03.674, Speaker A: And that's how you determine where these state variables are stored. Let's now actually try to read some private state variables. And here inside the constructor, I've set the password. And remember, that password was a private state variable, so we can't simply get it using remix. Next, I use this function, add user to add some users. And since the users array and the mapping are both private, we will need to compute the slot in order to read these private state variables. And lastly, here are some helper functions.
00:10:03.674 - 00:11:13.362, Speaker A: To compute the slot of a dynamic array element and one for a map value to follow along, you're going to need truffle and you're going to have to do some setups. So here I'm just going to use a truffle project from an older video where I showed you how to build a multi save wallet using truffle. Inside the terminal, I'm going to type truffle console network Robston and this will start a truffle console that is connected to the Robstone test network. Once you're inside the truffle console, let's now try to get these state variables where this contract is at this address. So I'm going to copy this address and say address is equal to here. I'm just storing the address in a variable called addr. To get the state variable stored at slot zero, we'll need to call web3 E, get storage at and then pass in the address of the contract here.
00:11:13.362 - 00:11:52.320, Speaker A: We stored it in a variable called AddR. Next we pass in the slot that we want to access, in this case zero. And then we pass in a callback here. We'll just console log it. You can see here that slot zero stores this data, which is in hexadecimal notation. And when you convert this seven b from hexadecimal notation to decimal notation, we get the number one to three back, which is the number here. We can get slot one by calling the same function.
00:11:52.320 - 00:12:46.880, Speaker A: And instead of slot zero, pass in slot one. And you can see that it stores the address and then the boolean value and then the number one f. Converting the number one f from hex to decimal, we get 31. And that is the number that you're seeing here. And finally, we're now ready to access the private state variable called password and it is stored in slot two. So we'll call the same function web3 e getstorage at and then access slot two and that is the password. Now we can convert the bytes 32 password into Alphabet by calling web3 utils to ASCII and then passing in the bytes 32 value.
00:12:46.880 - 00:13:38.130, Speaker A: And the Alphabet that we get back is equal to aaabbcc. So that is the password that is stored in here at slot two. Moving on, let's try to get the users in the user's private array and the mapping id to user slot six will hold the length of the array. So over here if we get slot six, you can see here that the array length is equal to two. Now the first user will be stored at the hash of the slot which is equal to six. And we can get the hash by calling web3 utils, solidity shot three and then passing in the value six. So that is where the first array element is stored.
00:13:38.130 - 00:14:41.720, Speaker A: So I'm going to store this hash in a variable called hash and we'll get our first user stored in this array by calling web3 e getstorejat, passing the address and the hash that we just assigned above, and then we'll print it out. What you're seeing here is the Id of the first user. To get the password from the first user struct, we will need to increase this value by one. And this is because the slot corresponding to this hash stores the first user's Id. So if we increment it by one, we will have access to the password. Now when we increment this hash by one in hex, f will become zero and the three will become four. We can get the password by calling getstorage at and that is the password of the first user in bytes 32.
00:14:41.720 - 00:15:39.366, Speaker A: Now if you want to convert this bytes 32 password into Alphabet, you can do that by calling web3 utils to ASCII and then passing in the bytes value. And what you get is the password aaabbcc. We can get the data for the second user by incrementing this hash by one and then calling the get storage app. And you can see here that it returns the ID equal to one. To get the password for the second user, we'll again increment the hash by one and then call getstorage at again. And you can see that that is the password in bytes 32. Again, you can convert this value by calling web3 utils to ASCII and you'll get that the password for the second user is equal to dddeff over here on the left we said that slot seven is equal to empty.
00:15:39.366 - 00:16:15.220, Speaker A: Let's just double check that it is actually empty. So we access slot seven and we get zero back. Let's try to get user one from this mapping. So user one will be stored at the hash of one where slot is equal to seven. We can compute the hash by calling web3 utils solidity shot three and then passing in the value one for the user id equal to one. And the mapping starts at slot seven. So we'll pass in seven and that is the hash that we get back.
00:16:15.220 - 00:16:53.840, Speaker A: And this is the slot where user one will be stored in the mapping. I'll assign this to a variable called hash and we'll get the value stored at this slot by calling get storage hat and then passing in the hash for the slot. And we get that the id of the user is equal to one. The password of this user is stored in the next slot. So we'll increment this hash by one and then call the get storage app function. And you can see that we get the password of user one back. So that was a demonstration of how to get private data.
00:16:53.840 - 00:17:12.530, Speaker A: The preventative technique here is to not store sensitive data on the blockchain. And I just showed you how easy it was to read private data from a contract. It I'll put the links for this code in the descriptions below. Thanks for watching and I'll see you soon. Bye.
