00:00:00.410 - 00:00:29.362, Speaker A: Call is a low level function and we've already seen how to use it to send ether to another contract. In this video I'm going to show you how to use call to call other functions in another contract. For this example, you'll be calling this contract test call. So to begin with, we'll create a contract that's going to be using call. So I'll name this contract call. For the first example, we'll call the function foo. So inside here I'll create a function called call foo.
00:00:29.362 - 00:01:10.802, Speaker A: Later we'll deploy two contracts, test call and call. When we call this function call foo, we'll pass in the address of test call. So for the input I'll say address, I'll name the input as test. It will be external to call the function flu. Using the low level function call we type test call parentheses, and inside this parentheses we'll need to encode the function that we're going to be calling, followed by the inputs that we're going to be passing. To do that, we'll type Abi encode with signature parentheses. The first input for this function will be the function that we're going to be calling.
00:01:10.802 - 00:01:41.606, Speaker A: The function that we're going to be calling is foo. So inside here we'll say foo parentheses. This foo function that we're going to be calling takes in a string as input comma, and it is important to remember here that there is no space between inputs that we're typing. The next input will be a uint. So inside here we type un 256. This is also important. Whenever you see a Un, you'll have to type un 256 for the function input.
00:01:41.606 - 00:02:33.850, Speaker A: Once you put in the function that we're going to be calling next, we need to pass the inputs. The first input will be a message of type string, and the second input will be a un. So for the first input I'll say call foo, and for the second input I'll pass in one, two, three. Now when we use call, it's going to return two outputs. The first output will be a boolean that tells whether the call was successful or not. So I'll say boolean success and the second output will be any output that was returned from calling the function foo, and it will be encoded in bytes, so it'll be bytes memory beta. Next we'll check that the call was successful by typing require success, and if it is not we'll revert with an error message saying call failed.
00:02:33.850 - 00:03:19.270, Speaker A: Now, when you're using call to call other functions, you can specify the amount of guests that you're going to be sending and also the amount of ether that you're going to be sending. So for example, inside here we'll say curly braces to specify the amount of ether that we're going to be saying. We say value colon and then type in the amount of ether that we're going to be sending. For example, we can send one, one one way and for the amount of gas that we're going to be sending when we call this function flu, for example, we can say we're only going to be sending 5000 guests. For this example, I want to show you what data looks like after this function is executing. So I'll create another state variable. I'll call it bytes public data antelboy name conflicts.
00:03:19.270 - 00:04:05.894, Speaker A: I'll prefix this with an underscore. And after the call is successful we'll store this data from the output to this state variable data. By typing data equals underscore data. When we execute this function later, we want to be able to send some ether so that when we call test call, it has enough ether to send. So I'll make this function payable. Next I want to show you example that using call we will try to call a function that does not exist inside this test call contract. Since we have a fallback here, I want to demonstrate that when we call function that does not exist inside this contract, the fallback function will be executed and the log fallback was called will be emitted.
00:04:05.894 - 00:04:44.470, Speaker A: So to show you that I'm going to create a function called call does not exist. Again, it's going to take in the address of the test contract as input. This will be external. And again we'll use the low level function call to call a function that does not exist by typing test call. And we'll execute a function that does not exist. So for example Abi encode with signature a function that doesn't exist. For example, a function does not exist.
00:04:44.470 - 00:05:15.310, Speaker A: Again, making a call will return two outputs. So we'll type boolean success. And the second output we don't care, so we'll just ignore it and then require that the function call was successful. Again by saying success. And if it failed we'll throw an error message saying call failed. Okay, so let's deploy these two contracts and then call these function call foo and call does not exist. So I'll compile the contract.
00:05:15.310 - 00:05:59.578, Speaker A: By typing control s. I'll deploy the call contract and then also the test call contract. Scroll down and then I'll open the call contract. First we're going to be calling the call foo function and I want to show that calling this function will fail because the amount of gas that we're sending is 5005 thousand gas is not enough to update state variables. Afterwards we'll fix the amount of gas that we're going to be sending and then show you a successful transaction of call foo. Okay, so to call foo I'm going to copy the address of the test call contract, paste it here and then call foo. Open the transaction log and notice that the transaction fail with the message call failed.
00:05:59.578 - 00:06:57.314, Speaker A: So this is because we only sent 5000 gas to call the function foo. But that is not enough gas to execute this function. So I'll remove this restriction, compile the contract and then we'll redeploy this call contract, remove the call contract that is already deployed and then deploy again. We'll call the function call foo and this time I want to show you that the transaction will be successful because we removed the restriction of guests. Now we need to send 111 way. So I'm going to scroll up and over here say we'll send 111 way with this function call, scroll down, copy the address of test call contract, paste it here and then call Foo and the transaction is successful. Next I'm going to show you example that when we call a function that does not exist since the fallback is declared, this fallback will be executed again.
00:06:57.314 - 00:07:40.554, Speaker A: Now copy the address to the test call contract. This is the contract that is being called. Paste it here and then call the function call does not exist. Open the transaction and the transaction log and you can see that the log fallback was called was emitted. Now if I were to remove this fallback and try to call a function that does not exist inside this contract, this transaction will fail. And to show you this, I'm going to compile the contract and this time I'll redeploy the test call contract. So I remove this, select test call, deploy, copy the address of the new test call contract, paste it in here and then call call does not exist.
00:07:40.554 - 00:07:43.850, Speaker A: Open the transaction log and you can see that the call failed.
