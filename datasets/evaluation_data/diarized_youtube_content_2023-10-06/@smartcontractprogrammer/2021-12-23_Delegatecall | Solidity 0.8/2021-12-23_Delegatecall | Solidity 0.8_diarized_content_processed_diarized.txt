00:00:00.330 - 00:00:27.318, Speaker A: Delegate call executes code in another contract in the context of the contract that called it. Let's take a look. For example, let's say that A, this can be a contract, or it can be an account. So a calls B and then sends 100 way. Next, B calls C and then sends 50 way. Inside contract C, message sender will be equal to B, message value will be equal to 50. This is because B be sent to C 50 way.
00:00:27.318 - 00:01:13.538, Speaker A: And whatever code that is inside contract C will be executed with the state variables inside contract C. If there's a code inside contract C that queries the balance of EF stored in contract C, or it might send some EF to another contract, then it's going to use the E stored in contract C. This is a regular call. So let's take a look how it's different when we use delegate call. Again, a calls B and sends 100 weight. Now, unlike the first example, this time B delegates call to C delegate call means that it's going to be executing the code inside the contract that is being called with the state variables and other context of the contract that called. So when B delegates call to C, message sender will be a.
00:01:13.538 - 00:01:56.082, Speaker A: This is a little bit surprising since B called C. So we expect message sender to be equal to B. But since we called delegate call here, message sender will be a. This is because when we query message sender inside contract B, it will be equal to a, a called b, and inside b message sender will be equal to a. Delegate call preserves the context. So when B delegates call to C, message sender remains it is still equal to a for the same reason, message value will be equal to 100 a sent 100 way to b. So inside contract b, message value will be equal to 100.
00:01:56.082 - 00:02:58.070, Speaker A: Delegate call preserves the context. So inside contract C, message value will still be equal to 100 code inside contract C will be executed with the state variables of B, and inside contract C, if it sends ether to another contract, or it queries the ether balance inside the contract, then it's going to use the ETH stored in contract b. For this example, we'll call the function setbars and we'll delegate call to this contract test delegate call calling this function. Inside this function, we will set a state variable num to the input num, and then also record message sender and the amount of EF that was sent message value. To use delegate call, we type test delegate call, and similar to call inside here, we abi encode the function that we're going to be calling followed by the parameters that we're going to be passing. The function that we're going to be calling is setbars. So you'll say Abi encode with signature.
00:02:58.070 - 00:03:49.282, Speaker A: The function that we're calling is set bars parentheses and the input is un 256 and for the input we will pass in the num. Now instead of typing a string to specify the function that we're calling, there is another way. So let me show you that. So I'm going to comment this, actually I'm going to copy this, paste it here, and replace this whole line with abi encode with selector parentheses. And then we'll say test delegatecall setbars selector. So these two code will do exactly the same thing. The benefit of writing it this way is that now you don't have to write a string.
00:03:49.282 - 00:04:36.854, Speaker A: So if you change the function signature of testdelegate call setbars, then you don't have to make any change here, whereas if you were to use a string, then you will have to update the function signature of the string. For this example we'll use this syntax, but both syntax accomplish the same thing. Test delegate call returns two outputs similar to call. So it'll be boolean success and some kind of output data bytes memory data. And lastly we'll check that the delegate call was successful by typing require success. Delegate call failed. This should be ABI encode with selector and that is how you use delegate call.
00:04:36.854 - 00:05:07.738, Speaker A: Let's deploy this contract and also this contract and then we'll call the function setbars. I'll hit Ctrl s to compile the contract. We'll deploy delegate call and test delegate call. Scroll down and then open delegate call. We'll call a function setbars and this will delegate call to test delegate call. Execute the code inside here. But since we're delegating call to test delegate call, the state variable that you see over here will not be updated.
00:05:07.738 - 00:05:43.114, Speaker A: Instead, it is the state variable of the contract that called, in this case delegate call that will be updated. I'll copy the address of test delegate call. Paste it here for the input to pass to the function setbars. I'll pass in one, two, three, and we'll also send some ether. We'll send one one one way, scroll down and then call set bars. Check the state variable num and it is equal to one, two, three. The sender that is the account that you see over here and the amount of ether that we sent is one.
00:05:43.114 - 00:06:24.182, Speaker A: One. Since we executed the code inside here using the state variable over here, we expect to see that these state variables inside testelegate call to be uninitialized. So I'll scroll down, expand, test, delegate call, and then call num, and it is still equal to zero. Sender is zero, address, and the value is zero. All of these state variables are uninitialized. Now, using delegate call, we can update this delegate call contract. The state variables will be the same, but the code that we're executing can be updated, which means that we can update this contract even though once this contract is deployed, we cannot change the code inside here.
00:06:24.182 - 00:06:54.100, Speaker A: For example, let's change how the num state variable is set. Previously, we just set it to the input. This time I'll just double it and then set it to num. We'll redeploy test delegate call. But to contract delegate call, we'll use the previous example. So I'll compile the contract and then we'll redeploy test delegate call, hit, deploy, scroll down, and then expand on the contract. Delegate call.
00:06:54.100 - 00:07:51.134, Speaker A: Clear the inputs, copy the address of the new contract test delegate call. This will double the input. Paste it in here, and for the input we'll pass in 100, and then call set bars, get the new state variable, and look, it is equal to 200. What we just did here was we were able to update the logic, the code of delegate call, even though we cannot change any of the code inside this contract. Now it is important to remember that when you're using delegate call to update your contract logic, then all of the state variables have to be the same in the exact same order. So if you were to change the order of the state variables or maybe add a new state variable on top of the old one, then you would see some weird stuff going on with your contract delegate call. And to show you this, I'll add an address, say public, and then owner.
00:07:51.134 - 00:08:28.714, Speaker A: We'll call setbars again and I'll show you that. Now when we call this function, we'll get some weird results. I'll compile the contract and we'll redeploy the new test delegate call contract. Scroll down, clear the input, copy the azure subtest delegate call, paste it here, and then pass in some input for num. Pass in one, two, three again, and then call setbars. Since we passed in one to three, we expect num to be two times one to three, which will be two, four, six. However, if we call the function num, notice that it is still equal to 200 sender.
00:08:28.714 - 00:09:06.102, Speaker A: We expect it to be this account. But if we call sender. Now we get something weird and we set zero for the value. So we expect to be zero, but we get some very large number. The reason why you're seeing some weird results here is because when we added a new state variable on top of the old one, we changed the storage layout. So the code that is being executed here writes to a different storage from the storage that is defined over here. How state variables map to the storage of the contract is an advanced topic that I've covered in another video search for a video about hack solidity accessing private data.
00:09:06.102 - 00:09:24.700, Speaker A: The point is, when you're using delegate call to update your contract code, make sure that the original state variables are declared in the same order. So instead of declaring address public owner at the top. If you preserve the original state variables and then appended new state variables, then this would have worked.
