00:00:00.330 - 00:00:01.950, Speaker A: Let's say that I have 1 million.
00:00:02.020 - 00:00:03.866, Speaker B: Die, and if I were to trade.
00:00:03.898 - 00:00:17.374, Speaker A: This 1 million die for USDC, I will only get about 975,000 USDC. Both the die and USDC are stable coins, so each of these coins will.
00:00:17.412 - 00:00:21.594, Speaker B: Be very close to $1. So ideally, if I were to trade.
00:00:21.642 - 00:00:24.606, Speaker A: 1 million die for USDC, I would.
00:00:24.628 - 00:00:27.330, Speaker B: Like to get 1 million USDC.
00:00:27.490 - 00:00:30.354, Speaker A: However, on uniswap, by trading from Dai.
00:00:30.402 - 00:00:57.646, Speaker B: To USDC, I lose about $25,000. This is where curb finance is a better option for trading tokens. Curve finance allows you to exchange similar value tokens with minimal loss. So here I have three tokens, Dai, USDC, and Ustt. They're all stablecoins pegged to the USD, so all of these will be close to $1. Now, similar to Uniswap, if I were.
00:00:57.668 - 00:01:10.786, Speaker A: To trade 1 million die for USDC, I would get over $1,000,500 worth of USDC, unlike Uniswap, where I would have lost $25,000.
00:01:10.968 - 00:01:46.142, Speaker B: The reason why exchanges on curb is a better deal for similar value tokens can be explained in this graph. Here is the graph of Uniswap. If I were to trade a large amount on uniswap, the token that I want to buy will become more and more expensive. So the bigger amount of token that I try to sell, I will get less amount of token that I want to buy. On the other hand, this is the graph of curb. Notice that in the middle it is kind of flat. This means that if I were to trade in this region, I would get a token swap of almost close to one to one.
00:01:46.142 - 00:02:36.538, Speaker B: We'll cover the details of the math for this curve in another video. In this video, I'll show you how to swap one token for another using biper. The curve contract that we'll be interacting is called stableswap three pool, and the function that we need to call is called exchange. On curb, there are many pools, for example, compound y, buSd, and the one that we're going to be using for this example called three pool. So what is a pool and why is there so many? Each pool holds groups of token that are in similar value. So for example, three pool is a contract where you can swap die, USDC and USDT, which are all about $1 in value. Back in our bipart contract, I defined an interface called stable swap, and the function that we're going to be calling is exchange.
00:02:36.538 - 00:03:15.450, Speaker B: It's going to take in four parameters, the index of the token to sell and the index of the token to buy, the amount of token to sell, and the minimum amount of token that should be returned. Next, I'm going to define some constants. The address of the stable swap contract that we're going to be calling. This is the address of stable swap three pool, and then the addresses of the stablecoins die, USDC and USDT. Next, I've created array holding the addresses of die, USDC and USDT. The ordering matters here. The index of this array corresponds to the index that is referenced here.
00:03:15.450 - 00:04:17.386, Speaker B: So for example, if I were to trade from die to USDC, die is index zero and USDC is index one. So inside this function I will put in zero and one the function that we're going to be calling for. This example, I've named it swap, and it's going to take in two parameters in J corresponding to the index of the tokens that we're trading. Now, I want to get the address of the token at tokens at index I, but the viper compiler is giving me an error, so I'm going to copy the whole array of tokens and the compiler error goes away. Next I'm going to get the balance of token I locked in this contract. When we run the demo, we'll send some tokens before we call this swap function, so that by the time we call this function, bow will be greater than zero. We approve the stable swap contract to spend bow amount of token I from this contract, and then finally call the function exchange.
00:04:17.386 - 00:05:11.454, Speaker B: On the stableswap contract we'll do an exchange from token I to token J, sending all of the token I that we have, and we'll say that the minimum amount of token j that must be returned is one. A minor detail here is that we will need to convert both I and j from un 256 to int one to eight. This is because the exchange function accepts both I and j to be uptype int one to eight. Okay, so now we're ready to simulate this exchange. Let's spin up a main and fork on Ganache and then run this test. This test will swap USDC to USDT and we'll be swapping 1 million USDC. And after the swap we'll be logging out how much USDT we get.
00:05:11.454 - 00:05:40.950, Speaker B: In one terminal I have ganache running on main network, and then inside another terminal we'll run the test. USDT has six decimals, so that is the amount of USDT we got, over 999,000 for a million USDC, so we lost less than $800 for trading 1 million USDC to USDT thanks for watching.
