00:00:00.810 - 00:01:11.290, Speaker A: Starting from this video, I'll walk you through step by step explaining how the multisig wallet is built using react and typescript. Alright, so the first thing that we need to do is install create react app, and we can do that by typing NPMI g create react app next, let's create a react app by typing create react app and the name of the app will be Multisig wallet followed by typescript. So the command that we just typed did two things. First, it created a folder called Multisig Wallet. And inside the multisig wallet folder it initialized the React app using typescript. So I'm going to go into the folder multisig wallet that was just created here. I opened the code editor inside the multisig wallet folder, and on the top left here you can see some files that it created.
00:01:11.290 - 00:01:52.690, Speaker A: If you type in NPM start, this will start a react app. And inside the browser at localhost 3000 you can see that this is the react app. I'm going to hit ctrl C to stop the dev server and we're going to install some NPM packages. We'll first install some libraries that will make the UI look pretty. So we're going to install semantic Ui CSs and semantic Ui react. Next, we'll install some NPM packages that we need to interact with our smart contract. So we will install web3 and this will allow us to connect with Metamask.
00:01:52.690 - 00:02:44.920, Speaker A: We will also install truffle contract which will allow us to interact with our smart contract. And lastly, we will install bn Js. Since JavaScript cannot handle big numbers correctly. Bn JS will take care of this. Alright, so once NPM packages are installed, we'll do some setup for truffle. Here I have my terminal open inside the tooth folder and there are two folders inside the tooth folder multisig wallet which contains the react app that we just created, and solidity multisig wallet which contains the truffle project. And in order to start truffle, I'm going to CD into the solidity multisave wallet and then type truffle develop.
00:02:44.920 - 00:03:43.450, Speaker A: And as a reminder, this will start a local private blockchain inside your computer. Next, I'm going to deploy the Multisig wallet contract onto this local blockchain. By typing migrate. I've opened another terminal inside Multisig wallet and this is the folder that contains the react app. We need to build files from the truffle project which contains the contract ABI and information about where the contract is deployed. So we're going to copy some files from solidity multisig wallet folder into here by saying CP R and we need to go one directory above solidity multisig wallet build. So that's the files that we need to copy and we're going to copy it into current directory source.
00:03:43.450 - 00:04:40.422, Speaker A: So now if you look in the source folder, there's a new folder called build and the file contains the contract ABI and where the contract is deployed. So to show you what the file contains, I'm going to close my terminal and then click on one of the files and this is needed for different programming languages to communicate with the solidity smart contract. And finally I'm going to open the terminal again and then type NPM start which would start the react dev server. Let's quickly go over what we just did. We first started the local blockchain inside the truffle project by typing truffle develop and then we deployed the multisig wallet contract by typing migrate. Next inside our react app. We copied the build file from the truffle project into our react app folder and then we finally typed NPM start to start the react dev server.
00:04:40.422 - 00:05:36.570, Speaker A: Keep in mind that you'll have to do this setup every time you stop the local blockchain and then restart it. The other thing that you'll need to do every time you restart a local blockchain is to reset your metamask account. And what I mean by this is recall that we imported some account from truffle into metamask. So here we have account number two which was imported from truffle and you'll need to reset this account. And the way you would do it is by going to settings, clicking on advance and then hit reset account. Now if you go back you'll see that the transaction history is gone. So why do you need to reset the accounts imported from truffle every time you restart a local blockchain? This is because every time you send a transaction, metamask will increment a special number called nouns.
00:05:36.570 - 00:06:28.874, Speaker A: So for example, if you send five transaction using metamask, the nouns will be equal to five. And this nouns inside metamask has to match the nouns that is kept track on the blockchain. So the problem arises when we send five transactions onto the local blockchain so that the nouns stored both in metamask and the local blockchain are in sync. But after we restart the local blockchain, the nouns on the local blockchain will be equal to zero. But here inside metamask it will still equal to the previous nouns, so that the nouns on the local blockchain and metamask are not in sync. So remember to reset your truffle account every time you restart the local blockchain. Now you won't need to do this when you're sending a transaction to a live network such as the Robston or the mainnet.
00:06:28.874 - 00:07:24.260, Speaker A: And the reason is because those blockchains will never be reset, so that the nounces stored in metamask and the nounses stored on the blockchain will never go out of sync. Okay, let's now build a front page. So open the file index TSX and the first thing that we need to do is import CSS from semantic UI and this will make our UI look pretty. So here we say import semantic UI CSS and the CSS file where semantic UI CSS is one of the NPM packages that we installed. Next, open the file app TSX. And what you're seeing here is what is being rendered here. So if you change the code inside here, then the changes will be reflected here.
00:07:24.260 - 00:08:07.162, Speaker A: And to show you this, I'm going to remove all of the stuff inside here. Save it. When we go back to our app, you can see here that everything's been deleted. And as you can see here at the moment it is a blank screen. So I'm going to edit the CSS to make it a light background back in our code editor Openapp CSS, and we'll delete all of this and we'll paste in the CSS that I already prepared. Since CSS isn't the focus of this video, I'm just going to skip the details on what the CSS does. When you go back to the app, you can see that now it is a light background back inside app TSX.
00:08:07.162 - 00:09:04.260, Speaker A: We'll render a header called Multisig Wallet. Next, we'll want to render the current account like this, and we'll initialize the account variable as a placeholder for now and say something like zero X 123456 later we'll actually fetch the account from Metamask and then render it here. But for now, the variable account is just a placeholder. Next we'll render a message saying Metamask is not connected. And we'll also render our button to connect to Metamask. And this message and button component comes from semantic UI. So we'll import them above, hit save and let's see what the app looks like.
00:09:04.260 - 00:09:48.480, Speaker A: So this is what the app looks like. Now the next thing that we'll do is create two functions, one to connect to Metamask and another to monitor for the changes in account in metamask. And we're going to be using web3. So back inside the code editor, I created a folder called API and then a file called Web three Ts. This is just how I organize my code, so feel free to change things around. What I'm doing here is I put all functions that make external calls inside the folder API first, inside the web3 Ts. We're going to import web3 by saying import web3 from web3.
00:09:48.480 - 00:10:55.670, Speaker A: The next thing that we'll do is create an async function called unlock account and we'll export it. And this function will ask metamask to unlock account and then initialize a web3 instance that we could use throughout the application. We'll try to get the variable ethereum from the window, and we'll throw an error if the variable ethereum is not found. One thing to note here is that I put at Ts ignore, and this is a handy way to stop typescript from compilation errors. So here you're just telling typescript to ignore whatever errors that may arise from this line of code from the Ethereum variable. We'll initialize a web3, and this instance of web3 will be used to interact with our smart contract. Now, to unlock the account protected by Metamask, we'll need to call Ethereum enable, and when this function is called, it would pop up a metamask asking for your permission to let this app connect to Metamask.
00:10:55.670 - 00:11:49.590, Speaker A: Once the metamask accounts are unlocked, we'll get the accounts by calling web3 e getaccounts. And finally, we'll return the instance of web3 and the first account. Now, if the account is empty for some reason, we'll just return an empty string, and that completes the code that will unlock an account protected by Metamask, initialize a web3, and then return the web3 and an account. Now, you really don't need to understand what's going on here. This is just like a ceremony that you need to do to get things started. And I got this code snippet from the metamask documentation, so I'll put the links here and you can check it out later. Next, let's work on writing a function that will monitor the changes to metamask so that if the account changes, then we'll be notified.
00:11:49.590 - 00:12:51.542, Speaker A: So I'll name this function subscribe to account, and it's going to take in a web3 instance and a callback, and the callback is going to either take in an error or account and you can do anything with it. In our case, we'll be reloading the page when the account changes, and I'll show you the code for that later on. So how do we keep an eye on what the current account of Metamask is? One way to do it is to get the accounts every second and then return the account as a callback. And that's what we're going to be doing here. Here we'll say set interval and the function to be called and the interval in this case 1 second. So what this code will do is call the function inside here every 1 second. And the function that we need to call inside here is to get the current account and then pass the account to the callback.
00:12:51.542 - 00:13:39.514, Speaker A: And we can accomplish that by calling web3 e getaccounts and then calling the callback. Since there's no error, we'll return a null and we'll return the first account. Lastly, this function may throw an error, so we'll wrap it in a try catch so that the code now looks like this, where this is the code that we previously had. And when this blockup code fails, we'll catch the error and then call the callback with the error. Now this function will run indefinitely and it will never stop, but we probably want a way to stop this function. So here's how we do that. The function set interval returns an id that we could later reference to stop this function.
00:13:39.514 - 00:14:28.870, Speaker A: So we'll capture the id in a constant called id. So we can stop this function by calling clearinterval. But here we'll return a function that calls clearinterval, since we don't want to stop this function right away, but instead we want the ability to be able to stop it whenever we need. And the way you would do it is by wrapping it in a function to be called for later, and that completes the function that will keep track of the current account in metamask. So we've completed the function to get a web3 instance and also to get the current account. Now we need a way to store these variables in our app. And where are we going to store these variables in our react app? We will store them using context.
00:14:28.870 - 00:14:41.180, Speaker A: We covered a lot of ground and I think this is a good point to stop. So in the next video we'll use react context to store the account and the web3 instance. See you in the next video.
