00:00:00.570 - 00:00:37.506, Speaker A: Let's implement the library for tick bitmap. In this video we'll implement the function for position, a function that will split the tick into two parts, the word position and the bit position. And we'll also implement the function to flip a tick given the tick bitmap. Let's start with the function position. So again, this function is going to split the tick into the word position which will be int 16 and the last eight bits of bit position. To get the word position this will be the first 16 bits from int 24 tick. And all we have to do is shift the tick over to the right by eight bits.
00:00:37.506 - 00:01:04.414, Speaker A: So we'll say word position is equal to shift the tick by eight bits to the right. And we do that by just simply shifting the tick by eight positions. And now the tick is int 24. So we'll cast this into int 16 int 16. Okay, so this is the word position. Let's next get the bit position. Again, the bit position is the last eight bits of the tick.
00:01:04.414 - 00:01:39.162, Speaker A: And to get this all we have to do is use the math operator mod say bit position is equal to tick mod 256. Why are we modding it with 256 here? Well, it's because two to the eight is equal to 256. By using the map operator mod on the tick we'll be able to get the last eight bits. Now again, the tick is int 24, so we'll need to cast this to un eight. To do this, we'll first cast the tick into Un 24. Then once we have a Un 24, we'll cast this into un eight. Un eight.
00:01:39.162 - 00:02:05.518, Speaker A: Okay, so this is how we split the tick into two parts, word position and bit position. Next, let's take a look at the function flip tick. So this function will take in the tick bit map that you see over here. We named itself. It's going to take in the tick to flip and the tick spacing. So recall that in uniswap b three when we do a swap, the tick does not necessarily update by one. The tick actually updates by tick spacing.
00:02:05.518 - 00:02:50.158, Speaker A: So let's say that you do the trade and the current tick crosses over the upper tick. The next upper tick will not necessarily be the upper tick that we just crossed now plus one. Instead, it will be the upper tick that we just crossed plus tick spacing. So first we'll require that this tick is a multiple of tick spacing. And we do that by saying require tick mod tick spacing is equal to zero. Next we'll get the word position and the bit position by calling the function position. So int 16 word position and un eight bit position is equal to call the function position with the current tick tick.
00:02:50.158 - 00:03:33.406, Speaker A: Okay, to flip a tick we first need to create a mask. This mask will be one at the bit position and everything else will be a zero. And this mask will be a u into two five six. So say un two five six mask is equal to one at the bit position and we do that by shifting one by bit position bit position and lastly, to flip a tick we first access the tick bitmap self at the word position word position. This will give us a un value and this un value represents where the ticks exist. This Un 256. We can think about it as a sequence of zeros and one having the length 256.
00:03:33.406 - 00:04:07.170, Speaker A: If it has a zero at some position then that means that the tick does not exist and if it is a one then it means that the tick exists. And to flip a tick all we have to do is XOR. So I'll put a carrot sign here and then xor it with the mask and that completes the function for flip tick. Let's try compiling this contract inside my terminal. I'll type forge build and our contract compile. In the next video we'll continue working on the library tick bitmap and we'll write the function that will find the next tick.
