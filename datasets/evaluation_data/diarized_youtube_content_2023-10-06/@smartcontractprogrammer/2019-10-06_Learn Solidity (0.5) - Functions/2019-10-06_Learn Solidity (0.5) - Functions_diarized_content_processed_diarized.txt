00:00:00.330 - 00:01:07.540, Speaker A: You the syntax for declaring a function in solidity is straightforward function name, data type, and variable name for each input, other declaration like the keyword public view, peer, and the type of outputs to return. And we'd be done with this video if solidity functions were like other programming languages. In programming language like JavaScript, function can take in data type like array and maps as input and also return them as output. However, you might be surprised and not amused to find out that in solidity, public functions cannot accept certain data types as input, and you also cannot return certain data type as outputs. So in this video, let's explore the restrictions on the type of inputs and outputs for a public function and go over data types that you can use but you really shouldn't use, or at least be extremely careful. We'll also go over the syntax for returning multiple outputs from a function. This is a useful feature when you want to aggregate multiple function outputs into a single function call.
00:01:07.540 - 00:01:51.566, Speaker A: In solidity, you can pass certain data types as input to a public function. Some data types that you cannot use are map and multidimensional array without a fixed size let's see what happens if you try to compile a contract with these invalid inputs. Here we have a function that takes a map as input. Let's try compiling the contract. You'll get an error like the one you can see here. How about multidimensional fixed sized array? Will it compile? It did. How about multidimensional dynamic sized array? Will this compile? Try compiling the contract and you get an error like the one you can see here.
00:01:51.566 - 00:02:28.570, Speaker A: The error message states that if you change the pragma to experimental AVI encoder version two, then the function is valid code. Here. I've done exactly that. Change the pragma inside the contract. But as you can see here in the warnings, you should not deploy a contract with experimental features to the main net. How about a regular one dimensional array? Will it compile? It does. So we've seen public functions can take array as input, but should you write functions that take array of arbitrary size? In most cases, the answer is no.
00:02:28.570 - 00:03:11.766, Speaker A: The reason is simple gas. The bigger the array is, the more gas it will use. The function would complete successfully for some arrays and fail for other inputs depending on the size of the array and how much gas is available. As a developer, this is difficult to predict upfront, and it goes against the best practices to write smart contracts that are simple, reliable, and with predictable outcomes. One way to make this function more reliable is to require that the size of the array is less than some fixed number. This would put an upper bound to the amount of gas this function can possibly use. Limitations on the outputs of a public function is similar to that of inputs.
00:03:11.766 - 00:04:11.790, Speaker A: Outputs of type, map and multidimensional array with dynamic size do not compile. Let's try them out in remix back in our contract, first declare some data types, a map, an array, a multidimensional array of fixed size, and a multidimensional array without a fixed size. Next, let's see if these functions that return different data types can compile. Try compiling. You would see errors next to the function that returns a map, and also next to a function that returns a multidimensional array. You will also see error messages here below the compile button, and these errors are similar to the ones we saw with invalid inputs. Solidity has no problem compiling a function that returns an array, but should you write a function that returns an array of unbounded size? Again, the answer is probably not what can go wrong? Imagine there are two contracts, a and b.
00:04:11.790 - 00:05:04.970, Speaker A: Contract a has a function that returns an array of addresses. This function does not create any transactions, so you don't have to worry about gas, right? Wrong. Why? Imagine contract b has a function that calls contract a to get the array of addresses and does something with it, like sending ether to each address. Now, what would happen if the array of addresses in contract a is huge and contract b tries to get it? The function in contract b will fail every time, and many people are unhappy that they can't receive their ether. So to summarize, when writing smart contracts, you'd rather be safe than sorry. And one way to be safe is to write functions that have a bounded consumption of gas. Solidity's limitation on public function is inconvenient.
00:05:04.970 - 00:05:52.058, Speaker A: But one useful feature of solidity is that you can return multiple values, and as a bonus, they can be named. Let's see an example. In remix, you can declare that a function is returning multiple values by listing the types of values inside the parentheses after the return keyword inside the function, you list the values to return. Outputs can also be named like this. Also, you can explicitly assign to return variables and omit the last return statement. When is it useful to return multiple outputs? It's useful when you want a function that collect outputs of several functions and return all of them in a single function call. Let's say that we have functions f and g.
00:05:52.058 - 00:06:36.140, Speaker A: One way to get the outputs of f and g is to call the functions individually. That's two function calls. Another way is to write a function that calls f and g and returns the two outputs in a single function call. How do you assign variables to the output of a function that returns multiple values? You use destructuring assignments. It's easier to understand by example than to explain what it is, so let's go through an example using actual code. Here we're assigning the outputs of the function return multiple bells. Notice that the type of variables declared here on the left side is consistent with the type of values being returned from the function being called.
00:06:36.140 - 00:07:10.070, Speaker A: You don't have to assign all values if a function returns three parameters, but you don't care about the second output. This is how you do it. Here you're telling solidity that you need the first output, not the second. So you omit declaring the type and naming it, and you also need the third output. In this video, we try to compile public functions with different data types as input and outputs. In both cases, maps can't be used. Multidimensional fixed size arrays can be used.
00:07:10.070 - 00:07:38.634, Speaker A: Multidimensional dynamic sized arrays cannot array compiles. But be careful and you should put an upper bound to the array size. We also learned how to write functions that return multiple values. These outputs can be named or assigned. Finally, we saw how to assign variable from a function that return multiple values. Thanks for watching. In the next video, I plan to cover peer and view functions.
00:07:38.634 - 00:07:41.530, Speaker A: Have a nice week and see you soon. Bye.
