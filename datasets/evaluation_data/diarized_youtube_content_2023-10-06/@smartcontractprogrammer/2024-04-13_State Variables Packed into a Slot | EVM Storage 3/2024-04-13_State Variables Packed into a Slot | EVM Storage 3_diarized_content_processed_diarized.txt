00:00:00.360 - 00:00:38.334, Speaker A: In EBM storage, data that are less than 32 bytes are packed into a single slot, if that is possible. In this video we will take a look at how to read and write from a state variable that is packed into a single slot. And to do this we will be using some of the bitmasking tricks that we learned in the previous video. And for the last part of the video, I'll also show you how to do the same thing using slot and offset. These are property of the state variable that we can access inside assembly. So let's start by declaring some state variables that will fit inside a single stock. The first one will be obvious since it is the first state variable that is declared inside this contract.
00:00:38.334 - 00:01:22.774, Speaker A: So instead of declaring this as UN 256, I'll declare as a number that is smaller than UN 256, so that we have some data inside slot zero, and we'll be able to declare more state variables that will fit inside zero. So the first one I'll declare as UN 128. If we declare this as Uint 256, it will use up all of slot zero, so we'll use only half of it. So I'll declare it as Uint 128. Un 256 will use up 32 bytes, so half of that will use up 16 bytes. This will be a public state variable, and for this example I'll name it s a. For this example, I'll prefix state variables with s to indicate that it is a state variable.
00:01:22.774 - 00:02:02.820, Speaker A: This first state variable is in slot zero. Since we didn't use up all 32 bytes, we can still declare some state variables as long as it fits inside slot zero. So say unint let's declare 64 public sb the first state variable, use up 16 bytes, so we still have 16 bytes that we can use up. A easier way to count is by bits. We use the 128 bits. We still have 128 bits that we can fit inside slot zero. So let's declare two more unint 32 public s c we still have 32 bits that we can fit inside slot zero.
00:02:02.820 - 00:02:34.304, Speaker A: So I'll declare another state variable, un 32 public SD. So all of these state variable will fit inside slot zero. And this is because when we add up all of the bits, the number of bits will be 256 bits, which fits under 32 bytes. Okay, let me give you another example. Let's store some state variables that will be packed inside slot one, slot one. So for example, we can have an address public. I'll name it s addr.
00:02:34.304 - 00:03:03.790, Speaker A: Now, an address takes up 20 bytes and this will be equal to 160 bits. An easy way to remember is that when you have bytes multiply by eight to get the number of bits. So we used up 160 bits. We can fit up to 256 bits. So we still have 96 bits, 96 bits left over. So for example, we can declare un 64 public. Let's call this s sub x.
00:03:03.790 - 00:03:49.744, Speaker A: And we still have 32 more bits that we can fit inside slot one uint 32 public s of white. Okay, so these are some examples of state variables that are packed inside a slot. Next, let's take a look at how we will read and write from these state variables. So declare a function test s store public, assign bully. First thing that I'll do is load up 32 bytes from from slotzill. Let b is equal to sload from slot zero. Again, sload will load 32 bytes from the storage, and the 32 bytes are loaded from slot zero.
00:03:49.744 - 00:04:20.988, Speaker A: Inside slot zero we have all this data. Let's update some of these state variables. Here's the layout of this 32 bytes stored in the variable b. State variables will be packed from right to left, and the first state variable that we declared is s sub a s a. It takes up 128 bits. And then to the left of this we have the state variable s b, which would take up 64 bits. And then to the left of this we have s c 32 bits.
00:04:20.988 - 00:04:51.366, Speaker A: And finally we have s d 32 bits. I'll show you some examples of how to read and update these statements. Variables and the data that we'll be updating is this variable b. And at the end we'll update the whole state variables by saying s store at slot zero. Update it by the new value of v. So for the first example, let's update the state variable s a. This is the first state variable that is declared, and it is stored in slot zero.
00:04:51.366 - 00:05:41.426, Speaker A: So far, the variable b is 32 bytes, and the layout looks like this. Now, if you wanted to update the first 128 bits, we first need to create a bitmask that will clear out the first 128 bits, and then we'll put in a new value for the first 128 bits, counting from the right and going left. So let's start by creating a bitmask. The bitmask that we want to create looks like this. Starting from the right, it will be 128 bit zeros followed by all ones. Okay, by creating this bitmask and then doing a bitwise and with our variable b, you'll be able to clear out the first 128 bits. I'll declare a variable called that mask a is equal to we want to create a bitmask that looks like this.
00:05:41.426 - 00:06:18.500, Speaker A: And to do this, we first want to create a one at the 128th position and all zeros. This trick was covered in the last video. So shift left 128 bits by one and then to create all ones over here, what we need to do is subtract this by one sub one. Currently we have all ones over here and all zeros over here. To flip this so that we have all ones over here and all zeros. All we have to do is invert this by using the note bitwise operator. Okay, once we have the mask, we can now clear out the first 128 bits.
00:06:18.500 - 00:06:50.564, Speaker A: So I'll say b is equal to and the current value of b bit wise and with the mask a. So this will clear out the first 128 bits. And this stores the data for the state variable s a. And finally, we can write something new inside the state variable s a. So for example, let's put a number eleven inside here. So say b is equal to this time you'll use the bitwise operator or, or b. Let's put in 1111.
00:06:50.564 - 00:07:19.898, Speaker A: When this part of the code executes, it will clear out the first 128 bits. It will be all zeros. In the next line we do a bitwise, or when we do a bitwise or with a zero, we're just going to get this data that we stored inside here. So in the first 128 bits we'll be storing eleven. Okay, let me give you another example. Let's store some data into the state variable s b. For this example, let's store number 22.
00:07:19.898 - 00:08:05.136, Speaker A: Again, we will be using the bitmasking check to clear out some bits. In this case the state variable Sb. If you go back over here, the first 128 bits belongs to the state variable sample, and then the next 64 bits belongs to the state variable S B. So to update this state variable without affecting the other ones, we need to create a bitmask where it is all zeros over here. So we will have 128 bits of ones followed by 64 bits of zeros and then followed by all ones. We create this bitmask so that we would clear out this part of the data, and then we will store something new inside here. So let's start by creating a bitmask.
00:08:05.136 - 00:08:50.816, Speaker A: Say that mask b is equal to. Again, we'll use the bitmasking tricks that I showed you in the previous video. So to first create a 64 bits of one, I'll do shift left 64 one and then sub one from this. So so far we have 64 bits of ones starting from the right and going towards left. Next, I want to shift this over to the left by 128 bits so that what you have is something that looks like this. Shift this bitmask to the left by 128 bits so that we have 128 bits of zeros followed by 64 bits of ones. To do this, all I have to do is shift this bitmask to the left by 128.
00:08:50.816 - 00:09:24.064, Speaker A: Okay, so this part of the code will produce a mask that looks like this. And finally, to create a mask like this, all you have to do is invert this mask. Not once we have the bitmask, we'll do the same thing as we did in the previous example. We'll use the bitwise n to clear out this state variable s b. So b to the value b. Assign a new value by using bitwise n with the current value of b, apply the mask b. This will clear out the data that is stored over here.
00:09:24.064 - 00:09:59.804, Speaker A: Okay, and lastly, to store a new value, we will say b is equal to four the current value of b. We're going to store 22. So we'll say 22. Now, if we just did 22, this will store 22 in the first 128 bits. So to store 22 over here, we'll need to shift this number by 128 to the left. Shift left one, 2822. Okay, so that's an example of storing the number 22 to the bits where it corresponds to the state variable s b.
00:09:59.804 - 00:10:29.838, Speaker A: Let's do something similar to the state variable s c. So I'll just copy this and then paste it here. So this time we'll be storing, we'll be setting the state variable S C. Let's put a 33. The mask that we'll need to create will look something like this. 128 bits of ones followed by 64 bits of ones, followed by 32 bits of zeros, and then followed by ones. The state variable S C, if we go back up, will look like this.
00:10:29.838 - 00:11:17.898, Speaker A: You have 128 bits for S a, 64 bits for S B, and then 32 bits for S C. This is the state variable that we want to update. So what we need to do is create a mask that will look like this. 32 bits of zeros in the middle, followed by 64 bits of ones, and then followed by 128 bits of ones. I'll call this mask mask C. And from the previous example, what do we need to change so that we will have 32 bits of ones over here? Well, to create 32 bits of ones, we first need to modify this 64 to 32, so the code over here will produce 32 bits of ones. Next, we need to shift this over by 128 plus 64.
00:11:17.898 - 00:11:57.940, Speaker A: So that is 128 plus 64 is 192. And then lastly, we will need to invert this so that it will be zeros over here. And we do this by using a not operator. Okay. To clear out the value that is stored over here, we will use the bit wise end with the mask C, and we're going to be storing the number 33. But like in the previous example, if we just store 33, then what's going to happen is it's going to store 33 over here in the first 128 bits. So we'll need to shift this 33 by 128 bits plus 64 bits.
00:11:57.940 - 00:12:37.154, Speaker A: So shift this number, shift left by 192. Okay, so that's an example of storing the number 33 to the state variable s C. For the last part, let's store something into the state variable s d. So if you look at s D is the last state variable and it occupies the last 32 bits, I'll copy this example again and then we'll modify it to s D. That's store 44. Since s D is gonna occupy the last 32 bits, you'll need to create 32 bits of zeros followed by all ones. So I'll call this mask mask D.
00:12:37.154 - 00:13:05.610, Speaker A: Now, there are other ways to create this bitmask, but we'll just modify the previous example to create a bitmask that looks like this. This part of the code will create 32 bits at once. And then you'll need to shift this over to the left by 128 plus 64 plus 32. 128 plus 64 is 192. So to this we need to add 32. This will be a four, and this will be 224. Okay.
00:13:05.610 - 00:13:47.588, Speaker A: And to the current value of b, we add this new mask to clear out the last 32 bits. And then to update it, let's update this to 44. And again, we'll need to shift this number 44 so that the number 44 will come over here like this. So to do this, we'll need to shift this 44 by 128 plus 64 plus 32, which is 224. Okay, so this part of the code will update the last 32 bits and store the number 44. And lastly, don't forget to store the new value of this value b. By calling sstore to slot zero.
00:13:47.588 - 00:14:01.884, Speaker A: Store the value b. I made a mistake. This add should be. And, and the same goes over here. And the same goes over here. Okay, let's try compiling the contract. And then deploy the contract.
00:14:01.884 - 00:14:36.148, Speaker A: And then let's call the function test s store. So this will set the state variable s a to eleven. Set the state variable s b to. Next, I'm gonna show you the same example. And instead of hard coding the slots and the offsets for the state variables. We will be using the property called dot slot and dot offsets that are available for state variables inside assembly. So first I'll copy this and then paste it here.
00:14:36.148 - 00:15:28.364, Speaker A: I'll call this function test s store using offset. Okay, so what I mean here is that inside assembly we can use the properties dot slot to get the slot where the state variable is stored and dot offset to get where inside the slot where the state variable starts. So for example, before we modify this function, first I'm going to show you some examples of the offset I created a function called test zero offset. And what we're simply going to do is return the offset of the state variables. So I'll say inside assembly you can access the property called offset that is available for the state variable. We'll say a offset is equal to s underscore a. S underscore a is the state variable dot offset.
00:15:28.364 - 00:16:09.492, Speaker A: And I'll do the same for all of the state variables that is stored in slot zero. Okay, I'll compile the contract and then we'll execute this function, call the function test slot zero offset, and I get these values back. So these are the values that I get for the variables a offset, b offset, c offset, and d offset. For a offset, we get a zero. This zero means that this state variable a is stored in zero and it has an offset of zero. So it means that our state variable starts from zero bytes. For bits.
00:16:09.492 - 00:17:02.022, Speaker A: We would times this by eight and get from zero bits. The next state variable s underscore b has an offset of 16. So this means that 16 times eight is 128 bits. So this means that our state variable b will start after 128 bits and likewise the next 124 will be 24 times eight and this will be equal to 192 bits. So the state variable s c will start after 122 bits, and the last one is 28 28 times 828 times eight is equal to 224 bits. The last state variable s d would start after 224 bits in slot zero. So this is offset.
00:17:02.022 - 00:17:43.840, Speaker A: Now let's go back to our example to rewrite our example of reading and writing from a state variable in a single slot using slot and offset. Instead of loading from slot zero, we'll replace this with s a dot slot. This will hold the value where this state variable s a is stored. In this case, this will be zero. Okay, the first state variable we know that starts from offset zero, so we won't modify it. Let's start by modifying this example to create a mask for mask b. We shifted this mask by 128 bits, but we can actually replace this using offset.
00:17:43.840 - 00:18:13.828, Speaker A: So what was the b's offset? If I scroll back up, B's offset starts at 128 bits. So over here. And to get this 128, we had to multiply the s underscore b dot offset by eight. And then we'll do the same over here. Multiply s b dot offset by eight. Okay, let's do the same for the state variable s c. Going back up again.
00:18:13.828 - 00:18:46.980, Speaker A: I'll just copy this and then I'll paste it here. We hard coded the bits to shift as 192. Let's replace this hardcoded 192 using offset. C's offset returns 24. And to get 192 bits we need to multiply this by eight. So c dot offset by eight and we'll do the same over here. Multiply s underscore c dot off offset by eight.
00:18:46.980 - 00:19:20.360, Speaker A: Okay, let's do the same. For the last example, to get an offset of 224 bits, what we do is multiply s d offset by eight and the same over here. Multiply s underscore d dot offset by eight. Let's try executing this function. Hit Ctrl s to compile a contract. Then we'll redeploy a new contract and then call the function test s store using offset. And let's see what the state variables are.
00:19:20.360 - 00:19:47.984, Speaker A: S a eleven s b so in this video I showed you some examples of how to read and write from state variables that are packed into a single slot. And the way we did it was by using tricks that we learned for bitmasking. And the other thing that I covered is how to replace hard coded offsets by using the property slot and offset that are available for state variables.
