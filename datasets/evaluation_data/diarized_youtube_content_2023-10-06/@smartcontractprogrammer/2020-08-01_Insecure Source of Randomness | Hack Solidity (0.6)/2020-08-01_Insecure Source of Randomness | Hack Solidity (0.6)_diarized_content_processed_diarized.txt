00:00:00.490 - 00:00:44.906, Speaker A: Let's say that you're building a program that needs an element of randomness. For example, you're programming a lottery and you need a way to pick a winner randomly. Using programming language like JavaScript and Python, it is straightforward task to generate a random number. However, generating a secure random number in solidity is extremely difficult. Now, you might think that block hash and the timestamp at which the block was created is a good source of randomness. So in this video I'm going to explain why block hash and block timestamp are not good sources to generate random number. First we'll walk through a contract that uses block timestamp and block hash to generate a random number.
00:00:44.906 - 00:01:33.626, Speaker A: And then I'll explain how we can exploit this contract. After that I'll show you a demonstration in remix guess. The random number is a contract where if you can guess the correct random number, then you will be rewarded with some ether stored in this contract. How does it generate the random number? Well, let's take a look at the function guess. Here is the code that generates the random number. It uses the block hash of the previous block, and this can be obtained by calling block hash and then specifying the block number that you want to get the hash for. Here we're saying that we want the block hash for the previous block by saying block number which gives the current block and then minus one to get the previous block number.
00:01:33.626 - 00:02:10.870, Speaker A: We're also using block timestamp for the source of randomness. Block timestamp will give the timestamp at which the current block was created. We use these two inputs as our source of randomness and then hash it and then convert the hash into un. So that is how the random number is generated. And if your guess is equal to the random number, then you will be rewarded with one ether. So that is how this function works. At first glance, these two variables look like a pretty good source of randomness.
00:02:10.870 - 00:02:57.766, Speaker A: Block that timestamp is the timestamp at which this transaction will be included in a block. So when we call this function guess, a transaction will be sent to the ethereum blockchain to run the code inside guess. So the code inside here will be executed, and after the code is executed it will be included in a block. Now this timestamp for the block will be in the future, so we won't know what this value is until this transaction is included in a block. So this makes it look like block. That timestamp is a good source of randomness. Block hash is computed by using a hash function and we know that the outputs of hash function behave like random numbers.
00:02:57.766 - 00:03:54.930, Speaker A: This is because the output of a hash function is hard to predict from the input. Therefore, using block hash as a source of randomness seems like a good idea. Now, the reason why we're using the block hash of the previous block here is because the block hash of the current block is not available when we call this function. The reason why the current block hash is not available when we call this function is because the block hash is calculated by the transactions in that block. When we send a transaction to execute this code, this transaction will be one of the inputs to calculate the current block hash. So the current block hash will be unavailable when this code is executing, and it will be available only after this transaction is included in a block. So that is why here we're using the previous block hash instead of the current block hash.
00:03:54.930 - 00:04:54.390, Speaker A: These two variables seem like they're difficult to know in advance, but let's now examine how these two variables are actually easy to know in advance. The key insight here is that these two variables are easily available to smart contracts. So what this means is that to us humans, these two variables are hard to predict, but we can access them easily by writing another smart contract. So that is what we'll do to correctly guess the random number calling this function from another smart contract which has access to these two variables. The function named attack, which is going to call the guess function above, is going to take in a single input. The single input that we're going to pass to this function is the address of the guess the random number contract above. First, we'll compute the correct random number somehow, and then submit our answer to the guess the random number contract.
00:04:54.390 - 00:06:05.010, Speaker A: So the big question is, how do we compute the correct answer? Well, we can simply get the correct answer by copying this code and then pasting it here. So how does this hack work? Let's walk through step by step. Notice that when eve calls this function, the code inside here and the code inside here will be executed in the same block. What this means is that block timestamp and block hash over here and the block timestamp and block hash over here are exactly the same. So when eve calls this function, the answer that is computed over here and the answer that is computed over here will be exactly the same, and Eve will be able to win the reward every time she plays this game. Before we deploy this contract, there's one other function that we need to declare inside here, and that is a fallback function, so that when this contract sends one ether. We need a fallback here in order to receive the ether.
00:06:05.010 - 00:06:49.210, Speaker A: And lastly, we'll add a helper function to check the balance of this contract after we win the game. Before I show you a demo in remix, we'll need to run a local blockchain using Ganache. And this is because block hash is not available inside remix. When you try to run these contracts inside remix, you'll get an error like this. So that is why we'll need to run a local blockchain using Ganache. So first of all, install Ganache Cli by typing G ganache Coi. Once that is done, run the local blockchain by typing ganache Cli.
00:06:49.210 - 00:07:42.570, Speaker A: Now we have a local blockchain running on localhost port a five, four, five back inside remix. Click on the deployment tab over here and then we'll switch over the blockchain to web3 provider. And notice here that this matches the URL where the local blockchain is running. So we'll hit OK, and we're now ready to deploy the contract and play around with them. First, Alice is going to deploy the guess the random number contract, and for the reward she's going to deploy it with one ether. Next, Eve is going to deploy the attack contract. And now we're ready to see the contracts in action.
00:07:42.570 - 00:08:30.460, Speaker A: Now, normally if you play this game, you have a one in two to 256 chance of winning. But using the attack contract, we'll be able to guess the correct number 100% of the time. To call the attack function, we'll copy the address of the game contract, paste it in here, and then call attack. And you can see here that the attack was successful. So let's check the balance of the attack contract and we have one ether. That was a demonstration of what, at first glance, seems like a good source of randomness can easily be computed it by using another smart contract. So the lesson here is that the source of randomness for a smart contract is difficult to get right.
00:08:30.460 - 00:08:33.160, Speaker A: All right, thanks for watching and see you later.
