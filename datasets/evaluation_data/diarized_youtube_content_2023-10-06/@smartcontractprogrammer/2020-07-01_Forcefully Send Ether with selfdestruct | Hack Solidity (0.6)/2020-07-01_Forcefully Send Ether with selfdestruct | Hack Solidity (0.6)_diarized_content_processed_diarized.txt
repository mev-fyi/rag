00:00:00.490 - 00:00:56.250, Speaker A: Over here, I have a contract called foo, and this contract cannot receive any ether since it doesn't have any payable fallback function, or a payable constructor, or a payable function. But when we check the balance of this contract, you can see here that this contract has one ether. So how was this contract able to receive one ether even though it doesn't have any payable function? So in this video, I'm going to show you how to forcefully send ether to another contract using self destruct. And then we'll code an example. And lastly, we'll talk about how to protect your contract from this hack. All right, so first let's talk about how this contract foo was able to receive ether using self destruct. What does the function self destruct do? Basically, self destruct deletes the contract from the blockchain.
00:00:56.250 - 00:01:48.590, Speaker A: Here we have contract bar. When the function kill is called, it calls selfdestruct and this would delete this contract bar from the blockchain. The function self destruct requires one input. Here you need to pass in an input of type address, and this will send ether stored in this contract to the address that is given here, regardless of whether the contract at this address has a payable fallback function or not. So this means that we can forcefully send ether to any address by calling self destruct and then setting the address here. And this is how contract foo above has one ether, even though it doesn't have any payable function. That's how you forcefully send ether to any contract, even contracts without payable functions.
00:01:48.590 - 00:02:26.998, Speaker A: And using this idea, I want to show you a little bit more sophisticated example. Ether game is a contract where the 7th person to deposit one ether becomes the winner, and the winner can claim the seven ethers stored in this contract. To play this game, the player will call the function deposit. They'll have to send one ether. If the current balance of ether stored in this contract is greater than seven ether, then the game is over. So after seven ether, no one should be able to send more ether. If the current balance is equal to seven ether, then we set the winner to message sender.
00:02:26.998 - 00:03:08.134, Speaker A: In other words, here we're saying that if message sender is the 7th person to deposit one ether, then that person becomes the winner. The winner of this game can claim the rewards by calling the function claimreward. This will send all of the ethers stored in this contract to the winner. That is how this ether game contract works. Let's now write a contract that can break this game. The basic idea is to use self destruct so that the balance exceeds the target amount of seven ether. By doing so, the balance will never equal to the target amount and the winner will never be set.
00:03:08.134 - 00:03:45.800, Speaker A: No one will be able to call the function claim reward, and all of the ethers from the players are stuck in this contract. That's the basic idea of how this contract can be broken. Let's now write this in code. The contract attack will have a single function named attack. And this is the function that we're going to be calling in order to break the contract above. For the input, we'll pass in the target address and then declare it as payable. The reason that the target address is payable is because the address that we pass into self destruct must be a payable address.
00:03:45.800 - 00:04:28.690, Speaker A: We'll send ether to this function and then have that ether forcefully sent to the contract above. So here we'll declare it as payable. Inside the function. We'll call self destruct and then pass in our target address. This completes the contract that's going to break the ether game contract above here, I've deployed two contracts, ether game and the contract that's going to be attacking ether game. We'll say that account one is Alice, account two is Bob, and account three is EB. So first of all, let's say that EB is going to play this game and she's going to deposit one ether.
00:04:28.690 - 00:05:16.750, Speaker A: So she calls deposit. Bob also wants to join in, so he also deposits one ether. At this point, the contract has two ethers, and Alice and Bob are trying to become the 7th person to store one ether, become the winner, and claim the seven ethers. Now, Eve is not a nice person and she decides to break this game. She knows that there are two ethers in this contract. So if she forcefully sends five ether at once, then she can break the game. And this is because in order for players to become the winner, they'll have to call the function deposit and also send one ether.
00:05:16.750 - 00:06:12.834, Speaker A: But after Eve sends five ether, the balance will be seven ether. So the balance here will be greater than seven ether since Eb forced it to be seven ether, and when a player sends another ether, the balance will be greater than seven. This means that the balance will always be greater than the target amount, and the function is going to fail here so that the winner is never set. Switching the account to EB, she's going to send five ether and then call the attack function, and the target will be the ether gain contract. You can see here that the attack was successful. Let's check the balance of the ether gain contract. So I'm going to call get balance and it has seven ether, which is the winning amount.
00:06:12.834 - 00:06:54.080, Speaker A: So who's the winner? The winner is zero address. In other words, the winner was never set and no one will be able to become the future winner. And just show you this. Let's say that Alice tries to send one ether by calling deposit, and you can see here that the transaction fails with game is over. In other words, the game is over, but we have no winner. That's how you break a game and have seven ethers stuck in the contract. Let's now talk about how to protect this contract from such an attack.
00:06:54.080 - 00:07:58.962, Speaker A: What you'll have to do is not rely on addressdis balance to get the current balance of ethers sent from all players. So we'll declare a state variable called balance, and when the player sends the one ether, we'll update the balance. Attackers can still forcefully send ether to this contract, but they won't be able to update the balance state variable unless they play the game, call the function deposit and send one ether. This will guarantee that the balance state variable is always less than or equal to the target amount, and at some point the balance will equal to the target amount and the winner will be set. So that's how you protect your contract from getting broken by an attacker that forcefully sends ether. I'll put the link to the codes in the descriptions below. Any feedback or questions, comment below or you can send me a message on discord.
00:07:58.962 - 00:08:00.980, Speaker A: Thanks for watching and have a nice week.
