00:00:00.560 - 00:00:29.921, Speaker A: This video is sponsored by Siphon. Follow the course on Siphon Updraft for better tracking quizzes. Prove your knowledge and join a community of over 50,000 Web3 engineers ready to help you out and answer your questions. Welcome to the course for Kerb B1AMM. This course is for advanced solidity developers who have experience with Foundry. To fully understand this course, you must also know the math of Constant Product AMM and Constant Sum Ammunition. These are the prerequisites, the must haves.
00:00:29.921 - 00:01:10.819, Speaker A: We also have some optional prerequisites in the course. We'll sometimes compare Uniswap B2B3 and Kerb B1 in other parts of the course. I'll also mention about some basic DeFi stuff for example like stablecoins such as Dai and USDC, so having a basic familiarity of defi will help. And finally, there are some optional lessons where I would use Python to show you some of the math of curve B1. So these are all nice to haves but are not required to follow along the course. Why take the course? First of all, understanding curve B1 might give you some ideas for a new AMM design. It's not just Uniswap B2 and B3 that are AMMs.
00:01:10.819 - 00:02:12.321, Speaker A: We also have other AMMs and by taking this course you'll get a better feeling for how you might construct a new amm. It might also help you in audit contests and bug bounties. And the last reason why you should take this course is because this is a prerequisite to understand curb B2. What will you learn in this course? You'll learn the math and algorithms for Curb B1. Curb B1 is written in BYPR and we'll do a cold walkthrough of the Curb B1 contract so you'll gain some experience reading by Per There are exercises and solutions written in Foundry so you'll have some hands on experience testing with Foundry. I'll be your instructor Taz so you might be asking who am I to teach you this course? Well, I've been a software developer for more than a decade and I've been a smart contract developer for more than five years. I also teach about smart contract programming on my YouTube channel smart contract Programmer and I am the author of the websites Solidity by Example and by provide example.
00:02:12.321 - 00:02:58.425, Speaker A: The GitHub repo that we'll be using in this course is called advanced defi 2024. For the course for curb b1 scroll down and look for a markdown file called curbv1md. Click on this this will take you to a markdown file that shows all of the links that you'll need in this course. Inside this file it lists the prerequisites which we already have discussed, and it also lists the tools that you'll need. The tools that you'll need is Foundry and optionally, if you want to follow along the optional Python examples, install Python and also Jupyter Lab. For each lesson, watch the videos on Siphon Updraft, and for the exercises you can find the link under the section called Topics. So scrolling down we have a section called Topics.
00:02:58.425 - 00:03:40.305, Speaker A: And then under here you'll see some of the links to the exercises and the solutions. Now there are other links inside this markdown file. Some of them link to the code that is used inside the videos and and other ones will link to additional notes and graphs. If you have further question, you can navigate to GitHub discussions under this repo. So scrolling back up under this repo called Advanced DeFi 2024, click on Discussions and then you can ask your questions here. To do the exercises in this course, you'll need to get cloned as repo. And to do that, click on Code and then copy this URL inside the terminal, type git Clone and then paste the repo.
00:03:40.305 - 00:04:13.405, Speaker A: Once the repo is cloned into your computer, next CD into advanced DeFi 2024. The exercises are written in Foundry. So to do the exercise, you'll first need to install Foundry. If you have not done so, copy and paste this command to install Foundry. Now, this command only works for Linux. Once Foundry is installed, let's do a quick check to make sure that the contracts which are used for the exercises compile the contracts are located under a folder called Foundry. So say CD Foundry.
00:04:13.405 - 00:04:57.615, Speaker A: And inside here we'll do a quick check by compiling the contract Forge Build and our contract compiled successfully. So if you made it this far, congratulations, you're now ready to do the exercises. Inside this folder, the exercises and the solutions are located. Under the Test folder, the exercises and solutions are organized by the name of the DeFi protocol. For example, here under Uniswap B2, you'll see a folder called Exercises and Solutions. The same goes for Uniswap B3 and for this course we have Curb B1, there's a folder called Exercises and a folder called Solutions. Exercises will contain some starter code, and inside here you'll write your code.
00:04:57.615 - 00:05:37.045, Speaker A: If you get stuck or if you just want to see the solution, then open the Solutions folder. Inside it you'll see some contracts which will Contain the solution to the exercises. Now, to execute the exercises or to just compile the contract inside this foundry folder. What you'll first need to do inside the terminal, first go into the foundry folder. So from the project group, I'll CD into the foundry folder. CD Foundry to compile the contract, type forge build. If you want to execute the exercises or the solutions, what you'll need to do is follow this command.
00:05:37.045 - 00:06:08.619, Speaker A: First you'll need to set up the environment variable for fork URL. This will be the URL that will be used to execute your code against the main network. And then afterwards, either to execute the exercises or the solutions, you'll have to type this command in. So let's go through an example. First I'll set up my fork URL. I'll type fork URL equals and then paste the fork URL. This URL I signed up and then got from Alchemy.
00:06:08.619 - 00:06:58.025, Speaker A: Next, let's execute one of the code inside Curb B1 Solutions. Let's execute the code inside Curb B1 Swap Test. So to do this you'll have to type forget, followed by fork URL, fork URL and then the environment variable that we set, fork URL and then the path to the test is match path test curb b1 solutions. And the name of the contract is curb b1 swap test. So, and if you wanted to also print out the console logs, then you'll type BBB. Okay, that executed two functions, TestExchange and test getdy underline. I'm not going to open this file because I don't want to show you the solutions.
00:06:58.025 - 00:07:32.325, Speaker A: But let's say that we only wanted to execute this function called testexchange. So what you can do is we'll start with the same command as the previous example. And then we type match test. The name of the test is test exchange. This will only execute the test called Test exchange inside the contract curb swap. And the same goes. If you wanted to execute one of the contracts inside the exercises, what you'll have to do to do one of the exercises is open exercises.
00:07:32.325 - 00:08:16.017, Speaker A: Let's say curb B1 swap test solution. Then you write your code inside here. And to execute the code inside here, what you'll do is inside your terminal, you will execute a similar command to this one. And instead of solutions, the path to the test will be under exercises. And obviously the test fails because the code inside the exercises are incomplete. It is your task to fill out the code inside the contracts, the exercises. So this is how the exercises and solutions are organized inside this repo for those of you who are new to defi here, I will give you a quick explanation of USDC and DAI which I will be using.
00:08:16.017 - 00:08:49.647, Speaker A: In this example, USDC and DAI are both cryptocurrencies that target $1. This is called a stablecoin. There are different mechanisms so that the price of the stablecoin floats around $1. We will not discuss here and this will be a topic for another defi course. With that said, let's take a look at an example of swapping USDC for Dai using Uniswap B2. Let's say that you wanted to swap 1000 USDC for some amount of Dai. Currently the best deal that you can get is 1000 USDC and you'll get 996 Daik.
00:08:49.647 - 00:09:30.914, Speaker A: These two coins are stable coins where the price are close to $1. So if we were to swap 1,000 USDC, we expect that the amount of DAI that we can get is also close to 1000. However, this is not the case here. We're losing $4 if we were to swap this 1000 USDC on Uniswap B2 and of course if we were to use Uniswap B3 we will get a better deal. This is because Uniswap B3 has concentrated liquidity. However, before Uniswap introduced concentrated liquidity, the option to swap USDC for DAI was either on Uniswap B2 or on another AMM called curb on curb. If you were to do the same swap 1000 USDC for some amount of DAI, then we would get 999.92
00:09:30.914 - 00:09:55.021, Speaker A: DAI. This is a better deal than swapping on Uniswap B2 where we lost more than $4. Here we're losing less than $1. Curve B1 is a AMM that is optimized for swapping tokens that should have similar prices. For example USDC and DAI or USDC and USDT. They are all stablecoins that target $1. Another example is ETH and Steth.
00:09:55.021 - 00:10:34.123, Speaker A: Both of them have a similar price, so they should swap close to 1 to 1. If you put in one token into the Kerb AMM, you should get back approximately one token out. How is Kerb B1 different from Uniswap B2 and Uniswap B3? For this comparison, we will consider the case when we're swapping between USDC and DAI. Let's start with the language. Both Uniswap B2 and Uniswap B3 are written in solidity on the other hand, Kerb1amm is written in byper. As you saw in the previous video, the slippage on Uniswap B2 is high. For example, if we try to swap 1000 USDC then we saw that we only got 996 DAI on Uniswap B2.
00:10:34.123 - 00:11:11.569, Speaker A: On Uniswap B3 it introduces a concentrated liquidity so the slippage will be low. If you were to swap 1000 USDC then we will probably get something close to 1000 Daisy. And we also saw in the previous video that slippage on curb B1 is also low. We saw that if you were to swap 1000 USDC then we got 999.92 Dai both in Uniswap B2 and in Uniswap B3 it supports two tokens. For example, in Uniswap B2 we saw example of a USDC Dai pool and also in Uniswap B3 it can only have two tokens. However in Curve B1 it can have two or more tokens.
00:11:11.569 - 00:12:02.633, Speaker A: For example, on the user interface of Curve Finance you can see over here that there is a pool with three tokens dai, USDC and usdt and if you scroll down there are some pools with two tokens and there are other pools with four tokens. Another difference between UNISWAP AMMS and KERB AMM is how liquidity is added and removed. For Uniswap B2, when we have liquidity, both tokens must be sent and when we remove liquidity, both tokens will come out. How about in Uniswap B3? In Uniswap B3 it depends on the price range where you're adding liquidity and the current price. If you add liquidity to a price range that is outside of the current active price, then you can only add one token. If you're adding liquidity to a price range that includes the active price, then you must add both tokens and for removing liquidity. This is also the same when you remove liquidity.
00:12:02.633 - 00:12:43.565, Speaker A: If your liquidity position is outside of the active price, then you can only withdraw one token. However, if the current price is in between your liquidity position, when you remove liquidity, you'll get both tokens. However, in Curb B1 you can specify which tokens you want to withdraw. It can be one token, it can be all tokens, or it can be somewhere in between. For example, inside the curve depot that consists of DAI, USDC and USDT, let's say that we have 100 LP tokens and we only want to withdraw a DAI, then this is possible. We can also only withdraw in USDC or in usdt. We can also withdraw all of the tokens in a balanced way.
00:12:43.565 - 00:13:30.109, Speaker A: Or we can specify how we want to withdraw the tokens. For example, maybe we only want DAI and USDT and not USDC. On Uniswap B2 and B3, there is no fee that is charged when we add or remove liquidity. However, in Curb B1 we we can both add and remove liquidity in a way that results in the pool's balance being imbalanced. For example, if we had 100 USDC, 100 DAI and 100 USDT in a curve pool and we decided to withdraw all of our liquidity in dai, then the balance of the tokens after removing liquidity will be imbalanced. In this case, curb will charge a fee on imbalance and this is the same for adding liquidity. Let's say that the curb beyond pool is balanced and then we add a lot of dai.
00:13:30.109 - 00:14:07.777, Speaker A: This will make the balance of the coins in the curb B1 pool imbalanced. And in this case imbalance fee will be charged. And the last big difference between uniswap and curb b1 is how swap fees are charged. Both in uniswap b2 and b3, swap fees are charged on token in however and curb b1, swap fees are charged on token out. Okay, so these are some Differences between curb B1, Uniswap B2 and Uniswap B3. In Uniswap B2, the curve of the AMM, the constant product curve is given by X times Y equals K here. In this example, instead of using K, we will use D over 2 squared.
00:14:07.777 - 00:14:39.547, Speaker A: We also have the constant sum which is given by the equation X y z. The curve B1's AMM curve is a curve that sits in between the constant sum and the constant product. The equation is given by this equation which looks complex. And it looks like. If you graph this, it looks like this. When the tokens X and Y are in imbalance, then we can see that it looks sort of like the constant product curve. When the tokens are imbalanced, then it looks more like the constant sum.
00:14:39.547 - 00:15:19.381, Speaker A: In other words, when the amount of token X and amantotoken Y in this pool are close to each other, then you can swap one token for another close to one to one, simulating the constant sum curve. However, when the tokens are imbalanced, it behaves more like the constant product curve. Now in this curve B1's curve. There's a parameter that defines how flat this curve is inside the whitepaper and also inside the code of curb B1AMM. This parameter is called A. When we increase A, we can see that the curve's B1 curve becomes more flat and it behaves more like the constant sum. And when this A decreases, it behaves more like the constant product.
00:15:19.381 - 00:15:51.295, Speaker A: So the curb's B1 curve is given by this complex equation. Let's break this down and see how to actually recreate this curve. Our goal is to create a curve that sits in between the constant product and the constant sum. So let's start by combining the constant product and the constant sum. So first I'll copy this constant product curve. And then to this, let's add the constant sum curve. So on the left side of the equation, I'll add A x plus Y, and on the right side I'll add a D.
00:15:51.295 - 00:16:18.207, Speaker A: So this X + Y&D is the constant sum curve. What we just did over here is took the constant product, and to this we also added a constant sum. X times Y Locals d over 2 squared, that's the constant product. And x plus y equals d, that is the constant sum. And notice that not much has changed. The curve still looks like a constant product. Now, before we move on, notice here that we have a D over two squared.
00:16:18.207 - 00:16:47.223, Speaker A: And the next term is a D. Let's multiply this D again by another D so that on the right side of the equation we have terms in D squared. So I'll multiply this by a D. So we will get D squared. And since we multiply this side by D, we also need to multiply this X plus Y by D. Okay, and now it sort of looks like a curve that is in between constant sum and constant product. So remember that when we increase this A parameter, this curve should look more like the constant sum.
00:16:47.223 - 00:17:17.747, Speaker A: And when we decrease it, it should look more like the constant product. So I'll add the A term to the part of the equation that describes the constant sum and also do the same on the right side of the equation. And when we increase this a parameter, now our curve starts to look like a constant sum. If we decrease it, it looks more like the constant product. And at A equals 0, we get exactly the constant product. Again, let's increase the A term. So from here, how can we get a curve that looks like the curve B1's curve.
00:17:17.747 - 00:17:49.921, Speaker A: Well, first of all, notice that our curve right now crosses over the x axis and also the Y axis. This means that this curve describes token balance that are negative. But that is not possible. Token balances has to be greater than or equal to zero. So we want this green curve to be within the x axis and also within the Y axis. To do this, we can multiply both side of the constant sum equation by an X and a Y. So, for example, if you multiply this side by X and then we also multiply this side by X.
00:17:49.921 - 00:18:20.441, Speaker A: Now notice that our green curve doesn't cross over the Y axis. It stays to the right of the Y axis. And we can do the same trick so that this part of the green curve doesn't cross over the x axis. So multiply by Y and then multiply by Y over here as well. And now what do we get? Now it kind of looks like a curve that is a constant sum, but without crossing over the x axis and the Y axis. When A is equal to zero, we get the constant sum. And when A is equal to 1, we get this curve.
00:18:20.441 - 00:18:55.163, Speaker A: So right now our curve is really sensitive to the parameter A. To make this less sensitive to the A parameter, what we have to do is divide this X times Y by a D over two squared. And the same goes on this side of the equation. Divide this X times Y by D over 2 squared. And what do we get if we increase A? Now we get a curb that looks like curb B1's curve. And if we increase this A parameter, it looks like the constant sum. And if we decrease it, it looks like the constant product.
00:18:55.163 - 00:20:03.623, Speaker A: So what we just did was recreated the curb B1's equation starting from constant product and constant sum. But why did we multiply this part of the equation and this part of the equation by X times Y divided by D over 2 squared? What does this part of the equation actually do? To give you a quick explanation, what it does is when the token balances of X and Y are equal, then this X times Y divided by d over 2 squared is equal to close to 1. For example, we can see that X times Y divided by d over 2 squared will exactly be equal to 1 when both x and Y are equal to D over 2. And when X and Y are not equal to d over 2, then this term is less than 1. And when x and Y are imbalanced, then this term approaches zero. So what this X times Y divided by D over 2 squared is doing to this part of the equation, and this part of the equation is saying that when X and Y are close to D over 2, then apply this part of the equation. So apply the constant some part of the equation.
00:20:03.623 - 00:20:47.757, Speaker A: And when X and Y are not imbalanced, then this part approaches zero. So the dominating factor of this equation becomes the constant product. In other words, when the amount of token x and amount of token Y are close to each other, when they are balanced, the curve will behave like the constant sum. And when the amount of tokens are not imbalanced, then they behave more like the constant product. And that is why you see that when the tokens are imbalanced, our curve looks like the constant product at the edges. In the previous video we graphed curbs V1 curve onto D. What made this equation work nicely so that we have a curve that is in between a constant sum and a constant product was the term X times Y divided by D over 2 squared.
00:20:47.757 - 00:21:35.365, Speaker A: In this video we will take a look at this term X times Y divided by D over 2 squared in 3D. So when we graph this, we get a three dimensional surface. The inputs are all of the points on the XY plane and the output is described in the z axis. So what we get is a two dimensional surface in 3D. Now what we're interested here is how this function behaves on the points of curves B1 curve. But before we do that, let's first plot this X times Y divided by D over 2 squared for all of the points on the constant product. So what we're going to do is take all of the points X and Y that satisfy X times Y equals d over two squared and take those points and then evaluate this equation which is equal to x times Y divided by D over 2 squared.
00:21:35.365 - 00:22:15.807, Speaker A: When we do that, we get a blue line on this 2D surface. And for this, the Z is always equal to one. And this is because if you take all the points x and Y that satisfies the constant product X times y equals D over 2 squared. And then we plug it into this equation. Since x times Y is always equal to d over 2 squared, this function will always evaluate to 1. So this is why for z we always get a 1 when we look at the points on the constant product curve. How about the points on the constant sum curve? And what do we get? We get an arc that touches one and decreases to zero as y goes to zero and also decreases to zero as x goes to zero.
00:22:15.807 - 00:23:06.795, Speaker A: Okay, what kind of line will we get on this to the surface? If we evaluate this equation for the curb's V1 curve? This is described in the line orange on this graph, I'll also put the point D over 2, D over 2 and Z equals to 1. This is shown in purple. And what we can see from here is that the X times Y divided by d over 2 squared for the points on the curves v1 curve, we get this orange line. And what it looks like is when X and Y are close to d over 2, then z is equal to 1 on this orange line. And as X and Y become imbalanced, then this orange line approaches zero. For example, we can see that as X increases and Y decreases, Z given by this orange line decreases to zero. And the same goes for the other way.
00:23:06.795 - 00:23:42.897, Speaker A: As Y increases and X decreases, we can see that this orange line also decreases to zero. In summary, we analyzed how X times Y divided by D over 2 squared behaves in 3D. And what we found out was that when X and Y are close to d2, then this equation is equal to 1. And as x and Y become imbalanced, then they approach zero. Here I'll explain more about curve B1's equation that you'll see in the whitepaper. In the previous video, we looked at the equation for two tokens. But inside the whitepaper, the equation is for N tokens.
00:23:42.897 - 00:24:20.129, Speaker A: This N is a number that can be greater than or equal to two. To begin with, we have the equation for the constant sum sum. All of the token balances from I equal to 1 to I n, and this must be equal to D. For example, for two tokens, this will be x + y equals to D, and we also have the constant product. Multiply all the token balance from I equals to 1 to I equals to n. And again for two tokens, this will be X times Y equals to d over 2 raised to the 2. And then we have the curve b1 equation, which is a composition of the constant sum and the constant product.
00:24:20.129 - 00:25:11.515, Speaker A: Furthermore, the constant sum part of this equation is multiplied by this symbol called chi, and then multiplied by D to the M minus 1, and this chi is equal to the a parameter that controls how flat this curve B1's curve is. And then multiply by all the token balances and then divide by D over N and then raise it to the power band. Again, going back to the example of two tokens, we saw that this was equal to X times Y divided by D over 2 raised to the power of 2. This is the equation that you'll see in the white paper of curve B1. In our example, we saw this equation for two tokens, and this equation over here is a generalization of that equation. Now it's the same equation as above, but another equation that you'll see in the curve white paper is given by this form. So in the rest of the video, I'll show you how to derive this equation starting from this equation.
00:25:11.515 - 00:25:46.665, Speaker A: So to begin with, I'll copy all of this equation and then I'll paste it here. Next, I'll replace this symbol called chi with the actual terms. And to be clear, I'll highlight this as orange and then I'll paste it here. And the same for over here. Okay, so to go from this equation to this equation over here, all we have to do is divide both side of the equation by D divided by the product of all the coins. So let's expand this equation on the left side. We multiply this and the same with the right side.
00:25:46.665 - 00:26:08.583, Speaker A: Let's start by simplifying the left side of the equation. So first of all, I see a product of all the tokens on the bottom. And I see the product of all the tokens on the top over here. So these two will cancel out. Next, I see a D raised to the power of N. And over here I see a D raised to the power of N minus 1. And then multiply this by D.
00:26:08.583 - 00:26:36.495, Speaker A: So this part will be D raised to the power of N. So this will cancel out with this over here. Okay, so the first term that is left is A times N to the N. And then we have this constant sum. Next we have a plus. And then the product of all the token balances on the bottom and the product of the token balances on the top will cancel out. And the second term will become a D.
00:26:36.495 - 00:27:01.107, Speaker A: Okay, so this is the left side of the equation. How about the right side of the equation on the right side as a denominator, we have the product of all the token balances. And for the first term we have a product of all the token balances as a numerator. So this will cancel out. Next I have a D raised to the power band over here. And then it is multiplied by D raised to the power band. So these two cancel out.
00:27:01.107 - 00:27:30.605, Speaker A: So the first term is A multiplied by D. And then multiply by N raised to the power band. Okay, and then for the next term we have a plus. And then we have a D multiplied by D raised the power of N. So this will become D raised to the power of N +1. And on the bottom we'll have this product. And furthermore, this product is multiplied by N to the N.
00:27:30.605 - 00:28:33.117, Speaker A: Okay, let's put all of this together so we get this equation, after multiplying both side of the equation by D divided by the product of the token balances, you can compare each of these terms and you'll see that they are the same. This is the other form of equation that you'll see in the curbs B1 white paper. Both in Uniswap B2 and Uniswap B3, we have an explicit equation for liquidity and for the amount of tokens that will come out from a swap. For example, in Uniswap B2, the amount of tokens to get out of a swap and the liquidity can all be solved from this simple equation. And here's an explicit equation for the amount of token Y to come out if we were to put in dx amount of token x. Likewise, in Uniswap B3, we can solve for liquidity and also the amount of tokens to go out during a swap by using this equation. For example, here are the equations that you'll use to calculate the amount of token X and amount of token Y given the liquidity in the price ranges.
00:28:33.117 - 00:29:25.819, Speaker A: However, in Curbs equation, it's really difficult to come up with an explicit equation for the amount of tokens to come out during a swap, and also an equation to calculate liquidity. Here's the equation that is used in Kirby1 to calculate the amount of token that will go out during a swap, and also to calculate liquidity. And just by looking at this equation, you can already see that it might be difficult to come up with an equation for the amount of token that will come out and another equation that will calculate liquidity. Even if we consider the case for two tokens, the equation still looks complex. And again, it looks difficult to come up with an equation for the amount of tokens that will come out during a swap and also for liquidity. So we saw that there might not be an easy way to find the equation for X, Y or D in Curb's equation. This D sort of represents liquidity.
00:29:25.819 - 00:30:13.061, Speaker A: The solution that Curb uses to find X, Y or D is to use a mathematical technique called Newton's method. So what is Newton's method? Newton's method is a mathematical technique to find the solution for the equation F of X equals zero. So the goal is to find X where the function F of X will evaluate to zero. Don't worry for now if this sounds abstract in the next video, we'll go through a Python example. The way this algorithm works is we first start with a guess of what this X might be so that F of X will be equal to zero. So for example, let's say our initial guess is x0. Next, we're going to run a while loop until when we feed this x event into the function F, it will evaluate to zero or something really close to zero.
00:30:13.061 - 00:31:10.669, Speaker A: So inside the while loop we say the Next X of N +1 is equal to take the current X, sub n and then from this minus, evaluate F at X, sub n, and then divide this by the derivative of x, evaluate it at X, sub n. And if everything goes well, this X of N +1 will usually be a better estimation of where F of x will be equal to 0 than x, sub n. Now, there are cases where Newton's method does not work well, if you're curious for more information, I'll put a link in the course. And then next we evaluate the difference between x, sub n + 1 and x, sub n. If this difference is really small, then we return x, sub n +1. In other words, when we plug this x sub n +1 into this function F, we'll get a number that is really close to zero. Otherwise, if x sub n plus 1 minus x, sub n is not a small number, then we move on to the next iteration of the while loop.
00:31:10.669 - 00:31:43.815, Speaker A: So we set X, sub n equal to x, sub n +1. And that is the basic idea for Newton's method. Let's see how this is used in Curb to calculate X, y and D. For example, how does Curb use Newton's method to find y? To begin with, we first need to set up a function. For this example, you'll use the equation for n equals to 2. So I'll copy this and then you'll paste it here. And we'll define F of Y be equal to this part of the equation.
00:31:43.815 - 00:32:18.183, Speaker A: And then we minus the right side of the equation. So if we can find a Y where this equation evaluates to zero, then this means that then we found a Y where this equation is satisfied. So we set up our equation to be this and we use the Newton's method to find Y where F of Y is equal to zero. Let's look at another example. Let's say that we wanted to find D. Again, this D sort of represents liquidity in curve and use Newton's method to find D. The equation is a little bit different from the first one.
00:32:18.183 - 00:32:48.205, Speaker A: The right side of the equation is the same, but the input for the function is different. Here we're solving for Y, and over here we're solving for D. But on the right side of the equation we still use the same equation, and using Newton's method, we find D where F is equal to zero. In the next video, we'll go over these examples using Python. Let's go over a simple example of Newton's method using Python. So let's say that we have a function def. I'll call this F, takes in a single input X.
00:32:48.205 - 00:33:20.941, Speaker A: And let's say that our simple equation is x squared minus 2. So using Newton's method, we're going to try to find the x such that when we evaluate x squared minus 2, then it equals to 0. Now, to use Newton's method, remember that for Newton's method we had X. The new X was equal to the current x minus F of x divided by the derivative of f F prime of x. So we have our function F. We also need a derivative. In this case, the derivative is simple.
00:33:20.941 - 00:33:47.999, Speaker A: So let's call this def df. For a derivative of F, the derivative of the function x squared minus two is simply return two x. So we're going to use these two functions and then apply the Newton's method. So let's first write a general algorithm for the Newton's method. I'll call this def and I'll name this function F. Solve, Solve the function F. So this is our function that's going to apply the Newton's method.
00:33:47.999 - 00:34:33.582, Speaker A: And for this function, it's going to take in several inputs the function f and the derivative of F. We'll call this df and our initial starting point for X, I'll call this X0. Next we'll put a number of iteration, the number of max iteration. To apply Newton's method, I'll call this n and that's the I'll pass in the input. I'll name this delta and this will be a number so that when we apply this equation. So let me rename this variable, I'll call this X1 and X0 and put an X0 over here and X0 over here. So this delta will be a number that when we compare x1 and x0 and when they are small enough smaller than delta, then we'll return this X1 inside this Newton's method.
00:34:33.582 - 00:35:12.097, Speaker A: So I'll say for I in range of n, we will write some code over here later. And if this function does not return a solution within this n iteration, then we'll throw an error. So I'll type assert, false, cannot find solution. Okay, so next let's write the Newton's algorithm for each iteration and for debugging purpose, let's Also print, say print in X0. So first we'll apply this algorithm. So I'll just copy this and then paste it here. X1 is equal to X0 minus F of X0.
00:35:12.097 - 00:36:04.227, Speaker A: This F comes from the input divided by F prime. Let's call this df, which also comes from the input. And this is how we get our x1. Next, we'll need to return x1 if the distance between x1 and x0 are smaller than delta. So say if the absolute value abs of x1 minus x0 is less than or equal to delta, if the difference between x1 and x0 are small enough smaller than or equal to delta, then we'll say that we found a solution where when we evaluate F of X1, this will be really close to zero. So say return X1, else we'll need to continue the iteration. So say the new X0, the X0 to be used for the next iteration, we will set this equal to x1 that we just calculated from here.
00:36:04.227 - 00:36:48.443, Speaker A: And this completes our Newton's method. Now, if you want to write a robust Newton's method, then there are some edge cases that you'll have to worry. But for the sake of simplicity, we'll keep this algorithm simple. Okay, so let's now use Newton's method to find an X where x squared minus 2 is equal to 0. So let's say x is equal to F. Solve, we'll solve for the function f and the df is defined over here, df and next, our initial guess, let's put a 1 over here and for iteration, the number of max iteration that we're willing to accept for this Newton's method. To find the solution, let's put this to 1000 and delta.
00:36:48.443 - 00:37:26.987, Speaker A: When the difference between x1 and x0 is small enough, it will return x1. So this delta, let's say, is 0.001. Okay, next, after it finds a solution, if it does find a solution, if it does not find a solution, then it would throw an error and this whole execution will fail. So let's say that we found a solution. Let's actually print this solution. So we'll evaluate F of X, and what we expect here is that this number to be equal to zero or something really small. So let's say print F of x is equal to and let's also print the solution, print X is equal to x.
00:37:26.987 - 00:37:59.957, Speaker A: Let's now execute this Python code. So as you can see, it ran three iterations and then found the solution. And according to Newton's method, the solution is equal to 1.41421 and so on. And also when we took this solution and then evaluate F of X, we get a really small number that is really close to zero. So this was a simple example of Newton's method. Let's now apply this same algorithm Newton's method on curve's equation to calculate Y and to calculate the number D.
00:37:59.957 - 00:38:48.853, Speaker A: Okay, let's start by defining the equation for curve using Python. So let's call def F. For this function, we'll put in several inputs x, y, the amplification factor a and the liquidity d. And the function is return x times y plus k. I'll do this lowercase k and where this k is equal to A times x times y divided by d over two to the square. Okay, and then we have k times d times x plus Y. So this is the left side of the curves equation and the right side is minus D over 2 squared, minus K times D to the square.
00:38:48.853 - 00:39:17.801, Speaker A: Okay. Next I'll define some parameters that we'll be using. For this example, let's say N is equal to 100. This will be the max iteration and delta. Let's set this equal to 0.0001. And let's say that we have x equals to 120, y equals to 90, a is equal to 10 and d is equal to 200. For the first example, we'll use Newton's method to find D.
00:39:17.801 - 00:39:44.525, Speaker A: So given we know what X is, we know what Y is, and we know what A is, then we'll use Newton's method to find D. Def F. I'll call this fd. It's going to take in a single input, the D that will be passed into the Newton's method. Then it's going to return F of F is the function that's defined over here. The X is already known, so this X will be used. Y is also known and A is also known.
00:39:44.525 - 00:40:09.785, Speaker A: So X, y and A. These three parameters will be used for this function. X, y, A and D will come from the Newton's method. Okay, Next we need to calculate the partial derivative of this function with respect to D. So I'll say def df I'll name this dd. It's going to take in a single input. D is going to be passed from the Newton's method.
00:40:09.785 - 00:40:37.995, Speaker A: And here's the partial derivative of this function F with respect to D. I'll briefly cover how I calculated this in the next video, or you can also use paper and pencil to manually calculate the partial derivative. Okay. Let's now apply Newton's method. So let's say D is equal to Newton's method F. Solve, it's going to take in the function F of D. Next it's going to take the derivative of this function df db.
00:40:37.995 - 00:41:13.141, Speaker A: The next parameter is the initial starting point for the Newton's method. And for this initial starting point, we will use this D over here. Next is the number of iteration, the number of max iteration. You'll pass N which is equal to 100, and then delta which is equal to 0.0001. So let's say that Newton's method was able to find D given these parameters x, y, A. It calculates D where it satisfies this equation, where this is equal to zero. So let's evaluate F of D passing in this D that was found by Newton's method.
00:41:13.141 - 00:41:59.697, Speaker A: And then let's print both of these out, print D D, and then print F of D passing in D. So here I'll say F of D and then remove this. Okay, let's execute this code. And notice that using Newton's method, we were able to find D that satisfies this equation given these three parameters in four iterations. So according to Newton's method, the D that satisfies the equation is equal to 209.895984 and so on. And when using this D and then evaluating the function F of D, it returns a number minus 1.1645
00:41:59.697 - 00:42:40.339, Speaker A: and so on raised to the power minus 10. It's a really small number that is close to zero. Okay, for the next example, let's again use Newton's method to calculate Y given these parameters. Given that we know X, given that we know A and D, what is the value of Y that will satisfy this equation so that it equals zero? Okay, so let's start by defining a function that takes in a single parameter of Y and then calls this function. So I'll just copy this paste here and then I'll call this F of Y for the input. It will take in a single input of Y that is calculated from Newton's method. And then we'll call this function which is this function over here.
00:42:40.339 - 00:43:15.111, Speaker A: Okay, and next we need to find the partial derivative of this function def with respect to Y. So say def call this df of dy. The input will be Y, and the partial derivative of F with respect to Y is given by this formula. Again, I use Python to calculate this partial derivative, but you can also calculate it using paper and pencil. So Once we define the function F and then the derivative of F. Next, let's use Newton's method to find Y. So first I'll copy this code and then we'll modify it.
00:43:15.111 - 00:43:57.265, Speaker A: So paste it here. The output will be a Y. The function that we're feeding is F of Y. The derivative of this function will be df dy. And for the initial guess, how about we put in this x value? So let's put an X here and the number iteration will be n and delta will be the same, which is equal to 0.0001. So we'll print out Y that was returned by Newton's method, and then we'll also evaluate F of Y, passing in this Y those returned by Newton's method F of Y and passing this Y. Okay, let's execute the function, then scroll down.
00:43:57.265 - 00:44:39.247, Speaker A: So using Newton's method, given that we know X A and D, the Y that satisfies this equation, so that this part is close to zero, is y is equal to 90. And when we evaluate F of Y with this value, it returns 0.022 and so on. So those were some examples of using Newton's method to calculate D from the curbs equation and also to calculate y from the curbs equation. Here I'll briefly explain how I use Python to calculate partial derivatives for the curbs equation. The library that I used is called sympyte. The first thing that I did is import this sympy.
00:44:39.247 - 00:45:31.323, Speaker A: And next, using this library, I define the curves equation and to get the partial derivative of this function with respect to D and with respect to y, all I had to do was call a function that is provided by this sympy library called called diff. Here saying, differentiate the function F with respect to D and I get df dd. Likewise, if I differentiate this function F with respect to Y, I get df dy and then I printed these out and when I do this, what I get? The results are over here. DF D is equal to this and df DY is equal to this. I copy this code and then used it in the previous video where we used it in the Newton's method for curb v1. There is only one contract that the user interacts with when they swap. Add liquidity or remove liquidity.
00:45:31.323 - 00:46:06.975, Speaker A: Now let's take a look at the user interface for curb. When we scroll down we can see that there are different pools. Here we have the three pool and then next we have the USD E USDC pool. And scrolling down further, we have the steth Pool. Most of these contracts are a variation of a base contract called stableswap. For example, the three pool contract is called Stableswap three pool and the Steth pool contract is called StableswAP Steth. So if you understand what are the Stableswap contracts, it won't take you long before you understand the other curb B1AMMs.
00:46:06.975 - 00:46:34.921, Speaker A: Let's take the example of Threepol and SDEF. These two are a variation of a contract called stableswap. Now notice the difference that over here we have three tokens. So three tokens will be inside a single contract. And over here we have eth and steth. Two tokens will be inside a single pool contract. Let's take a look at the contract for a three pool which is called Stableswap 3 Pool under Curve Contracts.
00:46:34.921 - 00:47:15.697, Speaker A: Contracts Pools 3 Pool the first thing that I want to mention here is a constant called ncoins. This tells how many tokens this pool will support. Since 3pool is DAI, USDC and USDT, it supports 3 tokens. Hence ncoins is set to 3. The reason why I'm mentioning this here is because this will affect the interface that you'll need to declare when you call curb B1AMM. For example, if you wanted to call the three pool, let's take a look at the function addliquidity inside the function addliquidity. You can see over here that amounts is a fixed size array of size ncoins, where ncoins is equal to 3.
00:47:15.697 - 00:47:59.395, Speaker A: So when you declare an interface to interact with the Stablesoft 3 pool, you'll need to make sure that this fixed size array is of size 3 in comparison. Let's take a look at how the function at liquidity is defined for the steth pool. The stableswap contract for the steth pool is located under curve contracts pools ste and the name of the contract is called stableswap ste. The first thing that I want to show you is ncoins. So scrolling down here it is. The constant ncoins is defined to be two. And this is because this pool contract holds two tokens eth and ste.
00:47:59.395 - 00:48:46.979, Speaker A: Now let's take a look at the function add liquidity. Okay, here's the function addliquidity. And notice that amounts again is declared as a fixed size array of size ncoins, where ncoins is equal to 2. To summarize what we've seen so far, Curve v1AMMS is a variation of a contract called stableswap. Each pool can hold up to any amount of tokens for Example, the three pool holds three tokens and the steth pool holds two tokens, and the input parameters are slightly different for each pool. So when you interact with the stableswap contract, you'll need to actually look at the pool contract that you want to call and make sure that you define the Interface correctly. The SuiteSwap contract can hold any number of tokens.
00:48:46.979 - 00:49:26.371, Speaker A: For example, the Stableswap 3 Pool Contract is a contract that manages the tokens DAI, USDC and USDT. Another example that we saw was the STE Pool which holds two tokens, ETH and STEF. However, all of the Stableswap contracts will have five functions that are common. Exchange, Add liquidity, Remove Liquidity, Remove liquidity, imbalance, and remove liquidity 1 coin. The function exchange is used to swap tokens, Add liquidity to add the tokens to the pool, and for removing liquidity. There are several variations. Remove liquidity, Remove liquidity imbalance and remove liquidity.
00:49:26.371 - 00:50:16.067, Speaker A: One coin Remove liquidity will give back the liquidity providers. All of the tokens Remove liquidity imbalance will give the user an option to specify how many of each token they wish to get back and remove liquidity. One coin allows the user to specify the token that they want to get back as a single token. There's a common pattern for the way the codes are executed when the functions exchange add liquidity and some of the functions for remove liquidity are called on the Stableswap 3 pool contract. The pattern that you'll see throughout the code inside these functions are that they first calculate the A parameter and then calculate the liquidity D. For example, take a look at the outline for the function exchange. Inside this outline we can see over here that it calculates A and then it calculates D.
00:50:16.067 - 00:51:16.411, Speaker A: Let's take a look at another example. Inside the function add liquidity, it first calculates A and then it calculates the liquidity D and then for remove liquidity it doesn't need to do this since the amount of tokens that need to be sent back to the liquidity provider only depends on the LP shares that are burnt and the total LP supply. However, it is different for remove liquidity 1 coin. So here we have the function Remove liquidity onecoin and again we can see that it first calculates the A parameter and then calculates the D parameter. Why does it do this? And what is the relationship between the A parameter and liquidity D? How does the change in a parameter affect the liquidity D? The reason why that we see a pattern of calculating the A parameter before calculating the liquidity D is because in order to calculate liquidity D, we first need to determine what the current A parameter is. Usually the A parameter is a fixed number. However, an admin can decide to set a new A parameter.
00:51:16.411 - 00:51:43.789, Speaker A: Afterwards, the current A parameter will start updating towards the new A parameter. This change will take over time. While this A parameter is going through an update, the liquidity D may change. So let's see how this A parameter will affect the liquidity D. Here you're looking at an example graph of the Curb B1's equation in pink. Now, Curb V1 can support multiple tokens. It can support two tokens, three tokens, four tokens, and so on.
00:51:43.789 - 00:52:05.823, Speaker A: To graph this equation for three tokens, we need a 3D graph. And to graph this equation for four tokens, we will need a 4D graph. And of course that is impossible. So we'll keep this example simple and say that the pool has two tokens. In this case, we can graph this equation on a 2D graph. So this is what you're seeing. Think that the pool has only two tokens.
00:52:05.823 - 00:52:36.191, Speaker A: Now let me explain how the A parameter will affect the parameter D. So let's say that we have some token balance, x0 and y0. The point x0 and y0 has to be a point on this pink curve. So I'll move this point so that it will be somewhere on this pink curve. Okay? And then I'm going to zoom in. So let's say that the current token balance in this curve B1AMM, is over here. We can represent the token balance after a thought.
00:52:36.191 - 00:53:09.013, Speaker A: For example, if token X went out and token Y came in, then this point will move up towards the left. And if there was another swap where token X came in and token Y went out, this point will move down and to the right. However, this blue point must be on this pink curve. Now let's see what happens when the A parameters change. So let's say that the current token balance is over here. And then the admin decided to update the A parameter. The change in a parameter will take some time.
00:53:09.013 - 00:53:52.371, Speaker A: So let's say that the admin set the A parameter to something higher. And now notice that the token balance is no longer on this pink curve. To make sure that this curve B1's equation given the A parameter and the token balances go through this blue point, what we need to do is find liquidity D such that this pink curve will go over this token balance. So to do that, let's adjust this D parameter. So let's move this liquidity D up and we'll move it until we can see that the token balance will be on this pink curve. Okay, I think that's the best approximation. So at this point we can see that the liquidity d is now 51.5.
00:53:52.371 - 00:54:50.805, Speaker A: What happened was when the a parameter changed from 1 to 6, the shape of this pink curve also changed and the token balance was no longer on this pink curve. To put this point back on the pink curve, what we had to do is find the liquidity D so that this pink curve will again go through this blue point. So that is why inside the code, it will first calculate the A parameter and then afterwards calculate the D parameter. What it's doing is given the A parameter and the token balances, it's finding the liquidity D that will satisfy this equation. And graphically we can see this as finding the D parameter so that this pink curve will go through the token balances, which is represented in this blue point. The A parameter inside Curve B1's AMM equation controls how flat the curve is. For example, if we increase A, we can see that the pink line, which represents curve B1's AMM curve, becomes more flat, like the constant sum.
00:54:50.805 - 00:55:21.697, Speaker A: On the other hand, when we decrease this A parameter, we see that the curve becomes more like the constant product. And when A is equal to zero, it matches the constant product curve. Let's take a look at how this A parameter is calculated inside Curb B1's AMM. The contract that we'll take a look at is called Stablesoft 3 Pool. This is a contract that is deployed on the mainnet and it holds USDC and usdt. The function that calculates the current A parameter is called A. The owner of this contract can set a new A parameter.
00:55:21.697 - 00:56:09.657, Speaker A: When a new A parameter is set, it doesn't take effect immediately. Over time, it gradually changes from the current A parameter to this new target, a parameter that is set by the admin. So inside this code you see T1 and A1. A1 is the new A parameter that is set by the admin and T1 is the timestamp where this new A parameter will stay fixed at and after the timestamp T1, this a parameter will stop increasing and it will stay flat as the new value A1. Let's say that the admin sets an a parameter to a1 at time t0. Then over time, from time between t0 to t1, the current a will gradually increase to a1 after time t1. Since the current a parameter has reached a1, it will stay flat as a1.
00:56:09.657 - 00:56:44.467, Speaker A: And we can see this in the code over here. If the current timestamp is less than t1, then get the a parameter a0 that was set at time t0. And there are two cases. If the target a parameter a1 is greater than a0, or if the target a1 is less than or equal to a0, both have a similar code. So we'll just take a look at when a1 is greater than a0. And to understand this code, consider the two cases when timestamp is equal to t0 and when timestamp is equal to t1. Lets start with the case when timestamp is equal to t 0.
00:56:44.467 - 00:57:23.715, Speaker A: When timestamp is equal to t 0, this expression t 0 minus t 0 is equal to 0. So when we multiply this part by 0, this whole expression will be equal to 0. So we get a 0. On the other hand, when timestamp is equal to t 1, then this part of the code is equal to t 1 minus t 0 divided by t 1 minus t 0 is equal to 1. So this part of the code will be a 1 minus a 0 multiplied by 1 which is simply equal to a 1 minus a 0. And then let's now do this. A 0 plus a 1 minus a 0, the a 0 cancels out with this a 0 over here and we get back a 1.
00:57:23.715 - 00:58:06.635, Speaker A: At time t 0 we see that the a parameter returns a 0 and at time t 1 the a parameter returns a 1. And anywhere in between this blocked out timestamp minus t 0 divided by t 1 -t 0 is a fraction that is less than 1. So the a parameter that is returned will be some number between a 0 and a 1. And that's how this part of the code works. This part of the code works almost exactly the same, except the current A parameter gradually decreases to the new parameter A1. Otherwise if the current timestamp is greater than or equal to t1, then it returns a1. So that is how the A parameter is calculated.
00:58:06.635 - 00:58:33.977, Speaker A: Next, let's take a look at how the admin can set this a parameter. The function that the owner of this contract can call to set the A parameters are rampa and stop rampa. Let's first take a look at the function rampa. What this function does is set the future a parameter in the code that we saw previously. This will set the parameter A1. Further input it's going to take in the future A and future time. First it checks that message sender is the owner of the contract.
00:58:33.977 - 00:59:11.735, Speaker A: And then it checks that the current timestamp is greater than or equal to initial a time plus minramp. This initial A time is set every time this rampa function is called. So once you call rampa, this means that you'll need to wait some time minramp time before you can call it again. And then it checks future time is greater than or equal to the current timestamp plus minramp time. The next part of the code calculates the current A. And then it checks that future A is greater than zero and also less than max. Next, it checks that the future A does not drastically change from the current A.
00:59:11.735 - 00:59:57.735, Speaker A: If future A is greater than or equal to current A, then it checks that the future A is less than or equal to the current A times max a change. What you're seeing here is that future A is capped by some maximum A change multiplied by current A. On the other hand, if future A is less than the current A, then it checks that the future A is greater than or equal to the current A divided by max a change. In other words, future A must be greater than or equal to some fraction of current A. And this fraction is determined by this max a change. After all these check paths, it sets initial A to the current A, future A to the future A from the input and sets the timestamps. So that's the function rampa.
00:59:57.735 - 01:00:37.805, Speaker A: Next, let's take a look at the function stop rampa. And again, only the owner of this contract can call this function. And when this function is called, it gets the current A by calling self underscore A. This is the function that we took a look at earlier. And then it sets initial a future A to the current A and sets the timestamps. Thus, the functions stoprampa and ramp A, these are functions that the admin calls to set the a parameter inside Kerr B1AMM all of the token balances are converted to have 18 decimals before any calculations are performed. Here we're looking at a contract for DAI, USDC and USDT.
01:00:37.805 - 01:01:12.101, Speaker A: DAI has 18 decimals, so there is no conversion to be performed to have 18 decimals. USDC and USDT both have 6 decimals, so the USDC and the USDT balance inside the pool must be converted to have 18 decimals. And this is done by an internal function called xp. The naming convention is a little bit weird. The way I remember this is X being the token balances and P for precision. So what this function will do is convert the token balances inside this contract to have 18 decimals. Let's take a look at this function.
01:01:12.101 - 01:01:30.077, Speaker A: First. It creates a UN256 array of size N and it initializes two rates. And what is this? Rates. The rates are defined at the top of the contracts. The first entry is one with 18 zeros. The next two entries are one with 30 zeros. So let's go back to the function that we were looking at.
01:01:30.077 - 01:02:02.369, Speaker A: Underscore xp. Okay, going back to the function underscore xp, we know that here result is initialized to be an array of 1e18, 1e30 and 1e30. In other words, one followed by 18 zeros and one followed by 30 zeros. And then it runs a loop for I equal to 0 to n number of coins. This contract holds three coins. So this n coins will be equal to three. The first coin is Dai and the second coin is Usdc.
01:02:02.369 - 01:02:25.557, Speaker A: And the third coin is Usdt. So for the first iteration it says results of I. Initially it will hold 1e18. So this number will be 1e18 times self balances of I. Again, the first coin is Dai. So balances of 0 will hold the DAI balance locked. In this contract, Dai has 18 decimals and then it divides by lending precision.
01:02:25.557 - 01:02:48.019, Speaker A: Let's check out what this value of the lending precision is. Okay, here it is. Lending precision is 10 to the 18. Okay, let's now see what the first iteration will produce. Results of I will initially hold one E18 and then it's multiplied by the balance of die. Again, die has 18 decimals and then lending precision is 1e18. So let's do the math.
01:02:48.019 - 01:03:21.717, Speaker A: 1e18 times die balance divided by 1e18. This will be the die balance with 18 decimals. Okay, how about the second iteration? The second coin is USDC and resultabye is initialized as 1e30. So result of I will be 1e30. Self balances abu will be the balance of USDC. Again, USDC has 6 decimals and again lending precision is 18 decimals. So for the second iteration it will be 10:30 which comes from here multiplied by USDC balance.
01:03:21.717 - 01:03:55.585, Speaker A: USDC balance has 6 decimals and then divided by 1e18. How many zeros will we have? We have 30 zeros over here. ESTC balance has 6 decimals. So 30 plus 6 is 36 zeros and then divided by 10 to the 18. So this will result in 36 minus 18 which is equal to 18 decimals. And the same goes for the last iteration, USDT. USDT has 6 decimals result I is initialized as 1e30, so 1e30 times USDC balance, this will have 6 decimals.
01:03:55.585 - 01:04:33.695, Speaker A: So this multiplication will result in 36 decimals divided by 18 and we get 18 decimals. So in summary, what this function does is it takes the token balances and then normalizes all the token balances to have 18 decimals. The variable D that you see over here, over here and over here inside curb B, One's equation determines the liquidity of the ammunition. There is a special meaning to this variable D. The special meaning of this variable D is that when the pool is perfectly balanced. For example, let's say that we have a pool with two tokens, X and Y. And here we have D equals to 50.
01:04:33.695 - 01:05:15.931, Speaker A: When the pool is perfectly balanced, then we will have half of this for each token. So for token X, since D is equal to 50 and half of that will be 25, and also for token Y, we will also have 25 tokens. So when the pool is balanced we will have token X and tokeny be over here when this value for D is equal to 50. This is an example of pool with 2 tokens. If we have a pool with 3 tokens, then we would divide this D by 3. More generally, if we had N tokens, D over N will be the number of each token when the pool is perfectly balanced. Inside the stablesoft three pool contract, the value D is calculated using Newton's method.
01:05:15.931 - 01:05:44.103, Speaker A: As an input, it's going to take in XP that we covered in the previous video. As a reminder, this XP represents the normalized balance of tokens. In this contract, this normalized Balance will have 18 decimals. Dai, USDC and USDT will be normalized to all have 18 decimals. And then we also have this input called amp. This amp, when multiplied by N will result in A times N to the N. We'll come back to this later.
01:05:44.103 - 01:06:16.089, Speaker A: So inside this function it's going to perform the Newton's method to calculate the value for D. The first part is to sum up all of the token balances that are normalized. And you can see this over here run the for loop for xp, which represents the normalized balance and for each X, add it to a variable called S. If S is equal to 0, then we return d as equal to 0. Otherwise we proceed. And then this is the part that does the Newton's method. We can see that it runs the iteration for max 255.
01:06:16.089 - 01:06:55.885, Speaker A: And at the bottom we can also see that if the previous DPREB in the Current D is less than or equal to one, which you see over here and over here. Then we break out of the for loop. These two cases mean that D and D prep are close enough. So using Newton's method, it found the D that satisfies the curved B1 equation inside the for loop. We can also see how this D is calculated. For each iteration, it will calculate D raised to the power of m +1. Since this pool has three tokens, you can think about n is equal to 3 and then divided by N raised to the power of M multiplied by all of the token balances.
01:06:55.885 - 01:07:34.969, Speaker A: And that's what this part of the code is doing. It's calculating this expression and then moving on. Next, it calculates the next D using the Newton's method. Remember that for each iteration of the Newton's method, we calculate the next D to be equal to D minus F of D divided by the derivative of F with respect to D, and then evaluate it at D. You can check for yourself that this code over here is equivalent to this equation. And I'll also link you to a Python code that I wrote that quickly checks that this code and this code are equal. Okay, moving on.
01:07:34.969 - 01:08:26.093, Speaker A: Once this part of the code calculates the D for the next iteration, it checks this D with the previous D. And if the difference between this current D and the previous D is less than or equal to one, then the for loop exits. Since at this point we found a solution to D that satisfied the curve's B1 equation. Also notice that even if it does not converge, so this part of the code never evaluates to true, then this for loop will run 255 times, and then at the end it will return D whatever this D is. Even if Newton's method could not find a solution and that completes the code walkthrough for the function get D. When I first saw the function get virtual price, I didn't know what this function was doing. Does this function return the price of the tokens or does it return the value of each LP tokens? But now we can figure out what this function does by looking at the code.
01:08:26.093 - 01:09:01.143, Speaker A: In the previous video, we looked at the function getd. This function uses the Newton's method to calculate this value, called D invis D represents the liquidity of this amm. When all the token balances inside the AMM are equal, then the pool is perfectly balanced. And when the pool is perfectly balanced, and let's say that there are n tokens, then D over N will be the token balance for Each token. So that is the meaning of D. So once we calculate D, next it gets the total supply. This total supply is the amount of LP tokens that were minted.
01:09:01.143 - 01:09:38.465, Speaker A: And then when we look at this part of the code, we can figure out what this function get virtual price does. It takes nd. So this is like the number that represents liquidity and then times it by precision and then divides by the total amount of LP tokens that were minted. So liquidity divided by the total amount of LP tokens. Effectively this will give us the value of each LP token. So the function getvirtualprice, we now know that it returns the value of each LP token. Once we understand what the value D represents, it's now difficult to understand what the function calctokenamount does for the input.
01:09:38.465 - 01:10:28.289, Speaker A: It's going to take in the amount of tokens and then a Boolean flag called deposit. If this is a deposit, then this will be true, otherwise it will be false. And then it returns a single number uint256. But what does this number return? Does it return like the amount of tokens, or does it return like the amount of LP tokens to be minted or burnt? Well, the answer is it returns the amount of LP tokens to be minted or to be burnt. Now, this function does not take into account the fees that might occur for making the pool imbalanced, whether this is from adding liquidity or removing liquidity. So what this function does is it's a simplified calculation of amount of LP tokens that either will be minted or burned for putting in or taking out this much amount of tokens. Let's take a look at this function.
01:10:28.289 - 01:11:07.075, Speaker A: So first it gets the balance and then gets the a parameter amp and then it calculates this number d0, d0 is calculated from the current balance of tokens. Again, this number D represents liquidity. And then it's going to run a loop to modify this balances. If it is a deposit, then add the amounts from the inputs. Otherwise, if it is a withdrawal, if it is a remove liquidity, then from the current balance take out this much amount. Then afterwards, after this balance has been updated, it calculates the value for D. Again, this is named as D1.
01:11:07.075 - 01:11:45.111, Speaker A: Next it gets the total supply and then it calculates the difference of D1 and D0. If it is a deposit, then D1 must have increased. Since we're adding tokens, liquidity must have increased. Otherwise if we're taking liquidity out, then liquidity must have decreased. So D0 will be greater than or equal to D1. Taking this difference, and then we multiply by the total supply of LP tokens and then divide by the liquidity d 0 before the balances were updated. In other words, this Diff divided by d0 represents the ratio of change in liquidity and then multiply by token amount.
01:11:45.111 - 01:12:39.377, Speaker A: To calculate the amount of LP tokens that either will be minted or will be withdrawn to the swap tokens with the curb B1AMM, a user will call the function exchange. For example, let's say that this user wanted to Swap Dai for USDC from the Stableswap 3 pool contract. First they will call the function exchange, specifying that the token name is Dai and the amount of Dai to swap. The Stableswap 3 pool contract will transfer the DAI in from the user over to the pool contract, calculate the amount of USDC to get back, and then transfer the USDC from the pool contract over to the user. Before we do a cold walkthrough for the function exchange inside the contract stableswap 3 pool, I first want to outline the algorithm for the function exchange Inside the function exchange. The first thing it does is it normalizes the token balances to all have 18 decimals. Dai has 18 decimals.
01:12:39.377 - 01:13:09.967, Speaker A: However, USDC and USDT have 6 decimals. To make the rest of the calculation easy. Inside the function exchange, it will first normalize all of the token balances to have 18 decimals. This will create an array of token balances which is initialized inside memory. Next it will transfer the token in and then update the token balance that was normalized in step one. The normalized token balance in step one is in memory. So here we're updating that normalized token balance.
01:13:09.967 - 01:13:47.265, Speaker A: Next, using the updated token balance, it will calculate the balance of token out. The calculation of token out balance involves several steps. Two of the steps that I want to highlight here is the calculation of the A parameter and the calculation of liquidity D. Once the new balance for the token out is calculated, we can now take the difference of the new token out balance minus the old token out balance. To calculate the amount of token that will go out in curb, we want swap fees are taken out out of token out. So the next step is to calculate the swap fee before transferring the token. Now it will update the internal token balance.
01:13:47.265 - 01:14:25.221, Speaker A: So this will be updating the state variables that keep track of the token balances inside the pool contract and then finally transfer the token out. So this is the outline of the code for the function exchange to Swap tokens on Curb B1AMM, you'll need to call the function Exchange. It takes in several inputs. Index I, index j, DX and min dy. I is the index for the token that's going to come in and J is the index for the token that's going to go out. DX is the amount of token to put in and min DY is the minimum amount of token that you expect to get back or else this function will fail. The function first creates an array called rates.
01:14:25.221 - 01:14:59.265, Speaker A: Remember that for three pool, this rate is fixed to a constant of 1e18, 1e30 and 1e30. And what these numbers are used for is to normalize all of the token balances to 1e18. Okay, moving on. It stores the balances of the tokens, the actual balances of the tokens. So this will be dai, USDC and USDT into memory called old balances. And then it takes the token balances and then normalizes it by calling the function xpem. At this point, all of the token balance will be normalized to have 18 decimals.
01:14:59.265 - 01:15:33.543, Speaker A: The next section of the code deals with bringing in the token in transferring the token in into this pool contract, it first creates a variable called DX with fee. This is used for tokens with fee on transfer. For example, some tokens when they are transferred does not actually transfer the full amount. Instead it will take a fee for transferring that token. So the amount of token that will come into the pool with these kind of tokens will be less than the amount that was specified. So that is what this DXWIFT fee is used for. This variable will become more clear as we go down further in the code.
01:15:33.543 - 01:16:03.901, Speaker A: Next it gets the address of the input token. This will be stored in coins of it. Remember I was an input from over here that specifies the input token. So it gets the address of the coin that's going to come in. And if this input token has a fee on transfer, then what the pool contract will do is first get the balance before transfer and then it will create the balance again after transferring. The difference will be the actual amount that came into the pool. For simplicity, let's say that there is no fee on transfer.
01:16:03.901 - 01:17:08.479, Speaker A: Okay, so moving on. Next it calls the function transfer from to transfer the token in. Now notice here that it's not using the ERC20 interface to call the function transfer from. Instead it's using a low level call to encode the function call and all of the parameters transfer from message sender to this contract for the amount DX the reason why it's using a loadable raw call to execute transfer from is because some tokens like USDT does not return a boolean when the function transfer from is called and other tokens like die when the function transfer from is called, it returns a boolean. And if we were to use the IERC20 interface that expects a boolean to be returned and we call transfer from on usdt, then the function call to transfer from will fail. So this is why it's using our low level call. To avoid that error, it solves the problem of calling the function transfer from both for tokens like die that returns a boolean and tokens like USDT does not return a boolean.
01:17:08.479 - 01:17:58.759, Speaker A: Okay, once transfer from is called next, it checks that if the response from this raw call returns anything, then it checks that the boolean is equal to true. And then we see DX with V again. After calling transfer from, it queries the balance of tokens. Again takes the difference to calculate the actual amount that came in. For simple tokens like DAI and USDT that does not have fee on transfer, you can think about this DX with fee as equaling to dx. The actual amount that was transferred into the pool is the amount that was specified. However, for tokens with fee, then we'll need to create a balance of the token before transfer from and also after transfer from to calculate the actual amount of tokens that came in after the input token is transferred into this pool contract.
01:17:58.759 - 01:18:43.103, Speaker A: Next it does the calculation for the amount of token that will go out first to this xp. This represents the normalized balance of the tokens. It modifies the normalized balance of token and to XP a buy at dx with V and this dx with V is also normalized to have 18 decimals. We can see this that it is multiplied by rates of buy and then divided by precisions. This code will make sure that this part of the code has 18 decimals. Next it calculates this pool's token balance of token out in the previous step over here. Because token came in this new y that is calculated using Newton's method by calling the function get y, this Y value must decrease from the previous value.
01:18:43.103 - 01:19:20.773, Speaker A: We'll take a look at what this function does in the next video. For now you can think about this function as Given that the index of tokenin is I and the index of token out is j, the amount that came in is X, the new balance of input token is X and then the normalized balances are xp. Then it calculates the new balance for token out. Since token came in, this new balance of token out must decrease. And we can see this over here. DY will be equal to the current normalized balance up token out minus the new balance up token out. And for a rounding error, it also does a minus 1.
01:19:20.773 - 01:20:01.693, Speaker A: The difference dy is the amount of token that will go out. From the amount of token that will go out, the fee is calculated. This is called DY fee and it's a simple calculation. Take the amount that is going out and then multiply by some ratio phi divided by phi denominator. Next it converts the normalized balance into the actual balance by reversing the operations to normalize a balance, we multiply the token balance by rates of j and then divided by precisions. To convert this normalized balance back into the real balance, we will multiply by precision and then divide by the rates. After we convert this into the real balance, it checks that this DY is greater than or equal to min dy.
01:20:01.693 - 01:20:25.373, Speaker A: Next it calculates the admin fee. This admin fee is a fraction of the DY fee. And then the last part of the code is to update the token balances. The balance of token in will be the old balance plus the amount that came in. And the balance of token out will be the old balance minus DY minus DY admin fee. This part is a little bit confusing. So I've unpacked what this actually does.
01:20:25.373 - 01:20:50.135, Speaker A: Dy. Let's take a look at this. Dy is equal to Dy minus DyF. And then Dy admin fee is a fraction of this Dy PHI. This part of the code, what it actually is doing is this minus DY minus DY phi and then minus DY admin phi. We can do the math, we can simplify the math. And this will be equal to minus dy.
01:20:50.135 - 01:21:16.927, Speaker A: And then inside this parentheses, the minus and minus become a plus. So this becomes plus DY phi. And then we have minus DY admin fee. So what this is doing is taking the old balance minus the amount of token that will go out dy and not all of this DY is going out. Some of it will stay as fee that are given to the liquidity providers. So we keep this amount DY fee. But from this DY fee we're also going to give it to the pool admin.
01:21:16.927 - 01:21:44.911, Speaker A: So we minus DY admin fee. So this is what this part of the code is doing. And then the last part is to transfer the token for token out. And again it's using raw call to call the function transfer to make sure that transfer does not throw any errors. And then it emits the event of token exchange. So that is the function for exchange. So we saw that the function gety calculates the token balance of token out if the new balance of token in is X.
01:21:44.911 - 01:22:11.887, Speaker A: And this function is called inside the function exchange, which is called to swap tokens. Let's take a look at how this function get y is implemented. For the inputs of function get Y, it takes in the index of token in. This will be I and the index of token out j. The new balance of token in, which is x. And then the rest of the token balances xp. This XP represents the normalized balances and then it's going to return a single value.
01:22:11.887 - 01:22:43.401, Speaker A: This value will represent the new balance of token out. Recall that Curb's equation is a complex equation and it's really difficult to get an explicit equation for a token. Now, the way that Curb finds the amount of token out is to use Newton's method. So first it does some checks on the indexes and then moving on, it gets amp. Next it uses Newton's method to get D. This D again represents the liquidity of this amm. And then there are a bunch of variables that are hard to guess what they're used for.
01:22:43.401 - 01:23:29.043, Speaker A: From their name you have C capital S underscore. And then later on in the code you'll see more. Basically what they're used for is to calculate Newton's method, which we'll come back over here. So going back up this C variable, you can later verify for yourself that this will turn out to be D raised to the power of n +1, where n is the number of tokens for this pool. For stablesop 3 pool, this n will be equal to 3 and then divided by this expression N raised to the n times P, where P is the product of all of the token balances except for token j which represents the token out. Multiply this p by a times n to the n. That's what this C will stand for.
01:23:29.043 - 01:24:28.201, Speaker A: And then S underscore will be the sum of all tokens except for token equal to j, which is the token out. And then we have ann, which represents a times n to the N. Okay, and the next part of the code you can verify for yourself that it calculates C, which we see over here to be this expression. And then moving on, we also calculate B and this C and D. You'll see later that it is used to calculate Newton's method over Here and then the next part of the code is where it uses the Newton's method to find the value for y. For the initial guess of Newton's method, it uses the liquidity D. The for loop will run max 255 times and then for each iteration it will calculate Y based on this equation and you can verify for yourself that this equation is equivalent to the Newton's method Y minus F of y divided by the derivative of F with respect to y evaluated at y.
01:24:28.201 - 01:25:17.577, Speaker A: I'll also link you to the code that I wrote in Python which verifies that this code is equivalent to this equation. Then next it compares this new y with the previous y. If the difference between them are less than or equal to one, then it found the solution so it will return. Otherwise it will run the iteration for 255 times and then simply return y. If you wanted to know the amount of tokens that will come out from a swap with a curb B1AMM, then what function should you call? The function that you should call which will calculate the amount of token that will come out if you were to swap with the curb B1AMM is the function getdy and getdy underlined. So there are two functions. The difference between the function getdy and getdy makes sense when the tokens inside this pool contract are yield bearing.
01:25:17.577 - 01:25:47.831, Speaker A: For example, for three pull, the tokens are dai, USDC and usdt. If you were to hold these tokens, they will not give you any yield. So in this case, calling the function getdy and getdy give you back the exact same amount. Now consider the case when the tokens inside the pool earn some kind of yield. For example, let's say that we have the tokens DashDC. The token C USDC is a token that you get for depositing USDC into a compound. This token is yield bearing.
01:25:47.831 - 01:26:25.871, Speaker A: If you were to hold on to this CUSDC over time you will earn some interest. And let's say that you wanted to find out how much USDC you will get for putting in dai. But the pool tokens are DAI and cusdc. So in this case, to answer the question how much USDC you will get for putting in dai, you will call the function getdy underlined. It will calculate if you were to put in Dai, how much usdc, which is the underlying token from for C usdc you'll get. But for stableswap3pool, the tokens are Dai, usdc and usdt. So these two function get dy underline and get dy are the same.
01:26:25.871 - 01:26:55.859, Speaker A: So let's take a look at this function getdy. For the input, it's going to take in the index of the token in and index of the token out and the amount of token that you're going to put in dx. And then it calculates the amount of token that the AMM will give you back. First it gets the rates. Remember, for this Stablesoft 3 pool, this rate is a fixed number of 1e18, 1e30 and 1e30. Next it gets the token balance which are normalized to all have 18 decimals. The tokens are DAI, USDC and USDT.
01:26:55.859 - 01:27:28.839, Speaker A: DAI has 18 decimals, but USDC and USDT have 6 decimals. By calling this function, all of the token balances are normalized with 18 decimals. The next part of the code calculates the amount of token that will come out and the fees on token out. The first part is adding the amount of token in to the current balance of tokenin inside this pool. And this part normalizes the amount of tokenin to have 18 decimals. Next, it calculates the pool balance of token out. If we were to put in DX amount of token into this pool.
01:27:28.839 - 01:28:10.677, Speaker A: Remember that this function uses the Newton's method to calculate the new balance of token out. Since token is coming in, the balance of this token out will decrease and taking the difference of the current balance of token out and the new balance of token out and accounting for rounding errors will be also minus one. Basically, this difference of old balance of token out minus the new balance of token out is the calculation for the amount of token that will come out. This is named dy. A fraction of this DY will be kept inside the pool as swap fee. And this is calculated by taking some fraction of DY and the actual amount of token that will come out is dy minus the fee. So that's the function get dy.
01:28:10.677 - 01:29:00.169, Speaker A: The first exercise in curb B1 is to calculate the amount of token you'll get for putting in some amount of token. For this exercise, what you'll do is calculate the amount of USDC that you'll get for putting in Dai and the amount of Dai that you'll use is 1 million Dai. And to calculate the amount of USDC you'll get for putting in 1 million DAI, you'll need to call the function Get DUI. Underlined, if you need a refresher on how to call this function, you can check it out by going Under Source Interfaces Curb IstabSoft 3 Pool and look for a function called getdui on the line. The inputs are the index for tokenin index for token out, and the amount of token in that you're putting in. Let's go over the solution for exercise one. Exercise one was to call the function getdy underlying on istableswap3pool.
01:29:00.169 - 01:29:33.837, Speaker A: So first I'm going to check how to call this function get DY underline inside the interface. Here it is. So I'll copy this and then I'll paste it here. And how do we call the curve Stableswap 3 pool contract? Going up to the setup and above the setup, I can see that the curb 3 pool is initialized as a variable called pool. So the function that we'll need to call here is called pool dot get DY underline. And then we'll need to pass in the correct inputs. The first input will be the index sub token in die has index zero.
01:29:33.837 - 01:30:09.741, Speaker A: The next input will be the index of token out. USDC is index one since this pool is dai, USDC and usdt. And then the amount of DAI that we're going to put in for this exercise, we're going to put in 1 million dai. So this is 1 yi6 die has 18 decimals, 1 e18. The function get dy underline returns a single output called dy. So let's assign this dy to the output of calling the function pool get dy underline. I forgot to put a semicolon here, so I'll put a semicolon.
01:30:09.741 - 01:30:59.301, Speaker A: Okay, and let's try executing exercise one inside the terminal. I'll type forge test dash dash fork URL Fork URL this is an environment variable that contains my RPC URL. And then we'll match on path match path test curb B1 exercises curb B1 swap test. So furthermore, we'll also match on the test dash dash, match test, test, get DY underline and then we'll print out the console logs dash bbb. Okay, the exercise passed for putting in one million dai. This is the amount of USDC that you'll get for exercise two, actually swap the Dai for USDC. The amount of Dai that you'll swap is 1 million Dai.
01:30:59.301 - 01:31:39.441, Speaker A: And as a setup inside this setup, this contract is given 1 million DAI and it has approved the curve stable swap 3 pool contract. To spend all of the DAI here, you'll need to call the function exchange. To swap DAI for usdc. To call the function exchange, you can navigate to the interface called istableswap3pool. And the path to this is specified over here under Source Interfaces Curb, Istableswap3 Pool. And here's the function exchange. The inputs are the index for the token in, index for token out, amount of token that you're going to put in, and the minimum amount of token out that you expect to get back.
01:31:39.441 - 01:32:07.145, Speaker A: So call this function to Swap DAI for USDC. Let's go over the solution for exercise 2. Exercise 2 is to swap 1 million DAI for USDC on curve B1. So the function that we'll need to call is pool dot exchange. And what are the inputs that we need to pass into this function? Let's check the interface. When inside the interface, it's going to take in these inputs. I'll copy these inputs and then we'll paste it here.
01:32:07.145 - 01:32:35.637, Speaker A: And before I forget, I'll put a semicolon as well. Okay, so for the inputs, the first input is the index of the token that we're putting in. We're swapping Dai for USDC and Dai has index 0. USDC has index 1. The amount of Dai that we're going to put in is 1 million Dai 1e 6 times 1e 18. 1 million has 6 zeros, as you can see from here. And Dai has 18 decimals.
01:32:35.637 - 01:33:03.421, Speaker A: 1E6 multiplied by 1E18 represents 1 million Dai. Okay, next, minimum Dy, minimum amount of USDC that we expect to get back. For this example, let's say 999,000 999,000 is 0.999 times 1E6. 0.999 of 1 million is 999,000. And USDC has 6 decimals.
01:33:03.421 - 01:33:40.899, Speaker A: So say 1E6. That completes exercise too. Let's execute this test inside the terminal. I'll type forget for QRL4 QRL match path test curb B1 exercises curb E1 swap test SOL and the exercise that we're going to execute is called test exchange. Okay, and our test passed for putting in 1 million DAI, we got 999,917 USDC. To add liquidity to a curb B1AMM, the user will call the function addliquidity. For example, let's say that a user wants to add liquidity to the stablesword3pool contract.
01:33:40.899 - 01:34:20.025, Speaker A: The stablesword3pool contract holds three tokens, DAI, USDC and USDT. The user will call the function addliquidity and specify the amount of dai, USDC and USDT to put inside the contract. Curbing one allows the user to specify the amount of tokens to put in. In the example of Stablesoft 3 Pool, we have three tokens and the user can specify the amount of any of this token to be equal to zero. For example, if they only wanted to put in dai, they would put in some amount of dai. And for USDC and usdt, they would specify zero. As another example, let's say that the user only wants to put in USDC and usdt.
01:34:20.025 - 01:35:01.185, Speaker A: Then for USDC and usdt, they will specify amount that is greater than zero. And for the amount of dai, they will set it equal to zero. Next, the amount of tokens that the user specified is transferred into the stableswap tuple contract, and the contract will calculate the amount of LP shares to mint to the user. Here, LP means liquidity provider. The owner of the LP shares will later be able to withdraw any of these tokens in exchange for giving the LP shares back to the pool contract. Let me quickly outline what's going inside the function addliquidity before we do a cold walkthrough of this function. The first part of this function is to calculate the imbalance fee multiplier.
01:35:01.185 - 01:35:40.425, Speaker A: In Kerb eOne, users can specify the amount of tokens to add as liquidity. This can cause the token balances in the pool to become imbalanced. For example, in the case of three pools, let's say that there are 100 DAI, 100 USDC and 100 USDT. And now a user comes in and adds 1 million DAI as liquidity. The resulting token balances will be 1 million and 100 DAI, 100 USDC AND 100 USDT. To discourage users from imbalancing the pools, there is an imbalance fee. If you cause the pool to become severely imbalanced, then you'll be charged a lot of fees.
01:35:40.425 - 01:36:14.185, Speaker A: So the first step is to calculate this imbalance fee multiplier, which will later be used to calculate the imbalance fee. The next step is to calculate the A parameter and then calculate the current liquidity inside the code. This is called d0. Now, inside the function addliquidity, liquidity will be calculated several times. The first part is to calculate liquidity before adding in any tokens. The next part is to calculate liquidity again after adding tokens. And then the last step is to calculate liquidity after minusing the imbalance fees.
01:36:14.185 - 01:36:36.067, Speaker A: We'll come back to this again. Moving on. Next, it transfers the tokens in and then it will update the token balances. At this point, it doesn't touch the state variables. It caches the token balances in memory and then updates this balance in memory. And then like I said before, it will Calculate liquidity again inside the code. This is named D1.
01:36:36.067 - 01:37:14.407, Speaker A: So here D0 will be the liquidity before adding tokens and D1 will be the liquidity after adding tokens. Once we have D0 and D1, next it calculates the imbalance fee. The updated token balances will be subtracted with the imbalance fees. And then next it will calculate the liquidity again D2, this is called D2 in the code. And it will represent the liquidity after adding tokens and then subtracting imbalance fees. Next it will update the token balances and this time it is updating the state variables. So why is it updating the token balance in memory over here? But over here it's updating the state variables.
01:37:14.407 - 01:37:48.255, Speaker A: The reason is is to save gas whenever you read or write to the state variable. It is very expensive compared to updating some data inside memory and then calculate the LP shares, the liquidity provider shares and then finally mint lp. So that's the quick outline of the function. Add liquidity. When a user adds or removes liquidity in a manner that changes the current ratio of the pool balances, a fee is deducted for causing this change. This is called the imbalance fee. Here you're looking at the code for the calculation of the imbalance fee when liquidity is added.
01:37:48.255 - 01:38:17.131, Speaker A: This block of code might be difficult to understand and. And when I first saw this, I had to draw example using paper and pen to see what's going on over here. So in this video let's go through a visual example of how to calculate the imbalance fee. Let's say that we have a stable swap pool where the tokens are DAI, USDC and USDT. With 100 DAI, 90 USDC and 110 USDT locked in this pool. With these token balances we calculate liquidity D. Let's call this D0.
01:38:17.131 - 01:39:02.625, Speaker A: When we divide D0 by 3, this will give the token balance of each tokens when the pool is perfectly balanced. So when the pool is perfectly balanced, we should roughly have approximately 100 DAI, 100 USDC and 100 USDT. Now to go through an example of imbalance fee, let's say that we added 300 DAI. So now the token balance of DAI is 400 when the pool is perfectly balanced. With this new token balances, we should roughly have D13amount of tokens. So the pool will approximately have 194 Dai, USDC and USDT. The imbalance fee is calculated by taking the difference of the actual balances of the tokens with what Curve calls ideal balances.
01:39:02.625 - 01:39:47.987, Speaker A: This ideal balance is calculated by comparing D1 and D0 liquidity before making some kind of change and liquidity after making some kind of change. In this example, liquidity before was approximately 299 and after is approximately 581. When we divide liquidity after by liquidity before, we get A ratio approximately 1.94. This will give us the percentage of how liquidity changed. In this case it says that liquidity increased by 94%. The ideal balances are calculated by taking this ratio of the change in liquidity and then multiplying it by the previous token balances. In our example, before adding liquidity we had 100 Dai.
01:39:47.987 - 01:40:16.823, Speaker A: So the ideal balance of DAI if we were to add liquidity is that previous amount of DAI 100. Multiplied by this ratio 1.94. This turns out to be 194. For USDC, the token balances has not changed. We take the previous token balance 90 and then multiply by the ratio 1.94. And this turns out to be approximately 174. And we do the same for ESDT, the previous balance is 110.
01:40:16.823 - 01:40:45.947, Speaker A: We multiply by the ratio 1.94 and we get that the ideal balance of USDT is 213. The liquidity increased by 94%. So in the ideal situation we should increase all of the token balances by 94%. But as you can see in our example this is not the case. And now moving on to the imbalance fee. Imbalance fee is calculated by taking the difference of the actual token balance and then taking a percentage of that difference as fees.
01:40:45.947 - 01:41:07.513, Speaker A: So for example, the ideal balance of DAI is 194. The actual balance of DAI is 400. Taking the difference we get, the difference is 206. We do the same for USDC and USDT. For USDC, the ideal balance is 174. The actual balance is 90. Taking the difference we get 84.
01:41:07.513 - 01:41:29.381, Speaker A: And finally USDT, the actual balance is 110. The ideal balance is 213. The difference is 103. And finally, moving on to the calculation of fees. For this example, let's say that the fee multiplier is 1%. Starting with DAI, we have that the difference is 206. Multiply this by the fee multiplier 1%.
01:41:29.381 - 01:41:48.695, Speaker A: And we get that we're going to charge 2.06 DAI as imbalance fee. For USDC, the difference is 84. 1% of 84 is 0.84. So from the token balance of USDC we deduct 0.84 for USDT. The difference is 103.
01:41:48.695 - 01:42:18.163, Speaker A: 1% of 103 is 1.03. So we deduct 1.03 from the balance of USDT. Now the imbalance fee does not actually transfer the tokens out out of the pool. The actual Token balances are still 400 DAI 90 USDC and 110 USDT. The token balances that you see over here are used for the next part of the calculation calculating the final liquidity after taking into account the imbalance fees. Let's call this liquidity D2.
01:42:18.163 - 01:43:03.467, Speaker A: In our example we added liquidity and this final liquidity is used in the calculation of minting pool shares. And of course since we deducted imbalance fee, this final liquidity is slightly less than liquidity before subtracting the imbalance fees. If you are wondering how I was able to come up with the numbers that I used in this example, what I did was I wrote a Python script. Given the token balances and the amount of tokens to put in, it will calculate the liquidity before before adding liquidity. After adding liquidity, the imbalance fees and then the liquidity accounting for the imbalance fees. Next I took these numbers and then plotted on a graph. Now if you also want to experiment with this script first go over to the project repo and from here click on a folder called Notebook.
01:43:03.467 - 01:43:46.189, Speaker A: The code that you just saw is called Curb B1 Imbalance Feed. Now to execute the script you'll need to install Jupyter Labs and Python. The function addliquidity is called to add tokens into Kerr B1's AMM for the input it's going to take in the amount of coins to put in and the minimum amount of LP token to mint mint amount. Next it initializes some variables. FEES is a rate that will be used later for imbalance fee. Curb V1 allows you to add liquidity in a way that makes the token balances imbalanced. For example, you can decide to put only one token in or you can decide to put all tokens in and when you add one token as liquidity, this will make the current pool balance imbalanced.
01:43:46.189 - 01:44:13.361, Speaker A: So that is what this FEES array is used for. We'll come back to this later. Next we have a variable called fee. This number is used to charge for the imbalance fee. If you take a look at this it has a weird formula fee multiplied by ncoins divided by 4 times n coins minus 1. Basically what this does is it makes sure that when you add liquidity and then remove liquidity, it won't be like swapping tokens without any swap fee. Let me explain this further.
01:44:13.361 - 01:44:43.495, Speaker A: Let's say that we have token X and then we swap and then we get back token Y. In this case, we will have a swap fee on token Y. Now, in Curve v1, we can also add liquidity in such a way that makes the token balances of the pool imbalanced. For example, we can decide only to add one token. So let's say we add X token to the pool. X token add liquidity. Now, curvy one also allows us to remove liquidity in such a way that makes the token balances of a pool imbalanced.
01:44:43.495 - 01:45:31.253, Speaker A: So for example, after we add only one token as liquidity, let's say that we remove liquidity and we remove liquidity in another coin, say remove liquidity and we request token Y out. So effectively what we did here was we put in X token and then we took out token Y. This is the same as swapping token X for token Y. Now, if you did not have fee on imbalance fee when we're adding liquidity, basically this allows us to swap tokens for free and to make sure that this does not happen. This weird equation makes sure that when we add liquidity and then remove liquidity, it is basically like a swap for the math for how to derive this part of the equation. Put a link in the course. So that's what this fee is used for.
01:45:31.253 - 01:45:56.643, Speaker A: And then we get the admin fee and then calculate the underscore rate. Next we get the total supply. This will be the total supply of LP tokens that I minted. And then we first calculate liquidity. D0, d0 will be the liquidity before we add any tokens into this pool. And we can see this over here. D0 is equal to get the mem with the old balances, where the balances are the token balances of this pool.
01:45:56.643 - 01:46:27.397, Speaker A: And then we initialize the array called new balances, which is basically copying the old balances. The next part of the code deals with transferring in the tokens. So scrolling down we can see that inside the for loop we get the coins to put in as liquidity. And then we call the function transfer from. And notice that here we're using raw call. This is to go around the problem that USDT does not return any boolean when transfer from is called. If you were to use the ERC20 interface for transfer from.
01:46:27.397 - 01:46:56.301, Speaker A: When we call transfer from on usdt, this part of the code will fail. So to avoid this problem, it's using a raw call to call transfer from. So for each iteration, it's going to transfer the tokens in and then it updates this new balances. Remember this new balances was initialized as old balances. So to the old balances we add some amount, the amount that came in. And with this new balances, next we calculate the D again. This time it is called D1.
01:46:56.301 - 01:47:37.761, Speaker A: Again, this D represents liquidity. We added some new tokens. And here what it's doing is it's asking with this new balance, what is the new liquidity? The next part of the code is calculating the imbalance fee. Imbalance fee basically means that if we were to add tokens into this pool in such a way that does not change the token balance ratios, then we've added tokens in an ideal way. Otherwise, if the ratios of the token change when we add liquidity, then there is some kind of fee that we'll have to pay. So the first question is, well, what is the ideal balance to add as liquidity? And the answer is simple. We take the old balance and we look at D0.
01:47:37.761 - 01:48:04.169, Speaker A: This will be the liquidity before adding liquidity. And then d1, this will be the liquidity after adding liquidity. D1 divided by d0 will be the increase in liquidity. So the old balance should increase by this much amount, d1 divided by d0. As an example, let's say that d1 is 110, d0 is 100. So d1 divided by d0. So the ideal new balance will be 1.1
01:48:04.169 - 01:48:30.475, Speaker A: times the old balance. Next, we calculate how much the new balance is off from this ideal balance. If the ideal balance is greater than new balances aby, then the difference is ideal balance minus new balances aby. Otherwise it's the opposite. New balances aby minus ideal balance. Here we're just getting the difference of ideal balance and new balances aby. And then phi will be equal to this magic number phi that we saw over here.
01:48:30.475 - 01:49:03.769, Speaker A: And then multiplies it by the difference and then divides it by the fee denominator. This is the imbalance fee that will be charged for each token. Looking at this equation, let's imagine the case that we added liquidity so that the difference will be equal to zero. This will mean that the new balance is exactly equal to the ideal balance. And when we execute this part of the equation, we see that the difference will be equal to zero. So the fee for adding liquidity, in this case, the Fee will be equal to zero. The next part of the code is to update the balance of the tokens.
01:49:03.769 - 01:49:31.441, Speaker A: The balance of the tokens will be the new balance. And then a fraction of the imbalance fee will be given to the admin. This is what this part of the code is doing. Take the imbalance fee multiplied by some ratio which are given to the admin here. Admin means the owner of this contract. And then from this new balances we minus the fees and using this new balance we calculate the liquidity again. This time we name it as D2.
01:49:31.441 - 01:50:10.075, Speaker A: So what we did here was we started with the old balance, added the amount of tokens that came in, and then from there we minus the imbalance fee to get new balances. And from this new balance we calculate the liquidity again. D2. And the last part of the code is to Mint LP based on the increase from D0 to D2. And you can see this over here. Token supply multiplied by d2 minus d0. That's the difference between d2 and d0 and then divided by d0 and then it checks that this LP amount is greater than the min mint amount specified by the user and then it actually mints the LP tokens.
01:50:10.075 - 01:50:50.169, Speaker A: So that is the function add liquidity. There's one exercise to add liquidity to curb B1. In this exercise, you'll add 1 million Dai as liquidity to curb B1ammo for the setup, this test contract is given 1 million Dai and it has approved pool to spend all of the dais to add liquidity, you'll need to call the function addliquidity on the interface istablesoft3pool. The function addliquidity will take in two inputs. An array of amount of tokens that you're going to put in and the minimum amount of LP that you expect to get back. The tokens inside the pool are dai, USDC and usdt. The first element in this array will specify the amount of DAI to put in.
01:50:50.169 - 01:51:20.891, Speaker A: The second element in this array will specify the amount of USDC to put in. And the last element will specify the amount of USDT to put in. So first exercise one, call the function addliquidity to add DAI as liquidity to curb B1. Let's go through the solution for exercise one of adding liquidity to curve B1. The function that we will need to call is called addliquidity. And how do we call this function? I'll navigate to the IstabSwap3 pool interface. And then this is the function that we're going to need to call.
01:51:20.891 - 01:51:58.995, Speaker A: So I'll copy this and then we'll paste it here. And before I forget, I'll put a semicolon here and the contract that we'll need to call. If I scroll up, the stableswap three pool contract is initialized as a variable called pool. So the contract that we need to call here is pool.add liquidity and then we'll need to pass in these parameters. Let's first create a uint256 array of size 3 with the balances of the coins to add as liquidity. Say uint256 size is 3 memory and I'll call it coins is equal to.
01:51:58.995 - 01:52:40.259, Speaker A: We're going to put in 1 million die and the first element in this array represents the amount of die that we'll put in. Say uint 256 1e6 times 1e18 1e18 because die has 18 decimals. Since we're only going to put in die, the rest of the numbers in this array will be zeros, uint256 0 and uint256 0. Okay, once we prepare the coins array, we can remove this part. And next let's prepare min LP, the minimum amount of LP tokens to mint for putting in 1 million Dai. For simplicity, let's just put a one here. Okay, that completes the exercise for Add liquidity.
01:52:40.259 - 01:53:12.689, Speaker A: Let's try calling this function inside the terminal. I'll type forge test--fork URL fork URL from my environment variable and then match path curb b1. Exercises curb b1 add liquidity.test. solve okay, and then type bbb to see what console logs prints out. So now we've added liquidity. There are several variations to Remove liquidity. Let's look at the first way by calling the function Remove Liquidity.
01:53:12.689 - 01:53:55.711, Speaker A: Remove Liquidity will burn the LP shares of the liquidity provider and then send back all of the tokens in the pool in proportion to the amount of LP tokens that they burn back to the liquidity provider. For example, let's say that a user calls Remove liquidity on the Stablesoft 3pool contract. The Stableswap 3pool contract has three tokens, DAI, USDC and USDT. The user will specify the amount of LP shares to burn. The Stableswap contract will calculate the amount of DAI, USDC and USDD to give back to the user, burn the shares, and then send all of these tokens back to the user. The function Remove Liquidity is not difficult to understand. First they will calculate the amount of tokens to send back to the user.
01:53:55.711 - 01:54:52.087, Speaker A: Next, they will update the state variables that keep track of the token balances and then transfer the tokens out and then burn the amount of LP shares that the user specified. Another common way to remove liquidity is to call the function Remove Liquidity 1 coin. What this function will do is it will burn the LP shares of the user and then send back a single token that the user specifies. For example, on the Stablesoft 3 Pool contract, let's say that a user calls removeliquidity 1 coin and then specifying some amount of LP shares to burn. And for this example, let's say that user wants all of their liquidity withdrawn in a single token dai. The stableswap contract will calculate the amount of DAI to send back to the user and then transfer this DAI over to the user. In the examples that we looked at, the difference between this function and the function Remove Liquidity is that Remove Liquidity will send back all three tokens to the user.
01:54:52.087 - 01:55:30.355, Speaker A: However, this function will send a single token that the user specifies, and in this case the user specified that they wanted all of their liquidity withdrawn. In dai, the function Remove liquidity may be a little bit difficult to understand. So let me quickly outline what's going on inside the function Remove liquidity one coin. The first step is to calculate the amount of token to go out inside the code. This is named dynamic and it also calculates the imbalance fee. Now, the function that calculates DY and the imbalance fee may be difficult to understand. This function is called calcwithdrawal 1 coin.
01:55:30.355 - 01:56:14.947, Speaker A: Here I'm going to mention three things that this function does. It will calculate the A parameter and then it will calculate the liquidity V and then it will calculate the imbalance fee. Since here we're removing liquidity as a single coin, this will have the effect of making the token balances in the pool become imbalanced. The next step is to update the state variables that keep track of the token balances and then burn the LP shares that the user specified. The last step is to transfer the token out. There are several options when it comes to removing liquidity from kerb B1AMM if you wanted to remove liquidity in a balanced way, then this will give you back all the tokens in the pool proportional to your LP tokens. This function is called Remove Liquidity.
01:56:14.947 - 01:56:56.841, Speaker A: The other two options are to Remove Liquidity, where you specify the amount of tokens to remove and to remove only one coin as Liquidity the functions are called Remove Liquidity, Imbalance and Remove Liquidity one coin. Let's first take a look at the function Remove Liquidity. Again, as an input, it's going to take in the amount. This will be the amount of LP tokens to burn and the minimum amount of tokens to return. And what this function will do is it will take in your LP and then send you back all of the tokens inside the pool proportional to the LP tokens that you burned. First, it caches the state variable Total supply. This will be the total supply of LP tokens and then initialize the array called Amounts and Fees.
01:56:56.841 - 01:57:47.965, Speaker A: When we remove liquidity by calling this function, there's no imbalance fee since all the tokens will be removed in proportion to the LP tokens. And as you can see over here says that fees are unused. So there's no imbalance fee for this function. So inside the for loop we can see that it calculates each amount to send by taking the balance of the coins multiplying by the LP token to be burnt divided by total supply. And then it checks that this value to be sent back to the caller is greater than or equal to the minimum amount specified by the caller, updates the balance, and then stores this amount to be sent to an array called amountabyte. Next is the part where it actually transfers the tokens to the message sender for the amount value, which is calculated over here. And then it burns the LP tokens and then it emits an event called Remove Liquidity.
01:57:47.965 - 01:58:25.131, Speaker A: So this is a function to be called if you wanted to just burn your LP tokens and in return you will receive all of the tokens inside the pool and the ratio of LP tokens that you burnt. The function Remove Liquidity one coin is called if you wanted to withdraw your liquidity all in a single coin. For example, inside the Stableswap 3 pool, the tokens are DAI, USDC and USDT. And let's say that you provided some liquidity and now you want to remove your liquidity. However, you don't want all three tokens, dai, USDC and usdt. Instead, you want your liquidity withdrawn in one token. Let's say dai.
01:58:25.131 - 01:59:03.493, Speaker A: Then you will call this function Remove Liquidity. One coin specifying the amount of LP tokens to burn and the token that you want to withdraw to calculate the amount of token that will be sent back to you. In our example, this Token will be Dai. There's an internal function called calcwithdraw1coin which will calculate the amount of token to send back to you. The code for this function may be a little bit difficult to understand. So before we do a code walkthrough, I first want to show you a geometric explanation of how this function calculates the amount of token that you will receive. Imagine that we have a curve B1AMM with liquidity equal to 20.
01:59:03.493 - 01:59:31.899, Speaker A: So this will be D equal to 20. Let's say that the current token balance is over here, shown as an orange point. As a quick review for our amm, token balances must be a point on this blue curve. And currently our token balances are over here. Next, let's say that we decrease the liquidity by 50%. Initially, the liquidity D is 20, and then we reduce this liquidity D to 10. The resulting curve is shown in pink.
01:59:31.899 - 02:00:05.401, Speaker A: Now, a ideal way to decrease the liquidity is to decrease the token balances by the percentage that the liquidity decreased by. For this example, we decrease the liquidity by 50% from 20 to 10. So in this case, the token balances should also decrease by 50%. This applies both to token X and token Y. For this example, initially we had a token balance of x equal to 6.57 and y equal to 13.52. The liquidity will decrease by 50%.
02:00:05.401 - 02:00:26.245, Speaker A: So the ideal amount of token X to withdraw will be half of this. This is equal to 3.285 and so on. This is an approximation. And the ideal amount of token Y to withdraw is half of this number. This is approximately 6.76. When we do this, the resulting token balance will be over here, shown in green.
02:00:26.245 - 02:01:01.807, Speaker A: Now, notice that in this case we withdrew two tokens. However, for remove liquidity one coin, we only want to withdraw in one coin. So on the graph, what would go on when we withdraw token in one coin? So let's see what would go on here when we withdraw liquidity in one coin. For this example, we'll say that the token that we're going to withdraw is tokeny token. Next is the horizontal X axis and token Y is the vertical Y axis. So we're going to be decreasing the amount of token Y. Since we're not going to withdraw token X, the amount of token X should be the same.
02:01:01.807 - 02:01:52.035, Speaker A: So we can represent this as a vertical line that goes through the current token balance of token X. Now recall that for AMMs, token balances must be on the curve that is defined by the AMMS equation. In our case, when we decrease liquidity, since we know what the amount of token X is, it must be somewhere on this line, then the only token balances that satisfies where the token X will be on this line and the balance of token Y will be on this pink line is the intersection between this green line and this pink line. This point shown in orange will be the actual token balance. After withdrawing liquidity only in a single token, the amount of token X remains the same. Since we're not withdrawing token X, we're only withdrawing token Y. So the balance of token Y decreases.
02:01:52.035 - 02:02:37.333, Speaker A: This difference between the original balance of token Y and the new balance of token y that is calculated by the function calcwithdraw1coin. Taking the difference will give us the amount of token Y that the user will receive. Then of course from this amount fees will be deducted. Another function that you can call to remove liquidity and if you wanted to remove liquidity in one coin, then you will call the function remove liquidity one coin. For example, inside the Stablesoft 3 pool, the tokens are DAI, USDC and USDT. If we call the function Remove liquidity then it will give you back all three tokens. However, let's say that you wanted to just withdraw in USDC, then you will call remove liquidity1coin and then specify the token that you want to withdraw.
02:02:37.333 - 02:03:16.499, Speaker A: For the inputs, it's going to take in the token amount. This will be the LP token to be burnt. And then it's going to take in the index of the token to withdraw and the minimum amount of token that you expect to receive. And based off of this token that you want to receive, it calculates dy. This will be the amount of single token that you will receive. And this calculation is done by an internal function called calcwithdraw onecoin which we will take a look at in the next video. Checks that this DY is greater than or equal to minimum amount specified by the user updates the token balances minus DY from the current balance of tokens and also a fraction of DYF is given to the admin.
02:03:16.499 - 02:04:00.129, Speaker A: So we also minus this from the current balance, burn the LP tokens, send the tokens by calling the function transfer and then that completes the function Remove liquidity one coin. One thing to note here is that remember that when we add liquidity there was an imbalance fee and now we have this function called Remove liquidity one coin which will allow us to remove liquidity per one coin. So if we do add liquidity with one coin and then remove liquidity with another coin, this is like swapping a token. And if there wasn't any imbalance fee, then this is like swapping without any swap fees. So that is why there's an imbalance fee. When we add or remove liquidity in a way that makes the token balances in the pool imbalanced. Inside the function.
02:04:00.129 - 02:04:35.417, Speaker A: Remove liquidity one coin. There's an internal function called calcwithdraw one coin which will calculate the amount of single token that you will receive for burning this much amount of LP tokens. Let's take a look at how this function is implemented. As a note, there's also an external function that calls into this internal function calcwithdraw1coin. Given the LP amount and the token that you want to receive, it will calculate the amount of token that you will receive for burning this much amount of LP tokens. Okay, here's the internal function calcwithdraw1coin. For the inputs, it's going to take in the LP amount and the token that you wish to withdraw.
02:04:35.417 - 02:05:23.035, Speaker A: For the output, it's going to calculate the amount of token that you will receive and the fees. The first part is to get the A parameter and then next it initialize the variable that is used for the imbalance fee, creates an array called precisions, caches the total supply, the total supply of LP tokens, and then gets the balance of tokens that are normalized to all have 18 decimals. And then it calculates the liquidity d0. The next part of the code deals with calculating the imbalance fee. First it calculates the ideal liquidity D1. If we were to burn this much amount of LP tokens, given the total supply, the liquidity will decrease by this LP amount to be burned, divided by the current total supply of LPs. For example, let's say that D0 is 100.
02:05:23.035 - 02:05:51.155, Speaker A: And let's say that we have 10 token 10 LP tokens. And again this D0 will be 100. And let's say that we have also 100 LP tokens. What is the percentage of LP tokens that we're burning compared to the total amount of LP tokens? Well, this is 10 will be the amount of LP tokens that we're burning. And total supply will be the total amount of LP tokens. 10 divided by 100 will be 0.1, which is equal to 10%.
02:05:51.155 - 02:06:28.257, Speaker A: So what this part of the code is doing in this example is we're taking 10% of the current liquidity and then subtracting it from the current liquidity. 10% of the current liquidity, 100 will be 10100 is the current liquidity, 100 minus 10 will be 90. In this simple example, D1 will be equal to 90. Next, we initialize the array that will be used to calculate the imbalance fees. First, we take D1. This is the current liquidity reduced by the amount of LP tokens that we're burning. And then we use a Newton's method called getyd to calculate the new y.
02:06:28.257 - 02:07:13.373, Speaker A: Since the liquidity d1 is less than the liquidity d0, when we calculate the new y with d1, this new y will be less than the current Y. To further explain, let's say that we have a perfectly balanced pool with three tokens, x0, x1 and x2, all having 100 tokens. And let's say that the liquidity is d0. Since this is a balanced pool, all of the token amounts will be d0 divided by 3. So d0 divided by 3 will all be equal to 100. After reducing this current liquidity d0 by the amount of LP tokens that we're burning, let's say that if we were to remove liquidity in a balanced way, then D1 will be over here. So from token x0 we will remove this much amount of token x0.
02:07:13.373 - 02:07:38.205, Speaker A: For x1, we will remove this much amount of x1. And likewise for x2, we will remove this much amount of x2. All of these amounts that we're going to be removing are the same. So this is the ideal D1 over 3. Why is it 3? Well, because we have 3 tokens. However, inside this code, we're saying that we only want to remove one of the tokens. Let's say that the token that we want to remove is x1.
02:07:38.205 - 02:08:27.029, Speaker A: So keeping the token balance for token x0 and token x2 the same at 100 and 100, we're going to remove only x1 until the new liquidity is d1. If we were to remove tokens in a balanced way, then the amount of tokens after removing will all be over here. However, since we're removing only one token and the rest will stay the same, this new Y, which represents the new token balance for X1 will be lower than D1 3. So keep this in mind as we go down further in the code. We calculate new Y and first we calculate the difference and it's called DY0. The difference will be the current token balance XP minus this new balance, which was calculated from above. The next part is to calculate the imbalance fee.
02:08:27.029 - 02:09:24.227, Speaker A: It runs a loop for each token. If J is equal to the Index of the token that we're removing, then the difference from the ideal amount of tokens to remove is XP of J will be the current balance of token that we're removing and the liquidity will decrease by D1 divided by D0. So this will be the ideal amount of token balance after removing. However, the actual amount that we're removing is this new y taking the difference. This will give us the difference from the ideal balance after removing liquidity and the actual amount after removing liquidity. Otherwise, for J, if j is not equal to the token that we're removing, the ideal balance is again given by XP times the decrease in liquidity d1 divided by d0, the actual amount will be XPOJ. Since we're not removing any tokens from these tokens, once we calculate this difference from the ideal balance and the actual balance, we multiply this by the fee to calculate the imbalance fee.
02:09:24.227 - 02:10:11.359, Speaker A: Once the imbalance fees are calculated, the next part is to calculate the actual amount of tokens that will leave this pool. And this is calculated by taking the token balance after the imbalance fee and then calculating the new balance of token that's leaving by using the token balances with the imbalance fees subtracted, taking the difference. This will give us DY the actual amount of tokens that will come out of the pool minus one accounting for rounding errors and then return the actual amount to be sent and the imbalance fee on this token. So that is a function calcwithdraw with one coin. There are two exercises to remove liquidity from curb B1amm. For the setup, the test contract is given 1 million daisy and it has put this 1 million dai as liquidity to curb B1 pool. So at this point you'll have some LP tokens.
02:10:11.359 - 02:10:52.585, Speaker A: The LP token is called kerb3crb for this test, the variable name for this curb3crb is LP. You'll be using this to remove liquidity. For the first exercise, call the function Remove Liquidity. Remember that the function Remove Liquidity will burn your LP tokens and give you back all of the tokens in the pool. For the SuiteShop3 pool, the tokens are DAI, USDC and USDT. So after you call the function removeliquidity, you'll get DAI, USDC and USDTD. For this exercise, call the function removeliquidcity and you'll need to specify the amount of LP that you're going to be burning the balance of the LP token inside this test contract.
02:10:52.585 - 02:11:33.857, Speaker A: Since LP is a IERC20, you can get the balance of LP tokens locked inside this contract by simply calling Balance of passing in the address of this contract. Once you get the LP balance of this contract, call the function Remove Liquidity passing in the amount of lp. For this exercise, you'll be removing all of the LP tokens and then the main coins. The minimum amount of coins that you expect to get back when you burn some amount of LP. For simplicity, you can put this main coins as 0 or 1 or whatever you want. There are two exercises to remove liquidity from curb B1's AMM. The first exercise is to call the function remove liquidity.
02:11:33.857 - 02:12:07.923, Speaker A: First let's check how we will call this function inside the interface istableswap3pool. I'll copy this function declaration and then paste it here. And I'm also going to check the name of the variable that is initialized for the curb b1's pool. The name of the curb b1's pool is called pool. So over here I'll call pool dot remove liquidity. And now we need to figure out the balance of LP that is locked in this contract and the minimum coins that we expect to get back. Let's start with the first one.
02:12:07.923 - 02:12:44.255, Speaker A: How will we get the balance of LP tokens that is locked inside this contract? Let's check the setup. Looking at the setup, we added liquidity to this curve B1ammo and the LP token that we get back is called LP so. And it's also a ERC20 token. So we can get the balance of LP tokens inside this contract by calling lp.balance of address this. Let's store this into a variable uint256. I'll call it LP Val and then we can put it in here LP.
02:12:44.255 - 02:13:17.789, Speaker A: Okay. The next part is to prepare this minimum coins array say uint 256 of size 3 memory. I'll call it Min coins is equal to. For this exercise, let's keep it simple and just put a 1uint256 1,uint256.1 and uint256 1. Okay. And then call the function Remove Liquidity with LPB and min coins.
02:13:17.789 - 02:13:56.457, Speaker A: That completes the first exercise for removing liquidity from Kirby 1. Let's execute the test and then call the function Test Remove Liquidity. For this exercise, there is a function called Test Remove Liquidity and Test Remove Liquidity one coin before we execute the test for exercise one. I only want this test Remove Liquidity to match exercise one. So I'll put in a regular expression to Say that we only want to match test Remove Liquidity. Do that by putting a backslash, opening parentheses, backslash and then closing parentheses and then execute the test. Okay, and our test passed.
02:13:56.457 - 02:14:35.897, Speaker A: When we call the function Remove Liquidity, it gave Us back all three tokens. We got approximately 368,000 Daisy, 373,000 USDC and 257,000 USDT. For the second exercise of removing liquidity from Curve B1, call the function Remove Liquidity One Coin. This function will remove liquidity in a single coin that is specified by the caller. In this exercise, you'll take the LP token, burn all of the LP token, and then withdraw all of your liquidity in dite. Inside the setup of this test, it adds liquidity. So this contract already has some LP tokens.
02:14:35.897 - 02:15:10.373, Speaker A: This LP token is a ERC20 contract. So you can get the balance of LP tokens locked in this contract by calling balance up. And the function that you'll need to call is called Remove Liquidity one coin passing in the LP amount. This amount will be the LP balance locked inside the test contract. Specify the index of the token that you're withdrawing inside the stableswap people. DAI has index equal to zero and then the minimum coin, minimum amount of DAI that you expect to get back. For this exercise, we'll keep it simple and you can put in 0, 1 or whatever number you want to put in.
02:15:10.373 - 02:15:43.895, Speaker A: Okay, let's go over the solution for calling the function Remove Liquidity. I'll navigate to the interface and then Copy this Remove Liquidity 1 coin. Paste it here, Put a semicolon and the contract that we'll need to call is pool dot remove liquidity one coin. The first input is the LP balance. The LP balance inside this contract. Let's call this UN256LP is equal to the contract is LP and then it is a ERC20. So we can call balance of.
02:15:43.895 - 02:16:05.603, Speaker A: Address this. Replace this LP with LP bal. For this exercise, we're going to remove die so the index of die is zero. And for a min coin, let's just set it to one. Okay, so that completes the exercise. Let's try executing the test inside the terminal. I'll execute the similar command from the previous exercise.
02:16:05.603 - 02:16:29.515, Speaker A: I'll modify the regular expression to match the test. Test Remove liquidity, underscore one coin. Okay, and our test passed. Unlike the previous exercise. Notice that the only token that we got back is Dai. And we got back approximately 999,905 died. We received zero USDC back and zero USDT back.
