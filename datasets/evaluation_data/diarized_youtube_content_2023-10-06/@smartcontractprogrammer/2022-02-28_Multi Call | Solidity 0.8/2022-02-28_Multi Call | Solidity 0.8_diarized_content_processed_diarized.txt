00:00:00.650 - 00:00:30.534, Speaker A: Let's say that I want to make a bunch of queries to a smart contract. I want to call multiple functions, and maybe I want to call multiple contracts. For this example. We'll keep it simple, and we'll say that we want to call function one and function two. Now, what we can do here is call function one, get the results, and then call function two, and then also get the results. Now, the problem with this approach is that blocked out timestamp may be different. We call function one, and we get a timestamp, and then we call function two.
00:00:30.534 - 00:01:18.882, Speaker A: So this timestamp might come after this timestamp. However, we can aggregate these two function calls, function one and function two, into a single query by writing a contract called multicol. The basic idea of this contract multicol is that we'll have a function to call these function funk one and then funk two, and then return both of the results. So we'll name it contract multicall, and then it will have a single function. I'll name it function multicall, and it's going to take in some parameters. The first parameter will be the addresses of the contracts to call address bracket call data, and then I'll name it targets. And then the other parameter is the data to pass to each target.
00:01:18.882 - 00:02:04.610, Speaker A: So I'll say bytes bracket call data. This function will be external view, and then it's going to return the output from each call to a target, and those data will be in bytes. So we'll return bytes array memory. Inside this function, we'll run a for loop to make call to each of these targets. Passing in the data, it will return an output, and we'll store that output in the array of bytes. But before we do that, we'll first check that the length of the targets is equal to the length of the data. So we'll say require targets length is equal to data length.
00:02:04.610 - 00:02:47.678, Speaker A: With the error message target length is not equal to data length. Next, we'll initialize an array of bytes. This will store the outputs and then return it. So we'll say bytes bracket memory results is equal to new bytes bracket. And we'll initialize this bytes array in memory to have the length equal to data length. We'll run a for loop, and then afterwards we'll return this results array by typing return results. Lastly, we'll run a for loop to call each of the targets.
00:02:47.678 - 00:03:28.478, Speaker A: So we'll say four un I I less than targets length I plus plus. And then we will call each of the targets by typing targets of I static call notice that here I'm using static call instead of the familiar function call. This is because we're going to make this function a view function. If you want to send transactions, then you would remove this view function. And instead of calling static call, we would say just call. But here we just want to query it. So we'll say static call.
00:03:28.478 - 00:03:51.798, Speaker A: And inside the parentheses we'll pass in the data of I. By typing data I. Now, similar to the dull double function call, this function execution will return two outputs. The first output will be a boolean. And this will tell us whether the call was successful or not. So we'll say success. And the second output will be any data that was returned by calling the function.
00:03:51.798 - 00:04:17.674, Speaker A: So it'll be bytes memory. I'll call it result. We will check that the function call to static call was successful by typing require success. Call failed. Once you know that the function was successful, we'll store the result in the results array. By typing results of I is equal to result. Let's try compiling this contract.
00:04:17.674 - 00:04:42.902, Speaker A: So I'll hit Ctrl s. We'll deploy this contract and also this test multicall. We'll prepare some data to call function one and function two. And then call multicol. We'll call the function multicol passing in the address of the test multicol contract twice. Once to call the function funk one, and the next one to call the function funk two. But before we do that, we need to prepare the data to pass in here.
00:04:42.902 - 00:05:19.282, Speaker A: This data will instruct the EBM to call function one and function two. To get the first data, I'll say function get data one. This will be external peer. Then it's going to return the bytes. Returns bytes, memory. To get the data to call function one, we'll say return Abi encode with selector this funk one selector. Now, this code that you see over here.
00:05:19.282 - 00:05:48.326, Speaker A: Does exactly the same thing as what I've showed you before. Abi, encode with signature passing in the string function signature of funk one. We will also get the data for funk two. So I'll copy this, paste it, and then we'll say, get data two. And change funk one to funk two. Okay, so we're now ready for the demo. I'll deploy the two contracts, test multicall and the multicall contract.
00:05:48.326 - 00:06:08.414, Speaker A: Scroll down. And then we'll open the test multicall contract. First call the function, get data one, and call the function, get data two. Next, we'll open the multicol contract. And then for the targets, this will be the addresses of the contracts. That we want to query. We'll call the test multicolore contract twice.
00:06:08.414 - 00:06:28.490, Speaker A: So, I'll copy the address. And then paste it in here. So, I'll type brackets, double quote, paste the address, close it with another double quote. Again, a double quote. Paste the address, double quote, close the bracket. The array of data that we need to pass in here. To call funk one and funk two.
00:06:28.490 - 00:07:00.738, Speaker A: Are these data that you see over here. I'll copy the first data, scroll down. And then we'll prepare the array of data. Bracket, double quote, paste the data, close the double quote, double quote again, scroll up, copy the data for calling funk two, paste it here, close the double quote and the bracket. And then we'll call the function call. Notice that we get some data back. Let's decipher this data.
00:07:00.738 - 00:07:24.738, Speaker A: The first part that you see over here. Is the first output of calling the function funk one. The first output returns one, which you can see over here that it returns one. And the next part is the timestamp. The next data that was returned is call to function funk two. The first output of funk two is two that you can see over here. And the next output is a timestamp.
00:07:24.738 - 00:07:37.530, Speaker A: Notice that the number you see over here. And the number you see over here are the same. This is because the two timestamps are the same. So this is how you can aggregate multiple queries. Into a single function call. By using multicolored.
