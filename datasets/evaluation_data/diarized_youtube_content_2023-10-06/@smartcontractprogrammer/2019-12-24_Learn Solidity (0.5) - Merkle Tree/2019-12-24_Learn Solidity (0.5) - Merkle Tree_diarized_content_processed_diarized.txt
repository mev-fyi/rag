00:00:01.690 - 00:00:44.010, Speaker A: Hey, everyone, merry Christmas. And we're going to be talking about a tree that grows on cryptocurrency like bitcoin and ethereum, and it's called a merkel tree. What is a merkel tree? The best way to explain what a Merkel tree is, is to show you how to build one. And to construct a Merkel tree, you first start with a non empty array. For simplicity, we're gonna assume that the length of the array is a power of two. For example, the length of the array can be two 4816 32, but it can't be six, since six is not a power of two. You'll see in a moment why we're going to need an array with a length of power of two.
00:00:44.010 - 00:01:19.362, Speaker A: Next, for each element in the array, we're going to compute the cryptographic hash of the element and then store it in a new array. From this array of hashes, we take the first two element and then compute the hash. We take the next two elements and then compute the hash. And we continue this process until we computed the hash of the last two elements. Next, we take this computed hashes and repeat the whole process. Eventually, you'll get a single hash, and this is called a root hash. And this is how you construct the merkel tree.
00:01:19.362 - 00:02:24.566, Speaker A: Now, if the number of elements in the original array is not a power of two, then at some point of the merkel tree construction, there will be an OD number of computed hashes. For example, if you start out with six elements, then you'll get three hashes after computing the hash of the pairs. And as you can see from here, we cannot compute the next level of hashes since we need four hashes, but there's only three here. So if there are OD number of hashes, then the trick to compute the next level of hashes is to duplicate the last element and then compute the hash of the duplicates. In essence, this is like filling the tail end of the array with duplicates so that the length of the array becomes a power of two. So how is a merkel tree useful? One application of the merkel tree is that you can create a cryptographic proof that a transaction was included in a block. Imagine that there are a bunch of transactions that are waiting to be included in a block.
00:02:24.566 - 00:03:38.686, Speaker A: To create a cryptographic proof that these pending transactions are included in the next block, we first construct the Merkel tree from these transactions, and we include the Merkel root hash into the block. Now, if Alice wants to know if her transaction was included in the block, all she has to do is get these four hashes, recompute the Merkle root hash, and then compare it with the Merkle root hash that was committed to the block. If the two Merkel root hashes are equal, then she knows that her transaction was included in the block. Now, another way to create a proof that a transaction was included in a block is to concatenate all of the transaction data and create a single hash from it. The problem with this approach is that in order to recompute the hash, you need all of the transaction data. So if there was 1000 transactions in a block, and if Alice wants to know if her transaction was included in the block, then she will have to download all 1000 transactions and then compute the hash. However, using a Merkel tree, she only needs log two of 1000, which is about ten hashes.
00:03:38.686 - 00:04:36.846, Speaker A: So in summary, a Merkel tree allows you to create a small cryptographic proof that a certain data is included in a set of data. And using this property, you can create a proof that a transaction was included in a block. Next, let's implement the function that will verify a Merkel proof in solidity. We'll need the function verify, and it's going to take in four inputs, an array of hashes that are needed to compute the Merkel root, the Merkel root itself, the hash of the element in the array that was used to construct the Merkel tree, and the index in the array where the element is stored. This function will return true if it can recreate the merkel root from the proof leaf and index. Otherwise it will return false. We'll start with the leaf, recompute the merkle root, and then compare with the merkle root that was provided to build our merkle root.
00:04:36.846 - 00:05:26.714, Speaker A: We need a for loop that will update our hash with the elements of the proof. First, let's try to figure out how to compute the parent hash from the very bottom of the merkel tree. Notice that the indexes of the left leaves are all even and the indexes of the right leaves are all odd. So this means that if the index is even, then we need to append the proof element to our current hash and then update our hash. Otherwise, the index is oD, which means that our hash belongs to the right branch and we need to prepend our proof element before updating the hash. And this will give us the hash one level above from the very bottom of the merkel tree. We want to repeat this logic where we concatenate our current hash with the proof element.
00:05:26.714 - 00:06:13.730, Speaker A: If the current hash belongs to the left branch. And if our current hash belongs to the right branch, then we want to concatenate our proof element with the hash and then update the hash. Now notice that if our starting index is three, then our parent index is one, and if our starting index is two, then our parent index is also one. And in general, if our index is either two k or two k plus one, then our parent index is equal to k. In other words, we divide our current index by two and round down to the nearest integer. And the way you do it in solidity is like this. And this completes the code to verify a Merkel proof.
00:06:13.730 - 00:06:58.638, Speaker A: Now let's go over how this function would work. Let's say that there are eight elements and we want to verify that the third element is contained in this Merkle tree. So the proof must be an array of hash of the fourth element, the hash of the hashes of the first and second element, and the hash computed from the right side of the Merkel tree. The leaf will be the hash of the third element and the index will be two. We start from the hash of the third element. Since the index is equal to two, our proof element must come from the right. So we concatenate our current hash with the hash of the fourth element and then update our hash, and then update our index.
00:06:58.638 - 00:07:40.590, Speaker A: Our index was two before, so two divided by two is equal to one and our current index is now equal to one and we move on to the next iteration of the for loop. Since our current index is equal to one, this means that our proof element must be on the left side. So we append the current hash to the second proof element and then update the hash, and then update the index. The index is equal to one. So one divided by two is 0.5. But since we're doing integer division, we round down to the nearest integer and 0.5 rounded down will be zero.
00:07:40.590 - 00:08:14.090, Speaker A: So our index is now equal to zero. And that completes the second iteration. For the third and final iteration, the index is now equal to zero. So the proof element comes from the right side of the Merkel tree, which means that we need to append it to our current hash and then update the hash. And lastly, we check that the Merkleroute that we computed is equal to the Merkleroute that was provided. So that's how this function works. Now let's try this function out in remix.
00:08:14.090 - 00:09:04.940, Speaker A: Now I've created a separate contract that I'll link in the description below that creates a Merkel tree from these data and the merkle root computed from this array is this, and these are the two hashes that we need to prove that the third element is contained in this Merkel tree. The first proof element is the hash of the fourth element, and the second proof element is computed by hashing the hashes of the first and second element. For the first argument of the verify function, we need to pass in an array of bytes 32. We do that by typing in a pair of brackets. Inside the brackets, we enter our two proof elements. Notice that we wrap each proof element in double quotes. Also notice that the order of proof element is important.
00:09:04.940 - 00:10:01.168, Speaker A: If you switch the orders around, then you won't be able to compute the correct Merkel root. Next, we pass in the root the leaf and the index of the leaf, which is two hit verify and it returns true. So this proves that the Merkel root was constructed from an array where the third element is equal to this data. And the way you can mathematically verify it is by taking this hash and the hashes of the proof. And if you change any part of the input, then the verify function will return false. In this video, we went over what a merkel tree is. A merkel tree is a tree that is constructed by taking paired data and hashing it, pairing the resulting hashes, and then hashing them again until a single hash remains.
00:10:01.168 - 00:10:26.950, Speaker A: This is called the merkel root, and it can be used to cryptographically prove that an element is contained in array without revealing all of the elements in the array. One example of this is proving that a transaction is included in a block without revealing all of the transactions. Well, that's all I got for this video. Merry Christmas, Happy New Year's, and I'll see you in the next video.
