00:00:00.250 - 00:00:33.778, Speaker A: In the previous video, we wrote the handler contract and then executed an invariant test against a single handler contract. What I want to show you in this video is how to write invariant test. And this time we will be executing the invariant test against multiple handlers. So I've created a file called invariant three t. So, and we'll be writing our test inside here. First thing to note is that I've imported the handler contract from the previous test, invariant two t Sol. What we're going to do in this video is we'll first create a contract that manages multiple handlers.
00:00:33.778 - 00:00:59.882, Speaker A: Next, we'll write an invariant test against this manager. So first I'll import some files. These are the same files that we imported inside the handler contract. Next, I'm going to create a contract. I'll name this actor manager and it's going to inherit these three imports from foundry. So inside here, inside this actor manager contract, it will manage the handlers. So first I'll declare a state variable of handlers.
00:00:59.882 - 00:01:45.578, Speaker A: I'll say handler bracket public, and I'll name it handlers. And then we'll set this inside the constructor, constructor handler bracket memory, underscore handlers. And then inside here, set the state variable handlers to the input. Okay? Later, when we write our invariant test, we'll deploy the handler contracts and then we'll feed it into this actor manager contract. Later, when we execute the invariant test, we'll execute the invariant test against the actor manager. So inside here, we'll define some functions that we want to test. And like before in the previous video, we executed the functions inside the handler contract.
00:01:45.578 - 00:02:28.566, Speaker A: So we want to do something similar. What I'm going to do is first copy these three functions, send to fallback deposit and withdraw from the handler contract, and then go back to the actor manager and then paste it here. I don't need a code inside, so I'll just remove it for now. And what we're going to test is calling the function send to fallback deposit and withdrawal. Now, recall from the previous video that inside the hamburger, these inputs amount inside the deposit and amount inside the withdrawal were random inputs that were fed in from foundry. And in this case, it will be the same. These will be random inputs.
00:02:28.566 - 00:03:12.054, Speaker A: What we're going to do for each of these function is we're going to randomly pick a handler and then from that handler call either into send to fallback deposit or withdraw. So what I'm going to introduce here is another input, another random input. Let's call it un handler index. So this will be the random input which will choose one of the handlers that is stored in the state variable handlers. So we'll do the same for deposit, un handler index. And that's again the same for withdrawal un handler index. Again, these handler index and amount will be random inputs provided by foundry.
00:03:12.054 - 00:04:00.966, Speaker A: So later, when foundry executes the invariant test and calls, let's say this function send to fallback. What code do we want to execute inside here? Well, first we want to pick the handler to call, but this handler index is a random number, so we first want to bound it to a valid index. This will be a number between zero and length of the handler minus one. So I'll say un index is equal to bound the handler index between zero and the length of handler minus one. Handlers length minus one. Okay, next we'll call the function sent to fallback on the handler. So going back to the handler function, the handler declares three functions, send to fallback, deposit, and withdraw.
00:04:00.966 - 00:04:36.174, Speaker A: So we'll do that over here. We can directly call the handler send to fallback by typing handlers, get the handlers at this random index, and then call the function send to fallback for the amount. Amount. This is the random amount provided by foundry. Okay, and we'll do something similar for deposit and withdrawal. So I'll copy this code, paste it here and paste it here for deposit. Instead of calling send to fallback, we'll call deposit, and for withdrawal we'll call withdrawal.
00:04:36.174 - 00:05:09.018, Speaker A: Okay, this completes our actor manager contract. Again, this is a contract that's going to randomly call one of the handlers and then call one of the functions. So next, let's write the imparian test. I'll name this contract WEf multi handler invariant tests for the state variables, we'll deploy the WEF, the actor manager contract that we just wrote above, and some handlers. So first let's set up these contracts, so say function setup. Then first we'll deploy the WEF contract. WEF is equal to new WEF.
00:05:09.018 - 00:05:58.650, Speaker A: Next we'll deploy the handler contract. Let's say for this example, we'll deploy three handler contracts, so say four un I equals zero, I less than three, I plus plus handers push deploy the handler contract, new handler. Now, the handler contract going back has a constructor argument that takes in WEF. So inside here I'll provide the WEF. Okay? And remember from the previous example, when we did an invariant test on the handler, we provided 100 e to this handler. So we'll do the same for each of the handlers in this test. I'll paste the code and then we'll say handlers of I deploy the handler and then send 100 e to the handler that was just deployed.
00:05:58.650 - 00:06:35.670, Speaker A: Okay, that completes the handler. Next, let's deploy the manager contract. Say manager is equal to new actor manager. Now scrolling back up the manager contract takes in a single input for the constructor array of handlers. So side here I'll provide the handlers handlers. And then lastly, recall from the previous video that we said that when we do an invariant test, foundry will by default target all of these contract ref, manager, and handlers. But in this test, we only want foundry to target the manager.
00:06:35.670 - 00:07:12.610, Speaker A: So we'll do that by typing target contract address of manager. Okay, and that completes the setup. So next, let's write a simple invariant test. In the previous video, we wrote the invariant test for the EF balance. We said that the amount of ETH that is locked inside the WEF contract must be greater than or equal to the total amount that was deposited by the handler. Here we'll do something similar. Here we'll say that the total amount of ETH locked inside the wef contract must be greater than or equal to the total of all the ETH deposited by the handlers.
00:07:12.610 - 00:07:49.358, Speaker A: So say function invariant. I'll name it e balance. This will be public, and we'll get the total of e that was deposited by typing un total equals zero. And then we'll need to run a for loop to get the amount of weft that was deposited into each handler. What I mean by here is going back to the handler contract. Every time there was an if deposit, we incremented this state variable called weft balance. And every time we withdrew from the handler, we decremented this state variable so we can get the total amount of weft that was deposited by handler.
00:07:49.358 - 00:08:42.130, Speaker A: By calling this state variable weft balance. So going back, we'll type four un I equals zero I less than handlers, length minus one I plus plus and then say total plus equals handlers of I wef balance. This total variable will now hold the sum of all wef balances by the handlers. And what we want to assert is that the e balance inside the WEF contract is greater than or equal to this total balance. Say assert greater than or equal to address of WEF balance should be greater than or equal to the total that we just calculated. And lastly, for this example, let's console log this total. So I'll type console log e total total.
00:08:42.130 - 00:09:11.950, Speaker A: Now, since total is going to be a large number, e has 18 decimals. So we'll divide this by ten to the 18 one e 18. Okay, we're done with the invariant test. Let's try running this test. So I'll open my terminal, and let's execute the test by typing forge test match path test invariance invariant three t sol. And we also want to see some logs. So type BBB.
00:09:11.950 - 00:09:34.540, Speaker A: And our test passed, and the total amount of beef that was logged is 97 beef. In this video, I showed you how to write an invariant test, simulating interaction with multiple users. How we did this was by deploying multiple handlers and then randomly selecting one of the handlers and then calling some function.
