00:00:03.640 - 00:00:40.244, Speaker A: You can think about the EBM memory as an array of bytes. Each element can hold one byte. One byte can be represented as two hexadecimal numbers, that is, from zero to nine, and the letters a to f. In theory, this array has two to the 256 elements. However, in practice, only a small amount of memory can be used because the cost to allocate memory is quadratic. Basically, to use n slots of memory or m bytes, the gas cost will be in the order of n squared. Since there's a gas limit for the blocks in the blockchain, this puts a limit on the number of memories that can be used.
00:00:40.244 - 00:01:18.864, Speaker A: Almost all operations to a read and write from memory happen in chunks of 32 bytes. Oftentimes when you're reading through a documentation on EBM memory, you'll see that memory is arranged in chunks of 32 bytes. Solidity assigns three special regions of the memory for special purposes. The first 64 bytes is called a scratch space. The next 32 bytes stores the free memory pointer. This is a pointer to a region in memory where you can store new data without worrying about overriding old data. Initially, this free memory pointer is set to 32 bytes starting from zero x 80.
00:01:18.864 - 00:02:03.786, Speaker A: The next 32 bytes after the free memory pointer is called a zero slot, and the 32 bytes after that is initially where the free memory starts. To store data into memory, the function mstore, which is accessible inside assembly block must be executed. It takes in two inputs, p and b. P is the location of memory to start writing the data, and from here 32 bytes will be written. The second input b is the data to store, and this is 32 bytes. For example, m store zero with the value zero xff will write zero xff starting from memory location zero. Since FF is one byte to the left of this, we will have 310 zeros.
00:02:03.786 - 00:02:53.956, Speaker A: Hence, you can see over here that at the end of the first row the value zero zero will be updated to ff. As another example, if you wanted to store the value zero xaa starting from the memory location zero x 20, then we would do m store zero x 20 with the value zero xaa. This will store the value zero x aa, padded with 31 bytes of zero zero to the left of the value aa starting from the memory location zero x 20. And you can see this that at the end of row two, the value zero zero will be overwritten with the value aa. The memory location to start writing from doesn't have to be a multiple of 32. For example, we can start writing from memory location equal to one. From here we write 32 bytes ending with the value zero x bb.
00:02:53.956 - 00:03:46.094, Speaker A: Again, this value zero x bb will be padded with 31 bytes of zeros to the left of this value bb. So when this code is executed, the value ff at the end of row one will be first overwritten with zero zero, and then at the beginning of the second row the value zero zero will be overwritten with the value bb. Let's look at one more example. M store two with the value zero x c c will write the value cc starting from memory location two. This value Cc is padded with zeros to the left so that it is exactly equal to 32 bytes. When we write this 32 bytes starting from memory location two, the one byte of value bb at the beginning of the second row will first be overwritten with the value zero zero. In the next slot, the value zero zero will be overwritten with the value Cc.
00:03:46.094 - 00:03:51.274, Speaker A: In the next video we will write some solidity code to store data into memory using assembly.
