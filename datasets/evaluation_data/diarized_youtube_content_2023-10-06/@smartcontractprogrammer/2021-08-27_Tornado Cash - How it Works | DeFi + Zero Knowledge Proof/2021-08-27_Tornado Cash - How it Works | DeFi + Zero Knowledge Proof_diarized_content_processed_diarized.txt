00:00:00.410 - 00:00:38.642, Speaker A: In this video, I'll explain how tornado cash protects privacy. Suppose that Alice sends 100 ether to another address. This transaction is recorded on the blockchain. Because data on blockchain is public data. Everyone in the whole world now knows that this address zero X B one b one b one, now has 100 ether. Now, if people know that this zero X b one B one B one address also belongs to Alice, then people around the world can conclude that Alice still has 100 ether. Likewise, if this receiver address belongs to Bob, then everyone in the whole world knows that Bob now has 100 ether.
00:00:38.642 - 00:01:16.510, Speaker A: So how does tornado cash protect privacy? How is it able to hide the link from the sender to the receiver? First, let's take a look at how deposit works in tornado cash. Before she deposits into tornado cash, she'll have to pick two random numbers, a secret and a nullifier. And then she computes the hash of these two random numbers to deposit into tornado cash. She'll send the one ether and the hash of the secret and the nullifier. Here we'll say it is zero X one two three. The ether gets docked in tornado cash contract. In this hash call, the commitment is also recorded into the smart contract.
00:01:16.510 - 00:01:56.370, Speaker A: This hash is later going to be used to withdraw this one ether from tornado cash. Users are always depositing and withdrawing from tornado cash. Here we'll say that Charlie the cat also deposits one ether and his hash is zero X four five six. The ether gets docked into tornado cash, and the hash zero X four five six is also recorded. Bob the bear also does the same send one ether and his hash is zero X seven eight nine. Ether gets docked and his hash zero X seven eight nine is also recorded into the smart contract. You might have noticed that Alice, Bob, and Charlie all deposited one ether.
00:01:56.370 - 00:02:47.922, Speaker A: Why is it that everyone is depositing one ether? Why can't alice deposit two ether and Bob deposit three ether and Charlie deposit 100 ether? To answer this question, let's imagine that Alice has 100 ether, Bob has one ether, and Charlie has one ether, and they all deposit into tornado cash. Later, an anonymous user comes along and withdraws 100 ether. We know that the only person that deposited 100 ether was Alice, so we can conclude that Alice still has 100 ether. So, to increase anonymity, everyone has to send the same amount of ether into tornado cash. This way, there is no one user that stands out from the rest of the crowd. So that is why everyone has to deposit the same amount of ether. So now let's see how withdrawal works in tornado cash.
00:02:47.922 - 00:03:27.210, Speaker A: First, I'll explain how it's done incorrectly. We'll first withdraw in a way that reveals the identity of the withdrawal, and then we'll see how to fix this problem so that the identity of the withdrawal is not revealed. So the wrong way to withdraw is that the withdrawal reveals the secret and a nullifier. The smart contract checks that the hash of the secret and a nullifier is equal to zero X one two three. And this hash, zero X one two three is recorded into the tornado cache smart contract. If it is, then tornado cache will send the one ether back to the caller. But in this process, it reveals the identity of the person who withdrew.
00:03:27.210 - 00:04:26.014, Speaker A: How is it that the identity of the withdrawal is revealed? Let's take a look. Well, we know that Alice deposited with a hash zero X one two three. Later on, an anonymous user came along and revealed a secret and a nullifier such that the hash of the secret and a nullifier is equal to zero x one two three. But because the hash function is a one way function, this means that the only person that knows the secret and the nullifier that hashes to zero x one two three is Alice. This is how the identity of the user is revealed on withdrawal. So how can we fix this problem? Well, we know that revealing the secret and a nullifier reveals the identity of the withdrawal. If somehow there is a way to prove that I know a secret and a nullifier such that the hash of the secret and a nullifier is recorded onto the tornado cash smart contract without revealing the actual secret and a nullifier.
00:04:26.014 - 00:05:15.382, Speaker A: So the anonymous user will send the proof that say I know a secret and a nullifier such that the hash of the secret and a nullifier is recorded onto the tornado cache smart contract. And this proof does not reveal the actual secret and the nullifier. This means that the anonymous user will stay anonymous. The smart contract verifies that the proof is valid, but it wouldn't know if the proof is for zero x 1230 x four five, six or zero x seven eight nine. In other words, the proof does not reveal the identity of the anonymous user. This is called zero knowledge proof, being able to prove that you know some information without revealing anything about the actual information. The math behind zero knowledge proof used by tornado Cash is called Gksnard.
00:05:15.382 - 00:05:52.670, Speaker A: Now, notice that when we deposit and when we withdraw, we select two random numbers, the secret and the nullifier. What is this nullifier, and what does it do when an anonymous user withdraws from tornado Cash? Tornado Cash doesn't know who is withdrawing. The withdrawal can be Alice, Bob the bear, or Charlie the cat tornado cash doesn't know who is withdrawing. This means that tornado cash cannot keep track of who has withdrawn their deposits. So a clever hacker would say, okay, tornado cash doesn't know who. If true. So what I'm going to try to do is deposit once and then withdraw multiple times.
00:05:52.670 - 00:06:34.230, Speaker A: The hacker sends a proof to withdrawal. The proof checks out, and the hacker gets one ether. The hacker sends the same proof again and then withdraw one ETH again. In total, the hacker deposited one ether, but he was able to withdraw two ether to prevent this double spend, meaning that you deposited once, but you can withdraw multiple times. When you send the proof to withdrawal, you'll also have to submit the hash of the nullifier and inside the proof of the DK snark, it would check two things. It would check that the hash of the secret and the nullifier is recorded on the tornado cache. And it will also check that the hash of the nullifier is equal to the nullifier.
00:06:34.230 - 00:07:09.186, Speaker A: Once the proof checks out, tornado cache records that the hash of the nullifier has been spent. The anonymous user gets the one ether back. And if this same user tried to withdraw again using the same proof, then it will fail because the hash of the nullifier has already been spent and it's recorded on the tornado cash. Smart contract. So that is the purpose of the nullifier to prevent double spending. Now let's see how tornado cash records the hash that is provided by the user when they deposit. The way the hash is recorded in tornado cash is by Merkel Tree.
00:07:09.186 - 00:07:36.730, Speaker A: Actually, Merkel tree looks like an upside down tree. The very top is called the root, and the very bottom elements are called the leaf. Let's quickly go over how Merkel tree is built. We start with an array where each element is a hash of some data. We take the first two element and compute their hash. We take the next two element and also compute their hash. We continue this process until all elements has been hashed.
00:07:36.730 - 00:08:07.698, Speaker A: Once the bottom elements has been paired together and then hashed, we do the same again. So we take the pair of hashes and then hash them again and then do the same for the next two hashes. We continue this process until there is only one hash. This is called the merkel root. In tornado cache, the merkel tree is initialized like this on the very bottom. So each leaf is a KetChaK 256 hash of the string tornado. To show how insertion works in the merkel tree of the tornado cache.
00:08:07.698 - 00:08:39.694, Speaker A: This is going to get messy, so I'm going to relabel these hashes. We'll say that the very bottom hash is g zero. On the next level, they're all named G one, and on the next level, they're named g two. Since the tree has three levels, we'll refer to the merkle root as g three. This is level zero, this is level one, this is level two, and this is level three. Okay, so let's see how to insert into the tornado merkle tree before anyone deposits. This is the merkle tree of the tornado cache.
00:08:39.694 - 00:09:10.090, Speaker A: We'll say that the first person to deposit selected a secret. We will name it s zero and the nullifier n zero. Hash it together and come up with a commitment named C Zero. When the first user deposits the commitment, so the hash of the secret and the nullifier of that user is inserted as a first element of the array. So we'll need to update the hash above. And once that's done, we'll also need to update the hash above it. And then finally we'll need to update the hash of the merkle root.
00:09:10.090 - 00:09:36.562, Speaker A: And that is what the Merkel tree will look like when the first user deposits. Let's take a look at how the merkle tree will change when the second user deposits. So the second user will come up with a secret. We'll name it s one and a nullifier. We'll name it n one and the hash of s one and n one. We'll name it c one. C one is inserted into the next available opening, which is right next to c zero.
00:09:36.562 - 00:10:00.362, Speaker A: So we'll need to recompute the hash above. And then at level two, we'll need to recompute the hash. And finally, we'll need to recompute the Merkel route. This is how the merkle route will change when the third user deposits. So we insert c three over here, and this will update the hash over here and update the hash over here. And finally the merkle root over here. And likewise for C four.
00:10:00.362 - 00:10:40.454, Speaker A: It will update the hash over here, the hash over here, and the hash over here. This is what the merkle tree will look like when the fifth user deposits, and the six, and so on. So that is how merkel tree insertion works in tornado cache. So once our hash is recorded into the tornado cache merkle tree, how do we prove that our commitment. So the hash of our secret and a nullifier is in the merkel tree. Let's say that a hash is c three and we want to prove to tornado cache that our hash is recorded into this merkel tree. How do we do it? The basic idea is that we'll need to provide a list of hash, and when we hash them together, it will match the merkel root hash.
00:10:40.454 - 00:11:36.780, Speaker A: So, starting from C three, we'll need to provide C two, and having these two hashes, we can recompute this hash. We'll need to provide this hash, and having these two hashes, we can recompute this hash. And finally, if we provide this hash, then we can recompute the Merkel root. So these are the list of hashes that we'll need to provide in order to prove that C three is recorded into the Merkel route. C three, c two in this hash over here and this hash over here. And if we provide the correct hashes, then it should match the merko root of the tornado cache. This proof is fed into GK snarks, and the GK snark will generate the geonology proof, meaning that we are proving that c three is in the merkel tree of tornado cache without actually revealing our hash, c three.
00:11:36.780 - 00:12:31.290, Speaker A: So once we have the proof, we send it over to tornado cache, and if the proof checks out, meaning that we are able to construct the correct merkle route of tornado cash, then we are able to withdraw the one ether. I was surprised to find out that Zksnark is already available in solidity. Let me explain how the smart contracts of tornado cash are built. The tornado cash smart contract has three distinctive parts. The part that manages ETH going in and going out, the merkel tree that keeps track of the deposit hashes, and the Dksnark verifier contract that verifies that the withdrawal has a valid proof for the Merkel tree. This Dksnark verifier smart contract is built using two tools. The first library is called circum, and using this library, what's called the arithmetic circuit is written.
00:12:31.290 - 00:13:07.780, Speaker A: This arithmetic circuit contains logic to prove that a hash is included in this circle tree. Now, once this arithmetic circuit is written, we pass it on to another tool called Snarkjs, and using snarkjs, it will automatically create a Zksnark smart contract. Further study is required on my part to explain to you guys how this part works. So hopefully I'll be able to make some videos dedicated to Gksnark and how to create zero knowledge proof smart contracts. So stay tuned. Other than that, thanks for watching and see you later.
