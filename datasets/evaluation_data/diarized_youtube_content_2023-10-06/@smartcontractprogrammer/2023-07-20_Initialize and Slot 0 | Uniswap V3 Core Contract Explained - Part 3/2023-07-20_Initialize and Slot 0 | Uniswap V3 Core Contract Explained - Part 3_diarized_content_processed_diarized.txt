00:00:00.250 - 00:00:39.306, Speaker A: Let's go over the code for the function initialized in unisoft b three. We're gonna encounter some new terms such as square root price x 96 and slot zero. Some of them I will explain in this video, others I will explain in another video. This is the code for unisoft b three and we'll implement the same functions inside our amm contract. So I'm going to open our amm contract, scroll down, and then we'll create a function called initialize function. Initialize. The input for this function is a u int 160 named square root price x 96.
00:00:39.306 - 00:01:21.170, Speaker A: Now, what does this variable represent? I'll explain in another video. So for now we'll just move along. Un 160 square root price x 96 external this function initialized will be called after this contract is deployed to set the initial price. And the initial price is somehow related to this variable. Square root price x 96. Looking at the code inside unisoft v three pool, the first term that we see that we don't understand yet is called slot zero. What is this variable? Slot zero is declared up at the top as a struct over here, and then it is declared as a state variable.
00:01:21.170 - 00:01:48.158, Speaker A: It is declared as the first state variable. Why is this called slot zero? Well, it's called slot zero because it uses the zero slot of the storage. In the EBM. State variables are stored in slots. Each slot can have up to 32 bytes. The first state variable that is declared inside a smart contract, if it fits on the 32 bytes, then that data will be stored in the zero slot. So this is why this variable is called slot zero.
00:01:48.158 - 00:02:19.570, Speaker A: So what is inside slot zero? We have all of this data that is stored in slot zero. So again, I said that each slot can store up to 32 bytes. So let's count this and make sure that this fits into 32 bytes. The first variable is Un 160. Un 256 is 32 bytes. If you divide 256 by eight, then you get 32. So to convert 160 into bytes, all we have to do is simply divide this number by 8160 divided by eight is 20.
00:02:19.570 - 00:02:46.222, Speaker A: So this will be 20 bytes. The first variable, square root price x 96 will use up 20 bytes. The next variable take let's divide this by eight again. So this will use up three bytes. The next one is 1616, divided by eight is two bytes and the same for the next variable. And the next one, fee protocol is un eight. So this will be one byte, and lastly boolean will also be one byte.
00:02:46.222 - 00:03:07.510, Speaker A: Okay, let's count all of the sizes that these data would take up. The first 120 plus the next one will be three plus the next one. Two. Three will be two bytes. So this will be two plus two plus two. Then plus one byte and one byte plus one plus one. Okay, let's add these up.
00:03:07.510 - 00:03:39.970, Speaker A: 20 plus three plus 225, 29, 30, and 31. So this is equal to 31 bytes, which is less than 32 bytes. So all of this data inside slot zero is stored in the zero slot. So that is slot zero. Now for our example, we're not going to cover price oracles. So some of the data in here we will omit it. Okay, so back in our contract, let's also declare slot zero and then initialize the first state variable to the slot zero.
00:03:39.970 - 00:04:11.462, Speaker A: So copy all of this and then go back to our contract. And then inside here I'll declare slot zero and then initialize a state variable called slot zero, slot zero public slot zero. And we also remove some of the comments. We'll keep square root price x 96, which I will explain in another video. Tick. We already covered observation index and observation cardinality. And observation cardinality.
00:04:11.462 - 00:04:42.338, Speaker A: Next, these are variables related to the price oracle, which we will not cover in this video fee protocol. This is the protocol fee, which we will also not cover. So we're left with three variables for our slot zero, square root price x 96, tick, and unblock. Okay, so once we have slot zero declared, our next step is to initialize slot zero inside our function. Initialize. Let's open the code for a unison b three pool and go back to our function. Initialize.
00:04:42.338 - 00:05:11.530, Speaker A: Okay, here's the function. The first part of this function checks that the function initialize cannot be called more than once. It can only be called once. And this is done by checking that slot zero. That square root price x 96 is equal to zero. So you'll say require slot zero, dot square root price x 96 is equal to zero. With the error message, let's say already initialized.
00:05:11.530 - 00:05:46.890, Speaker A: Okay, the next part is to compute the tick from the square root price x 96. And this is done by calling the function get tick at square root ratio. How to calculate the tick given square root price x 96. We'll cover this in another video. Okay, so int 24 tick is equal to tickmath, get tick at square root ratio, and then inside here pass in square root price x 96. Okay, the next part of the code is a code that's related to the price oracle. So we'll just skip it.
00:05:46.890 - 00:06:23.890, Speaker A: And then the last part is to initialize slot zero. We'll say slot zero is equal to slot zero, square root price x 96 is square root price x 96 from the input tick is what we computed above. And lastly, all of these variables we're not storing inside our slot zero. And the last one that we're storing is unlocked. This variable unlocked is used for reentrancy guard. So unlocked true. And the event initialized, we'll just omit it and that completes the function initialize.
00:06:23.890 - 00:06:57.100, Speaker A: Let's try compiling the contract. I'll open my terminal and then type forge build. Okay, our contract compiles in this video we completed the function initialize. However, there are terms that I did not explain yet. For example, square root price x 96 and how to get the tick given the square root price x 96. I'll explain what square root price x 96 is and how to calculate the tick given the square root price x 96 in another video. So we'll end it here for now and I'll see you in the next video.
