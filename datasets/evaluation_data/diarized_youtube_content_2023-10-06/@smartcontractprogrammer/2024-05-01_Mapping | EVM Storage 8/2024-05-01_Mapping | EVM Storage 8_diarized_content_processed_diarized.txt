00:00:00.360 - 00:00:38.396, Speaker A: In EBM, the storage slot for our mapping is computed by taking the catch Act 256. Let's say that we have a mapping from key to value and for this example we'll keep it simple and say that the value will take up one slot. The size of the value will be 32 bytes. In this case, the slot of the value will be the ketchak 256 of the mapping key and the slot where the mapping gets declared. For example, let's say that we have a mapping from address to Un 256. The key will be an address and the value will be Un 256. Un 256 will take up 32 bytes, so it will use a single slot.
00:00:38.396 - 00:00:59.874, Speaker A: Let's name this map. To compute where the values for the map is stored, we need to apply this equation. Take the catch Act 256 of the key. So a key will be an address and the slot where the mapping is declared. In our example, the mapping is declared in slot zero. So for over here we will put in a zero. Okay, let me give you some examples.
00:00:59.874 - 00:01:02.386, Speaker A: For this example, I've declared three addresses.
00:01:02.490 - 00:01:04.706, Speaker B: Address one, address two, and address three.
00:01:04.810 - 00:01:07.810, Speaker A: And I've stored eleven for address 122.
00:01:07.842 - 00:01:10.386, Speaker B: For address two and 33 for address three.
00:01:10.530 - 00:01:51.712, Speaker A: Next we'll write a function using assembly to get the values stored in this mapping function test mapping. We will take in a single parameter the address you'll call this key. This is the key to our mapping that maps from address to Un 256. Public view returns will return the value stored in the mapping having the key key returns un 256. We'll call this b for value and again we'll be using assembly to get the value that is stored in this mapping having the key queue. So let's now apply this equation. So I'll copy this equation and then I'll paste it here.
00:01:51.712 - 00:02:37.624, Speaker A: Slot of the value is a ketchup 256 of the key and slot where the mapping is declared. We'll compute this slot and when we take the ketchup 256 it will return bytes 32 I'll call this slot for b slot. For the value slot b is equal to getcheck 256 of abi dot encode. We first need to take the catch act 256 of the key. So inside here put in key and the next value that goes in is the slot where the mapping is declared. The slot where this mapping is declared is in slot deal over here I'll type uint 2560 and this will give us the slot where the value is stored. To get this we'll say b is equal to sload to load the slot at slot b.
00:02:37.624 - 00:02:47.688, Speaker A: Okay, let's try calling this function. Hit ctrl s. The contract compiles. Next, I'll deploy the contract. And then we'll call the function. Test mapping.
00:02:47.816 - 00:02:53.208, Speaker B: And we'll test address one, address two and address state. Address one, address two, and address state.
00:02:53.376 - 00:03:11.552, Speaker A: Let's start with address one. Paste it here. So the map having the key, address one, stores the value eleven. So when we call this function, we expect to get eleven back. And we do. Next, let's try address two. We expect the value to be 22.
00:03:11.552 - 00:03:15.984, Speaker A: 22. And finally, address three.
00:03:16.064 - 00:03:18.444, Speaker B: We expect this value to be 33.
00:03:18.744 - 00:03:19.464, Speaker A: Get 33.
