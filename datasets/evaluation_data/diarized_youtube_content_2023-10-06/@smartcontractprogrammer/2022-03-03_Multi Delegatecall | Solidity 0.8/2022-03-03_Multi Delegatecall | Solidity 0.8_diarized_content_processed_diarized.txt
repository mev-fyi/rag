00:00:00.410 - 00:00:28.390, Speaker A: Let's say that I have a contract and it has some function. For this example, I have a function one and function two. If I want to call function one and function two, then I will send a transaction to call function one. Wait. And then send another transaction to call function two. We've already seen how to call multiple functions in a single function call by using multicol. But what if we want to preserve the context, for example, message sender? Then we will need to use delegate call.
00:00:28.390 - 00:01:02.858, Speaker A: So in this video, I'll show you how to create multicol. Except we're going to be using delegate call. But why use delegate call? Why not just use multicall? Okay, let's say that we use multicol. Alice calls the contract multicol. The multicall uses the function call to call this test contract. For example, if the multicall calls the function funk one or funk two, message sender will be equal to the multicall contract and not Alice. But let's say that we want to do a multicall, except that we want this message sender to be Alice.
00:01:02.858 - 00:01:34.460, Speaker A: Then we will need to use delegate call. Let's take a look at how delegate call will preserve message sender to be equal to Alice. Again, let's say Alice will call this test contract. And inside this test contract, we'll do a multi delegate call back into this test contract. Because we're using delegate call inside this contract, message sender will still be equal to Alice. Okay, so let's not write the function for multidelegate call. So call it function multidelegate call.
00:01:34.460 - 00:02:14.098, Speaker A: The only input that we're going to need is the functions to call and the parameters to pass to the function. So we'll say bytes bracket call data. I'll name it data. This function will be external, payable, and we'll return the output of each function call as bytes. So, we'll type returns array of bytes memory, and I'll name it results. First, we'll initialize this results array to have the same length of data. So we'll type results is equal to new byte bracket.
00:02:14.098 - 00:02:48.114, Speaker A: Initialize it to the same length of data by saying data length. Next, we'll run a for loop to execute each of the data. So we'll say for un I I, this ten data length I plus plus, we'll delegate call to the same contract. So we'll say address this delegate call data of byte. Delegate call returns two outputs, boolean whether the function call was successful or not. Boolean. I'll name it.
00:02:48.114 - 00:03:15.642, Speaker A: Okay, and any function output by calling delegate call. So bytes, I'll call it rest. We'll check that the function call was successful. By making sure that okay is equal to true. And for this example, I'll use the custom error that is available since solidity 0.8. So, first, I'll define an error saying error, delegate call failed. And then we'll type.
00:03:15.642 - 00:03:47.070, Speaker A: If not okay, then revert with delegate call failed. If the call was successful, then we'll store the result into the results array. By typing results of I is equal to rest. I forgot to put memory here, so I'll do it right now. I'll hit Ctrl s just to make sure that the contract compiles. And we are now done with this contract. The next step is to add this functionality to this contract.
00:03:47.070 - 00:04:17.834, Speaker A: Test multidelegate call. And we'll do that by having this contract inherit this multideeligate call contract. So, I'll type is multidelegate call. And now this contract has the function multidelegate call. So we'll be able to call this function. To call both test funk one and funk two in the same transaction. Now, to use multidelegate call, we need to prepare the data call to function one with these parameters.
00:04:17.834 - 00:04:38.114, Speaker A: And call to function two must be Abi encoded. So, I've created a helper function. To abi encode the function call to funk one. Passing in the parameter un text and unty. And also abi encode funk two. We'll compile the contract. And then execute multidelegate call.
00:04:38.114 - 00:04:54.698, Speaker A: To call funk one and funk two. I will hit Ctrl s to compile the contract. And then we'll deploy test multidelegate call. And the helper contract. Scroll down. And then open both contracts. To call multidelegate call, we'll need to prepare the data.
00:04:54.698 - 00:05:19.540, Speaker A: So, to call funk one, the data for the input, I'll pass in one and two. And get the data. That is the data that we need to paste in here. And for funk two, that is the data that we need to pass in here. So, next, I'll prepare the data for multideeligate call. By typing brackets. Double quote, paste the data for the first function call.
00:05:19.540 - 00:05:38.662, Speaker A: And then paste the data for the second function call. And then close the brackets. And then we'll call multidelegate call. The transaction was successful. So I'm going to open the transaction logs. And look for their logs. You can see here that the event log was emitted for funk one.
00:05:38.662 - 00:06:05.374, Speaker A: And the caller is this address. Starting with zero, x five, B. Three, if I scroll up, you can see here that it matches this account. So message sender is this account. Now, scrolling down a little bit further, you can see that funk two was also called. And message sender is also equal to this account. Now, if we were to use multicall to call funk one and funk two, then message sender will not be equal to this address.
00:06:05.374 - 00:06:42.502, Speaker A: It'll be equal to the contract address of multicall. So that is the benefit of using delegate call to batch function calls. Now, multidelegate call can be a dangerous contract to add to your contract. Let's take a look at an example. Let's say that inside this contract, I have a function called mint, and it increments the balance of message sender for the amount of ether that was sent. Let's see what happens when we have multidelegate call with this function mint. And I've also added a function, get mint data, to get the data to call the function mint with multideligate call.
00:06:42.502 - 00:07:31.850, Speaker A: So, I'll compile the contract, and we'll redeploy these contracts. And then I'll show you example of calling mint and how it introduces a bug. So, we'll deploy, test multidelegate call, and the helper contract again, scroll down, and then open the two contracts. For this example, we'll call multidelegate call and call the mint function multiple times. So we'll get the data for get mint data, and that is the data to pass to multidelegate call. And we'll call multidelegate call on the mint function three times. So, I'll prepare the data, bracket the call data for mint, paste it three times, and when we call the function mint, we'll say, we'll send one ether.
00:07:31.850 - 00:07:58.134, Speaker A: Scroll down, and then call multi delegate call. The transaction was successful. So let's check the balance of the user that just called multidelegate call. Remember, we just sent one ether. And if you look at the function mint, then our intention is that the balance of message sender increases by the amount of ether that was sent. And we sent one ether. Scroll up.
00:07:58.134 - 00:08:30.874, Speaker A: So I'll copy this address, and we'll check the balance. Notice that this is not one ether anymore. This is three ether. So what happened when we use multideligate call to call the function mint three times message value is one ether. Since we only sent one ether, message sender is this account over here. But since we called it three times in the same transaction, it incremented the balance three times. So that is how multidelegate call can be a dangerous contract to add to your contract.
00:08:30.874 - 00:08:37.180, Speaker A: It is also a useful contract, so if you wanted to add to your contract, be sure to review your contract before adding it.
