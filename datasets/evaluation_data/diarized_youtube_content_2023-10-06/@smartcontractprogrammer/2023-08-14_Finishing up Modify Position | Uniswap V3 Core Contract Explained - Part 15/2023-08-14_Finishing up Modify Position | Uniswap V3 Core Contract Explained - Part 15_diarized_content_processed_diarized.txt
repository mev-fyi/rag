00:00:00.250 - 00:00:38.722, Speaker A: Let's finish the function. Modify position. This function takes in a liquidity delta, updates the position and it needs to return the amount of zero and amount of token one that either needs to be added or removed. But right now at the moment it is simply returning a zero. So what we'll do is write some code that will calculate the amount of token zero and token one that is either needed to add liquidity or the amount that goes out when liquidity is removed. So first of all, I copied and pasted some advanced math libraries from unisor B three which we will be using in this video. The library that we're going to be using is called square root price math.
00:00:38.722 - 00:01:14.206, Speaker A: I won't get into the details of how this math works. The function that we're going to need to call in this video are get amount zero delta. This function will calculate the amount of token zero that is needed given the price ranges p of a, p of b, and the liquidity. And the other function that we'll be calling in this video is called get amount one delta. Again, this will take in the two price ranges and the liquidity, and it will return the amount of token one that is needed. Okay, so going back to our cram contract, after we update the position, we'll calculate amount zero and amount one. Now, there are three cases.
00:01:14.206 - 00:01:48.862, Speaker A: If the current price is less than the lower price range, if the current price is between the two price ranges, and if the current price is above the upper price range. First we'll write a if statement. Make sure that liquidity Delta is not equal to zero. Say if params liquidity Delta is not equal to zero. And then inside this if condition, we will write our three conditions of the price ranges. If slot zero tick, this will represent the current price is less than params, take lower. So that's the first case.
00:01:48.862 - 00:02:29.382, Speaker A: The second case is if the current price is between the two price ranges, slot zero tick is less than Params tick upper. And the last case is if the current price is greater than the upper price range. The simple cases are when the current price is less than the lower price range and when the current price is above the upper price range. Let's start here. When the current price is less than the lower price range, then liquidity will all be in token next or token zero. So say amount zero is equal to and we're going to be calling square root price math. And the function that we're going to be calling is this one get amount zero delta.
00:02:29.382 - 00:03:01.570, Speaker A: So I split the screen into two. On top, you see the clam contract, and on the bottom you see the square root price math. So the function that we need to call is get amount zero, delta. So here I'll say square root price math, get amount zero, delta. And for the first two inputs we need to pass in square root ratio. So to do that, we'll use a library called tickmath. Get square root ratio at tick, and this will be in params tick lower and then the upper tick will be tickmouth.
00:03:01.570 - 00:03:37.646, Speaker A: Get square root ratio at tick at tick upper, and lastly, liquidity will be params liquidity delta. So this code over here will calculate the liquidity when the current price is less than the lower price range. And we'll do something similar when the current price is above the upper price range. So I'll copy this code and then paste it here. When the current price is greater than the upper price range, liquidity will all be in token one. And the function that we're going to be calling is called get amount one delta. The price ranges will not change tick lower and tick.
00:03:37.646 - 00:04:07.866, Speaker A: Upper and liquidity delta will be liquidity delta from params. And the final case is when the current price is between the two price ranges. What we're going to do is calculate amount zero and one. So I'll copy this code, and copy this code and then change the ticks. Amount zero will be from the current price to the upper price. So say underscore slot zero sqrt price x 96. This will be the current price represented in square root price.
00:04:07.866 - 00:04:51.626, Speaker A: The upper tick does not change and liquidity delta does not change. For amount one, the price ranges will be from the lower tick to the current price. So paste this and then remove this. And lastly, since we're adding liquidity to the current price, we'll need to update the current liquidity. So I'll say liquidity is equal to if params liquidity delta is less than zero, then the new liquidity will be the current liquidity minus un one two eight minus params liquidity delta. Otherwise, liquidity will be liquidity plus un one to eight Paramsa liquidity delta. Okay, and that completes the function.
00:04:51.626 - 00:05:15.060, Speaker A: Modify position. Let's try compiling the contract. So inside my terminal I'll type forge build. Okay, looks like I have not declared a state variable liquidity yet, so I'll go do that, go back to clam Sol and then scroll up. We will declare liquidity as un one two eight public liquidity. Okay, let's try compiling the contract again. Forge build.
00:05:15.060 - 00:05:49.730, Speaker A: And the contract compiled successfully inside the function modify position I forgot to remove this line of code. It's returning an empty position and amount zero equal to zero and amount one equal to zero. However, we no longer need this since amount zero and amount one are declared as output and position is also declared as output. Now that we're done with the function, modify position this completes the function for mint. So starting from the next video, we'll implement the function to remove liquidity. The function is called burn.
