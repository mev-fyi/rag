00:00:00.250 - 00:00:33.762, Speaker A: We're finally going to write the algorithm for binary exponentiation using assembly. What binary exponentiation does is it efficiently calculates x to the n. And this is a function that is used inside the makerdial stablecoin to calculate compound interest. I'll break this video into several parts. First we'll handle the case when x is equal to zero, and then we'll handle the case when x is greater than zero. For the case x greater than zero, we'll split this into three parts. In the first part we will write the algorithm, and then in the next part we'll put in some overflow checks.
00:00:33.762 - 00:01:02.906, Speaker A: And in the last step we'll put in some rounding error checks. Okay, let's start with the case when x is equal to zero. Here we have a function called r power, and this is a function that will calculate x raised to the n using binary exponentiation. This function takes in three inputs x, n, and b. X is the x that you see over here, n is the n that you see over here, and b is the base. Here we're doing fixed point math. So let's say that b is equal to 100 and x is equal to 80.
00:01:02.906 - 00:01:28.390, Speaker A: Then what x represents is 0.8. On the other hand, if x was equal to 120, then this would mean that x represents 1.2. So let's handle the case when x is equal to zero. So we're inside assembly, so we'll say switch x, and then there will be two cases. Case zero. We'll do something, and later we'll handle the case when x is greater than zero. Default.
00:01:28.390 - 00:01:50.606, Speaker A: Now when x is equal to zero, we'll further break this down into two parts. We'll handle the case when n is equal to zero and when n is greater than zero. When n is equal to zero, we're calculating x raised to the power of n. Both are zero. So we're calculating zero raised to the power of zero. In this case we'll return a one. The second case is when n is greater than zero.
00:01:50.606 - 00:02:08.230, Speaker A: Again, we're calculating x raised to the power of n. And in this case, what we're calculating here is zero raised to the power of n where n is a positive number. And in this case we'll return a zero. Okay, so let's write this in assembly. So inside here we'll write a switch. Again. Switch n.
00:02:08.230 - 00:02:33.102, Speaker A: The first case is when n is equal to zero. Case zero. In this case we'll return one. So the output is z. So to this variable z, we'll say z assigned to z. Now we want to say one, but remember again that here we're dealing with fixed point math and one is represented as a base. So if the base is 100 here, instead of returning a one, we'll need to return the base 100.
00:02:33.102 - 00:02:54.100, Speaker A: So we'll put b. Okay, how about the case when n is greater than zero? So this will be handled by default. In this case, we'll return a zero. So we'll set g equal to zero. Okay, so that handles the case of x equal to zero. Let's move on to the interesting part. When x is greater than zero.
00:02:54.100 - 00:03:30.974, Speaker A: Recall from the previous video about the algorithm for binary exponentiation that we initialize g equal to one or x depending on what n was. In particular, when n is an even number, we initialize z equal to one. And when n is an od number, we initialize z equal to x. For example, let's say that n is equal to two. Then we initialize z equal to one. When n is equal to three, we call from the algorithm graph that on the left side we did x multiplied by x, and on the right side we had a remainder of x. We multiply the left side and the right side to get x raised to the power three.
00:03:30.974 - 00:04:03.370, Speaker A: So this is how we're going to initialize d, the right side of the diagram that represented the algorithm. To handle this case, we will write a switch statement switch, and we want to check if n is even or not. To check whether n is even or not, we use the function mod n two. If n is an even number, mod n two will return a zero. If n is an od number, mod n two will return a one. When n is even, you'll say case zero to z. We'll assign one.
00:04:03.370 - 00:04:39.958, Speaker A: But remember again that here we're dealing with fixed point math and one is represented as b. Else default, we'll initialize z equal to x. Okay, so this completes the initialization of z. Okay, next we're going to use the for loop to calculate x raised to the power of n. What we're going to do is initialize n equal to n divided by two. We'll run the for loop while n is greater than zero, and after each iteration we'll divide n by two. So to do this, we'll write for initializing n equal to div n by two.
00:04:39.958 - 00:05:03.398, Speaker A: We'll run this loop while n is greater than zero. So say n. And then after each iteration, we'll divide n by two. N is equal to div n by two. Okay, and inside here, we'll write our algorithm that will calculate x raised to the power of n. Let's consider a simple example to see what the code inside here might look like. For example, let's say that n is equal to two.
00:05:03.398 - 00:05:23.602, Speaker A: In this case, n is even. So we initialize z equal to b. And what code would go inside here? N is equal to two. We initialize n to be two divided by two, which is equal to one. One is greater than zero. So we're going to definitely run the for loop. And after the for loop, we'll divide one by two, which will be equal to zero.
00:05:23.602 - 00:05:49.706, Speaker A: So this loop will run. Once again, we want to return x raised to the power two. So how will we do that? Well, on the first and the only iteration, if we multiply x mo x by x, we'll get x raised to the power of two. Let's assign this to a variable. Let's say that xx is equal to. Now recall that we're doing fixed point math. So this xx multiplied the base two times.
00:05:49.706 - 00:06:24.070, Speaker A: So what we need to do is divide xx by the base. So I'll say the new x x is equal to div xx by the base. Okay, so now this x represents x multiplied by x. And since over here it multiplied the base two times by dividing by the base over here. Here we will have x multiplied by itself and then normalized to have the correct base. Now, recall from the previous video that the last step of the algorithm was to combine x with z. And this is also the case when n is an odd number.
00:06:24.070 - 00:06:56.402, Speaker A: So we'll say if mod n two. If n is an OD number, including the last iteration where n is equal to b one, we'll combine g and x. Say let gx equal to mo g with x. And like what we did over here, we'll need to normalize gx by dividing it by b. So we'll say g is equal to div gx by the base. Okay, so this completes the algorithm. Let's do a quick check.
00:06:56.402 - 00:07:24.290, Speaker A: When n is equal to two. When n is equal to two, n is initialized to be equal to one. So we'll run the for loop once, multiply x by itself. So we have x square divide by b to normalize it. Now, since n is equal to one mod n, two will return a one. This means that this part of the code will execute g is initialized to be b, and then we multiply this g by x. X currently is equal to x square.
00:07:24.290 - 00:07:50.594, Speaker A: So, multiplying x squared by b, we get x squared multiplied by b. So here we have x squared multiplied by b. And on the next line, we divide by b to get g equal to x squared. And that completes a loop. And we return z equal to x squared. How about the case for when n is equal to three? When n is equal to three, let's consider this part of the code. First, n is equal to three.
00:07:50.594 - 00:08:13.530, Speaker A: N is odd, so we initialize z equal to x. Okay, how about the for loop? Well, we initialize n equal to three divided by two, three divided by two. And then, rounding down the decimals, we get n equal to one. So we'll run the for loop only once. Multiply x by x. We get x square and then normalize it. N is equal to one.
00:08:13.530 - 00:08:39.422, Speaker A: So we'll run this code inside here. Inside here, z is initialized to be equal to x. So we're multiplying x by x square. We'll get x raised to the power three with the extra base. So we normalize it by dividing by d, and the output z will be equal to x raised to the power three. Okay, so this is the algorithm for binary exponentiation. The next thing that I'm going to do is put in some overflow checks.
00:08:39.422 - 00:09:08.442, Speaker A: The condition to check for overflow when we're multiplying two numbers, we divide the product by one of the numbers. And if it is not equal to the other number, then that detects that overflow occurred. So let's write this part of the code first. Now here, since we're multiplying x by x, the check that we'll have to do is this. Let's write this part of the code first. So say div xx by x. And we want to check whether this is equal to x.
00:09:08.442 - 00:09:29.218, Speaker A: If this is equal, it will return a one. Otherwise it will return a zero. So we want to check if it returns a zero is zero. Then we want to throw an error. If this is true, if is zero, then rebirth. Next, we also put in an overflow check. After we multiply z by x.
00:09:29.218 - 00:10:01.978, Speaker A: What I'm going to do is copy this code, then paste it here. Okay, so the check that we need to do is check z, multiply by x and then divide by x. Is this equal to z? Now, there's also another check that we want to put in here. Since x can be equal to zero, we also want to make sure that x is not equal to zero. To check whether x is zero, we'll say is zero x. Now we want to check whether x is not equal to zero. So we'll negate this is zero.
00:10:01.978 - 00:10:30.834, Speaker A: If x is equal to zero, then this part of the code will return a one. So if you wanted to check whether x is not equal to zero, we'll negate the output of this by wrapping it in another is zero. Okay, so these are the two conditions. So I'll wrap this in a function called end. So what this condition is doing is checking x is not equal to zero and z time x overflowed. Then we'll throw an error. Okay, and that completes some parts of the overflow.
00:10:30.834 - 00:11:04.894, Speaker A: Next, we'll put in some rounding. And when we do rounding, we'll also put in some extra overflow checks. First, we'll create a variable that will be used for rounding. So say let half is equal to div the base by two. The first part that we'll put rounding is after we multiply x by x. So after we multiply x by x and then check whether it overflowed or not, we'll round xx by half. So say that xx round is equal to add to xx half.
00:11:04.894 - 00:11:42.346, Speaker A: And then after we round it, we'll divide by the base. So what we're going to do is take this xx and then instead of dividing it by the base, we'll replace this xx with xx round. By adding a half to xx and then dividing it by the base, we get a more accurate X. This was discussed in one of the previous videos. Okay, so after we add half to xx, we also want to check that this number did not overflow. So we'll check for overflow when we're doing addition. When we're doing addition, we know that a number overflowed if the total is less than the parts.
00:11:42.346 - 00:12:25.510, Speaker A: So we'll say if less than xx round. This is a total parts will be xx. If xx round is less than xx, then we know that an overflow occurred. So we'll rebirth rebirth zero zero. Okay, the final step is to also add rounding after we multiply g by x and then round it by the base. So here I'll say that gx round is equal to add to gx half and then we're going to check for overflow again. So I'll copy this code and then paste it here and we'll check that zx round whether it is less than zx.
00:12:25.510 - 00:12:57.302, Speaker A: And then instead of dividing by zx, we'll divide it by zx round again by adding half to zx and then dividing by the base. This will be a more accurate number than simply dividing dx by b. Okay, so that completes the algorithm for binary exponentiation. Let's try compiling this contract. I'll hit Ctrl s and the contract compiles. Okay, so let's deploy this contract and call the function. Deploy the contract, and then let's call the function.
00:12:57.302 - 00:13:17.010, Speaker A: Let's say that the base is 100 and we'll compute two. So two, when the base is 100, will be represented as 200. And let's say we want to compute two to the four, call the function, and we get 1600, which represents 16.
