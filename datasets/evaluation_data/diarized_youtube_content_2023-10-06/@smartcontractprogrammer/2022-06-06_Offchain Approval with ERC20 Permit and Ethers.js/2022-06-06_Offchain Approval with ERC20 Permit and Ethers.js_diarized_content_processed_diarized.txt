00:00:00.250 - 00:00:28.418, Speaker A: Let's say that there's a contract where you can deposit an ERC 20 token. The usual process is for you to first approve this contract to be able to spend your token, and then you would call this function deposit. When this function is called, it calls token transfer from. So that's two transactions approve and then transfer from. However, some ERC 20 contract allows you to prove and transfer from in a single transaction. So let's take a look here. I have a standard interface for the ERC 20 contract.
00:00:28.418 - 00:01:18.758, Speaker A: What we'll do first is define the function called permit. The function permit takes in the owner, the spender, and the amount to be spent, the signatures, and the deadline for the last time that the signature is valid. If the signature is valid, then anyone can call this function to approve the spender to spend value amount of tokens from the owner, and the signature will be signed by the owner back in our bulk contract. Since we added the function permit inside the IERC 20, I renamed this to IRC 20 permit. So back inside our bulk contract, I'll also rename this from IErc 20 to IErc 20 permit, and then I'll do the same for all of the IErc 20s. I'll change this to IErc 20 permit. And now let's discuss how we can transfer a token in one transaction without calling the approved function.
00:01:18.758 - 00:02:15.830, Speaker A: The basic idea is to call permit passing in the signature and then calling transfer from. So I'll create a function called deposit with permit and for the parameters we'll pass in the amount to deposit un amount and some parameters for the signature un deadline. This will be the deadline for when the signature is last valid, and then some parameters for the signature un eight b bytes 32 r and bytes 32s. We'll define this function as external and what we'll do is call permit and then call the function transfer from. Let's go back to IErc 20 permit to see how to call the function permit. The function permit takes in these parameters, so I'll copy this and then paste it here, and then I'll comment this out so that we can see what parameters we need to pass. I'll type token permit.
00:02:15.830 - 00:02:59.666, Speaker A: The owner will be message sender, the spender will be this contract, so that will be address. This value will be amount that we're going to be depositing, and then we pass in the rest of the parameters deadline br if this function executes correctly then this is like calling approve. So this is how we save one transaction and then the rest will be the same. We'll do a transfer from so I'll copy this from the function deposit and then paste it here. And this is how you can transfer ERC token in one transaction without calling the function approved. Let's now write some tests and then actually call this function deposit with permit. First I'll make sure that this contract compiles.
00:02:59.666 - 00:03:54.098, Speaker A: So I'll open my terminal and type mpx hard hat compile and the contract compiles. So let's now write some tests. I'll open my file navigator and click on tests. Then we'll create a new file called Erc 20 permit js now I'll open also verify signature and then copy all of this paste it into the file Erc 20 permit and then we'll remove the content inside here I'll rename this to ERc 20 permit and we'll change the title of the test to ERC 20 permit. For this test what we'll do is get the account, deploy some contract, sign some signatures for the permit, and then call the function deposit with permit. So the first step is to get some accounts. So I'll say const accounts is equal to awaite ethers get signers.
00:03:54.098 - 00:04:38.226, Speaker A: For this example we only need one signer so I'll put one inside here and then we'll say that the signer constiner is the first account account zero. Next we will deploy a token and the bulk contract. But we don't have a token contract yet, so let's define it inside the contract folder. So inside the contract folder I'll create a new file called token Soul. And for this example I'll use the ERc 20 from soulmate. So I'll open my terminal and then type NPMI at rari capitalsolmate. Once we install soulmate, we'll import ERc 20 contract into our file called token Soul.
00:04:38.226 - 00:05:21.534, Speaker A: So I'll define the headers and import ERC 20 from soulmate. Remember we'll create a contract called token contract token this will inherit the ERC 20 from soulmate so is ERC 20 and then we'll initialize the constructor by typing constructor is ERC 20. This will take in three parameters. The name we will name it token the symbol we will name it also token and decimals 18. And then we'll expose the internal function called mint which will mint tokens. So I'll say function mint. It will take in two parameters, the address to mint to and the amount to mint.
00:05:21.534 - 00:06:27.382, Speaker A: So I'll say address to un amount this function will be external and we'll simply call the internal function mint with underscore two for the amount and that completes the token contract. So let's go back to our test file ERC 20 permit and we'll deploy the token contract. We'll deploy the token contract by typing const token is equal to await ethers, get contract factory and then pass in the name of the contract will be token and then we'll deploy it. So we'll say const lowercase token is equal to await token deployed and then we'll wait for the token to be deployed. So we say await token deployed. We'll do something similar to deploy the bulk contract, replace the token with bolt, and the bulk contract takes in a single parameter of address of the token. So inside the deploy function we'll pass in token address.
00:06:27.382 - 00:07:34.990, Speaker A: Next we will mint some tokens to deposit into the vault the amount that we're going to mint, let's say 1000, and we'll call the mint function on the token. So I'll type await token mint to signer that address for the amount amount okay, we're almost there. Let's prepare the input to call the function deposit with permit. For this example, we'll keep it simple and say the deadline is maximum un so say const deadline is equal to ethers constants max Un to 56. Now if we go back to the bulk contract, we also need to prepare the signature parameters Brns and we also don't know what message we're signing. So let's take a look at what message we're signing by opening node modules, scrolling down, looking for a folder called rari capital rari capital source tokens erc 20 then I'm looking for a function called permit and there it is. Let's take a look at what message we're supposed to be signing.
00:07:34.990 - 00:08:19.340, Speaker A: So if you check over here then you can see that this is the message that we need to sign. Now to recreate this message is a little bit complicated, so what I'm going to do is try to find code on the Internet that already implements this. After doing some googling I found out that unisoft b three already has a code to create the message to sign for the function permit. So I'll copy this function called getpermit signature. We will paste it inside our test contract erc 20 permit and then we'll modify this function that we just copied. I'll remove the typescript type annotations. We're not going to need this permit config, so I'll also remove this and then also remove the permit config from the rest of the code.
00:08:19.340 - 00:09:46.902, Speaker A: Now this function splitsignature is imported from ethers utils so I'll prefix this function with ethers utils split signature and I think we're good with rest of the code. So by calling this function get permitsignature, we'll be able to get the signature to pass to the function deposit with permit. So I'll scroll down and then I'll type const the signature parameters brns is equal to await get permit signature passing in the signer the token, the address of the spender. This will be bolt address and the amount and the deadline. And lastly we'll call the function deposit with permit by calling await vault deposit with permit for the amount with the deadline and then the signature parameters br once you call the function we expect that this amount of token was transferred from the signer over to the vault contract. So we'll write a simple test case to check that the balance of the vault has increased. Expect payweight token balance of vault address we transferred this much amount from the signer to the vault contract so we expect the balance of the vault to equal amount.
00:09:46.902 - 00:10:24.780, Speaker A: Okay, let's now run the test. So I'll open my terminal, clear the logs, then type mpx hard hat test erc 20 permit js I made an error with the function get permit signature so I'll go back and remove export okay I fixed the test so we'll run the test again and the test passed so we were able to approve this bulk contract to spend our token and then actually transfer it in a single transaction by calling the function permit and then calling transfer from.
