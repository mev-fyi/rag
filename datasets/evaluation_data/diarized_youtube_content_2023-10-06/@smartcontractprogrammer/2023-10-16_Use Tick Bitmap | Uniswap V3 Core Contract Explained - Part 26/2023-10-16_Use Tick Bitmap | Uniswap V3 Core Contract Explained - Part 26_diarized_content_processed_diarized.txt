00:00:00.330 - 00:00:31.762, Speaker A: In the previous video we completed the tick bitmap library. For unisoft b three contract. We wrote a function that will flip a tick and we also wrote a function that would get the next tick. So in this video we'll be using this library and calling it inside our unison b three pool contract. Going back to my clem contract. This is the main contract. The first thing that I'll do is import tick bitmap import from viv import tick bitmap sol we want to be using this library.
00:00:31.762 - 00:01:19.238, Speaker A: So inside here we'll say using the library tick bitmap four we want to use this for mapping mapping from int 16 to un 256. And then we'll declare a tick bitmap state variable. So go down over here, I'll declare a tick bitmap mapping mapping from int 16 to un 256 public. I'll name it tick bit map. So recall again that this mapping tick bitmap will store information about where the ticks are located. Okay, the first place that we'll use this library tickbit map for the state variable tick bitmap is inside a function called update position. So I'll scroll down.
00:01:19.238 - 00:02:12.946, Speaker A: This function update position is called when we add liquidity or when we remove liquidity. And it makes sense that we'll be calling the tick bitmap library since only time that the ticks changes are when we either add liquidity or remove liquidity. Going down when liquidity delta is not equal to zero, we update the ticks. And this will give information whether the tick was flipped or not. And what we're going to do is if the tick was flipped then we'll call the tick bitmap library and call this function flip tick. So going back here you'll say if flip lower, then on our state variable tick bitmap we'll call flip tick. And for which tick are we calling? We're calling for the lower tick tick lower and passing in tick spacing.
00:02:12.946 - 00:02:57.714, Speaker A: And we'll also do something similar for the upper tick. If the upper tick is flipped, then on tick bitmap you'll call flip tick for upper tick, and tick spacing is the same. What this part of code is doing is that when we add or remove liquidity, this function called update position is called, and when it is called we're recording the positions into tick bitmap. The other place that we'll need information about the ticks is when we call the function swap. When we call the function swap we'll somehow need to get the next tick. So let's go down to the function swap. Function swap and inside here at the moment we just incremented the current tick and set it as a next tick.
00:02:57.714 - 00:03:40.606, Speaker A: But we're going to be replacing this code by calling the function. Calling the function next initialized tick within one word. Again, this function will get the next tick. So over here I'll first delete this. The function that we're going to be calling returns two outputs. The next tick, step tick next, and whether this next tick is initialized or not, step initialized and we will be calling the function tick bitmap get next initialized tick within one word. Okay, and what are the parameters that we'll need to pass going back? The first input is the tick bitmap.
00:03:40.606 - 00:04:20.782, Speaker A: The next will be the current tick and then tick spacing and the direction of where we should search for the next tick. Okay, so going back first input is the current tick state tick. The next input is tick spacing. Tick spacing, and the last input is the direction of where we want to search for the next tick. Okay, so what should we pass in for the input? Less than or equal to? Well, let's think through this. Recall that if we graph the liquidity on the vertical axis and the ticks on the horizontal axis, then to the left of the current tick, liquidity will all be in token one and to the right of the current tick. Liquidity will all be in token zero.
00:04:20.782 - 00:04:53.178, Speaker A: If we were to do a 41 trade, then this would increase the amount of token zero and decrease the amount of token one. We're moving the tick to the left. This means that the price decreases. The next tick that we should be looking for is less than or equal to the current tick. How about the other way around? If we were to do a one 40 trade, then token one is coming in and token zero is going out. Token one is increasing and token zero is decreasing. This will increase the current price, shifting the current tick to the right.
00:04:53.178 - 00:05:47.766, Speaker A: The direction of the next tick that we're looking for is greater than the current tick. With this in mind, further input less than or equal to you'll pass 00:41. If the trade is at 41 then this is equal to true and we want to pass less than or equal to also equal to true. Otherwise we want to pass false. Now, when we call the function next initialize tick within one word, the next tick may go out of bound. So what we're going to do is make sure that the next tick stays within the minimum and the maximum tick. If step tick next is less than the min less than tickmath min tick, then we'll set the next tick equal to the min tick step tick next is equal to tickmath min tick else if the next tick is greater than the max tick, we'll do something similar.
00:05:47.766 - 00:06:11.370, Speaker A: Say else if else if the next tick is greater than tick, map max tick, then we'll set the next tick to max tick. Okay, that completes integrating tick bitmap into our amm contract. Let's try compiling the contract inside my terminal. I'll type forge build, and our contract compiled.
