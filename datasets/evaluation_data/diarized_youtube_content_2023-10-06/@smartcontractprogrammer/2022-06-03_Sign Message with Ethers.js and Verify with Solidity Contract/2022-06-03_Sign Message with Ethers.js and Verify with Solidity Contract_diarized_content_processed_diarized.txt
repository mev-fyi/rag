00:00:00.250 - 00:00:29.570, Speaker A: Today I'll show you how to sign messages using ethers js. In this video we'll use a contract from solidity by example under verify signature. Here I have an empty folder. The first thing that we'll do is set up a hard hat project. So I'll open my terminal and then the first thing that I'll do is init a Npm package by typing npm init y. This will create a package json file and let's now install install some packages. The first Npm package that we will install is hard hat.
00:00:29.570 - 00:01:02.298, Speaker A: I'll type mpmi hard hat. Next we'll initialize a hard hat project. By typing mpx hard hat. We'll create a sample project. The project root will be this folder hello erc 20 permit add git ignore once the hard hat project is initialized, the next thing that we will do is copy the contract from solidity by example. So navigate to soliditybyexample.org and then I'll search for a contract called verify signature.
00:01:02.298 - 00:01:40.606, Speaker A: So hit ctrl f and type verify. Click on verify signature and then copy this contract. This is the example contract that we'll be using to sign a message and then verify the signature back inside our project. I'll create a new contract on the contracts called verify signature Sol. Then I'll close the terminal and then paste the contract. Now the contract that we just copied is for solidity 0.8.13. If I check the solidity compiler version inside hardhack config it is 0.8.4.
00:01:40.606 - 00:02:15.570, Speaker A: So we'll edit this compiler version to match 0.8.4 by removing 13 and this will mean that this contract is targeting solidity compiler version anything above 0.8.0. Next, I'll also remove the comments. Once that is down, let's try compiling this contract. I'll open my terminal and then type Mpx hard hat compile and the contract compiled successfully. The next thing that we'll do is inside the test folder. I'll write some scripts to verify signatures.
00:02:15.570 - 00:03:22.486, Speaker A: In there I'll show you how to use ethers JS to sign a signature and verify it against this contract that we just compiled. So I'll open test folder and then we'll rename this sample test Js to verify signature JS and then I'll rename this to verify signature and I'll also rename this test description to check signature. This is a test for the greeter contract, but we're not going to need it, so I'll delete all of this and then rename the greeter contract to verify signature. The contract verify signature doesn't take any inputs, so I'll remove the constructor input that was passed to the greeter contract and then rename the contract that was deployed from greeter to I'll just name it contract. Okay, so let's now write some code using Etherjs to sign some message and then verify it against the contract. Verify signature. The function that we'll need to call is called verify and it's going to take in these inputs.
00:03:22.486 - 00:03:51.350, Speaker A: And if the signature is correct, then it will return true. Otherwise it will return false. I'll copy this and then back inside the test, I'll paste it. These are the parameters that we'll need to prepare. And if all the parameters and the signature is correct, then when we call the function verify, it will return true, otherwise it will return false. Let's write this as a test. So we'll say expect, await, contract, verify.
00:03:51.350 - 00:04:34.306, Speaker A: The first input will be the address of the signer, so I'll say signer address. We'll write the test first and then prepare the inputs later. So we have not defined these variables yet inside this test to amount, message, nouns, and signature. If we prepare everything correctly, then we expect this to return true, so we expect to equal true. If however, the message that was signed so these parameters and the signature does not check out, then we expect this to be false. So I'll type here false and then we'll change this messager a little bit. For example, instead of passing in an amount, we'll say amount plus one.
00:04:34.306 - 00:05:05.390, Speaker A: So that is the test. Let's now prepare these parameters. So the first thing that we're going to need is a signer. So I'll type constiner is equal to. For this example, we'll use the first account that is provided in the test and then assign it to signers. So we'll get the accounts by saying const accounts is equal to awaite ethers, get signers, and we'll get two accounts for this example. So pass into here and then assign the signer to accounts zero.
00:05:05.390 - 00:05:26.546, Speaker A: Then the two address will be const. Two is equal to the amount that we're going to be signing. Const amount, I'll say nine. Nine, nine. The message that we're going to be signing const message is equal to I'll say hello. And the last parameter that we're signing is the nouns. Const nouns, I'll say one to three.
00:05:26.546 - 00:05:53.530, Speaker A: Okay, so we now have these parameters ready. The next step is to sign these parameters. Let's go back to the contract to see how the message that we're going to be signing is formatted. So I'll go back to verify signature contract, and under the function verify. The first thing that it does is from the input. It's passed to a function called getmessage hash, passing in some of the parameters to amount, message, and nouns. Let's take a look at this function.
00:05:53.530 - 00:06:55.598, Speaker A: What does it do? The function get message hash, takes in the inputs and then returns a catch act 256 hash of the inputs. Let's go back to the function verify. So once we have a message hash of these inputs, next it calls the function get e sign message hash with the message hash as input. So I'll go to the function get eevesign message hash, and this function takes a catch 256 of some prefixed message ethereum sign message appended by message hash and then returns it. Okay, let's go back to the function verify again. Once we have the esign message hash, it calls the function recover signer passing in the e sign message hash and the signature. If I scroll down and look at the function recover signer, it splits the signature to rsmb and then calls the built in function inside solidity called ec recover passing the e sign message hash and the signature parameters brns.
00:06:55.598 - 00:07:53.854, Speaker A: This function will return an address of the signer and inside the function verify, we compare that the recovered signer is equal to the signer from the input. Now, most web3 libraries, including ethers js when we sign a message, this part is automatically done for us. So the message that we actually need to prepare is this first part, hashing the inputs to amount message announced and then signing the message hash. So let's go back to the test file, and the first thing that we'll do is get the message hash. By typing const hash is equal to await contract get message hash, the function get message hash. If I scroll up, these are the orders that are passed in to amount message and nouns. So we'll go back to the test and then pass in two amount message, and then nouns.
00:07:53.854 - 00:08:39.550, Speaker A: This will return the hash that is to be signed. So the next thing that we'll do is use ethers Js to sign this hash. So I'll type const sig is equal to await signer sign message, and then here we'll pass in hash. Now, right now, this hash is a string, but we need to turn this into bytes. So what we'll do here is say ethers utails arrayify and then pass in the hash. This will turn the hash, which is a string, into something that looks like a bytes, so that when we call the function signer that sign message, it will correctly give us back the correct signature. Okay, so we have the signature.
00:08:39.550 - 00:09:25.674, Speaker A: Let's now run this test to see that these two test passes. If we pass in a correct parameter and the correct signature then verify should return true. However, if we pass in a wrong parameter here, we modify the parameter amount to be amount plus one, then the function verify should return false. Let's run this test. I'll hit ctrl s and open my terminal. I'll also clear the terminal and then type mpx hard hat test test verify signature js and the test passes. So that means we were able to correctly prepare the message and then sign it and then verify that the signature was correct.
00:09:25.674 - 00:10:04.158, Speaker A: If we passed in the correct parameters and if we passed in some wrong parameter. For example here we passed in amount plus one instead of amount. Then the contract verify returned false. Now for this test here, we use the default account provided by hardhat. But what if we wanted to use our own account to sign a message? Then what you can do over here is import your private key, instantiate a wallet and then the rest of the code should work as is. So for example, we'll say const prime key is equal to zero x something. I'm not going to paste my private key here.
00:10:04.158 - 00:10:53.210, Speaker A: And if you're writing some code then you probably import your private key from some environment variable or some secret file. Once you got your private key, the next thing that you need to do is initialize a wallet. So for example by typing const signer is equal to new ethers wallet and then passing in the private key and then commenting this default signer account. The rest of the code will work as is. And this is the only difference that you'll need to make in order to sign with your private key and then verify the signature. Now earlier I mentioned that the actual message that is being signed is not the hash, but the hash prefixed with some message and then hashed again. The actual message that is being hashed is this message over here.
00:10:53.210 - 00:11:57.118, Speaker A: Take the message hash, prefix it with this string and then hash it again. The output is the actual message that is being signed. So to show you this inside our test file, let's pass in the message hash, call this function to get the e sign message hash, and then we'll call the function recover signer to get the signer and then compare the signer that was returned from this function with the actual signer back in the test file. The first thing that I'll do is get the e sign message hash. So I'll say const e hash is equal to awaitcontract, get ef signed message hash and then pass in the hash. And then we'll console log the output of calling the function recover signer on the contract. So I'll type console log recovered signer and then call recover signer, await contract recover signer passing in e hash and the signature.
00:11:57.118 - 00:12:37.980, Speaker A: Now, this recovered signer should be equal to the actual signer, which is this account. I'll comment this code out, and then I'll comment the default signer, and then we'll console log the actual signer by typing console log signer and then typing in signer address. Okay, let's run the test again, and the recovered signer by calling contract recover signer should be equal to the actual signer. So I'll open the terminal again and then run the test again. And then we see that the actual signer and the recovered signer are the same.
