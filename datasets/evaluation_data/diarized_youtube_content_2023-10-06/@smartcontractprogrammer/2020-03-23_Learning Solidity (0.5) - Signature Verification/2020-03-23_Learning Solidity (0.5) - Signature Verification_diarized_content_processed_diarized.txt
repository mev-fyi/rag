00:00:01.130 - 00:00:37.758, Speaker A: In this video, I'm going to show you how to sign and verify messages. To sign a message, you first create a message to sign, and then you hash the message. And then you sign the hash of the message. To sign the hash, you're going to need your private key of your Ethereum account. And you want to keep your private key a secret. So you would do the actual signing without inter acting with a smart contract. And to verify a signature, you would first recreate the hash from the original message, and then you would recover the signer from the signature and hash.
00:00:37.758 - 00:01:23.906, Speaker A: And finally you would compare the recovered signer to the claimed signer. Let's imagine that we're signing a check from a bank account. So we need three informations. The person that we're signing the check to, the amount that this person can withdraw from our account, and a little note about what this check is for. And lastly, we're going to need a unique identifier called announce so that we can invalidate the check. Once the person withdraws from our account, we'll declare this function as public peer and it's going to return the 32 bytes hash of the inputs. And inside our get message hash function, we will return the catch Act 256 of our inputs.
00:01:23.906 - 00:02:18.360, Speaker A: So this function here covers steps one and two of signing. Now, when we sign the message hash, it's actually not the message hash itself that is being signed. What's actually being signed is this, you prefix the message that you're going to sign with ethereum signed message, followed by the length of the message, and then finally the message itself. You take all of this and hash it using catch up 256, and that is the message that is actually being signed. So when we sign the message hash, the actual message that will be signed is the prefix ethereum signed message. Since the message hash is 32 bytes here, the length will be 32 and then followed by the message hash. And then you take the catch up to 56 of the whole thing.
00:02:18.360 - 00:03:08.830, Speaker A: So we'll write a function to recreate that. The input of this function will be the message hash from the function above. And since it's going to create another hash, it's going to return bytes 32 inside the function. It's going to return the catch Act 256 of the prefix ethereum sign message, followed by the length of the message, which will be 32, and the actual message, which is going to be the message hash that is passed from the input. So that completes the code for the function that recreates the hash that is actually being signed. Now, to actually sign the message I'll show you later, after we deploy this contract. Moving on, I'm going to show you how to verify a signature given a message hash.
00:03:08.830 - 00:04:22.240, Speaker A: First I'm going to write the function that paints the big picture, and then we'll work our way down into the details. To verify a signature, we need several inputs, the address that claims to be the signer of the message, the parameters that was used to create the message hash, and the signature itself, and the function will return true if the signer is indeed the owner of the signature. We'll first recreate the message hash from the inputs, and then compute the hash that was actually signed. The function recover signer, which we'll write out later, will take in the hash that was signed and the signature, and it will return the address of the signer. So we'll compare it with the signer that we think should have signed the message, and then return the comparison. The function recover signer is going to take e sign message hash and the signature as input, and it's going to output an address based on the message hash and the signature. To recover the signer, we first need to split the signature into three parameters, rs and b.
00:04:22.240 - 00:05:13.518, Speaker A: Now you don't need to understand what these parameters are. All you need to understand here is that these parameters are needed to call the built in function ec recover. To call the function Ec recover, you first need to pass in the hash that was signed, and then the parameters brns that we split from the signature. And this function will try to compute the address that signed the hash and return a zero address if the signature is invalid. So that completes the code. To recover the signer, let's now work on the function split signature, which we have not defined yet. The function split signature is going to take the signature as input, and it's going to return the three parameters r, s, and b needed.
00:05:13.518 - 00:06:01.280, Speaker A: To call EC recover, we'll first require that the length of the signature is equal to 65, since 32 for the first output, 32 for the second output, and one for the last output is equal to 65. Now, to actually split the bytes, the only way to do it at this moment is to use assembly. And don't worry if you don't understand this part, since you won't be using assembly much. Now, to get the first output from the signature, this is how you do it. Add xy will return x plus y. So what does it mean to add 32 to the signature? Well, you're not going to be adding 32 to the actual signature. Signature is a dynamic data type.
00:06:01.280 - 00:06:59.620, Speaker A: So what's being stored inside the variable sig is a pointer to where the actual signature is stored. In other words, the starting position of the signature being stored in memory. And when you add 32, you move the starting position by 32, effectively skipping the first 32 bytes. Why do you skip the first 32 bytes? This is because dynamic arrays store the length of the array in the first 32 bytes. So the signature itself starts after skipping the first 32 bytes. And when you call the function m though with an input of p, it loads the next 32 bytes starting at the memory address p. So putting it all together, this line of code will skip the first 32 bytes and then load the next 32 bytes and then assign it to the variable R.
00:06:59.620 - 00:07:59.030, Speaker A: And to get the value for the s, we'll do something similar to what we did. To get the r value here, we need to skip 64 bytes, since the first 32 bytes stores the length of the signature and the next 32 byte stores the value for R. So the value for s starts after skipping the first 64 bytes. And to get the value b, we need to skip the first 96 bytes and then get the first byte after it. So this is how you get the RSMV value from the signature, and that covers the code for how to verify a signature. Let's now compile and deploy the contract, and I'll show you an example of how to sign and verify a message. And for this example you're going to need metamask, which is an ethereum wallet that you can install inside your browser.
00:07:59.030 - 00:08:59.610, Speaker A: So here I've deployed the contract that will create the message hash to sign, and then later verify the signature. And let's now go through these steps. First we'll create the message hash to sign. So we'll call the get message hash function, and for the inputs I'll pass in the second account for the number I'll pass in one, two, three, for the message I'll pass in coffee and donuts, and then for the nouns I'll pass in one, and then call a function. And that's the hash that we're going to be signing. And to sign the hash we need to allow remix to connect to metamask. And you can do that by hitting f twelve and opening the JavaScript console and then typing ethereum enable.
00:08:59.610 - 00:09:53.580, Speaker A: This will open up the metamask. So go ahead and type in your password to unlock it, and then hit connect. So now you'll have access to metamask inside the browser console, and we can sign the hash inside the browser. Now first I'll assign the hash to a variable named hash. And to sign the hash, you'll need to call web3 personal sign pass in the hash, followed by the account that we're going to use to sign the hash. In this case, we'll use the default account that is available to metamask, and you can access that by calling web3 e default account. And then finally we'll console log the result.
00:09:53.580 - 00:11:01.790, Speaker A: So you'll see a pop up like this and hit sign, and that is our signature. And this signature will be different for different accounts. Now, to verify the signature, we're going to need the address of the signer, and we can get it by calling web3 e default account again. So that was the address that was used to sign the message and to verify the signature, I'm going to paste the signer in here, and then pass in the parameters that was used to sign it, and then the signature itself, and then hit verify. And you can see that the function verify returned true. Now, if you change the parameter even by a little, for example, instead of sending one, two, three, we'll add an extra zero and then hit verify. And you can see that the function returns false.
00:11:01.790 - 00:11:31.620, Speaker A: Likewise, if we keep the message the same but change the signature. So for example, changing the signature by one number and then hit verify, it would again return false. So in summary, if you change the original message or the signature even by a little bit, then the signature is no longer valid. That's all I got to say about signature verification. Thanks for watching and have a nice day.
