00:00:00.330 - 00:00:43.050, Speaker A: We call the function burn to remove liquidity and then update the amount of token zone to our position. However, to actually transfer the tokens, we will need to call the function collect. So in this video we'll implement the code for collect. First, let's open the unisoft b three pool contract and see how the function collect is implemented. The function collect is going to take in some parameters, recipient tick lower, tick upper, and amount zero, and amount one that we want to transfer for the output. It's going to return the actual amount of tokens that was transferred out. We will first get the position and then the amount of tokens to transfer are calculated as the minimum of amount requested and the amount of tokens that is owned to the position.
00:00:43.050 - 00:01:23.042, Speaker A: If this amount is greater than zero, then we update the position and then transfer the tokens out. Okay, so let's implement this code inside our clam contract. So let's start with the inputs. The inputs are address recipient int 24 tick lower int 24 tick upper un one two eight amount zero requested. This will be the amount that we wish to withdraw from the pool and likewise un amount one requested. We also put a modifier lock. This will be a reentrancy lock and then this will return two outputs.
00:01:23.042 - 00:01:58.286, Speaker A: Returns un one two eight, amount zero and un one two eight amount one. The first thing that we'll do is get the position. So say position info. And since we're going to be updating the state variable position, this will be a storage position is equal to positions get. The position is determined by three parameters. The owner, message sender and the two ticks tick lower and tick upper. Next, we'll calculate the actual amount of tokens that will be transferred out of the pool.
00:01:58.286 - 00:02:45.682, Speaker A: This will be the minimum of amount that was requested and the amount owed to the position. Say amount zero is equal to. If amount zero requested is greater than position tokens owed zero, then we will return the smaller of these two numbers, which will be positions tokens owed zero, position tokens owed zero. Otherwise, amount zero requested will be the smaller of these two numbers. So we say amount zero requested. Then we'll do the same for amount one, amount one, amount one requested, position owed one, position tokens owed one, and amount one requested. Okay, the last step is to update the position and transfer the tokens out.
00:02:45.682 - 00:03:51.714, Speaker A: Say if amount zero is greater than zero, then we'll update the position first position tokens zero. We will subtract it minus equals amount zero and then we'll transfer the tokens out in the code for unison B three. It uses a transfer helper called safe transfer, and this function makes sure that the ERC 20 transfer either returns a boolean of true or it doesn't return any booleans. This is mostly used for tokens like USDC and USDT where it does not return a boolean. However, for our code example we'll keep it simple and then just say IRC 20 of token zero transfer to recipient for the amount amount zero and then we'll do the same for amount one. If amount one is greater than zero, then we subtract from tokens owed one for amount one, and then for token one transfer amount one. Okay, that completes the function for collect.
00:03:51.714 - 00:04:27.370, Speaker A: Let's try compiling a contract inside the terminal type forge build okay, and our contract compiled successfully. So that completes the function for burn and collect. And we also completed the function for mint. So from starting from next video we'll start working on a function for swapping.
