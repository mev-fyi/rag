00:00:00.330 - 00:00:36.600, Speaker A: Events allow you to write data on the blockchain. These data cannot later be retrieved by a smart contract. The main purpose of events is to log that something happened, so it can be a cheap alternative to storing your data as a state variable. If the data that you're going to be storing is something that you want to save on the blockchain once and later on, the smart contract does not have to retrieve it. We declare an event by typing event and then followed by the name of the event. I'll name this event log and inside the parentheses you declare the type of data that you're going to log. For example, we can log a typo string and I'll name this message.
00:00:36.600 - 00:01:10.834, Speaker A: We can also log another parameter. This time I'll log un and then name it Val. The line above declared an event. So how do we log this event onto the blockchain? Well, we do by typing emit and then followed by the event that we're going to be logging. For this example, we're going to be logging the log event parentheses, and inside the parentheses we put in the actual parameters. The first parameter is of type string, so for example I can say foo. The second parameter is of type un, so I'll say 1234.
00:01:10.834 - 00:01:34.730, Speaker A: Notice that this function is declared not as a readonly function. This is a transactional function. And why is that? Well, it is because we're storing some new data onto the blockchain. We're logging the parameters foo and 1234 onto the blockchain. So this is why this function is not a readonly function. It is not a view or a peer function. It is a transactional function.
00:01:34.730 - 00:02:06.970, Speaker A: If we execute this function, these two parameters will be stored on the blockchain. If you wanted to search for a particular event by the parameter that was logged, then we use the keyword index. Let me show you. So again I'll declare this as event, and this time I'll name this indexed log. I want to filter this log by the first parameter, which will be an address. So we'll say indexed and this name of the parameter. I'll name it sender and for the second parameter we'll log a unit.
00:02:06.970 - 00:02:53.982, Speaker A: Again bell to log this indexed log we use the same syntax, so we say emit indexed log. This time the first parameter is an address, so I'll just put in an address. For example message sender and for the value I'll put in seven, eight, nine. Let's say that Alice calls this function ten times, so message sender will be Alice. Next, let's say that Bob calls this function 20 times, so that message sender will be bob. Now. Now, since we have the keyword indexed over here, instead of searching all of the logs for index log and then filtering out for Alice using web3, we'll be able to quickly find all of the logs index log that was emitted by Alice.
00:02:53.982 - 00:03:22.800, Speaker A: Since index allows you to quickly search for logs by the parameters, then you might want to put indexes on all of your parameters. However, you might not be able to do it. Up to three parameters can be indexed. If you're logging four parameters inside your event, you won't be able to put an index on all four parameters, you'll only be able to put on three of them. Let's look at another example. I'm going to build a chat using event, so I'll declare event. I'll name this message.
00:03:22.800 - 00:04:12.086, Speaker A: This event will have three parameters, the address the message was sent from, the address the message is sent to, and the actual message. So we'll type address and we'll declare as indexed so that we can quickly search by the sender. And then I'll name this parameter. Underscore from the next parameter is the receiver of the message, so I'll say address indexed so that we can quickly search for the message by the receiver. Underscore two and the message string message. We'll create a function called send message, so I'll say function send message. It's going to take in two parameters, the address to send the message to and the string message that we're sending.
00:04:12.086 - 00:04:57.460, Speaker A: So it'll be a string string is a dynamic type, so I'll declare this as call data message. This function will be external, and inside this function we'll send the message by typing emit message from will be message sender to will be from the parameter, and the message will also be from the input. Now you have a smart contract where you can send anyone a message. This message will be public, meaning that anyone with access to the blockchain will be able to see your message. To send a message you'll have to send a transaction, so you'll have to pay for every message that you send. This isn't the cheapest chat application to use, but using smart contract it is possible.
