00:00:00.170 - 00:00:23.594, Speaker A: When you call function in solidity, you'll have to pass the inputs in the order that they are declared in. This can be problematic. When you have a lot of inputs to pass in, you'll have to remember the order of the inputs. However, there is another way to call function without remembering the order of inputs that you'll need to pass. You can call a function using key value pairs. So let's take a look at example here. I have a function named song found with many inputs.
00:00:23.594 - 00:01:07.438, Speaker A: And as you can see from here, there are many inputs x, y, and then z. Then an address a, a boolean b, and a string c. To call this function, you'll need to remember that you need to pass xyz for the first three inputs, an address for the fourth input, a boolean for the fifth input, and a string for the 6th input. Let me show you an example. Let's say that I wanted to call this function. So I'll call it function call funk external peer returns un, and inside here we'll call this function sumfunk with many inputs. I'll type return sum funk with many inputs.
00:01:07.438 - 00:01:40.922, Speaker A: And to call this function, I'll need to remember that the first three inputs are un. So for example, I'll pass in one, two, three, and the fourth input I'll need to pass in the address. So I'll say address zero. The fifth input I need to know that I need to pass in a boolean. For this example, I'll pass in true, and the last input I need to remember that I'll need to pass in a string. So I'll say a string c. Notice that to call this function sound funk with many inputs, I need to remember the order of inputs to pass to this function.
00:01:40.922 - 00:02:19.286, Speaker A: Now let me show you another way to call this function sound funk with many inputs without having to remember the order of inputs to pass. So I'll call this function function call funk with key values. This will be external again, peer returns un and then we'll say return call the function sum funk with many inputs. And now here's the difference. Instead of passing the inputs in the order that they are declared in, I'll use a key value pair. So inside the parentheses I'll put a curly braces. And then for example, say for the input x, I want to pass in one.
00:02:19.286 - 00:02:43.934, Speaker A: For the input y, I want to pass in two. For the input z, I'll pass in three. For the input a, I'll pass in address zero. For the input b, I'll pass in true, and for the input c, I'll pass in a string c. These two code do the same thing. However, when we write the code like this, we know that for the input x, we're passing in a one. For the input y, we're passing in a two.
00:02:43.934 - 00:03:10.610, Speaker A: For the input z, we're passing a three, and so on. The other advantage of writing a code like this is that now the order of inputs does not matter. So it doesn't matter if I pass in x, y, z, ABC, or I can also do like this, I can say ABC and then pass in xyZ. So when you pass inputs as key value pairs, you no longer have to worry about the order of inputs.
