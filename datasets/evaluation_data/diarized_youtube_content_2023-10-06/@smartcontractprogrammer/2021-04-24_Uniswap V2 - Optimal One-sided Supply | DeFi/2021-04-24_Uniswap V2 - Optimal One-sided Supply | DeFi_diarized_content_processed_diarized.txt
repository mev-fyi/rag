00:00:00.650 - 00:00:50.038, Speaker A: I have 1000 die and zero ether and I want to become a liquidity provider on Uniswap. So I'm going to sell half of the die that I have and then get some ether in return. Once I have both of the tokens, I'm going to put them into Uniswap and become a liquidity provider. Uniswap accepted all of my die, but it didn't take in all of my ether and it return some of it back to me. So by swapping half of my die for ether and then providing both of them as liquidity, I am left with some tokens that are unutilized, in this case, ether. Ideally, I would like to utilize all of my tokens for liquidity. So in this video, we'll find the optimal amount to swap so that we can minimize the amount of tokens that are unutilized.
00:00:50.038 - 00:01:28.118, Speaker A: We want to find the optimal amount of die to swap so that after adding liquidity, the amount of ether that is left in our hands is as low as possible. What is the optimal amount to swap? We'll say that uppercase A is the amount of token A in uniswap. Uppercase B is the amount of token B in Uniswap. F is the trading fee for trading from token A to b, and also from token B to a. Lowercase A is the amount of token A that I have. Lowercase B is the amount of token B that I need. S is the amount of token to swap from A to b.
00:01:28.118 - 00:01:58.754, Speaker A: Our final goal is to find S. And at this point, we don't know what b is. And we also don't know what S is. If we know S, b is not that hard to find out. So let's figure out what b is in terms of S. What does b equal? Well, we know that k is equal to a times b. In other words, the amount of token A and the amount of token b inside uniswap must equal a constant k, and after the swap, this constant must remain the same.
00:01:58.754 - 00:02:36.554, Speaker A: We can express the amount of token A and the amount of token b inside uniswap after the swap using this equation. So we're saying to A, we're adding s minus some fee. So this will be a percentage of S that we're adding onto a. From the b side, we are subtracting lowercase b amount of b tokens. From this equation, we can solve for b in terms of S. We will come back to this equation later so we know what b is in terms of S. Let's now find what S is after the swap.
00:02:36.554 - 00:03:35.170, Speaker A: The reserve ratio of token A to token B inside uniswap is equal to a plus S over B minus lower B. S is the amount of token A that was swapped, and lowercase b is the amount of b tokens that we got. Now, this reserve ratio must equal the ratio of tokens that we have. We started out with a tokens and we sold s amount of tokens and we got back B amount of tokens. The reserve ratio before adding liquidity must equal to the reserve ratio after adding liquidity. This is the reserve ratio before adding liquidity, and by adding tokens in amounts that are proportional to this ratio, we guarantee that the reserve ratio after adding liquidity will still be equal to this. And this will also guarantee that all of our a tokens and all of our b tokens will be utilized as liquidity.
00:03:35.170 - 00:04:10.140, Speaker A: From this equation, we can solve for S. I'll spare you the math. Finally, we get this quadratic equation in terms of S. Now, if you have a quadratic equation of the form ax squared plus bx plus c equals zero, then we can solve for x. X is equal to minus b plus minus the square root of b squared minus four ac over two a. And plugging this equation into our formula, we get that s is equal to this equation. We can further simplify this equation by replacing f with an actual number.
00:04:10.140 - 00:04:39.910, Speaker A: On uniswap, the trading fee f is 0.3%. Evaluating f equals three over 1000, we finally get this equation over here. F's the amount of token A that we need to swap to token b so that we can maximize liquidity. Is this formula over here. Let's write the actual contract. So this contract will calculate the optimal amount to swap and then perform the swap. And then finally add liquidity.
00:04:39.910 - 00:05:15.394, Speaker A: Solidity does not have a function to perform a square root. So I copied over the square root function from uniswap. Here is the formula that we derived earlier, and here is the actual code. Evaluate it with trading fee equal to 0.3%. Let's now write the function to swap and then add liquidity. I'll name this function zap. First it's going to take in all of our token A by calling transfer from and then we get the address of the Uniswap contract that handles exchange from token A to token B.
00:05:15.394 - 00:05:52.494, Speaker A: In our case it will be from dai to ETH. And we can get this address of the contract by calling get pair on the Uniswap factory contract. Once you get the address of the pair. We'll need to find out how much token A and token B is inside this contract, so we'll call getreserves on the pair contract. Next, we will calculate the optimal swap amount. The pair contract names the two side of the token, token zero and token one. We're not sure if token zero is equal to token A or token B, so here we'll do a conditional check.
00:05:52.494 - 00:06:47.550, Speaker A: If token zero is equal to token a, then we'll calculate the swap amount by passing in reserve zero the amount of token zero inside uniswap pair contract and then passing in amount a the amount of a tokens that we have. On the other hand, if this condition is false, then we'll calculate the swap amount using reserve one. Once we know the optimal swap amount, we'll do a swap from token A to dolk B for the swap amount. Once that is done, we'll add liquidity by calling an internal function add liquidity with token A and token B, and that completes our function. That will do an optimal swap and then add liquidity. This will minimize the unutilized tokens that we have after calling add liquidity. Now for comparison, I've also added a function called suboptimal zap.
00:06:47.550 - 00:07:41.578, Speaker A: Basically, this will swap half of the token that I have and then add liquidity. I've also added the function to do the actual swap, which I've already covered in another video, and the function to actually add liquidity, which I've also covered in another video. Here is the test that we're going to run the optimal swap and then the suboptimal swap. First I'm going to comment out the optimal swap. So we'll run the suboptimal swap once, reset everything, and then just run the optimal swap and then compare the numbers. We'll compare the amount of token A and token B that we have left after adding liquidity, and the less we have, the better it is. So I'm going to run Ganache on the main network and then open another terminal.
00:07:41.578 - 00:08:25.568, Speaker A: First we'll run the test for suboptimal swap. Notice that we have this much amount of die after adding liquidity. This is the amount of die that was not added to liquidity. Okay, let's now test the optimal version of swap and add liquidity. So back inside my test, I'm going to uncomment this and then comment out the suboptimal version. I'm going to restart Ganache and then rerun the test. Notice that this time we were able to utilize all of our tokens.
00:08:25.568 - 00:09:02.600, Speaker A: So after adding liquidity, we're left with zero dai and zero ether. All of our tokens are inside uniswap. We have successfully utilized all of our tokens. This video was based on a blog called optimal one sided supply to Uniswap by Alpha Homora. Similar code to the code that we wrote is actually in production on Mainnet. This contract is provided by Zapper Phi, and it basically does the same thing as the contract that we wrote. You can check out here that this is exactly the equation that we've also derived.
00:09:02.600 - 00:09:03.530, Speaker A: Thanks for watching.
