00:00:00.330 - 00:00:54.858, Speaker A: In the previous video we skipped all of the code inside the while loop. So today we'll go over some code inside the while loop and we will only write the code for a single iteration. First I'm going to open unisoft b three pool contract and this is the code inside the while loop. First let's copy over the condition of the while loop. So the condition is while amount specified remaining is not equal to zero and the current square root price x 96 is not equal to the limit amount specified remaining will be greater than zero for exact input and less than zero for exact output. So in our code you'll say state amount specified remaining not equal to zero and state square root price x 96 not equal to square root price limit x 96. Okay, the next step is to initialize a struct called step computations.
00:00:54.858 - 00:01:16.914, Speaker A: So I'll just copy this and then paste it here. And then the next step is to initialize a step computations. Set the square root price start x 96 to the current square root price x 96. Copy this. Okay, scrolling down. The next code gets the next initialized tick. But since we're only dealing with a single iteration, we'll skip this code for now.
00:01:16.914 - 00:01:38.986, Speaker A: And in the next video I'll explain the algorithm for how to get the next initialized tick. So here I'll just put to do. Moving on the next step is a check on the next tick. We'll skip this for now. The next line is to calculate the next square root price x 96. So I'll copy this, paste it here. So we copy this code.
00:01:38.986 - 00:02:11.686, Speaker A: Step is initialized tick next is initialized to the default value zero. So let's set this tick next to something other than zero. Going to scroll up and we can get the current tick by accessing state tick. So for now I'll just set step tick next to be equal to state tick plus one. Now it doesn't really matter what we put over here. We'll revisit this code when we do a swap for multi ticks. Okay, the next step is to call the function compute swap step.
00:02:11.686 - 00:02:51.694, Speaker A: And this function will calculate the square root price x 96 amount in amount out and the fees amount. So I'll copy this and then paste it here. Now notice here that it has some complex if conditions. So I want to explain what's going on here. So what this code is doing here is bounding the next square root price x 96 to the square root price limit. For example, for a 00:41 trade if the next square root price x 96 is to the left of the limit, then we return the limit. So we get the max of the next square root price x 96 and square root price limit.
00:02:51.694 - 00:03:27.534, Speaker A: On the other hand, if it was a one 40 trade, then we want to bound the next square root price to be less than the limit. And we do this by getting the minimum of the next and the limit. If it is a zero 401 trade, then we evaluate this condition. If the next square root price is less than the limit, then we return the limit. Otherwise we return the next one. On the other hand, if it was not a 00:41 trade, then we evaluate this condition. Is the next square root price greater than the limit? If it is, then we return the minimum of these two number.
00:03:27.534 - 00:04:00.778, Speaker A: So we return square root price limit. Otherwise we return the next okay, let's move on. So going back to the unison b three pool contract, the next thing that I'm going to explain is this code. So I'll copy this code and then paste it here and then refactor the code a little bit. Okay, so if the swap is an exact input, then amount specified remaining will be greater than zero. The while loop continues while amount specified remaining is not equal to zero. For exact input, we start out with a number greater than zero.
00:04:00.778 - 00:04:28.594, Speaker A: So we want to approach zero. So we minus step amount in and the fee amount amount calculated will be a negative number. So we subtract the amount that was calculated. On the other hand, if it was not an exact input, then amount specified remaining will be less than zero. To get to zero, we add step amount out and then amount calculated will be the amount that's coming in. So we add step amount in plus the fee. Okay, let's move on.
00:04:28.594 - 00:04:57.034, Speaker A: Let's go back to unison b three pro contract. Scroll down fee protocol we don't have this in our contract. Scrolling down. Updating global fee tracker we'll cover this in another video. So go back to our contract and then put a note okay, going back to unisoft B three pro contract again. Okay, the next step is to update the tick. However, since our code for now will only do a swap for one iteration, we will skip this part of the code.
00:04:57.034 - 00:05:25.700, Speaker A: So what I'm going to do is copy this part of the code and then paste it here and then make a note to complete this in another video. Scrolling down and that completes the while loop. So in this video we started writing the code inside the while loop and we only handle the case for one iteration. Before we can complete this function, I want to explain how to get the next tick the algorithm that's used inside the unison b three pool contract to get ah next take.
