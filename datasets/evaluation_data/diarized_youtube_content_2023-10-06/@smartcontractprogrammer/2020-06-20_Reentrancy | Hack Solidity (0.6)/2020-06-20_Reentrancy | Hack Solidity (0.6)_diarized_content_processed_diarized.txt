00:00:00.410 - 00:00:39.686, Speaker A: Hey everyone. Starting from this video, we'll learn how to hack solidity smart contracts. The purpose of this video is to learn how a smart contract can be hacked so that you understand the security risks involved writing solidity code. Lastly, this video does not encourage you to hack smart contracts in the real world. In this video, we'll explore a reentrancy. First, I'll explain what reentrancy is, and then we'll write some solidity code and see a demonstration of reentrancy attack in remix. Lastly, I'll show you some techniques to prevent a reentrancy attack.
00:00:39.686 - 00:01:31.100, Speaker A: So first of all, what is a reentrancy attack? Over here we have contract A and contract B. And let's say that contract a calls contract B. The very basic idea of reentrancy is that contract B can call back into contract a while contract A is still executing. So how can this be exploited? Well, let's say that contract A has ten ethers and contract B has zero ethers. Inside contract A, it keeps a record of how much ether it owes to other contracts and addresses in here. Contract a holds one ether from contract B. Now, let's say that it has a function called withdrawal, where if you have some ether stored in this contract, then you are able to withdraw it.
00:01:31.100 - 00:02:03.918, Speaker A: And the way it works is like this. It will first check that you have enough balance, and then it will send back to you all of the ether that you've stored in this contract. And then after it sends the ether back to you, it will set your balance to zero. So, for example, let's say that Alice has one ether stored in this contract and she withdraws from this contract. It would check Alice's balance. Does Alice have ether stored in this contract? Yes, she does. She has one ether.
00:02:03.918 - 00:02:39.918, Speaker A: Next, it sends that one ether back to Alice. So Alice gets one ether, and the total ether stored in this contract is ten minus one, which is nine ether. And finally, it sets Alice's balance to zero. So that's how the withdrawal function works. Let's now see how contract B can use the reentrancy to exploit the withdrawal function. Contract b is going to need two functions, the fallback function and a function named attack. And in both functions, it's going to call the withdrawal function inside contract day.
00:02:39.918 - 00:03:15.798, Speaker A: The way reentgency work is like this. First, eb calls the attack function. This will call the withdrawal function inside contract a. Inside contract A. Since contract b is the caller here, it checks that the balance of contract b is greater than zero, and it is since here contract b has one ether, so it sends that one ether back to contract b. And when it does inside contract b, it triggers the fallback function. So now contract b has one ether and contract A has nine ether.
00:03:15.798 - 00:04:23.358, Speaker A: Now, the fallback function inside contract b calls back into the withdrawal function inside contract A, and then it checks the balance of contract b. Is the balance of contract b greater than zero? If you look above, you can see that the balance of contract b is still one ether. So this check passes and it sends another ether back to contract b, which triggers the fallback function. And now contract B has two ethers and contract A has eight ethers, while the balance of contract b inside contract A is still equal to one ether. So this means that while the balance of contract b is not updated, it can keep withdrawing ether from contract A. And this could keep on going since the balance is updated on the last line of the withdrawal function, but it is not reached since it keeps on looping between the fallback function and the withdrawal function. And this is how contract b can keep on withdrawing ether from contract A by calling back into contract A.
00:04:23.358 - 00:04:55.386, Speaker A: While function inside contract A is still executing. Let's now see this in code using remix. Here we have a contract named Etherstore and you can store your ether in it. You can store your ether by calling the deposit function. And this will update the internal balance which is kept by using the mapping balances. You can also withdraw by calling the withdrawal function. It will first check that you have enough ether stored in this contract, and then it will send the ether to your address.
00:04:55.386 - 00:05:38.194, Speaker A: And lastly, it will update the balances mapping. And finally, we have a helper function called get balance which will return the total amount of ether stored in this contract. All right, so let's now write the contract that's going to use the reengency to attack this contract. We'll name this contract attack. We'll store the target contract to exploit in a state variable called Etherstore. When we deploy this contract, we'll pass in the address of the etherstore, and then we'll set our target by saying Etherstore equals Etherstore and then passing the address of the etherstore. We'll need two functions to do the reentry exploit.
00:05:38.194 - 00:06:18.310, Speaker A: We're going to need the fallback function and the function to initiate the attack and the function that's going to start the reentry exploit here. I named it attack. When we call this function, we're going to send one ether to ether store. So here let's require that we have enough ether to initiate the attack. And we can do that by requiring message value is greater than or equal to one ether. The first thing that we'll do is deposit one ether into etherstore. So here we'll say etherstore deposit followed by curly braces.
00:06:18.310 - 00:06:56.322, Speaker A: And inside the curly braces we say value semicolon one ether and we call the function by putting two parentheses. So the way you send ether to another contract in solidity 0.6 is like this. You need to use the curly braces and then specify the amount that you're going to be sending. Now the way you would do the exact same thing in solidity 0.5 was like this, using dot value and then specifying the amount. So this is 0.5
00:06:56.322 - 00:07:34.106, Speaker A: syntax and this is 0.6 syntax. And we'll be sticking with this syntax. After we send one ether to the etherstore contract, we'll immediately withdraw the 1 meter that we just sent. And we do this by calling etherstore, withdraw one ether and when we call this function, etherstore will send back the one ether that we just deposited. So this would trigger the fallback function above. So inside the fallback function we'll withdraw again by calling Etherstore withdrawal.
00:07:34.106 - 00:08:34.690, Speaker A: Now we want this reengency exploit to stop at some point. So inside the fallback function we'll say so we'll say if address of Etherstore balance is greater than or equal to one ether, then we'll call the withdrawal function. So here we're saying if Etherstore has more than one ether, then let's withdraw one ether from it. Just to quickly go over how the code is going to execute, when we call the function attack, it's going to call Etherstore withdrawal. And since Etherstore is going to send back one ether to this contract, it's going to execute the fallback function. And inside the fallback function we check that Etherstore has at least one ether and then call withdrawal again. Lastly, we'll add a helper function to check the balance stored in this contract.
00:08:34.690 - 00:09:06.282, Speaker A: And this will help us see the final amount of ether taken from Etherstore. That completes the code to do a re entrancy exploit on Etherstore. Let's deploy the contracts and see them in action. So I've deployed two contracts, Etherstore and attack. Let's say that account one is Alice, account two is Bob, and account three is Eve. And inside etherstore, Alice has one ether and Bob has also one ether. So in total.
00:09:06.282 - 00:09:36.954, Speaker A: This contract has two ethers stored, and we can check it here. Let's now call this function attack to take the two ethers stored in Etherstore. So first we'll switch over the account to account number three, which is eb. And to call the attack function, we're going to need one ether. So here we'll send one ether when we call the attack function. So e executes the attack function. And you can see here that the transaction was successful.
00:09:36.954 - 00:10:18.930, Speaker A: So we were able to steal two ethers even though we only deposited one ether. And we can confirm that this contract now has three ethers by calling get balance. And we can check here that it has three ethers. And we can also check that etherstore has zero ethers by calling get balance and it has zero. Let's see how the code was actually executed by using the debug feature in remix. So here I've set up some breakpoints, and you can do it by clicking on the line like this. And this will allow us to pause the code at that breakpoint.
00:10:18.930 - 00:11:07.780, Speaker A: We can rerun the transaction that did the reentgency exploit by going to the actual transaction. Once you find the transaction, hit the debug button, and you'll see a screen like this on the left. And then you can hit this button here to go to the next breakpoint. So it first calls the deposit function, which updates the balance. And then next it calls the withdrawal function. It checks that the balance of the attack contract is greater than one ether, and it is since we just deposited one ether. So the Etherstore contract sends one ether back to attack contract, which calls the fallback function.
00:11:07.780 - 00:11:40.410, Speaker A: And inside the fallback function, we check that Etherstore has more than one ether so that we could call withdrawal again. So at this point, we deposited one ether and withdrew one ether. So inside Etherstore, there's two ethers left. It calls withdrawal on Etherstore. The balance of attack has not changed since we never hit this line. So over here, we still have one ether. So Etherstore sends another ether to the attack contract.
00:11:40.410 - 00:12:32.506, Speaker A: Here, Etherstore had two ethers, and it just sent one to us. So now it has one ether left, and it calls the withdrawal function again. The balance still has not changed for the attack contract sends another ether. So that's the third time. And ether stores started out with three ethers, so now it has zero ether. And when we hit the breakpoint, it does not call the withdrawal function again, and it breaks out of the loop of the reentrancy and after we withdrew three ethers, it finally updates the balance, and that completes the code execution of the reentrancy exploit. So how do you prevent your contract from getting attacked by reentrancy? Well, I'm going to show you two techniques.
00:12:32.506 - 00:13:22.850, Speaker A: The first technique is to update your state variables before you make any external calls to other contracts. So what you'll have to do here is move this code up over here. You're making changes to the state variable before you make a call to another contract. And you may ask, how does this prevent the reentrancy attack? Well, it works like this. The first call to send ether will trigger the fallback function. The fallback function will call back into the withdrawal function and it will make a check to the balance. But since we updated the balance before we sent the ether, the balance over here will be the updated balance after the withdrawal.
00:13:22.850 - 00:14:21.130, Speaker A: And if you don't have enough ether in the balance, then this line of code will fail. So that's the first way of preventing a reentry attack, by updating the code before you make any external calls. The second way to prevent a reentry attack is by using a modifier called reentrancy guard. The idea here is that you lock the contract while a function is executing, so that only a single function can be executed at a time. We will need an internal state variable to lock the contract inside the modifier, no reentrant. We'll first check that the state variable locked is not locked, and then we'll set locked equal to true execute the function, and then only after the function finishes execution, we'll set locked equal to false. And then lastly we'll put the no reentrant function modifier to the function withdrawal.
00:14:21.130 - 00:15:07.950, Speaker A: So here we'll say no reentrant. And how does this prevent a reentrancy attack? Well, let's say that the attacker calls the withdrawal function. This will call the no reentrant function modifier, and then set locked equal to true. It will execute the function. So the code inside here will be run. And let's say that the attacker is able to call back into the withdrawal function the second time before the first one finishes execution. So no reentrant function modifier will be called again, but this time around, blocked is equal to true, and this check will fail, which will fail the transaction, and the attack fails.
00:15:07.950 - 00:15:31.300, Speaker A: And that completes the second technique of preventing a reengency attack. I hope you found this helpful and you now know how to prevent against reengency attack. If you have any questions or comments. You can put them in the comments below or you can message me on Discord channel and the links will be in the descriptions below. Have a nice weekend and see you soon.
