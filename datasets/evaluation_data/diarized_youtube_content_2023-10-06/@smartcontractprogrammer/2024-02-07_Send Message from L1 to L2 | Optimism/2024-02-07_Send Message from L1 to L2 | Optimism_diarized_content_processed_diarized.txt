00:00:00.330 - 00:00:37.074, Speaker A: Recently, I learned how to send messages between contracts on Ethereum and contracts on optimism. So in this video, I'll share you what I learned. What we'll do is we'll set up the faucet for optimism and also set up the network. And then we'll deploy a contract on Ethereum Testnet and optimism testnet. And then we'll send some message from Ethereum testnet over to optimism testnet. And what I mean here when I say send message, it means that by sending a message, we'll be able to call contract l two from L1. So the first step is to set up a faucet for optimism and also set up the network for testnets.
00:00:37.074 - 00:01:09.070, Speaker A: The first thing that I'll do is register the network for Sepoldia testnet onto my metamask. And all you have to do is go to optimism documentation and I'll paste this link in the description. So just follow the link and then from here, click on this link. This will open another tab and then go ahead and click on connect. Here I'm setting the network on Metamask and my metamask will pop up. So I'll click on switch network opening metamask. I can confirm that now I am on optimism.
00:01:09.070 - 00:01:45.774, Speaker A: Sepolio testnet if your metamask does not have sepolia testnet, then you also need to configure this. Once we have the testnets registered on the metamask, the next thing that we need to do is get some EF on Testnet. So there are two EFs that we need to get, one on Sepolia and one on Sepolio. Also from the official documentation, I'll click on this link to get EF on Sepolia and click on this link to get EF for Opolia. Clicking on this link will open a new tab that looks like this. Go ahead and paste your address here and get some EF for Sepolia. Next, click on this link.
00:01:45.774 - 00:02:10.582, Speaker A: This will open another tab. So go ahead and fill out the form and get some op Sepolia EF. Once that's done, you can open your metamask to check that you have ETH on op Sepolia. And you can also check on Sepolia testnet that you also have some e. So once that's done, the next step is to write our contract and then deploy it on these two testnets. Okay, back in metamask. So step one is done.
00:02:10.582 - 00:02:38.606, Speaker A: Let's now write a contract and we'll deploy it both on L1 and L two. What we'll do is write a simple contract called greeter. And what we're going to do is send a message from L1 to L two. To call contract from L1 to L two. We'll need to send a message to a specific contract deployed on the testnet. This contract is called cross domain messenger. And by sending a message to this contract, this message will be relayed over to optimism L two.
00:02:38.606 - 00:03:13.994, Speaker A: Now there are two functions that we need to know to be able to send a message to L two. The first function, the easy one, is called send message. You'll specify the target and some kind of call data and gas limit to be spent on L two. So we'll be calling this function to send a message over to the L two contract. And also we have another function called xdomain message sender. When our message is relayed over to L two, our l two contract will be executed. Inside our l two contract message sender will be this cross domain messenger contract that is also deployed on L two.
00:03:13.994 - 00:03:47.742, Speaker A: If you wanted to get the address of the greeter contract on L1, then we will need to call this function to get its address. These two function will become more clear as we write our code. Okay, so let's write our code. The first thing that I'll do is create a constant which will hold the address of the messenger contract. The cost domain messenger contract, say address public. Immutable. Since there are two different messengers, one on l one and one on l two, we'll make this immutable and we'll set it when we deploy our contract messenger.
00:03:47.742 - 00:04:24.750, Speaker A: Here are the two addresses for the messenger on e sepolia testnet. This will be the address of the messenger, and on op sepolia, this will be the address of the messenger. Okay, next we'll create a state variable called remote greeter. This will hold the address of the greeter contract on the other chain. For example, if this contract is deployed on L1, then this state variable will hold the address of the greeter contract on l two. And if this contract is on L two, then this state variable will hold the address of the greeter contract on L1 address public. We'll call this remote greeter.
00:04:24.750 - 00:05:02.666, Speaker A: Then let's now write the constructor. Constructor, we'll pass in the address of the messenger and say messenger is equal to messenger. Next, we will write a function to set the remote greeter. So say function, set remote greeter address remote greeter external and then say remote greeter. Remote greeter is equal to remote greeter. We'll keep this example simple and I'm not going to worry about authorization. Anyone will be able to set the address of remote greeter.
00:05:02.666 - 00:05:58.266, Speaker A: Okay, next let's write a function to send a message over to the l two contract. So say function send, you'll send a message string call, data greeting external okay, so we'll call the I cross domain messenger at the address messenger. So if we deploy this greeter contract on L1, then it's also calling a messenger contract on L1 and then call send message. We'll need to pass three parameters, target target will be the remote reader, message will be the message that we want to send. So this is like if you're dealing with the low level call function, this will be like the raw data that you're sending when you're executing the function call, say Abi encode call. We'll write a function later and encode the parameters. And the last parameter will be gas limit.
00:05:58.266 - 00:06:27.410, Speaker A: Gas limit. Let's set this to let's say 200,000. So this is how we will send a message to the messenger contract on L1. And once this message is sent, this message will be relayed over to l two and then execute the contract on L two. Next, let's fill out this part. Let's write a function that we'll call on the remote greeter, so say function. What we'll do is the function that we'll create is we'll call it set.
00:06:27.410 - 00:07:28.486, Speaker A: And what we're going to do is set a greeting for some address. So I'll create a mapping mapping from address to string, call it public greetings, greetings, so set will take in two parameters, address of sender and string call data greetings. And what we'll do is set the greeting for sender, greetings of sender, set it equal to greeting. Now when we deploy this contract on L two, we don't want anyone to be able to just set a greeting. We only want the messenger deployed on L two to be able to call this function. So what we'll have to do is say require message sender is equal to messenger and let's say for the error message not messenger. So now the first check checks that message sender is equal to the messenger contract.
00:07:28.486 - 00:08:32.574, Speaker A: We're going to deploy this greeter contract both on L1 and on L two. From L1 we're going to call this function send and try to execute this function set that is also deployed on L two. So we made sure that on L two message sender is equal to the messenger on L two. But how do we check that the message came from this greeter contract on L1? Well, we can get the sender of L1 by calling this function x domain message sender. So over here, let's say require icross domain messenger, messenger xdomain message sender. So the message sender on l one that called into this function and this should be equal to the remote greeter. For the greeter contract deployed on l one, this remote greeter will reference the l two contract and for the greeter contract that will be deployed on l two, this remote greeter will reference the greeter contract deployed on L1.
00:08:32.574 - 00:09:16.178, Speaker A: So this function over here, xdomain message sender is how we get message sender that sent the message over from l one. And if these two don't match, let's just say not authorized. Okay, so that completes the function for set. Let's now complete the function for send, so send a message. And what function do we want to call on the remote greeter? Well, it's going to be this function set. So inside here, say this set, call the function set with the parameters, the parameters are sender, let's say message sender, message sender, and the next parameter will be greetings. So this will be greetings that we get from here, greetings.
00:09:16.178 - 00:09:57.770, Speaker A: I'll hit Ctrl s to see if the contract compiles and the contract compiles. This is the contract that we'll deploy both on L1 and on L two. The next step is to deploy this contract both on L1 and on L two. Click on the deployment tab and click on injected provider and I'll make sure that I'm on sepolia Testnet and I'll deploy this contract. So for the constructor argument we'll need to pass in the address of the messenger on L1 will be this address, paste it here and then deploy the contract. Once the contract is deployed, I'll make a note here saying that the L1 contract is deployed here. Next we'll deploy the contract on L two.
00:09:57.770 - 00:10:41.478, Speaker A: So I'll click on my metamask and I'm going to switch over the network over to op Sepolia, click op Sepolia and then make sure that the network has changed on remix. And then we'll deploy the greeter contract this time on L two. On L two we'll need to pass in the messenger address using this address, paste it here and then deploy the contract. Confirm the transaction and wait for the contract to deploy. Okay, the contract is now deployed, so we have l one contract and l two contract. What is the next step? The next step is to set the remote greeter contracts. Currently we're on op sepolia.
00:10:41.478 - 00:11:16.818, Speaker A: So let's set the remote greeter contract to be the L1 greeter contract. Copy the address to the L1 greeter contract. And inside the l two greeter contract, I'll call the function, set remote greeter, paste the address, and then call the function, confirm the transaction. Once the transaction goes through, let's check remote greeter. So this is the address of the L1 greeter contract. Next we'll switch over to L1 and then set the remote greeter contract on the L1 greeter contract. Switch over to sepolio, make sure that the network switched also on remix.
00:11:16.818 - 00:11:44.458, Speaker A: And then we'll call the L1 greeter contract. Set remote Greeter and the address of the remote greeter will be this one. I'll copy this and then paste it here. And then call the function, confirm the transaction and wait for the transaction to go through. Okay. After the transaction goes through, the next step is to send message to L two. So make sure that we're on L1 sepolia testnet.
00:11:44.458 - 00:12:23.318, Speaker A: And what we're going to do is call the function send. We're going to be sending a message to this l two greeter contract. And what we expect to happen is on the l two greeter contract, we expect that this function will be called and we'll set the greetings. So from L1, let's say hello l two, call the function, send and confirm the transaction. So what we're doing now is calling this function. We're telling the messenger contract on L1 to call the contract on L two. The address of the contract is the remote greeter.
00:12:23.318 - 00:12:48.514, Speaker A: This will be the l two greeter contract. And we want to execute the function called set with the parameters message sender and greeting. We're going to wait a few minutes for the message to relay over to L two. Once the message is relayed, it will automatically execute this function. And afterwards we'll query greetings on the l two contract. Okay. I waited a few minutes for the message to relay over to L two.
00:12:48.514 - 00:13:19.322, Speaker A: Let's check that our transaction went through on L two. So first thing that I'm going to do is switch the network over from Sepolia to op Sepolia, click on Metamask, then switch the network over to op Sepolia. And then we'll check the greetings. We sent the parameter with message sender. Message sender will be this address over here. So I'll copy this, scroll down and then open the l two greeter contract. And we'll paste the address in here.
00:13:19.322 - 00:13:36.206, Speaker A: And then call greetings. And we get the message. Hello, l two. This is amazing. We sent a message over from the L1 contract. And magically the l two contract was executed. So in this video we call the contract from L1 over to a contract on L two.
00:13:36.206 - 00:13:46.260, Speaker A: In the next video I want to do the opposite. I want to send the transaction from L two and then call contract on L1. Thanks for watching and see you in the next video.
