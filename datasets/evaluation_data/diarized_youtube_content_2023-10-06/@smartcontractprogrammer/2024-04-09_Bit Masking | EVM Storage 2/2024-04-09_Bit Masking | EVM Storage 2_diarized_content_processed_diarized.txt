00:00:00.440 - 00:00:42.046, Speaker A: State variables that are less than 32 bytes, if possible, will be packed into a single slot. To manually read and write from these state variables, we will need to learn a little bit of bitmasking. So in this video I'll explain some bitmasking tricks that we'll need to reiterate from state variables that are packed into a single slot. First, I'll briefly explain how state variables are packed into a single slot, and then I'll move on to the bitmasking tricks. In the next video we'll go into the details of how to read and write from state variables that are packed into a single slot. So, as an introduction to state variables that are packed into a single slot, let's consider that there is a state variable of bytes four. So this will be four bytes.
00:00:42.046 - 00:01:06.728, Speaker A: I've named it b four. And I have another state variable called b two, which occupies two bytes in a single slot. We can store up to 32 bytes. In this case we have four bytes, and then the next state variable has two bytes. So these two state variables will be stored in a single slot. The first state variable will be stored in slot zero. This data will be stored all the way to the right of bytes 32.
00:01:06.728 - 00:02:04.390, Speaker A: For example, if we represent 32 bytes as 64 characters of hexadecimal strings, then the state variable Abab Ab will be stored to the right of this 32 bytes. And then this next state variable, b two will be stored to the left of this abab abab. So in slot zero we will get CDCD and then followed by abab ab Abab. And to show you this, I'll compile the contract and then we'll deploy this contract and then call the function get. And you can see over here that this 32 byte string ends with CDCD ab ab. The four bytes Abab ab is the first state variable and it is stored all the way to the right of this 32 bytes. The next state variable that takes two bytes, CDCD, is stored right next to this first state variable.
00:02:04.390 - 00:02:43.468, Speaker A: So that is what I mean when I said that state variables that are less than 32 bytes, if possible, will be packed into a single slot. In our example, in slot zero of state variable called b four, and two bytes of state variable called b two are packed into slot zero. And the way the state variables are packed are from right to left. Here is how these two state variables are stored into slot zero. Now, let's say that we wanted to use assembly to maybe read the second state variable stored in st zero. Or maybe we wanted to update the first state variable that is stored in zero. To do this, we need to learn some bitmasking.
00:02:43.468 - 00:03:22.986, Speaker A: For example, if you wanted to update this second state variable that is stored in zero, this CDCD, then we will need to create a bitmasking that looks like this. It is all f's except for these two bytes that we want to update over here. They are set to zero. And by creating this bitmask we will be able to clear out just this part of the data. Now, to be able to create this bitmasking, you'll need to know other tricks with bits. So the first trick that I'll show you is how to create a sequence of ones followed by zeros. And in our example we'll be using 256 bits.
00:03:22.986 - 00:04:00.244, Speaker A: So this means that we have a sequence of zeros and ones having the length 256. And we're going to create a bitmask where counting from the right we have all ones to a certain point, and from there we have all zeros. I'll call this function test mask public peer returns and we'll return bytes 32. I'll call this mask and we'll do this inside assembly. So assembly. For this example, let's say that we wanted to create 16 bits of ones. So this will be 16 bits or sequence of ones having the length 16.
00:04:00.244 - 00:04:41.912, Speaker A: To this variable mask we'll create a mask and then assign it. The way we will create 16 bits of ones followed by all zeros is first, by creating all zeros except at the 16th position, we'll have a one. And here we're working with zero index. So this will be index zero index one, index two, so on. And this will be index 16. So to put a one at the 16th index, what we can do is use the bitwise operator. Shift left 16 times one, shift 116 times to the left, and we'll have a one at the 16th position and everything else will be a zero.
00:04:41.912 - 00:05:13.522, Speaker A: So so far what this represents is this, to turn this into all zeros and then follow by 16 bits of ones. What we have to do is simply subtract one from this, subtract one sub one. Okay, let's try this out. Choice to compile the contract. Then we'll deploy the contract and then call the function test mask. And this is the mask that we get. 16 bits is two bytes.
00:05:13.522 - 00:06:05.592, Speaker A: Two of these hexadecimal character is also one byte. So four of these will be two bytes or 16 bits. And if you convert this into binary, you'll get this number, 16 bits of ones followed by all zeros. If you wanted to have 32 bits of ones followed by all zeros, then all you have to do is change this 16 to 32. And if you wanted to have 128 bits of ones starting from the right and going to the left and then followed by all zeros, what you'll have to do is change this to 128 and so on. So now we know how to create a sequence of ones followed by zeros. But what if we wanted this ones to be somewhere in the middle so that you have something like zeros, a sequence of zeros followed by a sequence of ones, and then followed by sequence of zeros again.
00:06:05.592 - 00:06:35.506, Speaker A: And for this example, we will be using 16 bits of ones. And for the zeros, let's say 32 bits. So we will have 32 zeros followed by 16 ones, and then the rest will be all zeros. To start off with, I'm going to first copy this code. Then I'll rename this to test shift mask. So at this point, what this code will do is this. This code will create 16 ones followed by all zeros.
00:06:35.506 - 00:07:18.272, Speaker A: Now, to create sequence of bits, so that we start off with 32 bits of zeros followed by 16 bits of ones. So what we want is this. To create this, all we have to do is shift this part that we created in the last example, shift it over to the left by 32. So I'll type shift left by 32 with the bitmask that we created in the previous example. Okay, let me show you example of what we have so far. So hit control s to compile the contract and then deploy the contract again. And then we'll call the function test shift mask, copy the mask that was returned, and this is what we have.
00:07:18.272 - 00:07:56.438, Speaker A: So notice that this FFF matches the FfF from the previous example. So this is 16 bits of once. And before that we also have some zeros. How many zeros do we have? We have 12468 zeros. Two of these represent one byte and we have eight zeros. So we have four bytes of zeros, which is equal to 32 bits of zeros. Okay? So all we did was first created a sequence of ones like in the previous example, and then we shifted over this mass to the left by however many bits that we wanted.
00:07:56.438 - 00:08:45.862, Speaker A: In our example, we shifted this mask over to the left by 32 bits. Okay, for the last example, what if we wanted to turn this around? We had this so far, but what if we wanted to invert it? So, for example, we will have 1111 followed by 16 bits of zeros and then followed by 32 bits of ones. So let's start off by copying this code. And then how do we change this code so that we can create something like this? I'll rename this function as test not mask. Currently, this code will create this mask. The mask that we want to create in this example is the opposite. We want all bits to be ones except for the 16 bits over here, followed by 32 bits of ones again in hexadecimal.
00:08:45.862 - 00:09:23.834, Speaker A: This is what we want. Okay, to create this mask, all we have to do is invert all the zeros and ones. And we can do that by simply wrapping this whole code with a not not will invert the zeros and ones of this mask, and this will produce this mask. Okay, let's give it a try. Compile the contract, deploy again, and then call the function test not mask. And this is what we get, okay? And it matches the mask that we wanted to create. So in this video I showed you examples of how to create some bitmask.
00:09:23.834 - 00:09:31.274, Speaker A: In the next video, we'll be using some of these bitmasking tricks to read and write from state variables that are packed into a single slot.
