00:00:00.570 - 00:00:37.640, Speaker A: Let's take a look at how to solve the fourth challenge of damn vulnerable DfI side entrance there is a lending pool that allows anyone to deposit E and withdraw at any point in time. This lending pool has 1000 e and it is offering a free flash loan. The challenge is to take all e from the lending pool. Let's take a look at the code. Here's the lending pool contract that we need to chain all of the ETH from. Anyone will be able to deposit ETH and then withdraw the ETH that they've deposited. Scrolling down let's take a look at what the flash zone function does.
00:00:37.640 - 00:01:37.450, Speaker A: It takes in an input of amount the amount of ETH that we want to borrow and then checks if the amount that we want to borrow is less than or equal to the actual amount of beef that is inside this vending pool contract. It calls the function execute message sender sending the amount of beef that was requested and then afterwards it checks that the balance of beef in this contract is greater than or equal to the balance of beef before the flash loan was executed. The challenge is to drain all of the EF stored in this contract. Pause the video here if you want to give it a cat. In a few seconds we will be going over the solution. Okay, so let's go over the solution. How do we drain all of the ETH stored in this lending pool contract? The idea is to get a flash loan for all of the ETH stored in this contract and then deposit the amount that we borrowed.
00:01:37.450 - 00:02:15.142, Speaker A: After the flash loan is done executing, we immediately call withdrawal. Let's write this in code. The contract that's going to be receiving the flash loan is called hack side entrance and it's initialized with the address of the lending pool. We'll initiate the attack by calling the function attack. Inside this function, the first thing that we'll do is call flash loan on the pool. The amount that we're going to be borrowing is all of the ETH inside the pool contract. Notice that when I scroll up so we call flash loan which is this function over here.
00:02:15.142 - 00:02:56.546, Speaker A: And then the flash loan calls back into a function called execute. So inside the hack contract we need to write a function called execute. Inside the hack contract, I've declared a function called execute. And what do we do when this execute function is called by the Flashstone? We're going to immediately deposit the amount of ether that we borrow. We'll do that by calling pool deposit, sending all of the ETH that was sent to this function. Once deposit is called, this will update the balance of ETH that we can withdraw. We've called deposit with all of the EF stored in this contract and the last step is to call withdrawal.
00:02:56.546 - 00:03:48.230, Speaker A: So scrolling back down and back inside the attack contract. Once the flash loan is done executing we'll call withdrawal. We'll call withdrawal and the ETH will be sent back to this contract. To be able to receive the ether that was sent from calling withdrawal we need a fallback function which is payable and once that is done we'll send all of the e that we just chained from the lending pool to message sender and that completes the attack contract. Let's now deploy this contract and then call attack function inside the test script inside entrance challenge Js I've deployed the hack side entrance contract and then called attack. We'll run the script by typing mpm run side entrance you you. We passed the test.
00:03:48.230 - 00:03:52.900, Speaker A: We've captured the flag of the fourth challenge. Thanks for watching. See you next week.
