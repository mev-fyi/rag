00:00:00.320 - 00:01:06.302, Speaker A: In this video I'll explain how to use the load label functions inside assembly called call call data copy, return data size, and return data copy. We'll be using these functions to call another contract. The function call takes in several inputs and it will take a contract that address a. Use a maximum gas of g and send b weigh amount of ether. We specify the input that is loaded onto memory from in to in plus int size and then we also specify the region and memory where to return the output from this call. The function call data copy is used to copy the data from call data into memory. And for the input it's going to take in the starting position of the memory to start copying the data, and the starting location to start copying the call data plus the size of the call data to copy the function return data size gets the size of the return data from a call, static call or delegate call and then the function return data copy will copy the data that was returned either from a call, static call or delegate call into memory starting at position p, and the data to copy from return data is specified by the input start and start plus size.
00:01:06.302 - 00:01:38.120, Speaker A: In this video we'll write assembly to call this counter contract and then call a function inc. Now this function is going to return the count after it is incremented. We'll also decode this using assembly. So first I'll create a contract. I'll call this, you'll call and then it's going to have a single function for function. I'll call this you call and it's going to take in two parameters, address of the counter contract. I'll just call this a DDR and we'll encode the data to call the function inc.
00:01:38.120 - 00:02:16.126, Speaker A: So call this call data, I'll just call this data and this function will be external. You'll make the call to the function increment and this increment returns the current count. After it is incremented we will capture this output inside our function, yield call and then return the raw bytes. So say returns bytes memory to make a call to the counter contract and then return the data as bytes. Here are the things that we'll need to do. We'll first load the free memory pointer and then copy data to memory and then call a counter contract. We'll revert if the call is not successful, and if it is we'll get the return data size.
00:02:16.126 - 00:02:36.668, Speaker A: Next we'll return the data as AbI encoded bytes. And this takes several steps. We will need to store the offset, store the name, copy the data from return data and then actually return the data. So let's start with load free memory pointer. Let's call this. Let p is equal to m load. The free memory pointer is always stored at the memory location.
00:02:36.668 - 00:02:59.806, Speaker A: Zero x 40. The next task is to copy call data to memory. So when we call the function counter, the function inc will use the function call and then pass this data. And this data will encode the function to call the function inc. So let's first copy this call data to memory. Okay, and how do we copy call data to memory? Let's scroll up. So here it is.
00:02:59.806 - 00:03:28.408, Speaker A: I'll copy this and then paste it here. Call data copy the memory location to start copying from will be from the free memory pointer p. And then we also need to specify the start. The start of the call data to copy and the size of the call data to copy. The start will be stored in data dot offset. This offset stores the location of the call data where this data actually starts. And then the size is stored in data length.
00:03:28.408 - 00:03:53.662, Speaker A: Okay, the next task is to call a counter contract. And to do this we'll copy this and then paste it here. We'll send all of the guests. So we say guess I and the address will be a DVR. The amount of ether to send will be zero. And the data to send inside memory is located at memory location p. This is where we loaded the call data data.
00:03:53.662 - 00:04:22.520, Speaker A: And the size will be data dot length. And for the return size we'll set it to zero for now since there's another way we can get this. So set zero and then zero. And when we call this function, it's going to return a single variable and we can check this to see if the call failed or not. So say that I'll call this ok is equal to this ok will either be a zero or a one. If this call fails, then this ok will be a zero. Otherwise if it is successful it will return a one.
00:04:22.520 - 00:04:56.618, Speaker A: So say if is zero ok. If ok is zero then we'll just simply revert, revert zero zero. The next task is to get the return data size. After you make the call to the counter contract, we're going to call the function ink and it's going to return the current count. Now this count will be encoded and returned inside the return data. We can get this return data size by saying return data size. And we'll assign this to let's say that return data size is equal to okay.
00:04:56.618 - 00:05:43.730, Speaker A: The next task is to return data as AbI encoded bytes. So the first task is to store the offset m store we'll use the free memory location p again, at first starting from memory location p, we store the data data and now we're using some parts of the same memory location to overwrite the memory. But it's okay because we're going to call return to finish execution of this function. So let's start offset. You'll say zero x 20 and then store the length. M store the size of the data that was returned is return data size and the place that we'll need to store is 32 bytes after where the offset is stored. So this will be add to p zero x 20 and we'll store the length as return data size.
00:05:43.730 - 00:06:14.528, Speaker A: Next, we'll copy data into memory from return data. And how do we do this? Scoring up this is the function that we need to call. The start of the memory will be 32 bytes after here. So this will be additive two p zero x 40 the start of the return data to copy. We'll copy all of it. So we'll start from location zero and the size will be return data size. And lastly we'll return the data that was copied into memory.
00:06:14.528 - 00:06:54.346, Speaker A: Let's say return starting from p. The first 32 bytes stores offset, the next 32 bytes stores the length, and then after that we have the actual return data that is stored. To return data size, we will need to add an extra 64 bytes, add an extra 64 bytes, zero x 40 to return data size. Return data size okay, and that completes the example for how to call another contract. Using call and using assembly to actually test this call, we'll create a helper contract. Okay, here's the helper contract. It's going to take in the address of this yield contract.
00:06:54.346 - 00:08:01.750, Speaker A: It's going to also take in the address of the counter contract and then it's going to call the function yield call passing the address of the counter contract and also ABI encode call the function to increment. When we call this yield call, notice here that it's going to return this count as bytes, Abi encoded bytes and then we'll capture it here and then we'll Abi decode this response. Let's give it a try. Hit CtrL s to compile the contract, deploy all three contracts, scroll down, and then to test the yield call contract, I'll open the test contract and we'll need to call the function test Inc. Copy the address of the yo call contract and then also copy the address of the counter contract and then hit transact, open the transaction log, scroll down and we can see over here that for decoded output it returned the count after incrementing. So the data that was returned is one. If you call the function again and then get the decoded output, now we get a two.
00:08:01.750 - 00:08:10.670, Speaker A: So in this video I showed you example of call call data copy, return data size and return data copy to make an external call to another contract using assembly.
