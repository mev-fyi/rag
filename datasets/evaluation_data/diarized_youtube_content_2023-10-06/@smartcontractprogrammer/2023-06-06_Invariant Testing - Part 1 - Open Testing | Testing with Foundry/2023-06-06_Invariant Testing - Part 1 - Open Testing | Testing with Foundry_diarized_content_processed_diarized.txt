00:00:00.250 - 00:00:33.094, Speaker A: In this video, I'll explain how to write invariant testings in foundry. The topics that we'll cover are difference between fuzz and invariant testing. I'll show you example of a failing invariant test, an example of passing invariant test. And lastly, when you run invariant test, it will show some stats. So I'll explain what these stats mean. Runs, calls, and reverts. So first, what is the difference between fuzz and invariant testing? The difference between fuzzing and invariant testing is that for fuzzing, a random input is passed into a single function and that function is tested multiple times.
00:00:33.094 - 00:00:58.170, Speaker A: On the other hand, in invariant testing, a sequence of functions are randomly called. After these functions are called, some checks that you write will be executed. If all of your checks pass, then the invariant test also passes. That is the difference between fuzz and invariant testing. Let's take a look at a failing invariant test. So first, we'll create a contract to test. I'll say contract intro invariant.
00:00:58.170 - 00:01:20.822, Speaker A: It's going to have a single state variable, boolean public. I'll name it flag. And for this example, we'll run an invariant test to make sure that this flag is always false. Next, let's create some functions. These are the functions that the invariant test will randomly call. So say function funk, one external. The code inside it doesn't really matter.
00:01:20.822 - 00:01:52.346, Speaker A: So I'll just leave it empty, and we'll create multiple of these functions. Function two, three, four and five. Now, inside five, inside function five, we'll do something different. We'll set the flag equal to true. Here I'm going to be showing an example of a failing invariant test. The test will be to check that this flag is always equal to false. However, as you can see, if function five is called, the flag will be set to true.
00:01:52.346 - 00:02:20.882, Speaker A: Okay, next, we'll write the invariant test. So first we'll import some libraries from foundry. So I'm going to import the test sol, and then I'll name this contract intro invariant test is test. Then we'll have a function called setup. Inside the setup, we'll deploy this contract intro invariant. So here I'll type intro invariant private. I'll name it target.
00:02:20.882 - 00:03:03.622, Speaker A: And then inside the setup, we'll deploy this contract target equals new intro invariant. Okay, so let's write our first invariant test. To write an invariant test, you type function, and it has to start with the name invariant. And then I'll name this flag is always false. Then inside here, we'll check that the flag inside this contract flag is always equal to false. Assert equal target flag should always be equal to false. Now, obviously, if function five is called, the flag will be set to true.
00:03:03.622 - 00:03:52.758, Speaker A: So this assertion will fail and the invariant test will fail. What I want to see here is that if foundry is smart enough to be able to call these function randomly, and at some point be able to call the function five, set the flag to true, and make this assertion fail. So let's run the test. Open my terminal, then type forge test match path test invariance. The name of the test is invariant zero, t sol, and as you can see, our test failed. Let's take a look at the sequence of functions that were called to make the invariant fail. So, if I check here on the sequence, I can see that foundry called function one, function three, and lastly, it called function five.
00:03:52.758 - 00:04:24.550, Speaker A: So when function five was called, the flag was set to true, and our assertion failed. And so our invariant also failed. So this was an example of a failing invariant test. What foundry did when we wrote the invariant test is that it called the functions inside the intro invariant contract randomly, and at some point, it called a function five. Set the flag to true, and our assertion failed. So next, let's take a look at a passing invariant test. For the next example, we'll write an invariant test for wef.
00:04:24.550 - 00:04:55.558, Speaker A: Wef is an Erc 20 wrapper for ETH, deposit ETH, and you get back wef. Withdraw wef, and you get back ETH. So for the setup, I created a file called invariant one. T sol imported some libraries from foundry, and also imported the WEF contract. And then inside the setup, I deploy the WEF contract, and I named this test Wef. Open invariant test. The reason why it's called the open test is because it's going to test all of the functions inside the WEF contract.
00:04:55.558 - 00:05:26.866, Speaker A: I'll come back to this topic later. For now, we'll write an invariant test for WeF, and for this example, we'll keep it simple. So I'll name it function invariant. Let's keep it simple, and let's check that the total supply of left is always equal to zero. Total supply is always zero public. And then inside here, we'll check that assert equal ref. Total supply should always be equal to zero.
00:05:26.866 - 00:06:38.006, Speaker A: So for this example, what's going to happen is that foundry is going to call the functions inside ref randomly, and then after it calls some sequence of functions, it would check, it will assert equal that total supply of ref is equal to zero. Okay, to show you this, I'll open the terminal again, clear the logs, and then we'll run the test forge test match path for invariant one, t zol. And as you can see, our test passed. But now you might be asking if foundry calls the functions inside wef randomly. For example, if it calls the function deposit, then wouldn't that increase the total supply, the amount of beef locked inside wef? How is it that our invariant total supply is always equal to zero? If foundry calls these functions randomly, at some point it should call the function deposit and increase the total supply. So what's going on here? Well, to answer this question, we'll go back to our terminal, and if you look at this stats over here next to our invariant test, look at this stats over here has runs, calls, and reverts. Let's start with runs.
00:06:38.006 - 00:07:38.286, Speaker A: Runs is a number of sequence of functions that this invariant test called and calls is the total amount of function calls, and rebirths is the total amount of functions that failed when this invariant test called a function inside ref. So notice that in total, it called 3840 times on the web contract. And out of this 3840 calls, 2263 failed. The reason why we're seeing so many fails on WEf is because if you go back to WeF, you can see that some of these functions will fail if message sender try to withdraw or transfer more than what their balance is. For example, let's say that the function withdrawal was randomly called. But if balance of message sender is less than what they want to withdraw, then this function will fail. Likewise for transfer, and transfer from these will also fail if the balance of message sender is less than the input of the amount that they try to transfer.
00:07:38.286 - 00:07:58.930, Speaker A: So this is the reason why we see so many fails over here. This was an example of how to write invariant tests in foundry. Now, we saw in this video that a lot of the functions that were being called were failing. So in the next video, I'll show you how to write a smarter invariant test so that the number of sales that you see over here will be smaller.
