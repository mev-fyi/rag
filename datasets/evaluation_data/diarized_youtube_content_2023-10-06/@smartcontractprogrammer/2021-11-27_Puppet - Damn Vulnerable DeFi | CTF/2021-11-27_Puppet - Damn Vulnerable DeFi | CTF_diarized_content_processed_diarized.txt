00:00:00.330 - 00:00:31.862, Speaker A: Let's tackle the 8th challenge of damn vulnerable dFI puppet there is a lending pool where you can borrow dBT tokens. To borrow the DBt tokens, you first have to deposit twice the borrow amount in ETH as collateral. The pool has 100,000 dbt tokens. Now there is a uniswap B one exchange with ten E and ten dBT. In liquidity, you start with 25 e and one and DBT. The challenge is to drain all dbt tokens from the lending pool. Let's take a look at the code.
00:00:31.862 - 00:01:12.674, Speaker A: The first contract that we need to take a look at is called puppet pool. Inside the constructor, it initialize the dbt token and it sets the Uniswap B one exchange to Uniswap Oracle. This contract has two functions, borrow and compute oracle price when you call borrow, you specify the amount of DBT tokens that you want to borrow. It calls the uniswap B one contract to calculate how much dBT token is worth in terms of ETH. To borrow dbt tokens, you'll need to send two times the value in ETH. Any excess ETH that you've sent will be refunded. It records the amount of ETH that you locked as collateral and then sends the DBT tokens to you.
00:01:12.674 - 00:02:02.858, Speaker A: The function compute oracle price calculates the exchange rate from DBT tokens to ETH. Multiply this by the borrow amount and we get how much ETH we need to borrow the DBt tokens. Lastly, you might want to check the unisoft by contract. Uniswapexchange by the challenge is to drain all DBT tokens from this pool. Contract pause the video here if you want to give it a try, and in a few seconds I'll go over the solution. Okay, let's go over the solution. So the solution is to manipulate the oracle price, set the token price and way to zero so that we can borrow all of the tokens inside this contract without sending any ether as collateral, and we can set token price and way to zero by manipulating the balance in unison.
00:02:02.858 - 00:03:18.046, Speaker A: B one exchange the way it calculates the price of dBT tokens is that it divides the amount of beef inside the Unisoft b one contract by the balance of dBT tokens inside the Unisop B one contract because division by un round down to zero. If we can send more DBT tokens into uniswap B one contract than the amount of beef that is locked in there, then this will return a zero. So token price and weigh will be zero, and we'll be able to borrow all of the tokens locked in this contract without locking any collateral. To do that inside puppet challenge JS, we're going to be sending a lot of tokens to unisoft B one exchange to skew the pool, and this will cause the compute oracle price to return zero. To do that, we approve Unisop B one exchange to spend all of our tokens, all of our DBT tokens, and then we swap our DBT tokens for ETH by calling Uniswap exchange token to ETH swap input. Afterwards, we'll check that the price of compute Oracle price is zero by logging it, and then we'll call lending pool borrow all of the tokens inside the pool. Let's run this challenge inside the terminal.
00:03:18.046 - 00:03:29.080, Speaker A: I'll type NPM run puppet it, the price is zero and we passed a challenge. Thanks for watching. See you later.
