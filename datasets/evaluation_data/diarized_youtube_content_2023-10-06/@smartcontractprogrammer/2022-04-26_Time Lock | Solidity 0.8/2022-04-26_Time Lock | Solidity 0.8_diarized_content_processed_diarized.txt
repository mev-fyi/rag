00:00:00.250 - 00:00:41.750, Speaker A: Timelock is a contract commonly used in DFI and dows. The purpose of this contract is to delay a transaction. First, you will broadcast the transaction that you're going to execute, and this is done by calling the function queue you're queuing a transaction. Once a transaction is queued, you will have to wait a certain amount of time defined in the timelock contract. This is usually anywhere from 24 hours to several days. Once the time has passed, then the function execute can be called to execute the transaction. These two steps of publishing a transaction that you're about to execute, waiting a few days and then actually executing it gives users some time to make sure that the transaction that you're about to execute is nothing dangerous.
00:00:41.750 - 00:01:22.146, Speaker A: For example, here I have a contract called test time lock, and I also have a function called test. This function can only be called by the timelock contract. Now this function might execute some code to upgrade the contract, transfer funds, or switch the price. Oracle any code that gives a lot of power to the owner of the contract. You can replace it with a time lock, and this will give the users of your contract more trust in you. Since any potentially dangerous code will have to be queued, wait a few days before it can be executed. If the owner of the contract is malicious and they try to steal your funds, as long as the function is secured by the time lock, you'll have some time to withdraw your funds before the owner steals your funds.
00:01:22.146 - 00:02:05.562, Speaker A: So that's the purpose of a timelock contract. Delay a transaction so that it gives the user some time to react before the transaction is submitted. Okay, so let's write the function for q. The function queue will take in the address of the target contract to call it will also take in a unit amount of ether to send. I'll name it value the function to call this will be string, so string call data funk and the data to pass to the function bytes call data data and the timestamp after which this transaction can be executed. So I'll say un time stamp. Now I only want this function to be called by the owner of this contract time lock.
00:02:05.562 - 00:03:02.578, Speaker A: So let's set the owner of this contract by saying address public owner and then set it inside the constructor. Constructor owner is equal to message sender and then we'll also define a modifier, modifier only owner. And then we'll say if message sender is not equal to the owner, then we'll revert with a custom error. We'll call it not owner error. Since we have not defined this error, we will copy this and then define it here. Error not owner error. If message sender is the owner, then we will execute the rest of the code with the underscore and then attach this only owner modifier to the function queue.
00:03:02.578 - 00:04:06.086, Speaker A: So external only owner to queue a transaction, we'll need to first create the transaction id from these parameters and it has to be unique. So I'll put a comment here for now, and then we'll later write the function out, create txid and then we'll need to check that the transaction id is unique, make sure that it is not queued. We also need to make sure that the timestamp that was passed from the input is greater than or equal to the minimum delay from the current time. So check timestamp and then lastly we'll queue the transaction. Okay, so let's write the function to compute the transaction id. First I'll name this function, get txid and the parameter are these same parameters as the q function. Paste it here and we'll make this function public so that we can call this function inside this contract, and any user can also call this contract.
00:04:06.086 - 00:05:18.590, Speaker A: To compute the transaction id, this function will be peer and it's going to return the transaction id that was computed. So returns bytes 32 txid. To compute the transaction id, we'll use the catch app 256 and hash all of these values. So we'll type return catch 256 of ABi encode and we'll encode all of the parameters target value funk data timestamp so back inside the function queue we will get the transaction id by calling bytes 32, txid is equal to get txid of target value funk data timestamp. Next, we'll need to check that this transaction id has not been queued yet. So we'll create a mapping from transaction id to boolean. If this transaction id is queued, then the boolean will be true, otherwise it will be false.
00:05:18.590 - 00:06:46.560, Speaker A: So I'm going to scroll up and then declare a mapping mapping from bytes 32 to boolean public and I'll name it queued and we'll check if the transaction id is unique or not by checking if it is queued or not by typing if queued txid. Then we'll rebirth with the error message already queued error passing in the tx id this custom error, we have not defined it yet, so we'll do that right now. Scroll up and then define error already queued error this error will take in a single parameter of bytes 32, the txid. Okay, what do we have to do next? So once the code reaches here we know that the transaction is not yet queued, so let's check the timestamp. We'll say that the current block is over here and we need to make sure that this timestamp fits between block plus min and block plus max. So our timestamp will have to be somewhere inside here. So to do that we'll say if the timestamp from the input is less than block timestamp plus min delay, we'll define this constant later.
00:06:46.560 - 00:08:04.246, Speaker A: Or if timestamp is greater than block timestamp plus max delay, then we'll throw an error message with rebirth and we'll call this error timestamp not in range error. We'll log the current timestamp, block timestamp and the timestamp that was passed from the input underscore timestamp and we'll define this error and these constant min delay and max delay. So I'll copy this, scroll up, and then paste error timestamp not in range error this error takes in two inputs, the current timestamp un block timestamp and the timestamp that was passed from the input un timestamp. Next, let's define the constants min delay and max delay. So we'll say un public constant min de is equal to 10 seconds. We'll use 10 seconds for this example so that I don't have to wait a few days. But in practice, usually min delay will be anywhere from a day to two weeks.
00:08:04.246 - 00:08:48.738, Speaker A: For Max delay we'll say un public constant Max delay is equal to 1000 and for most contracts on the main net this will be something like 30 days. But here for this example you'll just use 1000 seconds. Scroll back down. So once we did some check, the next thing is to queue the transaction. That's easy. All we have to do is say queued of TxID is equal to true and then we'll emit the event emit queue and we'll log all of the inputs. So that will be target value funk data time stamp.
00:08:48.738 - 00:09:40.018, Speaker A: We have not defined this event yet, so let's do that. The inputs are going to be the same, so copy this, scroll up, and then we'll define the event event q. Paste the code from the inputs of the function q. We also want to log the transaction ID. So we'll say bytes 32 Txid, and we'll put an index on this indexed same with the target contract indexed, and then rename some of the parameters that are being logged, remove the underscores and also the call data, and then scroll back down. We also log txid and that completes the function for queuing the transaction. Let's now write the function to execute the transaction.
00:09:40.018 - 00:10:29.018, Speaker A: The function execute will execute a transaction that's been queued. It's going to take in the same parameter as what we passed in the function queue. So I'll copy this and then paste it inside the function execute. When we execute a transaction by calling this function execute, there's a possibility that we might be sending some ether, so we'll make this function payable and then also enable this contract to receive some ether by scrolling up and then defining a fallback or a receive function. Here we'll define a receive so receive external payable. Now this contract can directly receive ether, so scroll back down. What else do we need to do? This function execute similar to the function queue.
00:10:29.018 - 00:11:22.514, Speaker A: We probably only want the owner to be able to execute this function, so we'll say only owner. Once the transaction is executed, we'll return the results, so we'll say returns bytes memory the first thing that we'll do is get the transaction id, so copy this and then paste it here. We will want to check that the transaction has been queued. I'll put it as a comment for now and then we'll fill out the code later. Check TX is queued we also want to make sure that this transaction has been queued for more than minimum delay. When we created the function to queue the transaction, the timestamp had to be greater than the current time plus the min delay. So by the time we get here, this timestamp must be greater than the current block timestamp.
00:11:22.514 - 00:12:38.218, Speaker A: So we'll do a check that the current time block timestamp is greater than timestamp passed from the input, and then we'll delete the transaction from queue and then execute the transaction. To check that the transaction is queued, we simply have to look into the mapping queued, so we'll type if not queued Txid. Then we'll throw an error rebirth not queued error passing in the txid we have not defined this error yet, so I'll copy it and then we'll define it. Error not queued error takes in a single input bytes 32 Tx id scroll back down. Next we'll check that the current timestamp is greater than the timestamp that was passed from the input, and if this check passes, this means that this transaction has waited more than the minimum delay. We'll type if block timestamp is less than the timestamp from the input. This means that the current time has not surpassed the minimum waiting period.
00:12:38.218 - 00:13:28.958, Speaker A: So we'll throw an error rebirth time stamp, not past error, and then into there we'll put the current timestamp, block timestamp, and the timestamp from the input, copy the error and then declare it over here. Error timestamp not passed error takes in two inputs, the same as one over here. So I'll just copy this and then paste it here. Then we'll scroll back down. We also want to have some logic where the transaction is expired. For example, once the transaction is queued and the current time has surpassed the timestamp, we want to make sure that this timestamp is not a timestamp from like a year ago. We want to make sure that the transaction to be executed is not expired yet.
00:13:28.958 - 00:14:03.722, Speaker A: So we'll introduce what's called a grace period. Let's say that the timestamp from the input is over here and timestamp plus the grace period is over here. The transaction is valid to be executed if block timestamp is within this range. If, however, the block timestamp is over here, then this means that the transaction is expired. We will put this in code by typing. If blocked up, timestamp is greater than the timestamp from the input plus grace period. We'll define this constant later.
00:14:03.722 - 00:15:05.470, Speaker A: Then we'll revert with the error rebirth timestamp expired error passing in block timestamp and the timestamp plus the grace period timestamp plus grace period so we'll scroll back up and define the error and the constant. Grace period error timestamp expired error this will take in two inputs, un block timestamp and un expires at. Then we also have to define a grace period. This will be a constant, so I'll type event public constant grace period is equal to. For this example, we'll just say 1000 seconds. So this means that once the transaction that's been queued is ready to be executed, we have 1000 seconds before the transaction expires. Scroll back down.
00:15:05.470 - 00:15:50.746, Speaker A: Next we'll delete the transaction from the queue, and that's easy. We'll type q txid is equal to false, and then finally we'll execute the transaction. Now, to execute the transaction, we'll type target call, passing in the value that was passed from the input value, underscore value, and then passing in some data. However, notice that we split the function name from the data to pass to the function. So we need some logic to prepare the data to be passed to the target contract. We will declare the data to be passed bytes memory data. If this function is empty, then we'll just simply pass data.
00:15:50.746 - 00:16:29.158, Speaker A: Otherwise this function is not empty. So we'll have to ABI encode the function and then append the data. So to do that, we'll say if bytes of funk from input length is greater than zero, then we'll say data is equal to ABI encode packed from the funk. You'll need to compute the function selector. This will be ketcheck 256 of bytes of funk. And then taking the first four bytes of the hash bytes four, and that will be the function selector. And to this we'll append the data from the input.
00:16:29.158 - 00:17:03.618, Speaker A: Otherwise, if function is empty, then we'll just directly send the data. So else data to send is equal to data from the input executing the transaction. This will return two outputs, Boolean okay and some kind of response bytes memory. I'll name it rest as in response. And we'll make sure that we got an okay back. So if not okay, then rebirth with tx failed error. We'll define this error later.
00:17:03.618 - 00:17:57.318, Speaker A: And this response that we got back. We all want to return it. So return press and we also emit the event for execute emit execute passing in the tx id and all of the inputs target value funk data time stamp let's scroll back up and define the event execute and the error tx error scroll back up and then define the error tx failed error. And the event execute is very similar to the event queue. So I'll copy it, paste it here, and then rename this to execute. And that completes the function. To execute a transaction, let's say that a transaction has been queued and we don't want to execute it, we just want to cancel it.
00:17:57.318 - 00:18:27.870, Speaker A: So let's now write a function to cancel the transaction. So say function cancel. This will be external and only the owner should be able to call this only owner. To cancel a transaction, all we need is the transaction id. So we'll say bytes 32 txid underscore txid. We'll check that the transaction has been queued. So we'll type if not queued Txid.
00:18:27.870 - 00:19:21.738, Speaker A: Then we'll rebirth with not queued error passing in Txid. And we already defined this not queued error, so we don't have to go back up and define it. And just to double check, I'll hit Ctrl s to compile a contract and it compiles. So that means that we have already defined this there we'll remove the transaction from the queue by typing q Txid is equal to false. And then lastly we'll emit the event emit cancel with txid. We have not defined this event yet, so I'll scroll back up and define the event event cancel bytes 32 txid, and we'll put an index on it, indexed, and that completes the contract timelock. Okay, let's now test the timelock contract.
00:19:21.738 - 00:20:14.526, Speaker A: We'll call the function test, and this function can only be called if the caller is the timelock contract. So we'll deploy the timelock contract and the test time lock contract, and then we'll queue the transaction to call the function test. So inside queue we'll pass in the address of the test time contract amount of ether to send zero function to call test data to pass to this function is empty and the timestamp at which this function can be called. We'll get the timestamp from a helper function that I created called get timestamp. This will return the current timestamp plus 100 seconds. So I'll copy this, paste it here, and then we'll execute the transaction. So for the data instead of an empty string, I have to pass zero X.
00:20:14.526 - 00:21:07.850, Speaker A: So we need to wait 30 seconds. But let's try to call this transaction before the 32nd passage. So I'll copy all of the inputs and we'll call the function execute again. Next time transaction should be successful. I've waited a minute or two, let's now try calling the function execute again. So I'll hit transact, and this time the transaction was successful. So a time lock contract, you publish a transaction that you want to execute, and after waiting a certain amount of time you can actually execute the transaction.
