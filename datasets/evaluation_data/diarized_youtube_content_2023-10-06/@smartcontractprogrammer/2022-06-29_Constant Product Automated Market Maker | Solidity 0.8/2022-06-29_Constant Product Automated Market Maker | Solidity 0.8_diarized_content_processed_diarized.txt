00:00:00.330 - 00:00:35.938, Speaker A: Let's write a code for a constant product Amm. A constant product Amm will take in two tokens. These two tokens will be ERC 20. So first let's import IERC 20 interface to ERC 20, which I've already declared it here. So back inside my constant product amm, first thing that I'll do is import the IERC 20 sol that I declared over here. So I'll type import from the current directory, import IERC 20 sol. Next, we'll declare some state variables and then write the constructor.
00:00:35.938 - 00:01:40.210, Speaker A: This contract will take in two tokens, so I'll declare IERC 20 public immutable immutable because the tokens will not change after we set the tokens inside the constructor, so immutable token zero and likewise IERC 20 public immutable token one. These are the two tokens that this constant product Amm will be trading. We'll set these two tokens inside the constructor. So let's write a constructor, say constructor, and it's going to take in the two address of token zero and token one. Address underscore token zero and address underscore token one inside the constructor. We'll initialize token zero and token one. So I'll say token zero is equal to IERC 20, token zero from the input, and likewise token one is equal to IERC 20 from token one from the input.
00:01:40.210 - 00:02:34.046, Speaker A: Okay, let's continue on with declaring other state variables. This contract will keep internal balance of the two tokens. So I'll type un public reserve zero and un public reserve one. I name these two state variables. State variables that keep track of how much token zero and token one is inside this contract. Reserve zero and reserve one because this is how it is named inside unison B two contract when a user provides or removes liquidity, we'll need to mint or burn shares, so we'll declare some state variables. We'll say that the total share will be stored in un public total supply and the share per user will store it in a mapping mapping from address to un public balance up.
00:02:34.046 - 00:03:23.294, Speaker A: And that completes the state variables that we're going to need for this example. Next, let's write some internal function to mint and burn shares. The next function that I'm going to write is an internal function to mint shares. So I'll type function underscore mint. It's going to take in two parameters, the address to mint two and the amount. Address underscore two un amount this function will be internal, so I'll declare it as private and to mint shares, we'll increment the balance of for the two address by the amount amount from the input, and we also increment the total supply. So total supply incremented plus equals by the same amount.
00:03:23.294 - 00:04:01.006, Speaker A: And this completes the internal function to mint shares. Next, let's write an internal function to burn shares, decrementing shares from a user. I'll copy the mint function and then we'll rename this to underscore burn the address to burn the shares from the amount will be the same and rename two to from. And instead of incrementing, we'll decrement the shares and the total supply. And that completes the two internal function to mint shares and burn shares. Okay, moving on, let's write the function that the users will be able to call. So this will be function swap.
00:04:01.006 - 00:04:40.630, Speaker A: For now, we won't worry about the inputs or the outputs. We'll just declare some functions so users can call a swap to do a trade between token zero and token one, or from token one to token zero. Also declare this as external so that the solidity still compiles. We also need a function to add liquidity. External user will be able to provide two tokens into this contract to add liquidity and earn some fees by calling add liquidity. This will also mint shares to the user, and the opposite of add liquidity is to remove liquidity. So function remove liquidity.
00:04:40.630 - 00:05:31.254, Speaker A: External users that add tokens to this contract are called liquidity providers, and once they have shares, these liquidity providers can call the function remove liquidity to withdraw their tokens and some fees that accrued from a trade. These are the three functions that the users will be able to call on this contract. Let's write the function for swap. First, the function swap will take in two parameters. The address of the token to sell. We will name this token in, and this will have to be either token zero or token one, and the amount that they're selling un amount in and then we'll return the amount of other token that the user gets back, so returns un amount out. We'll first check the inputs, make sure that token in is either token zero or token one.
00:05:31.254 - 00:06:23.250, Speaker A: Then also check that amount in is greater than zero. So I'll type require token in is either equal to address of token zero or token in is equal to address of token one. If token in is not equal to token zero and token in is not equal to token one, then this will return an error with the message invalid token. Next, we'll require that the amount in is greater than zero, so require amount in greater than zero. With the error message amount in is equal to zero. Before we move on and write any more code, let's think through what this function needs to do. First, we'll need to point the token that the caller is selling.
00:06:23.250 - 00:06:54.750, Speaker A: I'll type pull in token in, and then we'll need to calculate token out. And this would include fees. We'll say that the fee is 0.3% of amounting and then we'll need to transfer token out to message sender. And then we'll need to update the reserves. So this will be reserve zero and reserve one. Okay, so these are the comments.
00:06:54.750 - 00:07:47.266, Speaker A: Let's now write the code. Now, notice that we're pulling token in and then transferring token out, but from our inputs token in, we don't know if token in is token zero or if it's token one. So first let's write some code to figure out whether token in is token zero or whether it is token one. So I'll create a boolean called is token zero. And this is equal to whether the input token in is equal to address of token zero. Once we know whether token in is token zero or token one, we can now figure out what token in and token outs are. So I'll declare IERC 20 token in and IERC 20 token out is equal to if token in is token zero, so is token zero.
00:07:47.266 - 00:08:21.450, Speaker A: Question mark. Actually, I'll put the question mark here. If token in is token zero, then token in over here will be token zero and token out will be token one. Otherwise it will be the other way around. So token one token zero. So now that we declared a local variable token in and token out, we can now write some code to pull in the tokens and then transfer the tokens out. So I'll type token in, transfer from from message sender to this contract.
00:08:21.450 - 00:09:00.474, Speaker A: So address this for the amount amount in, and we also know what token out is. So let's complete this part of the code. Transfer token out to message sender. I'll type token out. Transfer to message sender for amount out. Now, we don't know what amount out is yet, but we already have declared it over here. So inside this function, we don't need to declare amount out as something like unit amount out because we have already declared it inside the output of the function.
00:09:00.474 - 00:09:31.486, Speaker A: Swap unit amount out. Okay, so inside the swap function, we transfer token in and transfer token out. Next, we'll calculate the amount of tokens to transfer out to message sender. When we worked out the math for how much tokens that go out. We derived the equation that the amount of tokens that go out Dy is equal to this equation over here. Y times dx divided by x plus dx. Y is the amount of token out that is locked inside this contract.
00:09:31.486 - 00:10:16.822, Speaker A: Dx is the amount of token in that came in, and x is the amount of token in that is locked inside this contract before the swap. So we'll implement this part of the equation to calculate the amount of tokens that go out dy. But before we do that, let's compute the amount of tokens that came in minus the fee of 0.3%. So I'll type uint amount in with fee is equal to amount in times 99.7. So 997 and divided by 1999 divided by 1000 is 99.7. And effectively we are charging a fee of 0.3% from a mountain.
00:10:16.822 - 00:10:59.054, Speaker A: Okay, once we have a mountain, we can now implement this part of the code to calculate amount out. So amount out is equal to Y will be reserve out and x will be reserve in. But we have not declared these variables yet. So before we complete this part of the code, let's declare the variables reserve in and reserve out back where we check token in and token out. We'll say un reserve in and un reserve out. If token in is token zero, then reserve in is reserve zero and the token that is going out. So reserve out will be reserve one.
00:10:59.054 - 00:11:44.366, Speaker A: I made a spelling mistake over here, so I'll remove the R, otherwise it will be the other way around. So reserve in will be reserve one, and reserve out will be reserve zero. Okay, so now we declare reserve in and reserve out so we can continue calculating amount out. Amount out is equal to reserve out times. The amount that came in will be amount in with fee. And then we'll need to divide this by reserve in plus amount in with fee. So I'll type reserve in plus amount in with fee, and that completes amount out.
00:11:44.366 - 00:12:19.434, Speaker A: We just implemented this equation and the last step of the swap is to update the reserves. Now we're going to be updating the reserve also when we call the function to add liquidity and remove liquidity. So first let's implement an internal function that will update the two reserves. I'll scroll up and then declare an internal function function. I'll name it underscore update. It's going to take in two inputs, the values for the new reserves. Un I'll name it underscore reserve zero and un underscore reserve one.
00:12:19.434 - 00:13:11.018, Speaker A: This will be a private function and what they will do is update the reserves. Reserve zero is equal to the new reserve zero from the input, and likewise, reserve one is equal to the new reserve from the input. Okay, so let's continue finishing the function swap. The last step of the function swap is to update the reserve. So underscore update, and we'll update the reserve to be the actual balance of Token Zero and token one. I'll type token zero, balance of address this, and likewise, reserve one will be updated to the actual balance of token one. Token one, balance of address this.
00:13:11.018 - 00:14:02.854, Speaker A: Now, why are we keeping track of the amount of token Zero and token one internally in a state variable called reserve zero and reserve one? Well, we are doing this so that users cannot directly send token zero and token one to mess up the balance of the two tokens. And if they were able to directly manipulate the balance of token zero and token one, then they might be able to mess up the swaps and the amount of shares to mint and burn. So that is why we're keeping an internal track of amount of tokens inside this contract, and that completes the function for swap. Let's move on and write the function for add liquidity. Okay, let's think through what the function add liquidity should do when a user calls the function add liquidity. We'll pull in two tokens, token zero and token one, and then mint shares. So I'll put some comments.
00:14:02.854 - 00:14:29.758, Speaker A: Pull in token zero and token one. Next we'll mint shares. And lastly we'll update reserves. So for the input, we'll take in the amount of token zero and token one to pull from the user. Un amount zero and un amount one. And then we'll return the amount of shares that was minted. Returns un shares.
00:14:29.758 - 00:15:08.366, Speaker A: So first, let's pull in token zero and token one from the user. So token zero. Dot transfer from message sender address this for amount, amount zero, and likewise for token one. Token one. Transfer from message sender to this contract for the amount amount one. Now at this point, the user can add any amount of token zero and token one, but if they do that, then this will mess up the price of the tokens. So after we pull in the amounts, let's make sure that the price of the tokens has not changed yet.
00:15:08.366 - 00:16:04.714, Speaker A: In the previous video about math, we derived that the amount of tokens that the users can add to liquidity without changing the price must follow this condition. The amount of token one that comes in over the amount of token zero that comes in must be equal to reserve one over reserve zero and this is a restriction. If reserve zero or reserve one is not equal to zero. So I'll type. If reserve zero is greater than zero or reserve one is greater than zero, then we'll implement this check require reserve zero times amount. One that came in must be equal to reserve one times amount zero. What I'm doing here is instead of dividing and getting dy over dx, I'm multiplying dy times x and then y by dx.
00:16:04.714 - 00:16:46.394, Speaker A: If this check does not hold. This means that by adding liquidity, the user can change the price of the token. So we'll say the error message is equal to dy over dx is not equal to y over x. The next step is to mint shares. Now in the previous video about math, we defined that we're going to measure liquidity by taking the square root of x times y. And then we also derived that the amount of shares to mint s is equal to dx divided by x times t the total supply the total shares and this is equal to dy divided by y times total shares. So first I'm going to declare an internal function called square root.
00:16:46.394 - 00:17:26.922, Speaker A: So I'll copy a square root function that I found from the Internet and then paste it here. This square root function, I copied it from the Unisoft code base and we now have a way to implement this part of the code. Let's write the code to calculate the amount of shares to mint. We're going to be implementing this part of the code for shares to mint. There are two parts. If total shares is equal to zero, and when total share is greater than zero. So type if total supply, total supply keeps track of the total shares is equal to zero, then we'll say that the amount of shares to mint shares is equal to square root of the amount that came in.
00:17:26.922 - 00:18:07.922, Speaker A: That will be amount zero times amount one. Otherwise, we can use this equation to calculate the amount of shares to mint shares is equal to now notice that dx divided by x times t is equal to dy divided by y times t. So we can use either of these equations. But for safety, we'll take the minimum of these two calculation. So first I'll declare an internal function called function underscore min. This will take in two inputs, un x and un y. This function will return the minimum of x and y.
00:18:07.922 - 00:19:12.138, Speaker A: Private peer returns un and we'll say return if x is less than or equal to y, then return next. Otherwise y is smaller. So return y now that we have a function called min we're now ready to implement this part of the code by saying min of amount zero times total supply divided by reserve zero. And this part of the expression will be amount one times total supply divided by reserve one. Next, we will check that the amount of shares to mint is greater than zero, require shares greater than zero, else shares is equal to zero. And then we'll mint the shares by typing by using the internal function mint that we declared above mint to message sender further amount shares. And lastly, we'll update the reserves.
00:19:12.138 - 00:20:08.766, Speaker A: So I'll type update, and then again we'll use the actual balance of the tokens. Token Zero, balance of address this and token one, balance of address this. Again, we're keeping track of the reserves internally, and then only updating the reserves to actually match the actual balance of token zero and token one after the function is called. And this is done for security purpose. If we were to mint the shares using the values of token zero balance of this contract, or token one balance of this contract, then the user might be able to mint more shares than what we actually want them to. So we're keeping track of reserve zero and reserve one, mostly for security reasons. We don't want the user to directly send tokens and manipulate with the shares and the price that is kept inside this contract and that completes the function.
00:20:08.766 - 00:21:03.950, Speaker A: Add liquidity let's move on and write our final function. Remove liquidity so the function remove liquidity let's first think of what this function needs to do before we write any code. We'll need to calculate amount zero and amount one to withdraw. So this will be amount zero and amount one to transfer back to the users for burning shares. So the input will be un shares that is provided by the user, and we'll return the actual amount of token zero and token one that was transferred over to the user. Returns un amount zero and un amount one once we know the amount of token zero and token one to withdraw to the user, at some point we'll have to transfer it. So transfer tokens to message sender.
00:21:03.950 - 00:21:43.182, Speaker A: We'll also need to update the reserves and burn the shares, but we probably want to do that before we transfer the tokens to message sender. So I'll type burn shares and update reserves. Okay, so we're now ready to write the code. Let's start off by calculating amount zero and amount one to transfer back to the user. Again. In the previous video, we derived that the amount of token zero that goes out DX is equal to shares divided by total shares times amount of token Zero in this contract. And likewise for token one.
00:21:43.182 - 00:22:29.258, Speaker A: The amount of token one that goes out to the user is equal to shares divided by total shares multiplied by amount of token one in this contract. So first, let's implement these two part of the code. To get the amount of tokens locked in this contract that's x and Y. Instead of using the reserves, we'll use the actual balance of the tokens, and this will make sure that the user gets a fair share of the tokens locked inside this contract. I'll type Unbow zero is equal to token zero. Dot balance of address this and we'll do the same to get the balance of token one. Unbow One, token one, balance of and then we can calculate the amount of tokens that is going to go out.
00:22:29.258 - 00:23:20.730, Speaker A: Amount zero is equal to s will be the shares to burn shares times balance of token zero will be bow zero and then divided by the total supply. Total supply. Likewise for amount one is equal to shares multiplied by bow one divided by total supply. And we'll require that both amount zero and amount one are greater than zero, amount zero greater than zero, and amount one greater than zero. Otherwise, I'll say amount zero or amount one is equal to zero. Once we know the amounts of tokens to transfer back to users, let's now burn the shares of the user. And we'll do that by calling the internal function that we defined.
00:23:20.730 - 00:23:50.610, Speaker A: Underscore burn from message sender for the amount of shares from the input. Next, we'll update the reserve. So I'll say update. We're going to be transferring amount zero from Token zero. The balance of token zero before transferring out is Bal zero. Amount zero will go out, so that will be minus amount zero, and the new reserve loan will be likewise Bal one. That's the amount of token one inside this contract.
00:23:50.610 - 00:24:33.246, Speaker A: Before we transfer out token one, the amount that is going to be transferred out is amount one. So bow one minus amount one. Once we update the reserves, let's finally transfer the tokens to the user. So I'll type token zero, dot transfer to message sender. The amount will be amount zero, and likewise for token one. Token one transferred to message sender amount one, and that completes the function for remove liquidity. And we now have a minimal example of a constant product amm.
00:24:33.246 - 00:25:03.594, Speaker A: Let's deploy this contract and call the functions. Add liquidity, swap, and then remove liquidity. I've copied the code for ERC 20 from the Internet and then deployed the two tokens, token zero and token one. I've also minted 1000 token for both token zero and token one. To user zero and user one. We'll say that user zero is the liquidity provider. This will be the user that's going to be calling the function add liquidity and remove liquidity.
00:25:03.594 - 00:25:41.370, Speaker A: Remember, we'll say that user two is a trader. So this user will be calling the function swap. So first user one will add liquidity to the constant product amm. I have not deployed this contract yet, so let's deploy the contract. This contract takes in two parameters, token zero and token one, which I've deployed over here. So I'll copy the addresses, paste it, and then deploy the contract. So once constant product AMM is deployed, user zero, user one will add liquidity to this constant product AmM.
00:25:41.370 - 00:26:48.366, Speaker A: User One has both token zero and token one balance of 1000 which I've already minted. To add liquidity, user one will have to approve the constant product AMM to pull in the tokens so it will approve constant product AMM for the amount 1000, and likewise for token one. User one approves constant product AMM for the amount 1000 and then user one adds liquidity for the amount. Let's say token zero is 1000 and token one is 500, and then hit transact. Add liquidity was successful. So if we check the shares of user zero, I'll copy the address of user zero and then check balance of this will be greater than zero. User One has 707 shares reserve zero.
00:26:48.366 - 00:27:45.854, Speaker A: That will be token zero, amount is 1000 and reserve one is 500. Next, we'll switch to user two, and this user will call the function swap to trade token zero for token one. So the first thing that this user will have to do is approve the constant product AMM. To spend token zero, we'll reuse the inputs that we passed in previously. So spender will be constant product amm for the amount, let's say 100. User two will be spending 100 of token zero and then getting back some token one. So let's call the function swap, scroll down, and then we'll call the swap token name will be token zero, paste it here and amount 100, and then call the function transact, and the function is successful.
00:27:45.854 - 00:28:38.050, Speaker A: So if we check the balance of token one for user two, I'll scroll up, copy the address of user two, scroll back down to token one, and then click on balance up. Before we call this function, I minted 1000 token one. After the trade, this balance up should be greater than 1000 and it is 1045. And lastly, we'll switch back to user one and then remove liquidity. I'll scroll down and then user one will call remove liquidity. How much share does user one have? User one has 707 shares. So I'll copy this and then paste it here and then call remove liquidity.
00:28:38.050 - 00:29:04.700, Speaker A: And the function is successful. So if I check the balance of user one, this will be the amount of shares that the user one has in the constant product amm. It is now equal to zero reserve zero. How much do we have? It's zero reserve one. Also zero. And now let's check the balance of token zero and token one for user zero. Sorry, for user one.
00:29:04.700 - 00:29:46.302, Speaker A: So token one, I'll copy the address of user one and then we'll check the balance of user one. I've minted 1000 token of token zero to user one. User two traded 100 token zero for token one. So that is why you see an extra 100 over here. Let's check the balance of token one for user one. I paste the address of user one again and then call balance of 955. Before adding liquidity, I minted 1000 tokens to user one.
00:29:46.302 - 00:30:00.860, Speaker A: And now this user has less than 1000. The amount that decreased was given to user two during the trade. So that is why you see less than 1000 over here. And that completes the demo for the constant product Amm. Thank.
