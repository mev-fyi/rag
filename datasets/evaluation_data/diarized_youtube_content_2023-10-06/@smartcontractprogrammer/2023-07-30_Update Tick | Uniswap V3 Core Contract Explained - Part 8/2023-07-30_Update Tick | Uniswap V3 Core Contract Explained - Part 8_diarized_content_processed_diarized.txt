00:00:00.250 - 00:00:33.254, Speaker A: We started working on the function mint. This function calls an internal function called modify position. The function modify position calls another internal function called update position. Inside the function update position there are some code that updates the ticks. So today we'll be working on ticks update and ticks. Clear inside our code I'll declare a state variable called ticks and this will be a mapping from int 24 to a struct called tick info. We have not defined a struct yet so we'll do that later.
00:00:33.254 - 00:01:10.530, Speaker A: This will be public and then I'll name it ticks. Int 24 will be a tick and then from here it maps to some kind of data that stores the information at this tick. Okay, let's go define a struct called tick info. Inside my viv click on tick and inside here we'll create a struct struct info and what information do we need to store here? Let's go to the unisoft b three code to find out what data we need to store inside here. Here's the code inside unisoft b three. I'll copy all this code and then paste it over to our code. Here's a code that's copied over from unisoft B three.
00:01:10.530 - 00:01:41.418, Speaker A: Okay, let's go one by one. Liquidity growth this will be the total liquidity inside this tick. Liquidity net is the amount of liquidity that needs to be added or removed when this tick becomes active. Fee growth outside zero x one two eight and fee growth outside one x one two eight. These are data that is needed to calculate the fees tick cumulative outside and the next two data are data related to the price oracle. So we won't need these. And Boolean initialized whether this tick is initialized or not.
00:01:41.418 - 00:02:12.930, Speaker A: Okay, so this is the struct that we're going to need. Let's go back to our clam contract, make sure that we have tick imported. Scroll up and we have tick imported. Okay, next let's add this library to our clam contract. So here I'll say using tick for the mapping which we've declared over here. So I'll just copy this then paste it here for the mapping from int 24 to tick info. Next let's actually implement the functions that we need inside the tick contract.
00:02:12.930 - 00:02:40.720, Speaker A: So first I'm going to go back to the unison b three pull contract. And what are the functions that we're going to be calling? The first function that we're going to be calling is called ticks update. And the other function that we're going to be calling is called ticks. Clear. Let's take a look at what these function do. So I'm going to open tick sol inside unison b three code and look for a function called update. And then I'll copy this function signature over to our code.
00:02:40.720 - 00:03:12.362, Speaker A: Okay, here's the function update. The first input is going to take in the state variable from int 24 to tick info inside our clam contract we declare this, we name this state variable as ticks. So here we're going to pass in the state variable ticks. Okay, next parameter is a tick, the tick that we're going to be updating. Next one is the current tick. This will be stored in slot zero liquidity delta. Some variables that are related to the fees and the next three parameters we're not going to need it.
00:03:12.362 - 00:03:48.270, Speaker A: These are parameters that's related to the price oracle. The next variable, upper, means whether the tick is an upper tick or a lower tick, and max liquidity. And what does it return? It returns a boolean called flipped. Flipped means that this will be true when the liquidity gets activated or deactivated. Otherwise it will return false. If liquidity is equal to zero and after we call the function update, liquidity becomes greater than zero, then flipped will be equal to true. Another case where the flipped will be true is if liquidity is greater than zero and after calling the function update, liquidity is equal to zero.
00:03:48.270 - 00:04:26.494, Speaker A: So these are the two cases when this boolean flipped will return true. Okay, the first thing that we'll do is load the tick into memory. So say info memory, I'll name it, info is equal to self. This will be a state variable at the tick. Next we'll store the liquidity growth before and after into a local variable, say un one to eight liquidity growth before this will be stored in info liquidity growth and then also liquidity growth after. This will be the previous liquidity. So this will be stored in liquidity growth before plus liquidity delta.
00:04:26.494 - 00:05:04.618, Speaker A: Now liquidity delta is int one to eight. However, liquidity growth before is u int one to eight. So we'll have to either add or subtract depending on whether liquidity delta is positive or negative. So I'll say liquidity delta is less than zero. If liquidity delta is less than zero, then liquidity gross after will be liquidity gross before minus cast liquidity delta into UN 28. Since this is negative, we'll need to bring it to positive first. So say minus liquidity delta otherwise liquidity gross before plus cast liquidity delta which is not negative.
00:05:04.618 - 00:05:26.350, Speaker A: Cast it into un one to eight. Okay, next, we'll check that liquidity growth after is less than or equal to max liquidity. So here I'll say require liquidity growth after should be less than or equal to max. Liquidity. Error message. Liquidity greater than max. Okay, the next thing that we'll do is compute whether this liquidity has been flipped.
00:05:26.350 - 00:05:48.746, Speaker A: Again, we return true for flipped. If liquidity has been activated or it has been deactivated. For liquidity to be activated, it means that liquidity growth before was equal to zero. And liquidity growth after is greater than zero. For liquidity to become deactivated, it's the opposite. Liquidity gross before was greater than zero. And liquidity gross after is equal to zero.
00:05:48.746 - 00:06:13.106, Speaker A: Now, if you take a look at the tick sol inside unison v three code. It does this confusing check to calculate flipped. So what I'm going to do is copy this. And then I'm going to explain how this code is exactly the same as this situation. So here's the code from unison B three. And here is the condition for being flipped. Let's see how these two code does exactly the same thing.
00:06:13.106 - 00:06:43.210, Speaker A: If this part is true, then we are looking at this case, liquidity gross after is equal to true. And in that case, liquidity growth before must be greater than zero. Which is exactly the same as saying liquidity growth before equal to zero. This part should evaluate to false. We have this part evaluating true and this part evaluating to false. So in this case, flipped will be equal to true. Likewise, if liquidity growth after is equal to true returns false.
00:06:43.210 - 00:07:03.246, Speaker A: Then we are looking at this case. In that case, liquidity growth before must be equal to true. Which is this case. This part will be equal to true. And this part will be equal to false. And again, flipped will evaluate to true. So this code over here is a concise way to express this condition.
00:07:03.246 - 00:07:20.118, Speaker A: Okay, let's move on. What do we have to do next? So, going back to tick. So inside unisoft v three code. The next part of the code that I'll explain is this part. If liquidity growth is equal to zero. For now, we'll ignore this part. This part of the code relates to calculating the fees.
00:07:20.118 - 00:07:59.318, Speaker A: Then set info initialize equal to true. Okay, let's write this part of the code into our contract. If liquidity growth before is equal to zero, then set info initialize equal to true. Okay, what's the next part? Going back to unisoft B three code. So it looks like we update liquidity gross to liquidity. Gross after okay, let's also do that inside our code say info liquidity gross is equal to liquidity gross after okay going back to unisoft B three call. Again, the last part is setting liquidity net.
00:07:59.318 - 00:08:45.298, Speaker A: If it is an upper tick, then we subtract liquidity delta from liquidity net. Otherwise, then we add liquidity delta to liquidity net. Going back to our code, here's a brief explanation of what the code does. As the price moves from left to right to the current liquidity, we'll add liquidity net. So let's say that the current price is over here below the lower tick and then as the price moves from left to right, this tick will become active. So to the current liquidity we add this positive number, liquidity net and as the price further moves from left to right the upper tick will become deactivated and at that point we minus liquidity net from the current liquidity. A similar situation happens when the price moves from right to left.
00:08:45.298 - 00:09:18.766, Speaker A: When the current tick crosses the upper tick moving from right to left, the liquidity net that is stored here is negative. So to this liquidity net we minus minus minus becomes a positive. So we're adding liquidity to the current liquidity and as the price moves further to the left, the current tick will cross the lower tick. Here the liquidity net that is stored is positive and we do a minus. So this will decrease the current liquidity by whatever value that is stored inside liquidity net. For the lower tick. I'll explain how all of this works in another video.
00:09:18.766 - 00:10:01.350, Speaker A: So moving on, let's write the code so say info liquidity net is equal to if it is an upper tick then we store the negative. If it is a lower tick we store the positive. If it is an upper tick then to info liquidity net we minus this so say minus liquidity delta. Otherwise we say info liquidity net plus liquidity delta. Okay and that completes the function update. Next let's write the function clear. So I'm going to open the ticks library inside unisoft b three and all it does is it's going to take in a mapping from int 24 to tick info.
00:10:01.350 - 00:10:51.886, Speaker A: This will be our state variable ticks. It's also going to take in the tick to clear and all it does is delete this state variable. So inside our code I'll say function clear we'll take in a mapping from int 24 to info. This will be a storage I'll name it self and it's also going to take the tick to delete int 24 tick. This function will be internal and what we do is delete self of tick info going back up. Okay, that completes the function clear and update inside the library tick let's go back to unisoft b three pull contract, and next thing that we'll need to do is call those functions update and clear. Okay, let's work on this part of the code first.
00:10:51.886 - 00:11:59.678, Speaker A: So first we declare two boolean variables called flipped lower and flipped upper. Okay, I'll do that inside my code as well, so I'll just copy this, then paste it here. Next we'll need to call tickstock update if liquidity delta is not equal to zero. So if liquidity delta is not equal to zero, you'll need to call ticks update and what are the parameters that we'll need to pass ticks update the parameters that we'll need to pass is tick lower tick lower current tick liquidity delta fee growth global zero x one two eight, and fee growth global one x one two eight. The next three parameters are parameters for the price oracle, so we'll ignore them. And this is a lower tick so we'll pass in false, and the max liquidity pre tick calling the function ticks update will return a boolean whether this tick, this lower tick, was flipped or not. So say flipped lower is equal to okay, what's next? We'll do the same for the upper tick, so copy this, paste it here, rename this variable to flipped upper.
00:11:59.678 - 00:12:36.714, Speaker A: The tick that we're updating is tick upper, and then the other parameter that I'll change is this is an upper tick, so I'll change this to true. Okay, what's next? If tick is flipped, then it calls tick bitmap. We'll skip this for now. And what's next? The next part is calculates the fee and then updates position. Update position. We have the code over here, and the last part is this part of the code. If liquidity delta is less than zero, then this means that liquidity was removed, and if the boolean values were flipped, so this means that the liquidity was removed and the lower tick was flipped.
00:12:36.714 - 00:13:27.146, Speaker A: This means that this tick's liquidity is now equal to zero. So we can remove this tick. So say if flipped lower, then clear this tick ticks clear tick lower, and we'll do the same for the upper tick. If flipped upper, then ticks clear tick upper okay, that completes the function update position for now. Let's try compiling the contract. I'll open my terminal and then type forge build, and our contract compiled in this video, we've completed the update function, except for calculating the fees, which will be the last part of the video series. Now, writing the code inside the update position, we wrote some code inside ticks update and if we take a look at this function tix update, we came across a term called liquidity.
00:13:27.146 - 00:13:38.700, Speaker A: Net. This is a variable that is used to track the current liquidity. In the next few videos, I'll explain how liquidity. Net is used to keep track of the current liquidity. Thanks for watching. See you in the next video.
