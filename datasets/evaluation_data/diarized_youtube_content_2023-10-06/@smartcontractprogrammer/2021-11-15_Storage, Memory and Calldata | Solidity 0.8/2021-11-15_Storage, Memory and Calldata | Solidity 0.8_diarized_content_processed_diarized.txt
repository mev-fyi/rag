00:00:00.330 - 00:00:44.890, Speaker A: When we use a dynamic data type as a variable, we need to declare its data location storage memory and call data storage means that the variable is a state variable. Memory means that the data is loaded onto memory. Call data is like memory, except it can only be used for function inputs. Let's take a look at examples of each of these. For this example, I'll be using a struct called mystruct, and with the mapping from address to my struct we'll be getting data from this mystruct. So I've already inserted one mystruct into the mapping. Now you've already seen that to modify a struct, the first thing that you can do is to declare mystruct followed by storage and then declaring the variable name.
00:00:44.890 - 00:01:27.142, Speaker A: Here I am getting the mystruct struct from the mapping mystructs that is stored at message sender. And I am telling solidity that the variable that I am about to use should point back to the storage meaning the state variable. You would declare a struct as storage when you want to modify the struct. So for example, we'll modify mystruct text by typing. My struct text is equal to foo when we execute this function. Examples, it will update the mystruct text to foo. Now if you just wanted to read mystruct, we don't need to update it, we just want to get some data out of it.
00:01:27.142 - 00:02:06.738, Speaker A: Then instead you can replace this with memory. We'll copy this line of code and then change the keyword storage to memory. And then I'll also change the variable name to, say read only. This will build my struct store message sender to memory and you can also modify this variable. So for example, say readonly, foo is equal to one, two, three. Actually, I'll change this to four, five, six so we can modify the struct. But since the data is loaded onto memory, once the function is done executing, this change will not be saved.
00:02:06.738 - 00:02:54.366, Speaker A: So use storage to update data and use memory to read the data. Now when you're writing a function both for input and outputs, you'll see the keyword memory and call data being used. So for example, we can pass in a Uint array as input by typing Un brackets. So this is an array of un and then we need to declare the data location. We'll start off by saying that this data location is memory and I'll call this input y. Let's take a look at another example for the input we can pass in a string and again I'll declare this data location as memory and then I'll name this input s. Likewise, we can also return a dynamic data type and in that case we'll need to declare the return type as memory.
00:02:54.366 - 00:03:39.390, Speaker A: If we wanted to return this array, then we will say return parentheses, my struct and the data location is memory. And over here we'll say return read only another example. Let's say that I wanted to return a Un array. Then over here I would type un bracket and then type memory. I'll remove this return statement and then we will need to return a Un array. We can return this array from input, but just to make this example a little bit more interesting, we'll initialize a un array in memory and then return it. We'll initialize an array of Un in memory by typing un brackets memory.
00:03:39.390 - 00:04:22.686, Speaker A: We're declaring that this array will be loaded onto memory. And I'll name this array mem r, short for array in memory equals to new un brackets parentheses. For arrays that are initialized in memory, we can only create a fixed size array. We cannot create a dynamic array. So I'll declare this fixed sized array as having the size three. Once the array is initialized in memory, this array has three elements since it is a fixed size of three. So for example, let's update the first element by typing mem r of zero is equal to two thick bar.
00:04:22.686 - 00:04:52.758, Speaker A: And lastly we'll return this array in memory by typing return mem R. I made a mistake over here, so I'll change this return to returned. So this is how you initialize an array in memory. The syntax is a little bit tricky, but you'll get used to it. For the last example, let me explain what call data is. Call data is like memory, except that you can use for function inputs. And why would you want to use for function inputs? Well, it has a potential to save gas.
00:04:52.758 - 00:05:47.126, Speaker A: Let's take a look. So we'll replace the inputs, memory and memory over here to call data, call data and also for the string call data. Now, since data type declared as call data is non modifiable, meaning that we cannot change the values inside it, it can save gas when you pass this input into another function. For example, I've declared another function called internal and it takes in the Un array from the input over here. Take the input y and then pass it into the function internal. Now if this input was declared as memory, then what solidity would do is take this input and when it passes on to this function then it's going to copy each element in this un array, so it will be creating a new un array inside the memory and then pass it onto here. However, if we declare this input as call data, then there is less one copying to do.
00:05:47.126 - 00:06:14.250, Speaker A: It takes the y from the input and passes it to the internal function without copying it, so that is how it saves gas. In summary, use storage to those dynamic data that you will update. If you only need to read the data or modify it without saving it onto the blockchain, then you can use memory. And then for function inputs, use call data to save gas. Whenever this input is passed to another function, it saves gas by avoiding copies.
