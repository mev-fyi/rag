00:00:00.410 - 00:00:55.790, Speaker A: What are function modifiers? In this video I'm going to explain what function modifiers are, show you how to write a function modifier, and explain why they are useful. Function modifiers are reusable code that can be attached to a function. This reusable code can be executed before and or after the function is executed. You you we'll go over three examples in remix. In the first example, we'll go over the basic syntax for writing a function modifier, and we'll create a function modifier to restrict write access to a function. In the second example, I'll go over the syntax for passing parameters into a function modifier, and we'll create a function modifier for input validation. At this point, I'll also explain why a function modifier is useful.
00:00:55.790 - 00:01:34.278, Speaker A: For the third example, I'll quickly explain what a reentrancy hack is, and we'll write a function modifier to prevent this hack. Here we have a contract. When this contract is deployed, it sets the owner variable to message sender. Message sender is the sender of the transaction, so in this case it will be the sender of this transaction that deployed this contract. Inside a contract we have a function called changeowner. Change owner takes in the address of the new owner as input. Inside this function, it first calls the function only owner.
00:01:34.278 - 00:02:22.150, Speaker A: The function only owner checks that message sender is equal to the current owner. If it is not equal to the current owner, then this function throws an error and the transaction fails. Next, the function valid address checks that the new owner is not equal to the zero address if it is equal to the zero address. Again, this function throws an error and the transaction fails. Once the two functions execute without any errors, the current owner is set to the new owner. Let's go over how we will use function modifiers to restrict write access only to the current owner, and how we will use a function modifier to validate the address of the new owner. First, we'll turn the function only owner into a function modifier.
00:02:22.150 - 00:03:28.386, Speaker A: So replace the keyword function with the keyword modifier and remove the keyword public. We won't need to modify the code that checks that the sender of the transaction is equal to the owner, so we won't modify this part of the code. On the next line, type an underscore and followed by a semicolon. The underscore is a special character that you can only use inside the function modifier, and it tells solidity to execute the rest of the code. So once this modifier is attached to the function change owner. This underscore would tell solidity to execute the code inside the function, and you can attach a function modifier to a function by declaring the modifier in the function signature and go ahead and delete the function only owner, since we rewrote it as a function modifier. Next, let's go over how to pass parameters into a function modifier.
00:03:28.386 - 00:04:34.948, Speaker A: First, replace the keyword function with the keyword modifier, and also remove the keyword public. We won't need to change the code for input validation on the next line type underscore followed by a semicolon. So here again we're telling solidity to execute the rest of the code, and we can attach the function modifier by declaring it in the function signature, and you can pass parameters into a function modifier the same way that you would in a function. Finally, go ahead and delete the function valid address. Since we turn that function into a function modifier, function modifiers can make your code more readable. Here is the function change owner before we use the function modifier inside the function, we do some validations before we update the owner to the new owner. We moved the validation that was done inside the function into the function signature using a function modifier.
00:04:34.948 - 00:05:19.092, Speaker A: We made our intent clear on who can call this function and what kind of inputs are allowed into this function. So now let's cover the third example, reentrancy hack, and let's see how a function modifier can prevent this attack. First, let's talk about what a reentrancy hack is. Imagine there are two contracts, contract a and contract b. A function f inside contract a is called inside the function. It calls a function inside contract b, and contract b calls back into the function f. The function f inside contract a starts executing its code before the previous call to the function completes.
00:05:19.092 - 00:05:59.796, Speaker A: It calls function g and contract b again, and function g calls back into function f, and this can continue indefinitely using this hack. Millions of dollars were stolen in a future video. I'll go over this in more details. So how can we prevent this from happening? We can guard against this hack by preventing a function to be called while it is still executing. First, let's see an example of a function that can be called while it is still executing. Here we have a function called decrement. Decrement takes an integer variable named I, and it decrements the state variable x by I.
00:05:59.796 - 00:06:34.784, Speaker A: If I is still greater than one, it calls back into itself with I minus one. So let's see what happens with the function decrement when we pass in three as input. On the top you see the current value of the state variable x, which is ten. On the right you'll see a stack of functions that are called and have not finished executing. It decrements the state variable x by three. So now the value of x is seven. Since three is greater than one, we call decrement again with three minus one.
00:06:34.784 - 00:07:21.730, Speaker A: So the function decrement with the input two is called. It decrements the state variable x by two, and since two is greater than one, we call decrement with two minus one. We again decrement the state variable x by one. So now the current value of x is equal to four. Since one is not greater than one, decrement is not called, and decrement one finished executing, so we'll remove it from the stack of function calls. Now decrement two's execution is also finished, so we also remove it from the stack of function calls. And finally, decrement three finished its execution, and we are left with the state variable x equals four.
00:07:21.730 - 00:08:04.690, Speaker A: So now let's see what would happen if we had a function modifier that prevented recursive calls. We'll create a modifier called no reentrancy. Inside the modifier, we first check that the boolean variable locked is set to false. Next we set it to true and then call the function. And then after the function, we set it back to false. Finally, we attach this modifier to the function decrement. Let's go over how this modifier would prevent a recursive call.
00:08:04.690 - 00:08:53.660, Speaker A: First, the state variable locked is set to false. When the function decrement is called, it first sets the lock to true, and it starts executing its code, and it calls itself again with three minus one. But now, since locked is equal to true, the required statement fails and the transaction fails. In this video we talked about function modifiers. Function modifiers are reusable code that can be run before and or after a function. Some common use cases of function modifiers are to restrict write access for input validation and for reentrancy guard. In a future video, we'll revisit the reentrancy hack in more details, so stay tuned.
00:08:53.660 - 00:08:58.080, Speaker A: Thank you, you so much for watching, and I'll see you soon. Bye.
