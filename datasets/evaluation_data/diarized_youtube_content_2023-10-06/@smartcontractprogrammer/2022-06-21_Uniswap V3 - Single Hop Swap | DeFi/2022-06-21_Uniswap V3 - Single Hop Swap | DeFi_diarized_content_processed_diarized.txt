00:00:00.170 - 00:00:32.854, Speaker A: Today I'll show you how to do a swap on uniswap b three using solidity. Now, Uniswap allows you to do either a single hop or a multihop trade. A single hop is a trade where it trades from one token to another token, for example, from Eth to Dai. A multi hop trade involves several tokens, for example from E to Dai, and then from Dai to USDC. In this video, I'll show you how to do a single hop trade. I'll be following the official documentation, so let's get started. So the first thing that we need to do is set up the project.
00:00:32.854 - 00:01:07.860, Speaker A: So I'll scroll down then. Looks like we'll need to do an NPM init. I've created an empty folder called Unib three and we'll initialize the NPm package by typing npm init y. This will create a package json and we're now ready to install some NPm packages. What are the packages that we need to install? Back inside the documentation, I'll scroll down and we'll need to install hardhat. I'll copy this command, and then back inside the terminal I'll paste the command. This will install hardhat into this project.
00:01:07.860 - 00:01:42.286, Speaker A: Once hardhat is installed, let's go back to the documentation to see what the next step is. After installing hard hat, the next step is to install the unisoft b three periphery npm package. This will contain the unisoft b three interfaces so that we can write solidity to interact with it. So I'll copy the command, and then back inside the terminal I'll paste the command to install the unison b three library. Okay, that's done. Let's move on. The next step is to initialize a hard hat project.
00:01:42.286 - 00:02:13.286, Speaker A: I'll do that by typing inside my terminal mpx hard hat. And then we'll initialize a simple hard hat project. So I'll hit enter, enter hit yes, and then hit yes again. The hard hat project is initialized. Let's move on and see what the next step is. So back inside the Unisop official documentation, it says to set the solidity version to 0.7.6. This is because UnisOP B three is written in 0.7.6
00:02:13.286 - 00:02:53.138, Speaker A: and the UnisoP interface that we just installed over here is also solidity 0.7.6. So we'll initialize our project to be solidity 0.7.6. Back inside my code editor, I'll open hardhat config JS and then paste the solidity version to be 0.7.6 and remove the default 0.8.4. Now let's try compiling the contract. So the first thing that I'll do is change the compiler version for the default contract. So I'll change this to 0.7.6
00:02:53.138 - 00:03:37.026, Speaker A: and let's try compiling the contract. So I'll put in the terminal, then type MpX hard hat compile okay, the contract compiled successfully. So let's move on for the next step. We'll copy the code from the official documentation on their single swaps and we'll try out the two functions. Swap exact input single and swap exact output single. So I'll scroll all the way down to copy this contract. Copy it and inside my contracts folder I'll create a new solidity file called swap examples sol and then paste the code that we just copied and we'll change some of the code.
00:03:37.026 - 00:04:13.706, Speaker A: So first I know where the address of the swap router is. So I'll change this from immutable to a constant. Back inside the uniswap documentation, I'll click on the navigator and scroll down and look for a submenu called deployment addresses. And I'm looking for the address of swap router. I'll scroll down, actually I'll hit ctrl f and then search for router. And I'm going to copy this address. Swap router now don't copy the address of swap router two because this has a different interface from swap router.
00:04:13.706 - 00:04:55.462, Speaker A: So the example will only work for swap router and not swap router geltip. So copy the address of swap router back inside the code. We will make iswap router a constant and it will be equal to swap router iswaprouter at the address that we just copied and then we'll remove this constructor. Okay, next let's take a look at the example. Swap exact input single. This function will take in all of the amounts of token that we specify for the input amount in and then swapped it to another token. Now, the default example of the documentation swaps from Dai to ETH.
00:04:55.462 - 00:05:35.958, Speaker A: But for our purpose we'll swap from Eth to Dai. And I do this because when we initialize accounts inside the test we already have some free eth, whereas dai we don't. So to make our example simple, we'll swap from e to die. The first thing that I'll do is change safe transfer from die to wef nine. If I scroll up, wef nine is defined over here. So we'll transfer wef nine into this contract, and then we'll approve wef nine to be spent by uniswap b three. So next we'll need to prepare our input to be passed to uniswap b three.
00:05:35.958 - 00:06:09.394, Speaker A: The default example takes in die as token in and weft nine as token out. But for this example, we'll be swapping from wef to die. So we'll switch things around. Token in will be wef nine and token out will be die, and the rest of the parameters are the same. Now, notice that we have this mysterious setting called square price limit x 96. When we do a trade on unisop, it pushes the price up of the token that we're buying. So this setting allows you to set the limit for the price.
00:06:09.394 - 00:06:42.502, Speaker A: But for this example, we'll keep it simple and just disable this by setting square price limit to zero. And then lastly we'll call exact input single passing in the parameter that we just prepared and then calling the uniswap b three router. So this is the part of the code that does the actual trade. Okay, let's try running this function. When we call this, it will swap from wef to die. So first thing that I'll do is open my terminal and try compiling contract by typing mpex hard hat compile. Okay, the contract compiled successfully.
00:06:42.502 - 00:07:23.098, Speaker A: So the next thing that we'll do is write the test that will execute this function on the main network. So the first thing that I'll do is configure hardhat config to run on main net fork. So I'll paste this configuration network hardhat forking and URL set to this URL that you can copy from alchemyapi IO. To get your own API key, log in or sign up to alchemyapi IO. And once you're in, create a new project and then click on view key. And this is the URL that I copied. So once we've configured hirehat test to run on the main network, the next thing that we'll do is write the test.
00:07:23.098 - 00:08:12.790, Speaker A: So I'll open my file navigators and inside test I'll rename sample test js to swap test js and then open it. Now so far we have a default test for the gleeter contract, and we'll modify this to test our first example. Swap exact input single. So first I'll change the titles of the test. So I'll call this swap examples and this test I'll rename it to swap exact input single. Then I'll remove this part of the test and we'll name the contract that we're going to be deploying from greeter to swap examples. The constructor of swap example takes in no constructor argument.
00:08:12.790 - 00:08:55.474, Speaker A: So I'll remove this constructor argument and then rename the greeter contract to. So once the contract is deployed, the first thing that we'll do is get the accounts that will be testing the functions. So I'll say const accounts is equal to await ethers, get signers. By calling this function we'll get some accounts which will be able to call the functions on the swap example contract and it will have also some eth. So we can easily test the trade from eth to die. Now if you go back to the contract, you can see that we are pulling in wef nine and then getting die back. So back inside our test file, let's initialize wef and die.
00:08:55.474 - 00:09:43.650, Speaker A: To do that, we'll first copy the addresses of wef die. I'll copy the addresses and then paste it in the test file and change the solidity code to javascript code. Once we have the addresses for the contract, die and wef, we'll initialize these contracts. To initialize these contract, I'm going to need the interface for die and with nine, the interface for IERC 20 is included in the Unisop package that we installed. So the only thing that you'll have to do is declare an interface for web nine. So I'll open the file navigator contracts, and then I'll create a new folder called interfaces. And then inside here I'll declare a new interface called IweF soul, and then I'll copy this interface that I got from the Internet.
00:09:43.650 - 00:10:43.270, Speaker A: Wef nine extends iERC 20. So these are all functions from ERC 20, and on top of that wef nine has a function called deposit which is payable, and a function called withdrawal. Okay, so back inside the test we'll initialize die and weft nine. So I'll say Const die is equal to awaite ethers, get contract at the name of the interface that we're going to be loading IERC 20 and then followed by the address this will be die, which we defined over here. We'll do something similar for wef as well. So say const wef await ethers, get contract at Iwef, which we define over here, and then the address of wef will be wef nine. These two command will load wef and die at these contract addresses.
00:10:43.270 - 00:11:51.280, Speaker A: We deploy the swap contract and we're now ready to call the function swap exact input single we're going to be trading wef for die, so we'll need to convert our e into wef. Let's say that we're going to put one e, so I'll say const amount in is equal to ten to the n times 18 to the n. Now, Javascript doesn't support big numbers, but however it can support big numbers. It's called big int by appending an n to the numbers. So we'll say amount in is ten to the n raised to the power of 18 to the n. We'll deposit eth by typing await weft deposit and then pass in the amount of eth to deposit by doing curly braces. Value amount in next, we'll approve this contract to be able to pull our one e into the contract by typing await wef approve the contract that we're approving is swap examples address for the amount amount in and just to be clear that we're calling these two functions from account one.
00:11:51.280 - 00:13:00.962, Speaker A: I'll say connect accounts zero dot and then call the rest of the function. Disconnect means we're calling the deposit function from accounts zero, and likewise we're calling approve function from account zero. The next step is to execute swap exact input single so I'll type await swap examples swap exact input single the amount of eth that we're trading is amount in and after the trade is done we'll console log the amount of die that we got back. By typing console log. I'll say die balance of will be of account zero. So I'll type die await die balance of account zero address again, we're trading from e to die by first converting our e to wef and then putting our wef to be converted into die. Before the trade we have zero die, but after the trade we should have some die.
00:13:00.962 - 00:13:52.434, Speaker A: Let's run the test. So I'll open my terminal and then I'll clear the logs, and then I'll run the test by typing mpx hard hat test test swap test js and the test executed successfully and you can see that our die balance is something greater than zero. The account has zero die. After the trade we have some die. For the next example, I'll show you how to call the function swap exact output single this is an example where it tries to get the exact amount out specified in the input amount out, and the maximum amount in that it will take in is amount in maximum. In other words, it would try to sell the minimum amount of token in to get amount out. Again, the default code example swaps from die to wef, but for our example, we'll swap from wef to die.
00:13:52.434 - 00:14:51.610, Speaker A: So we'll first pull in wef and then we'll approve wef to be spent by the unisoft b three router. So token in will be wef and token out will be die. Sorry, wef nine, wef nine, and weft nine over here. Once the parameters are prepared, we can call the function swap router exact output single passing in the params, this function will return the amount of token in that was spent to get the amount out of token out. But notice that over here we transferred amount in maximum. So if the amount in is less than amount in maximum that is locked inside the contract, we'll need to refund the difference back to message sender. We pulled in Wef, so the first thing that we'll do is reset the approval on uniswap b three router.
00:14:51.610 - 00:15:29.606, Speaker A: So I'll change die to ref nine. This code over here is resetting the approval for ref nine on swap router to zero, and then we'll refund the difference to message sender. Change this to left night. Let's try compiling this contract. Open the terminal and then type mpx hard hat compile and the code compiles. So let's now write a test and try executing the function swap exact output single back in the test file. I'll copy this, then paste it here.
00:15:29.606 - 00:16:09.966, Speaker A: We'll rename this to swap exact output single and notice that we have some redundant code from here and over here. So I'll remove some of the repeated code. We'll move this part of the code to the initialization process before we execute these two tests. So I'll copy this. Actually, I'll just cop the code out and then paste the code inside the before block. So I'll type before async and then paste the code. We will declare the variables accounts wef and die, and then reassign the variables inside the before block.
00:16:09.966 - 00:17:05.006, Speaker A: This before block is some initialization code that runs before any of the test runs, and we also declare the swap contract that swap examples and then instead of using const, we'll reassign it to this variable that we declared over here. And now we can remove this part of the code. For this example of calling swap exact output single, we'll do a trade where we will send one e and we'll try to get 100 die. So one e will be sent that will be converted to 100 die and whatever weft that was not spent will be refunded back to us. So I'll rename amount in to wef amount in max. This is the amount of weft that we will be sending to swap examples, and it will be the maximum amount of weft that will be used by uniswap. B three how much die are we trying to buy? We'll say we'll try to buy 100 die.
00:17:05.006 - 00:17:46.194, Speaker A: So I'll say const die amount out is equal to 100 n times ten to the n to the power of 18 to the n. We'll deposit the e and then convert it to f. So say wef amount in max. Wef amount in max. And the function that we're calling is swap exact output single. The function swap exact, output single, takes in two parameters, the amount of die that we want and the amount of e that we're willing to spend. So two parameters, amount of die we want, die amount out.
00:17:46.194 - 00:18:20.300, Speaker A: This will be 100 die, maximum amount of eth that we're willing to spend. That will be one e with amount in max. And that's the after the trade, we should have 100 die in this account. Now, before we run test, I know that this test passed, so for this example, I'll just comment it out and then run this example. Swap exact, output single. Let's run the test, open the terminal, and then we'll run the test again and our test passed. And notice that we got right back.
