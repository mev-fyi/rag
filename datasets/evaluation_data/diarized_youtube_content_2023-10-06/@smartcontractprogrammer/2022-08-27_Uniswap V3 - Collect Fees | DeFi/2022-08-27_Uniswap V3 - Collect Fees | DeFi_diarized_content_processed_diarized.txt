00:00:00.170 - 00:00:27.334, Speaker A: Today we'll take a look at how to collect fees on unisoft B three. So inside the official documentation, the first thing that I'll do is scroll down and copy the sample code. So I'll scroll down and copy this part of the code. I'll click on the copy button and copy the code back. Inside the code editor we have some code from the previous video where we did some demo of minting new liquidity. We'll paste our code inside this contract. So I'll scroll all the way down and then paste the code.
00:00:27.334 - 00:01:23.606, Speaker A: And then I'll remove the comments. Okay, once the code is copied, let's now modify this code so that we'll be able to run this example with our example contract. When we run our example, we first need to mint new position and get the token id. So first I'll declare a state variable up top and then I'll call it un public token id. And for this example, the first thing that we'll do is call the function mint new position to mint a new position and receive a token id. When we call this function, if we scroll down, you can see here that we're calling an internal function called create deposit passing in the token id. So inside here I'll assign the token id to the state variable, saying token id is equal to token id.
00:01:23.606 - 00:01:55.162, Speaker A: Now notice that both the state variable and the input have the same name. So let's change the input to underscore token id. So I'll change this to underscore token id. Then I'll do the same for the rest of the inputs. Okay, I think we're done and we can now modify the code to collect fees from unison b three. Since when we call the function mint new position, we are assigning the token id to a state variable so we won't have to pass it as an input inside to this function. So I'll remove it from the input.
00:01:55.162 - 00:02:23.270, Speaker A: Also for this example, the owner of the token id is this contract. So we won't have to transfer the token id into this contract from message sender. So I'll remove this code. So the first part of the code example, we see that we prepare some kind of param to be passed to unisop b three and then calling a function collect. Here we're saying that we're collecting the fee for token ID. Recipient is this contract. And here we see two parameters, amount zero max and amount one max.
00:02:23.270 - 00:03:16.986, Speaker A: What are these inputs used for? Looking at the code inside uniswap b three, it looks like amount zero max and amount one max are used to put a cap on the amount of fees that you collect. So back inside of code what this part of code means that for token zero, we're telling uniswap to collect all fees by saying amount zero max equals to max of un 128. And likewise for amount one max, we are telling uniswap to collect all fees for token one. Okay, once we prepare the parameters, we can collect the fees by calling the function collect on the nonfungible position manager passing in the params, and in return we get amount zero and amount one back. These are the amount of fees that we collected. Now send to owner is an internal function that we copied over from the official documentation of unisoft B three. However, we won't be sending tokens to anyone.
00:03:16.986 - 00:03:54.882, Speaker A: For this example, we'll just log the amount of fees that we collected inside this contract. So I'll type console log fee zero, amount zero, and likewise for amount one, fee one, amount one. Okay, that completes the contract. Let's try compiling this contract. I'll open my terminal and then type Mpx hard hat compile. Okay, I see a warning that I want to fix. So on line 39 I declared a local variable called token ID, but we also declared it as state variable.
00:03:54.882 - 00:04:24.434, Speaker A: So let's go fix this. So I'll change this token ID to underscore token ID, and then we'll try compiling the contract again. All right, the contract compiled without any warnings. Let's write the test and run the example. So inside the test, I'll open the test file called liquidity test Js. Now for this test example, we'll first need to call the function mint new position. So we execute this test.
00:04:24.434 - 00:05:29.510, Speaker A: This will mint a new position for us, and then afterwards we'll execute the collect fees. So after the test called mint new position, we'll write a new test called it collect all fees async. The first thing that we'll do is get the token id by typing const. Token id is equal to await liquidity examples token id when we call this function to get the token id, this token id will be valid because prior to calling this test, this test mint new position would have executed and minted us a new token. And then inside the contract it would set the state variable token iD. Okay, so back inside the test, collect all fees, we'll get the token id, and let's log the token id. So I'll say console log and then type tick.
00:05:29.510 - 00:06:06.266, Speaker A: Token id is equal to dollar sign curly braces token id here I'm using string interpolation to log both a string and variable. Okay, the last step is to call the function collect all fees. So I'll type await liquidity examples. Collect all fees. Okay, let's run this test. I'll open the terminal, clear the logs, and to run the test, I'll type mpx hard hat test. The name of the test is under test liquidity test js.
00:06:06.266 - 00:06:26.740, Speaker A: Okay, the test passed. First it called a function mint new position. To mint a new position. And in return, we got a token id of 300-1349 and then afterwards, we call the function collect all fees to collect fees. And obviously, the fees were both zero and zero. So this was a simple example of how to collect fees on unison B, three.
