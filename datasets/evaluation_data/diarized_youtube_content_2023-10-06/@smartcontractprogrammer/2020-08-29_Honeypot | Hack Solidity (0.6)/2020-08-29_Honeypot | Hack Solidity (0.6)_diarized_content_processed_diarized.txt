00:00:00.490 - 00:00:56.510, Speaker A: So far, we've seen contracts that can be exploited by hackers. So in this video, I want to show you an example of contract where we can catch the hacker trying to hack the contract, and this is called a honeypot. We'll craft our honeypot by creating a contract that looks like it's vulnerable to a reentry attack. And then we'll use the technique of hiding code that we learned in the previous video in order to catch the hacker trying to do a reentry attack. So, first of all, we'll write a contract that looks vulnerable to reentry attack. Contract bank will have two state variables, state variable called balances, which will keep track of balance per user, and a state variable called logger, which will reference a contract called logger. As the name suggests, contract logger is a simple contract that will log the caller, the amount, and the action.
00:00:56.510 - 00:01:56.260, Speaker A: When we deploy this bank contract, we will set the logger state variable to the logger contract at this address. This bank contract has two functions, a function to deposit ether and a function to withdraw ether that is stored in this contract. When a user deposits ether into this contract, we'll update the balance for the user and then log the action by calling the logger log with message sender message value, and the action will be equal to deposit. When a user wants to withdraw ether, they'll call the withdrawal function. We'll first check that the amount that they want to withdraw is less than the balance that they have in the contract. If they have enough ether, we'll send the ether back to the caller, and then we'll deduct the amount from the caller, and then log the withdrawal action by calling the logger. Notice that the function withdrawal looks like it is vulnerable to the reentrancy attack.
00:01:56.260 - 00:02:44.850, Speaker A: Why is this? Well, this is because it sends the ether and then deducts the balance. So if message sender was a contract, then they'll be able to receive the ether and then call back into the withdrawal function before the balance is deducted. And since the balance has not yet been updated, this check will pass, and this line of code will send extra ether to the contract. This is what the hacker will see, and they'll try to do a reentry attack on this function. But this is exactly what we want the hacker to do. So this is going to be the bait to catch the hacker. And how are we going to catch the hacker? Well, the trick to catching the hacker in action lies in the logger.
00:02:44.850 - 00:03:28.960, Speaker A: Remember from the last video that we can hide code by initializing a contract at an address, but then having a different contract at that address. So here we're initializing the logger contract to the contract at this address. But by deploying another contract other than the logger contract at this address, we will be able to execute code different from the log function which gets called when we call the withdrawal function. So here's what we'll do to catch the hacker. We'll have the same function as the logger log. So we'll paste it here. When this function is called, we'll want to do something like this.
00:03:28.960 - 00:04:11.440, Speaker A: If the action is equal to deposit, then we'll do nothing. But when this action is equal to withdrawal, then we'll forcefully fail the transaction by calling rebirth with. It's a trap. Now, since there's no easy way to do string comparison in solidity, we'll have to write some code to compare strings. And the easiest way to compare strings in solidity is to hash them and then compare the hashes. So we'll create a helper function called equal, which takes in two strings and returns true if the two strings are equal. And the way you compare the two strings is by hashing each of them.
00:04:11.440 - 00:04:59.500, Speaker A: So here I'm hashing the first string and then hashing the second string, and then comparing that the two hashes are equal. So this is how we're going to compare the strings. And back at top, we'll compare the action is equal to withdrawal by saying equality. And that is it. So in other words, when the action is equal to withdrawal, we'll forcefully fail the transaction by calling rebirth. And this will be the contract that we're going to be using to catch the hacker. The way it works is like this.
00:04:59.500 - 00:05:51.578, Speaker A: We will deploy the honeypot contract, and then we'll deploy the bank contract. And for the address of the logger, we will pass in the address of the honeypot contract that we just deployed. And then we'll publish this code on ether scan so that the code that the hacker will see are the bank contract and the logger contract. And hopefully the hacker will also see that this contract is vulnerable to the reentry attack. The hacker will call the withdrawal function to do the reentry attack. And this will start draining the ether from this contract. But at some point, the hacker will have to stop calling back into the withdrawal function in order to complete the transaction.
00:05:51.578 - 00:06:39.642, Speaker A: This means that after they are finished doing the reentry attack, this line of code will have to be executed. But when it does, instead of calling the log function inside the logger. This will call into our honeypot log function, and since the action is equal to withdrawal, the transaction will fail. We'll be able to see the failed transaction on Etherscan, which will reveal the address of the hacker. So that is how this honeypot works. To show you this in action, let's imagine that this is the contract that the hacker wrote. So they set the target to our bank contract, and then they'll call the deposit function and then immediately withdraw from it.
00:06:39.642 - 00:07:21.110, Speaker A: By withdrawing, this will trigger the fallback function, and hacker will withdraw ether from the bank contract as long as there is at least one ether. By calling bank withdrawal again. So this is the reentry attack that the hacker can write. All right, let's now see that the hacker won't be able to do the reentry attack. And from the failed transaction, this will reveal the address of the hacker. We'll say account one is Alice and account two is EB. First, Alice will deploy the honeypot contract and then take the address of the honeypot contract and deploy the bank contract.
00:07:21.110 - 00:08:13.100, Speaker A: And she will also deposit to ether so that Eve will be able to see that there's two ethers stored in the bank contract. And this will be the bait to get Eve into doing the reentry attack. So Alice is going to deposit two ethers. So now there's two ethers in the bank contract. EB sees that there's two ethers in the bank contract. She also sees that the withdrawal function is vulnerable to the reentry attack. So e is going to deploy the attack contract with the address of the bank, and then she deploys it.
00:08:13.100 - 00:08:44.620, Speaker A: Next, she is going to call the attack function to initiate the reentry attack. So she's going to need to send one ether, so e will send one ether and then call the attack function. And you can see here that the attack failed with fail to send ether. So that was a video about honeypot, and I hope it was a good example of reentrancy and hiding code. Thanks for watching and see you soon.
