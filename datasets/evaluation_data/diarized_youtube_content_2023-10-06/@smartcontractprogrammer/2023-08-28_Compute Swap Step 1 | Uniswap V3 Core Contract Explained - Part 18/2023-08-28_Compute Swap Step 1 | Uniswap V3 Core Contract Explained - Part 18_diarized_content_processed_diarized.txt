00:00:00.330 - 00:00:43.638, Speaker A: Inside unisoft b three pool contract and inside the function swap. It calls the function called compute swap step to calculate the square root price x 96 amount in, amount out, and the fee. This function calculates the amount of token that needs to go in, the amount of token that needs to go out, and the swap fee. In this video and the next video, we're going to be reimplementing this function. Compute swap step. So so here I've created a file called swap math and we'll be writing our code inside here. This function will take in the current square root price ratio and the target square root ratio, the current liquidity and amount remaining if we're doing a swap where we specify the maximum amount of token that will go in for this trade.
00:00:43.638 - 00:01:18.738, Speaker A: This is called exact in and in this case, amount remaining will be a positive number. On the other hand, if we are specifying the amount of token out, then this amount remaining will be a negative number. Fee pips is a percentage from amount n that we're going to be charging for the swap. One basis point is one 100th of 1%. Or we can write this as one divided by ten raised to the power of four. If we have phi pips equal to one, then this means that this will be one 100th of basis point. One basis point is one divided by ten raised to the power of four.
00:01:18.738 - 00:02:00.370, Speaker A: So 100th of this will be one divided by ten to the six. So for phi pips, if this value is equal to ten to the six, then this means that the fee is 100%. And if this phi pips is equal to one, then this means that this will be equal to one 100th of the basis point. So these are the inputs. What are the outputs? The outputs of these functions are the next square root ratio. The amount in required to push from the current square root ratio to the square root ratio next and the amount of token out for putting in amount in and the fees involved. What this function is going to do is it's going to calculate the maximum amount in or maximum amount out.
00:02:00.370 - 00:02:56.338, Speaker A: And this will depend whether amount remaining is a positive number or a negative number. And it's also going to calculate the next square root ratio next, we're going to calculate the amount in and amount out between the current square root ratio and the next. As a safety measure, we're also going to cap the output amount. And lastly, we'll calculate the fee on amount in. The first thing that we'll do is determine whether this trade is 00:41 or one 40 for one means that we're putting in token zero and then getting out token one and one 40 means we're putting in token one and then getting out token zero. So I'll say Boolean 00:41 is equal to and given the inputs, how will we determine if this trade is a 00:41 or not? Well, here's how you would determine. Let's say that we have current tick and to the right of current tick, liquidity will all be in token zero and to the left, liquidity will all be in token one.
00:02:56.338 - 00:03:38.846, Speaker A: If this trade was for 00:41, then this means that we're going to put in token zero and get out token one. So this will push the current tick to the left. On the other hand, if this trade was one 40, then in this trade we're going to get more token ones and then token zero will go out. This would push the current tick to the right. Now, given these two information, we can determine from this input whether this trade is 00:41 or not. So let's say that this trade was for 00:41 this means that the current tick, we have this square root ratio, current tick, and we have square root ratio target x 96. This target needs to be to the left of the current tick.
00:03:38.846 - 00:04:26.830, Speaker A: So we can say here 00:41 if square root ratio current x 96 is greater than or equal to square root ratio target x 96. If the target square root ratio is to the left of the current tick, then we know that this trade is for 00:41 otherwise, the target will be to the right of the current tick. So this trade will be one 40. So this is how we would determine whether this trade is a 00:41 or not. Okay, the next thing that we'll do is determine whether this trade is an exact in or not. Exact in means that we specify the maximum amount of token that will go in for this trade and we get some amount of token out. If it is not an exact in, then we specify the exact amount of token out that we want from this trade.
00:04:26.830 - 00:05:16.802, Speaker A: We'll say boolean exact in is equal to and how will we determine whether this trade is exact in or not from the inputs? Well, if this trade is an exact input, then amount remaining will be positive number. If it was an exact output, then this amount remaining will be a negative number. So here we can say amount remaining greater than or equal to zero. Okay, the next thing that we'll do is calculate max amount in or out and the next square root ratio. So this will split into two conditions. If exact in, else if this flop is exact in then we'll calculate the maximum amount of token in between the two square root ratios, square root ratio current and square root ratio target. And then we'll also round up this amount in.
00:05:16.802 - 00:05:45.098, Speaker A: Why are we rounding up the mountain? This is for safety measures. If we round down then we might be taking in less tokens than what is required. So to be on the safe side, we round up. Once we calculate the maximum amount in, we'll calculate the next square root ratio. Okay, to calculate the amount in, we'll say amount in is equal to. So there are two cases whether this trade is a 00:41 or not. In both cases we're going to be calling a similar function.
00:05:45.098 - 00:06:27.318, Speaker A: So say 00:41 if this trade is a 00:41 then we'll call the function square root price math get amount zero delta and then we'll pass in the two square root ratio. Square root ratio target is to the left of square root ratio current. So for the first input we will pass in square root ratio target x 96 and for the second input we'll pass in square root ratio current x 96. The next input is the current liquidity. We get this from the input of this function. And since we're rounding up, we pass in true. So if this trade is 00:41 then amount in will be token zero.
00:06:27.318 - 00:07:06.398, Speaker A: So we call the function get amount zero delta. Otherwise we know that the trade is one 40. So amount in will be token one. So what I'm going to do is copy the code, paste it here, and the function that we're going to be calling is get amount one delta. And again, when we're trading amount one for amount zero, the current tick will be to the left of the target tick. So for the first input I'll pass in the current tick and then for the second input I'll pass in square root ratio target x 96. The current square root ratio is to the left of the target square root ratio.
00:07:06.398 - 00:08:05.858, Speaker A: Okay, now that we calculated amount in, the next step is to calculate the next square root ratio. Now, the fee on swap is calculated based on the amount in. If this swap pushes the current square root ratio all the way to the square root ratio target, then the fee will be taken out from amount remaining. Otherwise, if the current swap does not push the current square root ratio all the way to square root ratio target, then the fee will be taken out from this amount in. So to calculate the next square root ratio, we need to compare this amount in with amount remaining minus the fees. Here I'll type uint amount in remaining less fee this will be equal to we're going to be using the library called full math moldiv amount remaining is int two five six. So we'll cast it to u into two five six u into five six amount remaining.
00:08:05.858 - 00:09:43.618, Speaker A: And this is a safe operation since for exact n, we know that amount remaining is greater than or equal to zero. Amount remaining minus the fees will be one e six minus fee pips, and then we'll divide by one e six. Here we're calculating the amount in remaining minus the fees. Okay, so now we can calculate next square root ratio, amount in, remaining less, fee is greater than or equal to amount in. Then fee will be charged on amount remaining and the next square root ratio will be square root ratio next x 96 this will be equal to the target square root ratio target x 96. Otherwise, we'll need to calculate the next square root ratio, x 96 square root ratio next x 96 is equal to and we'll use the library square root price math get next square root price from input and then pass in the inputs the current square root ratio square root ratio current x 96 current liquidity liquidity amount remaining less fees amount this should be amount remaining amount remaining remaining less fee and 00:41. Okay, so we finished the code for calculating max amount in and the next square root ratio.
00:09:43.618 - 00:10:28.542, Speaker A: For exact in. We'll do something similar when the trade is not exact in. So when the trade is not exact in, we'll calculate the max amount of token out and then round down the amount out. And why are we rounding down the amount out? Well, if we did not round down, if we round it up, then this means that we might be giving out more tokens than necessary. So for the first step, I'm going to scroll up and then copy this code, and then we'll modify it so paste it here instead of amount in, we're calculating amount out. And if this trade was 00:41 token in is token zero and token out is token one. So here we'll put amount one delta.
00:10:28.542 - 00:11:05.010, Speaker A: On the other hand, if it was not a 00:41, this trade will be one 40. So the amount of token out that we need to calculate is for amount zero, and the parameters for square root ratios remain the same. Liquidity stays the same. And since we're rounding down here, we'll pass in false. Okay, the next step is to calculate the next square root ratio. So, like in the case of exactin, there are two cases whether amount remaining exceeds amount out or not. So say if now in this case, amount in will be a negative number.
00:11:05.010 - 00:12:12.722, Speaker A: So we'll cast it into a positive number by typing un to 56 minus amount remaining. If this amount remaining is greater than or equal to amount out, then the next square root ratio. Square root ratio next x 96 is equal to the target square root ratio target x 96. Otherwise, we'll need to calculate the next square root ratio. And again, we're going to be calling the similar function as what we see over here. So copy this and then paste it here. The next square root ratio is calculated by calling the function get next square root price from output and for the inputs of this function we'll pass in the current square root ratio liquidity and amount will be un two, five, six minus amount remaining and then 00:41 okay, so that completes the step of calculating the maximum amount of token in or the maximum amount of token out and the next square root ratio.
00:12:12.722 - 00:12:50.546, Speaker A: The next step is to calculate the amount in and amount out between the square root ratio current and next. This will be the amount of tokens that come in and the amount of tokens that go out in this swap. Now, there are several cases that we need to consider to calculate the amount of tokens in and out. First we need to find out whether this swap used up all of amount in or all of amount out. And to do that we'll say boolean max equals the square root ratio. Target x 96 is equal to square root ratio. Next x 96.
00:12:50.546 - 00:13:46.494, Speaker A: So scrolling up, we know that when the next square root ratio is equal to the target over here, in the same case over here, then we know that this trade either used up all of a mountain between these square root ratio or it's going to take out all of the tokens in between these square root ratio. So in this case, we know that this is a max trade. So there are four situations to consider whether this trade was max or not and whether this trade was an exact input or not. Let's examine each case. So if this trade was a max trade, and if this trade was exact in, then what will be the amount of token in and what will be the amount of token out? Well, in this case, we know that amount in must be equal to amount in that we calculated from over here. The maximum amount of token between the square root ratio target and square root ratio current is equal to amount in. So we don't have to do any calculation.
00:13:46.494 - 00:14:28.194, Speaker A: We know that the amount in will be equal to amount in that we already calculated. How about amount out? Well, amount out we need to calculate. Okay, how about the next case? If this trade was max and it is not an exact in. Well, if this trade is not exact in, then we need to calculate the amount in, since over here we did not calculate amount in yet. How about amount out? Well, we calculated above over here what amount out is, so we don't need to calculate amount out. In the rest of the case, the trade does not use up all of the tokens between the two square root ratios. So in these two cases, we'll need to calculate amount in and amount out.
00:14:28.194 - 00:14:57.786, Speaker A: Okay, so let's put this into code. Now, the code splits into two parts, whether this tray was a 00:41 or not. If 00:41 then we'll calculate amount in, amount out. Else we'll write some code to calculate amount in and amount out as well. So what is the final amount in? This is equal to. Well, what's the easy case? The easy case is when max and exact in. So say max and exact in.
00:14:57.786 - 00:15:39.434, Speaker A: In this case, amount in will be amount in. Otherwise we'll call the function square root price math, get amount zero, delta and then pass in. Square root ratio next and square root ratio current pass in liquidity and for amount in we'll round up. Okay, how about amount out? Well, what's the easy case for amount out? The easy case is when it's max and not exact in. In this case, amount out will be. We already calculated amount out, so say max and not exact in. In this case, amount out is already computed amount out.
00:15:39.434 - 00:16:19.446, Speaker A: Otherwise we'll call the function square root price math get amount one delta and then we'll pass in similar inputs. Square root ratio next current liquidity, and we want to round down the amount out. So here say false. Okay, so this is the case for 00:41 for one 40, we'll do something similar except change the function calls around. Amount in will be get amount one delta and amount out will be get amount zero delta. Again, the cases don't change. So in the true case we'll set amount in to amount in and amount out to amount out.
00:16:19.446 - 00:16:41.786, Speaker A: We're going to be calling the same functions. However, the order of the ticks will be different. We need to swap the order of the ticks. Since this trade will be one 40, the next square root ratio will be to the right of the current. Swap, the current square root ratio, and the next. And then we'll do the same over here. Square root ratio, current square root ratio next.
00:16:41.786 - 00:17:27.160, Speaker A: Okay, and that completes the code for calculating amount in and amount out. The last step of this video is we're going to cap the output amount and this is done for safety measures, say if not exact in and amount out. Amount out that was calculated is greater than Un 256 minus amount remaining, then amount out is equal to un 256 of minus amount remaining. Okay, that completes the code for capping the output amount. We still need to write the code to calculate the fees, but we'll do this in the next video. So for now, let's try compiling this contract. Open my terminal and then type forge build.
00:17:27.160 - 00:17:45.500, Speaker A: Okay, and our jack compiled successfully. So in this video, we started writing the code for compute swap step and wrote our code all the way down to here. In the next video, we'll write the code for calculating the fee amount, and I'll also explain the math behind it.
