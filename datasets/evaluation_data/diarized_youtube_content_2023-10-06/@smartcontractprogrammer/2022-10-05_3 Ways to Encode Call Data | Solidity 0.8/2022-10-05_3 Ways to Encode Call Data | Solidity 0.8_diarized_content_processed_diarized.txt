00:00:00.250 - 00:00:40.810, Speaker A: I'm going to show you three ways to encode data and this data will be passed to the low level function call to call other contracts. So in this video I'll show you three ways to encode data. Encode with signature, encode with selector, and encode call. We will use the data that's returned by these function to call the function test. When we call this function, it will use the low level function call to call contract passing in the data that we return from these functions. For this example, the contract that we're going to be calling is the token contract that we will deploy. Okay, so the first way to encode data that we will pass on later to this part of the code.
00:00:40.810 - 00:01:07.918, Speaker A: So the data part. The first way to encode the data is to use encode with signature. So we'll type return Abi encode with signature. For the first input we'll need to pass in the function signature that we want to call. And this is a string. So for this example we're going to be calling the function transfer. So inside a string we'll type transfer and then the inputs.
00:01:07.918 - 00:01:40.530, Speaker A: The first input is an address comma and without any space the next input is un. So we'll type un 256 and that will be the function signature that we're going to be calling. And then next we're going to pass in the inputs that we're going to be encoding. The first input will be an address, the two, and the next input will be the amount that you see over here. So here I'll type two and then amount. That is the first way to encode the data. The next way to encode the data is by calling encode with selector.
00:01:40.530 - 00:02:21.734, Speaker A: So let me show you how return Abi encode with selector. The first input will be the selector. So I'll type ierc 20 dot. The function that we're calling is transfer and then the selector will be selector. Next we'll pass in the input, so it'll be two and then amount. Now notice that for the first encode with signature, we passed in the string for the function that we're going to be calling. But if we made a typo like put in a space or instead of un, we put in un instead of un 256 and then try to compile a contract.
00:02:21.734 - 00:02:46.202, Speaker A: The contract still compiles. So here we can pass in an incorrect function signature and the contract still compiles. I'll fix this to a un 256. Now unlike the first example here, if we made a typo. So instead of transfer, maybe I'll put in the s at the end and try to compile it. The contract fails to compile. However, this part of the code still compiles.
00:02:46.202 - 00:03:33.462, Speaker A: If we forget to pass in some inputs, for example the function transfer, it's going to take in an address and a unit 256. But over here, let's say that we forgot to pass in the first input the address and then hit ctrl s. And notice that the contract still compiles. Or instead of passing an address, we might pass in some boolean value, for example. True, and the contract still compiles. So using encoder selector we won't be able to make a mistake with a typo for the function name, but we can still pass in the wrong data type and the wrong amount of inputs. So next I'm going to show you how to encode data where we cannot make a mistake for the function name and for the type and the amount of inputs to pass, I'll type return ABI encodecall.
00:03:33.462 - 00:04:26.740, Speaker A: The first input will be the function that we're going to be calling erc 20 transfer and then next inside the parentheses we'll pass in the actual inputs. The actual inputs are the two address and the amount. Let's hit ctrl s to make sure that the contract compiles and the contract compiles. So what if we mistype the function? So for example, transfers then try to compile it and the contract does not compile. How about if we pass in some wrong inputs? For example, let's pass in address two, then maybe we'll pass in some boolean true, and then try to compile it. And the contract does not compile. So using encode call it checks that both the function and the inputs to pass matches that they are correct.
00:04:26.740 - 00:05:20.674, Speaker A: Okay, so let's deploy this contract and test out calling the token contract by calling the function test. So I'll deploy both the contracts Abi encode and also the token contract. And then first I'll open the ABI encode contract, and then we'll call the encode call encode with signature and encode with selector. Make sure that all the data return the same data. So for the first input we need to pass in an address. I'll just copy the address of this contract and for the amount I'll pass in one, two, three, copy the inputs and then paste it for the other functions and then call all of the functions scroll down and you can see that all of the data that was returned are the same. So let's copy this and then call the function test.
00:05:20.674 - 00:06:06.394, Speaker A: So for the data I'll pass in the data that we copied, and then for the address we'll pass in the address of the token contract that we deployed, paste it here, and before we call the function transact, I'll open the debugger so that we can see the transactions, and then call transact and the transaction was successful. So there are three ways to encode data to be passed to the low level function. Call encode with signature, encode with selector, and encode. Call encode with signature. You can mistype the function that you're going to be calling, and the contract still compiles. Encode with selector. You can put in the wrong type of inputs and the wrong amount of inputs, and the contract will still compile.
00:06:06.394 - 00:06:15.890, Speaker A: However, for encode call, if either the function name or the data type of the inputs or the amount of inputs are different, then the contract will not compile.
