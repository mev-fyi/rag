00:00:00.330 - 00:00:40.138, Speaker A: The governance contract for the tornado cache was recently hacked. So in this video, I'll explain how it was hacked, and also I'll explain the technique that was used to hack it. How to deploy different contracts at the same address. First, let's start with an overview of how the governance contract for tornado cache was hacked. So here I have an attacker, and let's say this tornado cache icon is the governance contract. The attacker first deploys a proposal contract. If the tornado cache governance approves this contract, then the code inside here will be executed inside the tornado cache governance contract using delegate call, the tornado cache governance will review the code.
00:00:40.138 - 00:01:16.226, Speaker A: The code looks good. There's no malicious code, so they say the code looks good to me. We'll approve this contract. After the proposal contract is approved, the attacker deletes this proposal contract and then deploys a malicious contract at the same address as the proposal contract that was just deleted. Since this contract was already approved by the tornado cache governance, now the attacker can execute this proposal contract. The attacker will call a function to execute the proposal inside a tornado cache governance contract. And this will delegate call to execute this malicious code.
00:01:16.226 - 00:02:07.586, Speaker A: And since it's using a delegate call, this malicious code will be executed inside the tornado cache governance contract. And what this means is that if the malicious code contains some code, for example, to withdraw all EF inside this contract or to overwrite the owner of this contract, then it is possible to do so since it is executing any code inside here using delegate call storage. Variables inside the tornado governance contract will be updated, and if the attacker wanted to, they can steal all of the tokens and ETH locked inside this contract. This contract has been compromised by the attacker. This is an overview of how the hack was executed. But how was this attacker able to deploy two different contracts at the same address? So let's examine how the attacker was able to deploy different contracts at the same address. First, this attacker deployed a contract.
00:02:07.586 - 00:02:41.150, Speaker A: Let's call this contract deployer deployer. Basically, this will be a contract that deploys another contract. So using create two, this contract would deploy another contract. We'll call this deployer. Now, since the deployer deployer is using create two to deploy this deployer contract, this means that the address of this deployer contract will always be fixed. We can know ahead of time what the address of this contract will be even before we deploy this contract. So let's say that this contract address is fixed to zero XFF.
00:02:41.150 - 00:03:00.854, Speaker A: Next, the attacker will call into this deployer contract to deploy the proposal contract. Let's say at the address zero X ABC. And to deploy this contract, the attacker used create. So, notice the difference here. Deployer. Deployer used create two. And then to deploy the proposal, the attacker used create.
00:03:00.854 - 00:03:51.878, Speaker A: Next, the attacker deleted this proposal contract, and then using create again, somehow was able to deploy another contract at the same address as the proposal contract. So how was the attacker able to deploy two different contracts, proposal and malicious code at the same address? Zero xabc. To understand how this was pulled off, let's take a step back and see how the address of a contract is computed using create. How is a contract address computed using create? An address of a contract that was deployed using create is computed in the following way. The address will be equal to the last 20 bytes of Shaw three RLP encoded of the sender and announce. Or we can look at it this way. Take the sender and announce RLP encoded, and then take the shaw three hash of this RLP encoded data.
00:03:51.878 - 00:04:22.894, Speaker A: And then lastly, take the last 20 bytes. This is how the address is computed for a contract that is deployed using create. This nouns that you see over here is the number of transactions of a sender. From this formula, we can see that the address of a contract that was deployed using create depends on the sender and the nouns. So this means that if we use the same sender and the same nouns, we'll get the same address. And on the other hand, let's say that the sender is fixed. But if the nouns is different, then the address of the contracts will be different.
00:04:22.894 - 00:04:57.866, Speaker A: In other words, different nouns will produce different contract address. Let's apply this formula of how the address of a contract is computed to the contracts that were actually deployed. The deployer contract deployed. The proposal contract, and this proposal contract was deployed using create. To compute the address of this proposal contract, we need to know the sender and the nouns that was used. The sender will be this deployer contract. This contract used create to deploy this proposal contract, and the nouns that was used to deploy this proposal contract will be equal to zero.
00:04:57.866 - 00:05:39.306, Speaker A: This was the first transaction that was called from the deployer contract. So let's say that this proposal contract has an address of zero x ABC. Now, using this deployer contract, if the attacker deployed another contract, let's say the malicious code contract, then now the nouns will be equal to one. And let's say that this contract address will be zero XYZ. Now, notice that here the nouns that was used is equal to zero, and the nouns that was used over here is equal to one. This means that the address of these two contracts will be different. Since the nouns will be different, the nouns that was used to deploy the proposal contract and the nouns that was used to deploy the malicious contract are different.
00:05:39.306 - 00:06:12.558, Speaker A: Hence, the address of these contract will also be different. But if there's somehow a way to reset this nouns, then we'll be able to deploy the malicious code contract at the same address as the proposal contract. Is there a way to reset the nouns of the deployer contract? The answer is yes. Let's see how this is possible. So again, let's start with the deployer deployer contract. This will be the first contract deployed by the attacker. Next, using create two, this deployer deployer contract will deploy the deployer contract.
00:06:12.558 - 00:06:47.082, Speaker A: It's using create two, so the contract address will be fixed. Again, we'll say this is equal to zero XFF. Next, the attacker will call the deployer contract to deploy the proposal contract, and this proposal contract will be deployed using create. The address of a contract using create depends on the sender and announce. In this case, the sender will be this deployer contract, and the nouns that was used will be equal to zero. Once the proposal contract is approved, the next thing that the attacker does is delete this proposal contract. And then, the attacker will also delete the deployer contract.
00:06:47.082 - 00:07:40.474, Speaker A: Using create two, the attacker will redeploy the deployer contract. So note here again that since this contract is deployed using create two, no matter the number of times you deploy this contract, this contract address will always be equal to zero, XfF. Next, the attacker will deploy this malicious code through the deployer contract. Again, this contract was deployed using create, the sender is still equal to zero, xff, and the nouns that was used will be equal to zero. This is because when this contract was deleted at step four and then redeployed at step five, the internal count, the nouns was reset to zero. So now we have a situation where the sender is zero, xffff, and the nouns is equal to zero. Notice that this nouns matches the nouns that was used to deploy the proposal contract.
00:07:40.474 - 00:08:20.394, Speaker A: And what this means is that the address of this malicious code will be exactly equal to the address of the proposal contract. So this was how the malicious code was deployed at the same address as the proposal contract, even though the code inside these two contract might be totally different. In summary, the attacker used create two to obtain a deterministic sender. Let's say this is equal to zero, xff. Next, the attacker used self destruct to reset the nouns, and then deploy a different contract at the same address. So the attacker used self destruct to delete this contract. And then the attacker used self destruct to delete the deployer contract and then redeploy.
00:08:20.394 - 00:08:28.010, Speaker A: This effectively reset the nouns. So now the attacker can deploy a different contract at the same address as the proposal contract.
