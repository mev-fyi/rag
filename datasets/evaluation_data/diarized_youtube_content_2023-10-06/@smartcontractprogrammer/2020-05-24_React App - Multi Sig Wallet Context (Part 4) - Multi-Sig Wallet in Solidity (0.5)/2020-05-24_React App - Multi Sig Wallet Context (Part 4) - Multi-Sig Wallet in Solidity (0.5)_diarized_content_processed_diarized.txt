00:00:00.410 - 00:00:51.630, Speaker A: In the previous video, we wrote some code to render the current account. Since then, as you can see, I've added some new features. One of the features I've added is to render the current account. So up top here you can see that it is rendering network unknown and if you go to Metamask and then switch network over to Robston, it would reload the page and when I connect to metamask it will render the Robstone network. You too can also code this feature and I've created an exercise for this and I'll post the link to the exercise in the descriptions below. In this video I want to show you four things. How to read and write from a contract, how to send ether into a contract, and lastly how to subscribe to an event emitted from a contract.
00:00:51.630 - 00:01:38.470, Speaker A: But before we get started, make sure that you're running truffle develop and you've migrated the multi Sig wallet contract. Also make sure that you've copied the build file from the Truffle project and then started the react dev server. The last thing that you'll need to do is reset your accounts imported from truffle. If you don't do this, all transactions that we'll do in this video will fail. Once you're done with the setup, the first thing that we'll do is write our API function to get data from our multisig wallet contract. And on the left here inside the API folder, I created a file called Multisigwallet TS. Inside the file you'll first need to import some NPM packages.
00:01:38.470 - 00:02:17.254, Speaker A: We'll need web3 to communicate with the ethereum full node. We'll also need bn Js to handle big numbers that JavaScript cannot. We'll also import truffle contract. Now you can interact with a smart contract using web3, but using truffle contract it will make the code easier to write. And finally, we'll import the build file that we copied over from the truffle project. And this file contains information such as where the contract is deployed and the contract. ABI to use truffle contract, we'll need to pass in our build file into it.
00:02:17.254 - 00:03:06.280, Speaker A: And now we can use this multi SIg wallet variable to deploy new contracts and interact with deployed contracts. Let's now write our first function to get data from our contract. Here is our function that's going to be called to get data from our multisig wallet contract. And as you can see here, I've added some fake data that we're going to be returning. So when we call this get function inside our react component, it's going to return the address of the contract, the balance of the contract, and the owners. The num confirmations required, the number of transactions and the transactions. So we're going to be writing code to get the actual data and then filling them out here.
00:03:06.280 - 00:04:05.078, Speaker A: The first thing that you'll need to do is set web3 provider on the Multisig wallet. What does this line of code exactly do? I do not know. This is part of the setup needed to use truffle contract to get our Multisig wallet contract that is deployed, we'll call multisigwallet deployed. Once we get the Multisig wallet that is deployed, we can get the owners by calling getowners, and getowners is a public function inside the multisig wallet contract. Similarly, we can get the num confirmations required by calling multisig numconations required. We'll also get the number of transactions stored in the multisig wallet by calling gettransaction count. Now, to get the balance of ether stored in the multisig, we'll need to call web3 e getbalance and then pass in the address of the multisig.
00:04:05.078 - 00:04:56.646, Speaker A: Next, we'll write some code to get the ten most recent transactions. And the reason that we're only returning ten transactions here is because if we have 100 transactions, then it might take too long for the application to load. First we'll say count equals transaction count two number. And the reason why we're doing this here is because transaction count is an instance of big number, and in order to make this into a number that JavaScript understands, we'll need to call two number. We'll declare array of transactions and then write a for loop that will get the actual transactions. We'll set our TX index to the most recent one and then count backwards. So once TX index is less than zero, we'll just break out of the for loop.
00:04:56.646 - 00:06:01.658, Speaker A: We'll get the actual transaction data by calling Multisig gettransaction and then passing the TX index. We'll also check if this transaction is confirmed by the current account, by saying multisig is confirmed, and then passing the TX index and the current account. And lastly, we'll push all of this information into our transactions array. For each transaction, we'll store the TX index, the address the transaction is meant for, and the value that we're going to be sending to the two address, and also the data that's going to be sent to the two address. We'll also store whether the transaction is already executed or not, and the current number of confirmations for this transaction. Lastly, we'll store whether this transaction is confirmed by the current account or not. So that completes the for loop to get data about the transactions stored in the Multisig wallet contract, and we've also retrieved the basic information about the contract.
00:06:01.658 - 00:07:11.586, Speaker A: So now let's return all of this data. So at the very bottom we'll say that the address that we're returning is multisig address balance is the balance that we got earlier, and the same goes for owners. Now, for Num confirmations required, we'll say numconformations require two number and again, this is because NUM confirmations required is an instance of big number, but here we want to cast it into a number that JavaScript understands and we'll do the same thing for transaction count. And lastly we'll return the transactions that we populated using the for loop that completes our function. To get data from our multisig wallet contract now to render this data inside our react component, we'll need to code a context for the multisig wallet similar to what we did for web3 context. I've created a file called multisigwallet TSX inside the context folder and I've opened the file over here. As you can see here on the top, I've imported some files.
00:07:11.586 - 00:08:18.220, Speaker A: I've also prepared some code. The code inside here is similar to the code inside web3 context similar to web3 context, we first declare the state and then declare the initial state and then some actions, and we also have a reducer inside the switch statement. We will later write the state transitions. We also have the declaration for the multisig wallet context and we export a function use multisig wallet context for other react components to access the multisig wallet context. Scrolling down we also have the provider of the multisig wallet context and scrolling down further we finally have our updater and inside this component we'll write the code to get the data from the multisig wallet contract and then pass that data over to the reducer. Before we can get data from our contract, we need the web3 instance and account. So first we'll call use web3 context to get web3 instance and the current account.
00:08:18.220 - 00:09:19.386, Speaker A: Next we'll get the state of the Multisig wallet and the function set that will set the state of the multisig wallet and we'll get these variables by calling use Multisig wallet context. We'll call the use effect hook to get the data from the contract inside the hook we'll define a function called get, which will take in web3 and the current account. We'll use this function to get the data from our multisig wallet contract and then call set to update our state to the data that we fetched from our API. We'll put our API call inside a try catch block, and if there's an error we'll just console log it to get the actual contract data. We'll call get Multisig wallet and then pass in our web3 and our current account. Now the function get Multisig wallet is the function that we defined in our API. Back inside the API file we named this function get, but over here it is called get Multisig wallet.
00:09:19.386 - 00:10:13.040, Speaker A: And this is because up at top we imported the get function, but inside here we renamed it as get Multisig wallet. After we get the data, we'll call the function set and then pass in the data. This function will dispatch an action to set the state to the current data. Once we define the get function above, we'll call this function when the web3 instance is available by saying here if web3 then get and then pass in the web3 instance and account. And we only want this hook to run when the web3 instance is available. So inside here we'll say web3 so that this code inside here will run every time the web3 instance changes. And this will make sure that when the web3 instance is available for the first time, the function will run and get the contract data.
00:10:13.040 - 00:11:00.350, Speaker A: Now when the function set is called, it's going to call the function above, also named set, which is inside the provider, and it's going to dispatch an action of type set with the data. When we call the function dispatch, this will execute the reducer above. So inside the function reducer, the action type will be equal to set. So let's write the code to update the state. When the action of type set is dispatched, we'll say when the case is equal to set. Obviously we'll want to return the state and we also want to update the state with our new data. So here we'll say dot dot dot action data, and this will copy the data from action data.
00:11:00.350 - 00:12:04.530, Speaker A: So this whole return statement here will return the current state and then update with all the data provided by action data. Before we render the state stored inside the multisig wallet context, we'll need to do some setup. So here I have index TSX open and similar to what we did for web3 context, we'll need to import the provider and the updater from Multisig wallet context and inside the render function we'll put the multisig wallet provider and the multisig wallet updater. One important thing to note here is that the Multisig wallet provider is rendered under web3 provider. And this is because in order to use multisig wallet context, we need web3 context. All right, so now we're ready to render the state stored in Multisig wallet context. So in the browser I'm going to connect to metamask and you can see here now that it's rendering the contract address, the owners, and the number of confirmations required.
00:12:04.530 - 00:13:41.366, Speaker A: We'll next work on the feature to deposit ether into the wallet so that after we send some ether, the balance would update back inside multisavewallet ts inside the folder API I've declared a function called deposit, and when this function is called, it will send ether to the multisig wallet similar to the setup that we did for the get function. We'll set the web3 provider and then get the deployed contract to send ether to this multisig wallet. All we have to do is called send transaction and then pass in the account that we're going to send the ether from and the amount that we're going to be sending inside depositform tsx we'll import the deposit function that we just defined inside API and when the deposit button is clicked, it will trigger on submit which will call the function above over here, and it will call the call function which is defined over here, and the function call will call the deposit function which we defined in the API. So let's give it a try. In our browser I'll send 100 way and then hit deposit and then hit confirm. So the transaction was successful, but you'll notice that the balance hasn't changed and we'll need to refresh the page to confirm that our balance did update. But there's a way to render the balance without refreshing the page, and this is by subscribing to events.
00:13:41.366 - 00:14:52.638, Speaker A: So what we'll do is subscribe to the events emitted by the Multisig wallet contract and then update the multisig wallet context when the deposit event is emitted. Back in our editor inside API Multisigwallet TS, we'll start by creating a function called subscribe. For the input, it's going to take the web3 instance and the address of the contract to subscribe to, and the callback function to call when there's either error or a log and the type of log that we're going to be sending back is defined here. But the one that we're interested in now is the deposit. Since the library truffle contract does not have a way for us to subscribe to a contract here, we'll use web3 to subscribe to the contract. And we can do that by calling web3 e contract and then passing the contract ABi and the address of the contract, and we'll subscribe to the events emitted by the Multisig wallet contract by saying multisig events, all events, and then passing a callback. When we get an error, we'll forward the error to the callback.
00:14:52.638 - 00:15:53.960, Speaker A: Else if when we get a log, we'll call the callback with the log. Lastly, we'll want a way to unsubscribe and we can do that by capturing the result and then returning a function that will call unsubscribe on the result variable back inside the file multisigwallet TSX we'll write the code to subscribe to the events emitted by the Multisig wallet contract. So inside the updater component we'll first write a use effect hook. And this hook should run when either the web3 instance or the address of the multisig wallet changes. Inside the hook, we'll call the subscribe function when the web3 instance and the address of the multisig wallet contract is set inside the callback. If there's an error, we'll just log it. When the log event is equal to deposit, we'll somehow update the balance, and when the event does not match any of the case, we'll just console log the log.
00:15:53.960 - 00:17:04.502, Speaker A: So how do we update the balance? Well, we can do that by scrolling up and then getting the function update balance from the multisig wallet context, scrolling back down. And then here we say update balance and then pass in the log return values and this will send the return values all the way up to the reducer. Now, if you look over here, you can see that the return values return the balance back inside the reducer. We can update the balance by simply updating the balance stored in the state with the balance provided by action data. And we're now ready to see the balance update in real time without reloading the web page. So back in the browser I'll send 200 way and then hit deposit and you can see that the balance updated right away without refreshing the page. All right, so the last thing that I want to show you is how to create transaction so that when we hit create transaction and then hit submit.
00:17:04.502 - 00:17:47.094, Speaker A: This will send the transaction to our multisig wallet. Again, we'll first write our API function back inside multisig wallet. I prepare the function called submit transaction. So when this function is called, it will create a transaction inside the multisig wallet contract. We will first do the usual setup and then get the deployed contract. Next we'll get the inputs from the Params variable and these inputs will be sent with the transaction. And lastly we'll call multisig submit transaction, passing our inputs to value in data, and this transaction will be sent from the current account and that completes the code to submit transaction to the multisig wallet.
00:17:47.094 - 00:18:28.870, Speaker A: But before we see this in action inside the browser, I first want to explain how the react component works. Here I've opened the Createtxmodal TSX and it's located on the app as Createtxmodal TSX. At the top you can see that we've imported submit TX that we just wrote. When the create button is clicked, it will call the onsubmit. The onsubmit will call the call function, and the call function will call the submit tx that we defined inside the API folder. Let's now see this in action inside the browser. I'll copy the address of owner number three and then hit create transaction and then paste the owner.
00:18:28.870 - 00:19:29.380, Speaker A: We'll send zero value with zero bytes and then hit create and you can see that the transaction was successful, but you don't see it here, and in order to see it you'll have to refresh the page. Once the page reloads, you can see our transaction here and if you want to render this in real time without reloading the web page, you can do something similar to what we did with the deposit. All you have to do is write some case statement similar to the deposit inside the updater component where we subscribe to the events, and inside the redo. Sir, you'll have to write another case statement, so I'll leave the rest of the feature as an exercise. I'll leave a link in the descriptions below for the code with all of the features completed. In the next video we'll deploy the contract onto the Ropson test network. Have a nice weekend and see you in the next video.
