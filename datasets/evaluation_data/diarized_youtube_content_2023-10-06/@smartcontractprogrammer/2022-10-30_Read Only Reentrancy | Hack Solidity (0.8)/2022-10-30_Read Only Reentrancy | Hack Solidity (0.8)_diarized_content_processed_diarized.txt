00:00:00.250 - 00:00:20.442, Speaker A: In a reentrancy hack, a contract will call a target contract. This target contract will call back into the caller. In this case, the hack contract. While the first call has now finished, this hack contract will call back into the target contract. This is reentrancy hack. A readonly reentry is a little bit more complicated. First, the hack contract will call into a contract.
00:00:20.442 - 00:00:42.506, Speaker A: We'll call this contract date. Contract date will call back into the caller. In this case, it will be the hack contract. At this moment, the call made in the first step to contract day has not yet finished. While the call in the first step is not yet finished, this hack contract will call into a target contract. The target contract will read some state from contract day. Finish executing step three.
00:00:42.506 - 00:01:04.130, Speaker A: After the function called to the target contract finishes. Then the execution to step two finishes, and lastly, the execution to step one finishes. Let's take a look at an example. For this example, I'll be using foundry. So first let's install it. I'll install foundry by copying and pasting this command into my terminal. All of the command and the codes that I'll be typing, I'll put it up on GitHub.
00:01:04.130 - 00:01:47.360, Speaker A: The next step of installing foundry is to type foundry up. So I'll type foundry up. Next, I'll initialize a foundry project inside this directory by typing forge init. Okay, once that command executed successfully, if I check the current directory, you can see some files that foundry put in, and we're now ready to write some code for the readoni reentgency example. For this example, we'll simulate a Readoni reentgency attack on the curve st e pool, and we'll be executing this on the main network. So we won't be actually hacking the contract, we will just be running a simulation. First, I'll open source folder and then remove this boilerplate code.
00:01:47.360 - 00:02:20.418, Speaker A: And then I'll create a new contract called hack Soul. First, I'll paste the solidity version. Next, I'll import console Sol so that we'll be able to console log some values inside the transaction. Next, I'll set the address for the curb SdE pool and the token that you get when you deposit into this pool. I'll name it LP for a liquidity provider. We're going to be hacking the curb contract, so I'll paste the interface for the curb. For this example, the functions that we're going to be calling is get virtual price, add liquidity, and remove liquidity.
00:02:20.418 - 00:02:45.566, Speaker A: When you call this function, get virtual price. It returns the value of the shares. The higher the value of the shares, the more tokens that you'll get that is locked inside the pool when you call the function withdrawal. We can add the tokens to this curve pool by calling the function add liquidity and to remove the tokens from this pool, we'll be calling the function remove liquidity. We're also going to need the IERC 20 interface. So I'll paste it here. Okay, so next, let's write the hack contract.
00:02:45.566 - 00:03:24.786, Speaker A: So type contract hack. First let's set some contract addresses. I curb this will be private constant and I'll name it pool. And this is equal to I curb this is the interface that we defined above and the address of the pool that we'll be calling is st e pool. I'll also set the IERC 20 for the LP tokens. So IERC 20 private constant LP token, and this will be IERC 20 for the LP. This is the token that we will receive when we call the function add liquidity on the kerpool.
00:03:24.786 - 00:03:59.894, Speaker A: Next I'll write the function called pong. This will be external and payable. Since we will be sending some leaf. This will be the main function that we will be calling to initiate the attack. So what we're going to be doing is to first add liquidity to the curve pool. Next we'll log the value of the shares by calling the function get virtual price log get virtual price and then we'll remove liquidity. By calling this function, we'll be able to trigger the Readoni reentry attack.
00:03:59.894 - 00:04:43.570, Speaker A: When we call the function remove liquidity on the curb SDE pool. And then if I scroll down, you can see here that it sends the EF back before the function finishes executing. So this means that when we call the function remove liquidity, the code will execute. And then before it finishes executing all of the code, it will send some EF. So this is where we can do the reengency back inside my code editor and back inside our contract. When we call the function remove liquidity, at some point it would send the e back to this contract. So inside this contract, I'll define a receive external payable and this is where we would write our rest of our code to execute the readonly reentry.
00:04:43.570 - 00:05:26.778, Speaker A: In this example, to show you that get virtual price will be higher while we're still executing remove liquidity inside here we'll log get virtual price again. Okay, let's write our code. The first thing is to add liquidity. Now if I scroll up to call add liquidity on the curve pool, we'll need to prepare an array of two specifying the amount of tokens to add and the minimum amount of Lp tokens to mint. So scroll down. First, we'll initialize a unit array of two un to memory. I'll call it amounts and this will be equal to the first value represents the amount of ETH that we're going to be sending.
00:05:26.778 - 00:06:06.894, Speaker A: So we'll be sending message value. The second amount represents the amount of st e that we're sending. We'll be sending zero and then we'll add liquidity by calling pool, add liquidity, passing in the amounts and the minimum amount of LPs that we'll be minting. We'll say one and when we call this function, dial liquidity. Since this is an e sde pool, we'll have to also send the amount of e that is specified over here. So say value is message value. When we call this function add liquidity, it returns the amount of Lp tokens that were minted.
00:06:06.894 - 00:06:55.898, Speaker A: So I'll say un lp equals to and that is add liquidity. Next, we'll log the virtual price, the value of one share of these Lp tokens. So I'll say console log and then I'll type before remove Lp virtual price and then call the function pool, get virtual price and then we'll remove liquidity. Let's scroll up to call remove liquidity. We'll need to pass in the amount of Lp tokens that we're going to be burning and the minimum amount of underlying token. This will be ETH and st e that we expect to receive. So scroll down, we'll prepare a un array of size two un two memory min amounts.
00:06:55.898 - 00:07:38.938, Speaker A: For this example, I'll just say minimum amount size zero, un zero, un zero. And then we'll call the function remove pool remove liquidity, passing in the amount of Lp tokens that we're going to be burning. We'll withdraw all of it, so we'll pass in all of our lp tokens and pass in minimum amounts. When we call this function remove liquidity, at some point it will send us back the ETH which will trigger the receive function. So inside here we'll log the get virtual price. So I'll copy this, paste it here, and then say during remove liquidity, log the virtual price. Okay, this completes the first step of our hack contract.
00:07:38.938 - 00:08:18.010, Speaker A: What we're trying to see here is that while we're calling remove liquidity, we should see that get virtual price is higher. And by confirming that get virtual price will be higher. While this part of the function is executing, we'll be able to write our exploit inside this receive function. So let's first check that get virtual price is actually higher inside this part of the code. So I'll open my terminal and then I'll try to compile the contract by typing forge build. Now I noticed that the contract didn't compile because there was a contract in the test file that we deleted. So I'll go fix that right now.
00:08:18.010 - 00:08:59.030, Speaker A: Open the test and then remove the import. Then remove all of the code inside the test and let's try compiling again. Okay, our contract compiles. Let's now write the test. I'll rename counter to hack t Sol and also rename the test contract to hack test. Instead of importing the counter, we'll import the hack contract and then inside our test contract, I'll also import the console from Forge std. So copy this, paste it here, and then first we'll initialize the hack contract.
00:08:59.030 - 00:09:50.998, Speaker A: So type hack public hack and then we'll write the function to set up the test function set up public. Then we'll initialize the hack contract. Hack is equal to new hack. Next we'll write a function to test our poem function function test poem public and then we'll call the function hack poem. When we call this function, let's send 100,000 E. So I'll say value 100,000 times one e 18 okay, let's execute the test. So when we call the function pone, we should see that get virtual price will be higher inside the receive function compared to what we get when we call the function, get virtual price inside the poem.
00:09:50.998 - 00:10:52.422, Speaker A: So I'll open my terminal, clear the logs, and then we'll be running our test on the main net fork I'll copy the address for the fork URL that I got from alchemy API. I'll paste this command sending the fork URL to the alchemy API and then we'll execute the test by calling forge test I'll put in four b's, bbb and this will print out a lot of logs when we run the test. Then we'll say fork URL is fork URL from what we set above and then hit enter. Okay, our test finished executing and you can see that there is a lot of logs. This is because if I scroll up I put in four B's and this means that it will print a lot of logs for this execution. What I am interested in in the virtual price before removing liquidity and the virtual price during removing liquidity. Let's take a look before removing liquidity.
00:10:52.422 - 00:11:24.514, Speaker A: It is this amount that you see over here. And during when we're removing liquidity, you can see that the virtual price has gone up by a little bit. You see a five over here and you see a nine over here. What this means is that if we target another contract that depends on virtual price and then call that contract while we're removing liquidity, we'll be able to exploit that contract. That will be the next step. Okay, I'm back in my hack contract and what we're going to do next is write an example contract to target. A contract to exploit inside the function received.
00:11:24.514 - 00:12:11.590, Speaker A: So first I'll write a target contract that we'll be using for this example. So I'll say contract target. And let's imagine that this target contract, you'll be able to stake the LP tokens and you'll get some kind of rewards where the rewards is calculated based on the value returned by get virtual price. So first I'll copy these two contract addresses and instead of Lp token here I'll name it token, I'll rename it to token. So let's imagine that this contract has three functions. A function to stake the tokens, a function to unstake the LP tokens, and some kind of function to get rewards based on the amount of tokens that we stake. Function get reward.
00:12:11.590 - 00:12:41.440, Speaker A: Okay, let's fill in the details. So stake it would take in the amount of Lp tokens to stake. This will be external. And when we call this function, let's say that it transfers the token transfer from from message sender to this contract. Address this for the amount from the input. And then let's say that it keeps track of the amount of tokens that is staked. So I'll create a mapping from address to un.
00:12:41.440 - 00:13:17.734, Speaker A: This will be public on a main balance up. Then when we stake it will update the balance up for message sender incremented by amount. Okay, scrolling down. When we unstake we'll be able to unstake the amount. This will be external. When we unstake, we'll first update the balance of message sender, decrement it by amount and then we'll transfer the token token transfer to message sender for the amount. Okay, the last function we'll write is getrewards.
00:13:17.734 - 00:13:53.778, Speaker A: So this will be external returns. Let's say that it just returns the amount of tokens, amount of rewards, tokens that we earn. We'll say that the amount of rewards token that we earn is we multiply the amount of stake by the value of shares and the value of shares. We get it by calling get virtual price on the curve pool. So say unit reward is equal to balance of message sender times. Get virtual price pool get virtual price. Now both the LP tokens and get virtual price has 18 decimals.
00:13:53.778 - 00:14:38.680, Speaker A: So what we'll have to do is divide by ten to the 18. If we multiply balance of, which has 18 decimals, and get virtual price which has 18 decimals, this multiplication now has 36 decimals. So to get it back down to 18 decimals again, we'll have to divide by ten to the 18, and then we'll have some code to transfer the reward. Code to transfer reward. But for this example, we'll just omit it, skip code to transfer reward, and for this example, we'll just return the amount of reward that was calculated. Okay, let's try compiling this contract. Clear the logs, and then type forge build.
00:14:38.680 - 00:15:21.966, Speaker A: Okay, the contract compiled successfully. So let's move on to write some exploit inside the hack contract. So, scrolling down to the hack contract. First I'll store the target contract inside the hack contract. So I'll say target private immutable target, and then define a constructor, constructor, we'll take in the address of the target, and then we'll set the target target equal to target address of target. Now what we're going to do is before we call the function poem, we'll stake some LP tokens into the target contract. And then afterwards we call the function poem.
00:15:21.966 - 00:16:07.790, Speaker A: This will eventually call remove liquidity, which will call the receive function. Inside here we know that get virtual price is overpriced. So inside here we'll call the function get reward on target, and we should get more rewards than what we should have if we didn't do the exploit. Okay, so let's do that. So first I'll create a function called setup. This will be external, payable, and inside here we'll stake some tokens into the target contract. So first we'll need to add liquidity, copy this, paste it here, and then we'll transfer this Lp token over to the target contract.
00:16:07.790 - 00:17:20.202, Speaker A: So Lp token approve address of the target for the amount LP, and then call target stake Lp. Next we'll execute the poem function, and this will execute remove liquidity, which will execute receive, and inside here, let's get the reward by calling un reward is equal to target getreward. And then for this example, we'll log the amount of rewards that we earned if we had called getreward inside the receive function. So say console log, reward, reward, and then we'll also compare this amount of rewards that we would have got. Compare it to how much reward we will get if we called it after the read only reentrancy is done. So if we did not execute a readonly reentry, how much reward will we get? I'll copy these two code, then paste it here. Okay, let's update our test.
00:17:20.202 - 00:18:07.362, Speaker A: So back inside the hack test contract, I know that we'll need to deploy the target contract, so target public target, and then we'll deploy the target contract. First target is equal to new target, and now the hack contract takes in the address of the target. So inside the constructor, I'll pass in the address of the target. And then before we call the function poem, we will need to call the function setup to stake some of our LP tokens into the target contract. So here hack setup. Then when we call this function setup, we'll get some LP tokens from the pool, from the curb sd e pool, and then stake it. So let's send some ETH.
00:18:07.362 - 00:18:29.840, Speaker A: So I'll say value, we'll send ten e, ten times ten to the 18. Okay, let's try compiling the contract. I'll open the terminal, clear the logs, and then type forge, build it, and our contract compiles. So let's now run the test again. And our test was successful. Let's check the logs. Scroll up.
00:18:29.840 - 00:19:15.466, Speaker A: Before we remove liquidity, get virtual price, return some amount during the LP is being removed. So this will be the code that was executed. Inside the receive function, get virtual price was slightly higher. And when we call the function getreward, we would have gotten this much amount. Whereas after remove liquidity is done executing, and then we call getreward, we get a slightly less amount. This means that if we were to call getreward while the liquidity was being removed, then we would have gotten more rewards than calling getreward. After we called remove liquidity, that was an example of readonly reentrancy where we wrote our hack contract.
00:19:15.466 - 00:19:53.860, Speaker A: And then we called the curb st EF pool. We called it by calling the function remove liquidity. And then while the remove liquidity is executing, it transferred some EF, and then inside here, it executed the code inside the receive, which allowed us to call the target contract getreward. Getreward. The amount of rewards by calling get virtual price inside the curve pool. At this point, the virtual price is slightly higher than what it should be. So by the time all of this finished executing, we were able to get more rewards than what we would have if we did not execute the read only.
