00:00:00.330 - 00:00:56.474, Speaker A: Today we'll be coding the ERC 20 token. Total supply is the total amount of this ERC 20 token calling the function balance of returns the amount of ERC token that the account has. The holder of the ERC 20 token can call the function transfer to transfer his ERC 20 token over to a recipient instead of calling transfer directly. If the holder of the ERC 20 token wants to allow another spender to send his token on his behalf, then he'll call the function approved approving the sender to spend some of his token. How much is a spender allowed to spend from a holder? Well, you can find out by calling the function allowance. Once a holder of a ERC 20 token approves another spender to transfer his token on his behalf, then the spender can call the function transfer from transferring from the holder to another recipient for the amount. This is the interface.
00:00:56.474 - 00:01:20.546, Speaker A: Let's now write this code. So I'll scroll down. We'll create an ERC 20 contract. So I'll say contract. ERC 20 is IERC 20 and this means that this contract will implement all of the functions that are defined here. Let's start off with the state variables. We'll need to keep track of the total supply of this token, the total amount of token that was minted.
00:01:20.546 - 00:01:58.494, Speaker A: So you'll say un public total supply. When we mint new tokens, this total supply will increase, and when we burn tokens, this total supply will decrease. Next, we'll create a mapping from address to un which represents how much each user has a token. So we'll type mapping address to un. This state variable will be public. We'll call it balance up. When an ERC 20 token holder calls the function approved approving the sender to spend some of his token on his behalf, we need to save that somewhere in a state variable.
00:01:58.494 - 00:02:23.926, Speaker A: So we'll do that by typing mapping from address. So this will be the owner to another mapping from address. This will be the spender to amount. Here we're storing the data. Owner approves a spender to spend certain amount. We'll make this state variable public and we'll call it allowance. Next, we'll store some metadata about the ERC 20 token.
00:02:23.926 - 00:03:15.270, Speaker A: Name, symbol, and decimals. So we'll type string public name is equal to I'll name this test symbol string public symbol is equal to I'll name this test with all capitals and decimals. Un eight poly decimals is equal to most ERC 20 tokens have a decimal of 18, so we will also say 18 over here. Decimal means how many zeros are used to represent one ERC 20 token. For example, US dollars has two decimal places, so 100 cents is equal to $1. In the same way, decimal equals 18 means ten to the 18 is equal to one of this token. Now, if you try to compile this contract right now, you'll see that the compilation fails.
00:03:15.270 - 00:04:16.570, Speaker A: This is because we have not implemented these functions yet, so we'll copy all of this function and then implement it. Let's start with the easy one. Transfer this function will transfer the amount of token that message sender has over to a recipient. When we transfer a token from message sender to the recipient, we want to update the balance of so we'll do that by saying balance of message sender. We want to subtract the amount so we'll say minus equal to amount and we want to increment this amount to the recipient. So you'll say balance of recipient incremented by amount. When the function transfer is called for the ERC 20 standard, we need to emit the event transfer logging the sender which will be message sender.
00:04:16.570 - 00:05:17.780, Speaker A: The recipient will be recipient from the input and amount. And lastly, we need to return a boolean and we'll return true. This means that the function to this call was successful allowance we don't need this function since we already have it inside the state variable, and the next function that we will work on is approve message sender will be able to approve a spender to spend some of his balance for the amount. So we'll do that by saying allowance of message sender to spender is equal to amount. Message sender is allowing the spender to spend amount of his token. We also need to emit the event, so we'll say emit approval message sender to spender amount and we also need to return a boolean. If this function executes correctly, there is no error, so we'll return true.
00:05:17.780 - 00:06:17.346, Speaker A: And the last function that we need to write for this ERC 20 contract to be complete is transfer from this function will transfer some token from sender to recipient for the amount from the input, and this function can be called by anyone as long as the sender has approved message sender to spend his tokens. So the first thing that we'll do is deduct the allowance by typing allowance of the sender to message sender deducted by amount. Notice that in solidity 0.8 overflows and underflows cause an error to a function. So if sender has not approved message sender to spend this token, then this part of the code will fail. Since we're transferring the tokens, we'll update the balance of sender and recipient. By typing balance of sender, we're sending from the sender to the recipient.
00:06:17.346 - 00:07:00.766, Speaker A: So we'll decrease the balance of the sender and we'll increase the balance of the recipient. And again for transfer from, we also need to emit the event transfer and this will be from the sender to recipient for the amount. And lastly, we need to return true, meaning that this function executed correctly without any errors and that completes the ERC 20 token contract. If we hit compile notice that it compiled now. So far there is no way to create new tokens. This function is usually called mint. We have not implemented the function to mint new tokens.
00:07:00.766 - 00:07:32.986, Speaker A: Usually this mint function is restricted in some way. For example, you can only mint tokens in exchange for sending some EF. Or maybe only the owner of this contract can mint some tokens. For this example, we'll keep it simple and we will allow message sender to mint any amount of tokens. So I'll scroll down and then we'll implement the function mint. So I'll say function mint for the input we'll pass in the amount to mint, so say unit amount. This function will be external.
00:07:32.986 - 00:08:07.720, Speaker A: When this function is called, we'll increment the balance of message sender by the amount. Since we're creating new tokens, we also need to increment total supply. So we'll say total supply incremented by amount. We'll emit the transfer event by typing emit transfer. We're not sending existing tokens from another account. Here we are creating new tokens. So for the mint, we'll set the sender to address zero.
00:08:07.720 - 00:08:41.006, Speaker A: The recipient is message sender. The amount that was transferred is the amount that was minted. This line of code means from address zero transfer over to message sender for the amount amount. In other words, we are creating new tokens. Lastly, we will write the function to burn mint means create new tokens, whereas burn means destroy the tokens from circulation. So we'll say function burn unit amount. This function will be external.
00:08:41.006 - 00:09:18.970, Speaker A: We'll copy this code, paste it here, and instead of increasing the balance of message sender, we'll deduct the amount. Since we're destroying tokens, we'll deduct it from the total supply, and then for the emit event, we'll transfer it from message sender over to address zero for the amount amount. These two functions are not part of the ERC 20 token standard, but you'll usually see a function for mint and burn in most of the ERC 20 tokens. I'll hit Ctrl s to make sure that the contract compiles and we are done with the ERC 20 token contract.
