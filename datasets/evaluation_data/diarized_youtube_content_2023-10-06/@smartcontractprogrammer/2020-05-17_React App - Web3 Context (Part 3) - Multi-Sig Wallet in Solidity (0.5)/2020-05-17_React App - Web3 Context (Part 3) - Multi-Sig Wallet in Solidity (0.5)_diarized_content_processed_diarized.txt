00:00:00.410 - 00:00:50.746, Speaker A: In the previous video, we wrote some API functions that will connect to metamask and monitor the current account on Metamask. The goal of this video is to render the current account of Metamask on the user interface. So for example, when we change the current account of metamask from account number two to account number three, the account rendered here should also equal account number three. And the way that we're going to accomplish this is by storing the current account using react context and then rendering it. But before we get started, make sure that you're running truffle local blockchain by typing truffle develop. And you've also deployed the multisave wallet contract by typing migrate. And make sure that you also copy the build file from the Truffle project into the React project.
00:00:50.746 - 00:01:36.700, Speaker A: And here in another terminal, I've started the React dev server by typing NPM start. All right, so that's the setup that you need to do before we get started. Over here on the left you can see that I've created a folder called context, and then inside it I've created a file called Web three TsX. And it's important to note that this file extension is not Ts but TsX. And for all react components you'll have to use the extension TsX inside web3 TsX. We'll first import some functions from react, and I'll explain what these functions are used for as we go along. We're also going to need web3.
00:01:36.700 - 00:02:26.310, Speaker A: Lastly, we're going to need the subscribe to account function from the API web3 file. And this is the function that we wrote to monitor the current account of Metamask. The first thing that we'll do is declare the state that we're storing. So here we're saying that we're going to store the account as a string and we'll also store web3 as either an instance of web3 or null. And here we're saying web3 or null because when we first initialize the app, we won't have an instance of web3 until the user unlocks their account. So this value of web3 will be null until the user unlocks their account. We'll declare the initial state as account being an empty string and the web3 instance being null.
00:02:26.310 - 00:03:24.480, Speaker A: Next we'll define some actions that can be performed on the state, and the only action that we need is the ability to update the account, and this action will be passed to the reducer which will update the state. So here we're saying that the type of action is update account, and when we update the account we'll pass in the new account and optionally we'll also pass web3. Here web3 is optional since when we unlock the account we'll have both the account and the web3. But when we update the account later on we only need the new account since we already have the web3 instance. Next we'll define the reducer it's going to take in the state and the action that we defined above. And when the action type is equal to update account. Here we'll say that web3 is equal to either the web3 that was given from the action or the current web3 from the state.
00:03:24.480 - 00:04:07.046, Speaker A: And we'll also get the new account from the action and then update the state. And if the action type is not equal to update account, we'll just return the current state. The next thing that we'll do is define the web3 context. And what you're seeing inside here is what other react components will have access to. So other components will have access to the state which stores web3 and the current account, and we initialize it as initial state. They will also have access to a function called update account which they can call to update the account. Now this isn't the actual function that's going to update the account, it is just a placeholder.
00:04:07.046 - 00:04:47.960, Speaker A: So that typescript doesn't complain. We'll also export a function called use web3 context, and by calling this function, other react components will have access to the state and a function called update account. In order for other react components to be able to call this function, we need to declare a context provider. So that's what I did over here. Any react component inside the provider will be able to call this use web3 context and then get the state and be able to call update account. First we initialize the state using use reducer. Next we'll define a function called update account.
00:04:47.960 - 00:05:38.300, Speaker A: The input account in web3 will fetch it from the API and then pass it to this function. And here we say dispatch update account and then pass in the data. By doing this, this will update the state. This is just basic react reducers. The way you pass context to other react components is by putting the context in the value. And here we're using use memo to tell react to only render this component when the state changes. The last thing that we'll do is define a react component called updater, and this component will monitor the current account of metamask and when it changes we'll reload the web page.
00:05:38.300 - 00:06:27.350, Speaker A: We'll first, get the state which stores web3 and account by calling use web3 context. We'll use the use effect hooked to call subscribe to account when the state changes. So once the user unlocks their account, we'll have an instance of web3. So we'll call subscribe to account and we'll pass in this callback. When there's an error, we will just console log it. And if the new account is not equal to undefined, and the new account is not equal to the current account, in other words, the account has changed, then we'll reload the web page by calling window locations reload. Now recall that subscribe to account returns a function to unsubscribe.
00:06:27.350 - 00:07:00.370, Speaker A: So we'll return it from the react hook here. And by doing this, react will call this function when this component is unmounted. Finally, this react component has nothing to render, so we'll return null. Okay, that completes the code for web3 context. But let's just quickly go over what we just did. We first declare the state that we're going to be storing in the web3 context. And what we're storing is the current account and the web3 instance.
00:07:00.370 - 00:07:50.494, Speaker A: Next, we declare how this state can change by writing a reducer. And the only way that the state can change is by the update account action, which will update the account and the web3 instance. We also declare that other react components will have access to the state and a function called update account by calling create context. And they'll be able to get the context by calling use web3 context. To use the web3 context, components have to be rendered under web3 context provider. So we declare this provider that's going to pass the actual state and the function update account. Lastly, we created a react component called updater which will monitor the current account of metamask.
00:07:50.494 - 00:08:32.030, Speaker A: And when the account changes, it will reload the web page. All right, so that's web3 context. Let's now write the code to render the context. The first thing that you need to do in order to use web3 context is open index TSX. And then we'll import the provider and the updater component. Next, we'll put web3 provider as a parent of app, and this will allow all react components inside app to have access to web3 context. And the last setup that we need here is to put web3 updater inside web3 provider.
00:08:32.030 - 00:09:43.186, Speaker A: So now this component will be monitoring the account of Metamask. And note that since this is using web3 context, this component has to come under web3 provider, we're now ready to render the account stored in web3 context. Since we initialized the account stored in web3 context to be an empty string, when we load this page, the account should be blank. First open app TSX and since this app component is rendered inside web3 provider, we have access to web3 context. And the way you get the web3 context is like this. We first import use web3 context from context web3 and we can get the current account stored in web3 context by calling use web3 context and the account will be stored inside state, and this account should be an empty string. So let's see hit save, and then let's check back on our browser.
00:09:43.186 - 00:10:29.750, Speaker A: You can see here that our account is rendering an empty string. If you go back to web3 context and then change the account to something like zero, x one, two, three, hit save. And you can see here that the account is now rendering zero x one, two, three. All right, so we know that our web3 context and our react app is now connected. Let's now try to write the code so that when we hit connect, it will unlock the metamask account and then render the current account of metamask over here. Back in app TSX, I've imported unlock account from API web3. Now, when you call an asynchronous function, you usually want to render like a loading state.
00:10:29.750 - 00:11:13.522, Speaker A: So for example, when we call connect to Metamask, the button will show like a loading user interface. And once that is done, we'll remove the loading animation. Back in app TSX, when the user clicks the connect to metamask button, we'll call the unlock account function. And since this is an asynchronous function, we'll render like a loading animation. Once unlock account completes, we'll remove the loading animation. Since this is a common pattern, I've created a component called useasync inside the components folder. The way you use this useasync component is by passing the async function.
00:11:13.522 - 00:12:17.750, Speaker A: In this case, we're passing unlock account and this function will return three things. The current state of the asynchronous function will be stored in a boolean value called pending. If the asynchronous function fails, it will be stored in a variable called error, and you can call this asynchronous function by calling the call function. When the user clicks on the connect to metamask button, we'll call the onclick connect function up over here, which we'll define later, and inside here we'll call the unlock account by calling call, and when we call this call function, the variable pending will be equal to true. So over here, back in the button component, we'll render a loading animation by saying loading equals pending. When the onclick connect function is called, we'll call the call function and pass in null. The reason that we're passing null here is because I'm not a typescript expert.
00:12:17.750 - 00:13:11.530, Speaker A: In this case, I don't want to pass any inputs, but I couldn't get typescript to not complain. So that's why I'm passing a null here and saying that there is no input. What's important here is that when you call call, it will return either the error or the data. Error is self explanatory, but for data, if there's data, it will return the web3 instance and the account. So here we'll say if there's an error, we'll just log it, and if there's data, we somehow need to update the account. And remember that we can get the function to update the account from the web3 context. So we'll get the function update count, and over here we'll say update account and passing in the data.
00:13:11.530 - 00:13:53.080, Speaker A: So that completes the UI to connect to metamask, let's now give it a try. Back in the browser, I hit connect to metamask, and since we're not logged into metamask, you can see that the metamask pops out. And you can also see here that the button is rendering a loading animation. So here, back in metamask, I'm going to type in my password and then hit connect. And you can see that the loading animation is gone and we're rendering the account from Metamask. Remember that we wrote web3 updater component which monitors the changes to the account. And if the account changes, then it reloads the web page.
00:13:53.080 - 00:14:32.620, Speaker A: Let's test that it works in our user interface. So I'm going to open Metamask and then change the account from account number three to account number two. And that was quick, but you can see that the web page reloaded. I think this is a good point to stop, and I'll put the link for the code in the descriptions below so that you can take your time to digest and fully understand how the code works. As an optional challenge, you can try monitoring the network of Metamask and then rendering the network over here again, thanks for watching and see you soon.
