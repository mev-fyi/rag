00:00:00.410 - 00:00:36.546, Speaker A: Hey, everyone. In this video, I'm going to show you how to code a multisig wallet. There are many ways to code a multisig wallet, but we'll be doing it in such a way that will cover these topics. And then afterwards, I'll show you two demos. One, to send ether to another account, and two, to call another contract from a multisig wallet. So, first of all, what is a multisig wallet? A multisig wallet stands for multi signature wallet, and it is a wallet that has many owners. To spend from this wallet, an owner would need to get approval from the other owners.
00:00:36.546 - 00:01:34.806, Speaker A: For example, here we have a multi signature wallet that holds some bitcoins, and this wallet is owned by Alice, Bob, and Carol. Let's say that in order to spend from this wallet, at least two of the owners have to agree. For example, Alice says, I want to withdraw one bitcoin, and Bob approves Alice to spend one bitcoin. So that's two owners that agree that Alice can withdraw one bitcoin, which satisfies the condition that at least two of the owners have to approve the transaction and Alice is able to withdraw one bitcoin. What happens if Alice cannot get approved by the other owners? So, like before, Alice says, I want to withdraw one bitcoin, and this time Bob says, nope. And Carol also says, no, Alice, you cannot withdraw one bitcoin. So in this case, we only have one approval, which is less than the two approvals required to spend from this wallet.
00:01:34.806 - 00:02:21.138, Speaker A: This is called a two out of three multisig wallet, since it requires the approval of at least two owners out of the total three owners. If there are five owners, a two out of five multisig wallet will require the approval of at least two owners. Likewise, a three out of five multisig wallet will require the approval of at least three owners, and a five out of five multisig wallet will require the approval of all five owners. Next, I'm going to explain how we're going to implement a multisig wallet with a smart contract. The way it's gonna work is like this. Let's say that Alice wants to withdraw one ether. She proposes a transaction that can be executed if at least two owners approve.
00:02:21.138 - 00:03:09.850, Speaker A: Bob agrees that Alice can withdraw one ether and approves Alice's proposed transaction. We now have the required number of approvals so any of the owners can execute this transaction. Now, since this is a smart contract, our multisig wallet will be able to do more than just send ether and be able to call other smart contracts from the multisig wallet. For example, Alice says I want to call that contract, and Alice gets the approval of Carol. Alice executes the transaction on the multisig wallet, and the multisig wallet calls the contract. These are the functions that a contract is going to need. First, the owner will have to propose a transaction that must be approved by other owners by calling this function submit transaction.
00:03:09.850 - 00:04:09.530, Speaker A: Next, the other owners can approve the transaction by calling confirm transaction. If the owner decides to cancel the confirmation, he can call this function revoke confirmation and finally, if enough owners approve the transaction, then they can call execute transaction and for each of the functions below we'll define a corresponding event. And finally, we'll define an event named deposit, and this event will be emitted when an ether is sent to this contract. Next, we'll define some state variables. First, we need to store the owners in an array of addresses. We also need to store the number of confirmations required to execute a transaction when a transaction is proposed. By calling the submit transaction function, we'll create a struct called transaction and then store the struct inside the array of transactions.
00:04:09.530 - 00:04:51.210, Speaker A: Inside the transaction. We'll store some basic information such as the address that the transaction is sent to, the amount of ether to send to the address. In the case that we're calling another contract, we'll store the transaction data that is going to be sent to that contract. We need to know whether our transaction is executed or not, so we'll store that as a boolean value. When an owner approves a transaction, we'll store that in a mapping from an address to Boolean. And finally, we'll store the number of approvals in a field called numconformations. So these are the minimum state variables that we need for this contract.
00:04:51.210 - 00:05:47.900, Speaker A: Let's now write the constructor that will initialize the state variables. The inputs for the constructor will be the owners of this multisig wallet and the number of confirmations required to execute a transaction. First, we will do some input validation and require that the array of owners is not empty. We should also require that the number of confirmations required is greater than zero and also less than or equal to the number of owners. Next, we'll copy the owners from the input into the state variables. So we'll first start with a for loop, and it's going to run from I equal to zero to I less than the length of the owners. We'll first get the owner at index I and then store it in a variable and make sure that this owner is not equal to the zero address.
00:05:47.900 - 00:06:39.420, Speaker A: Now we also want to check that there are no duplicate owners. So back at top we'll declare a mapping from address to Boolean, and this will tell if an address is an owner or not. And back in the for loop we can check if an address is already an owner. If not, we'll set is owner to true and then add the owner to the owner's state variable. After we're done initializing the owners, we'll set num confirmations required, and that completes the constructor. Next, we'll write the function for submit transaction. When an owner submits a transaction, they'll need to send the address that the transaction is for, the amount that is going to be sent to the address, and the transaction data that is going to be sent.
00:06:39.420 - 00:07:41.280, Speaker A: This will be a public function, and we only want to allow the owner of this contract to be able to call this function. So we'll define a modifier called only owner. The modifier only owner would check if the message sender is an owner of the multisig wallet by looking at the mapping is owner. If the caller is an owner, then we'll execute the rest of the function inside submit transaction first, we need the id for the transaction that we're about to create, and for the id I'm just going to use the current length of the transaction array. So that means the first transaction will have an ID of zero, the second transaction will have an ID of one, and so on. Next, we'll initialize a transaction struct and then append it to the array of transactions. Note that executed is set to false, and the number of confirmations is set to zero.
00:07:41.280 - 00:08:45.034, Speaker A: Lastly, we'll emit the submit transaction event with message sender, the current transaction id, and the inputs that was passed to this function. So once the owner submits a transaction, they'll be able to approve the transaction by calling confirm transaction for the input it's going to take in the ID of the transaction that is going to be confirmed. This function will be public. We only want the owner to be able to call this function, so we're going to append the only owner modifier. The owner should only be able to confirm a transaction that exists, so we're going to later create a modifier called TX exists. If the transaction exists, then it should not be executed yet, and also the owner should not have confirmed the transaction yet. So this means that the owner will only be able to confirm a transaction once these modifiers are not yet defined.
00:08:45.034 - 00:10:08.190, Speaker A: So let's now write the code, the modifier TX exists will take in the TX index as input. And how do we know if a transaction already exists? Well, we can simply know that a transaction exists by checking that the TX index is less than the length of the array of transactions. And how do we check that a transaction is not executed yet? We can do this by getting the transaction at the index and making sure that the field executed is false. And lastly, how do we check that a transaction is not confirmed by an owner yet? Again, we'll first start by getting the transaction at the index and then access the is confirmed mapping and then check that is confirmed for message sender is equal to false. To update the transaction struct, we'll first get the transaction at the index. Next we'll set its confirmed for message sender to true, and this will mean that message sender has approved this transaction. Once that's done, we'll increment num confirmations and finally emit an event confirmed transaction with message sender and the index of the transaction that was confirmed.
00:10:08.190 - 00:11:03.150, Speaker A: Once enough owners confirm a transaction, they'll be able to execute it. To execute a transaction, we'll need to pass the index of the transaction and this function will be public. Again, only the owner should be able to call this function. The transaction should exist and it should not be executed yet. To actually execute a transaction, we'll first get the transaction struct and then require that the number of owners that confirmed this transaction is greater than or equal to the minimum number of confirmations required to execute any transaction. If there are enough confirmations, we'll first set executed to true. Then we'll actually execute the transaction by using the call method and then check that the call was successful.
00:11:03.150 - 00:11:56.974, Speaker A: And finally emit execute transaction with the owner that called this function and the transaction that was executed. So that completes the code for execute transaction and I'll leave revoke confirmation as an exercise for you. I'll post the links to the exercise and the solutions in the description below. Finally, we need to define a fallback function declared as payable so that we can send ether to this contract. And when the fallback function is called, we'll emit a deposit event. Now for this example, we'll also create a helper function so that we can easily deposit into this contract when we run a demo in remix. So that completes the code for the multisig wallet.
00:11:56.974 - 00:12:34.430, Speaker A: Let's now deploy the contract and I'll show you some demo. I've compiled the contract. Let's now create a two out of three multisig wallet. The three owners of the contract will be these three accounts, which I already have prepared them here. So I'm going to copy the addresses and paste them here. And since it's going to be a two out of three multisig wallet for the Num confirmations required, I'm going to pass in two and then hit deploy. The first thing that we'll need to do is deposit some ether into this contract.
00:12:34.430 - 00:13:30.480, Speaker A: So I'm going to send one ether to the multisay wallet by calling deposit. Now I'm going to show you an example of how to send ether to another account and account that we're sending ether to is this account over here. And I've already prepared the inputs over here. So I'm going to copy the inputs and then paste it here. So we're going to be sending one ether to this address. And for the transaction data we're sending zero bytes. Since we're not going to be calling another contract and then hit submit transaction, we can check that a transaction was created by checking the state variable transactions at index zero.
00:13:30.480 - 00:14:17.120, Speaker A: And you can see here that we're going to be sending one ether to this address. And the number of confirmations so far is zero. And the transaction has not been executed yet. We need two confirmations. So we'll go ahead and confirm transaction zero, and then switch our account to owner number two, and then also confirm transaction. So when we check back on transaction zero, now the number of confirmation is equal to two and we can now execute this transaction. So we can call execute transaction on transaction zero.
00:14:17.120 - 00:15:04.800, Speaker A: And when we check back on our accounts, you can see here that the multisig sent one ether to this account. That was a demo of how to send ether to another account from a multisig wallet. Let's now look at how to call another contract. And for this demo, I created a test contract that we're going to call, and we're going to be calling this function, call me, which will increment the state variable I. And I've created a helper function that will generate the transaction data that's going to be sent to this contract. And the transaction data will allow us to call the callme function above with the input. One, two, three.
00:15:04.800 - 00:16:20.360, Speaker A: So I've deployed test contract and that's the transaction data that we'll be sending from the multisig wallet. First, I'm going to create a transaction that needs to be confirmed by other owners. So I'm going to pass in the address of the test contract, followed by the amount of ether that we're sending to this contract, which is going to be zero and then followed by the test data. So I'm going to copy the test data from, get data from test contract and then paste it here and then hit submit transaction. Now we need to confirm transaction. So owner one is going to confirm transaction number one and I'm going to switch the owners to owner number two and owner number two is also going to confirm transaction number one and then finally we'll execute transaction number one. Now checking back in our test contract and hitting I, we can see that the state variable I is equal to one, two, three.
00:16:20.360 - 00:16:42.890, Speaker A: So what happened here is that the multisig wallet called call me with the inputs one, two, three and then it updated the state variable and that completes a demo for how a multisig wallet can call another contract. That's all I got for this video. Thank for watching and have a nice day. Bye.
