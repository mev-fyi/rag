00:00:00.650 - 00:00:27.618, Speaker A: Today we'll be building another application in solidity. The application that we're going to be building is access control. This contract will manage roles assigned to accounts. Depending on the role, accounts will be able to call a function or be disallowed to call it. So let's get started. The first thing that we'll need to do is store whether our account has a role or not. And to do that we'll use a mapping from role to counts and from account to boolean.
00:00:27.618 - 00:00:58.106, Speaker A: For example, the role will be admin. The account will be Alice, and if Alice has the admin role, then Boolean will be equal to true. We'll type mapping the role. We'll store it in bytes 32. So we'll say bytes 32, and from there we'll need another mapping. So we'll say another mapping from address to boolean. I'll make this state variable public, and I'll call it roles.
00:00:58.106 - 00:01:37.206, Speaker A: Next, we'll define two roles. For this example, we'll define the role admin and define the role user. Now, why did we define the role as bytes 32 and not as a string? The role is bytes 32 because we're going to hash the name of the role, and we do that so that even if the name of the role is a really long string, it still hashes to bytes 32. And by doing that we'll save some guess. So to define the admin role, I'll say bytes 32. I'll make this variable private. Since we can recompute the hash of the role off chain, we don't need to store it on chain as a public state variable.
00:01:37.206 - 00:02:14.434, Speaker A: When we do store this variable as a public state variable, this contract will use a little bit more gas. By making it private, this contract will use a little bit less gas. This variable will not have to change. So we'll make this as constant. And usually for constants we name it with all uppercase. So I'll say admin is equal to catcheck 256 Abi encode, packed. The name of the role, I'll say admin, and we'll do something similar to create a role called user.
00:02:14.434 - 00:02:51.540, Speaker A: So I'll copy this and then paste it. The name of the role will be again capital user, and the string we'll replace it with from admin to user. These are the two roles that we'll be using for this example. But if you want other roles, go ahead and add more roles to this contract. Next, I'm going to write the function to grant role to account, and this will give you a better idea of how this roles nested mapping is used. Since we're going to be using this function both internally and externally, I'll first create an internal function. So I'll say function.
00:02:51.540 - 00:03:52.578, Speaker A: I can see that there's going to be a name collision for the function grant role for the internal and the external function, and to avoid that, I'll prefix this function with an underscore and call it grant role. This function will take in two inputs, bytes of the role and account assigned the role to address account. This function will be internal and we'll keep it as internal and not private, so that if you have another contract that inherits access control, they will be able to call this function grant role. If we declare this function as private, then the contract that inherits access control will not be able to call grant role. So that is why we're making this function internal over here. Sorry, this should be bytes 32. Now, to grant a role to an account, we'll have to update the roles mapping by typing roles.
00:03:52.578 - 00:04:54.806, Speaker A: The first key to this mapping is a role of bytes 32. So we'll pass this role from the input, and this will return another mapping that goes from address to boolean, so we'll say address will be account. Now we have access to the boolean, so we'll set it equal to true. This code over here means that to this role for this account, set it equal to true, in other words, grant role to this account. When this function is executed, we probably want to emit some events, so let's go ahead and define some events. So we'll say event grant role, and we'll log two parameters, bytes 32 role, and the address that the role was granted to address account. We also put index on both of these parameters so that we can quickly filter through the logs.
00:04:54.806 - 00:05:41.622, Speaker A: So here I'll say indexed, and for the account I'll also say indexed. While we're here, we'll also declare another event revoke row. So I'll copy this, paste it here. The parameters that will be logging is the same, but the name of the event will be revoke role. And lastly, when we call this function grant role, we'll emit the event emit grant role passing in the role, and the account that the role was granted to account from the input. So this will be the internal function of grant role. Let's now write the external version of this function grant role.
00:05:41.622 - 00:06:41.310, Speaker A: So I'll type function grand role. It's going to take in the same inputs as the internal function, bytes role and address account. Paste it here and this time this function will be external, and then we'll call the internal function grant role passing in the role and the account. We don't want anyone to be able to call this function. We only want the admin to be able to grant roles to other accounts. So what we'll do is create a modifier where if you have the admin role, then you'll be able to call grant role. So we'll create a modifier, name it only role passing in the role, and then say require roles of role for message sender.
00:06:41.310 - 00:07:42.630, Speaker A: And if message sender does not have the role from the input, then we'll say the error message is not authorized. If message sender has the correct role, then we will execute with the rest of the function. Scroll down and to the function grant role we'll add the function modifier only role admin. So now this function grant role external function can only be called if message sender has the admin role. Now, so far, when we deploy this contract, no one will be able to call any of the function since no one has the admin role. So we'll grant admin role to the deployer of the contract. So over here I'll say constructor, and inside the constructor we'll grant role admin to message sender, the deployer of this contract.
00:07:42.630 - 00:08:24.938, Speaker A: So that is why we created the internal function grant role. Inside here we'll say underscore grant role. The role will be admin, and we'll grant admin role to message sender. So now when this contract is deployed, admin role is granted to message sender. So the deployer of this contract will be able to call the function grant role to give other roles to other accounts. The last function that we'll write is revoke role. We have a function called grant role that gives role to accounts, but we also want a function that can take away roles from accounts.
00:08:24.938 - 00:09:21.760, Speaker A: To start off with, we'll copy this function, paste it here, and we'll rename the function to revoke role. It will still take in the same inputs the role and account, and only the admin should be able to call it. So we'll keep the function modifier the same, and then we're not going to be calling the grant role function, we'll want to revoke the role. So I'll copy this code over here, paste it here, and instead of setting the role to true, we'll set it to false. And instead of emitting the event grant role, we'll emit the event revoke role. Earlier I mentioned that these roles do not have to be public, and we made it private to save some guess. Now, to compute the hash of the admin and the user string, I've temporarily made these variables public.
00:09:21.760 - 00:10:18.770, Speaker A: Deploy the contract and then call admin and user so that I can get the hash once I know the hash now, I'll make this back into private, and we'll redeploy this contract, and then run some examples. I'll hit Ctrl s, and then for the contract I'll delete the previous one, scroll back up, and then deploy access control. We deploy this contract with this account. So this account will have the admin role, and to show you that I'll copy the address of this account, scroll down, open the contract, the role will be admin. So I'll scroll back up on the contract and then copy the admin role hash, paste it into roles and the address. I copied it over here. I'll cut this out, paste it here, and then call roles.
00:10:18.770 - 00:11:06.638, Speaker A: And you can see here that it returns true, meaning that this account has the admin role. For the next example, I'll grant a user role to some account, and then rebook it later. First I'll get the hash of the user role. So I'll scroll back up, copy this over here, paste it here, and then for the account we'll scroll up, select the second account, copy it. Now recall that grant role can only be called by the admin, and we know that the only admin that we have is the first account. So I'll switch back to the first account, scroll down, and then for the second input of grant role, we'll paste the account that we just copied, and then call grant role. The transaction was successful.
00:11:06.638 - 00:11:39.570, Speaker A: So if I copy these inputs over here, and then paste it into roles, and then call roles, you can see that it returns true, meaning that this second account has the role user. Next we'll revoke the role. So I'll copy all of the inputs from grant role, paste it into revoke role, and then call revoke role. Transaction was successful. And now if we call the roles, it returns false, meaning that the second account no longer has the user role.
