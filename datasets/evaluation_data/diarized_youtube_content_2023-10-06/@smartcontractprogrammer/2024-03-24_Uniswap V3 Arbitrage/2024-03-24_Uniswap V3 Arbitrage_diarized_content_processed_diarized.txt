00:00:00.320 - 00:00:28.938, Speaker A: Both in uniswap b two and in uniswap b three. During a swap, you can actually receive a token before you put the token in. We'll use this mechanism to build a smart contract that will do an arbitrage between two uniswap b three pools. For example, let's say that we have two uniswap b three pools di wef, with 0.3% swap fee, and another pool, di weth, with 0.05% swap fee. And let's also say that in the first pool, dai web with 0.3%
00:00:28.938 - 00:00:58.102, Speaker A: swap fee, weth is selling for 2000 dai. And in the second pool, with 0.05% swap fee, let's say that weth is selling for 2100 dai. Here we can execute an arbitrage to make some profit. To initiate an arbitrage to buy the wev from the first pool, we won't need to deposit any dai. This is because we're gonna do a flash swap on pool zero. Here we'll say that the first pool is pool zero and the second pool is pool one.
00:00:58.102 - 00:01:30.964, Speaker A: So we do a flash swap on pool zero without putting any die in. We'll be able to request for a weft. On the second step, we'll swap this weft that we got for die. This is executing a regular swap on pool one, and once we have die on the last step, we'll repay pool zero with the die. The profit from this arbor charge will be the die that we received from pool one. This is from swapping from step two, and then the dai that we repaid in step three. The difference will be the profit and dai.
00:01:30.964 - 00:01:59.352, Speaker A: Okay, let's write some code. To begin with, I'll first declare some interfaces that we're gonna need for this contract, you'll need the interface iswap router zero two to execute a regular swap with pool one. To initiate a flash swap, we'll directly call the pool. So we're also gonna need the interface for a uniswap b three pool. And I'll also declare two interfaces, IERc 20 and IUF. Okay, next, I'm gonna declare some constants. First, I'll declare the contract address of swap router zero two.
00:01:59.352 - 00:02:37.830, Speaker A: And then inside our contract, we'll initiate the iswaprouter zero two interface, passing in the address of the swap router zero two, I'll also declare some constants. Min square root ratio and max square root ratio. These constants will be handy when we directly call a uniswap b three pool, and then call the function swap. Okay, next, I'll declare three functions function flash swap. This will be our entry point. This will be the function that we will call to initiate the arbitrage. Next, I'll also create an internal function, and this will be a simple wrapper on calling the function exactinput single onswaprouter zero two.
00:02:37.830 - 00:03:15.120, Speaker A: Now, when we initiate the flash swap, we will directly call the uniswap b three pull contract and then call the function swap. Then we'll ask this pull contract to send us some tokens. When we do this, the pull contract will call back into our function. The specific function that we will need to implement is called function uniswap b three swap callback. This is the function that uniswap b three pull will call back into. And then inside here we'll execute our arbitrage and then send the amount of that was requested back over to the pool contract. Okay, so let's begin by writing the function flash swap.
00:03:15.120 - 00:03:59.676, Speaker A: This is the function that will initiate the arbitrage. For the input, I'll pass in the address of the first pool pool zero. And to identify the second pool I'll pass in three parameters, uint 24 fee one, and address token in and address token out. With these three parameters, we can identify a pool in uniswap okay, and the last parameter that we'll pass into this function is uint 256 amount int. This will be the amount that we'll have to pay to pull zero. Okay, next, we'll directly call the function swap on the pull contract. So to do this, I'll first use the interface I uniswap b three pool pool zero, and then we'll call the function swap.
00:03:59.676 - 00:04:38.776, Speaker A: To call the function swap. Let's look at the parameters that we will need to pass. So these are the parameters that we need to pass for the recipient. This will be the receiver of the token. Let's set this to address this zero four one. Is this trade going to be zero four one? If it is true, it means we're sending token zero and then receiving token one. Now, how can we figure out whether this trade will be a zero four one or a 140? So say Boolean zero four one is equal to well way that the token are identified as token zero and token one is by ordering the tokens by the address.
00:04:38.776 - 00:05:13.254, Speaker A: So for example, when we compare token in and token out, if token in is less than token out, then we know that token in is token zero and token out is token one. This will be a trade for zero four one if token in is less than token out. Otherwise tokenin will be an address that has a greater value than token output. So we know that token in will be token one and token out will be token zero. Okay, so that's 041041, the next input amount specified. And notice that this was an int 256. We're going to put token in.
00:05:13.254 - 00:05:47.726, Speaker A: So this will be int 256 amount in. Okay, next uint 160 square root price limit x 96. This will be the limit of the price that we're willing to accept. For this example, we'll keep it simple and then either set it to max or min depending on the direction of the trade. So this is where the constant that we declared over here becomes useful. Here we have min square root ratio and max square root ratio. When we execute the function swap and then pass in the square root price limit over here.
00:05:47.726 - 00:06:20.842, Speaker A: The value that we pass over here must be greater than this number and less than this number. So let's say over here uint 160 square root price limit x 96 is equal to. If this flop is at zero four one, then the square root price will decrease. Otherwise, if the trade is a 140, then the square root price will increase. So using this fact, we can figure out what we should put first. Square root price limit x 96. So say zero four one.
00:06:20.842 - 00:07:16.630, Speaker A: If it is a zero four one, then the price will decrease and the minimum that it can decrease to will be min square root ratio plus one. Otherwise, square root price will increase and the maximum it can reach to will be max square root ratio minus one. Okay, so now we figured out square root price limit x 96 square root price limit x 96. The last parameter that we will prepare is data. This will be the data that will be sent over to uniswap b three pull contract and then this data will be forwarded to the callback uniswap v three swap callback we will encode the data that we're going to need inside the callback here. So say bytes memory data is equal to abi dot encode. We'll encode message sender the message sender of to the function flash flow.
00:07:16.630 - 00:07:53.814, Speaker A: And this is because when this function is called, it's going to be called by the pool contract. So message sender will be the pool contract. And we want to know who the message sender is when this function flash swap is called. So we'll encode message sender message sender. Next we'll encode all of these data. So this will be pool zero v one token in, token out, amount in and we will also encode this 041041. And then over here I'll put data.
00:07:53.814 - 00:08:23.862, Speaker A: Okay, so that completes the function. Flash swap again. This function is going to initiate a flash swap to kickstart the arbitrage. When we call this function, it's going to call swaponpoolcontract and the pull contract is going to call back into the function. Uniswap b three swap callback for the inputs, we will receive three inputs. Amount zero, amount one, and data. Notice here that amount zero and amount one are int 256 and int 256.
00:08:23.862 - 00:09:00.914, Speaker A: When these numbers are negative, it means that the tokens came out from the pool. For example, if amount zero is negative, then this means that amount zero of token zero came out out of the pool. And if amount one is negative, this means that amount one of token one came out out of the pool. Here are the steps that we will implement inside this function. Let's first start by decoding this data. So I'm going to do is I'm going to copy this and then paste it here so that we know what we encoded, okay? And then say the first data that is encoded will be address message sender. So I'll call this caller.
00:09:00.914 - 00:09:23.626, Speaker A: The second one is the pool. So say address pool zero. Next one is fee one. Okay, I'm going to scroll back up. Fee one is encoded as un 24, so going back down, we'll decode this as Un 24 v one. Next is token in and token out. Address token in, address token out.
00:09:23.626 - 00:10:03.830, Speaker A: Okay, next is amount in, Un 256, amount in, and that's the zero four one. This was a boolean variable zero four one, and we'll decode this by using the function Abi dot decode. Decode the data and the types to decode it as are. I'll copy this, paste it here, and then remove the names. We're just keeping the types here. Okay, once we decode this data next, we'll call the internal function swap to do a swap on pool one. We have not implemented this internal function called swap.
00:10:03.830 - 00:10:37.138, Speaker A: What do we need to pass in for the inputs here? Well, if I scroll down to call the function exactinput single on swap router zero two, these are the inputs that we'll need to prepare. So here say token in. I'll leave it as a question mark for now. Token help. We also need to pass in the fee fee. These three parameters will identify the pool to swap on for the recipient that you see over here. We'll set it to this contract so we don't need to pass this as an input to our internal function as well.
00:10:37.138 - 00:11:43.312, Speaker A: Okay, amount in, amount in, and amount out minimum. We'll call this amount out min and for the square root price limit x 96, we'll set it as zero. By setting this as zero, the swap router will automatically set the square root price limit x 96 when it calls the pull contract to these values that you see over here. So we'll call this internal function swap and we'll ask this function to return the final amount of token that came out, say uint to 56. I'll call this buyback amount is equal to and then to calculate the profit, what we'll do is say unint 256 profit will be equal to the amount that came out from swapping on pool one buyback amount minus the amount that we'll have to pay back to pozio. This is encoded inside amount in, say amount in. So this is how you will calculate the profit.
00:11:43.312 - 00:12:28.972, Speaker A: Next, let's go back to this swap function and figure out what parameters that we'll need to pass into this function. So to begin with pool zero, what we did was we first requested token out and we promised pool zero to pay back with token name. So when this callback is called, the token that we have is token out. And on pool one, what we want to do is swap this token out that we have so far, token out with token in. So over here, token in will be token out from pool zero and token out will be token in from prozio. Fee is easy. This is the fee that is decoded over here.
00:12:28.972 - 00:13:08.152, Speaker A: This will be fee one amount in. How much amount do we need to pass in here? Well, when this callback is called, we got back out token out. And what is amount out over here? To figure this out, we will need to look at these two parameters. So remember I said that if these numbers are negative, then this means that this much amount came out from the pool. So to figure out what amount out is, we can look at this zero four one. And since the amount that came out will be negative, we'll need to turn it into a positive number. So declarative variable uint amount out is equal to.
00:13:08.152 - 00:13:49.076, Speaker A: This is the amount out that came from pool zero. So is this trade at 0410 for one on pool zero? Is this a swap for zero four one? If it is, then we know that the amount out is inside amount one that we get from the input over here. And this will be a negative number and we want to turn this into a positive number. So we'll put a minus and it is int 256. So we'll cast it into uint 256. Otherwise, if the trade was not a zero four one, then it would be a one 40, which means that the token out was token zero. So again you'll say yuint 256 minus amount zero.
00:13:49.076 - 00:14:37.886, Speaker A: Okay, so we now figured out what amount out is. Let's put this back over here. When we do a swap with pool one, we'll take this amount out that we figured out over here and then use it as amount in amount in first swapping with pool one amount out. Okay, how about amount out minimum? What is the minimum amount that we want to receive from pool one? Well, when we do a swap on pool one, we're going to put in token out relative to pool zero and then get back token in the minimum amount of token in that we'll need to repay. Pool zero is this amount in. So when we're swapping with pool one, the amount out minimum should be amount in. Otherwise there's no arbitrage profit.
00:14:37.886 - 00:15:52.614, Speaker A: Okay, next let's complete the internal function swap and then we'll come back to this function uniswap b three swap callback to finish repaying pool zero and then paying the profit over to call up. Okay, so first I'm gonna copy this and then I'll paste it here. For the input to this internal function swap, you'll need to pass in token in address token in address token out fee will be un 24 un 256 amount in and uint 26 amount out min. Then when we call this function, we want to return the amount that came out from the slot returns un 256 amount out inside here the first thing that we'll do is approve the router to spend. So say ierc 20 tokennin approve the address of the router for the amount amount in. Next we'll call the router and call this function. So I'll copy the struct and the function and then paste it here.
00:15:52.614 - 00:16:26.090, Speaker A: Let's start by preparing the parameter. So the parameter is I swap router zero two dot exactinput single params memory. I'll call it params is equal to I'll copy this again then paste it here. And this is the parameter that we will need to prepare. Token in will come from the input token in token out will also come from the input token out fee will also come from the input fee recipient. We want to send the token out to this contract. So this will be address.
00:16:26.090 - 00:17:00.002, Speaker A: This amount in will also come from the input amount in amount out minimum. This will also come from the input amount out min and square root price limit x 96. We'll set it to zero. Okay, once we have the parameters prepared, next we'll call this function exactinput single on the router contract. Router dot exactinput single pass in the parameters, and then it's going to return a single input called amount out. We declare this amount out as an output. So we'll just assign it.
00:17:00.002 - 00:17:31.153, Speaker A: Okay, so that completes the internal function swap. Let's go back to finish off uniswap b three swap callback. So we're not going to need this. And then the last part is to repay pool zero and pay the profit to caller. So here I'll say I erc 20 token in dot transfer to pool zero for the amount. Amount in. This is the amount that we need to repay pool zero.
00:17:31.153 - 00:18:03.902, Speaker A: And the profit will be Ierc 20 token name dot transfer to caller. This will be the caller to a function, flash swap to the caller, pay profit. And lastly, there's a chance that profit is zero. So we can require that this profit is greater than zero. Profit equals zero. Okay, that completes our arbitrage contract. So again, what this contract is going to do is it's going to initiate an arbitrage by first requesting for token out from pool zero.
00:18:03.902 - 00:18:37.800, Speaker A: Pool zero will call back into this function uniswap b three's fault callback. Inside here, we'll execute a trade with pool one, get the token out, and then from the token that came out, we repay pool zero. And then whatever that is leftover, we send to the caller. This will be the profit. So I wrote a test, and before we execute it, I want to quickly show you what's going on inside the test, we'll simulate our arbitrage between diref pool with 0.3% swap fee and die with pool with 0.05% swap fee.
00:18:37.800 - 00:19:17.964, Speaker A: The profit that we can make is really small. So the amount of dai that we'll send will be ten dai. And before we execute the arbitrage inside the setup, I'll first create an arbitrage opportunity. What it's going to do here is first it's gonna make weft cheaper on pool zero. And this is done by selling 500 waf on pool zero. Once wef is cheaper on pool zero, we execute our arbitrage and print out how much profit we made by sending ten dai inside my terminal, I'll execute the test and the test pass. So, for swapping ten dai worth of web, the profit that we got is roughly $0.24.
