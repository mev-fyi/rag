00:00:00.410 - 00:00:30.230, Speaker A: Starting from this video, we'll write the function first of all. So here I'm inside unisoft b three pool contract and the first thing that I'll do is copy this function definition, go over to our contract, and then we'll paste this function definition. I'll paste it here. Let's first talk about the inputs and the outputs. The inputs are recipients. 00:41 this means that token zero will come in and then token one will go out. If 00:41 is false, then the trade goes the other way.
00:00:30.230 - 00:01:17.300, Speaker A: Token one will come in and then token zero will go out. Amount specified is the amount specified for the trade. If this number is greater than zero, then this means that this swap will be at exact input, and this means that the user defined the amount of tokens to come in and the contract will calculate the amount of tokens that go out. On the other hand, if amount specified is less than zero, then the trade goes the other way. User has defined the amount of tokens to go out and this contract will calculate the amount of tokens that must come in. Square root price limit x 96 if the current square root price reaches this limit, then the trade will stop and data data to be used for the callback. Now, inside our contract we don't have any hooks, so I'll remove this data don't need an override, you don't have a node delegate call.
00:01:17.300 - 00:01:41.750, Speaker A: Now, however, we're going to put a reentry and clock over here. So we'll say lock. Then it's going to return two outputs, amount zero and amount one. Here, a positive number will indicate that a token must come inside this contract and a negative amount will indicate that the token is going to the user. It is being transferred to the user. So these are the function inputs and outputs. The next thing that I'll do is define some structs.
00:01:41.750 - 00:02:16.178, Speaker A: So going back to the unisoft b three pool contract, if I scroll up, these are the structs that are involved in the swap contract in the swap function. So I'm going to copy these and then head over to our contract, paste it here, and we're going to reboot some of the fields that we don't need. Fee protocol, we don't need it inside our smart contract. Liquidity start. We're going to need this block timestamp tick cumulative seconds per liquidity cumulative x one, two, eight and computed. Last observation. These are field related to the price oracle.
00:02:16.178 - 00:02:44.622, Speaker A: We don't have a price oracle, so I'll remove these fields so our struct swap cash only has one field liquidity start. This will be the liquidity at the beginning of a swap. Okay, let's move on. Swap state amount specified remaining. We're going to need this amount calculated. This will be the amount calculated by this contract. For exact in amount calculated will be the amount that goes out and for exact output, this will be the calculated amount that must come in the current square root price.
00:02:44.622 - 00:03:18.358, Speaker A: Tick fee growth global X One two eight this is needed for the fees. We'll keep it, but we won't touch on it till the last section of this video series protocol fees, we're not going to need it. And the current liquidity, we won't need this. Okay, the last chuck is step computations square root price start x 96 we'll need tick next initialized square root price next x 96 amount in amount out and fee amount we're going to need all of these field. Okay, so these are the struct. Moving on. What I want to do next is go to the swap contract.
00:03:18.358 - 00:03:54.342, Speaker A: And for the rest of this video I want to explain most of the code inside the swap contract except for the actual part that does the swap. So going to our contract, the first thing that we'll do is require that amount specified is not equal to zero. Require amount specified is not equal to zero. Okay, the next thing that we'll do is load slot zero. So say slot zero memory, we'll call it slot zero. Start is equal to slot zero. Slot zero is a state variable and we're loading this onto memory to state some guess.
00:03:54.342 - 00:04:32.114, Speaker A: Okay, the next thing that we'll do is check that square root price limit x 96 is a valid square root price. If we're doing the trade for a 00:41 then the price will be pushed to the left. So this means that the square root price limit should be to the left of the current square root price. And likewise, if we're doing a one 40 trade, then the current square root price will shift to the right. Sorry. Limit should be to the right of the current price. Say require is this a 00:41 trade 00:41 if it is, then the square root price limit x 96 should be to the left of the current square root price.
00:04:32.114 - 00:05:14.650, Speaker A: Slot zero start dot square root price x 96. And this square root price x 96 should be greater than the minimum and square root price limit x 96 should be greater than tick math min square root ratio. Otherwise, if this trade is a one 40, then we'll do something similar. So I'll just copy this, paste it here. The square root price x 96 should be to the right of the current square root price x 96 and this should be less than the max. And then we'll say that the error message is invalid. Square root price limit.
00:05:14.650 - 00:05:42.790, Speaker A: Okay, next we'll load the swap cash. So going back up, we're going to be filling this struct and the only field that we'll need to fill out is liquidity start. So going here, say swap cash memory, we'll name it. Cash is equal to swap cash. And the only field liquidity start will be liquidity from the state variable. Okay, next we'll create a boolean called exact input. Exact input.
00:05:42.790 - 00:06:26.278, Speaker A: Is this an exact input? Well, this will be an exact input if amount specified is greater than zero. Okay, what's the next thing that we need to do? Open the unison B three pool contract and then scroll up. So at the moment we're here, the next step is to initialize a struct called swap state. So I'll copy this and then go back to our contract. Paste it. Okay, so this is swap state. We initialize amount specified remaining as amount specified from the input amount calculated is initialized as zero square root price x 96 is the current square root price x 96 the current tick fee growth global x one to eight.
00:06:26.278 - 00:07:00.914, Speaker A: If this is a trade for a 00:41 then we initialize this to fee growth global zero x one to eight. Otherwise, we initialize it to fee growth global one X one to eight. This is a state variable that keeps track of fees. Have we defined this state variable yet? Let's scroll up and check whether we've declared a state variable. So scroll up. Okay, it looks like I have not declared any state variables for fee growth global. So let's declare them un 256 public fee growth global zero X one two eight.
00:07:00.914 - 00:07:29.046, Speaker A: And then we'll do the same for one x one two eight. Okay, go back to our swap contract to our swap function for our contract. We don't have any protocol fee, so we can remove this and liquidity. And liquidity is cash liquidity. So this will be the same as the state variable liquidity. Okay, what's the next step? So go back to the swap contract. The next step is to run some kind of for loop that will calculate the amount calculated inside the while loop.
00:07:29.046 - 00:08:05.410, Speaker A: It's going to calculate this part for this video. We will skip it. So say while true, do something and then put a comment to do. Okay, let's go back to unisor B three pool contract. So we're going to skip this while loop. And what is the next step? The next step is to update the current square root price x 96 and the current ticks. So inside our contract here, I'll say update the square root price x 96 and the tick say if state tick is not equal to slot zero start tick.
00:08:05.410 - 00:08:51.426, Speaker A: So what does this state mean? Well, if you go up, we declared it here and this state will be updated inside this while loop. How about slot zero start? Slot zero start. We declared it over here and this variable is not going to change. So what this means is that if the tick at the beginning of the trade is not equal to the tick after the trade, then we'll need to update. We'll update the current square root price and the tick. Slot zero dot square root price x 96 and slot zero tick is equal to the latest square root price and the latest tick will be stored in state. State square root price x 96 and state tick.
00:08:51.426 - 00:09:20.154, Speaker A: Otherwise the tick has not moved. But since there was a trade, the square root price may have moved. In this case, we'll just update square root price. Slot zero dot square root price x 96 is equal to state dot square root price x 96. Let's go back to the unison B three pool contract. So we finish this part. What's the next part? The next part is to update liquidity.
00:09:20.154 - 00:09:54.310, Speaker A: We'll update liquidity. So say if cash liquidity start is not equal to state liquidity, state liquidity will be the current liquidity after the trade. Cash liquidity start will be the liquidity before we did the trade. If this is not equal, then we'll update the liquidity. State variable liquidity is equal to state liquidity. Okay, let's go back to the unison B three pool contract again. And the next part is updating the fee growth global.
00:09:54.310 - 00:10:24.258, Speaker A: So go back to our contract. If you is taken from the token that comes in. So if this was a 00:41 trade, then token in is token zero. So the fee growth global that increased will be fee growth global zero x one two eight. So we'll update this. Fee growth global, zero x one two eight is equal to the latest fee growth global will be stored in state. State fee growth global x one to eight.
00:10:24.258 - 00:10:50.010, Speaker A: Otherwise token in was token one. So we'll update fee growth global one next one to eight. So this was update fee growth. What's the next step? Go back to the unisoft v three pool contract. The next step is this code. What I'm going to do is copy this code and then paste it here. This code over here is calculating the amount of token in and the amount of token out.
00:10:50.010 - 00:11:35.622, Speaker A: However, it's not clear why this condition 00:41 is equal to exact input will give the correct amount for amount zero and amount one. So I want to explain what's going on over here. What I've done here is laid out the four possibilities of combined with exact input, 41 can either be true or false, and exact input can either be true or false. In each of these cases, let's see what amount zero and amount one should be. In the case of 00:41 and exact input amount zero that's going to go into the pool will be the amount specified by the user minus the amount specified remaining. That was calculated from this contract. This contract is going to try to pull in amount specified, but if it cannot, then we're going to minus amount specified remaining.
00:11:35.622 - 00:12:08.966, Speaker A: How about amount one for one and exact input? Well, amount one, this will be the amount that will be calculated from this contract. This will be amount calculated. This will be the same case for a trade of one 40 and exact output. So when 00:41 is false and exact input is also false. When 00:41 is false, token in will be token one, and token out will be token zero. An exact input false means that the amount out was specified. Amount out is token zero.
00:12:08.966 - 00:12:52.286, Speaker A: So this value is known, specified minus remaining. What needs to be calculated is the amount that goes in amount one or token one. Notice that in the case of 00:41 equals to true and exact input equals to true. Or when 00:41 is false and exact input is false, we have the matching condition. Amount zero is specified minus remaining, and amount one is calculated. When we do a trade for one 40 and exact input, we're basically doing the same calculation as this, except we're flipping the token in and token out, token zero will be calculated, and token one will be specified. It's the same case as over here, but we're just flipping the tokens.
00:12:52.286 - 00:13:33.806, Speaker A: And likewise for 00:41 and not exact input, we're going to be flipping this situation. Amount zero will be calculated, and amount one will be specified minus remaining. Now, we listed all of the conditions and let's compare it with this code. So when 00:41 is equal to exact input, this is either both of them are true or both of them are false. Then amount zero will be amount specified minus remaining, and amount one will be calculated. Otherwise, when these two variables differ, then amount zero will be calculated, and amount one will be specified minus remaining. Amount zero is calculated.
00:13:33.806 - 00:14:23.534, Speaker A: Amount one is specified minus remaining. So this code over here is a short way of handling this situation. Okay, and the last step is to transfer the tokens. So we'll say if it is a 00:41 then the token that goes out is token one. And if it is going out, this number will be negative. So say if amount one is less than zero, then we'll type IERC 20 token one transfer to recipient recipient for the amount amount one is negative, so we'll cast it into positive number Un 256 minus amount one, and then we'll need to transfer token zero. Transfer token zero transfer from from message sender to this contract.
00:14:23.534 - 00:15:00.110, Speaker A: Address this for the amount amount zero. If this was not a 00:41 trade, then we'll do the opposite. Copy this code, paste it here. Token out will be token zero. So if amount zero is less than zero, then we transfer out token zero for the amount amount zero, and we transfer in token one for the amount amount one. Okay, that completes the swap function, except for the while loop that actually calculates the amount of token that either goes in or goes out. We'll work on this in the following videos.
00:15:00.110 - 00:15:10.730, Speaker A: For now, let's try compiling the contract. Sign my terminal type forge build okay, did our contract compile and our contract compiled successfully?
