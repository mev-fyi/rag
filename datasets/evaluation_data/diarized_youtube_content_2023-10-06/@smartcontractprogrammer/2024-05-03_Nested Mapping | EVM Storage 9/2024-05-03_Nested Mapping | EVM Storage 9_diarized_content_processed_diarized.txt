00:00:00.200 - 00:00:42.426, Speaker A: For our mapping from a key to a value where the value takes up exactly 32 bytes, then the EBM storage slot where the value is stored is given by taking the catch act 256 of the key and slot where the mapping is declared. But how about the case for a nested mapping? Let's say that we have a nested mapping from key zero to key one, and then from key one to a value. In this case, how do we compute the slot where the value is stored? And again, we assume that value takes up exactly 32 bytes. The slot where the value is stored in this case is calculated by taking a nested catch up to 56. Here, I'll show you an easy way to remember. Let's start with a simple mapping. Not a nested mapping, just a simple mapping from key to value.
00:00:42.426 - 00:01:03.972, Speaker A: So in this case, the slot where the value is stored is given by this. So I'll just paste it here. This is our starting point. We first replace this key with key zero. This is the first key for a nested mapping and then we take another ketchup 256. And then for the first input we'll put in key one. This will be the slot where the values start.
00:01:03.972 - 00:01:48.602, Speaker A: Take the ketchak 256 of key one. With it you take the ketchak 256 of key zero and slot where the mapping is declared. The difference in how the slot is calculated between a nested mapping and a simple mapping is that a nested mapping takes the kecak 256 and then takes another catch up 256. Let me give you an example. Let's say that we have a mapping from address to another mapping address, and then to un 256 I'll call this map and let's say that we have address zero and we have address one and we have some kind of value stored. To calculate where this value will be stored, we will first compute this part. And to compute this part, we'll first need to compute this part.
00:01:48.602 - 00:02:15.224, Speaker A: Key zero will be in this case address zero slot where the mapping is declared. This mapping is declared in slot zero. So here we'll put in a zero and key one. Key one will be address one and this will be the slot where the value is stored. Let's actually test this by using assembly to calculate the slot where the value is stored. First I'll initialize some constants. Address one, address two, and address three, and then fill in the map.
00:02:15.224 - 00:02:53.954, Speaker A: Mapping from address one to address two will store eleven. Mapping from address two to address three will store 22, and mapping from address three to address one will store 33. We'll be using the values stored in this mapping for our next example. So I'll create a function test nested mapping. It's going to take in two inputs the two keys that will identify the value for the mapping address key zero and address key one. And this will return the value that is stored in this mapping, which is unit 256. We will use assembly to get the value that is stored in a slot.
00:02:53.954 - 00:03:30.492, Speaker A: Next I'll write the code to calculate the slot where the value is stored. So I'll copy this and then I'll paste it here. We'll write the code for the in our catch act 256 first and then we'll write the code for the outer catch Act 256. So let's say bytes 32. The inner one I'll call it s zero is equal to take the cat check to 56 of key zero and the slot where this mapping is stored is in slot zero. So I'll say uint 256 and then zero. Now you'll need to abi encode this parameter.
00:03:30.492 - 00:04:06.014, Speaker A: So I'll say abi dot encode t zero and unt 256. So this code will calculate the inner ketchup 256. Next we will get the outer ketchup 256, say bytes equals catch act 256, abi dot encode. And then for the first input we need key one. Key one will be from the input key one, and the second input will be the inner catch Act 256 which we computed over here. So I'll say s two. S one will be the slot where the value is stored.
00:04:06.014 - 00:04:44.298, Speaker A: To get the 32 bytes that are stored in the slot we'll use assembly b is equal to sload s one and I'll name this output as un 256 b. Okay, let's try deploying this contract. I'll hit control s to compile a contract and then we'll deploy the contract. First I'll get the values for address one, address two, and address three. Next we will call this function test nested mapping and try to get these values. Let's try getting eleven. First I'll copy address one for key zero and address two for key one call the function and I get a eleven.
00:04:44.298 - 00:05:03.734, Speaker A: Let's try getting 22, copy the address of address two for key zero and copy address three for key one call the function, I get a 22. And lastly we will try to get 33. Key zero is Azure three and key one is Azure swan. Call a function and I get a 33.
