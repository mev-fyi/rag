00:00:00.330 - 00:00:29.138, Speaker A: In this video, I'll show you how to check for overflows and underflows using assembly. And I'll also show you how to do fixed point math. These are concepts that we'll need to understand to understand the code for binary exponentiation. Okay, so first let's start with overflow. So here I have a function called uad, and it's going to add two numbers, un x and un Y. And it's going to return the sum unz. In solidity, zero point overflows and other flows were a thorough error.
00:00:29.138 - 00:01:03.586, Speaker A: However, inside assembly, this is not the case, so we'll need to manually handle it. To check for overflow when we're adding, let's first add the two numbers x and y. So say z is equal to add xy. Okay, when we add x and y, this resulting sum may have overflowed. So how do we check that this z did not overflow? To check that z did not overflow, what we need to check is that z is still greater than or equal to x. If z did indeed overflow, then it will wrap around and become less than x. We'll say if less than.
00:01:03.586 - 00:01:43.390, Speaker A: If z is less than x, then we know that z overflowed. So we'll revert with revert. Okay, so this is an example of how to check for overflow when we're adding two numbers using assembly. How about the case for when we multiply two numbers to check whether the product of two numbers overflowed or not? What we need to do is divide the product by one of these numbers and see if it equals the other number. So what we're going to do is multiply x and y, and that will give us the product z. And then to check for overflow, we would divide by x and see if it equals y. So what I mean here is we first multiply x and y.
00:01:43.390 - 00:02:06.594, Speaker A: Say z is equal to mo x y, and then we'll compare z divided by x with y. So say div z with x. And we want to check that this is equal to y. So say equal equal y. If these two numbers are equal, this will return a one. Otherwise, if it is not equal, then it will return a zero. We want to throw an error.
00:02:06.594 - 00:02:31.494, Speaker A: If this equality returns a zero, so say is zero and then wrap it in. If is zero, then rebirth. If this condition is not true, then this will return a zero and then is zero. Zero will return a one. So then we would throw an error. This is the basic idea of how we would check for overflow. When we're multiplying two numbers.
00:02:31.494 - 00:02:54.590, Speaker A: However, there's an edge case here. We're dividing z by x. But what if x is equal to zero? So we'll need to handle this case. So say switch x case zero. If x is equal to zero, then we know that multiplying x by y is also equal to zero. So we'll type z is equal to zero. Otherwise default.
00:02:54.590 - 00:03:21.082, Speaker A: Otherwise we know that x is greater than zero. So we'll paste our code inside here. Okay, so this is how you will handle overflow when we're multiplying two numbers. And this includes the edge case of when x is equal to zero. The next topic that I'm going to discuss is fixed point math. Fixed point math means that we'll use some of the digits to represent decimals. For example, let's say that 100 represents one.
00:03:21.082 - 00:03:57.254, Speaker A: Then if another number x is equal to 90, then x will represent zero point 990 divided by 100 is equal to zero. Nine. For this example, what I want to show you is how to round a fixed point number. So for example, we have x equal to 90 and the base equal to 100. This number 90 is closer to 100 than zero. So if we were to round this number, we expect z to be equal to 100. However, if we simply divide x, which is equal to 90 by the base 100 and then multiply by the base again, then this will be equal to zero.
00:03:57.254 - 00:04:29.650, Speaker A: However, what we want for rounding, since x is closer to 100, we want the return value z to be equal to 100. We can accomplish this by first dividing the base B by two and then adding it to x. And then afterwards we carry out this operation. Divide x by the base B and then multiply it back by the base B again. For example, let's say that x is equal to 90. Again, half of the base base is 100, so half of that will be equal to 50. Add this half to x, 90 plus 50.
00:04:29.650 - 00:04:51.482, Speaker A: This will be equal to 140. And now let's carry out this operation again, 140 divided by 100 the base, and then multiply by the base. We get 100. So that's what we wanted. X now rounds to 100. This is one of the math that we'll be using for the binary exponentiation. Okay, so let's write this in code.
00:04:51.482 - 00:05:17.330, Speaker A: So say let half is equal to half of the base. So say div b by two. Next, we'll add this half to x. Z is equal to add x with half. Okay, and then we carry out this operation. So I'll copy this and paste it here and then change x to z. So this was an example of how to round fixed point numbers.
00:05:17.330 - 00:05:44.810, Speaker A: Another example that I want to show you is how to check for underflow when we subtract x from Y. How will we check for underflow inside assembly? Underflow when we're doing a subtraction only occurs if x is less than y. So all we have to do is check that x is greater than or equal to Y. So to do that, we'll say if less than. If x is less than y, then we know that an underflow will occur. So we'll revert. Revert.
00:05:44.810 - 00:06:15.278, Speaker A: Otherwise we'll return the difference. G is equal to sub xy. Okay, so this is the example of how to check for underflow when we're subtracting two numbers using assembly. The last example that I'll show you is how to do fixed point multiplication. And for this example, we also check for overflow. Make sure that multiplying x times y does not result in an overflow. Let's say that we wanted to multiply two numbers, nine times two, which is equal to 18.
00:06:15.278 - 00:06:50.142, Speaker A: How do we do this using fixed point numbers. So let's say that the base is equal to 100. So this means that 100 represents a one, x is equal to 900. So this means that this represents a nine, and y is equal to 200. So this represents a two. If we simply multiply the two numbers x and y, then we get 900 times 200, which is equal to 180,000. Now, to get back the number representation, we need to divide this 180,000 by the base 100, and we get 1800 back.
00:06:50.142 - 00:07:30.842, Speaker A: But what we actually needed, the correct answer was 18. And we don't get 18 back when we multiply two fixed point numbers. This gave us some extra digits that came from multiplying the bases. When we multiply 900 times 200, what's actually happening is we're doing nine times the base, times two times the base, and this is where the extra two zeros are coming from. So to fix this, what we need to do is after we multiply x times y, so say G is equal to x times y. Inside here, this will have two bases. So we need to divide by the base to remove the extra base.
00:07:30.842 - 00:08:04.486, Speaker A: So when we do this, what we're going to get is 900 times 200 divided by 100. 900 times 200 will be equal to 180,000. So we divide this by 100, we remove the two zeros, and we get 1000. 801,800. When the base is equal to 100 represents 18, and we get the correct answer. Okay, so let's implement this encode to do multiplication with overflow check. We go up and then we will copy this code and then paste it here.
00:08:04.486 - 00:08:39.422, Speaker A: So we're multiplying x times y and then also checking for overflow. The last thing that we need to do is divide this product z x times y by the base B. We're doing this operation to remove the extra base. So say z is equal to div z by b and this completes the function for fixed point multiplication. These are all topics that we'll encounter when we write the code for binary exponentiation. Okay, let's try compiling the contract. I'll hit Ctrl s and the contract compiles.
00:08:39.422 - 00:08:59.306, Speaker A: Let's deploy the contract and call some functions. So deploy the contract and then let's call some functions. Let's start with addition. Let's add two and three and we get fight. Let's also check for overflow. So what we're going to do is add max un with one and we expect this function to fail. And it does.
00:08:59.306 - 00:09:35.922, Speaker A: Okay, let's next try the function sub. If we sub two from one, then we get a one back. How about if we try to subtract one from two and the function fails? Okay, next let's call the function fixed point multiplication. So if we multiply two by nine, so 200 by 900. Let's say the base is 100, then we expect the output to be 1800 or 18. Call the function and we get 1800 back. Okay, for the last example, let's try fixed point rounding.
00:09:35.922 - 00:09:57.540, Speaker A: So let's go back to our example. So let's say that the base is 100 and x is 90. If we round x then we expect the output to be equal to 100. Call the function and we get a 100 back. How about if we try 40, then we expect the answer to be equal to zero. Call the function and we get a zero back.
