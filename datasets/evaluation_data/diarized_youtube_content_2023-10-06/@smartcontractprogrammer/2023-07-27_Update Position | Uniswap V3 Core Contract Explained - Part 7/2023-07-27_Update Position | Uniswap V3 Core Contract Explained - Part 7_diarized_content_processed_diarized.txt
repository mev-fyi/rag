00:00:00.250 - 00:00:29.698, Speaker A: In the previous video we started working on the function mint. And then we also started working on the function modify position. In this video we will start working on the function modify position. In particular what we're going to do is I'm gonna open the unisoft b three pool contract and inside the function modify position. There is another internal function called update position. So in this video I'll explain some of the code up until here. Okay so the first thing that it does is call the function called check ticks.
00:00:29.698 - 00:01:07.214, Speaker A: And what does this function do? Here's the function check ticks. This function simply checks that tick lower is less than tick upper and that tick lower is greater than or equal to the min tick. And lastly it checks that tick upper is less than or equal to the max tick. Okay so let's create the same function inside our contract function check tick. It's going to take in two inputs. Int 24 tick lower and int 24 tick upper. This function will be peer and we'll require that tick lower is greater than tick upper.
00:01:07.214 - 00:01:53.778, Speaker A: Then next we'll check that tick lower is greater than or equal to the min and tick upper is less than or equal to the max tick. The min tick and max tick is defined inside here tickmath sol inside library. You can see it over here. So we'll need to import it inside our clamp contract import from lib import tickmath sol and now we can say require tick lower is greater than or equal to tickmath min tick. And we'll do something similar for tick upper. Tick upper is less than or equal to max tick. This function check tick should be check ticks with an s.
00:01:53.778 - 00:02:29.222, Speaker A: Okay let's go back to our function modify position. Then we'll call check ticks. The ticks to check are params tick lower and params tick upper. Okay what's the next thing that we need to do? Let's go back to unison b three pool contract and then go back to the function modify position. So the next thing that it does is load slot zero to memory. And why is this doing it? Well this is because reading directly from storage costs a lot of gas. So by first loading it onto memory you'll be able to save some gas.
00:02:29.222 - 00:03:08.870, Speaker A: So this is why it's loading slot zero into memory. And then we'll call the function update position passing in some parameters. Let's do that. Also inside our code slot zero memory underscore slot zero is equal to slot zero from storage. And then we'll call the function update position. This function we have not defined yet. Then the parameters to pass are params owner, params tick upper, params tick lower, params liquidity delta.
00:03:08.870 - 00:03:47.218, Speaker A: This liquidity delta represents the amount of liquidity that is being added or removed. And lastly, slot zero from memory tick calling this function will return the position. So say position which we've declared over here as position info storage position okay, and the rest of the code inside modify position. I'll cover this in another video. In this video, let's move on to the function update position. Let's go back to a unisop b three pool contract and look for the code for the function update position. Okay, here it is, a position in unison.
00:03:47.218 - 00:04:24.570, Speaker A: B three means that some owner puts some liquidity in between two ticks tick lower and tick upper. And when the owner either adds or removes liquidity, this internal function update position is called, that is the high level overview of this function. So there are a couple of things that's going on inside this function. First, it's going to get the position. The position is defined by the inputs owner tick lower and tick upper. And then it's going to store the state variable fee growth global zero x 128 and fee growth global one x 128. These are state variables used to track fees.
00:04:24.570 - 00:04:48.386, Speaker A: Fees will be covered in the last section of this video series. So moving on. For now we'll ignore fees. We'll also ignore price oracle, and we'll also ignore this part of the code. For now tick bitmap is used to get the next tick when we do a swap. So for now we will also ignore this. Some calculation on the amount of fee that was generated inside the ticks we also ignore.
00:04:48.386 - 00:05:52.350, Speaker A: However, we'll look into the function's position update. Okay, so I'm going to scroll up and then we'll also implement the same function function update position inside our contract. So here I'll say function update position parameter it's going to take is the address owner int 24 tick lower, tick upper liquidity delta and the current tick. And this function is private returns position info storage name it position okay, the first thing that it does is gets the position and this will be a state variable. Say position is equal to positions get position is defined by the owner tick lower and tick upper. Have we defined the state variable positions yet? Well, let's check. I'm going to scroll up and we have, how about the function position get have we defined this yet? So I'm going to open the positions library and we have not defined the function position get yet.
00:05:52.350 - 00:06:48.730, Speaker A: Let's go to uniswap code inside library I'll go into position sol and then look for a function called get. Here it is the first input for this function get is the state variable mapping from bytes 32 to info. Info here means position info and then it's also going to take in the inputs owner tick lower and tick upper and the position is determined by the ketchup 256 hash of owner tick lower and tick upper. Okay so let's implement this function also inside our position library. So inside our position library say function get it's going to take in a mapping from bytes 32 to info. This will be a storage so a state variable. It's called self inputs address owner int 24 tick lower and int 24 tick upper.
00:06:48.730 - 00:07:49.074, Speaker A: This function will be internal. This function is read only view returns position info, storage state variable and name it position. And to get the position position is equal to it's a mapping from bytes 32 to info. So be inside self this is a mapping and the id of the position is determined by the ketchak 256 of avi encode packed owner tick lower and tick upper okay let's go back to our clam contract and then I'm going to scroll up to make sure that we can use the position library on the state variable position. Scrolling up so here I'll have to say using position four, mapping from bytes 32 to position info. And then we also say using position four, position info. Okay going back down to update position.
00:07:49.074 - 00:08:22.682, Speaker A: So now we've implemented this part of the code. Let's go back to unisoft B three pool contract and then the next thing that it does is get some state variables that are related to the fees. What I'm going to do for now is I'm going to skip this part. So what I'll do is say set these to zero for now. We'll ignore the price oracle. We also ignore ticks update for now and the last part we'll implement in this video is position update. So over here we'll say position update.
00:08:22.682 - 00:09:03.578, Speaker A: So we got the position here and then next we're calling position update passing in liquidity delta. And here I noticed that it's passing in fee growth inside zero x one to eight and fee growth inside one x one to eight. These are variables related to the fees for now. We'll just set it to zero zero, then make a note saying to do fees. Okay, so the next step is to implement the function update on position info. Let's go back to the positions library inside unisoft b three contract and look for a function called update. Okay, we'll do the same inside our position library as well.
00:09:03.578 - 00:09:41.702, Speaker A: Then create a function called function update. It's going to take in the inputs info storage self int one to eight, liquidity delta uint two, five, six, fee growth inside zero x one, two, eight, and fee growth inside one, x one to eight. This function will be internal. And what this function does is it would update position info. First, it loads the info into memory. So this is a gas saving technique. Info memory self is equal to self.
00:09:41.702 - 00:10:13.006, Speaker A: Next, it checks that if liquidity delta is equal to zero, then the liquidity inside info must be greater than zero. So say if liquidity delta is equal to zero, then require self dot liquidity greater than zero and say zero liquidity. Okay, let's scroll down. Tokens owned. This is a code that calculates the amount of fees that's accrued. So for now we'll skip this and then come to here. We'll ignore this part of the code for now.
00:10:13.006 - 00:10:53.662, Speaker A: And I want you to pay attention to this part of the code. If liquidity delta is not equal to zero, then it will update the position info. Self dot liquidity is equal to liquidity. Next, go back inside positions. You'll say if liquidity delta is not equal to zero, then we'll update self dot liquidity is equal to. Notice that liquidity delta is int, so it can be positive and it can also be negative. How about self dot liquidity? If I scroll up, self dot liquidity is always a positive number, so we'll need to handle this case.
00:10:53.662 - 00:11:36.890, Speaker A: If liquidity delta is less than zero, then we'll need to say two self dot liquidity minus cast this liquidity delta from our input to un, one, two, eight, and to make it positive since it's negative minus liquidity delta. Otherwise liquidity delta is positive. So say self dot liquidity plus cast it to un one to eight. Liquidity delta is positive, so say liquidity delta. What this part of code does is it updates self dot liquidity, which is a state variable. If liquidity delta is negative, then it will subtract it, and if it is positive it will add it. And that completes our code.
00:11:36.890 - 00:11:59.680, Speaker A: For now. Let's try compiling this contract. Open my terminal and then type forge build. Okay, I need to go fix tick math, so going back to clam, this should be tick math. Okay, let's try compiling again. There's a misspelling inside position. Fix the misspelling, try compiling again.
00:11:59.680 - 00:12:18.900, Speaker A: And our contract compiles. So in this video we started working on the internal function update position inside the unisoft b three pool contract and inside the function update position. There are some other codes that we have not implemented yet. In the next video we'll be implementing ticks update. See you in the next video.
