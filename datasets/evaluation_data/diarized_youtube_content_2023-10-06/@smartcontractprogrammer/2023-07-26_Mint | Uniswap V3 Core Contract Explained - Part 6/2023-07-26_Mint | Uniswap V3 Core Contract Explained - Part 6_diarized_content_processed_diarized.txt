00:00:00.250 - 00:00:33.526, Speaker A: When you add liquidity to unisoft b three pool, the function mint will be called. So today we'll be implementing this function inside our contract. So I'm going to expand our contract and inside here we'll create a function called function mint. What are the parameters that we'll need to pass to this function? Let's open the unisoft b three pool contract. Again, the parameters that we're going to need are recipient tick lower tick upper amount. This will be the amount of liquidity that we're adding and bytes data. This is the data to be passed to the callback, but we will not cover in our video.
00:00:33.526 - 00:01:12.274, Speaker A: So the parameters that we're going to pass to our min function are address recipient int 24 tick, lower int 24 tick upper and un one to eight amount. Again, this amount will be the amount of liquidity to add. Okay, what are the signature for the return type? The signature will be external and it has a modifier called log. This will be our reentrancy log which we will implement later. And it's going to return. Returns two outputs. Amount of token zero and amount of token one to add to increase the liquidity by this much amount.
00:01:12.274 - 00:01:51.818, Speaker A: Returns Un 256 amount zero Un 256 amount one. Now the math to calculate how much amount of token zero and token one to add to increase the liquidity by this much amount. We'll cover this math in a later video. In this video, what I'm going to do is mostly go over this code for the function mint. And then we'll go into the details in another video. Okay, so the first step is to implement the reentrancy modifier called lock. To implement this modifier, what we're going to do is scroll up and then I'll define a modifier, modifier called lock.
00:01:51.818 - 00:02:28.362, Speaker A: And it's going to check the boolean value unlocked inside slot zero. So say require slot zero unlocked else the error message blocked. And then we'll set slot zero unlock to false execute the code. And then lastly we'll unlock here again set unlock to true. Okay, so this is our reentrancy guard which we put it on the function mint. Let's go back to the unisoft b three pool contract and see what code we need to implement into our mint function. So the first thing that we'll need to do is require that the liquidity amount is greater than zero.
00:02:28.362 - 00:03:05.846, Speaker A: Require amount greater than zero. Else, let's say amount is equal to zero. And then it calls an internal function called modify position. A position is defined by the owner tick lower, tick upper and liquidity delta. The amount of liquidity in between tick lower and tick upper at a high level. When we call this function modify position, it will save this information as a position and it will also calculate the amount of token zero and token one that's needed to add this much liquidity. So I noticed that it returns three outputs by calling the function modify position.
00:03:05.846 - 00:03:39.438, Speaker A: So I'll say ignore the first output. The second output will be the amount of token zero that is needed. Int 256 AMount zero int and int 256 amount one int. Notice here that amount zero int and amount one int are not un, they are of type int 256. This means that these numbers can be negative. And why would it be negative? Well, it will be negative when liquidity delta that you see over here is negative. In other words, when we remove liquidity, liquidity delta will be negative.
00:03:39.438 - 00:04:10.942, Speaker A: And therefore these amount zero int and amount one int will also be negative. However, since here we're adding liquidity, amount will be positive. Liquidity delta will also be positive. So the amount of token zero and amount of token one that is needed to add liquidity will also be positive. So say modify position and then pass in the struct. Modify position params and inside here pass in owner will be recipient from the input recipient. Tick lower will be tick lower.
00:04:10.942 - 00:04:46.390, Speaker A: Tick upper will be tick upper and liquidity delta. Liquidity Delta this will be we need to cast amount into int two, five, six and then cast it to int one, two, eight. And to do that we'll have to say int two, five, six to cast amount to int two, five, six. We first need to cast it to u int two, five, six. Say uint two, five, six amount and then cast it to int two, five, six and then cast it to two int one two, eight. So far we have not implemented this function. Modify position.
00:04:46.390 - 00:05:13.770, Speaker A: We have not defined a struct modify position params and we also need a library that will cast int two, five, six to int one two, eight. So let's just go define a function called modify position and also define this modified position. Params struct and also create a library to cast int two, five, six to int one to eight. So I'll scroll up first I'll define a struct. Struct. Modify position parameters. It's going to take an address owner.
00:05:13.770 - 00:05:41.366, Speaker A: What else is it going to take? It's going to take tick lower. Tick lower is of type int 24. Tick lower and tick upper. Tick upper and liquidity delta will be of type int one two, eight int one to eight liquidity delta. Okay, next we need an internal function called modify position function underscore modify position. It's going to take in a single input of type. Modify position params.
00:05:41.366 - 00:06:03.626, Speaker A: So modify position params memory. I'll name it params. We will make this function private. Then it's going to return three outputs, returns something that we don't know yet. We'll go back to our unison B three code in a second. The next output will be int two, five, six, amount zero. And the last one will be int two, five six, amount one.
00:06:03.626 - 00:06:34.886, Speaker A: Okay, let's go back to unison Bt pro contract and check what this first output should be. So here's the function. Modify position. The first output is called position info storage position. And what is this position info? Well, I'm going to open the library and then scroll down to position. And the struct that it's returning for the first output is position info. So what we're going to do is we're going to copy this and then we also declare the same struct inside our library.
00:06:34.886 - 00:07:09.650, Speaker A: So back inside our code, open div, create a new file called position soul and then paste the struct copied over from unison B three code. For now we won't worry about the data that is stored in this struct mean. Okay, the next step is to go to our contract and then import the positions library. So say import from div, import position soul. And then going back here we'll say position info storage. And then I'll name this position. Now inside this function, modify positions.
00:07:09.650 - 00:07:26.522, Speaker A: We don't have any return statements yet, so let's say returns position. We'll work on it later. And amount zero. For now we'll say zero. And for amount one we'll also say zero. Position has to be a storage state variable. So let's create a storage state variable over here.
00:07:26.522 - 00:08:00.038, Speaker A: Let's say mapping from bytes 32 to position info public positions. This bytes 32 is some kind of ID and it maps to position info. Going back to here for now, let's say positions bytes 32 of zero. This should be a return. So I'll remove the s. Okay, that completes the internal function modified position for now. What else do we need to do? We need a library that will cast int two five six to int one two eight.
00:08:00.038 - 00:08:59.554, Speaker A: So going back to our unisoft v three pool contract, how is this done? Scrolling up it declares a library called safecast for int two, five, six. So what is this library going to go inside the library folder and open safecast inside here. It has a bunch of functions that will cast one type of number to another type. We'll just copy this over to our code inside div I'll create a file called safecast soul, declare the header and then going back to safecast from unison b three code. Copy this, paste it here. Okay, the next step is to import this safecast into our contract. At the top I'll say import from bivsafecast sol, and then inside here we'll say using safecast four int two five six okay, are we done scrolling down to our mint function? It looks like so far we are done.
00:08:59.554 - 00:09:26.994, Speaker A: Let's try compiling this contract. Open my terminal and then type forge build. Okay, our contract compiles. Let's move on. What else do we need to do for the mint function? After we call the function modify position, this function will return the amount of token zero and token one needed to increase the liquidity by this much amount. Next step is to cast this amount that was returned into Un. And then the last step is to transfer the tokens here.
00:09:26.994 - 00:10:34.294, Speaker A: The transfer is done by first checking the balance of token zero and token one and then calling the callback. This callback will send the tokens into this contract and then checking the balance afterwards. For our contract, we'll keep it simple and then just simply do an ERC transfer from so inside our code you'll say amount zero is equal to un two five six of amount zero int and the same for amount one, amount one, amount one int. And then the last step of our code is to transfer the tokens. So I'll say if amount zero is greater than zero, then IERC 20 token zero transfer from transfer from message sender to address this for the amount amount zero, then we'll do the same for amount one. If amount one is greater than zero, transfer token one transfer from message sender into this contract for amount one, and that completes our mint function. Let's try compiling a contract type forge build again.
00:10:34.294 - 00:11:13.998, Speaker A: Okay, I have not declared an IERC 20 interface, so I'll go do that right now. Open my file navigator and inside source I'll create a new folder called interfaces. And inside here I'll create IERC 20 soul and then paste a standard interface for IRC 20. Going back to the clam contract, we'll import the IRC interface, so say import from interfaces, import IRC 20 sol. Okay, let's try compiling the contract again and our contract compiles. So in this video we implemented the mint function. However, we still have not yet implemented the function.
00:11:13.998 - 00:11:20.260, Speaker A: Modify position. We will implement this function in our upcoming video. Thanks for watching and see you in the next video.
