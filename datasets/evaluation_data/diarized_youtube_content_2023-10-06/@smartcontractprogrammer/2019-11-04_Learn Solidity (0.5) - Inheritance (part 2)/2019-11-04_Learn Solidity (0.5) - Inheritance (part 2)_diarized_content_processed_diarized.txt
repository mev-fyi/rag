00:00:00.410 - 00:00:44.220, Speaker A: You. In this video, we'll go through some examples of multiple inheritance in solidity. For the first example, we'll consider the case where contract c inherits from contract a and contract B. Here we have three contracts, contract A, contract B, and contract C. For contract C to inherit both contract a and and contract b, we first start with the keyword is followed by the name of the contracts. So contract a comma and then b. And if contract A has a function called foo and contract b has a function called bar, contract C has both functions foo and bar.
00:00:44.220 - 00:01:36.430, Speaker A: You can verify this for yourself by compiling the contracts and deploying contract c. And if both the parents had the same function function foo, then contract c will inherit only one of the functions. So which function foo did contract c inherit? Let's find out. Go ahead and compile and redeploy the contract. When you execute the function foo, you'll get the string b back. When we called the function foo inside contract c, the function foo inside contract b was called and it returned the string b. If you reverse the inheritance and redeploy the contract and execute the function foo, you'll get the string a back.
00:01:36.430 - 00:03:01.876, Speaker A: So now we've seen that when the order of inheritance was ab, function foo inside contract b was called, and it returned a string b. On the other hand, when the order of inheritance was ba, function foo inside contract A was called and it returned a string a. You can see from these two examples that the order of inheritance determines which function a contract inherits. So how should you order the contracts that you want to inherit into your contract? According to the solidity documentation, you have to list the parent contracts in the order from most baselike to most derived. What do we mean by most baselike and most derived? So, for example, contract A is more baselike than contract C because contract A does not inherit any other contracts. Likewise, contract B is more baselike than contract C, and contract C is more derived than both contract B and contract a because contract c inherits from a and b, and if he had a contract d that inherits from a and c, then contract d is more derived than c and also more derived than contract a. Notice the order of inheritance for contract d is from most baselike to most derived.
00:03:01.876 - 00:03:58.308, Speaker A: Since contract C inherits from contract a, it is more derived than contract a. If you were to switch the order of inheritance from most derived to most baselike, the solidity compiler might throw an error like this. Once we order our inheritance from most baselike to most derived, how does solidity determine which function to call according to the solidity documentation. When a function is called that is defined multiple times in different contracts, solidity searches for the function from right to left and in a depth first manner. Right to left is easy to understand, but let's go over a quick example using contract c. When we call the function foo inside contract c, you'll get the string b back. This is because solidity searched for the function foo.
00:03:58.308 - 00:05:11.090, Speaker A: Starting from the rightmost parent contract, which is contract b, and inside contract b, it found the function foo. If contract b didn't have the function foo and we call the function foo inside contract c, then solidity will start from the rightmost parent contract, finding that contract b does not have the function foo. Next, solidity will search for the function foo inside contract day. Since function foo is defined inside contract day, the function foo inside contract c will resolve to the function foo inside contract day, and when we execute the function, we get our string a back. If we were to switch the order of inheritance so that contract day is the rightmost parent contract, then solidity will first search for the function foo inside contract day before searching for that function in contract b, and you can verify here that the function foo inside contract a was called. Next, let's go over what it means to search depth first. Here we have contract d that inherits from a and c.
00:05:11.090 - 00:06:13.252, Speaker A: When we call the function foo on contract d, it returns the string b. First, solidity search for the function foo inside contract d. Since the function foo is not defined inside contract d, solidity searched for the function foo in the rightmost parent contract, in this case contract c. Again, the function foo is not defined inside contract c, so solidity searches for the function foo in the rightmost parent contract, in this case contract b. Function foo is defined inside contract b, so solidity calls this function and returns the string b, and we get our string b back here. If the function foo was not defined in contract b, and the function foo was called on contract d, then solidity will first search for the function foo inside contract d. Next, it will search for the function in the rightmost parent contract, in this case contract c.
00:06:13.252 - 00:07:08.208, Speaker A: Again, the function foo is not defined inside contract c, so solidity will search for that function in the rightmost parent contract, in this case contract b. Function foo is not defined inside contract B, so solidity comes back to contract c and searches for the function in the parent contract left of contract B. In this case contract a. Since contract a defines the function foo, this is the function that is being called, and this is the value that's being returned. So we've seen how solidity overrides functions that are defined multiple times in different contracts. Next, let's go over how to call functions of parent contracts. But before we do that, I want to first introduce you to a feature in solidity called events.
00:07:08.208 - 00:08:00.184, Speaker A: You can fire events inside the function, and these events will be recorded into the transaction logs. So how is it useful to us now? It will be useful for us to trace function calls. I'll make another video for the topic of events where we will explore in more details. For now, I'll just show you how to declare an event fire events inside the function and how to see events inside the transaction log. You can define an event by starting with the keyword event, followed by the name of event that you want to define. In this case, I'll just name it log inside the event you can pass parameters that you want to log. In our case, we'll log the name of the function by passing it as a string inside the function.
00:08:00.184 - 00:08:51.640, Speaker A: You can fire the event by starting with the keyword emit, followed by the name of the event that you want to fire and passing in the parameters that you want to log, compile and deploy contract day and then execute the function foo. Click on the transaction log and scroll down under logs. You can see that the event name log was fired with the message a foo was called. And that's all you need to know about events for now. So now let's go back to the topic of how to call parent contracts. Parent contracts can be called directly or by using the keyword super. By using the keyword super, all of the parent contracts will be called.
00:08:51.640 - 00:09:46.190, Speaker A: Let's go through an example using actual code. Here we have contract B that inherits from contract A, and contract C also inherits from contract A, and contract d inherits from both b and c. Next, both contract b and C overrides the function foo from contract a. When we call the function foo on contract D, we want to be able to see which parent functions were called. So we'll fire an event before calling the parent contract, compile and deploy contract d, and execute the function foo inside contract D. Click on the transaction and scroll down to logs. Inside the transaction log.
00:09:46.190 - 00:10:36.880, Speaker A: You can see that c foo was called and then a foo was called. So when we called the function foo on contract D, it called a function foo inside contract c and fired this event. Next, it called the function foo on contract A, and this event was fired. Next, let's see how the parent functions will be called when we use the keyword super. First we'll create a function named bar and contract A, and then we'll override the function in contract b and c. The function bar inside both contract b and c first emits an event. Next it calls the parent contract by using the keyword super.
00:10:36.880 - 00:11:54.100, Speaker A: Let's see which events will be fired when we call the function bar on contract d, recompile and redeploy contract d, execute the function bar and scroll down and click on the transaction. You can see in the transaction logs that C bar was called first. Next, b bar was called, and finally a bar was called. So when we executed the function bar on contract D, it first called the function bar inside contract C. Next, instead of calling the parent contract, it first called the function bar inside contract B, and finally it called the function bar inside contract a. Notice that super bar was called twice, but inside the transaction log a bar was emitted only once. In summary, you can explicitly call the parent contract or use the keyword super to call all parent contracts.
00:11:54.100 - 00:12:33.030, Speaker A: In this video we went over how to write multiple inheritance in solidity. When we list the inheritance, ordering is important and you need to list your parent contracts from most baselike to most derived. There are two ways to call parent contracts. You can explicitly call the function of a parent contract or use the keyword super. In this case, all immediate pairing contracts will be called. Thank you so much for watching. If anything was unclear, please put your questions in the comments below.
00:12:33.030 - 00:12:36.960, Speaker A: Have a nice week and I'll see you in the next video. Bye.
