00:00:00.650 - 00:00:53.838, Speaker A: Hi, everyone. In this video, I'm going to explain what delegate call is and show you how to use it. Delegate call is a low level function similar to call method, and it's used to call other contracts. Unlike the call method, when delegate call is used inside contract A to call contract B, contract B's code is run inside A's context. So what this means is that inside contract B, storage will refer to contract A, storage message sender will refer to the caller who called contract A, and message value will be the value that was sent to contract a. Now, once you deploy a smart contract onto the blockchain, you can't change the code of that contract. However, using delegate call, you're able to upgrade the contract even though you cannot change any of the code inside it.
00:00:53.838 - 00:01:47.102, Speaker A: Suppose that there are two contracts, contract A and contract b. Inside contract a, we have a function called increment. So when you call the function increment inside contract a, it calls another function, also called increment inside contract b. Now suppose Alice calls the function increment inside contract a and sends one ether inside contract a, message sender will equal to the address of alice, and message value will equal to one ether, and the value of the state variable x is equal to zero. From contract a, it calls the function increment which is inside contract b. Inside contract b, message sender will equal to contract a. Since contract a is the address that called contract b, message value will be zero.
00:01:47.102 - 00:02:55.762, Speaker A: Ethers since contract a did not send any ether to contract b, and the initial value of the state variable x will be equal to zero, the function increment updates the state variable x by one. Now suppose that we use delegate call inside contract A to call function increment inside contract b. Alice again calls the function increment inside contract a and sends one ether, same as the previous example. Message sender will be Alice, and message value will be one ether, and the state variable x will be equal to zero. From contract a, it calls the function increment inside contract b using delegate call. Now, unlike the previous example, message sender will be alice, message value will be equal to one ether, and the initial state of the state variable x will be equal to zero. So you can already see that using delegate call, message sender and message value is preserved to the original values.
00:02:55.762 - 00:03:57.094, Speaker A: Now let's see what happens to the state variable when the code inside contract b is executed. It does not change the state variable inside contract b and the state variable x inside contract A, not inside contract b is updated. So what's happening here is that delegate call runs the code inside contract b using the storage message sender and message value of contract A. So how is delegate call useful? Well, using delegate call you can write upgradable contracts. What do I mean by this? Suppose that contract A and contract B are already deployed on the blockchain. So this means that you won't be able to change the code inside either contract A or contract b. Inside contract A, we store two state variables, un named x and the address of contract B.
00:03:57.094 - 00:04:43.382, Speaker A: And the function increment uses the delegate call method to call contract B. So let's say that Alice calls the function increment inside contract a. Contract a will call the increment function of contract b using delegate call. The code inside contract b is executed and the state variable of contract A is updated. Now imagine we have a version two of contract b named b two. And let's say that inside contract a we have a function where we could update the address of contract b so that this b variable now holds the address of contract b two. And now let's see what happens when Alice calls the function increment inside contract a.
00:04:43.382 - 00:05:30.070, Speaker A: Again. So like before, Alice calls the function increment. Now, since the address b now points to contract b two, when Alice called increment function, it called a function increment inside contract b two. The code inside contract b two is executed and the state variable inside contract A is updated. Notice that we were able to change how the state variable x is updated using delegate call. When the address B pointed to contract b, it incremented the state variable x by one. But after we updated the address of B to point to contract B two, we were able to increment the state variable x by two.
00:05:30.070 - 00:06:12.702, Speaker A: So this is the idea of how to use delegate call to update your contract even though you cannot change the code inside the contract. To show how all of this works using code, we're going to first declare some state variables. For this example, we're going to declare a state variable called num, sender and value. For this example, we're going to create a function called setbars. And inside this function we'll use delegate call to call contract B. Now the function setbars is going to take two arguments, address of contract b and some number that we're going to use for this example. And since we're going to send some ether to this function, we're also going to declare this as payable.
00:06:12.702 - 00:06:49.322, Speaker A: The way you use delegate call is similar to the call method inside the delegate call function. You call the function abi encode with signature. Inside abi encode with signature. You first pass in the function signature of the function that we're going to call. So inside contract b, we'll later define a function called setbars that's going to take a un. So here we're passing that as a function signature and to the setbars function that we're going to call. Inside contract b we're going to forward the input num like call method.
00:06:49.322 - 00:07:38.000, Speaker A: Delegatecall returns two outputs, a boolean value called success that returns true if the function executed without any errors and the output of the function that was called in bytes. But for this example, we don't need to worry about the output of delegate call. Next. Inside contract b, we first need to declare the state variables. And these state variable must be in the exact same order as contract a. So if you were to change the order of the state variables, then when the code inside contract b is run, it would mess up the state variables inside contract a. So it's important to remember to have the exact same state variable as contract a in the same order.
00:07:38.000 - 00:08:16.460, Speaker A: The function setbars is going to take a un as input. Inside the function. We'll capture the input, the color of the contract and the value that was sent to the contract into the state variables. Now we're ready to deploy the contracts and see a demo. So here I've deployed contract A and contract B. And now we're going to call the function setbars on contract a. And that should change the state variable inside contract A, but have no effect on the state variables inside contract B.
00:08:16.460 - 00:09:10.674, Speaker A: So I'm going to copy the address of contract B and we're going to call a set bars function. So I'm going to copy the address here, pass in the number one, two, three. And we're going to send one ether. So after the function was called, the num state variable of contract A should now be one, two, three. The sender should be the address of our account and the value should be one ether. And the state variables of contract B should have not changed at all. So next I want to show you how to upgrade contract A that is already deployed.
00:09:10.674 - 00:10:10.366, Speaker A: First, we'll create a new version of contract B. So we're going to copy contract B, paste it here, and then rename it as contract B two. Now remember that the layout of the state variables have to be the same as contract A and inside the function step bars, we'll multiply the input by two and then store the result. So here I have newly deployed contract B two, and contract day is still the same contract from the previous demo, and we'll call the function set bars inside contract day, passing in the address of contract B two. So that should multiply our input by two and store the result inside contract day. I'm going to copy the address of contract B two, paste it in here, and call it with the same input. One two three.
00:10:10.366 - 00:10:49.494, Speaker A: And this time we'll pass two ethers. So now the num should be two four six. Since we passed one two three, which was multiplied by two, the sender should still be the same, and the value should now be two ethers. So in summary, delegate call runs the code of call e using the caller's context. The state variables of the call e must be the same as the caller, and you can use delegate call to upgrade contracts. Well, that's all I got for this video. If you have any questions or feedback, let me know in the comments below.
00:10:49.494 - 00:10:53.370, Speaker A: Have a good night, and I'll see you soon in the next video. Bye.
