00:00:00.490 - 00:00:42.870, Speaker A: Let's say that I want to trade my one ether. Uniswap tells me that for one ether I'll get over 2002 dies. But where is this die coming from? Where's that 2000 die that I am about to buy coming from? The short answer is anyone can provide tokens for the trade. This person is called a liquidity provider. By becoming a liquidity provider you earn trading fee these so in this video I'll show you how to provide liquidity into a Uniswap smart contract. To provide liquidity, you'll need to call the Uniswap B two router and the function that you'll need to call is called add liquidity. For the input, this function takes in the two address of the tokens.
00:00:42.870 - 00:01:35.722, Speaker A: For our example, we'll be using the dAi and the wef, which stands for wrapped ether. The two amounts that you're willing to put into the Uniswap contract and the minimum amounts that has to go inside the contract or else this function will fail. The reason why we have amounts that we desire to put in and the minimum amount that Uniswap will actually take in is because Uniswap will try to take in tokens so that the pool remains in balance. So for example, currently one ether is trading above 2000 die. If you pass in one ether here and 2000 die, then this function will probably execute successfully. So Uniswap will take in your one ether and 2000 die and use almost all of it for trading. On the other hand, let's say that you try to put in 0.5
00:01:35.722 - 00:02:00.558, Speaker A: ether and 2000 die. In this case, Uniswap will probably only take in 0.5 ether and 1000 die. So you try to put in 2000 die, but uniswap only took in 1000 die. This is because one ether is trading around 2000 die. So 0.5 ether will be worth about 1000 die.
00:02:00.558 - 00:02:34.778, Speaker A: And if you were actually able to put in all 2000 die, then this pool will be out of balance. So that is why Uniswap only accepts 1000 die. For your 0.5 ether, the next parameter is the two address. This is the address that is going to be receiving the liquidity pool tokens in exchange for the two tokens that you provide. The holder of this liquidity token will later be able to claim the two tokens and also some trading fees. The last parameter is deadline.
00:02:34.778 - 00:03:23.162, Speaker A: This tells Uniswap the last timestamp where this call to this function is still valid. And this is useful in case your transaction gets stuck. Maybe you want to sell some tokens, but due to a gas spike, your transaction gets processed 1 hour later. At that time, let's say that you no longer wanted to do the trade. Then by setting the deadline to 30 minutes, then you're guaranteed that this function will fail in case the transaction gets stuck. When this function executes successfully, it returns three outputs. Amount a, the actual amount of token a that was put into the Uniswap contract, and likewise for amount b, the actual amount of token b that was put into the Uniswap contract, and lastly, liquidity.
00:03:23.162 - 00:04:21.198, Speaker A: This is the amount of liquidity tokens that was minted and sent to this two address. For this example, we'll be writing a smart contract that adds liquidity to die and weft pool. So I've added some smart contract addresses on the main net Uniswap B two router and uniswap factory contract and wef. For this demo, I've created an event called log and we'll use this to log some un values and the message telling what that value is for the function that's going to add liquidity. In other words, the function that's going to transfer token a and token b to the Uniswap contract, I named it add liquidity. It's going to take in the address of the two tokens and the two amounts that we want to put in. We'll first transfer the two tokens by calling transfer from on token a and token b for amount a and amount b.
00:04:21.198 - 00:05:04.698, Speaker A: So after these two functions are called, this contract will have amount a of token a and amount b of token b. Inside this smart contract, we'll need to allow uniswap B two router to spend those tokens. So we'll call approve on token a and token b. Next we'll call the add liquidity function on the Uniswap B two router contract, passing in the parameters the two tokens, the two amounts. For simplicity, the two minimum amounts that uniswap should take in. I've set it to one and one. The recipient of the liquidity token is this contract, and we'll set the block that timestamp.
00:05:04.698 - 00:06:29.298, Speaker A: The output of calling this function is the actual amount of token a that was put inside the uniswap contract. Likewise for amount b, the actual amount of token b that was put inside the contract, and the amount of liquidity pool tokens that this contract received. We'll log all of this output using the event log which we defined above over here. So this is our basic example of adding liquidity to uniswap, transfer the two tokens that's involved in the trade, approve Uniswap to spend those tokens, and then actually call the add liquidity function. Once we have the liquidity token, how do we use that token to claim our trading fees and also get back our token a and token b? We do that by calling the function remove liquidity which is inside the Uniswap B two router contract. It's going to take in the address of the two tokens and the amount of liquidity tokens that you want to give back, the minimum amount of token a that you expect to get back, and the minimum amount of token b that you expect to get back. The recipient of the two tokens and the last timestamp that this transaction is valid for the output, it's going to return the actual amount of token a that was returned and the actual amount of token b that was also returned back.
00:06:29.298 - 00:07:36.590, Speaker A: Inside our smart contract, I've created a function called remove liquidity and it's going to take in the address of the two tokens. The first thing that we'll do is get the balance of liquidity tokens that this contract holds. So we'll need to get the address of the contract that actually manages the liquidity pool tokens and the token a and token b. We do that by calling get pair on the Unisop contract called Unisoft B two factory. So this pair contract is the contract that actually handles all of the trading for token a and token b, and also manages to mint and burn liquidity tokens. We can get the balance of liquidity tokens that this contract has by calling the ERC 20 balance up on the smart contract pair that we just got above. And for the input of balance up, we'll pass in the address of this contract, we get back the balance of liquidity pool tokens that this contract has.
00:07:36.590 - 00:08:27.390, Speaker A: We're going to burn all of our liquidity tokens and claim the maximum amount of token a and token b, and also all of the trading fees. So we're going to approve the Uniswap B two router to spend all of our liquidity tokens. And then we'll call the remove liquidity function of the Uniswap B two router saying we want to claim the maximum amount of token a and token b for all of our shares. It's going to return the actual amount of token a and token b that was transferred back to this contract. So again, we'll use logs to log those two outputs. I've spun up a ganache running MMA network. I've also written a test to add liquidity and remove liquidity.
00:08:27.390 - 00:09:18.944, Speaker A: And after each transaction, we'll console log the events that were emitted. And for this example, we'll try to add liquidity of one ether for one die. And we'll run the test by saying MPX truffle test, Uniswap liquidity js and the network that we'll be using is main network. The test ran successfully. Let's check the output. We try to add one ether for one die. The actual amount of die.
00:09:18.944 - 00:10:07.828, Speaker A: That Uniswap token is one die. And the actual amount of ether that Uniswap took in is significantly less than one ether. And for providing these two amounts, it gave us this much liquidity tokens. In the next transaction, we took all of this liquidity tokens and claimed back our ether and our dai. And these are the amounts that we got back. Now, the numbers that you see here are less than the numbers that you see here, and it's probably due to rounding errors. Now, if you were to add liquidity and then let it sit and accrue trading fees for maybe one day, and then call it remove liquidity, then these numbers should be more than the numbers you see over here.
00:10:07.828 - 00:10:13.010, Speaker A: So that is how you add and remove liquidity from a uniswap contract. Thanks for watching.
