00:00:00.330 - 00:00:34.518, Speaker A: Let's take a look at inheritance and solidity. Let's say that I have a contract A with some code in it. And then I also have contract B, where I want to use most of the code in contract A, but maybe customize a few functions inside contract B. One way to do it is copy all of the code inside contract A, paste it into contract B. And let's say that I wanted to customize the function foo in bar. So what I would do is maybe change this to B and also change this code a little bit. There's a lot of duplicate code between contract B and contract A.
00:00:34.518 - 00:01:12.210, Speaker A: However, using inheritance, we'll be able to remove a lot of the duplicate code. For this example, contract B will inherit from contract A. So contract A will be the parent, and contract B will be the child contract that we want to customize. To start off with, the first thing that we need to do is declare the functions that's going to be inherited as virtual. For this example, we want to customize foo in bar inside contract B. So these are the two functions that will be inherited by contract B. And to declare that this function can be customized by child contract, we need to put in a keyword called virtual.
00:01:12.210 - 00:01:53.358, Speaker A: This keyword virtual will tell solidity that this function can be inherited and customized by the child contract. We also want the function bar to be customizable by a child contract. So again here, we'll put the keyword virtual. Next, we want to declare that contract B is going to inherit from contract A. It's going to inherit all of the code, and we want to be able to customize Fulinbar. So to do that, we first say B is a, and for the function Fuinbar, these are the functions that we want to customize from contract A, we declare as override. Same with bar.
00:01:53.358 - 00:02:23.302, Speaker A: We declare as override. To show a demo of this inheritance of foo and bar, I've also created a function called bads inside contract a. Since contract B inherits contract a inside here, although the function is not declared, this function will be available. Let me show you. So I'm going to compile the contract and then deploy contract b. Scroll down, open contract b, and notice that we have three functions here. Bar, bas, and foo.
00:02:23.302 - 00:03:03.350, Speaker A: But inside contract b, we only declare two function foo and bar and not bass. So where does Bass come from? Well, bas comes from contract A. We declare that over here, and contract B inherits contract a. So that is why contract B has the function baz, even though we have not declared it here, when we call the function foo, we get the string b. Likewise, when we call the function bar, we also get the string b. However, when we call the function baz, we get the string a. Foo and bar are functions that we inherit from contract A and then later customized it in contract B, and the function badge remains the same.
00:03:03.350 - 00:03:59.060, Speaker A: Let me give you a little bit more complex example. Now, let's say that we wanted a contract that inherits from contract B, and we wanted to override the bar function. How do we do it? The first thing that we want to do is declare that bar can be overwritten by the child contract. And to do that, we'll have to declare it as virtual. And for contract C, we'll declare that it inherits from contract b by saying contract C is b. And then we'll override this function by copy paste, and then say the function bar overrides the function bar of contract b. And for the string we'll return C, compile the contract, deploy contract C, and again, we have three functions, foo, bar and bas foo returns b, bar returns C and bash returns a.
