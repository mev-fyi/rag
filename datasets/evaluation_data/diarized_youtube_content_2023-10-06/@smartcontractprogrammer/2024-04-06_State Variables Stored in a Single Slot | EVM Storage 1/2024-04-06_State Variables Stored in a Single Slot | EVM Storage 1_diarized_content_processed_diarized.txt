00:00:00.400 - 00:00:51.778, Speaker A: This will be a video series on EBM storage. We'll learn where the state variables are stored inside the EBM storage, and we'll also learn how to read and write state variables using assembly. Okay to begin with, we will first look at some Yule syntax to understand the EBM storage examples that I'll show you in this video. So first of all, what is yo? Yo? Is a language used for inline assembly in solidity. Yo can be used by itself to write a smart contract and it can also be used as inline assembly in solidity. For our purpose, we'll be using yield as inline assembly to read and write from state variables the minimal amount of yield that you need to know to understand the examples for EVM storage are how to assign variables in Yule and the fact that the only data type that is supported in Yule is bytes 32. So let's start with how to assign variables using Yule.
00:00:51.778 - 00:01:42.646, Speaker A: Okay, to write Yule inside solidity, we will write assembly first assembly and inside here all of the code will be in u and to assign a variable. If you wanted to create a new variable inside assembly, we will say that. For example, let's say that x is equal to one, and if you wanted to reassign it to something else, for example, let's say two. Then we would say x two. Another way to assign variable is we can first create a variable in solidity and then inside assembly assign it. For example, let's say uint 256s is equal to zero. So over here this is solidity code, and inside assembly this will be u to assign something to this s variable that is declared as a solidity variable.
00:01:42.646 - 00:02:19.802, Speaker A: Inside assembly we will say s colon equals let's say two. And then after we assign it we can also return this return s. Okay, let's try this out. I'll hit ctrl s to compile a contract and then deploy yo intro and then call the function test yobar. And what I get? I get a two bag. This is because we declared a variable called s in solidity, and inside assembly we set this s value to two and then we return it. So that is why you saw two that was returned when we call the function test do button.
00:02:19.802 - 00:02:51.948, Speaker A: Okay, so that's assigning variables using yule. Next, let's take a look at yul types. The only type that is supported in yule is bytes 32. For this example, we'll use assembly to assign some variables and then return them, say assembly and inside assembly when we say x is equal to one. Notice that inside solidity we're declaring it as a boolean. But inside assembly this will be handled as bytes 32. And the same goes for this variable y.
00:02:51.948 - 00:03:27.934, Speaker A: We declared it as u into 256, but inside assembly this will be handled as bytes 32. For example, let's say zero, x, aaa, and let's say z. We declare that adds bytes 32. For example, inside here let's put a short string so that it fits inside bytes 32. Let's say say hello yield. Let's see what the return values are when we call this function, I'll hit ctrl s to compile a contract. Again inside the deployment tab, I'll redeploy the contract, and then we'll call the function test yield types.
00:03:27.934 - 00:04:23.064, Speaker A: Notice that even though inside assembly everything is handled as bytes 32, when these variables are returned from a solidity function, we get x equal to true y equals to 27 30, and byte 32 is equal to whatever this is. So those are the two things that you need to know about yo to understand the examples for EBM storage, how to assign variables inside yo, and that all of the data type inside Yue is bytes 32. Okay, so with that said, let me give you a simple example of how state variables are stored in EBM. The way state variables inside a solidity smart contract is stored inside EBM storage is by chunks of 32 bytes. There are two to the 256 slots, and each slot can store up to 32 bytes. In general, slots are assigned in the order that the state variables are declared. Now there are exceptions.
00:04:23.064 - 00:04:58.774, Speaker A: The rule for how slots are assigned to dynamic arrays and mappings are a little bit different. We will cover these topics in separate videos. State variables that are less than 32 bytes are packed into a slot. We will cover how state variables are packed into a single slot in a separate video. In this video, we will take a look at some simple examples and we'll use the function s store and s load. S store will take in two inputs, k and b. K will be the slot k where value v will be stored, and when we call sload k, this will load 32 bytes from slot k.
00:04:58.774 - 00:05:43.786, Speaker A: Okay, so let's start with some simple examples. Let's say that we have a Un 256 state variable public, and I'll name it s x. And let's create several more state variables uint 256 public s y and byte 32 public s alkali underscore z. So remember I said that slots can store up to 32 bytes and slots are signed in the order the state variables are declared. So in this contract, the first state variable that is declared is s x. And also this is a state variable of type Un 256. Un 256 can be converted into bytes 32.
00:05:43.786 - 00:06:10.438, Speaker A: In other words, this state variable will fit inside bytes 32. So this will fit inside a single slot. And since it's the first state variable, this will be assigned slot zero. And the same goes for the next state variable. The next state variable that is declared in this contract is s y. The data type is un 256. And again un 256 fits inside bytes 32.
00:06:10.438 - 00:06:42.428, Speaker A: So this will be assigned slot one. Okay? And the third state variable that we have is s z. Again, this data type fits under bytes 32, since this data type is bytes 32. And how about the slot? Well, according to this rule, this is the first one that is declared, so it's slot zero. This is the second one that is declared, so it's slot one. This is the third one that is declared, so this is slot two. Okay? So that is how slots are assigned to state variables.
00:06:42.428 - 00:07:09.894, Speaker A: Let's look at some simple examples of s store and s load. First, I'll show you some examples of s store. S store is going to take two inputs, k and b, and it will store the value b to slot k. So let's see what this means. Let's say assembly. For this example, let's store something inside s x. So to do this, I'll type s store and the next input is the location of the slot slot zero.
00:07:09.894 - 00:07:33.830, Speaker A: So that will be zero. And the value that we want to put in now this value that we store has to fit inside bytes 32. For this example, let's say we'll store one one one. So what's going on here is the same as writing the code s sub x equals 111. This code is in solidity and this is in u. Let's look at another example. Let's say s store.
00:07:33.830 - 00:08:10.434, Speaker A: Let's store the value 222 to the state variable s y. The state variable s y is located at slot one. So to slot one we'll set this to 222. So the value will be two two two, okay, and another example, let's store something to the state variable s z. This state variable is in slot two. So here I'll put in two access slot two, and to slot two store the value, let's say zero x. Abab.
00:08:10.434 - 00:08:39.668, Speaker A: Another way to access these slots instead of manually counting and putting in the numbers is to say state variable dot slot. For example, I'll copy this again. Then I'll rename this function again. Test s store again. So currently we're manually counting the slots and then hard coding the slots. Over here. Another way to access the slot is by saying state variable.
00:08:39.668 - 00:09:02.572, Speaker A: For example s sub x. That's the state variable. Then access the property called dot slot. This will store the slot where this state variable is stored. Another example, slot one is s of y. So here I can say s of y dot slot. And likewise slot two will be s of z, say s z dot slot.
00:09:02.572 - 00:09:43.452, Speaker A: And for this example, I'll change the numbers around. So say 123456, and bytes 32 will be cdcd CD. Okay, so these are some basic examples of how to write to a state variable using s store. Next, let's look at some examples of how to read data using s load. Okay, so for the next example, I've declared some variables that will be returned uint 256 x y, and bytes 32 z. Inside assembly, we will get the values that are stored in these three state variables, assign it to these variables, and then return it. For example, let's get the value s x.
00:09:43.452 - 00:10:26.036, Speaker A: This is stored in slot zero. So we can do assign to this local variable x, get the value that is stored in slot zero by calling s load zero. Okay, can also do the same for the state variable s one assigned to the local variable y, get the data from slot one. And lastly, we'll do the same for bytes 32 assigned to the variable z. Get the data from slot two. And again, slot two will store the state variable s underscore z like what we did over here. Instead of manually putting in the slot where the state variables are stored, we said state variable dot slot.
00:10:26.036 - 00:11:12.334, Speaker A: And we can do the same over here to get the data stored in a state variable. So copy this paste to here, and then I'll rename this function to s test sload again. And this time instead of using these numbers, we'll replace it with the state variable dot slot. So the zero slot will be s sub x dot slot. The first slot will be s sub y dot slot, and the last one will be s s z slot. Okay, let's try executing these functions. I'll hit control s to compile a contract, clear out the previous one, deploy a new one, and then first I'll set the state variables by calling these functions.
00:11:12.334 - 00:11:56.452, Speaker A: Let's call the function test s store. So I'll call this function. Okay, and this will set the state variable s sub x to to abab. Okay, let's try getting these state variables. To get these state variables, I'll call the function test slope s load will load 32 bytes from slot 00:32 bytes from slot one and 32 bytes from slot two. Okay, so let's call the function test sload and we get the values 11122 and bytes 32 that ends with abab. Okay, let's do the same for this function.
00:11:56.452 - 00:12:47.734, Speaker A: Call this function test estore again and then we'll call test again to get the values. So when we call this function test s store again, it's going to store one, two, three for the state variable s x 456 for the state variable s y and zero x cdcd CD for the state variable s z. So call the function test s store again and then call the function test s stored again to get the values stored inside the state variable. And what do we get? We get 123456 and bytes 32 ending with cdcdcd. In summary, in this video we looked at how to assign variables using yule, and we looked at some examples of sstore and s load to read and write from EVM storage.
