00:00:00.280 - 00:00:39.716, Speaker A: For fixed size array, the storage slot where the element is stored is the slot where the array is declared plus the index of the array element. For example, let's say that we have a Un 256 fixed size array of size three. I'll call this r zero and has three elements, let's say one, two and three. The slot of the first element, the 0th index, will be slot where the array is declared. We start with slot zero and this state variable is declared in slot zero. So this will be slot zero plus the index of the array element. Index of the first array element will be zero, so zero plus zero is equal to slot zero.
00:00:39.716 - 00:01:00.768, Speaker A: The next element, the second element will be index one. Again. The slot where the array is declared is in slot zero. So we start from slot zero again and the index will be one. So this will be equal to slot slot one. And the last element in this fixed size array, the slot where the array is declared. Again, we start from slot zero and the index is two.
00:01:00.768 - 00:01:37.970, Speaker A: So the last element in this array will be stored in slot two. Let's take a look at another example. So let's say Uint 256 again, let's create a fixed size array of uint of size three and I'll call this r one, say has four, five and six. So slot where the array is declared, we used up slot zero, one and two. So the starting slot where this array is declared is slot three. The first element is index zero, so this will be three plus zero or will be equal to three. The next element will be index one and the starting slot is slot three.
00:01:37.970 - 00:02:14.088, Speaker A: So this will be slot three plus one or slot four. And likewise the last one will be slot three. If each element inside the fixed size array is less than 32 bytes, then it will be packed into a single slot, if that is possible. So for example, let's say we have a Uint 128 fixed sized array of size five. I'll call this two reals and let's say it has elements seven, 8910 and eleven. We used up three, four and five, so the starting slot will be slot six. The index of the first element is zero, so this will be plus zero.
00:02:14.088 - 00:02:56.944, Speaker A: Or the first element will be stored in slot six, the next element, the second element. Since un 128 only takes up 16 bytes, we still have another 16 bytes that we can fit inside slot six. So the next element, which only takes up 16 bytes, will also be stored in slot six, the third element. This will have an index of two. The starting slot will be slot six and index will be two. Since in each slot we can fit two of these, u and one, two eight. The slot where the element having the index two is stored will be in slot six one, or this will be equal to slot seven, and the same goes for the next element having the index three.
00:02:56.944 - 00:03:27.240, Speaker A: This will also be installed in slot seven, and the last element will be stored in slot eight. This is because we used up all of slot seven. So we move on to the next slot that is available, which is slot eight. And at this point for slot date we only use 16 bytes, and we still have 16 bytes that can be filled out. Next, let's write some functions to actually get these values using assembly. So I'll create a function called test r zero. For the input we'll pass in the index of the array.
00:03:27.240 - 00:03:59.776, Speaker A: To get event 256 I public view returns event 256. I'll call this b. The value that is stored at index site assembly. Okay, for r zero, the value will be stored in the slot. So let's say b is equal to s load I for the index. If you wanted to access the zero filament for I will pass in zero. If you wanted to access the first element for I, we will pass in one, and if you wanted to access the second element for I, we will pass in two.
00:03:59.776 - 00:04:42.400, Speaker A: Okay, let's create another function. This time we'll get the values from r1, so I'll copy the first function and then now name it to test r1, if you wanted to get the 0th element in r1, then the index will range from zero to two, and the starting point will be from slot three. So say here I need to type start from three and then add that index. If you wanted to get the 0th index, then we will pass in zero. 30 is three, so we will get slot three, which will store this number four. If we wanted to get the array element with index one for I, we will pass in one three, one is four and this will load slot four. Okay, let's write one more function.
00:04:42.400 - 00:05:14.664, Speaker A: This time we will get the values from r two. I'll name this test two reals. Since two reals holds elements of size uint one to eight, the value that we will return is uint 128. Inside assembly, we'll first get all of 32 bytes from a slot. So say that I'll call this b 32, short for bytes 32 equals s load. Then this array starts from slot six. So for our starting point we'll say add six.
00:05:14.664 - 00:05:59.090, Speaker A: On the top, I'll list out the slot where each element is stored on the bottom I'll list out the index of the array, and in the middle I'll list out the values that is stored in this array. To get the 0th element, you'll need to start from six, and to six we'll need to add zero. To get the first element again we'll need to start from six, and to six we'll need to add zero again. To get the array element with index two, you need to start from six and then add one. Six plus one will be seven. To get the array element with index three, we'll start from six again and then to six we'll add one to get seven. And lastly, to get the array element with index four again we'll start from slot six, and then to six we add two to get slot eight.
00:05:59.090 - 00:06:32.124, Speaker A: What's happening here is that every time the index increases by two, then we need to increase the slot where we start from by one. So for example, the first two, index zero and one will start from six. The next two indexes, two and three will start from seven. In the next index four will start from eight. So what we need to do here is divide the index that we want to access by two. This will load the 32 bytes of the slot that stores two elements. So the next step is to somehow get the elements from this 32 bytes.
00:06:32.124 - 00:07:24.106, Speaker A: Remember that in each slot there are 32 bytes and data is packed from right to left. So the 0th element will be stored on the right, and then next to it going towards left, we will have the first element. The second element again will start from the right, and the third element will be to the left of the second element, and the last element will be stored starting from the right of slot eight. The pattern that we observe here is that if I is even, then we need to get the 128 bits starting from the right and going left, get right 128 bits. And the way we can get this is after we load this 32 bytes, we simply just cast it into UN 2128. When we cast it into uint 128, the left 128 bits will be cut off and we're left with the right 128 bits. So cast two uint 128.
00:07:24.106 - 00:08:02.966, Speaker A: On the other hand, if I is odd, then we need to get the left 128 bits. And we can do this by first loading the 32 bytes and then shifting this right by 128. So shift write 128 bits. Okay, so let's actually implement this code to figure out whether I is even or odd. I'll use the switch statement inside assembly switch mod I two case. If it is odd, then we need to shift right by 128 bits. So b is equal to shift right 128, b 32 otherwise default.
00:08:02.966 - 00:08:32.738, Speaker A: So this will be the case when I is even. We simply need to cast this b 32 to uint 128. And we can do this by simply assigning to b the 32 bytes. When we assign 32 bytes to unt 128, it will cut off the left side of the 128 bits. Okay, let's compile the contract and then call these functions. I'll hit control s and the contract compiles. Next I'll deploy this and then let's call some functions.
00:08:32.738 - 00:09:17.374, Speaker A: So let's try getting the 0th element from our zero. Put a zero here and I get a one. If I put a one here, I get a two, and if I put a two here, I get a three. Okay, let's try getting the elements from r1. If I put a zero, I get a four, put a one, I get a five, and put a two, get a six. Okay, lastly, let's try the function test two reals. Put a zero, get a seven, one is eight, two is nine, three is ten, four is eleven, and five is zero.
00:09:17.374 - 00:09:39.694, Speaker A: This is because for slot eight, we're only using up the 16 bytes starting from the right. So the remaining 16 bytes to the left inside slot eight is zero. Right. Now, that is why when we try to access element index five, we only have five elements, so element index five doesn't exist. That is why we get a zero over here.
