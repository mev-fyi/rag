00:00:00.410 - 00:00:43.910, Speaker A: Before solidity zero eight, fallbacks could not take any inputs and they could not return any outputs. However, in solidity zero eight now the fallback can take an input of bytes and then also return an output of bytes. If you look at the documentation for solidity zero eight, you can see over here that the fallback can optionally take an input of bytes and then also return optional output of bytes. To take an input and return some output from the fallback. In solidity zero seven, what you will have to do is use the assembly. Take a look at a code example for the transparent upgradable proxy on the website soliditybyxample.org. However, in solidity zero eight, we don't have to use the assembly to consume inputs and return outputs in a fallback.
00:00:43.910 - 00:01:14.722, Speaker A: So in this video I'll show you how to accept input in a fallback and also return an output. In this example, we'll execute the fallback and then trigger some code inside the target contract which I've set inside the constructor. Okay, let's now write the fallback that can take in an input and return an output of bytes. So I'll declare a fallback by typing fallback, the only input that it can take. It's a bytes. So I'll say bytes call data, I'll name it data. The fallback will be external, payable, and unlike solidity 0.7,
00:01:14.722 - 00:02:06.190, Speaker A: we'll return bytes as output returns bytes memory, and inside the fallback we will simply execute the code inside the target contract. So I'll say target call. We'll also send the value value message value, and then forward the data of the input and execute the code at the target. So inside here I'll type data. The call returns two outputs, a boolean indicating whether the call was successful or not, and some output by calling the target. The output will be in bytes. So two outputs Boolean, I'll name it, ok, and bytes memory, I'll call it rest short for response, we'll check that ok is equal to true, otherwise fail with the message call failed, and then we'll simply return the output return rest okay, let's try compiling this contract.
00:02:06.190 - 00:02:40.090, Speaker A: I'll hit Ctrl s and the contract compiles. Okay, to test this fallback function, I'm going to create two other contracts. The target contract will be a counter contract, and to test the return output of the fallback, this rest over here we'll create another contract called test fallback input output, which will execute the fallback. After the fallback finishes executing, it will return this rest back to the contract test fallback input output. Okay, the counter contract. This will be the target contract that we'll put in here. This is a simple contract.
00:02:40.090 - 00:03:01.314, Speaker A: It has a state variable called count, and it also has a function called ink which will increment the state variable count. And afterwards it will return the current count. This is the function that we're going to be calling for our example. Okay, let's now write the contract for test fallback input output. The function that we're going to call. We'll name it function test. This will take in the address of the fallback.
00:03:01.314 - 00:03:36.350, Speaker A: I'll name it with underscore fallback. And then we'll pass in the data to execute ink on the counter contract. So this will be bytes call data, I'll name it data, and then this will be external. And we'll call the fallback function by using the low level function call. So what I'll do is I'll copy this part of the code, paste it here, and then remove the return rest statement and change the target to fallback. There is no value of beef that we're going to be sending, so we'll remove this part of the code. And now notice that we have a response that we get back from the fallback.
00:03:36.350 - 00:04:05.226, Speaker A: And we'll log this as an event. So I'll create event log byte on emirs. And then over here we'll emit the event. We'll log the event emit logres. Okay, we need one more function to be able to call this function test. We somehow need to prepare the data that will be forwarded over to the fallback contract. And the fallback contract will consume this data and then call the counter contract to execute the ink function.
00:04:05.226 - 00:04:42.082, Speaker A: So what we need to do is prepare data to execute the ink function. So to do that, I'll create a function called function get test data, external peer returns, bytes, memory, and then we'll type return ABI encodecall. The call that we're encoding is counter ink. The input will be an empty input, so just the empty parentheses. Let's try compiling the contract and the contract compiles. So let's now test our fallback. So to test the fallback, we'll need to first deploy the countercontract.
00:04:42.082 - 00:05:05.118, Speaker A: So click on deployment tab, click on the countercontract, and then deploy. Next we'll need to deploy the fallback input output contract. This is the contract that we're testing. And to deploy this we'll pass in the address of the counter contract paste it here, and then call deploy. And lastly, we'll deploy the test contract. This is the contract that we're going to call. The function that we're going to call is called test.
00:05:05.118 - 00:05:36.610, Speaker A: And this will test this fallback. And we're going to test that we can take in some input and return some output, deploy the test contract. Scroll down. The two inputs that we're going to need to pass is the address of the fallback input output contract. So copy this, paste it here, and the data that will be passed over to execute the counter ink function. So to do that, I'll call the function, get test data. This is the data that we'll need to pass, paste it here, and then call the function transact.
00:05:36.610 - 00:06:00.110, Speaker A: Okay, the transaction was successful. Let's check the logs. So if I scroll down and then scroll down further, I see that the event log was emitted. The output that was returned is one. This is the value that was returned from calling the function inc. It returned the current value of the count. After we called increment, the current value of the count will be equal to one.
00:06:00.110 - 00:06:26.690, Speaker A: That is why you see a one over here which was emitted by the event log. So this was a video about taking in some inputs and returning some outputs in a fallback function in solidity zero eight. However, if you still want to return some data using a receive, then you cannot do this. Notice here that the contract did not compile. So this means that if you want to consume data and return some data using a fallback and a receive, then you'll still have to use the assembly.
