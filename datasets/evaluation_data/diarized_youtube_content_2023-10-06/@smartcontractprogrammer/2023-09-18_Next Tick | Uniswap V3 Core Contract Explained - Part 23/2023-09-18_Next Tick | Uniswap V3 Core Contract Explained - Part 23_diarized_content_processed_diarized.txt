00:00:00.250 - 00:00:28.742, Speaker A: How does unison b three find the next tick position? For this example, we will be using the tick equal to -200 697. Here's the same number in binary. As a review. This sequence of bits splits into two parts. The first 16 bits is called the word position. When you evaluate just this part, this turns out to be -784 and the last eight bits is called the bit position addition. For this example, this turns out to be equal to seven.
00:00:28.742 - 00:00:56.190, Speaker A: We'll be using this example to find the tick to the left and to the right of this tick. Let's start with the example of finding the next tick. To the left of the current tick. The next tick will be less than or equal to the current tick. This means that on the tick bitmap we'll need to find the bit to the right of the current bit. Let's start with the example of the tick bitmap. Let's say that we access the key -784 this is the word position.
00:00:56.190 - 00:01:52.286, Speaker A: Accessing this tick bit map will give us the value of un 256 256 sequence of zero than ones. Now, in our example, the bit position was seven and we want to find the next tick less than or equal to the current tick. So over here, what we want to look for is a one to the right of the 7th index. To find a one at the 7th index, or to the right of it, we first create a mask. The mask will be all ones at the 7th index and to the right of it, to the left of the 7th index, everything will be zero. We do a bitwise and with the current value that we got from the tick bitmap, and this will give us all ones to the right of the 7th index. For example, let's say that this value at the 7th index is a zero, at the 6th index is a zero, at the fifth index is also a zero, and all the way down to the second index it is equal to zero.
00:01:52.286 - 00:02:48.146, Speaker A: Let's also say at the first index we have a one and at the zero th index we also have a one. When we do a bitwise n with this mask over here, what we get is the masked value of all zeros all the way down to the first index being a one and the zero index being a one. So what we accomplished here was we got the next one to the right of the 7th index, taking this mask value to find the next bit position, what we need to find is the index of the most significant bit from here. Now, in this case, the most significant bit of this value will be the one over here. So in this value, what is the index of the most significant bit? Well, just by looking at it, we can tell that the index of the most significant bit will be the first position. So this will be equal to one. The next bit position is equal to one.
00:02:48.146 - 00:03:22.598, Speaker A: Okay, now that we found the next bit position, how do we get the next tick? To get the next tick, we start with the current tick minus the current bit position and then add the next bit position. And here's the same equation with some pictures. We start with the current tick. We minus the current bit position. So now our bit position will be all zeros. And lastly we add the next bit position. And this is how we will find the next tick to the right of the current tick, the next tick which is less than or equal to the current tick.
00:03:22.598 - 00:03:52.422, Speaker A: To find the next tick which is greater than the current tick, we will do something similar on the tick bitmap. The next tick will be to the left of the current tick. So we search left on the tick bitmap. For example, let's again start with the tick bitmap and let's access the key. -784 again, this is the word position. We get some kind of value of Un 256 256 sequence of zeros and ones. The zero means that there is no tick here and one means that there is a tick at this position.
00:03:52.422 - 00:04:24.490, Speaker A: Again, for this example, we will be using the 7th index. This is the bit position that we said earlier for this example. And we want to find the next tick greater than the current tick. So this means that we'll need to search left of this sequence of zeros and ones. To search for all ones to the left of this 7th index from this sequence of zeros and ones, we first create a mask. This mask will be one. To the left of the 7th index will all be ones, and to the right of it it will all be zeros.
00:04:24.490 - 00:04:56.090, Speaker A: We take a bitwise n to get all ones to the left from this sequence of zeros and ones. Let's say that this is the masked value that we got. And let's also say that this part is all zeros. And here is the first one. This will be at index 255. This will be index 254 and this will be index 253. To find the next bit position to the left of the 7th index, we will need to find the index of the least significant bit from this masked value.
00:04:56.090 - 00:05:35.830, Speaker A: Now, we said that for this example, the first one that appears in this masked value is one over here. And we said that to the left of this one is all zeros. So what is the index of the least significant bit from this value? Well, it is this one over here, since for this example, to the right of this one is all zeros. So this is the least significant bit. And what is the index of this one? Here we will have 255, this will be 254 and this will be index 253. So the index of the least significant bit from this mask value is 253. And this will be our next bit position.
00:05:35.830 - 00:06:02.490, Speaker A: To find the next tick, what we do is we first take the current tick minus the current bit position and then add the next bit position. And lastly we add a one to make sure that the next tick is greater than the current tick. Let's see this in pictures. So again, this is the binary representation of the current tick. We minus the current bit position. This will zero out all of the current bit position. So all of this will be zeros.
00:06:02.490 - 00:06:23.780, Speaker A: And then we add the next bit position. This sequence of ones and zeros that you see over here is equal to 253. This is the next bit position. And finally, to this bit position we add the one to make sure that the next tick is greater than the current tick. And this is the algorithm that finds the next tick in unisol B. Three.
