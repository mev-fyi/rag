00:00:00.250 - 00:00:36.306, Speaker A: Today, I'll solve the 23rd challenge on Ethernot called Dex two. The goal of this challenge is to drain all of token one and token two from the Dex two contract. You start with ten token one and token two, and the Dex starts with 100 tokens each. I'll copy this code over to my code editor and then also deploy this challenge. I've copied the code from Ethernot over to my code editor. Again, the goal of this challenge is that we have a Dex two contract, and it holds token one and token two. It has 100 tokens each, and our goal is to drain both of token one and token two from the Dex two contract.
00:00:36.306 - 00:01:06.558, Speaker A: So let's take a look at the contract. The first function is set tokens, and it has a modifier called on the owner. So this means that only the owner of this contract will be able to set the tokens. And likewise for add liquidity, there is a modifier called onioner. Scrolling down, there's a function called swap, get, swap, amount, approve, and balance up. All of these are public functions without the only owner modifier. So we'll need to hack this dex contract by calling any of these functions.
00:01:06.558 - 00:01:39.062, Speaker A: Let's take a look at the function swap. It takes in an address of, from, and also address of, to and the amount. So what are these inputs from, to, and amount from? It's the token that we want to swap from. N to will be the token that we want to buy. The token that we want out from this trade and amount is the amount of token from that we want to put in this contract. Usually when a smart contract calls into another contract, it first does some validations. Make sure that that contract that it's calling to is not malicious.
00:01:39.062 - 00:02:30.378, Speaker A: However, notice that for this function swap, the address from and to are set by the user, and there is no validation. To make sure that from and to are either token one or token two, let's say that we wanted to trade token one for token two. Then from will be token one, and two will be token two for some amount amount. However, since this function does not do any validation, check to make sure that from is equal to token one or token two, and likewise two is equal to token one or token two. What we can do here is trade some token that is not token one or token two. For token one and token two, we can pass in some fake token for from and then get token one and token two out of this trade. For example, let's say that we'll trade some fake token, and we'll set it as from and two, we'll set it to token one.
00:02:30.378 - 00:03:22.642, Speaker A: This contract will first check that the balance of fake token for message sender is greater than the amount specified here. Next, it computes the swap amount, pulls in the fake token into this contract, and then it will send token one to our contract. So how much fake token do we need to send? What is the amount we need to set over here to get 100 token one out? So let's take a look at the function get swap amount again from will be the fake token that we're going to be providing. And initially the balance of token one will be 100. So we want token out amount to be equal to 100 and this will be amount in times 100. That is amount of both token one and token two locked in this Dex contract. And then we divide this by the balance of the fake token locked in this contract.
00:03:22.642 - 00:03:58.242, Speaker A: So let's say that we send one fake token into this contract. Then what is the amount in that we need to send to get 100 token one? Well, we can simply set amount in to equal one amount in will be one times 100 divided by one and that will be equal to 100. This means that we'll be able to get 100 token one by calling the function slot. So let's write this in code. So I'm going to write my code over here. Contract hack. Since this contract is importing open Zeppelin, but I'm going to copy this part of the code over to remix.
00:03:58.242 - 00:04:24.122, Speaker A: I'll define an interface for Dex and maybe ERC 20. Here's the interface for the dex two contract. We're going to be calling the function token one, token two, and swap. I've also pasted the IERC interface and I've also created an ERC 20 contract. I named it my token. This contract is basically our ERC 20 with mint and burn function. We'll be using this my token as our fake token.
00:04:24.122 - 00:04:56.234, Speaker A: We'll write all of our hack contract inside the constructor. So I'll say constructor then it's going to take in the dex contract for input. I Dex, I'll name it Dex. First I'll initialize token one and token two. So say IERc 20 token one is equal to dex token one. This will return an address. So I'll initialize this as IERc 20, then do the same for token two, IErc 20 token two IRc 20, dex token two.
00:04:56.234 - 00:06:04.622, Speaker A: Next, I'll deploy two fake tokens, name it my token one is equal to new my token, and then we'll do the same to create the second fake token, my token two. Next I'm going to mint some fake tokens, so I'll say my token one mint. Before we call the swap on the decks we'll send one token and then when we call the swap we'll send another token. So we'll need one plus one two tokens, likewise for my token two. And then before we call the swap, let's send one token of each mytoken one and my token two. This is because when the function gets swap amount is called, we want this balance of IERC 20 from balance of the Dex contract to be equal to one, the one that you see over here. So that is why we're going to be sending one token to the Dex contract mytoken transfer to address Dex further amount one mytoken one, then my token two.
00:06:04.622 - 00:07:01.826, Speaker A: And then finally we're going to call the swap function and to do that we'll need to approve the dex contract to spend these my tokens from the hack contract. So say my token one, approve address Dex for amount one, and likewise my token two. And then lastly we'll call the function swap. Dex swap from will be our fake mytoken one. So I'll say address mytoken one to what is the token that we want out of this trade? We want token one, so say address token one and how much my token one do we need to send to get 100 token one out? Well, we said earlier here that the amount that we need to send is one. I'll copy this and then go to top. Then I'll paste a comment over here.
00:07:01.826 - 00:07:39.598, Speaker A: So amount that we need to send is one and we'll need to do the same for my token two. That should drain the tokens from the dex contract. But let's double check require token one balance of address Dex, and we expect this to be zero. Otherwise you'll say Dex token balance one not equal to zero. Then we'll do a check for token two as well. Token two balance of Dex should be equal to zero. With error message dex token balance two now equal to zero.
00:07:39.598 - 00:08:28.602, Speaker A: Okay, we're now ready to deploy this contract. So I'm going to copy the code from here all the way to my token, paste it inside, remix, and I'll hit Ctrl s to see that the contract compiles. I forgot to declare the events inside the IERC 20 interface, so I'll paste the events inside the IRC 20 interface and then try compiling the contract again. Okay, the contract compiles, so click on deployment tab and we're going to be deploying the hack contract. So I'll select the hack contract and we'll need the address of the decks inside Ethernet. Type F twelve to pop open the browser console and then copy the address of the contract, paste the address in here, and then deploy the hack contract. Once the hack contract is deployed, we'll go back to Ethernet.
00:08:28.602 - 00:08:38.220, Speaker A: Back inside Ethernet. The last step is to submit our instance. Once the transaction is included in the plug, you should see the button change to go to next level.
