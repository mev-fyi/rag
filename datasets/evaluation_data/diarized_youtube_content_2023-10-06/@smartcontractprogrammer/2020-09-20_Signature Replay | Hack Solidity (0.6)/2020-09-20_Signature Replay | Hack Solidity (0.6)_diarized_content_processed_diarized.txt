00:00:00.730 - 00:00:41.218, Speaker A: In this video, let's take a look at signature replay attack. The basic idea of signature replay attack is that you can use the same signature to execute a transaction multiple times. What does that mean? Let's say that we have EB and some contract. And in order to execute a function inside this contract, you'll need to submit a signature. So, EB can execute a transaction by submitting a signature and then using the same signature. Again, she can execute the same function inside the contract. So that's the basic idea of signature replay attack, that you can use the same signature to execute a function multiple times.
00:00:41.218 - 00:01:25.958, Speaker A: Now, you might be asking questions like, what's the point of submitting a signature to a contract? And what kind of damage can be done when you can execute a transaction multiple times against the same signature? So, first, let's go over how submitting a signature can be useful. Imagine that we have a multi Sig wallet owned by Eb and Alice with two ethers. EB wants to withdraw one ether from the contract. So what does she have to do? Well, first, she'll have to send a transaction approving herself to spend one ether. Likewise, Alice will also send a transaction to approve E to withdraw one ether. And then Ebb can finally withdraw the one ether inside the multisig wallet. So that's three transactions in total.
00:01:25.958 - 00:01:58.590, Speaker A: However, using signatures, we can reduce the number of transactions to just one transaction. Let's see how again. Let's say that Eve wants to withdraw one ether. First, Alice will sign a message that says, Eevee can withdraw one ether. Next, she will give the signature over to EB. And then EB sends a transaction to withdraw one ether, sending her signature and Alice's signature. The contract will verify Eb's signature and Alice's signature, and then send one ether to EB.
00:01:58.590 - 00:02:38.878, Speaker A: In total, that's one transaction. Alice and EB were able to reduce the number of transactions by exchanging signatures off chain and then sending a transaction to a contract that can verify signatures. Now, let's take a look at how EB can perform a signature replay attack on a multi SiG wallet that uses signatures. So, like before, EB can take the signature of Alice and withdraw one ether. Now, using the same signatures, Eid can withdraw another ether from the multi SiG wallet. Even though Alice's intention was to allow Eve to withdraw one ether. So that was an example of signature replay attack.
00:02:38.878 - 00:03:17.930, Speaker A: On a multisig wallet, you use the same signatures to execute a function multiple times. In this case, Eve was able to withdraw two ethers. Now, there are at least three situations where the signature replay attack can be performed. The first situation is, as we discussed, we can perform a signature replay attack on the same contract. Another situation is on the same code, different address. So, for example, here we will have the same multisig wallet contract deployed at a different address. And the third situation is on a contract that was deployed using create two.
00:03:17.930 - 00:04:19.706, Speaker A: And inside the contract, it has a self destruct function. Create two is a function that will deploy a contract always at the same address. So with the combination of create two and self destruct, you can deploy a contract at the address and then use self destruct to delete the contract and then use create two again to recreate the same contract. Now, let's examine how we can prevent a signature replay attack on these different situations. In the first situation, we can prevent the replay attack by having a unique signature for every transaction and keeping track of which transaction has been executed inside the contract. And we can accomplish this by including a nouns inside the signature and then also keeping track of the nouns inside the contract. So if EB tries to execute the same transaction twice, the contract will already know that that nouns was already used, so the transaction will fail.
00:04:19.706 - 00:05:09.038, Speaker A: Next, how would we prevent a replay attack on the same code deployed at a different address? Well, we can do that by including the address of the contract inside the signature. And to prevent the attack from the first case here, we'll also have to include announce in our contract. Lastly, how about the case for a contract that's been deployed by create two and inside the contract, it has a self destruct. How do we prevent the replay attack on this contract? Well, the bad news is that you cannot. The reason is because you can reset the nouns. And this is done by deleting the contract by calling self destruct and then using create two to deploy a new contract at the same address. And when the new contract is deployed, the nouns is reset back to zero.
00:05:09.038 - 00:05:46.826, Speaker A: The announce is used to keep track of which transaction has been executed. But here, by resetting the nouns, e will be able to do a replay attack. All right, so that's three situations where a replay attack is possible. Let's now examine a multisig wallet contract that is vulnerable to replay attack. We'll turn that contract into a contract that is guarded against replay attack. And in the process, you'll get a better understanding of how the nounses are used and how the contract knows which transaction has been executed. Here we have a multisig wallet contract that is vulnerable to replay attack.
00:05:46.826 - 00:06:18.658, Speaker A: Let's first take a look at what each function does. First of all, we set the owners. When the contract is deployed. Anyone will be able to send ether into this contract by calling deposit and to transfer the ether stored in this contract to anyone else. Then you'll have to call transfer. To call this function, you'll have to send three inputs, the address to send the ether to the amount and the signatures. Here you'll need to send two signatures corresponding to the two owners.
00:06:18.658 - 00:07:09.986, Speaker A: Now let's take a look at how the transfer function works. Well, first, it recreates the hash that was signed from the parameters to and amount. Next, it checks the two signatures against the hash and if the signatures are valid. In other words, if the two signatures were signed by the two owners, then the ether will be sent to the two address. The gettx hash is a simple function that hashes the two and the amount and check sigs is also a simple function from the transaction hash. It recomputes the actual hash that was signed by calling two e signmesses hash. Next, it runs a for loop, and for each signature we recover the signer and then check that the signer is indeed equal to the owner.
00:07:09.986 - 00:07:57.800, Speaker A: If the signer and the owners are not equal, then it will return false, otherwise it will return true. This contract is vulnerable to a replay attack because once EB has Alice's signature, she'll be able to call this transfer function as many times as she wants and the signatures will be valid. So we need a way to create a unique signature for each transaction. And then once that transaction is executed, we need to mark it as executed so that Eve won't be able to do a replay attack. And we can create a unique signature for each transaction by creating a unique transaction hash. And we can do that by including announce inside the transaction hash. So that is what we'll do.
00:07:57.800 - 00:09:38.578, Speaker A: So we'll pass announce into the get TX hash function, which we'll also pass to the transfer function. And then we'll hash the nouns over here's now we are able to create a unique transaction hash by passing a unique nouns. So next, we'll need to invalidate this transaction hash when this transfer function is successful. So we'll scroll up and create a mapping called executed that will map from bytes 32 to Boolean, and we'll name it executed. And then we'll require that the transaction hash has not been executed yet. If it is, we'll throw an error saying TX executed. So once we know that the TX hash has not been executed and we have a valid signature then we'll mark the TX hash as executed and then transfer the ether.
00:09:38.578 - 00:10:24.738, Speaker A: So by having announced and keeping track of which transaction hash has been executed, this will prevent a replay attack on the same contract. Now, we'll need to go one step further and protect this contract from replay attack for the same contract deployed at a different address. And we can do that by including the address of this contract inside the gettx hash. So here we'll say address this. So now when Alice and Eve signs this TX hash, they are signing a hash that is unique to this contract. And this is because we are hashing the address of this contract. All right, so now we have a contract that is protected against replay attack.
00:10:24.738 - 00:10:52.940, Speaker A: And this was done by including announce and the address of this contract in the hash that we're going to sign. And once the transaction corresponding to this hash is executed, we mark it as executed. So, in summary, we used signatures to reduce the number of transactions, and we protect against the replay attack by signing TX hash with nouns and the address of this contract. Thanks for watching, and have a good night.
