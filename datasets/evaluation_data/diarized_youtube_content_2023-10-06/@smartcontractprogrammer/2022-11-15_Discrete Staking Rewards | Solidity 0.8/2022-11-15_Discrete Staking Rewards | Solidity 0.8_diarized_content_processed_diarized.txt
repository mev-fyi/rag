00:00:00.330 - 00:00:45.526, Speaker A: Let's write the code for the discrete staking rewards contract. This contract will need to take in two tokens, the staking token and the reward token. So the first thing that I'll do is import IRC 20 which I have defined over here. So first I'll type import from the current directory import IERC 20 sol. Next we'll store the staking token and the re rewards token inside this contract. So I'll say IRC 20 public. We'll define it as immutable and I'll name it staking token and likewise for reward token IRC 20 public immutable reward token.
00:00:45.526 - 00:01:33.298, Speaker A: We'll initialize these inside the constructor. So I'll type constructor address of staking token, address of reward token and then initialize in by typing. Staking token is equal to IERC 20 staking token and reward token. Reward token is equal to IRC 20 reward token address from the input reward token. Okay, next let's declare some state variables. When the user stakes a token, we will store the amount of tokens that is staked by a user in a mapping from mapping from address to un. This will be public and I'll name it balance up.
00:01:33.298 - 00:02:22.890, Speaker A: So when a user stakes token, the balance of the user will increase and when the user unstakes the balance of the user will decrease. And then we also keep track of the total amount of tokens staked un public total supply next, we'll declare some state variables that are needed to calculate the amount of rewards earned by each user. The global reward index, I'll name it un. I'll make this private and then name it reward index. I'm making this private because this reward index is only used internally as a way to calculate the amount of rewards earned by a user. Next, I'll create a mapping reward index of each user mapping from address to un. Again, this will be private and then I'll name it reward index of.
00:02:22.890 - 00:03:03.426, Speaker A: Lastly, I'll create a mapping from my address of the user to the amount of rewards they earn. Mapping address un private and then I'll name it earned. Later we'll write a function to calculate the amount of rewards earned by a user and then make that a public function so that anyone can call and see how much rewards they've earned. Now one other logic I'll put in here with the reward index is we want to avoid divisions that result in zero. For example, if we divide one divided by two in solidity, that will be equal to zero. We want to avoid that. So we'll scale the top by the numerator by some scale.
00:03:03.426 - 00:03:57.874, Speaker A: So I'll say un private constant multiplier and we'll set this to ten to the 18 one e 18. Okay, next I will write a function to update the reward index. Anyone will be able to call this function and when they do this will pull in the reward token into this contract and then update the reward index. So I'll say function update reward index and then the input will be the amount of reward to pull in into this contract. Un reward this will be external. Anyone will be able to call this function and the first thing that I'll do is transfer the reward token from message sender into this contract. Reward token transfer from message sender the caller to this contract address this further amount reward.
00:03:57.874 - 00:04:39.638, Speaker A: Once the reward is transferred into this contract, I'll update the reward index. So I'll say reward index is equal to the current reward index plus the amount of reward that was pulled in. We multiply this by the multiplier and then we'll divide this by total supply. Total supply is the total amount of tokens that is staked here. We're multiplying this by a multiplier, a scalar of ten to the 18 so that if the reward is smaller than the total supply, if we did not multiply by this multiplier, then this number might be zero. So we're avoiding addition by zero by multiplying it by a big number. That completes the function.
00:04:39.638 - 00:05:32.550, Speaker A: For update reward index. Next I'll write an internal function to calculate the amount of rewards earned by account. So say function underscore calculate rewards. This will take in a single input an address account this will be private view returns un returns the amount of reward earned the amount of token staked. I'll name it un shares. This is equal to the balance of account and then to get the amount of rewards earned we'll return shares multiplied by reward. The current reward index minus the user reward index reward index of account and then since this reward index is always multiply scalar multiplier, we'll divide this by the multiplier.
00:05:32.550 - 00:06:25.970, Speaker A: This function will return the amount of rewards earned by account since the last time their reward index was updated. Next, let's write a public function that will return the total amount of rewards earned by a user. So I'll say function calculate rewards earned address of the account. This function will be external view returns un and then to return the amount of rewards earned by a user, we'll say return earned up account. This will store the amount of rewards earned by a user so far, plus the amount that was currently earned by calling the function calculate rewards. Underscore calculate rewards passing in the account. Okay, so this completes the function calculate rewards earned.
00:06:25.970 - 00:07:07.358, Speaker A: This is a public function where any user can call to get the amount of rewards earned. So the next functions that we'll be writing is a function to stake and a function to unstake and the function to claim the rewards. All of this will be external. So unstake external and claim external. When a user calls stake, unstake, or claim, we will update the reward index of the user. So we'll declare an internal function called function update reward and this will update the reward of the staker. So address account private.
00:07:07.358 - 00:07:51.358, Speaker A: We'll fill in the details later. So when the function stake on stake or claim is called, the first thing that we'll do is call updaterewards of message sender. This will be the same inside the function stake and also inside the function claim. So next let's write the function for update rewards. This will update the amount of rewards earned by the account and then also update the reward index of the account. So to do that, we'll say earned of account plus equals call the internal function, calculate rewards, and then pass in the account. This will calculate the amount of rewards earned since the last time the reward index was updated.
00:07:51.358 - 00:09:02.226, Speaker A: And then we'll update the reward index of the account. So say reward index of account is equal to the current reward index, reward index and that completes the internal function for update rewards. Next, let's write the function for stake. So when a user calls the function stake, we'll update the balance of message sender plus equals. This function will take in an input of amount of tokens to stake, so say unit amount, and then over here update the balance of message sender by the amount, update the total supply by the amount, and then lastly we'll transfer the token stakingtoken transfer from message sender to this contract for the amount amount unstake will be something similar. So we'll copy this and then paste it here. The function onstake will also take in the amount to unstake unit amount and then instead of adding it, we'll decrease it, decrease the balance up and decrease the total supply.
00:09:02.226 - 00:09:58.198, Speaker A: And then that's the transfer to message sender for the amount. Okay, the last function that we will write is claim. When a user calls this function, this would transfer the reward token to the user so the amount of rewards earned we called update rewards first. So this will update the amount of rewards earned by the user to the latest amount and this will be stored in the mapping earned. So reward is equal to earned of message sender and then we'll transfer the reward if the reward is greater than zero. If reward is greater than zero, then we'll set earned of message sender to zero, reset it to zero and then transfer the reward reward token. Transfer to message sender for the amount reward and then lastly we'll return the amount of rewards that was earned.
00:09:58.198 - 00:10:41.350, Speaker A: This is a useful feature if the function claim is called by another contract, so say return reward and then we'll update the function signature to be external returns un here we're returning the reward that was claimed by message sender. Okay, and that completes the function for claim. If I hit ctrl s the contract compiles. So let's deploy this contract and see an example of this contract. We're going to need an ERC 20 contract. So first I'll create your file called ERc 20 sol and we'll use this for both the staking and the reward token. And then I'll paste the code for ERc 20 token that I got from the Internet.
00:10:41.350 - 00:11:12.130, Speaker A: And then just to make sure that it compiles, I'll hit Ctrl s and the contract compiles. So we'll deploy the staking token and the reward token first. So I'll deploy the first ERc 20 token. We'll say that this is the staking token and then deploy the next one. We'll say that this is the reward token. Next I'll compile the discrete staking rewards contract and then we'll deploy this. The first input is the address of the staking token and then the second input is the address of the reward token.
00:11:12.130 - 00:12:18.050, Speaker A: If I scroll down I can see that the discrete staking reward contract was deployed. Next we'll call the functions inside the discrete staking rewards contract and what we're going to call first is the function stake and then we'll call update reward index and then we'll call the function claim and then lastly we'll call the function on stake. We'll also say that the first account is the account that's going to be providing the rewards and the second account will be a staker. First I'll switch over to the second account, this will be the staker, copy the address, scroll down and then we'll mint some staking token. This staking token has 18 decimals so I'll mint one staking token so that will be ten to the 18 and then call the function mint next, this account will approve the staking rewards contract to be able to spend the tokens. So the amount will be the amount that we minted and the address that we're going to approve is the discrete staking rewards contract and then hit approve. Next, we'll call the function stake.
00:12:18.050 - 00:12:47.614, Speaker A: So copy this amount, scroll down and then call the function stake. If I click on total supply, I can see that the total supply has increased to ten to the 18. Next, we'll provide some rewards into this contract. So I'll scroll up and then switch to account one. Scroll down and then we'll mint ten rewards token. Open the rewards token. This reward token also has 18 decimals.
00:12:47.614 - 00:13:22.026, Speaker A: So ten to the 18 is one token. Add a zero to be ten tokens and then mint. Next, we'll be calling the function update reward index. So we'll approve this amount for the staking rewards contract. Scroll down, copy the address of the staking rewards contract and then paste it here and then call transact and then we'll call the function update reward index. The amount of reward that we'll be sending is this amount. Paste it here and then call update reward index.
00:13:22.026 - 00:13:53.138, Speaker A: Okay, let's switch back to user two and then claim some rewards. So switch to user two. Also copy the address of user two. Let's call the function calculate rewards earned to see how much amount of rewards we have earned. Paste the address and then call the function and it looks like we have earned some amount. Next we'll call the function claim and then afterwards if we call the function calculate rewards earned again, notice that it has turned to zero. Okay, the last function that we'll call is on stake.
00:13:53.138 - 00:14:05.060, Speaker A: So I'll copy the amount that we staked and then call the function on stake with the same amount and the transaction is successful. If we call the function total supply. Now the total supply is zero.
