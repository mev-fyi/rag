00:00:00.280 - 00:00:44.018, Speaker A: Previous videos explain where the storage slots are located for basic data types. In this video and in the next video, I'll give you examples of how to locate storage slots for complex data structures. Here I'll explain how to locate storage slots if we had a mapping of dynamic arrays. And for simplicity, we'll assume that each element of the dynamic array is 32 bytes. For example, let's say that we have a mapping from address to uint 256. I'll name this map. Where would each element of this dynamic array be stored inside the storage slot? To figure this out, let's take a step back, figure out how storage slots are calculated for a simple mapping, and also figure out the storage slots for a dynamic array of size.
00:00:44.018 - 00:01:23.478, Speaker A: 32 bytes. If we had a mapping of 32 bytes, then the value where this 32 bytes will be stored is calculated by taking the ketchup 256 of the key and the slot where this mapping is declared. For a dynamic array where each elements take up 32 bytes, the slot of where this array element is stored is calculated by taking the catch Act 256 of the slot where this dynamic array is declared plus the index of the array element. These two are just reviews of the previous videos. We will combine these two rules to figure out where the value is stored for a mapping from an address. A dynamic array of Unt 256. Let's say that we have a key for this mapping.
00:01:23.478 - 00:02:10.044, Speaker A: Then to get this dynamic array, we first need to apply this rule. Slot of a value in a mapping is the ketchup 256 of the key and the slot where this mapping is declared. In this case, this will give us the slot where the dynamic array is declared. Now to get the array element, we will apply this rule. The slot of the array element is the catch Act 256 of the slot where the array is declared plus the index of the array element. In this case, the slot where the array element is declared will be this one, which is the ketchup 256 of the mapping key and the slot where the mapping is declared. So I'll replace this with this and for clarification I'll say here slot dog map.
00:02:10.044 - 00:02:39.890, Speaker A: Okay, this is how the slot of array limit is calculated for a mapping from address to a dynamic array of Un 256. Let's write some assembly code to actually get the values. I'll first put some data into this mapping. For address one, I'll store 1122 and 33. For address two, I'll store 44, 55 and 66. Next we'll write some assembly code to get the values that are stored in here. I'll call this test map r.
00:02:39.890 - 00:03:07.794, Speaker A: It will take in two inputs address. This will be the key to the mapping. I'll call this addr and the index of the array to get uint 256, I'll name it I and we'll return two outputs. Uint 256 the value I'll name it b, the value that is stored in this dynamic array. And I'll also show you where to get the length of this dynamic array. We'll call this uint 256 then here. Okay, so let's apply this equation.
00:03:07.794 - 00:03:46.422, Speaker A: Let's start by computing the inner catch Act 256 slot of the map, the slot where the map is declared. Uint 256 v scroll up. You can see that this mapping is declared in slot zero. So I'll call this map slot equals zero. This map is declared in slot zero. Next, we'll calculate this inner catch up to 56 bytes 32 I'll call it maphash equals to getcheck 256 abi dot encode. And then for the first input you need to pass in the key.
00:03:46.422 - 00:04:25.244, Speaker A: The key will be an address from the input addr and the slot where this mapping is declared. We said that it is declared in slot zero, map slot which is equal to zero. Okay, so this computes the inner catch Act 256. Next, we need to calculate the outer ketch Act 256, say bytes 32. I'll name it array hash r hash equals two. Check 256 abi dot encode map hash. Next, let's get the value that is stored in this dynamic array assembly.
00:04:25.244 - 00:05:02.292, Speaker A: Say b is equal to. We will apply this equation to load the value in a storage slot. We'll call s load and the slot to load will be this. So this will be add to this r hash r hash add the index I. Let's also get the length of this dynamic array. As I review, the length of the dynamic array is stored in the slot where the array is declared. In our example, the slot where the dynamic array is declared will be this, and this is equal to maphash.
00:05:02.292 - 00:05:31.522, Speaker A: So to get the length of the array, we'll type length equals to sload map hash. Okay, let's try compiling the contract. I'll hit ctrl s and the contract compiles. Next, let's deploy the contract and call the function test map log. Deploy the contract. First I'll load address one, address two, and then we'll call the function test mapbar and try to get these values eleven to 66. Let's try getting eleven.
00:05:31.522 - 00:06:18.444, Speaker A: I'll copy address one, paste here. Try to get the element at zero for index for the value I get eleven, and for the length of the array, I get three. Let's try getting the first element, get a 22, 2nd element, 33. And if you try to get the third element, which does not exist, you'll get the value is equal to zero. Let's try getting 44 to 66. I'll copy, address two, paste it as a key, and try to get the 0th element, 44, 1st element, 55, and second element 66. The length of this array is also three, so if you try to get the fourth element, which will be index three, then we get a zero.
