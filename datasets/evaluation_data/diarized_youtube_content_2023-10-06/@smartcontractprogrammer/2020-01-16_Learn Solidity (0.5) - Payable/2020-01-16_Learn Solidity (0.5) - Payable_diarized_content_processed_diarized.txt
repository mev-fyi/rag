00:00:00.250 - 00:00:56.910, Speaker A: You contracts can receive and send ether by using the keyword payable. So in this video, I'm going to give you examples of how to create payable functions and how to use payable for addresses. And a good way to explain about these examples that I'm about to show you is by building a wallet. So we're going to build a wallet that supports depositing ether, withdrawing ether, and then also transferring ether to another address. First, we're going to define some events that will be emitted when we either deposit, withdraw or transfer from this wallet. Now, if you're building a user interface on top of this contract, then emitting events is essential if you want to get your updates in real time. But for the examples that I'm about to show you, I'm going to use events to show you some features in solidity that are relevant when you send and receive ether to a contract.
00:00:56.910 - 00:01:54.418, Speaker A: When someone deposits into our wallet, we're going to deposit the sender of the ether, the amount that was sent, and the total balance of the ether in this contract after the deposit. When we withdraw, we're going to log the amount that was withdrawn and the total amount of ether that is left after we do the withdrawal. Unlike the deposit, we don't need to log the address of the sender. Since we only want the owner of this contract to be able to withdraw. And the last event is transfer, we're going to log the address that we sent the ether to, the amount and the total balance of ether after the transfer. The first function that we're going to define is the deposit function. To make this function be able to receive ether into this contract, all we have to do is declare this function as payable and we're going to emit the deposit event.
00:01:54.418 - 00:02:44.094, Speaker A: The sender of the transaction will be stored in a global variable called message sender. Message value will hold the amount of ether that was sent with this transaction, and to get the current balance of ether in this contract, you do it like this. Here, we're casting this into an address type where this refers to the contract and then accessing the balance. Here, the balance is the amount of ether that is stored in this contract after the deposit. So let me give you an example. Let's say that this contract stores ten ethers and the generous user calls this function sending one ether. So, message sender will be the address of the generous user, message value will be one ether and the balance will be eleven ether.
00:02:44.094 - 00:03:26.510, Speaker A: Since we started out with ten ether in this contract and the user sent one ether and ten plus one is eleven. Now, if the function is not marked as payable, then when you call this function, you won't be able to send any ether. If you do, then the transaction will fail. And I'll show you an example of this later in the video. Now, we also want to be able to deposit into this contract when the contract is created, and you can do it like this. Similar to the deposit function, all you have to do is declare the constructor as payable. So now when we deploy this contract, we can send ether with it.
00:03:26.510 - 00:04:03.798, Speaker A: Again, when you don't have the payable keyword for the constructor, then you won't be able to send any ether. When you deploy this contract, after we deposit some ether into this contract, later on, we will want to be able to withdraw from it. So let's create a function to withdraw ether for the input. We're going to pass the amount of ether to withdraw. We only want the owner of this contract to be able to withdraw. So let's create a function modifier called only owner. The function modifier only owner will require that the sender of the transaction is equal to the owner.
00:04:03.798 - 00:04:40.550, Speaker A: So we need to define the owner of this contract. That we're going to do. Now, up on top, we define a state variable called owner, and when the contract is deployed, we assign the owner to the sender of the transaction. And lastly, we append the only owner modifier to the function withdrawal. So now this function can only be called by the owner of this contract. Now, to send ether to the owner, you call the transfer function and pass in the amount that we're going to transfer to the owner. If you try to compile this, you'll get an error saying that the owner is not payable.
00:04:40.550 - 00:05:28.838, Speaker A: This is because in order for any address to be able to receive ether, you need to declare as payable. So we're going to do that right now and declare the owner as payable. Now, when you compile it, the error will be gone. After the ether is transferred to the owner, we're going to emit the withdrawal event, and we're going to emit the amount that was withdrawn and the remaining ether in this contract after the withdrawal. Actually, there are three ways to send ether to another address, which I will cover in the next video. So that's withdrawal function. Next, let's write the function to transfer ether to another address.
00:05:28.838 - 00:06:34.742, Speaker A: We're going to name the function transfer, and like the withdrawal function, we only want the owner of the contract to be able to withdraw ether to another address. So we're going to append the only owner function modifier to this function for the input we're going to pass in the address to send the ether to, and the amount of ether to send. Similar to how we send ether to the owner, we're going to send ether to this address by calling two transfer and in order for this address to be able to receive ether, we need to declare it as payable. So we're going to do that right now. And similar to how we send ether to the owner, in the withdrawal function here, all we have to do is call the transfer function on the two address. Now, it's a little bit confusing, but this transfer function is different from this function that we defined above. This transfer function is a built in function that is only available to payable addresses, whereas this transfer function is a function that we define.
00:06:34.742 - 00:07:18.020, Speaker A: And to avoid confusion, it might be better to name this transfer function to something like transfer ether. After the function transfers the ether, it's going to emit the transfer event with the address that we sent the ether to, the amount and the balance of ether in this contract after the transfer. And lastly, we'll create a helper function so that we can check the balance of ether stored in this contract. And we've already seen how to do this in the code above. So now let's deploy this contract and test it out. Notice that the deploy button is red. Usually it is orange.
00:07:18.020 - 00:08:07.572, Speaker A: This is because we made the constructor payable, which means that we can send ether when we deploy this contract, which is what we're going to do now. So I'm going to deploy this contract with 100 way and the balance should now be 100. Next, let's deposit ten way into this contract. So I'm going to call the deposit function and send Tang way with it. And when we check the balance, it is now 110. Earlier I mentioned that you won't be able to send ether to a non payable function. So let me give you a demonstration of that here.
00:08:07.572 - 00:08:49.990, Speaker A: This function not payable is not declared as payable and when we send some way to it, the transaction should fail. So here I'm going to send one way and call it not payable. And you can see that the transaction to the function not payable failed. This is because we try to send ether to a function that is not declared as payable. Next, let's try the withdrawal function. First, I'm going to deposit ten ether into this contract and deduct this account by ten ethers. So now the account balance should be around 90.
00:08:49.990 - 00:09:36.464, Speaker A: Next, let's deposit one ether. Recall that one ether is equal to ten to the 18. And now when we check our account balance, it should have went up by one, which it did. And finally, let's transfer one ether to account number two. So I'm going to copy the address of account number two. Switch back to account number one because this is the owner of the contract, and only the owner can transfer and copy the address of account number two to here. And we're going to send one ether after the transfer.
00:09:36.464 - 00:10:15.688, Speaker A: When you check back on the account balance of account number two, you can see that it is now 101 ether. So the transfer was successful. So in this video, we went over how to use the keyword payable. When you declare a function as payable, then that function can receive ether. And when you declare a constructor as payable, then you can send ether when you deploy the contract. And finally, if you want to send ether to another address, then you have to declare the address as payable. Well, that's all I got to say about the keyword payable.
00:10:15.688 - 00:10:26.010, Speaker A: In the next video, I'll be talking more about how to transfer ether to another address. Thanks for watching. See you in the next video. And until then, have a nice day.
