00:00:05.370 - 00:00:05.920, Speaker A: It.
00:00:07.250 - 00:01:11.518, Speaker B: So the motivation of this talk is for you, as the audience, to be able to answer at the end of it, out of these three things, which of them are truths and which is a lie. So, to start us off, let's tell you a little bit about what fully homomorphic encryption is, so you can think of it as an extension to public key cryptography. The idea here is you have the usual algorithms, key generation, encryption, decryption, but now you have these additional functionalities, like being able to add and multiply ciphertext together. There are usually some additional operations when you actually go into an FHe scheme, and these tend to allow you to do additional operations on encrypted data, stuff like relinearization, modulus switching and bootstrapping. So, in terms of fhe and how it's evolved as a technology, the very first scheme was 2009, Craig Gentry. Incredibly slow. I've heard all kinds of estimates on time, but roughly speaking, it took somewhere between ten minutes and 30 minutes to multiply two encrypted numbers together using Gentry's original FHE scheme.
00:01:11.518 - 00:01:56.334, Speaker B: Second generation of FHE started 2011 2012. Much more efficient. So now we're down to milliseconds to multiply encrypted numbers together. Third generation of FHE, which is the generation we're on currently, that is fairly fast as well, a little bit different than the second generation. So rather than prioritizing fast arithmetic, it prioritizes fast comparisons and also allows for fast bootstrapping. The idea here is you can do truly arbitrary computation on encrypted data, whereas the second generation of FHE, you generally set up the scheme to do a certain amount of computation, and then you stop. In terms of the work being done on FHE, most of the initial work was focused on performance.
00:01:56.334 - 00:02:41.626, Speaker B: In the last five, seven years, it's transitioned more to usability. If you want a rough idea of the overhead from using FHE, we're roughly looking at about ten to the 510 to the six, versus doing the computation in the clear, and that's with regards to both space and time. So what does fhe have to do with web three? I wouldn't say that's the focus of this talk, but to give you some motivation, people are interested in private smart contracts. So smart contracts that operate directly on encrypted data. Some folks are interested in private auctions and dark pools, like we heard in the previous talk. And some folks are also interested in constructing some notion of private shared state. But that requires a little bit more than just single key, fully homomorphic encryption.
00:02:41.626 - 00:03:33.166, Speaker B: In terms of how exactly you use fhe to do these applications, you can imagine that the user needs to encrypt their inputs via some sort of fhe scheme, and then they will need to prove that their inputs satisfy some application dependent conditions via zero knowledge proofs. So how does fhe and zero knowledge proofs fit together? Here? We're looking at an example of a private transaction. So imagine Alice is the sender, Bob is the recipient. She wants to send some encrypted amount of currency using the account model. So if we're assuming there's an honest majority of validators, the validators will check the proofs produced by Alice, and then they will perform the computation directly on the encrypted data. So they'll update Alice's encrypted account balance and Bob's encrypted account balance. There is a different way of thinking about fhe in web three.
00:03:33.166 - 00:04:13.820, Speaker B: That's if you're looking to do something more roll up style. The difference here is that the validator will check Alice's proofs. They will perform the computation directly on the encrypted data, but since there's only one of them, potentially they will need to prove that they've done these updates correctly. I would say the roll up style use of fhe is not the focus of our talk. It is incredibly expensive, probably not feasible for the next one to two years. So let's say you're an engineer and you want to use fhe in your web three application. What is the experience like? So the very first step is to figure out which fhe scheme makes the most sense for you.
00:04:13.820 - 00:04:42.034, Speaker B: You have a couple of different choices here. There is the BFE scheme that uses arithmetic circuits. It supports exact arithmetic. There is the CKKS scheme, which also uses arithmetic circuits, but only supports approximate arithmetic. And finally, there's the TFHE scheme, which works with binary circuits and therefore could support more general purpose computation. And it supports comparisons on encrypted data. In terms of these three different schemes.
00:04:42.034 - 00:05:27.750, Speaker B: We can look at some of the tradeoffs here. Since most applications of FHE and web three are related to financial data and financial transactions, approximate arithmetic is generally not suitable, so we can immediately cross that scheme off in terms of the two remaining schemes, BFE and TFHE. The major tradeoffs there is that BFE supports super fast arithmetic. It supports very high precision, so you can easily do 64 bit computation. It has relatively small keys and ciphertext in comparison to TFHE. The downsides with BFE is that it's very difficult, if not impossible, to compare encrypted data, and you generally have slow bootstrapping. So here you might not be able to do truly arbitrary computation on encrypted data.
00:05:27.750 - 00:06:07.314, Speaker B: TFHE, on the other hand, offers super fast comparisons, very fast bootstrapping. You generally bootstrap with every single operation. The downsides is that arithmetic, particularly multiplications on encrypted data, is incredibly slow. The ciphertext and keys tend to be quite large, particularly in comparison to BFE. And finally, there are some serious precision issues with using this scheme, so it's often hard to do 32 64 bit computation when you look at TFHE. So we figured out two FHe schemes that might be suitable for us. We'd be looking at either the BFE scheme or the TFHE scheme if we're interested in applying it to web three.
00:06:07.314 - 00:06:46.586, Speaker B: So what actually happens in setting up an FHE scheme? So we're going to focus on BFE. But you can imagine there are similar considerations in setting up the tfhe scheme. So BFE works with polynomials, and particularly plain text are polynomials of less than degree n with coefficients mod p. Ciphertext are polynomials of less than degree n with coefficients mod q. P needs to be much smaller than q for security reasons. The first step you as an engineer will need to think about is how are you going to translate from numbers into polynomials? There are actually a number of different encoding techniques with very different trade offs. So we have the scalar encoder.
00:06:46.586 - 00:07:45.060, Speaker B: So essentially a trivial encoding taking a number to some constant polynomial. You have slightly fancier encodings like the integer encoding, that's similar to doing like a binary decomposition or a binary expansion. And you have fancier techniques like using the chinese remainder theorem to essentially vectorize the computation. After you figure out which data encoding technique you'd like to use, you now need to pick the scheme parameters. So particularly you're going to have to figure out how to pick the degree n, the plaintext modulus p and the Ciphertext modulus Q. The sorts of considerations you'll need to ask yourself in choosing these parameters are what kinds of computations are you looking to do? What sorts of ciphertext and key sizes are you okay with? And finally, what sort of performance are you looking to get? Another question you have to ask yourself is there's this special ciphertext maintenance operation called relinearization. Do you want to use it? If not, that might save you a little bit of time.
00:07:45.060 - 00:08:37.454, Speaker B: So for the first truth and lie, is fhe fast or slow? I would say that FHE is actually pretty fast, but the speed of the various operations are highly scheme dependent, and the speed of various operations is also highly parameter dependent. Another issue with FHE is that you really need to know how to effectively translate your program into a circuit. So let's look at how different schemes perform. We're going to focus on doing 32 bit computation. These are the two major schemes we've identified as being most suitable for web three. You can see there is a very significant difference in terms of key generation time, multiplication time and comparisons. So for BFB, if you're wondering why there's question marks for comparisons, that's just because it is unclear whether or not you can actually do comparisons.
00:08:37.454 - 00:09:21.886, Speaker B: It depends a little bit more on the exact computation. As we mentioned earlier, the performance of fhe also depends quite a bit on the parameters you choose. So if we look at the BFE scheme, one of the biggest factors in performance is the degree of the polynomial. So you can see here there's a pretty significant difference in terms of key generation time if you go up two parameter sets. Very significant difference also for decryption time and multiplication time if you go up two parameter sets. There is a similar issue for the TFHE scheme, not necessarily as extreme as for the BFE scheme. Here we're focused mostly on what sort of precision do you need? That really tends to affect the performance the most.
00:09:21.886 - 00:10:08.078, Speaker B: So you can see that multiplication is quite slow in both schemes, but there's about two x increase in time if you want to go from 32 to 48 bit computation. So to sum up what's challenging for fhe, well, you need to figure out the right data encoding technique. You need to figure out what the right scheme parameters are. You need to determine if you want to insert in this special ciphertext maintenance operation. If you're working with BFE, if you're working with TFHE, you have to manually manage precision issues. And finally, regardless of which scheme you choose, you need to know how to translate from programs to circuits effectively. A question you might ask is, can you create a compiler that handles these things? For us, the answer is yes.
00:10:08.078 - 00:10:53.580, Speaker B: But for the somewhat hot take of this talk, I would say that many fhe compilers do a serious disservice to fhe when it comes to performance. Let's look at what happens if we want to do a chi squared test on encrypted data. This application was chosen based on a recent SOK on FHe compilers from Oakland S and P 2021. We're going to look at how long it takes to generate keys, encrypt data, perform the computation, and decrypt. So if you're an expert who knows what they're doing, you can work with some super low level library like Microsoft Seal. You can write this yourself, and you can manually optimize it. This will take you about 00:50 3 seconds to do everything from key generation down to decryption together.
00:10:53.580 - 00:11:33.100, Speaker B: So how did the fhe compiler stack up? You can see that most fhe compilers do a pretty bad job. They add a huge overhead to the overall computation. The only two compilers that I would say have a reasonable overhead are Microsoft's AVA and Sunscreen's compiler. So for compilers to really be useful in this space, we really need for them to marry performance with usability. So we've narrowed down our FHe scheme options. We have figured out how exactly to set up our FHe scheme. Now we need to figure out how to prove stuff on our fhe encrypted data.
00:11:33.100 - 00:12:06.274, Speaker B: So there will be two things we need to prove about our fhe encrypted data. You will need to prove that your encrypted inputs are valid, I. E. The ciphertext are well formed. You will also need to prove that your encrypted data satisfies whatever application or contract specific conditions you're looking at. So, to go back to our motivating example of a private transaction, Alice the sender, may need to prove that the amount she's sending to Bob is greater than zero. She'll need to prove that she has enough money in her account to make this transaction.
00:12:06.274 - 00:12:46.430, Speaker B: She'll need to prove that she's encrypted the same amount with respect to both public keys. And finally, she'll need to prove that the ciphertext are well formed. For our second truth and lie, a question a lot of people ask is fhe useful or useless on its own? I would say that fhe without zero knowledge proofs in the web three space is frankly useless. You really need these two technologies to work together to do anything meaningful. There is a very large compatibility issue between these two technologies. FHE uses something called lattice based cryptography. The most efficient zero knowledge proof constructions do not use lattices.
00:12:46.430 - 00:13:18.762, Speaker B: How do you combine these two technologies and get good performance? That is an open question. It also turns out that in combining FHE and ZKPs, it is not fhe. That's the expensive part. It is Zkps. So the expensive part of the solution is proving you have a valid encryption. It turns out this is very expensive with regards to both prover and verifier time, you might consider using a latice based proof system, but you are likely to end up with gigantic proofs. We're talking hundreds of kilobytes to megabytes in size.
00:13:18.762 - 00:13:33.470, Speaker B: It's also unclear if prover and verifier times will be that much better than using something based on elliptic curve or hash based cryptography. And Rick will tell you all about the proof system we're currently looking at at sunscreen.
00:13:36.510 - 00:14:27.070, Speaker C: Thank you ravital. My name is Rick and I'm working on some of the zero knowledge proof stuff that I'm going to tell you about. So the first thing we have to do is we have to show that a ciphertext is well formed. And we are doing that using something called the short discrete log proof, whereby you set up your lattice relation as equals t, where a is a matrix that contains your public key. Among other things, t is your ciphertext and s is the witness known to the prover, which contains the message, the noise, and some other things kind of intrinsic to the proof. The prover then decomposes the coefficients in their polynomials into binary to show that they are sufficiently small. This is going to show that you're not making a ciphertext with an immense amount of noise that won't decrypt properly.
00:14:27.070 - 00:15:26.026, Speaker C: Then the prover has to make a commitment to it, a Pederson commitment to it, and shows in zero knowledge that their witness actually indeed satisfies this as equals t relation. So once you've actually implemented this proof system, the prover times turn out to be pretty reasonable. The proof sizes are under 2 kb. Unfortunately, the verifier times are still several seconds long. So if you were to actually deploy the system as is, you would run into some challenges. The reason for this is the short discrete log proof uses an inner product proof similar to bulletproofs. And so, as you show, if you want to prove that, say, more ciphertexts are well formed, or if you want to increase the lattice dimension you're using, or if you want to increase the ciphertext modulus, all of these things will blow up the runtimes of this proof.
00:15:26.026 - 00:16:17.330, Speaker C: And so we're currently working on using GPUs to accelerate scalar inversions, scalar multiplications and multiscalar multiplications. Surprise, surprise, that's a recurring theme. So we're trying to speed all these things up so that we can get reasonable verifier times. So once we've shown that a ciphertext is well formed, we now need to show that the messages within these ciphertext obey whatever properties the system requires. So for example, when I want to send ravital some money because I spent too much on a drink last night, I have to show that the amount I'm sending her is not a negative value and I have to show that it's less than my account balance. So to do this, we use bulletproofs for many of the kinds of things we want to show. We're doing simple comparisons, for example, in zero knowledge.
00:16:17.330 - 00:17:16.078, Speaker C: These are fairly small, they're under 1000 constraints, under 1000 multiplies. Prover times are well under a second, verifier times are 50 milliseconds somewhere there about, and proof sizes are also under 2 kb. So bulletproofs are perfectly fine for this. So now that we have an R one cs circuit that shows some kind of properties of some messages in ciphertext, and we have the short discrete log proof showing the well formedness of some ciphertext, how do we show that the inputs to the R one cs circuit and then the message that's going into them is in fact the same message you used when proving your well formless of the ciphertext. And it turns out both proof systems use a pettit commitment at their core to their inputs. And so what you can do is use the same generators for both proofs. Neither of them uses trusted setup.
00:17:16.078 - 00:18:20.310, Speaker C: You can break the Pederson commitments into two parts in both proof systems, into a shared component and a non shared component. The approver can publish the shared commitments and the, I guess, non shared ones as well. And then the verifier can pass the same shared commitment to both proof systems, regenerate the total commitment, and continue with the proof. The approver also needs to, I think they need to reuse the blinding factor in both proofs so that the stars align and the proofs can be verified. So rather than just using bulletproofs r one cs directly, we built a compiler so that maybe we're not married to any particular proof system if we ever need to change this in the future. Our zero knowledge proof compiler is currently ongoing work, but we already support gadgets types and you can use public or private inputs. So some of the inputs may be known to both the prover and verifier, some of them only to the prover.
00:18:20.310 - 00:19:07.542, Speaker C: And the approach we're taking with this is very similar to our fhe compiler where you write a circuit, you describe it as a function in rust, and you put this nice little macro on it, and then you can pass that function to the fhe compiler and it will spit out a directed graph of all the things that need to happen. And the nice thing about this is you get in visual studio code, you get like little red squiggles when you make mistakes. You get syntax highlighting, you can publish these things on crates. IO you get all of this for free. We didn't have to build any of this infrastructure. And the API for using R one CS circuits in sunscreen is very similar. Simple and exactly what you'd expect.
00:19:07.542 - 00:19:59.080, Speaker C: You compile an R one CS circuit, you can then prove that you know a witness that satisfies it and the verifier can then just verify that proof. But as we mentioned, we also have these short discrete log proof and these things are a bit nastier. You have this, a matrix. And how do users express this? Like here I want to show the, well, formless of three ciphertexts. So what does that API look like? Furthermore, users are going to need to specify which parts of the witness they want to share between the two proof systems. So that API is also kind of indeterminate and we're still thinking about that. So if you want to build an fhe compiler for web three, you have to tackle a number of issues.
00:19:59.080 - 00:20:44.150, Speaker C: It needs to support a scheme that is actually important to web three. So BFE or TFHe, you have to make circuits that run on the order of milliseconds, not minutes. You have to effectively use the hardware in your machine when running the circuit. Sunscreen does this today. It will automatically parallelize execution down your dependency graph and the kind of primitive types used in the FHE schemes. So in BFX for example, they're polynomials over ZP, which are really annoying to work with. So your compiler should ideally expose types so that users can play with things that are more friendly, like integers.
00:20:44.150 - 00:21:27.982, Speaker C: Some operations like relinearization, which you should do after multiplications, the compiler can automatically insert these for you so that users don't have to think about them. And finally, most compilers today, they think of the world as you're going to compile and run this one circuit. So you feed some inputs to it, you run the circuit, you get some outputs and then that's the end of the story. You don't do anything else like maybe you decrypt the output, but in web three this isn't really how things work. You're going to have some data that's on chain and maybe I send ravital some money and so this impacts and decrements my balance. Then she sends me some money. This increments my balance.
00:21:27.982 - 00:22:08.340, Speaker C: And so the same ciphertext is being transformed over time. And so the data is actually going through multiple circuits, potentially even different circuits. And finally, as we've kind of explained, you need zero knowledge proofs to go along with fhe. Otherwise I can just send random values to the ether and who knows, you're just going to random garbage if you do this. So you have to prove that the input is well formed, invalid. So is fhe currently usable? Unusable. Well, we need a bit of tooling before we can truly use it in web three.
00:22:08.340 - 00:22:55.600, Speaker C: In particular, we need the tight integration between zero knowledge proofs and fhe. So now that we've kind of discussed some of the challenges facing fhe and its adoption in web three, we can start approaching talking about solutions and how we solve some of these problems. So thanks for attending the talk. You can follow us on Twitter at sunscreen Tech, or you can visit our website, sunscreen Tech, from which we have links to our discord server, to our Twitter, our blog and our GitHub repository. And very excited that we have a zero Knowledge podcast episode coming out tomorrow where ravital talks about Fhe. And so with that, I'll open the floor to questions.
00:23:06.470 - 00:23:12.610, Speaker A: First of all, thank you for the talk. Is there any of these is open source?
00:23:15.610 - 00:23:32.940, Speaker C: Yes, we actually have a playground. So if you go to playground sunscreen tech, you can try it out in your web browser. Alternatively, on our GitHub, all of this is open sourced and additionally we have some crates published, so you can just download as a dependency and use it.
00:23:35.630 - 00:23:51.570, Speaker A: Questions? Second, so I'm offering if you can support.
00:23:53.480 - 00:23:55.270, Speaker C: I'm sorry, support what?
00:23:56.200 - 00:24:13.770, Speaker A: Here you support generated actually dividend and it's different from just the financial. So I'm wondering if you can support.
00:24:18.640 - 00:24:37.180, Speaker C: I don't think we currently have any plans to support those, but that's something we can investigate in the future. Maybe you should answer that one.
00:24:38.350 - 00:24:56.510, Speaker B: So this project started out while I was a cryptographer at Newscypher. I was working on secure, private, functional smart contracts. You can guess that abbreviates to SPF. The founder there hated that name, so thankfully it turned into sunscreen.
00:24:59.330 - 00:25:27.290, Speaker D: Did we take one moment at a time. If we take a broader look at use cases, I would love to hear an example of a use case that's uniquely enabled by FHG. Rather than just homomorphic encryption, you could describe an app that works with it.
00:25:28.540 - 00:25:30.830, Speaker C: Right. Do you want to talk about some of those?
00:25:33.440 - 00:26:10.490, Speaker B: Yeah, so I would say there's a few things going on there. I agree that a lot of applications just need homomorphic addition by itself, particularly private transactions, so that's not the best use case. What we're really imagining is that using fhe combined with zero knowledge proofs can be a more lightweight solution for the user because there is less things for them to prove. So we're imagining it as supporting general private smart contracts in terms of interesting applications of fhe outside of web three. Of course a lot of people are interested in private machine learning, so doing private inference where you definitely need homomorphic multiplication, I hope that answers it.
00:26:14.290 - 00:26:17.980, Speaker A: One more way. What.
