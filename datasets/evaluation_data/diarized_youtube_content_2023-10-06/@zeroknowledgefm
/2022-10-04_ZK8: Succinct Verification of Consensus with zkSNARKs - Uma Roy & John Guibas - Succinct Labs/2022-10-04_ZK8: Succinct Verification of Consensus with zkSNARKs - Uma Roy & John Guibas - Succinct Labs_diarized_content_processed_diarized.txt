00:00:06.730 - 00:00:07.134, Speaker A: Here.
00:00:07.252 - 00:00:19.390, Speaker B: Let's welcome Uma and John, who will be presenting about Zksnark enabled light client and bridge for e two clients. Anyways, give them a quick round of applause.
00:00:30.410 - 00:00:45.130, Speaker C: Hello, I'm uma, and this is John. And today we're going to be presenting on succinct verification of consensus with ZK snarks. How do we.
00:00:45.660 - 00:00:47.096, Speaker A: Maybe it's not on.
00:00:47.278 - 00:01:37.236, Speaker C: Okay, yeah. So let's start with a 10,000 foot overview of the multichain and cost chain landscape. In the past few years, there's been a ton of different blockchains that have come online, and they lie on very different points of the tradeoff curve in terms of decentralization, security, throughput, transaction fees, et cetera. And as the number of applications has grown across all these different chains, users generally want to interact between these chains. So some of the things they want to do include transfer assets from one chain to another. And currently, a lot of builders are also exploring other applications of cross chain interoperability that go beyond asset transfer and the current space of crypto. One of its main promises is that it really delivers on permissionless interoperability.
00:01:37.236 - 00:02:38.380, Speaker C: And so if users do want to use multiple chains and multiple different ecosystems, then we should allow these ecosystems to operate in a permissionless, decentralized, and secure fashion. And because of this, we believe that bridges are actually very critical infrastructure in the whole space. So what's the state of bridging today? There's a lot of user demand for bridging. And what does it look like? Right now, all the bridges, or most of the bridges, go through very centralized entities. In particular, most l one bridges today are built on top of a multistake architecture, where you have a centralized entity controlled by a set of trusted parties that's responsible for watching deposits on one chain and then signing off on deposits on another. And this is really bad because a lot of assets flow through these bridges, and it's kind of this centralized choke point of the blockchain ecosystem. And not only is this ideologically bad, it has real consequences.
00:02:38.380 - 00:03:51.744, Speaker C: The multifig design is very censorable, and also, practically speaking, there have been a lot of hacks of these bridges. So in particular, there have been many bridge hacks over the past year or so that have resulted in over a billion dollars of user funds being lost. And I would argue that this is not only bad for the users, it's actually bad for the whole space in general, because it lessens the credibility of the entire space, and then it leads to downstream consequences like regulation okay, so I've talked a lot about the current problems with the bridging landscape, and so let's start talking about solutions. So what does a maximally secure and trust minimized bridge look like between L ones? So if we were in a world in which onchain computation was not expensive, and we didn't have to worry about those practical limitations, then a really simple and elegant solution comes to mind. We already have a method for a decentralized group of validators to agree on the state of a chain. It's called a consensus protocol. And so we think that if we were able to verify the consensus of one chain in the execution layer of another chain, then we can use the same mechanism that's already being used to agree on the state of the chain for bridging.
00:03:51.744 - 00:04:07.856, Speaker C: We call this verification of consensus. And we think that if we're able to do this, then it provides a really great solution for more secure, decentralized and permissionless bridging. It.
00:04:07.978 - 00:05:10.808, Speaker A: Yeah. So before we get into how to actually verify consensus in a practical manner, let's zoom out a bit and try to understand the high level overview of how you might be able to build a bridge or a cross chain communication protocol over this idea of verifying consensus. So in practice, you're going to have some blockchain like Ethereum, and over the course of its lifetime, it's obviously generating block headers, validator signatures, attestations and other metadata as part of its consensus process. And this information is normally gossiped over the network to other validators. But what we can also do is we can propagate this information to a smart contract running on another blockchain, such as gnosis chain. And inside this smart contract, we could theoretically reimplement all the logic we would normally run to verify consensus. And the reason why this is super powerful is because if you can verify consensus, you can sort of keep like an append only list of finalized block headers on this target chain, such as gnosis chain.
00:05:10.808 - 00:06:39.604, Speaker A: And if you have access to the blockheaders, as you probably know, we have access to all of these Merkel tree commitments to the entire state of Ethereum, all the transactions that have ever been submitted, all the events that have ever been emitted. And basically we can trustlessly read any of this data as long as we provide a valid Merkel inclusion proof against these commitments. So why hasn't this been done yet? Well, it's because in proof of stake systems, verifying consensus is just a generally very hard problem on consumer hardware with not that much resources in general, for Ethereum, there's two big challenges. So the first challenge is that there's a lot of validators, and the number of validators is something that you have to keep track in your client, which is trying to verify consensus, because you have to know the validators public keys and how much east they have staked to accurately calculate how much their signature is worth. The second problem in particular with the EVM, is that there are no pre compiles for the elliptic curve operations, which the Ethereum two signature scheme is based off of, which is this curve known as BLS twelve 381. So the developers of the theory ecosystem actually recognized that verifying consensus cheaply is sort of an important primitive to have for your blockchain to run light clients. So they sort of introduced this easier to verify consensus algorithm on Ethereum, and it's known as this protocol called the sync committee.
00:06:39.604 - 00:07:44.856, Speaker A: And basically the way to think about this is that instead of having 400,000 validators running consensus on the chain, you select a subset of 512 validators, which are chosen randomly every 27 hours. And basically these validators will just sign each block header and if enough of them vote on it, it's considered valid. Now the trade off here obviously is that at the cost of it being easier to verify, you obviously have much weaker security guarantees, as you're assuming that two thirds of these validators are acting honestly. So we explored this method at first to see whether we could basically build a lite client on chain with just like these 512 validators. But we found basically in practice, is that even verifying this consensus mechanism on chain is too gas expensive. Now the practical reasons for this are that you have to store these 512 valid republic keys and prove that they validly rotate every 27 hours. There's also this problem again, which I mentioned previously, where we don't support the elliptic curve operations currently on the EVM needed for these signature schemes.
00:07:44.856 - 00:08:40.796, Speaker A: So for every header you want to finalize, you might have to do up to 512 curve additions and one final pairing check on chain. So what's our solution? Well, our solution is basically to use the technology that zk summit is all about, and to leverage the power of succinct zero knowledge proofs. So what I mean by that is that in your smart contract you're going to have some function that's validating new blocks. And in practice, what we're doing in there is some preprocessing step, some check that the current validator set is valid, and then finally we check like the aggregation and the final signature check. And as I mentioned multiple times before, the big two challenges are these two bottom functions that I highlighted in red. And essentially what we can do is that we can move all this expensive compute off chain, just wrap it up into a ZK snark. And what we can do instead on chain is just verify this super easy to verify graph 16 proof on chain.
00:08:40.796 - 00:09:46.420, Speaker A: And that basically makes it super gas efficient to run these light clients on chain. And I think more broadly speaking, while we did this design originally for the ETH two sync committee, you can essentially think of this as a roadmap to basically creating light clients for a wide variety of consensus protocols, including full Ethereum consensus. And I think this is really exciting because we're obviously seeing how zk snarks are being used to scale the execution and throughput of blockchains. We're also now seeing how zk snarks can scale the interoperability and composability of blockchains by making it easier to verify the consensus protocols that these blockchains run. So we're calling this basically like proof of consensus crosschain communication, or proof of consensus bridging. And essentially the idea again is to use these decay scenarios to generate a validity proof of the state of the chain. And we basically believe that this sort of bridge design, where you're running light clients on the target chain that can trustlessly prove the state of the source chain, is sort of like the end game design for trust minimized interoperability.
00:09:49.000 - 00:10:27.424, Speaker C: Okay, so John talked about the high level approach, and now I'm going to dive into some more technical details, in particular to the implementation we did for the Ethereum sync committee. So as John previously mentioned, the sync committee does two things. Members of the sync committee, for each header they generate a signature. They generate a BLS signature for each header they believe to be in the canonical chain. And then that signature gets aggregated. And so for each header there's an aggregate BLS signature from validators in the sync committee and a proof that we generate of that signature being valid. The other thing the sync committee does is every 27 hours it rotates its members.
00:10:27.424 - 00:11:17.344, Speaker C: It's important it does that for security reasons. And so the current sync committee basically signs off on the next sync committee public keys. And we have another snark that basically validates this rotation. And we have a trick we use in there to reduce gas costs so that we never have to actually post the sync committee public keys on chain because that's expensive. So yeah, we have two snarks, one snark that verifies this BLS signature is valid over the header and the other snark that validates this rotation. And without going into too too much detail of the snarks, basically we have these two snarks, and we had to develop a suite of primitives that we built in circom to actually generate these proofs. So I'm going to just go over some of the primitives we had to develop, and we hope that it's generically useful for future work.
00:11:17.344 - 00:12:17.620, Speaker C: So the first primitive is BLS public key addition to get the aggregate public key of all the sync committee members that are signing and generating a proof of aggregate verification. The other primitive we worked really closely with our collaborators at Xerox park over the summer for implementing pairing inside of snark, and we use that primitive to verify the BLS signature. And so one thing to note here is all the arithmetic we do for the pairing and elliptic curve stuff is done in the BLS twelve 381 field, which is different than the field that we're doing the arithmetic in the snark. So we have to do this out of field arithmetic. Other primitives we had to implement were the commitments to the snark public keys, or commitments to the sync committee public keys. So we had to implement simple serialization, which is what ethereum two uses for serialization, SSZ for short. And we also implemented a snark friendly commitment to the public keys with a Poseidon commitment.
00:12:17.620 - 00:13:42.636, Speaker C: So I previously mentioned this trick we did for reducing gas costs of storing public keys on chain. So just at a very high level, snarks have public keys and snarks have public and private inputs, and the public input is in red because it's bad, because that means if we're verifying a snark proof on chain, we have to store the public inputs on chain. And a private input is in green, and it's good because it's invisible on chain, so we never have to put it on chain. So, naively, if we were to implement verification inside of snark, we would have to have the public keys as public inputs, because we have to check that the signature is from a known set of validators, right? Unfortunately, as I mentioned, storing public keys on chain is expensive also, because the set of public keys in the sync committee rotates every 27 hours. So we decided, what if we just store a commitment to the public keys? So you basically hash all the public keys together and store this commitment on chain, and then inside your snark, you prove that the public keys which are now a private input belong to this commitment. But because the sync committee rotates, we have to update this commitment, and it's not super clear how to do that. So one idea is when the current sync committee signs the next sync committee, they actually sign a SSD serialization of the public keys.
00:13:42.636 - 00:14:43.936, Speaker C: So one idea is we just use the SSD of the public keys as the commitment, which is pretty simple. But the problem is that the SSD is very snark unfriendly, and so it's super expensive to compute in every header verification snark, because SSD is just a bunch of shahs which is very snark unfriendly hash function. So our idea was when updating the sync committee, we would verify a proof that would take in the new public keys, assert inside the snark that it corresponds to the SSD serialization, and then also compute Poseidon serialization of the public keys, which is very snark friendly. And with that we are able to map the snark unfriendly commitment to a snark friendly commitment. And what we store on chain is just a snark friendly commitment. And what this gets for us is it saves us 70 million constraints, which is quite a lot in every header verification snark. So yeah, hopefully this trick can be useful in other contexts as well, and just some benchmarks.
00:14:43.936 - 00:15:17.260, Speaker C: So as I mentioned, we have two different circuits. The sync committee rotation circuit has way more constraints because of this SSZ thing I mentioned. But for both circuits the total witness generation postproving time is on the order of four to five minutes. So our methods are actually really practical. In ethereum you have to wait for finality anyways, which is two epics, which generally is maybe around the twelve minutes. So on top of that you have to wait an additional like four minutes for proof generation. And we think that more modern proving systems can reduce this time quite significantly.
00:15:17.260 - 00:15:19.680, Speaker C: And so hopefully the delay is quite minimal.
00:15:23.300 - 00:16:11.836, Speaker A: Yeah, so we've been working on this for the past few months, and everything we described in the presentation we've actually implemented, we implemented the light client and we've also got in like a prototype bridge working on top of it. You can go play around with it. I think now it's at just async XYZ, fair warning, it's in beta and the mobile support is bad. But yeah, here's just a few screenshots of it working. It's just like a normal token bridge demo. You just choose your network, you choose your token, you say how much you want to send over, and then you'll basically just submit a transaction. And then basically behind the hood what's happening is you'll make a deposit on Ethereum, and basically what you have to do is you have to wait until the light client on the target chain gets updated with a block header which can Merkel prove your deposit.
00:16:11.836 - 00:17:03.580, Speaker A: So that'll happen after like twelve minutes, plus the three minutes for proving, and then we'll submit a transaction to update the light client and basically to withdraw your assets. You'll just basically provide a Merkel proof proving that your deposit is validly represented in the ETH state route. And after that you'll have your assets. And yeah, you can go play around with it. It's all online. But anyways, yeah, to zoom out a bit about what the pros and cons are of these proof based bridges are, first, obviously because we're able to borrow the security of the consensus protocol, in theory, you could borrow the entire security of Ethereum. Here your bridge is going to have much higher security guarantees, especially when compared to existing bridges, such as multistig bridges or bridges based on smaller decentralized networks.
00:17:03.580 - 00:18:05.220, Speaker A: Another pro is like in a world where there's like an operator implementation where anyone can generate proofs, theoretically, for example, you could incentivize people to submit proofs on chain and maybe they get a small percentage of the fees that the lite client is making or something like that. And for these reasons, it's just much more decentralized and I think aligned with a lot of the values we care about in blockchains. And at this trade off, there's obviously some cons. Verifying like a snark proof is obviously more expensive than just checking that five out of the seven validators have signed. There's also some latency that you're incurring because of the proof generation time, but maybe that can be reduced by an order of magnitude and also in terms of scalability. One challenge here is that for every change you make to a consensus protocol, or for every difference in consensus protocols for different blockchains, you have to kind of go ahead and hand design your snarks, and maybe you have to get them audited and stuff. So that can be a huge developer bottleneck for building these type of bridges.
00:18:05.220 - 00:18:59.668, Speaker A: In terms of our future roadmap, we kind of want to become a trust minimized and decentralized interoperably layer for Ethereum and other decentralized blockchains. And in the short term, we're actively working on building what we're calling these succinct, light clients for other consensus protocols. And we also want to start working on moving away from the sync committee, which only has a security of 500 toll validators, and work towards a world where we can verify all 400,000. Furthermore, we sort of want to also explore applications such as governance and identity outside of token bridging. But yeah, that's what we're thinking for now. Before we end, I just want to give a big thanks to Gnosis Dao, who was generously, very funded us a lot for this work, and also Xerics park, where we worked out this summer, and we borrowed a lot of ideas from the people there. And yeah, that about wraps it up.
00:18:59.668 - 00:19:07.130, Speaker A: If you want to collaborate or if you have any comments or thoughts, I'd love to hear them and come find us afterwards. But also if we have time, we can take questions now.
00:19:15.280 - 00:19:21.500, Speaker B: So we have about a little bit over five minutes if anyone has any questions for Umanjan.
00:19:30.090 - 00:19:36.920, Speaker D: First of all, congratulations and thanks a lot for doing this. This was way overdue. This like should have.
00:19:37.370 - 00:19:37.830, Speaker E: Awesome.
00:19:37.900 - 00:19:55.920, Speaker D: You guys are pushing this. Just maybe if you could. So you use this sync committee from e two. Can you elaborate a little bit more how you prove that this next set of signatures is constrained to be the correct one? Just to get questions started?
00:19:56.770 - 00:20:29.430, Speaker C: Yeah. So the current sync committee signs the public keys. In the next sync committee, they do something like, something very equivalent to this. So you just have to verify that the signature of this header that includes these next sync committee public keys is valid. And then, as I mentioned with the trick where we map this commitment to the public keys from being a snark friendly commitment or snark unfriendly commitment to a snark friendly commitment, that's just to reduce the gas costs of not having to store these public keys on chain.
00:20:31.850 - 00:20:54.380, Speaker B: Great question. Are there any more questions? In fact, there should be more questions. If there's like nobody who has any questions, I'm shocked. I guess you did such a good job that we have. Oh, all right, there we go. Hang. No, no, sorry.
00:20:54.910 - 00:21:05.060, Speaker E: Just quickly, maybe you mentioned it, but I could have missed it. So how do you handle equivocation if the current sync committee signs multiple seating ones?
00:21:07.190 - 00:21:08.900, Speaker A: Sorry, could you repeat the question?
00:21:09.930 - 00:21:18.840, Speaker E: Yeah, but if they sign multiple disjoint subsequent sync committees to follow them.
00:21:20.010 - 00:21:57.170, Speaker C: He's saying if they basically double sign. Currently the sync committee, there's an honesty assumption on the sync committee where if they double sign, they're not penalized for this. So you have to assume the members of the sync committee are honest. Of course, if you validate full Ethereum consensus, or validate some subset of Ethereum consensus using the duties the validators normally do, then you don't have to worry about this problem. So the assumptions of a sync committee are definitely a lot stronger than the assumptions on full Ethereum consensus.
00:22:01.610 - 00:22:27.070, Speaker F: Hey, so this is kind of a philosophical question, but do you think that it's better for decentralization overall to have a consensus protocol that has many, many validators but no real practical lite client, or one that has fewer number of validators, but where the light client is very easy to run on any device?
00:22:32.930 - 00:23:13.340, Speaker A: Yeah, I think this is one point Uma made a few times to me, but I think basically having a lot of these, I think in principle having one big network, decentralized network is probably better. I think the Ethereum and roll up future is actually pretty secure and pretty nice. But I think one thing is basically having multiple of these l ones is a point of meta decentralization where maybe you don't have so much lock in into, for example, the EVM or framework, you're too much relying on the ETH consensus protocol operating correctly. And by having many of these other l one chains, you can sort of hedge against sort of bugs being introduced into a piece of software that's so important.
00:23:15.070 - 00:23:48.920, Speaker C: Yeah, I think also your point about in other consensus protocols maybe you have less validators or something, and it's easier to have a like client. I think if we accomplish one of our goals, which is to verify all 400,000, or someday maybe it's more ethereum validators and verify all of their signatures and verify the consensus in a snark, then you can have a light client with a lot of validators. So I think this is kind of like working towards that future as well. Obviously it's technically very complex, but I think it's possible if we're able to do it. Yeah.
00:23:51.230 - 00:23:57.660, Speaker B: Cool. I guess I'm all the way back here, but are there any last burning questions? All right.
00:24:02.430 - 00:24:08.640, Speaker D: Hello guys. Do you still use gross 16 as your zk improving system?
00:24:09.490 - 00:24:39.670, Speaker C: Yeah, we used circum to make these circuits. So that uses Grout 16, or I guess it also has plonk, but we use the Grout 16 version. But one of the main benefits of Circom and Grout 16 right now is that has a really stable, really trusted, used on chain verifier, like for example in tornado cache. So it actually makes it practical right now. But as these newer generation of proving systems get more proven out, especially with Zkevm and stuff. We definitely want to reimplement this stuff and get all the efficiency advantages.
00:24:40.170 - 00:24:41.160, Speaker D: Thank you.
00:24:44.430 - 00:24:48.730, Speaker G: We've got a question from the chat, the live stream chat all the way back here.
00:24:48.800 - 00:24:50.074, Speaker B: All right, go for it.
00:24:50.192 - 00:25:07.140, Speaker G: Jeremy asks if I make a malicious ERC 20 token, for example, only transferred to my address on one L one and bridge it to another. Does it emerge as a, quote, normal ERC 20 on the second L one? Does sync committee check code?
00:25:10.390 - 00:25:34.330, Speaker C: Yeah, I think this is like a problem any bridge has or something. So I think most bridges deal with the sync committee does not check code. We're mostly making this cross chain communication protocol for getting one chain state on another chain state, and then what you do with that if you choose to make a token, like, you have to figure out what cases you're going to handle.
00:25:37.630 - 00:25:41.190, Speaker B: All right, well, let's give it up one more time for Umanjohn.
