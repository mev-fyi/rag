00:00:07.370 - 00:00:43.100, Speaker A: Hello, everyone. I'm very excited to present this workshop about Jubix. It's a really interesting project. It has many ideas. It has evolved during this last year. My name is Jonathan Cuides and I also prepared this with Paul Katman, which unfortunately couldn't come today, got sick and. All right, let me try to say a few of the goals that I have for this talk.
00:00:43.100 - 00:01:39.500, Speaker A: I want you to understand what is Juvix? Why we are building this new programming language for anoma. And I believe we can use Juvix also for other different purposes. And in particular, since we are here in CK summit, I would like to just present a little bit about the compiler infrastructure to support serenolis proofs. And my main objective today is that you can try Uvix yourself on your machine. So I hope you can open your laptops and try with me all the exercises that we prepare for you. All right, before delve into the specifics of the talk, I believe it's important to just mention the people that is behind this project. We are a group of five.
00:01:39.500 - 00:01:59.006, Speaker A: We are mostly just mathematicians or computer scientists with a background in formal verification and type theory. This is my team is Paul Kadman. Jonathan it's my name. And Lukash Shaika and Arten Gudev, and Jan Mans.
00:01:59.038 - 00:01:59.854, Speaker B: Roberta.
00:01:59.982 - 00:03:00.840, Speaker A: That's the team. So in very short terms, Jubix is this high level language that we have for writing anomal applications. We are designed this language to have privacy preserving, decentralized applications. And I would like to give some context will justify why we are creating this new programming language. So Anoma, this is the definition of anoma. It's an intent centric architecture for decentralized counterparty, discovery, solving, information flow control and atomic multi chain settlement, right? And I just said that Juic is this programming language that you are going to use or that you can use to write applications for anoma. So for improve the understanding of Anoma here, I prepared this.
00:03:00.840 - 00:03:47.234, Speaker A: So Anoma is based on the concept of intent. So this is really central. It's a primitive in this context. And an intent is basically just a message that express how you want the state change, right? So it's a high level description. It's a program that encodes your preference about how the state is going to change. So we have here, this is a simple example of two paria change, right? We have three actors in this. We have Alice and Bob.
00:03:47.234 - 00:04:16.286, Speaker A: And Alice has the intent. He wants to get one unit of dolphin and is willing to trade either one unit of item a or two units of item b, that's Alice. And we have Bob, who has also the desire to trade one unit of dolphin. He can trade one dolphin for one unit of a.
00:04:16.468 - 00:04:16.910, Speaker B: Right.
00:04:16.980 - 00:05:00.026, Speaker A: That's the preference. And we have in a noma, a component that is called Tiger. Tiger is framework for shield transactions, but is the component in enoma that is in charge of dealing with this intent. And there is another concept that we have in Tyga that is called partial transaction. So before to submit any transaction to the blockchain, we need to prepare it. And the way that we need to do that is to create partial transactions. And once you encode that in something that Tyga can't handle, we put this into a gossip pool where all the intents go.
00:05:00.026 - 00:06:00.350, Speaker A: And there is another component in enoma that is the intent solving. So we have solvers, and solvers are basically just algorithms that can be users as well, or just other programs. And these solvers, they can unfold information about this intents, about this parcel transaction. And there are some other specifics that you can use in order to get a matching between the preference of Alice and Bob. And once you find a matching, then you can get the finalized transaction and submit that to anoma. Of course, I'm oversimplifying many details here. If you have any questions regarding the cryptography, I have here my colleague Alberto, who is the person that is designing Tiger as well.
00:06:00.350 - 00:07:05.430, Speaker A: And yeah, all this concept of intents, me with my team, we are just developing the programming language. So the programming language looks like what you have on the right. So we have an API for Tiger, and you should encode every intent in what we have modules here, right? So I don't really expect you fully understand all the encoding here, but as I said, an intent, you need to encode it as a partial transaction. For example, Alice, I said that is willing to trade one unit of a or two units of b for one dolphin. So in tiger you have these two components of a party transaction. So you said what are you going to consume and what is going to be available later?
00:07:05.500 - 00:07:08.840, Speaker B: That's the created pair, right?
00:07:09.690 - 00:07:35.210, Speaker A: So you can see here that you have one unit of a or two units of b, right? And we have an or encoding for the Alice intent. So this part gets a little bit more trickier because you need to encode the logic, which are just the conditions for your transaction to be valid.
00:07:35.370 - 00:07:35.934, Speaker B: Right?
00:07:36.052 - 00:08:00.600, Speaker A: So you can express this using this predicate, which is just a function that gets value into bull. And there is this encoding, by the way, just taking this example from the documentation so you can just go to docs jvx.org and just follow this.
00:08:01.850 - 00:08:02.518, Speaker B: All right.
00:08:02.604 - 00:08:35.300, Speaker A: And there is other components. And also, if you're interested, how exactly the transaction lifecycle is, we included like a client server sequence diagram for you to understand. This is the long term. This is like the main goal for Jubix is to be the language in which you can write these intents to able to create these transactions on the animal blockchain, basically.
00:08:37.670 - 00:08:40.660, Speaker B: Right. Okay.
00:08:43.350 - 00:09:39.318, Speaker A: Let me go back to my. So that's the reason why we're creating a new programming language. And it's important because anoma itself can be seen as an operated system, right? Where the primitive notion is the intent. And as any other operated system there is a notion, a model computation, which is not the same as the computer that we are running these slides. So those details are what makes special Juvix, because we are targeting a different model of computation. But the specifics, I'm not going to go into the details. Anoma and Juvix are these two projects that are on heavy development and we are figuring out all the details about how to make the things work.
00:09:39.484 - 00:09:40.200, Speaker B: Right?
00:09:44.090 - 00:09:59.926, Speaker A: Yeah. So these are our three main goals for Jubix. And we plan to be a language jointly with the compiler for anoma, basically.
00:10:00.048 - 00:10:00.720, Speaker B: Right?
00:10:02.210 - 00:10:53.470, Speaker A: Yeah, these are our main goals. However, while developing the language, we are not really limited to anoma. We are actually reaching the point where Jubix can be just a general purpose programming language. And as I said in the beginning, we have a pipeline that compiles to serenolis proof, which I believe is what you are here. So our compiler starts with file that is written in Jubix. This is the extension and we perform different static analysis. Of course we need to parse the file and we have a type checker and we have this Jubix core, which is the main core language is just anti lambda calculus with some extensions and some optional typing.
00:10:53.470 - 00:11:15.810, Speaker A: And for this intermediate representation we have backends, we have native binary output we can deploy to wasm. We have these in house compilers that are called vampire and gap. And the purpose of these two backends is to produce serenol sprue.
00:11:17.130 - 00:11:17.880, Speaker B: Right.
00:11:21.130 - 00:11:51.562, Speaker A: So I was checking on the lock of CK summit and I found that there are some talks about vampire. So you can check it out online. You take Jubix and you generate vampire code. And this is our in house compiler that can produce halo two circuits. It's basically an proof system agnostic compiler.
00:11:51.706 - 00:11:52.400, Speaker B: Right.
00:11:53.430 - 00:12:28.454, Speaker A: We have currently just support for Halo two and plunkish circuits. So let me talk about a little bit the language itself. We decide to create this language in the same fashion as ML or Haskell. So Jubix is just another language in the ML family. And the main reason is because the intents are just declarations about your preference.
00:12:28.582 - 00:12:28.970, Speaker B: Right?
00:12:29.040 - 00:13:46.310, Speaker A: So you specify exactly what you want, but you don't specify how this really matches with the declarative style of programming. And something that we decide like this is our design choices. The language is strongly type and the evaluation strategy is strict, so we have strict semantics, and we are just taking feature from the mainstream languages. So we have purity, we have totality, so we enforce your functions and your data type declarations to pass certain static analysis. You have immutability, pattern matching traits, referential transparency, so on and so forth. Jubix is just, this functional language is string complete by certain annotations. And you can go to the documentation we have, provide reference of the many constructs of the language.
00:13:46.310 - 00:14:00.810, Speaker A: And if you are more curious about the specifics of the language, we are also making some aspects, some formal aspects about the language.
00:14:02.750 - 00:14:03.258, Speaker B: Right.
00:14:03.344 - 00:14:11.152, Speaker A: Okay. It seems like I don't have Internet here. Yeah.
00:14:11.206 - 00:14:11.810, Speaker B: Okay.
00:14:13.160 - 00:14:49.760, Speaker A: Yeah. So we have in the language these characteristics, which is referential transparency. You expect that a program with the same inputs produce the same outputs. That's something that you expect. We have a module system, so you can modularize your program. You have top and local modules, you have these open import statements, so you can bring to scope different identifiers, names, and you can select imports, you can hide things. We also have a red repl so you can interact with the language.
00:14:49.760 - 00:15:32.508, Speaker A: And we are very proud of this documentation tool. It's really nice. You can just in the same way that you put comments on your code, you can put doc strings or kind of what you find in Haskell with Hadoc I'm going to show all these things quickly. And we are just building an ecosystem around Jubix. So we have a few libraries already, and I really expect at some point people will start contributing to the ecosystem with your libraries. We need cryptography, we need many other things.
00:15:32.594 - 00:15:32.844, Speaker B: Right?
00:15:32.882 - 00:15:42.064, Speaker A: So at the moment we just have support for data structures. We have property based testing a lot. Quick check.
00:15:42.182 - 00:15:42.608, Speaker B: Right?
00:15:42.694 - 00:16:15.770, Speaker A: And we have a unit test framework if you want to do. All right. So may I ask how many of you are willing to try on your machines? Jubix, I hope. Yeah, I will try. So the idea is just to go like very high level. I will not go into the technical details. Everything is in written form so you can just find it on the website.
00:16:16.720 - 00:16:19.420, Speaker C: When you press the install Jubix on your machine.
00:16:22.990 - 00:16:23.562, Speaker A: Oh really?
00:16:23.616 - 00:16:25.660, Speaker C: I'm not running your server there.
00:16:26.430 - 00:16:28.620, Speaker A: All right. Yeah, probably.
00:16:31.970 - 00:16:32.720, Speaker B: Okay.
00:16:34.450 - 00:16:38.080, Speaker A: Those are things that need to be double checked before.
00:16:42.450 - 00:16:42.958, Speaker B: Right?
00:16:43.044 - 00:16:49.940, Speaker A: So this is our documentation. The colors are not really like you can see here.
00:16:51.510 - 00:16:51.874, Speaker B: Right.
00:16:51.912 - 00:17:24.670, Speaker A: So we have two options you can install on your machine. We have support for homebrew. You can install the binary directly. There are many ways that you can install Jubix. And for this workshop we also have a code space. So you just click here and this will open on your browser jubix with all the environment in visual code. Yeah, I saw your comment.
00:17:24.670 - 00:17:46.042, Speaker A: So in the documentation we have installing Jubix and basically you just can copy and paste this on your terminal, execute this and you will install Jubix. Otherwise you can have Mac homebrew utility.
00:17:46.206 - 00:17:46.920, Speaker B: Right.
00:17:48.250 - 00:18:28.540, Speaker A: Okay. But I really like this code space, so let's just try this. And by the way, I included in the tutorials we have this CK submit, right? So let's try to follow this tutorial altogether. So the first thing is to install the juxt compiler. If you want to just skip this process, just clone this. This is the source of the workshop.
00:18:28.960 - 00:18:29.710, Speaker B: Right.
00:18:33.190 - 00:18:45.640, Speaker A: Okay. So when you're creating the code space, you just click here. It will take a few minutes, I think.
00:18:50.090 - 00:18:50.838, Speaker B: Well, okay.
00:18:50.924 - 00:19:42.400, Speaker A: While this loads, let me see if I can say a little bit. Right. Okay. Is there any questions so far about the language? I haven't really showed the sermon proof thing, but I'm going to do it. The main intention for me today is that you get familiarized with this language and that you can leave the room knowing that there exists a new programming language that you can use to compile to serenolis proof. It's a high level language and we are solving a lot of the problems that you face during circuit compilation. There are very few.
00:19:42.400 - 00:21:09.134, Speaker A: Okay, so it's just building. So if you have on your machine visual code, you can go directly and just put here Jubix. This is our extension and then you just need to install it. And something nice that we put here is that you don't need to really install the binary of Jubix. It will do it automatically and it will also install the binary for our in house compiler, the vampire one. So you also have that problem solved once you install that. My recommendation is to open a new folder where you're going to put your files.
00:21:09.134 - 00:21:21.014, Speaker A: Because the extension needs a workplace inside for your files. The first thing that you want to see is hello world.
00:21:21.052 - 00:21:21.302, Speaker B: Right.
00:21:21.356 - 00:21:46.714, Speaker A: You want just to see how to encode hello world. So every file defines a module and the module name is exactly the file name. So you need to use the same name. It's hello world in this case. And this is a bit of the syntax. I just want you to try this on your machines and just execute. We include these four buttons.
00:21:46.714 - 00:21:56.850, Speaker A: Actually with this one you type check the code, so you check that your terms actually correspond to the type you are annotating with.
00:21:56.920 - 00:21:57.394, Speaker B: Right.
00:21:57.512 - 00:22:15.560, Speaker A: And you have also compile because you can compile your program to different back ends by default is the native and you have also the play button so you can run this. So in this case you will just see here hello world.
00:22:16.810 - 00:22:17.560, Speaker B: Right.
00:22:21.630 - 00:23:07.430, Speaker A: For example, as I said, we have this documentation, let me try to see it. Exercises. Did we include? Yeah, so the documentation just starts with three dashes. And in visual code you just can press this button, HTML preview, it's on the top and you get a nice looking documentation. I'm going to try. So you can use this to document your programs. And this is a web version of the tiger simulator, which is the example that I show about the intents at the beginning.
00:23:07.430 - 00:23:17.450, Speaker A: What is nice is that you just can click, if you don't know anything in the code, you just need to click on the identifier and that will take you to the definition.
00:23:17.790 - 00:23:18.540, Speaker B: Right.
00:23:18.990 - 00:24:01.462, Speaker A: So for example here in the anomaintent API, a resource is this record type. So you have four fields. The first one is a logic hash, which is just an address that encodes where to find the predicate. You can have other data types, sorry, other values and. Yeah, so this is more or less how it looks. And I'm going to try to you to try this on your machine. Okay, so this is visual code.
00:24:01.462 - 00:24:17.920, Speaker A: Let's check it out. If the visual code, yeah, so this is the code space. Just let me change the color team let to something, I don't know, the light is better or the dark light.
00:24:19.170 - 00:24:19.920, Speaker B: Okay.
00:24:25.510 - 00:24:26.900, Speaker A: Perhaps this one.
00:24:30.610 - 00:24:31.360, Speaker B: Okay.
00:24:33.890 - 00:24:41.974, Speaker A: Actually let's just double check what we have in the readme. Just make this appear.
00:24:42.042 - 00:24:48.430, Speaker B: This, oh.
00:24:51.120 - 00:25:02.376, Speaker A: I had. Okay. Yeah. Okay, so we have workshop exercises.
00:25:02.488 - 00:25:03.150, Speaker B: Good.
00:25:08.400 - 00:26:08.848, Speaker A: 1 second. All right, so in the code space, and if you follow the instructions after doing the installation, you can just execute from your terminal. So here in your terminal you can have another, this is the CLI and you have different options, right. So you can type, check your code, you can compile it, eval and generate the HTML. Something that we also include is this command. Doctor checks if you have everything set up correctly, you can initiate project and there are many other things that you can do. For example, if you're interested in compiling to serenosh proof to circuits, then you will go and write compile and then put compile help, right.
00:26:08.848 - 00:26:56.432, Speaker A: And then you have our options, right. And you will be interested about the target. So we have all these targets at the moment. We have wasm, webassembly, native, we have and vampire and coron and ASM. In the code space you also have access to the vampire code, sorry, with this. So vampire is the one, it's like our low level, high level language for writing circuits. So before you write hello to, you can just use vampire and it will abstract many details that you don't need to know.
00:26:56.432 - 00:27:08.404, Speaker A: It has support for higher order functions and there are many things inside this compiler. And then you can work with plunk. Hello two.
00:27:08.522 - 00:27:09.190, Speaker B: Right.
00:27:09.560 - 00:27:59.860, Speaker A: But we want to do that in a moment. All right, so this seems like we have everything set up. All right. CK submit something as developers were used to also to interact. So you have this button over here is the one that loads the file in the repl. Also you have this option and if you click on this, this will open a terminal, it loads the module. And then you can ask things like, you can ask for example what is the definition of booleans, because I don't remember.
00:27:59.860 - 00:29:01.444, Speaker A: Then you get this nice output. And also, as I said, if you don't know anything, you just can click on an identifier, just press command. And we actually have two things. So you can, let's just close this terminal, you can with your mouse, hover the identifier and then you get this information, right. For example, it tells you that this nut type is just an inductive natural numbers definition, right. And then just pressing command or just with the mouse you can go to the definition, you can jump and see exactly what the things are. Right, the definition itself, yeah.
00:29:01.444 - 00:29:34.990, Speaker A: So with the compiler we ship also the standard library. So you don't need to care about installing standard library, you just start importing it this way. But yeah, let's go step by step. I'm just trying to show an overview of all the features that you have. If you use visual code. We also have support for emacs in case you are an emacs user. But today I'm just using visual code.
00:29:34.990 - 00:29:49.516, Speaker A: Okay. There are many things we are trying just to cheap to make a programming language with all the advantages that you will find in any other high level language.
00:29:49.628 - 00:29:50.290, Speaker B: Right.
00:29:53.080 - 00:30:52.660, Speaker A: So let me go for probably the most essential things, right, which is functions. So in python you will define a function using the keyword def. Well, in Jubix you don't need it because you are just defining so many functions. So we decide to just drop that keyword and the first part of a definition is the name of your function. You can have arguments and then put a name for that argument and always put that type of notation so that goes after the column. So in this case we're defining a function that takes us an argument, a natural number with the name n, and produce an output of type natural number. What is a natural number? You don't really need to know, but if you want to know, then you just, in your code, as I said, command click.
00:30:52.660 - 00:31:40.084, Speaker A: And then you just go and see the definition fit. Okay, all right, so if you write this, well, this is a function and it's incomplete because you haven't defined the body of the function. So you need to define what the function does, right? And for that we have this assignment symbol. So after this assignment symbol, you define what exactly your function does. And we have many language features to define this. In this case, we just want to add one, right? So try to code yourself on your machine. This function, it's just at one, and then you define m plus one.
00:31:40.084 - 00:32:35.224, Speaker A: Let's try to do it altogether. So I'm going to open a file, just going to name this add put here Jubix. The extension will suggest to insert the module name. I'm just going to click and after clicking I'm going to define the function. So if I do add one and put for example, net, this is incomplete. I just configurate a shortcut for the you can click here on the check symbol to type check your code. And then you get this error message, right? What the error message is saying is that it's expecting the definition of the function.
00:32:35.224 - 00:33:19.190, Speaker A: So we need to use the assignment symbol. Oh, and then I have the copilot so it can learn how to code Jubix already you just can put equals one and this is perhaps a name for this will be one, right? But it doesn't know what is not. So we need to import the definition. So we have a standard library, it's called standard leap. And then we have a prelude with all these definitions and it tells you well done. It type checks. This is like the reward for you.
00:33:19.190 - 00:34:05.036, Speaker A: Now let's define this function at one, and the type signature can take different forms. Look, this copilot is already too smart. You can use it. One thing about the visual code is that we have support for Unicode. So if you press the package slash, then you can have really nice things like alpha, beta, you can put really nice things. But, yeah, so what, what I'm doing here? Oh yeah.
00:34:05.158 - 00:34:05.830, Speaker B: Okay.
00:34:06.600 - 00:34:35.100, Speaker A: I'm just taking a number. Let's call it x or n. Doesn't really matter. And then just x plus one. Right, we have, or you just can do it directly. Well done. Okay, this is how you define a language.
00:34:35.100 - 00:35:01.760, Speaker A: We have flutter constructs. You can define the maximum between two numbers. The way that you do it is that just put the name for the two arguments. Put the tag signature saying that the maximum of two natural numbers is just another natural number. And you can use the if. So you have this comparison here, and then you return what is the maximum?
00:35:01.840 - 00:35:02.470, Speaker B: Right.
00:35:03.260 - 00:35:10.730, Speaker A: We can just copy this from the documentation. Click here.
00:35:12.620 - 00:35:13.128, Speaker B: Right.
00:35:13.214 - 00:35:42.644, Speaker A: So you need to import this. So we need to import data not already open. We need the relationship. Okay, this type checks. I'm going to try this right away. I'm going to use the repl and I'm going to do maximum. Between one and six is six.
00:35:42.644 - 00:35:53.300, Speaker A: Of course. Again, if you want to know what is maximum, then you have the definition.
00:35:55.740 - 00:35:56.570, Speaker B: All right.
00:35:59.420 - 00:36:45.496, Speaker A: I think something that we inherited from the ML family is the definition of function by pattern matching. This is really convenient. So a definition of a function by pattern matching is telling you. Well, it's introducing equations for the definition. For example, in this case, we want to check, I don't know if this is big enough. We want to check if a function, if a natural number is zero or not, something that you will encounter in circuits. Well, you can say the natural number can take two forms, it can be zero, and in that case you just output true value.
00:36:45.496 - 00:36:49.880, Speaker A: Or it can be the form of a successor of a natural number.
00:36:50.030 - 00:36:50.632, Speaker B: Right.
00:36:50.766 - 00:36:53.172, Speaker A: And in that case you output false.
00:36:53.316 - 00:36:53.912, Speaker B: Right.
00:36:54.046 - 00:37:19.680, Speaker A: This is the way that you split out the definition of a function. And you just can take this and type check if you want. Well, okay, here it's telling me that I don't have booleans, so I need to include booleans.
00:37:20.360 - 00:37:21.110, Speaker B: But.
00:37:23.720 - 00:37:37.000, Speaker A: Sorry, it's actually about this, we are changing the syntax to make it simpler. Right, let's terminate this.
00:37:38.890 - 00:37:39.640, Speaker B: Good.
00:37:41.450 - 00:38:44.646, Speaker A: And you also have support for recursion. So if you want to check that a function, sorry, that a natural number is even, you can formulate this function, introducing these two equations. Zero is an even number, so you just output true. And if it's a successor, you ask the same function to respond the question. But for the previous number, right? So you can have also this you can type check, we are again with the semicolon, can make this appear. This, and something really nice about programming languages, especially functional programming languages, is that you can define the parametric type of list of elements of different type. So we have support for polymorphic prenex polymorphism.
00:38:44.646 - 00:39:32.282, Speaker A: So we can define the type of list of a natural number, the type of list of strings and list of lists, so on and so forth. So you don't really need to do this. We are just declaring a lot of functions, we have libraries that already provides all these implementation details here show up the polymorphism. So you have a variable a. This is a type variable, it's an implicit one, so you don't need to provide it. It will calculate the length of the list. So the argument of the list, sorry, the argument of this function is a list.
00:39:32.282 - 00:40:01.890, Speaker A: It can take two forms. It can be the empty list, in which case the length is zero, or it can be format by, or consists of one piece of data of type a and with another list, right, that's the constructor of a list. And then you have just using recursion, the length of this list, for example, is just plus one, right? So you can use successor or plus one and then calculate the length.
00:40:04.330 - 00:40:04.694, Speaker B: Of.
00:40:04.732 - 00:40:37.690, Speaker A: The soup list in the case. And we are really excited about this language feature is we can change the syntax. There are many things that we can do. Let me just reference where exactly you can find. So we have some syntax extensions in the documentation. You can put aliases to things. So if you want to name.
00:40:40.460 - 00:40:40.776, Speaker B: I.
00:40:40.798 - 00:41:33.240, Speaker A: Don'T know, let's say that you don't want to use bool, you want to name boolean that type. You just can put syntaxes, aliases here you don't like false, you want to be very logician, so you use the unicode term, you can do these things. Where are things? We have iterators, so it's not really usual to find these extensions. Actually I haven't seen this in other programming languages. I like to Jubix, but we have this iterator syntax. We can tell. I'm going to define an iterator like a for loop that goes from starting point here and goes to other bound.
00:41:33.320 - 00:41:33.950, Speaker B: Right.
00:41:35.520 - 00:42:31.544, Speaker A: Another syntax extension that we have is fixity, so you can define different fixities. This is more like if you are defining your own operations and you want to define a binary function that is associated to the left or to the right, or that is equal to some other operator, and then you have lattice basically to resolve the syntax. So that's another facility that we are including, and we are also having this operator syntax in this case. This is very nice in my opinion. You are defining the type, the product type, which is just taking two piece of data of different types. The constructor is just the pairing.
00:42:31.672 - 00:42:32.350, Speaker B: Right?
00:42:33.760 - 00:43:46.040, Speaker A: For the constructor, it's just a function that takes something of the type a, something of the type b, and then you construct a term of the product type. Well, here you're using this time symbol. This is really nice, but you can say, okay, this time symbol is just another operator for the product, and the product is just a binary operation. And then you are free to go. You can use the time symbol everywhere and this will resolve again. If you don't know anything or you just miss something that I said, you just use the search bar, you can go for operator here, and then this will take you exactly to the place we're trying to document all the things you can do with Jubix. All right, let me see, what else do we have? Pattern matching polymorphism iterators.
00:43:46.040 - 00:44:29.748, Speaker A: Yeah, right. And then we have the exercises. Okay, so how would you define a function that takes a list and sum up all the elements in this list? Well, it's a function, let's call it sum the argument, let's call it excess. And then you have the type of, this is the list of natural numbers. And because you are summing up, you are getting a value of the type nat. This is the type of natural numbers. And then you need to define some way to do it.
00:44:29.748 - 00:45:07.120, Speaker A: So the way that you can do it is using this iterator syntax. We have this four. So you said, okay, I'm going to define a four similar to python a little bit. You have an accumulator, this is a variable where you can put values in it, and then you can iterate in the list. This is the syntax, you say x in the list excess. And then in the accumulator you can put this value, which is the element that you are current visiting plus what you had before accumulated.
00:45:08.100 - 00:45:08.850, Speaker B: Right.
00:45:10.180 - 00:45:34.760, Speaker A: This is really nice because you then can simplify a lot of the common function that you will find in functional programming languages. You would usually use fault left, right, and that. Well, it's really nice, but we already have these convenient functions.
00:45:35.500 - 00:45:36.888, Speaker C: I have one question.
00:45:37.054 - 00:45:37.432, Speaker B: Yeah.
00:45:37.486 - 00:45:49.650, Speaker C: Is this like fully statically typed with compile time, or can I have like runtime list of any objects, my determinant through some discriminated union of what it is at runtime, and then apply the code.
00:45:50.820 - 00:45:52.640, Speaker A: Yeah. It's a statically typing.
00:45:53.060 - 00:45:55.920, Speaker C: It's fully statically typed. That's compiled time.
00:45:55.990 - 00:46:28.380, Speaker A: Yeah. Yes. And something that we are trying to enforce, at least for now, is that typing is, as I said, is required. So it's like a discipline. Maybe it can be seen as a drawback, but in the long term, it's a good investment for you and for the sake of your users. Yeah. We have a type inference.
00:46:28.380 - 00:46:51.796, Speaker A: So the core language is actually anti lambda calculus with an option at typing. And we have underscore in some places you can put, for example, let me see, this works, for example here.
00:46:51.898 - 00:46:52.500, Speaker B: Right.
00:46:52.650 - 00:46:55.956, Speaker A: So you can infer what is the type of one.
00:46:56.058 - 00:46:56.710, Speaker B: Right.
00:46:57.800 - 00:47:06.148, Speaker A: This is fine. So we have an algorithm that we have type inference.
00:47:06.184 - 00:47:06.528, Speaker B: Right.
00:47:06.614 - 00:47:23.110, Speaker A: But you cannot skip the typing. And by that is what I'm trying to say, is that you cannot skip the colon type. But we have this underscore, which is the device that you can use as a placeholder. You can ask here, for example.
00:47:26.120 - 00:47:26.436, Speaker B: What.
00:47:26.458 - 00:47:44.892, Speaker A: Is the type of one? So let's do it. So you can open the repl here. And then I think it was Colon T. But let me double check. Yeah, colon type.
00:47:44.946 - 00:47:45.260, Speaker B: Okay.
00:47:45.330 - 00:48:13.940, Speaker A: So you click type and then one, and then you get not. And if you are disciplined, so you put here not. So you can interact with the Repl and try to make your program well specified. I think it's a good discipline. Also, I'm a fan of types.
00:48:14.920 - 00:48:25.050, Speaker C: In the maximum example, if I replace both of the nats, three of the nats, with an underscore, and then I can apply that to anything that supports the.
00:48:26.300 - 00:48:26.760, Speaker B: Right.
00:48:26.830 - 00:48:46.380, Speaker A: So this in particular, you can see that I'm just getting the definition and you have the two arguments. Not so in that case, I can infer that as well. Yeah, there are other places where it gets more challenging.
00:48:46.800 - 00:48:57.650, Speaker C: I'm thinking more like macros, templates by the same algorithm. And I want to apply it to different. I'm really worried about this bamper. And it just spits out 40gb of.
00:48:58.100 - 00:49:01.392, Speaker A: Type inference code, not type different states.
00:49:01.446 - 00:49:13.370, Speaker C: That could possibly be in if I want to very specific with the underlying types that I'm using, but have like two versions where one runs on 28, but into the other one's on crime field.
00:49:14.460 - 00:49:35.230, Speaker A: Yeah, there is a step going to vampire that we need to monomorphize the code. And so we will be very explicit about all the types inside the type signature. So, yeah, there is no. So much room to screw it up here.
00:49:39.460 - 00:49:40.210, Speaker B: Right.
00:49:41.620 - 00:50:34.290, Speaker A: And things that you will find and I'm really sure that this will become really mainstream in the future is mapping and filters like this functional programming paradigm of these facilities that we are shipping in juryx and you can find in Haskell or ocamel or cock and ling. This will show up in all other programming languages. You have mapping you just sent out. This is just an abbreviation for a function that just takes a list and then you evaluate the function in every single part of the list. Or you can filter out things. This is the syntax. I think it's a really nice thing for you to try.
00:50:34.290 - 00:50:51.332, Speaker A: So we have these exercises, we have ten minutes, so we can probably pick one. Let's try to do the exponentiation.
00:50:51.396 - 00:50:52.010, Speaker B: Right.
00:50:55.820 - 00:51:47.160, Speaker A: You also have maybe things, so you are not missing anything here. Everything is going to be online. So if you cannot follow the tutorial today, just sit down next day or whenever it's better for you, and just follow the tutorial. So if we try to do the exponentiation exercise and you download this, we have this file, maybe you didn't notice, but we have an statement to introduce things without definition. And we call that axioms. So if you don't know the definition of a term and you want to use it, you can put axiom that basically tells the compiler that that term doesn't have any computational content at the moment.
00:51:47.310 - 00:51:48.010, Speaker B: Right.
00:51:48.380 - 00:52:15.868, Speaker A: And if you later find out what is the definition, you just can remove the keyword action. So if you have exponentiation here, let's just try to define this. Right, so how would you define exponentiation? Let's say that the first argument is the base and the second one is the exponent.
00:52:15.964 - 00:52:16.610, Speaker B: Right?
00:52:22.120 - 00:53:05.810, Speaker A: I would like to be the secretary here. So if someone tells me. Okay, so this is exponentiation takes two arguments, x and n, and we're going to do it in the same fashion of pattern matching. So you need to pattern match on nuts. So you have x and then you have zero. What is the result? We have the copilot that just says as one.
00:53:06.900 - 00:53:07.650, Speaker B: Right.
00:53:09.000 - 00:54:05.940, Speaker A: All right, man, you can use the copilot and just write the definition for. Right, okay, the copilot screw up here. So if you have x and you are trying to have n plus one, then you just need to multiply the recursive call of x with n. Then you're free to go. It's not soaked with double c, just with one c. What is going on here? Let me all check it. We probably going to change.
00:54:05.940 - 00:54:40.830, Speaker A: Sorry. Right, well, actually, yeah, there is no need for putting this x. What is going on the column. Yeah. Semicolon. No, there is something wrong. Well, that's why you prepare the solution in case you cannot handle it.
00:54:40.830 - 00:55:10.790, Speaker A: One thing is that when you introduce names before the colon in a definition, you introduce that variable here is not necessary. Actually, we're just going to copy and paste this. But essentially you just need the x to have a name here and then the exponent, you can just put or match and get one.
00:55:13.980 - 00:55:14.730, Speaker B: Good.
00:55:19.420 - 00:56:10.488, Speaker A: But before to let you go, let me go to the main page here. We have, by the way, we have blocks and we are describing some parts of the internals, how to compile vampire through gap. This is important if you don't want to go for the direct approach of compiling to circuits. This is an evaluation interpreter approach to compiling functional programs to circuits. And the other approach that we have is Jubix to vampire directly. And in this case, we basically just take the program and remove all the features that vampire doesn't support to compile to circuits. And we have a blog post about that.
00:56:10.488 - 00:56:42.070, Speaker A: And it also takes you to all the examples, all the instructions in the main page we have this small example. So I said, you take the Juvix file, you compile to vampire. Then you can go to plunk or halo two. So you just need to specify the target your file. This is your file. For example, here we're just defining a hash function. It's the mid square hash function.
00:56:42.070 - 00:57:24.720, Speaker A: In this part we have the definition of exponentiation by fast is the fast algorithm where you basically put the exponent in binary form and then perform stat. You can say that the program is terminating. And we have also fragments for enrolling recursive functions, which is some of the challenges that we have when compiling to circuits. This is probably going to change for the moment. You need to be explicit about how many times you want to enroll your functions. Otherwise you cannot compile the circuits.
00:57:27.060 - 00:57:27.760, Speaker B: Right.
00:57:27.910 - 00:58:05.236, Speaker A: We are investigating how to remove this. We have some ideas. And the main function that you're going to compile to has one input. In this case, it's not and will produce a nat. And this is the instruction that you need to perform. So you take the vampire, you do the trusted setup with the parameters, right? And then you specify that you're going to use plunk compile using the inputs. This is the output that we are heading.
00:58:05.236 - 00:58:50.342, Speaker A: So in the code space or. Well, if you don't have the code space. No, I think I need the code space. Okay. In the code space, you just can copy and paste this on your machine and you will get also taking the inputs, you will get the results. Let me see if this already loaded. Okay, so there are many things that are missing and other things you can generate the proof with these commands and verify as well.
00:58:50.342 - 00:58:53.270, Speaker A: That's part of the vampire topic.
00:58:54.490 - 00:58:55.240, Speaker B: Okay.
00:59:03.520 - 00:59:46.772, Speaker A: Just 1 second. Everything about juicy is open source, so you can just go and see all the compilation parts. This is a really basic example of a Jubix. It's just comparing that the natural number is zero. And yeah, you can compile this to vampire if you want to know more specifics. I just can sit down with you and show you exactly what to do. If I don't know that answer, I can point you to the person that knows how to solve the thing.
00:59:46.772 - 01:00:14.990, Speaker A: But I'm very confident that I can answer any technical question with more time. I think just have 1 hour. All right. I'm very excited if you have any feedback. I'm really interested if you want to use Jubix or any of the intermediate languages. We are doing integration with Ckllbm. That's another project.
01:00:14.990 - 01:00:55.992, Speaker A: And yeah, we can basically just talk to you about the internals and probably get more integration with the CK ecosystem. So it's not limited to anoma, but it's mostly focusing on providing the next language for anoma, the apps. That's where I wanted to transmit communicate today. All right, does anybody have any questions? Yeah, you are correct. So it's like any mortal specimen.
01:00:56.056 - 01:00:56.670, Speaker B: Yeah.
01:00:57.360 - 01:01:07.980, Speaker A: So we hope Jubix don't die. Sorry, I thought it'd be simpler. The language describing intent.
01:01:10.560 - 01:01:11.820, Speaker C: Uses camel.
01:01:13.780 - 01:01:14.192, Speaker B: Right?
01:01:14.246 - 01:01:53.496, Speaker A: So that's part of our roadmap. Like in the moment you need to use this, let's call it primitive API for Tiger. But what is really important is that we are the designers of the language, the developers of the compiler, so we can change anything in the language. And of course we want to make this much easier to follow. That's why we are including these syntax extensions and many other facilities for you to basically not write code contracts.
01:01:53.528 - 01:02:03.490, Speaker C: You want to create conditions to be filled, they can't synthesize a bunch of code and then get someone to compile it. They will like really basic stuff.
01:02:04.260 - 01:02:23.690, Speaker A: Yeah, we're going to get some applications and what I foresee is that once we start doing those applications, we're going to change more the language. So so far we are just putting the ground for this technology.
01:02:26.220 - 01:02:32.600, Speaker C: The natural thing here would be time, because when you have an intent to exchange risk, there's usually a time limit.
01:02:33.340 - 01:02:34.090, Speaker A: Now.
01:02:36.220 - 01:02:58.050, Speaker C: In financial markets you have an order to do the stock market order. It's GTC, Fok tomorrow, stuff like that. If I want to buy something, I want to trade this for a dolphin. I want to do it today, but tomorrow is another day.
01:02:58.740 - 01:03:07.952, Speaker A: Yeah, but that's an issue that is not concerned to the language. It's more on the component that resolve the intents.
01:03:08.016 - 01:03:08.630, Speaker B: Right.
01:03:10.760 - 01:03:14.490, Speaker A: Which is actually quite hard problem computationally speaking.
01:03:16.860 - 01:03:19.960, Speaker C: What do you do if you want to retract?
01:03:20.700 - 01:03:24.010, Speaker A: To retract from the. I don't know.
01:03:27.260 - 01:03:28.120, Speaker C: Tomorrow?
01:03:29.200 - 01:03:48.530, Speaker A: All right. Yeah, I'm not really familiar with that scope of the application. Maybe you can answer, I don't know. Yeah. But yeah, it's probably very concerning. Any more questions?
01:03:53.150 - 01:03:59.260, Speaker C: Can you talk about the composition? How is it different?
01:04:03.550 - 01:04:54.478, Speaker A: Yeah, so that's actually a quite interesting question to solve. Just for seeing this, we include, so we have a report about what is gap. But it's essentially at the moment like a language for doing arithmetic circuits via categorical semantics, so to speak. So it's our alternative to not a direct compilation, as usually we will find with other programming languages that target circuits. So we basically observe that you can just see a language as a category and then you have functions. So at some point we want to evaluate the program that represent the circuit, and then in that sense, in that context, we want to avoid problems like the branching problem.
01:04:54.564 - 01:04:55.054, Speaker B: Right.
01:04:55.172 - 01:05:21.458, Speaker A: So it's our detour in order to solve one of the issues that you basically will face when compiling to circuits. So, yeah, gap is this. I would describe it as an arithmetic language for the moment using categorical terminology.
01:05:21.554 - 01:05:22.054, Speaker B: Right.
01:05:22.172 - 01:05:29.880, Speaker A: It's a category like finset basically. Yeah. But I can point you exactly what is the definition, which is not.
01:05:32.430 - 01:05:32.794, Speaker B: The.
01:05:32.832 - 01:05:33.850, Speaker A: Specifics.
01:05:37.330 - 01:05:43.440, Speaker C: About the piano integers, do you compile piano integers into.
01:05:45.510 - 01:05:48.450, Speaker A: Yeah, map.
01:05:50.150 - 01:05:52.770, Speaker C: Symbolic types to machine.
01:05:53.430 - 01:06:30.460, Speaker A: So from the Jubix point of view we just compile natural numbers to natural numbers to vampire. But the in house compiler, which is the one that takes the job, I'm not entirely sure what it's doing, but. Yeah, so the piano, this definition that I show about natural numbers is compiled to natural numbers. Sorry, to natural, native. Yeah, there are. It's. Yes.
01:06:30.460 - 01:07:20.700, Speaker A: Yeah. You don't exactly, you don't want to describe natural. It's just that this definition for natural numbers is convenient when you are defining functions by pattern matching. But you don't want to compile this like this way. But no, we have this annotation built in Nat, which tells the compiler that this type definition correspond to natural numbers. So we have a special compilation phase for this yeah. How big is it? The last time I tried it range up to two, power 62? Yeah.
01:07:20.700 - 01:07:46.740, Speaker A: It's not 64 bytes, it's just 60. But we are planning in our roadmap to support big integers, which is challenging as well. Yeah. Any other question? No. Okay.
