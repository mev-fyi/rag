00:00:12.440 - 00:00:42.314, Speaker A: Well, good afternoon folks, I'm wuha Wang from Yale University. I'm a first year PE student advised by Fan Zhang, and today I'm going to present our work on magnet design in Zika Europe market. And this is. Oops, what's happened? Okay, so this is joint work with Ludu Aviv, Pham Ben and Benjamin. So first, let's remind ourselves of this fact. ZK applications need poorer markets. So nowadays we have a lot of ZK applications.
00:00:42.314 - 00:01:35.796, Speaker A: For example, zero knowledge decentralized identifiers, zero knowledge virtual machines, ZK rops, and they all are facing a problem that is, zero knowledge proofs are very costly to compute. And it's typical that these ZK applications will assign the job of generating such zkps to provers. And the idea is that instead of having only one prover generating the ZKP, we can have many provers distribute the job. So these provers may have their own capacities on cost of proving, and they act as the supply side of the prover market. And these applications, and the users of these applications may also have valuations of their transactions, their programs, and the supply side demand side of the poorer market. So let's narrow down our scope for a little bit. Let's talk about poorer marketing.
00:01:35.796 - 00:02:24.066, Speaker A: Zero knowledge drops and we say here the mechanic design problem for Zika approved markets is challenging. It's a challenging matching problem because of these facts. So let's firstly focus on what's the dynamic between users and provers in ZQ rops. So users basically they post their transactions on the rope and offer their fees for the transactions, while the provers are willing to supply proves for such transactions at a cost. And also in Z co ops, for efficiency considerations, user transactions needs to be batched instead of being proved one by one. And also we have that users improve strategic so they are willing to bid optimally to optimize their revenue. So given this problem, we have a stroma mechanism.
00:02:24.066 - 00:03:01.470, Speaker A: So in this Stroma mechanism, the users basically submit their bids, which are their transactions, and the fees they are willing to pay for their transactions. Or the provers were also metabolizing the form, the proof generation capacity each prover will have, and the unit cost for generating proof. So the Stroma mechanism is fairly simple, it basically looks like this. So the mechanism greedily includes the highest fee transactions and the lowest cost provers into each round until the prover costs cannot be covered by the users. Here we omit a limitation that this implies the transactions are ordered by fees. But let's just omit that limitation so far. So let's look how this mechanism will pay the provers.
00:03:01.470 - 00:03:43.720, Speaker A: So basically, the provers get paid the second price, or more strictly, the victory payments. So say if there are two provers, the first prover, the highest, the lowest cost prover actually gets paid the second lowest cost in this straw man solution. And there may be some difference in the fees collected from the users and the fee and the rewards that's actually distributed to the provers, and we simply burn that difference into strawman mechanism. So let me give you an example. So let's see. There are three types of different transactions in the prerequisite markets. So there's one transaction at valuation of nine, five transactions at valuation of five, and ten transactions at valuation of one.
00:03:43.720 - 00:04:21.044, Speaker A: We also have two types of provers. Well, the first prover is willing to prove ten transactions at cost one, while the second prover is willing to prove ten transactions at a cost of five. So if everyone is honest, if everyone is very merry, so here's what's going to happen. What's included in this run is actually one transaction at valuation nine, five transaction at valuation five, and one transaction at valuation one. So this is the maximum number of transactions that can be included in dispatch. Well, the prover gets selected is the first prover. Because of this, it's the lowest cost prover, and it's paid the second price.
00:04:21.044 - 00:05:21.046, Speaker A: So it's actually paid five, which is number, which is the cost unit cost paid to the prover, and seven is the number of transactions. However, this example has a collusion problem, which can be demonstrated here. So, actually, the second prover and one transaction at the cost of five can clue with each other. So the second prover can bid four instead of its true cost, five, and the user, the malicious user, can bid two instead of five as well. So in this case, what we're going to happen is that the joint utility of this colluding user and colluding proverb will increase by three because this user transaction will now still be including dispatch, but it pays less. Okay, so I want to show you this strongman mechanism because we previously think it may satisfy these desired properties. Informally speaking, these properties are respectively efficiency, incentive compatibility, and option grip proofness.
00:05:21.046 - 00:06:14.840, Speaker A: Let me explain. Efficiency in the sense that the pure market should be able to prove as many transactions as possible and set it compatibility in the sense that the mechanism should encourage each actors to bid honestly, and option agreement proven it in the sense that no collusions between users and between provers can increase their joint utility. So they cannot act maliciously by forming a collusion. So however, there are problems with this strongman mechanism, and we ask the question, how can we design a mechanism to satisfy these properties? So the first problem with the previous strawman mechanism is that the payment to each prover is dependent on other proverbs base in the stromat solution. So let's recall, so in the trauma mechanism, we actually pay the winning prover, the second price, the victory payment. So it's not separable payment rule. So this may cause some problems.
00:06:14.840 - 00:06:59.430, Speaker A: For example, if the not winning prover can change their bid for a little bit, then it can change the allocation who is winning and who pays what amount of money for the entire round execution, which is not what we want. And this may cause some collusion problems. So the idea to solve this problem is that we use a separable payment rule for provers. The second problem for the strawman mechanism is that there are some fee burns. So let's recall, so it's actually separated how we collect fee from the users and how we distribute the reward to the provers. And this strongman mechanism actually burns if there is difference between them. So this is not optimizing the social welfare.
00:06:59.430 - 00:08:09.252, Speaker A: And since the social welfare is not optimized, some collusions are formed by users, and provers may be strategically to extract this burnt fee, which we don't want either. So the idea for this to solve this problem is that it optimizes social welfare by ruining burning for all, within all mechanisms. And the third problem with the strongman solution is that the prover can include non winning users to win additional profits through option agreements. So I'm not going to get into detail, for example, for this problem, but the idea we solve this problem is that we can cap the number of transactions that can be included in each round of mechanism execution by adding a capacity parameter. So based on these three observations, we present our mechanism proof e. So let's see how it works. So basically, on a high level, proof v assumes that we have a fixed capacity parameter c in the number of constraints for each round of the mechanism execution, and it will select transactions with the highest value up to that capacity limit.
00:08:09.252 - 00:09:27.240, Speaker A: It's like Ethereum before the EIP 115 59 upgrade, and after we select the user transactions, how do we pay the provers and select approvers? So basically this mechanism simply calculates the average fee of the selected transactions, and our provers is cost less than the average fee, may be willing, may be profitable to prove this transaction. So they join a lottery pool and this mechanism then randomly select provers in a pool until all transactions can be proved by some prover. So about this proofing mechanism, we actually can show that it can have some good properties that we desire. Firstly, we can show that proofing is incentive compatible for the users, and secondly, we also can show that proofy is incentive compatible for provers if we assume that no civil attacks can happen. So in the sense that, recall that improving mechanism, all provers may join a lottery pool. But the Sibyl attack problem is that some prover may create a lot of copies of itself and therefore increase its chance of winning. But however, if we assume that no civil attacks will happen, we can show that it's also incentive compatible for provers.
00:09:27.240 - 00:10:05.554, Speaker A: And we'll discuss our potential ideas to for store CBO tax in later slides. And it also has some other nice properties. And most importantly, it is option agreement proof in the sense that no correlations between some user and some prover can increase their joint utility. So this is a property we want to achieve in a stronger mechanism, which we couldn't, but it can be achieved and proved. Now still, this proofing mechanism has some limitations I want to show you here. So firstly, it's not collusion resistant for provers. So let's give you an example.
00:10:05.554 - 00:10:59.832, Speaker A: So let's think, in the worst case, all provers in the prover market can collude with each other, and they will be strategically to extract the most amount of revenue from the users, which we don't want to see. So our mechanism is not resistance to this type of attack. And we also show examples, we also have show examples that it's not gluten resistant if some parts of the provers glue with each other. And regarding efficiency, we observe that the efficiency of this proofing mechanism is highly dependent on how we set this capacity parameter c. And the efficiency is suboptimal if the capacity parameter is set too low. So we may need to find a way to adjust the capacity parameters to accommodate the market conditions in the zero nodule approval markets. Okay, so let's look at the discussions.
00:10:59.832 - 00:11:28.344, Speaker A: Open questions. So we have four points here. Firstly is how do we prevent the civil attack which may exist in the proofing mechanism. So we have two different ideas. One is from system level design, we can have registration for provers, so the prover must register themselves before joining the prover markets. So this can in part mitigate this simple type problem. And in a magnet design level we can have some proof of stake when we do the lottery draw.
00:11:28.344 - 00:12:30.324, Speaker A: So each prover in this sense will be drawn with probability proportional to how much stake it has in this network. The second deciding point I want to address is how do we adjust the capacity parameter. Well, we observe that the optimal capacity parameter is actually the sum of preferred capacity in the lottery pool, but we still need to find a way to adjust it. So we leave it as an open question to you. And the third discussion is how do we mitigate collusions among provers? So as I said, the full collusion among provers is always a problem for any kinds of mechanism because it can always bid strategically with each other to extract maximum value from the users. One way we think to mitigate this is actually we can set a default prover either run by some third party or run by the Zika app itself. It has reasonable price, reasonable capacity, which means that the user can some parts of the user transactions can always get food with reasonable price.
00:12:30.324 - 00:13:34.054, Speaker A: The first point is how is getting full incentive compatibility. So let's recall our goal of designing a mechanism for secure approval markets. The final goal is actually to have a mechanism which is incentive compatible for both users and provers, OCA proof and collusion resistant for provers. So how to design such mechanism is an open problem now. And the takeaway of today's talk is that proofe is a transaction fee mechanism for Zikara approver market that aims to encourage low cost provers and first dollar attacks. And our paper marketing design in Zikr pure markets, which has the same title, is online and you can scan this QR code to get access to it. And what you will find in this paper is our models of floor market in ZQ drops our model of threats and the desired properties of a profit market mechanism and we state in more details the proofread mechanism and analyze the properties and also discuss in more details open questions and directions to explore in the future.
00:13:34.054 - 00:13:39.944, Speaker A: So if you have any ideas of how to address open problems, we're happy to chat after this talk. Thank you.
00:13:45.724 - 00:14:07.994, Speaker B: Thank you Wenhao, do we have any questions? Oh, over there. Just wait 1 second for the mic please. We got to get that audio on video there in the middle.
00:14:11.414 - 00:14:14.434, Speaker C: What would happen if there were a number of zero bits?
00:14:14.854 - 00:14:19.974, Speaker A: Number of zero bits assuming the prover wants to prove some transactions at zero cost.
00:14:20.134 - 00:14:20.874, Speaker C: Yes.
00:14:21.374 - 00:14:38.504, Speaker A: Well actually what we show is that the prover in this mechanism will actually choose to bid their costs. Choose to bid their costs truthfully. So in reality, in my point of view, I wouldn't think there would be provers actually has zero costs, right?
00:14:39.644 - 00:14:44.164, Speaker C: No, but for example, in Mena it's currently happening where they're doing proofs for free.
00:14:44.284 - 00:14:57.974, Speaker A: Then maybe Zeek will get selected as some round of the execution of the mechanism. And if the fee is very low, which is below their actual cost, then they won't earn negative revenue in such rounds.
00:14:59.274 - 00:15:05.414, Speaker C: So did I understand correctly that the price that ends up getting paid to the prover is not the same as what they bid?
00:15:07.154 - 00:15:26.034, Speaker A: Right? The mechanism will actually select the provers. So what we have in proof e is actually the Mexican will select the provers who is profitable to prove the batchel transactions. So if they bait dishonestly, for example, they bait maliciously low cost. They may lose in such ways.
00:15:29.894 - 00:15:37.294, Speaker B: We have to go to the next talk. If you have more questions for Wenhau, please feel free to hook up with them afterwards. Thank you very much Wenau thank you.
