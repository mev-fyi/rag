00:00:06.810 - 00:01:00.830, Speaker A: So I am going to talk about permissionless interchange scaling with IBC, which is not yet in zero knowledge, although it might make use of zero knowledge in the future, or allow existing non zero knowledge blockchains to use zero knowledge features of blockchains which have it. So first, interblockchain has become a bit of a buzzword, so I'll try to specify what we're trying to design here. IBC is a protocol designed to be implemented as part of the state machine of a blockchain. It could be implemented on blockchains which support smart contracts like Ethereum and a smart contract. It could be implemented by custom state machines like some of what we're building with the cosmos hub as a module in the state machine, or a subcomponent of the state machine. It could be implemented by lots of different future chains. Maybe parachains could implement IBC, we hope, if I manage to convince the people sitting in the front row.
00:01:00.830 - 00:01:58.050, Speaker A: IBC is designed to be used by heterogeneous chains, so it doesn't require a common virtual machine. We want it to be the case that different chains which specialize in different things, maybe some of those things being zero knowledge proofs, can implement as part of their state machine IBC. We want IBC to enable users of a set of chains to choose which chains they trust and how much they trust them. We want it to be permissionless so that different blockchains can open and close connections, relay data packets, tokens, assets and code in between each other without anyone other than the users involved needing to approve it. So no governance required. We want it to be in the same vein. Automatable smart contracts should be able to use the interchain system, and we want it to be efficient, at least in the amortized case, such that most of the traffic and transaction throughput should be used by the actual data and the actual state transitions, not the consensus proofs.
00:01:58.050 - 00:02:58.710, Speaker A: So the basics of how we do this are that we require an efficiently verifiable consensus transcript, which is commonly known in blockchain powerlands as a light client. So in one in, say, two chains with an IBC connection between them, usually we specify IBC as a protocol in between two chains. Each chain will run a like client of the other. It will start out with a root of trust, and it will relay header updates, or some off chain process will relay header updates from one chain to the other so that each chain tracks each other's like client and then can verify, say, any state on the other chain with a Merkel path proof. In order for this to be efficient, these headers. So these fragments of the consensus transcript need to be cheap to verify, and the chains themselves need to have fast finality if you want cross chain transactions to proceed quickly. You also need a few particulars to be true of the incentive design.
00:02:58.710 - 00:04:02.060, Speaker A: So specifically, you need quite strong like client guarantees. You want it to be the case that since IBC is only running like clients, you want it to be the case that if a like client can be convinced of a committed state that wasn't actually committed, someone gets slashed. Because hopefully that will disincentivize validators from lying about the state. So you want stronger guarantees, say, than you might have in a bitcoin like client. So on top of verification, IBC provides sequencing between two chains. If you want to enforce invariance about the combined state of some set of chains, maybe that the balance of a token are conserved, you need to be able to reason about which events occurred in what order on shards of state on different chains. So in order to do this, IBC provides as a protocol TCP, like exactly once message delivery, each chain implements queues and counters on the messages, which prevent replay and only allow them to be committed assuming the protocol is implemented correctly in a particular order.
00:04:02.060 - 00:04:53.574, Speaker A: So in order to do this, we need Merkel proofs from one chain to the other, which are then verified against the say, root hash and the header. And those Merkel proofs include the sequence numbers of packets, so each chain can verify that the other chain sent the packets in the order in which it is receiving them and processing them. On top of this, we can build a whole host of different applications. The simplest one is token transfers, where on one chain maybe the source chain for the token, you have bitcoin. And then if you want to send bitcoin using IBC to another chain, you escrow it on the source chain. In the IBC handler, you send a packet to the destination chain, proving that this bitcoin has been escrowed on the destination chain. You can mint, call it a bitcoin voucher, virtual bitcoin.
00:04:53.574 - 00:05:50.950, Speaker A: Send that bitcoin around on the destination chain, maybe turn it into a user issued token on the zcash applink circuit, send it in zero knowledge, play around with it, even send it to another chain. When you're done, you can burn the voucher and prove that you've burned the voucher to the original source chain, release the bitcoin from escrow, and now you have your bitcoin back. So in that sense, it's not like an atomic swap. IBC enables token transfers across chains. IBC can also enable a whole host of different applications, multi chain smart contracts where you have different parts of a sort of complex multi chain state machine executing on different chains, and you pass some part of the smart contract state closure as variables to the next chain in the sequence. You can have delegated security, which we're building out for the cosmos hub where the validator set of one chain. So this is particularly useful for proof of stake.
00:05:50.950 - 00:07:10.742, Speaker A: The validator set of one chain agrees to be slashable for equivocations faults committed on a second chain, which are, if they are committed, submitted over IBC. So that way, say someone who wants to start up a blockchain but wants to rent out an existing validator set in return for some to be determined compensation can convince that validator set to accept slashing risk and so gain the economic security of the original sort of root chain. IBC can also instantiate lots of different sharding protocols, depending on which sorts of ordering guarantees you want, although we think it will be most useful in the case of heterogeneous chains, where different chains can specialize in different application level provisions, but users can use the same assets and can craft complex, interdependent state machines across several chains. So what is the state of affairs? We are trying to write IBC as an open protocol. I want to emphasize that it's not although it's being primarily developed by tendermint Cosmos, it is not dependent on the use of necessarily our blockchain or our token. All the specifications are in the open@GitHub.com. Slash Cosmos ICs and we have a sort of ecosystem working group forming with biliweekly Zoom calls which are recorded and you're welcome to join in person if you like.
00:07:10.742 - 00:07:29.020, Speaker A: Let me know. You can find us on Twitter at cosmos or email me at cwgos@tendermint.com. We expect MVP implementation along with an MVP final specification sometime in summer 2019. Don't want to be too specific. Thanks. Questions?
00:07:37.570 - 00:07:53.022, Speaker B: Hey, thanks for the presentation. So I'm still slightly confused. If you send bitcoin in an escrow and then prove it onto one of the cosmos chains, how do you use the information of the burned token to release the bitcoin inside the bitcoin network.
00:07:53.086 - 00:08:41.422, Speaker A: Itself, how do you use the information of the burnt so on the cosmos chain, you mint a bitcoin voucher, right? And that bitcoin voucher is stored in some key in state which the source chain knows about. The bitcoin chain knows about that key in state and can read the amount of that voucher. So then when that voucher is burned, you can send a packet back to the source chain, which proves that the amount decreased and the source chain will. And the packet also contains data about which address the original bitcoin should be released to. Then the source chain can accept that bitcoin. To be clear, the bitcoin chain would need to change its state machine. To do this, we have another more complex solution to work with the existing bitcoin chain using like a multiparty ECDSA peg.
00:08:41.422 - 00:08:48.310, Speaker A: But two custom chains can need to understand part of each other's state machine, and then they can do this safely.
00:08:58.890 - 00:09:00.666, Speaker C: Could you say something a bit more.
00:09:00.688 - 00:09:07.626, Speaker D: About the scalability of the protocol? Because I can see that when it's like one to one communication between two.
00:09:07.648 - 00:09:09.962, Speaker C: Blockchains, I see it working.
00:09:10.016 - 00:09:21.434, Speaker D: But in the future, if there is many communication or many side chains or blockchains, communication to one, to each other, this means like a lot of medical.
00:09:21.482 - 00:09:24.320, Speaker C: Proofs will need to be proof and so on.
00:09:24.690 - 00:09:28.480, Speaker D: So, yeah. Do you have a solution for that?
00:09:29.570 - 00:10:09.434, Speaker A: That's a good question. I mean, IBC is designed to, it's not specific to a particular network topology, and we expect the network topologies that emerge to be reflective of the economic properties of the commerce that the chains are trying to provide. So, for example, if there were a bunch of payment chains around the world, most commerce is local. Most payments in Shanghai are to other vendors in Shanghai. Most payments in Oregon are to other vendors in Oregon. Occasionally, those two chains need to know Shanghai Oregon transaction, but that's much rarer. So we would expect the payment chains to be local or maybe to be only one hop away via IBC in most cases.
00:10:09.434 - 00:10:12.750, Speaker A: And in the exceptional cases, yes, the payments are slightly more expensive.
00:10:14.690 - 00:10:16.700, Speaker B: All right, let's thank Christopher again.
