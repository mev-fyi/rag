00:00:08.010 - 00:00:27.014, Speaker A: Okay, what's a roll up? Roll up is very simple thing. So at the end is we are maintaining a state. Mainly. The state is a database of balances of people. We have balance. These people has this amount, these people has this amount. Okay? And this database of balances, it's a current state, is a snapshot of a moment.
00:00:27.014 - 00:00:58.446, Speaker A: We store that and the idea is we merklize all that. We put that in the Merkel tree. So we get like a hash of all together. We have a root. And then what we do, what we're doing is we are forging batch, we are changing this estate. So this batch is a set of transactions that actually what it does is modify these estates very much like a normal blockchain warex. But the here things is that the blocks, or what we call it, the batch, just to distinguish between the blocks in layer one and the batches in L2, just to distinguish this.
00:00:58.446 - 00:01:39.782, Speaker A: But we are creating these batches just as a normal ethereum transaction. When we want to create a transaction, mainly what we do is we put a new state. This is a new estate that actually mines, actually forges a set of transactions. So this evolution from a state a to estate b with all these transactions, and we publish this newest state in the theorem. In a normal transaction, we call it this forging a batch. And the properties of ZK roll up is mainly that. Besides the newest state, we also give a proof that this state is valid.
00:01:39.782 - 00:02:08.674, Speaker A: It's correct. Okay, so it's a proof of validity. Proof. We call it the NSA snark. It's a proof that's verified in the same smart contract, and it guarantees that this new estate is correct. So that means that all the transactions that are included in these bytes are signed, that there is no double spending, that there is enough funds to send from one to the other, so that the state is current, if the state makes sense. Okay, so that's mainly what we are doing.
00:02:08.674 - 00:02:42.160, Speaker A: In what we are doing. In our roll up, there is an important property that all the roll apps needs to fulfill. And is that what they call it? The data availability. If somebody imagine an operator that puts a new estate, but this estate, it's calculated from some hidden transactions from the operator, then the roll up would stop. Nobody would knew exactly what this new estate. So in some way, we need a way to reproduce this state. And this is the data availability problem.
00:02:42.160 - 00:03:16.060, Speaker A: In some way in this smart contract, we need to prove that this data is available. In the case of the or ZK roll up, mainly what we do is just put all this data in the same transaction, in the same blockchain, but we put it in a very compressed way. We'll see this data structure. So in this way what we can do mainly is we can compress. This is a roll up effect. We can compress a lot of transactions in a single transactions. There are other options, validiums, maybe they put it off chain or in a federated systems and so on.
00:03:16.060 - 00:03:52.440, Speaker A: There is an optimistic roll ups that they don't include this decay proof, proving that and they are more based on gaming. Somebody can challenge that this proof is not valid and then they need to wait a little bit more in order to finalize. But VK roll ups mainly what it works that way. Okay, well let's start going deep. And what's the state, what we have in this estate? Well, this estate is mainly, as I told you, it's a mercury tree in this case. In our case it's a sparse mercury tree. We could use a normal mercury, but we choose a sparse mercury tree because have some good properties for this.
00:03:52.440 - 00:04:18.480, Speaker A: But here, what's in each leaf? What we have in each leaf? Well, mainly what we have in each leaf is just a token. It's a token id. It's an idea of which token are. Token zero is going to be Ethereum token one. We don't know. People can register tokens in the main net and every token will be assigned an id. So we have a token id.
00:04:18.480 - 00:04:45.730, Speaker A: We have a nons of this account. We have a baby jab jab public key here with the sign and the public key you see here the third and the last one. This is a public key. We have an Ethereum address of this account. So we have this address. That means that can be handled by an Ethereum address or by baby Jap, depending if we are in layer one or L2. And of course we have the balance.
00:04:45.730 - 00:05:06.846, Speaker A: Okay, this account holds this balance. So this is mainly what we have. And in each leaf we have one state. And this is a structure we are generating here. So mainly what we do is we get this structure, we hash them. We are using poseidon in all the roll ups. So this is the main hash function.
00:05:06.846 - 00:05:45.014, Speaker A: We are putting the hash function and then all this, we merge the lights altogether. So this is what the internal structure, this very simple structure, what we have. Okay, well, just a brief introduction of what sparse mercury tree. A sparse merco tree is a tree that if you want as many levels as you want. We are limited here for the circuit just to 32 levels. But here sports market tree theoretically can grow as much as you want and many. It has two kind of locks.
00:05:45.014 - 00:06:11.586, Speaker A: This would be like a normal tree. What you have here is just the hash of the left, of the right. And you go down to the tree until there is a point where there is only one key value. There is only one place. In this case, what we do is we hash different. We put a different hash and then we just put the Kia value directly here. So we can have a structure that can grow.
00:06:11.586 - 00:06:45.070, Speaker A: But just for the presentation, you can imagine that's just a normal circuitry and it works the same way. Okay, the other important structure, the other important data structure of the roll up is the transaction. What are L2 transactions? Looks like. Well, here is, you see here a lot of information, but let's go just one by one. So we have a signature constant. So, because we are assigning something that we cannot reuse these signatures here. This probably a hash of.
00:06:45.070 - 00:07:04.174, Speaker A: This is a roll up transaction. And I have to move whatever. So this is a constant on it. There is a chain id because ethereum can hard fork. So here the transactions we already. Well, we are just putting the chain id here, the from index. So who is sending.
00:07:04.174 - 00:07:26.118, Speaker A: Who is from the leaf that's sending the funds that to index. And the amount here, you see that the amount is 16 bits. We will see here. We'll put the token. This would not be necessary because we already have in the index. The from index. We already know that on there.
00:07:26.118 - 00:07:49.534, Speaker A: But we decided to put here just for security reasons, just for be sure that the user is signing to send this specific token and there is no completion there. Announce a user fee. You see here a user fee of eight bits. And. Yeah, that's mainly it. Okay, I will go the other here. Well, here is the destination.
00:07:49.534 - 00:08:10.694, Speaker A: Can be a two index, but can also be an ethereum address. Or can also be a baby jab, jab. And it can be a combination of this. It must be, must fulfill this and this. So we have these three things. Okay, and at the end, if you see at the end, at the end, you see the signature. Okay, so the signature is baby jab.
00:08:10.694 - 00:08:40.260, Speaker A: It's an EdDSA signature with poseidon as the hash function. So we hash all these, all these parameters together and we put it all together here. Let me go little. Yeah. Here is the flot 16 that we are using here. You see it's five mantisa of ten bits. Exponent of five bits and then one half bit.
00:08:40.260 - 00:09:05.740, Speaker A: You can see the formula here. But this allows to put any number with precision of three and a half numbers, three numbers. And the last number can be a zero and a five. This is the half bit here. So this is very natural way of talking about the money. If you see here, for example. So we cannot put any amount there, but we can set a lot of the normal amounts that a normal person would use on that.
00:09:05.740 - 00:09:27.470, Speaker A: The other thing is the fee. The fee is just eight bits. And here, mainly it's a table. It's a lookup table of eight bits. And we go from zero, zero from zero. And the next one is zero, zero, 1%. We go logarithmically.
00:09:27.470 - 00:10:07.226, Speaker A: We have a lot of density in what would be a normal field. Something between zero, zero, one and maybe 5%. So everything is in here. It's more compressed and then we can go just 1000%, 10,000% and we can go high. So we have all the spectrum of all the possibles with more density in what we understand that's the more normal ways. As a small percentage of normal value for what you are sending. I want to tell that here in Hermes, the fee is paid with the same token that you are transferring.
00:10:07.226 - 00:10:30.562, Speaker A: So if you are transferring Hermes tokens, for example, you will pay it with Hermes tokens. If you are transferring dives, you will pay it with dives. So every transaction goes to the. We will talk a little bit later about the fee, about the fees. Okay. And then here in the transaction, you see all these fields that start with airview. This is for the atomic transactions.
00:10:30.562 - 00:11:00.602, Speaker A: Most of them are going to be zero here. But we will explain later on about the atomic when we talk about the atomic transactions. But mainly this is the conditions that the other transactions need to fulfill. That's why more or less all the fields are repeated here. Okay, so we have already what l two transactions looks like and what the circuit does. Well, the circuit mainly what it does. We start with a node with a root.
00:11:00.602 - 00:11:12.626, Speaker A: Okay. We process a transaction, we get a new route. We process another transaction, we get a new route. And we process 2000 transactions. And then we have the last route. Okay, so this is mainly what we are doing. Yes, there is a question or something.
00:11:12.808 - 00:11:28.360, Speaker B: Yeah, there's two questions, jordy. Yeah. So the first is, how is Hermes network using Dran based random numbers? How is it better than the starkware VDF and Chainlink VRF? That's first question. And then there's a second. I'll let you answer the first one.
00:11:30.810 - 00:11:38.386, Speaker A: The for random numbers, you mean for the random bitcoin of the trusted setup.
00:11:38.578 - 00:11:40.280, Speaker B: You can check out if you read.
00:11:56.450 - 00:12:20.780, Speaker A: We are using Devran, we are not using starware because in the startware you don't have the code for generating the proof open source. So we decided to go to Dran and it's just for the random beacon and it should be safe enough. We'll do exactly the same with the phase two. We have the verification there and that's what we have.
00:12:21.150 - 00:12:23.260, Speaker B: And then igor has a question too.
00:12:24.350 - 00:12:48.100, Speaker A: Whole data availability proofs are working at Hermes for plung based roll ups. KCAC 256 could be used to pass all data in the roll up hold. Solve this problem with gross 16 based roll up. Yeah, we'll explain. We'll go on that later. I will answer you. I will answer Igor on that.
00:12:48.100 - 00:13:04.342, Speaker A: If I don't answer during the presentation, ask me again. Okay, but you will see. Well, let me just move. Well, here, what we do here is. Well, I started to do this. So we have these transactions. So mainly what we do is we need to process.
00:13:04.342 - 00:13:36.530, Speaker A: We need to verify that from going from an old route to a new route. It's fine by these transactions. Well, one of the things that we need to do is also what we do is we get all this data availability. Here you see that this data availability is very short. It's a from index, the two index, which is 32 bits, 32 bits plus the mode, which is 16 bits. And use fees. So we get all this data availability of all the fees and we hash them all together.
00:13:36.530 - 00:14:08.620, Speaker A: So in the circuit there is only one input. Actually, we'll see that in the circuit there is not only the hash of this, but the hash of all the other inputs, all the other parameters. So at the end, the circuit has a single public input, which is very cheap. And what we do is we do an SHA 256 of the data availability, plus a lot of things. So I have another presentation for that. So we'll see later. Okay, so let's see a little bit more.
00:14:08.620 - 00:14:37.746, Speaker A: Let's zoom in a little bit how the roll up circuits are organized. Well, we have the main roll up here. I will share the presentation. So here, there is a link here. So here's a main roll up, which is the main circuit done in circum. But maybe you can go push here. So I don't know if you can see it.
00:14:37.746 - 00:14:54.778, Speaker A: So this is the main roll up. Okay, so here is all the inputs. And here you see the parameters. Here is the number of transactions. In this case, it's going to be 2000. Number of levels is going to be 32. Then the Max L1 transactions and maxi, that we will see, we will see later.
00:14:54.778 - 00:15:23.170, Speaker A: Okay, this main roll up, mainly it's a placeholder for, well, we have the transaction. The transaction, we divide the transactions in two parts. Actually it's a decode transaction. And then we have what's specifically the roll up transaction. The transaction that we process. Okay, I will explain later on why we do that. Okay, here, of course, with all these transactions, we hash them all together.
00:15:23.170 - 00:16:01.966, Speaker A: So we have here a huge hash sha, 250 seats. That's hash inputs, that takes all the inputs, the data availability, and many other things that we will see later. Okay. And then at the end, it's important to see a fee transaction. Mainly what we do for the transactions is in each transaction we sum up, we accumulate the transactions, and at the end we get all the transactions of the different tokens we have up to in a block, can be up to 64 different tokens. And then at the end we just modify the state. So we change the root, we modify the state.
00:16:01.966 - 00:16:46.666, Speaker A: We add these fees to some operator defined by the coordinator, so some account that it's owned by the coordinator. And this is added at the end of the roll up. Okay, so if go a little bit more on that later. If we go in here, if we zoom in again in a single transaction, what there is in the transaction, what we see in the transaction. Well, mainly what we see in the transaction are these two pieces, the processor one and processor two. Actually, these two pieces, what it does, it modifies the state. So it goes to a leaf and it updates this leaf maybe, or it updates or inserts those leaf.
00:16:46.666 - 00:17:13.154, Speaker A: We are processing. And why we have two? Well, because in the normal transactions we need to update two leaves the from. We probably need to subtract some value from the from and the two. So we need to add into the two. So that's why we need two times. And this is, we are having these two processors that are the biggest part when we are talking about constraints. Okay, what we do in the middle, well, we have this state hash.
00:17:13.154 - 00:17:42.410, Speaker A: So this is the state that we saw before. Mainly it's a poseidon hash that gets a state and put it as the input of the processor. And we have here a balance updater. The balance updater. Mainly what it does, it takes, well, it do all the math, it do all the calculus. It subtracts from one side, it adds from one side. Also when we do the deposit, also the deposits, it calculates the fees.
00:17:42.410 - 00:18:01.154, Speaker A: It sends the fees. So it do, what would we do? What we can say the math of the transaction and this is in this circuit. Okay. We have a fee accumulator that we will see later on. And two important things. We have a signature verifier for a L2. We need to verify that the signature is valid.
00:18:01.154 - 00:18:23.930, Speaker A: So if the signature is not valid, then the proof will not be valid. So in order to process this transaction, we need to have a valid signature. That's important. And of course we have the request for the atomic transactions, the verification of the other one. We'll see a little bit more on that. Okay. With this we have very much a transactions.
00:18:23.930 - 00:19:01.254, Speaker A: So a roll up that works very good if we are only in L2. But what happened? How do I deposit to the layer one? How do I deposit to the L2 from the layer one? And how do I exit? So, well, let's start with the deposits. Okay, for the deposits, for deposits or what we have here is a special kind of transactions that we call l one transactions. So an l one transaction is a transaction that somebody do in the smart contract. You do maybe a deposit in a smart contract. And then the operator needs to process these l one transactions. We have different kind of transactions.
00:19:01.254 - 00:20:18.782, Speaker A: This can be a deposit, can be a transfer. But let's think about the deposit, which is the typical l one transactions. Well, what we do here is, well, what we have is a queue of qe, okay? So when somebody puts a transaction, we put it here in qe one, okay? When somebody else put another deposit, it put it in the second slot of the qe one, okay? And this queue is limited to 128 slots. If there is 129, then it will going to be put in the next one of the qe two and so on. So people is adding transactions on that, okay? And from the smart contract, what we do is we force the operators to forge all these l one transactions every five minutes. When an operator forges these l one transactions, then it can forge as many other batches for during five minutes. But after five minutes, the next operator, the ones that after five minutes will be forced to forge the next kiwi.
00:20:18.782 - 00:20:59.546, Speaker A: So we are in some way, we are processing all the kiwis. Every five minutes we process one kiwi and we force that buying smart contract. So this way there is no way that the deposit is going to stay in the middle, in the limbo of the smart contract. We know that everything is going to be deposit. Okay, here we have the data structure. So mainly what we are doing here, we are constructing that in the same transactions, in the little one transactions we were putting here, what we have in these transactions we have the from ether account. So when you are depositing is the from of who's sending this deposit? The baby jab jab.
00:20:59.546 - 00:21:29.500, Speaker A: Anybody can choose which baby jab jab. In this case compressed, it's 156 bits from index. You can do a deposit on top if it's for index. But if from index is zero, then that means that you are creating an account actually. Okay, how much this is set it up by the smart contract. Of course, if you are depositing dice, of course the smart contract needs to check in some way that you sended the dice to the roll up smart contract. Okay.
00:21:29.500 - 00:22:13.254, Speaker A: The token id and the token id. And also in this transaction, in the same l one transaction we can do a transfer. So I can do a deposit on top of something and maybe sending this to somebody else exactly in the same transaction. Why? It's possible that because for deposit we're using just the first processor of the transactions and then we can use the other one just for the destination. So in the first processor we are adding the lot amount. We are subtracting the amount and in the other one we are adding the amount. This is very useful because this allows, for example, to do a single payment in the layer one transaction, but the second one received automatically in the L2.
00:22:13.254 - 00:22:54.254, Speaker A: And you are doing, with the same Transaction, you are doing one single deposit. Okay, this is interesting because with this we can do, layer one can do a transfer for sure. I can do a force transfer or I can do a force exit. We will see it later. At the end, what we are doing is this, okay, a cool thing of these l one transactions, this would be like what we call it a user transaction, say transaction that the user do in layer one. But there is another kind of layer one. It's an operator in the same transaction that's forcing the batch.
00:22:54.254 - 00:23:28.030, Speaker A: Just before forcing the batch they can add l one transactions there. Okay. And these l one transactions mainly is for creating accounts. So an operator can create an account there. Okay. So this is very interesting because this allows, for example, to send from layer one, send ether or any token to a user that have no account yet. So have no leaf in the roll up.
00:23:28.030 - 00:24:08.038, Speaker A: It doesn't exist in the roll up, but it exists in the account. Maybe have an ethereum address or has a baby jab jap address already. So I'm able to send that. So I will generate this transaction, I will send to the coordinator, and the coordinator what we'll do is, well, in the same transaction of forcing the batch, it will create the account. And after creating the count will process the transaction. Of course, the transaction probably will have to have a little bit more of gas because the operator needs to pay for these other layer one transactions. But this can be very transparent for the user.
00:24:08.038 - 00:24:46.150, Speaker A: Okay, and what we include in this layer one coordinator transaction, well, we include a signature here. A signature mainly is a signature that's generated by the receiver, especially just in some ways to link the Ethereum address and the baby jabjab address. It's kind of. I authorize this baby jabjack for Hermes roll up creation. You are signing. So you are proving in some way that you have this Ethereum account. So this ethereum account and this babyjabjab address, it's linked together.
00:24:46.150 - 00:25:14.000, Speaker A: So this is created here. Of course, we put the baby jabjab, the token for this and the ethereum address. So that's mainly what it does. It creates this account. But with this property at the end in the roll up, in Hermes roll up, we are warranting that the owner of the baby jap and the owner of the ethereum address in a lift is null or it's the same, it's controlled. So that's why we are signing with one key to the other. Okay.
00:25:14.000 - 00:25:50.720, Speaker A: Free processor. We explained it a little bit before, but here we go a little bit more in detail. It's accumulator step. So see here what we do here. Well, let me just start here. So mainly what we are doing here, we are accumulating. In this case, we have 64 accumulators.
00:25:50.720 - 00:26:20.590, Speaker A: And each transaction generates a fee to charge. And it's added to one of those accumulators. This goes accumulating. And at the end of the cumulator, there is this fee transaction. Mainly what it does, it actualizes the root of there. So the coordinator get the fees in the L2. That's interesting, because we're using the same L2 to collect the fees in here.
00:26:20.590 - 00:27:02.152, Speaker A: Okay, let's talk about the exits. We know how to transfer things. In L2s, we know how to deposit things. But how can the users exit? Well, what we are doing here mainly is when a user is sending to the address one, which is leaf one, which is a special address, then that means it's an exit. And when we detect that an exit, mainly what we are doing is we are maintaining another merkle tree. So it's like another state. It has exactly the same format that the roll up state, but it's a state that in each block starts from zero.
00:27:02.152 - 00:27:50.308, Speaker A: So it starts empty. And we are adding there all the deposits that are exiting. So here what we do is in the process, two, instead of modifying the old fruit state, instead of modifying the old root estate, what we are doing is modifying the exit fruit. So we are creating another tree that includes all the tokens, all the money that's exited in that block. So at the end of the after all the transactions, we have a new exit route that includes all the exits that happen in that block. This exit tree is maintained in the smart contract. And then we can do a withdrawal.
00:27:50.308 - 00:28:29.572, Speaker A: So mainly in the withdrawal, what we need to prove is that we have some key that belongs to this exit route. So we have some tree that belongs to this exit route. And of course that we didn't have a kind of nullifier that we didn't withdraw it before. And all this, we can prove it with a normal merkel proof, which is a little bit expensive to do it in Ethereum, because Poseidon in Ethereum is expensive. But we can also use zero knowledge. We can also use a small circuit just to prove all this. The signature and the mercury of the exit and Hermes roll up allows both things.
00:28:29.572 - 00:28:59.416, Speaker A: Maybe with an exit that there is just a single exit in the batch. It's going to be cheaper to do it with a normal mercury. Maybe one level, two. But if there is more levels, then you can go to the zero knowledge sequence. So here is how we do the exit reconstruction. We start with an empty tree. And if it's an exit, then what we are doing is we are adding that into the exit.
00:28:59.416 - 00:29:26.004, Speaker A: But it looks like it's the same. It's the same processor. We are recycling this processor because we are actualizing a tree that has exactly the same format that the standard tree. And at the end we have the exit tree. Yeah. And this is what I mentioned you before. Okay, so all this because when we are processing, for example, these layer one transactions, well, we are modifying the state.
00:29:26.004 - 00:30:01.212, Speaker A: We are modifying here the layer one transactions, we are modifying the state. So we are creating new accounts and so on. So here what we do is, well, we collect what would be all the public inputs, if you want, or public input outputs. And we are packing all them and doing just a single SHA 256. What we include in these public inputs, outputs we have here. Let's start with the third one, the altar state route, the newest state route, the newer exit fee. So we have these dates.
00:30:01.212 - 00:30:42.640, Speaker A: We have all the layer one transaction for ladder. So here, of course, the layer one transactions. Yeah, we have it in the smart contract. But we need to guarantee that this is current what we are processing in the input. So actually what we do is we put all this input we include in this hash. So it's like if we put everything that we have in the smart contract and we put it in the circuit, and then in the circuit, we check that everything is exactly what you have in the smart contract. So we are processing exactly these layer one transactions.
00:30:42.640 - 00:31:14.600, Speaker A: We have all these layer one transactions. We have all this layer one, L2. This is what's data availability. The ones that we talked before, these four fields from, to amount and user fee. Here we have this 64, well, this is the deposit address. So where the fees goes, the operator. So the mechanism is the operator just sends in the transactions, put these fees.
00:31:14.600 - 00:31:56.728, Speaker A: So fee indexes, we put it in the operator and then we hash them together. So we see that actually these fee indexes. So where the transaction fees goes is also a valuable, it belongs to that availability. We know what needs to be included in the data availability. So in the call data of the forge block transaction, we have of course the chain id here too, just for relaying attacks. Here we have also the current batch. This is when we see, we'll see that a little bit more later.
00:31:56.728 - 00:32:43.444, Speaker A: And here we also have what's the old last index and the new last index. So when we are inserting transactions here, the smart contract needs to keep control on what's the last index, the last leaf that's inserted. If you have four leafs, when you create three new accounts, then you will have three more leaves. So we need to keep control on that. So we need to be sure also that the indexes, those smart contract keeps coherent with the state and we hash them all together and we have this single public input. And this is a single input that goes to the public circuit. Okay.
00:32:43.444 - 00:32:46.676, Speaker A: Yeah, I'm sure there is a lot of questions. I don't know if we are.
00:32:46.778 - 00:32:54.184, Speaker B: Yeah, we're good sometimes doing great on time. And maybe I'll let you read the question right off the chat window. I just wanted to flag that there was a question.
00:32:54.222 - 00:33:03.470, Speaker A: Yeah, let me just read there. I have a poll here. Which one is, I don't know. Igor. Yeah.
00:33:05.680 - 00:33:06.764, Speaker B: How many?
00:33:06.962 - 00:33:08.236, Speaker A: How many what?
00:33:08.418 - 00:33:13.324, Speaker B: Oh, sorry, go a little below. The question is how many transactions can be packed.
00:33:13.372 - 00:33:37.636, Speaker A: Yeah. Okay. How many transactions can be packed in one block and whether dynamic block sites can be support. Here we need to see, because we need to distinguish between what we call it a block and what we call it a batch. Okay. A block is for layer one. We reserve this word for layer one and we talk about the batch.
00:33:37.636 - 00:34:05.856, Speaker A: I understand that we are talking about the batch. In a batch, there is a fixed number of 2000 transactions. There is one kind of transaction, it's a knob transaction. So it should be less than 2000 transactions at most. Okay for layer one transactions. Okay. For layer one transactions, we accept only, well, the user layer ones is 128.
00:34:05.856 - 00:34:55.040, Speaker A: And operators layer one transactions are up to 256. So if you just used two users, you can do active, actually 254 operator transactions, you can end up until 256 with layer one transactions and the remaining transactions, or even less so until 2000 are just L2 transactions. Here, let me just go back a little bit. But here in the rot transactions here, you see states. It's a roll up transaction states. Actually, all this logic here is integrate all this logic. It's a layer one, it's a L2, it's an exit.
00:34:55.040 - 00:35:09.670, Speaker A: It's not an exit. So all these states or all these state variables are computing in this specific circuit here.
00:35:11.480 - 00:35:22.724, Speaker B: And then there's another question about or just a clarification on hashing to a single public input. And is this a technique to save on gas fees or gas fees on verification?
00:35:22.852 - 00:36:02.000, Speaker A: This basically saves a lot of gas fees, but it's also very convenient. Well, we pack them all together, so it's also safe constraints inside the circuit. But yes, mainly it's for saving fees. Doing a hash in the ethereum is very cheap. And then we just get a single input, and this input, then the prover is much cheaper. It has one single multiplication. It's just one group multiplication for the verifier.
00:36:02.000 - 00:36:03.750, Speaker A: So that's much better.
00:36:05.240 - 00:36:09.464, Speaker B: Okay, I think that's all the questions that we have for now.
00:36:09.582 - 00:36:21.550, Speaker A: Okay, so let's move forward. Okay. See how we go a little deeper in one of the specific circles. This is a fee accumulatory step. So this is for example. Well, if we start us from here. Okay.
00:36:21.550 - 00:36:52.432, Speaker A: Yeah, now we start from here. Okay, so this is accumulator step. So now I'm assuming here the fee accumulator, how the fee accumulator would look like. So the fee accumulator would look like there is 64 fee accumulator steps and each accumulatory steps. Mainly what it does is this. It's like, okay, you start from an accumulator. This is the input of the accumulator.
00:36:52.432 - 00:37:19.372, Speaker A: And here in the multiplex, we select, here we select if we add it or not. So if it's not added, then the fee accumulator just copied to the output. If it's added, just we select the one that's added. Okay. And here we have an internal signal here that is already selected or not. If it was already selected, then we don't do anything else. Okay.
00:37:19.372 - 00:37:45.076, Speaker A: And when we select it here, when the fee plan matches the token. So this is. Okay, this is the right one. If it is a right one and it's not selected yet, then is when we added them. If not, then it goes. And maybe it's a second. So if this already was selected, the next one is going to be selected.
00:37:45.076 - 00:38:09.810, Speaker A: So here is just an example of a very small circle. That's accumulatory step. And then when we put them all them together, we just put. And this is the fee accumulator of a single transaction. And when we go here and the fee accumulator, we accumulate all of them here. And at the end, we, of course, we add the transaction fees. This is, for example, how we add on this.
00:38:09.810 - 00:38:39.832, Speaker A: Okay. Here's another example. Just to have a detail of things. How it works. The last index id here is if it's new account, that mainly what we do is we increment. So we have this kind of circuitry for computing the new last id. Okay? Yeah.
00:38:39.832 - 00:39:06.204, Speaker A: One of the things that I announced in the main stage. And maybe I want to go a little bit deeper here is the massive migrations. We are prepared for massive migrations. And how will it work? Well, mainly here we have the hash that includes all the data availability. We have all this from and to. So how would it work? Let's see how it would work in Hermes. A massive migration.
00:39:06.204 - 00:39:20.580, Speaker A: Okay, so imagine that there is new version. It's Hermes two. Or there is, I don't know, uniswap L2. Or something like that. There is another L2 thing. Let's think. For example, that's like Hermes two.
00:39:20.580 - 00:39:44.008, Speaker A: Okay? And we want people just to move from layer one. These are very decentralized. And we want people to move to L2 in a massive way. So here, what we do is we create this destination. In this case would be the Hermes tool. We call it the destination smart contract for abbreviation. This contract.
00:39:44.008 - 00:40:04.448, Speaker A: What we do is we'll register a new account in the roll up. Mainly we do a deposit. If you want a zero deposit. So we create a leaf there. Okay? And then the people can start send tokens to that destination. To that index id. To that destination leaf.
00:40:04.448 - 00:40:37.308, Speaker A: Okay? In praters those. And this to the destination, to the destination index. The indexes means the destination index. So it's the index of this roll up. Okay. Then we have. Okay, in the roll up, we already have funds received from many accounts in a single roll up account.
00:40:37.308 - 00:41:09.448, Speaker A: So the smart contract can again do a force exit. A force exit is a layer one transaction that's sending, okay, just do a force. It's like force an exit. It's only from the layer one. Of course, because the operators is forced to mine to forge these transactions, then the exit will be created, okay. And because it's created, then it can withdraw. So once exited, this smart contract can withdraw it.
00:41:09.448 - 00:42:13.644, Speaker A: But the cool thing is that we can use the data availability hash to process all these transactions. We know all the transactions that this account received and we can have this data availability hash to process those transactions. In the L2 of the destination roll up, we have this Hash, so we can process this new roll up. They will insert these addresses, we can use the state and we can use the transaction hash so we can all the information, probably creating a circuit to process these massive migrations and update the state of the new roll up. But as you see, in the layer one, there is only one single withdrawal. There is one single transfer of the aggregated transactions until now of that token, of that contract. So this is a little bit how it works.
00:42:13.644 - 00:42:56.120, Speaker A: So it's possible and of course requires some work. It will require some work in the destination address, but this is actually possible there. Okay, I see some questions here. Let me read, let me see how many I might have. Massive, I have missed your explanation, but is ShA 250 hashing all this into a single public input, a technique to save gas? Oh yeah, we answered that, yes. Okay. Contracts upgrade.
00:42:56.120 - 00:43:17.548, Speaker A: Well, first of all, we want to disable that as soon as possible. That's it. But in the beginning, we have some security mechanisms that is going to be enabled at the beginning. We hope we can disable that very soon. And one of those is the contract upgrade. So in case there is something wrong in the contract, we have this. The thing is that we cannot upgrade.
00:43:17.548 - 00:43:39.370, Speaker A: So the upgrade has going to be one week delay for that. But as I told you, I hope that we can just fully decentralize. That means that this smart contract at some point will not be able to upgrade. Maybe we can use massive migrations to create another rollout, but it's going to be always an October. It's not going to be forced on that.
00:43:40.460 - 00:43:44.680, Speaker B: There's a question in the chat Jordy about the previous slide.
00:43:45.500 - 00:44:17.760, Speaker A: So one additional circuit is used for DSC, for bucket token. Bucket token transfer. Yes, exactly. In the recipient, it will process an exit. When you do an exit, you will process. But because you have all the information there, you have the hashes of all this information. These hashes can be like the input of this new circuit.
00:44:17.760 - 00:44:41.876, Speaker A: And then this circuit will process in the domain specific of the destination. Yeah, that's mainly how it will work. So one additional circuit is used for DSC, for budget token transfer. Exactly. Yeah. The destination will have to have their own circuit to process all these massive migrations. That comes from the role.
00:44:41.876 - 00:45:24.970, Speaker A: But we have all this information and we have it packed and hash. So it should not be difficult to process to convert this data that's already hashed there to the specific of this new roll up. We don't know how this roll up will be maybe using different corp and maybe there is some conversion there. But definitely you have all the information in the smart contracts and all this hashing can be inserted in this destination circuit. This is how it would work. I don't know if.
00:45:32.080 - 00:45:36.540, Speaker B: You saw the follow up question. I think so. One circuit for GSC, smart contract.
00:45:37.120 - 00:45:37.870, Speaker A: Yeah.
00:45:38.880 - 00:45:40.012, Speaker B: And one for smart contract.
00:45:40.076 - 00:46:13.028, Speaker A: Yeah, at least one. Yeah, maybe there is others, but yeah, at least one. Cool. Okay, so another thing that's safety mechanism. I don't want to go deep in here, but that's, well, again, this is a safety mechanism that we will start in the beginning, but we want to disable that very fast. This is just a kind of escape hatch just for the beginning. So how it will work? Well, first of all, if it is disabled people just you have in the end withdraw.
00:46:13.028 - 00:46:35.052, Speaker A: When you withdraw, you just withdraw and that's it. And this is how the system should work. And we hope we can enable this mode very soon. Okay, but what will be in the beginning? Well, at the beginning it's going to be two kind of withdrawals. It's going to be a direct withdrawal and delayed withdrawal. Direct withdrawal. The idea is that the direct withdrawal is going to be some rate limit.
00:46:35.052 - 00:47:05.690, Speaker A: So it's not going to be possible to directly. Maybe there is, I don't know, just 1 million tokens of each token per second. Actually, it's more complex than that. There is like five ranges of transactions and there is a limit for limit for high value transactions, a limited for less value transactions and so on. There is like five limits. And this can be controlled by governance. Okay.
00:47:05.690 - 00:47:50.036, Speaker A: But then if the rate is full, then the users can always do what we call it delayed withdrawal. Delayed withdrawal just goes to another smart contract that's not going to be upgradable. We call it a withdrawal delayer. And actually this will. So you will be able to get the funds later on, maybe in just 1 hour, in 2 hours, in one day or in some margin. In any case by smart contract this can never be more than two weeks. So this is the maximum delay that can happen, okay? And during this delay so the governance can switch.
00:47:50.036 - 00:49:16.324, Speaker A: For example, if the idea is that, for example if there is a problem and we detect some problem in the roll up, we can just put very very, so we can stop direct withdrawals just by putting a very low limit, okay, so we just stop withdrawal. So everything needs to be go to the withdrawal delay and we can delay that to maximum to two weeks. We can never get the funds but we can delay on that. So here we can analyze thing, we can analyze thing, maybe we can update the smart contract but see that we can update the roll up smart contract but we cannot update this. So everything that's in there, it's going to be there. And the only thing that we can do then is this, withdraw the layer. We have a trigger button, escape hatch button in case that we see that something that's measuring, for example a poseidon break, something breaks a poseidon or something really crazy happens on just a huge bag we found, then what we could do is we have an escape hatch and then the funds and this without the layer will go to with trusted members of the trusted members of the community, some white hats and people that's trusted, but it's not us, as I told you, we want to disable all these mechanisms, direct withdrawal for everybody and that's it.
00:49:16.324 - 00:50:28.264, Speaker A: And we hope we can reach this state of maturity very soon, but we'll see. And we need to be comfortable. And this is just some safety mechanisms that we want to be sure that everything works in the right way, especially at the beginning. Okay, another thing that we already talked about, the atomic transactions, how the atomic transactions work? Well, mainly what here is, and here is what we have, the decode transaction and the roll up transactions, the decode transactions, mainly what it does, it just gets part of the transactions. Imagine the decentric transactions, you see this one, that black arrows goes here, okay, so here what we send is we send the last four transactions and the next three transactions, the information of these transactions, and then we multiplex this to a single transaction. And this is a selector so the operator can select which is the pair, the transaction that's related, that's related to, okay, and the rockets verifier mainly is checking that what, sign it. What we saw at the beginning matches us with that transaction.
00:50:28.264 - 00:50:57.008, Speaker A: This allows us to, for example do an exchange. So I will send you this die, but with the condition that you send me this ether behind. So that there is this other transaction that's mining in the other direction and the other way around. So we have these two things. So we have these kind of linked transactions and we can do these atomic transactions. Another thing that we added recently is a time limit. So we can, in the transactions we have the time limit.
00:50:57.008 - 00:51:43.436, Speaker A: If we go to the first slide here, you see here, all these request transactions are from. And here the other thing is the maximum batch. I don't know if you see my cursor somewhere, but you see here the second block and second is the maximum batch. So this allows to create the transactions with timeout. If this transaction is not forged by this batch, then this transaction is invalid. And that's the motivation why we are putting as an input hash it. But as a public input, the hash id here is the last thing that we hash is the current number.
00:51:43.436 - 00:52:25.700, Speaker A: Okay. So we have these things that I think can be very convenient for exchanges or for payment channels for different applications that can run on top of the roll up. Okay. Yeah. And the last detail is that it's more a technical thing, is that you see here. So in the transactions, instead of computing the root in a serial way, here we have a transaction, we compute the root, the transaction, we compute the root. This is very slow to process because there is this dependency, especially in circumstance.
00:52:25.700 - 00:53:11.916, Speaker A: So mainly what we do is we do a trick here, is that what we do is, okay, so instead of calculating all these hashes in order, actually what we do is as an input, we put all the inputs of all the transactions, so we can process these transactions in parallel. And then we add single constraint that the output of these transactions is equal to this. Actually, we are not really solving the problem, we are just translating the problem outside the circuit. But outside the circuit, the things are much cheaper to compute and we can do much faster. We can do it in parallel, we can use other techniques. And here in the circuit we use it this way. So at the end, what we have is a parallel way of processing the transaction.
00:53:11.916 - 00:53:56.604, Speaker A: So if you analyze the circuit, you will see that there is these intermediate signals. It's just for optimization things. Okay, so this is my talk with you here. This is a brief introduction of how Hermes network works, especially how the cirques works. We are looking for people to take a look at the reviewers we love. If anybody is interested to review the code, please let us know. We are probably going to create a group of people that wants to review that, as you can imagine, more or less.
00:53:56.604 - 00:54:23.888, Speaker A: It's quite easy to find people that reviews, for example, smart contracts. But it's not easy to find people to review circuits, because it's more new technology and especially circuits in circom and so on. So anybody that's interesting, it will be very helpful. There is some budget for that. So just anybody that wants to join, please contact us with our discord account or something like that. But just join us. And that's the main goal.
00:54:23.888 - 00:54:35.224, Speaker A: If somebody likes this and wants to know more about circum, about Hermes and that, please contact us. And yeah, that's my presentation. Let's go for more questions.
00:54:35.422 - 00:54:53.868, Speaker B: Great. So we actually have someone who's raised their hand up live. So I'll bring them up now, Garrett McDonald. And then we have another question from the chat. So let me actually see if this works here. Hopefully we get Garrett in a second and then take that question. Then I'll go to the chat.
00:54:54.044 - 00:54:54.770, Speaker A: Ok.
00:54:58.340 - 00:55:02.850, Speaker B: There's a little bit of a lag, just so you know, Jordi, between the chat and the actual.
00:55:03.460 - 00:55:05.970, Speaker A: Okay, let me see what's the.
00:55:09.960 - 00:55:14.528, Speaker B: Maybe we'll just take Leo's question and I'll Dm Garrett see if he meant.
00:55:14.544 - 00:55:49.436, Speaker A: To ask the question. I'm going from then I'm going up. Can you talk a bit about performance? How long does it takes to compute proof of the circuit for 2000 transactions? Oh yeah. Approve of the circuit right now where we are just checking what's better just in a CPU or GPU. But it takes about two minutes to compute. Two minutes to compute this proof, depending on how many transactions, if they are zero or not. But the maximum.
00:55:49.436 - 00:56:00.070, Speaker A: The limit that we are managing is about two minutes. Next one. Thanks a lot for explanation, Jordy. You are welcome.
00:56:00.600 - 00:56:14.570, Speaker B: Yeah, I think you answered those kind of in the course of the talk. So we'll ask here. So, does anyone have any other questions for Jordy? And I just pinned Garrett to see if he wanted to ask his question live.
00:56:15.100 - 00:56:34.770, Speaker A: Oh, there you go. Where there is any tool to help transfer smart contracts to. No, no, it doesn't work that way. So you need to build the circuits. Actually, we built circum. You can go to circum. Let me just write it down here.
00:56:34.770 - 00:57:08.190, Speaker A: Go to GitHub. Find circum is circuit compiler, which is very easy name. And with that you can build. There are other languages, but this is the one that we are using here and it's very easy. There is some tutorials and there is also another for example, there is another ZK Sumit talk that I gave, like one year ago, talking about circum. You can go through there and it's very easy. But you need to create the circuits in there.
00:57:08.190 - 00:57:47.680, Speaker A: Snarkjs, which is. Let me just put here. Snark. JS is a tool, and there are other tools, but the tool that in some way it converts this circuit where you need to do the trust set up and all the sequences. But at the end, you end up with a validation key. And a validation key is what actually, you have a smart contract where you can validate this proof. But in order to build circuits, you need to go to a specific language for building circuits.
00:57:47.680 - 00:58:04.696, Speaker A: Circum is the one that we are using here. But there are others in the space you can check. Each one has these different properties. Circum is very straightforward. How it works. You just connect. It's very like for electronics, it's like a circuit.
00:58:04.696 - 00:58:17.756, Speaker A: You need to connect blocks and just join things. And it's like a puzzle. And then you build things. And this is how Hermes circuit is. Think. So.
00:58:17.778 - 00:58:28.964, Speaker B: It's running out of time for the session, but we have two more questions. I think we can probably get to both. Leo in the chat has a follow up question. And then we have another one just below that. Okay, why don't we take those two.
00:58:29.002 - 00:58:54.348, Speaker A: And wrap it up? Let me see. Leo, thanks for the two minute number. How many constraints does your circuit have? Two to the 27. So 128,000,000. Ah, yeah. Can you talk a bit more about how long? Yeah, I think it's. I'm done, right? I'm forgetting anything.
00:58:54.348 - 00:58:56.830, Speaker A: I don't know if in the past I forget anything.
00:58:57.600 - 00:59:03.356, Speaker B: Sorry, there's one more question below. Will all circuit code be open sourced?
00:59:03.548 - 00:59:18.884, Speaker A: Yeah, it's already open source. It's already there. I see somebody already. It's Tony. Okay, Tony. Already put. Let me just go to the link.
00:59:18.884 - 00:59:35.716, Speaker A: Well, you can see my screen here. So it's already open source. Here is the contracts. Here is the circuits. Let me just put and paste this. Somebody's already put there. This is the circuits.
00:59:35.716 - 00:59:54.904, Speaker A: But here's network. You can see here in MS network. We will publish everything in here. Right now we have the contracts and the circuits, which is mainly the protocol. But here we will publish also the contract circuits. It's private already, but we will publish all this. We will publish.
00:59:54.904 - 01:00:33.180, Speaker A: Here we have the Hermes JS for the API. The Hermes node. We have the dogs contracts. This is private, you see, most of them are private. But we will release when we clean up and we put something that it's easy to read on that synchronizer. Testing compatibility here is a little bit internals okay, but here is all the work that we are doing right now in the Hermes and we will publish in the upcoming weeks. As I mentioned in main stage, the idea is to have a running testnet for Christmas more or less.
01:00:33.180 - 01:01:36.512, Speaker A: And once we feel comfortable running this testnet, then we will go mine it. Hope this be very soon, but it's like we'll see how the things go. But what I can tell you is that we have the full team very committed to publish this as soon as possible, but at the same time as safe as possible. And we will not stop until we do it. So that's our commitment and that's why we are working for. I think it's important having a roll up of these properties with the scalability, just having this real number of transactions with scaling all that and having this in the space and understanding how the roll ups will work. This is very important for Ethereum in particular, but for the space in general, roll ups, I really believe that are the future for blockchain scalability and this is the best thing that we know right now.
01:01:36.512 - 01:02:13.212, Speaker A: So it's really an important step for the scaling space just together with. Oh yeah, I think we are out of time. So that's good. Just let me say that I'm very happy, for example, that Ethereum two right now, it was funded in a world so it will launch like next week, the Ethereum two. And this is very important also for the scalability, especially for the data availability in there. So the data availability together with the roll ups is actually what I really believe that will bring this to mainstream. That's at the end.
01:02:13.212 - 01:02:16.524, Speaker A: People use crypto everywhere. Yeah.
01:02:16.562 - 01:02:45.476, Speaker B: Well, thank you very, that's a great call out, Jordy, because yeah, big, big accomplishment for the ETH ecosystem today. And thank you very much for your presentation. I think we all learned a lot and I would encourage everybody in the session here to go check out our next session right after this. I think Leo from Algorand is going to be presenting a technique for aggregating vector commitments called point proof. So I really encourage you to check that out after this and I hope to see you around the rest of the event today. Thank you, Jordy. Thank you everyone.
01:02:45.578 - 01:02:45.890, Speaker A: See you.
