00:00:05.530 - 00:00:55.802, Speaker A: Welcome to Zero Knowledge. I'm your host, Anna Rose. In this podcast, we will be exploring the latest in zero knowledge research and the decentralized web, as well as new paradigms that promise to change the way we interact and transact online. This week, Tarun and I chat with Chris goes from Heliax, the team behind Inoma and Nemada. As a quick disclosure, I am an investor in enoma through the ZK validator. We start off with a short recap of Chris's journey since we last spoke on the show, and what's happened in cosmos since he and the team at interchange game Beha launched IBC into the wild over two years ago. We then dive into the topic of the episode that is intents and how one builds systems with intents at their core.
00:00:55.802 - 00:01:42.970, Speaker A: We cover the history, the concept of intents, from Chris's earlier work on the Wyvern contracts to his more recent work on Anoma. The discussion around intents has been growing over the last six months or so, but the meaning of the term can vary from project to project, so in this episode we try to lay the groundwork for intents. We explore the history of the term and the existing projects that already have some form of intents baked in. We then discuss how the term can be generalized and the new architectures that this could enable. We start to scratch the surface on the opportunity that this may bring for user experience, but also talk about the tradeoffs these systems need to grapple with, especially when you add ZK, or privacy to the mix. Now, before we kick off, I want to remind you about ZK summit ten. It's happening on September 20 in London.
00:01:42.970 - 00:02:18.250, Speaker A: Once again, we are bringing together ZK enthusiasts, experts, and practitioners from around the world to showcase the latest research, share updates, discuss important and highly relevant themes, and hopefully spark new projects, new ideas, and new directions. There's an application form not only for speakers, but also for attendees. If you want to join the ZK summit, you do need to fill that out. Tickets are limited, so applying does not guarantee a spot. But we do tend to prioritize folks who've applied early, so get your application in soon. I've added the link in the show notes. Now Tanya will share a little bit about this week's sponsors.
00:02:19.070 - 00:03:18.550, Speaker B: Polygon Labs is thrilled to announce Polygon 20, the value layer for the Internet. Polygon 20 makes mass adoption possible by offering users and developers unlimited scalability and unified liquidity. This mission is fueled by groundbreaking ZK innovations, including a first of its kind, ZK powered interoperability protocol and the next generation of the industryleading and widely adopted plonky two proving system. Polygon 20 will change the way we experience web3 by bringing the security and decentralization of Ethereum to the scale and usability of the Internet itself. Polygon 20 and all of their ZK tech is open source and community driven. Reach out to the Polygon community on Discord at Discord GG Zero x Polygon to learn more, contribute, or to join in on building the future of web3. Together with Polygon, Alio is a new layer, one blockchain that achieves the programmability of Ethereum, the privacy of zcash, and the scalability of a rollup.
00:03:18.550 - 00:03:45.454, Speaker B: If you're interested in building private applications, then check out Alio's programming language called Leo. Leo enables noncryptographers to harness the power of zkps to deploy decentralized exchanges, hidden information games, regulated stablecoins, identity products and more. Alio's incentivized Tesna is now live. Participate as a developer, apply for a grant, or go for a bug bounty. Check out forward slash blog for more info. That's alio.org forward slash blog.
00:03:45.454 - 00:03:51.030, Speaker B: You can also find the link in our show notes. So thanks again, Alio. And now here's our episode.
00:03:54.090 - 00:04:03.110, Speaker A: So today, Taruna and I are here with Chris goes from Heliax, the team behind Inoma and Pneumata, and we're going to be talking about the topic of intense. Welcome to the show, Chris.
00:04:03.190 - 00:04:04.122, Speaker C: Thank you for having me.
00:04:04.176 - 00:04:16.106, Speaker A: Actually, I should say welcome back. Last time you were on the show, you were here talking about IBC and the work you were doing there. I'm thinking this is over two years ago that we last spoke.
00:04:16.218 - 00:04:21.438, Speaker C: I think it was around the launch of IBC. Yeah. Which was in like February, March 2021.
00:04:21.524 - 00:04:26.762, Speaker A: Nice. Yeah. One of the first things I want to do is do a little bit of a catch up, but I also want to say hi to Tarun. Hi, tye.
00:04:26.826 - 00:04:27.054, Speaker C: Hey.
00:04:27.092 - 00:04:29.086, Speaker D: Excited to be back. It's been a little bit of a.
00:04:29.108 - 00:04:32.878, Speaker A: Sabbatical, but I'm glad to have you back.
00:04:33.044 - 00:04:33.374, Speaker C: Yeah.
00:04:33.412 - 00:04:50.498, Speaker A: Okay, Chris, let's do that catch up and backstory. Since you were last on, you were working on IBC. Since then, we know that IBC has launched. Tell me a little bit about that time. Yeah. How was it? Did it go the way you'd, you know.
00:04:50.524 - 00:05:17.502, Speaker C: I don't know how. I mean, I tackled IBC from kind of like a very tactical perspective at the know. There was a bunch of organizational chaos within cosmos. The engineering team had to unionize and secede in order to launch the know. We were a little bit like short term focused, let's put it that way. I don't think I had a theory of the political economy of IBC in 2021. We just had design problems make the blockchains talk to each other.
00:05:17.502 - 00:05:32.630, Speaker C: And I really wanted it to be something other than just token transfers because I thought that was boring. And if I spent like a year of my life designing a protocol that people only use to do token transfers, then it's hard to justify. Here we are two years later. People mostly use IBC to do token transfers.
00:05:33.610 - 00:05:34.920, Speaker A: I was going to ask.
00:05:37.370 - 00:05:52.938, Speaker C: At least people understand that it's more general than that. So that part at least it didn't get communicated early on. People read the cosmos white paper. It said like, IBC does token transfers. And so I spent a lot of time trying to communicate that. The problem it solves is a bit.
00:05:52.944 - 00:06:19.554, Speaker D: More general, maybe to go into a little bit, what are the things that aren't token transfers that people do right now that you would say stick out in your mind? To me, that one thing that sticks out is like people who use tendermint chains for custodying and then they build all this kind of like multi sig type of management across multiple chains. But there's got to be something better than that because that's only like a slightly above token transfer usage.
00:06:19.682 - 00:07:12.466, Speaker C: Yeah, I mean, I know there's some usage of, I believe the standards are called interchange accounts and interchange queries. Interchange accounts, I think is related to what you're talking about. Basically, where you use, there might be multiple layers of custody here, but where you use one chain or an account on one chain to control an account on another chain, interchange queries is basically like state proofs over IBC, just in this nice standardized way where you can request state proofs or particular things. People are using this, for example, for liquid staking in the cosmos ecosystem. I think there's a chain called stride which provides liquid staking for Cosmos hub and maybe some other chains, and they use some of these non token transfer IBC packets. So if you go look at the chart, the mapofzones.com, I think it is, I don't know if they display packet type breakdowns, but it's still probably 99% token transfers.
00:07:12.466 - 00:07:14.406, Speaker C: But there is at least a little bit of other stuff.
00:07:14.508 - 00:07:21.398, Speaker A: Would you say, like, looking back, is there any choices that you made at the time that you would now make differently?
00:07:21.494 - 00:07:53.106, Speaker C: Yeah, I mean, I think it's interesting to watch. In some sense. IBC was kind of early, like bridging protocols seem to have become a very hot topic in the last twelve months, six months now. There are a lot of other protocols which, from my very biased perspective, I kind of wonder why they are necessary. It seems like many of the problems people want to solve are problems that, at least in principle, IBC kind of was designed to tackle. And I wonder why they don't just use it. But I think that there are good reasons for that.
00:07:53.106 - 00:08:20.166, Speaker C: I think IBC made some assumptions about. I mean, it's a relatively intricate protocol. It's difficult to implement it in solidity, even if the gas costs weren't a factor. And on EVM chains, typically they are. It's just like a lot of work to implement a protocol like that. IBC, it tries to provide many things. It tries to provide, for example, different ordered channel abstractions that you can have relationships between the partial orderings in different state machines.
00:08:20.166 - 00:09:08.342, Speaker C: So it's designed for efficient concurrent cross chain communication. And how many concurrent vms are there on blockchains right now? Are any of them using multiple IBC ordered channels to have efficient parallel cross chain execution? I think the answer is no. So some of that protocol complexity maybe could have been factored out or abstracted in different ways. I think there have been some learnings there. I also think there's still a fair amount of incentives for communicating things or understanding things that are kind of token aligned in unhelpful ways. Not that it's anyone's fault, but I think people perceive IBC sometimes as particularly cosmos specific or tendermint specific. And some people, occasionally I end up in conversations like, oh, do I have to use the cosmos hub to use IBC or something? Or people thought they needed atoms, which you don't.
00:09:08.342 - 00:09:17.278, Speaker C: But that indicates a certain. I think that kind of communications mismatch may lead people sometimes to reinvent the protocol wheel when they might not have needed to.
00:09:17.364 - 00:09:51.834, Speaker A: Do you think the role, like, now that it is live and it's been live, the role of the relayer is something I'm kind of curious. Did you already envision how that would happen? Or had you thought of incentives for relayers? And maybe just to describe to the listeners, there is this agent that's helping to move things. I may be saying this wrong, but bring things across from different zones over IBC, but that often are not compensated. And so incentives for running this infrastructure has been sort of questioned or it's been thought about since then, right?
00:09:51.872 - 00:10:48.860, Speaker C: I mean, to be honest, at the time when we were working on IBC, we had like three engineers. And so at the time, we made the kind of choice to simplify our scope somewhat by leaving problems till later that at least didn't have anything to do with the security of the protocol. And the relayer was one of, you know, I'm sure we could have considered some of the things at the time more, but I don't think that even if we did, there was very much we could have done with the way the scope for IBC was designed. Right. The scope of IBC takes tendermint as this black box, or takes consensus black box, which have their own peer to peer networks and their own rules for accepting transactions and their own systems of messaging. And IBC just builds on top of those black boxes another system of messaging on top. Right? So the relayers are acting as message relayers, just copying data basically from one consensus network or Mempool to another.
00:10:48.860 - 00:11:36.810, Speaker C: And the only way, thinking about it now, the only way I see to really clean those abstractions up is to redraw some of the boundaries and to basically to make consensus more aware of this interchange messaging that's going on to kind of fuse these networks, at least partially so that messages can just flow at the mempool layer or the sort of lower level gossip layer directly. Right. I mean, IBC, when executing an IBC transaction, in some sense, the blockchain already knows where it should be sent. Right. It's just the fact that the validators running consensus, they don't have any protocol built in way to route a message to this other network. So you have to sort of redraw the boundaries to get that without any additional relayer, which now you have to pay. And it's just this kind of software engineering point of unnecessary complexity.
00:11:37.390 - 00:11:39.334, Speaker A: Although they don't pay the relayers.
00:11:39.382 - 00:11:40.990, Speaker C: Right, still, they're subsidized.
00:11:41.570 - 00:11:42.320, Speaker A: Okay.
00:11:42.690 - 00:12:22.618, Speaker D: Actually, one other point towards implementing IBC and other networks. It definitely seems like the security characteristics of the particular implementation can be quite nuanced. And so I've always heard people who've tried doing EVM IBC style protocols arguing that they can't really verify the exact same claims. That, I know you spent a lot of time on the verification for Tenderman Cosmos SDK, and I imagine that that might also be a slight barrier to entry of re auditing that for the new environment might be just as hard as it was for you the first time.
00:12:22.704 - 00:12:23.786, Speaker C: Yeah, that makes sense to me.
00:12:23.808 - 00:12:24.650, Speaker D: Do you think that's.
00:12:27.550 - 00:13:09.234, Speaker C: Know also, I think it depends on when people tried to do it early on. A few of the abstractions in clients, for example, light clients in IBC, which is the part that performs the verification, were not the cleanest. They were still maybe a little bit tendermint specific or made certain API assumptions which would be difficult to satisfy with an EVM blockchain or a very different consensus algorithm over time. The IBC team has done a pretty good job, I think, cleaning those up. So I suspect that some of these concerns might have been addressed. But IBC was not designed to be efficient on the EVM, right? Or easy to implement on the EVM. That just wasn't design constraint.
00:13:09.234 - 00:13:22.634, Speaker C: And most roll up teams or people building bridge protocols currently, I expect, just because of the prevalence of EVM networks take that to be a design constraint, they probably end up with, at the very least, different engineering trade offs.
00:13:22.762 - 00:13:44.578, Speaker A: Let's continue on with your story. So this was cool to hear the recap since IBC launched, but after the launch of it and after it was rolled out, what did you do? Did you stick around for a while? I know you'd been working at interchange game Beha at the time, I think. But yeah. Tell me a little bit about what you started working on since then.
00:13:44.664 - 00:14:08.666, Speaker C: Right, so IBC launched. I'm going to get these dates wrong now, but I think in February, March 2021, along with a Stargate upgrade for the Cosmos network. Now, it took IBC launched, and then it was on one blockchain. An interoperability protocol on one blockchain is not so useful. Right. So it took a few more months before people launched other chains. I think the iris hub had it pretty soon on.
00:14:08.666 - 00:15:01.930, Speaker C: And the real kind of kickstart for IBC usage came with osmosis, right. Kind of later in the summer. So there was a slow start. But around the time IVC launched, I kind of wanted to see that through to actual production, and it seemed to be working. Someone did token transfers and then that was kind of a good cadence for me to just part ways with interchange, although I still remain friends with them and kind of embark upon a philosophical investigation into what the purpose of all these blockchains is, which is kind of. Whoa. Well, I would say like anoma started with this vision paper, right? And the vision paper describes how we thought about trying to characterize coordination in particular and how blockchains might be helpful in solving coordination problems.
00:15:01.930 - 00:15:35.574, Speaker C: But the vision paper is abstract. I think it was helpful for us thinking about things, and it was helpful for recruiting some people who are interested in these aims but it wasn't yet a mathematical description of a system. Right. And it took us several kind of different tries and incarnations to come up with a good understanding of how all of these concepts and components fit together. So that's what we've been doing on enoma in the past two years, really. And we care about things like privacy or. I've stopped using the word privacy recently, I think is the wrong word.
00:15:35.574 - 00:16:15.220, Speaker C: Maybe we'll get into that later. But we care about the ability for users to reason about where their information is going within a system. We care about all of these design constraints that we wanted to kind of all include to how we even think about what the system is doing in the first place. So a lot of anoma's journey in the past two years has been figuring out what that is and also the right words to describe it. So I suspect that sometimes people have been confused because very fairly, we used one term to describe a system, and then we decided we didn't like it. And then there's like some terminological whiplash going on. But I hope that we're reaching the point of sort of conceptual solidification and it will become clear what everything means.
00:16:15.670 - 00:16:29.618, Speaker A: One of those words is one of the things we want to talk about today. I think intense. And I have to say, every time I say it, it comes out a little bit, like, intense, but it's intense. Intentions is sort of like, yeah, that's.
00:16:29.634 - 00:16:32.714, Speaker D: Why it's a good meme, though. That's the point.
00:16:32.832 - 00:16:35.062, Speaker A: Oh, really? It's just super intense. Intense.
00:16:35.206 - 00:16:40.860, Speaker D: People make so many memes about it because they can't say it exactly correctly in every different.
00:16:42.110 - 00:17:07.570, Speaker A: Nice. We wanted to bring you on in part because we wanted to start exploring this concept of intense. And I wondered in that story you just shared and kind of trying to figure out a lot of these concepts. When does the idea for intense start for you? Is it with anoma, the founding of where. Where did that first come up? And did you coin the phrase? Because we think you did?
00:17:07.720 - 00:17:31.020, Speaker C: Right. The honest answer to that question is, I don't. So I know when I actually traced this back recently because I was interested in this question. Okay, when did I start using this phrase? Because I didn't really remember and I managed to trade. The first piece of writing I found that used the phrase was actually back to this protocol called Wyvern, which I wrote as an early Ethereum project many years ago, like five, six years ago now.
00:17:31.630 - 00:17:35.086, Speaker D: You should also mention it's one of the most used Ethereum contracts in history.
00:17:35.188 - 00:18:18.138, Speaker C: Right. Or another way of putting it is that the Ethereum miners gained a lot of extra revenue from my very not gas optimized solidity contracts, which were written in the days of like 4g way gas prices. Like, it was great. So yeah, ethereum miners, you should donate to public goods. But originally I wrote Vivern kind of as, I don't know, just a random project. I was just thinking at the time, I was reading a bunch of meditations on Moloch or something like blog posts about coordination problems. And I thought, oh, these blockchains seem like a great tool for solving these coordination problems because you can make credible commitments and you could just describe your preferences about the state of the system.
00:18:18.138 - 00:18:58.438, Speaker C: Right. And I just prototyped that in a way, but it was very, Wyvern kind of implements intents in a very limited and restrictive way on top of the evm. So in order to do that, it needs a very hacky account abstraction sort of thing. It can only do two parties, basically, or I wrote it just to do two parties, because other things are just more complicated. But it could do simple kinds of intents. And openc use this even for stuff like bulk orders, I think so users could describe which nfts they wanted to buy in a bundle or something and place bids or offers on specific combinations of things. So, yeah, early kind of prototypical intent system.
00:18:58.524 - 00:19:12.860, Speaker A: Cool. I didn't know you were behind that. I know that from, I mean, if you've ever signed like a bulk thing on Opensea, you see the name of that contract. It's Wyvern. Yeah. Okay, cool. Interesting.
00:19:12.860 - 00:19:15.710, Speaker A: Was that just you or was there like a group of you there?
00:19:15.780 - 00:19:41.622, Speaker C: Well, so originally I tried to be pseudonymous, and so it was mostly just me. And it was very hard to be pseudonymous, which is why I gave up and went to not being pseudonymous. No longer pseudonymous. I don't know what I'll do after inoma to become pseudonymous again. Dye my hair like some other color. But it was difficult to kind of recruit contributors in that day and age when you were pseudonymous. There was just too much spam in the world.
00:19:41.622 - 00:19:48.070, Speaker C: So why remember, it was mostly just me. I mean, a few people contributed to the open source stuff, but I didn't want to turn it into a company or anything.
00:19:48.140 - 00:19:57.930, Speaker A: So you're saying that it was like around that time in that project where you first started to use this term. Let's continue on that. So when was the next time?
00:19:58.080 - 00:20:35.586, Speaker C: Yeah, to be honest, my reflections at the time I worked on this project for Ethereum, I thought, oh, cool. That was also before it became popular. So I didn't have any slide incentives, which maybe is good, but then I thought, but I think we really need political polycentrism. Right? I don't want one world computer. I wanted like a network of sort of interoperable, kind of overlapping computers. So for that reason, I went to work on IBC because that seemed like the thing most relevant to this understanding of the political philosophy of blockchains, and then joined the Cosmos project and worked on IBC. So I kind of took the intent idea and then, hmm.
00:20:35.586 - 00:21:01.502, Speaker C: But we need like a different foundation. It went somewhere else. Also, I think it's know, I don't want to claim a special amount of foresight here. I don't think that I had a special amount of foresight. I was just reading some blog posts about coordination problems. And the word intent comes very naturally from natural language. If you're getting lunch with some friends, you say your intent, like, I want to go to mexican food or thai food.
00:21:01.502 - 00:21:19.030, Speaker C: I want to go to thai food before 13:00. Then you find some match that satisfies all of those preferences. And most people would have no trouble describing, they might not always use the word intent, but if you use the word intent, people would understand what you're talking about. Right. So I think there's kind of a natural correspondence here.
00:21:19.100 - 00:21:27.160, Speaker A: Is there any intent stuff in IBC? Or would you say you shelved that for that project and then kind of came back to it?
00:21:27.850 - 00:21:54.686, Speaker C: Know, it depends on whether some of the messages in IBC are kind of formally intense or not. Depends on how exactly you define the term. And some of them might be. But if they're intense, they're not really user level intents. They're like protocol level intents. Like subject to these conditions, update the state atomically on this other chain. Right? So, yes, but not at the kind of holistic, user centered understanding of intents level.
00:21:54.788 - 00:22:08.950, Speaker A: I think it's probably a good moment to really define it and maybe define it as you define it today. I think you've just given us a really kind of nice human example of the thai food lunch plans. But tell us your definition of intense today.
00:22:09.100 - 00:23:08.594, Speaker C: Right. So I want to give two definitions here because I think they're actually the two slightly different. So another reason why I think intense has recently become popular, and it's clearly not due to anoma, because we've been talking about it for a long time and it never became popular. So I think credit for intense becoming popular is much more due to kind of what you alluded to, Tarun, but that it's this kind of unifying concept or universal concept, which is a great way to describe what many of these systems are doing that you can view from a lot of different angles. Right? So the first definition of intent I'll give here is the way that I think people use the word on Twitter, let's just say, like in the discourse. And I think there, people use the word intents to refer to basically credible commitments to preferences over the state of some system, right? And what the system is, the kind of boundaries of the system vary. So someone might be talking about intents on Ethereum.
00:23:08.594 - 00:23:39.314, Speaker C: Then the system they're talking about is Ethereum. Someone might be talking about intents across all the ethereum roll ups. Like maybe suave is interested in this. Then the system they're talking about draws boundaries around all the ethereum roll ups. Someone might be talking about intents in cosmos, or like some cosmos chains. And then the system they're talking about draws sort of bounds the system around these cosmos chains. Right? But in particular, the first part of that definition, credible commitments to preferences, distinguishes intents from transactions in this useful way.
00:23:39.314 - 00:24:28.318, Speaker C: Right? So intents don't specify an exact path of execution. Right. They specify some executions of a system or some future states of a system, which a user is, let's just say, happy with, or which a user authorizes. That's what makes the commitments credible. And then how precisely what exact path the system takes, what exact computations the validators execute, or including solvers and other parties to get from a to b, let's say, is not fully constrained by the intent. Whereas in a sort of transaction based system, kind of at the other extreme, a transaction fully constrains, it says start at a and do little step x, then little step y, then little step z, sort of whatever you get to, that's what I authorize it in virtue of its having resulted from this passive execution. But an intent instead authorizes this kind of end state directly.
00:24:28.494 - 00:24:30.434, Speaker A: Was that your first definition or was that both?
00:24:30.472 - 00:24:32.466, Speaker C: That was definition one, yeah.
00:24:32.648 - 00:24:35.218, Speaker A: Okay, so what's definition two?
00:24:35.384 - 00:25:30.758, Speaker C: Definition two is kind of the version where you try and include privacy or try and reason about how information is flowing around the system. And this is kind of the definition anoma uses, which is just a little bit different, that intents are credible commitments to information flow constraints. So in particular, intents, let's take the example of like a zero knowledge swap. I think it's illustrative. So when you're doing some kind of zero knowledge swap with Tyga. And I suspect that other private swap projects, I don't know exactly how they work, but they're probably doing also routing information in this way. What you're really doing is saying that I will give someone information or give their private key, which I know the public key for the ability to send these tokens, which I'm sending to them in the future, if I also get this other information which allows me to send these tokens that I'm getting in the future.
00:25:30.758 - 00:26:50.814, Speaker C: Right. So the thing which you're actually routing around the system is information which is related in a particular way, right? In this case, it's related to some state on the blockchain, which is information that everyone can see that, assuming everyone follows the protocol, says that if we provide a zero knowledge proof of such and such in the future, that counts as spending the asset. Right? But this definition probably sounds really abstract, and in a certain way it is. But it's also helpful in that it kind of unifies what we're doing with all of these little cryptographic components, right? There are many different cryptographic components in a system like anoma or ethereum, sort of public key cryptography, digital signatures or knowledge proofs, sometimes fancier stuff, verifiable encryption, homomorphic encryption. And if we think of from the perspective of the system designer, and in particular from the perspective of the user, what these cryptographic components are doing from the perspective of the user, these cryptographic components are allowing them to specify how information gets routed around the system, right? And you could have a transaction centric view of that where you say, route information in exactly this way and exactly these steps. And a more intense centric view steps back and says, okay, here are the ways in which you could route information that I am happy with that I authorize. Right.
00:26:50.932 - 00:28:26.142, Speaker D: I guess one question I have about these things in general is somehow, and maybe this is my myopic view, but somehow these definitions never include any notion of efficiency. And I think somehow that seems fundamental to how well they're usable by end users. There's sort of a couple high level things, right? There's like, how efficiently can these paths be found or taken? And then sort of how when you talk about some notion of credibility, in some sense, to me, credibility, at least from the sort of economic lens, sort of means, hey, the user doesn't really have to do a lot of work or a lot of communication to figure out that the person who's doing the task or the group that's doing the task didn't fuck them. I think that's my colloquial definition, right? Like, you don't have to do much work to know you didn't get fucked, right? So maybe a little too blunt of a definition, but somehow there's like three components here, right? There's like privacy, there's efficiency, and then there's, how easy is it to tell if I got fucked, right, whatever that is. And somehow those three things are this triangle that you're kind of choosing where you are. And that's where I find it hard to come up with one definition personally. But if that makes sense, there is some balancing of this table of those three things.
00:28:26.142 - 00:28:36.400, Speaker D: It feels like. I don't know, do you think I'm missing anything in there? Because at least that's always been my conception, is that those three things are like the fundamental things you're getting at, right?
00:28:36.930 - 00:29:12.526, Speaker C: No, I mean, I think you're absolutely right. That intent, at this level of abstraction doesn't talk about efficiency. And. And I think that results from that. Intent is a way, at least as we use it, is a way of describing what's happening in a system that is dependent only on properties which the user can ultimately verify, right? Or is not so concerned with how things get computed, but rather is concerned with what could be verified at the end. And that things can be efficiently computed is very important. Right.
00:29:12.526 - 00:29:45.586, Speaker C: It's critical to a system actually working. But I think you can describe a system sort of the topology of a system and the properties which interfaces must satisfy in a kind of simpler and just more easily universal way, if you leave how things get computed as a separate choice. Right? So not that intense. Wouldn't say that an intense f grid sign wouldn't make your system more efficient or less efficient necessarily. It's just sort of orthogonal to the question of efficiency.
00:29:45.698 - 00:30:43.894, Speaker D: Yeah, I get that there is a way of defining it separately, but it does feel like in practice it does quite matter. And part of the examples of this, or like, the intents that people talk about as existing in practice, are like Cal swap or rfqs or like kind of like Xerox or Yvern. And those just have a very particular notion of efficiency. There's sort of a sense in which efficiency is built into their mapping. You have to prove to the user some guarantees on price or some guarantees on routing quality, right? And their efficiency seems to be quite explicit. So I guess my question is, you're talking about a definition that doesn't include it. What's like the boundary, right? It feels like it's like a computational complexity boundary of, like, some things can be intense, but never verifiably efficient.
00:30:43.894 - 00:30:54.298, Speaker D: Intense or something. And how do you think about designing a system when your users are sort of not omniscient and unfortunately have to run simple algorithms?
00:30:54.474 - 00:31:43.790, Speaker C: Right. No, I mean, then I think it definitely makes sense to restrict the space of intent that you actually encourage users to author and try to execute two ones for which there are sort of computational bounds on the solving algorithms, right. And something like uniswap or cowswap or opensea all have nicely boundable complexity solver algorithms. Maybe a kind of interesting alternative lens to this question that I think is helpful is thinking about when we're. We could come up with, in principle, you can make an intense system that is like a sort of interesting way to farm out NP solving problems to a market. Right. And I think that probably does have some applications.
00:31:44.210 - 00:32:50.900, Speaker D: That was the original Cal swap, which never took off, like whatever gnosis called the Dex gnosis Dex in 2019 or 2020, where they had this NP hard problem, but they're like, we'll take any solution that verifies. And it was just like matching these pools of different tokens, but it completely was too complicated. And then by that time, Uniswap and the simpler complexity things beat the more complex things. But they were effectively farming out this mixed integer or linear program and being like, hey, find a solution. If you find any solution up to some constraints, we'll execute it, and you win. I guess there's sort of this thing where this is where I find trouble reasoning about these systems from all the different aspects that people have, because the very concrete ones, the efficiency thing seems. You know, when you gave this talk at research day in New York, was that last month or two months ago? Something like that? Last month, maybe.
00:32:50.900 - 00:33:10.334, Speaker D: You gave a lot of examples of more general intents. Right? Like writing a programming language for these. So I guess. How do you think about that? How do you think about the structure of a language for describing this? And maybe this goes into the philosophy of how you should write languages.
00:33:10.482 - 00:36:01.130, Speaker C: Yeah, I guess, to be clear, I guess as a protocol designer, I work really hard to be lazy. Right? Like, I want the minimum number of abstractions to kind of talk about how different parts of the system relates to each other. And at least I find in kind of conceptualizing what's going on, efficiency to be separable, as in, not that you would not in practice, you want to use systems where you can reason about efficiency, but the relationships of the interfaces that allow you to compose a system like, let's say you have a zero knowledge proof scheme, right? And different zero knowledge proof schemes have different specific efficiency parameters, but they all provide the same abstract interface modulosum, important but mostly abstractable or cryptographic assumptions, right? They all provide you a way to take a statement and make a proof about it that a third party verifier can verify, usually non interactively, that attests to the truth of the statement, or that, you know, some data satisfying it. So I think it's possible to describe how you would fit a zero knowledge proof scheme into some larger system and then separately calculate the efficiency of using the whole composite system with different zero knowledge proof schemes, right? So just from the design perspective, it's helpful to separate these parameters. I think if you do it well, it can allow you to reason more cleanly about efficiency, because you can view efficiency as a function of a composition of the different costs of all of your different specific primitives, right? So you have kind of some system design that uses a zero knowledge proof scheme and you can reason about, okay, well, given a zero knowledge proof scheme with proof size x and prover cost y and verifier cost z, you can say the whole efficiency properties of this system are a function of x, y and z, right? And then you sort of pull that out, right? That would at least be sort of my argument for why this kind of frame could make reasoning about efficiency a little bit easier, just because it separates out these components in terms of languages. I think primarily what we've been spending time on is thinking about what the key, you could call it vm, or like what the key black box abstraction that an intent center system tries to provide is, right? So something like Ethereum was originally designed to provide a world computer. They modeled, or at least that's what used to be on the website, and they modeled the EVM after these old von Neumann machines, which take some instructions and take a stack, some memory, and kind of run through the instructions in sequence, right? So users send transactions which give sequences of instructions and those are executed.
00:36:01.130 - 00:36:51.614, Speaker C: And the central replicated abstraction that's being provided here is this sort of instruction executing machine, right? So what we've been trying to think about is what instead would it take to make an intent executing machine? And the one thing which sort of changes from a transaction centric world to an intent centric world is that in an intent centric world, you have multiple intents which you want to match and settle atomically, and you want to take the system from some initial state to some final state where all of the intents involved in that. That is what we call a transaction, right. All of the intents involved in that transition have their conditions satisfied. So it's a different black box, right. As opposed to like the atomic unit is execution instruction. Execution instruction, executed an instruction. The atomic unit for us is take a lot of intents and try and match them in some way.
00:36:51.614 - 00:37:38.154, Speaker C: And then there's a very nontrivial problem of how do you choose? Because now you have multiple possible paths of execution, right. There are many different, at least potentially many different final output states which might satisfy all of the involved attempts. So now you have this very nontrivial problem of how do you pick which I'm going to leave for later, but for now just talk about this black box. I'm not sure. I think originally we thought that that might be a languages question, and we did a lot of language research and we have some interesting languages which do nice things like abstract zero knowledge proof schemes. That one's called vampire. But I'm not really, in the end, I think it's maybe not a language question, it's more like a VM design question or like, what is your atomic unit of state transition?
00:37:38.282 - 00:38:05.446, Speaker A: I'm kind of curious, as you describe this, how if you had multiple parts of this kind of intent put forward, are you talking like the end user would basically say, I want this for either this or this, or maybe I want this instead for this? Is that sort of what you mean? It's like this desire and how much they want to pay and what they want to do with it. Maybe can you give a little bit more color to what that ux might look like?
00:38:05.548 - 00:38:36.242, Speaker C: Right? I mean, it could look like that. It could look like something like a. Let's take the example of real world things, because I think it'll be a little bit clear. So if I want to purchase a festival ticket and a hotel ticket and a train ticket all at the same time, I want atomicity for that transaction. But I might have some flexibility for, let's say, the dates. So I want the cheapest set of tickets to go to the festival. The festival's running next weekend and the weekend after.
00:38:36.242 - 00:38:51.558, Speaker C: So two possible weekends. I want train tickets from Berlin to Munich for three people. I want to be sitting next to my friends. Right. So I have some preferences over the state space here, but I'm willing to go either weekend. I just want the best price.
00:38:51.644 - 00:38:52.946, Speaker A: This festival is in Munich.
00:38:52.978 - 00:38:58.246, Speaker C: Yeah. Or the other way city I came up with. But Munich must have some festivals I.
00:38:58.268 - 00:38:59.800, Speaker A: Feel like you'd be coming up to.
00:39:02.490 - 00:39:33.730, Speaker C: In that, in that example, right? In that example of these specific real world, these would be non fungible tokens or something like this. Yes. The user would use some kind of interface that describes what configuration of things they want. And if you go to online ticket sellers or something like mean, they typically have some perhaps slightly simplified version of this. Right? You can search through things based on constraints. You can select your maximum price, you can select which dates you're willing to fly. And Google flights is a very intent based flight search engine.
00:39:33.730 - 00:40:39.210, Speaker C: Right? It's doing a lot of pathfinding for you. So I think that many things, many applications in the real world already try and do a lot of the work of interpreting a user's intent for them and searching over the state space of available flights, available hotels, available. You could even have something like available stock trades on the basis of what the user said their intent was. That's the kind of like real world application example. I mean, also, and perhaps to Turin's point, there are many kinds of intents for which you want very specific efficiency or fairness guarantees. Like you want a guarantee of optimal execution over some batch of intents, or like fair pricing over some batch of intents, and there your intent is going to include that constraint. So it's going to say that I am happy with the output price I get, as long as the output price is calculated in this way, where this way is like, take all the intents in this batch, which was maybe previously committed, and then threshold decrypted and calculate the output price at the best price.
00:40:39.210 - 00:41:31.602, Speaker C: Or let solvers within some period submit solutions and rank them by whatever your price optimality criterion is. So intents will include often properties that they want to be true about the path of execution. Right. And that might be a way in which you can get specific kinds of efficiency or fairness guarantees. I think that's particularly important when dealing with fungible assets. Let's say a lot of the things people use uniswap or cowswap to do today, and might be for tickets or something like train tickets, hotel tickets, these things are a little, it's harder to define what a kind of fair price would be, and maybe also a little bit less important because there is mev scalping. I don't know, there are weird things, but there's less immediate concern for exact best price execution in some batch.
00:41:31.746 - 00:42:02.802, Speaker A: I want to just go back. So we've mentioned sort of cowswap a few times, and when I started learning about this concept, cowswap was floated as like, if you want to know how an intense system kind of works, cowswap sort of does that. But what is different from what they are doing? And what you're like, is there some sort of central actor in their system? Is it because it's including zkps that it becomes more interesting? Yeah, I'm just curious how you'd differentiate your new ideas about intents from what that is.
00:42:02.856 - 00:42:42.362, Speaker C: So Enoma really just aims to kind of generalize and protocolize the architectural problems faced by intent centric applications. So cowswap is already an intent centric application. They have users sign intents. They submit them to some kind of aggregator. I think as far as I understand, like the last version of the system someone explained to me, so it could have changed, but the last version I understood, someone, users submit their intents to an aggregator. The aggregator takes a batch of intents, then solvers compete to submit solutions for that batch, right? So Cowswap has built all of this extra infrastructure. They've built this aggregator, they've built this intent language.
00:42:42.362 - 00:43:27.514, Speaker C: They built this kind of way to rank solutions from solvers. People have built solvers, and Enoma really just tries to build protocols that can handle many of those things without special cased intent systems for each application. So Cowswap has their own RPC API and own network for submitting intents. And cowswap intents are Calswap specific. They're not composable with intents of other applications, at least not easily, because they're kind of being handled by this separate network and sort of off chain execution selection system. And Enoma tries to make things composable at the intent layer. Right? So you could have intents for one application and intents from another application and know in some cases they might not even be solvable unless you compose the applications.
00:43:27.514 - 00:44:17.914, Speaker C: Right. Let's suppose that I want to buy a ticket, but I want to pay in some different currency other than what the ticket seller wants to accept. Right. Then I might want to compose intents from the ticket application and from the currency trading application so that I can get this composed thing which together matches and satisfies everybody's preferences. But without intent level composition of applications here, you would just have two separate interactions. At the very least, you couldn't make them atomic. Primarily what we're aiming to do is solve the general problems once and turn them into protocols so that people who want to build applications like cowswap or like Opensea can do so without reinventing the wheel on intent based architecture, without building their own networks of solvers, without building their own gossip systems for intents, without building their own intent languages, especially if they want privacy.
00:44:17.914 - 00:44:28.786, Speaker C: That's kind of a big lift in terms of cryptography required. So we want to standardize and abstract those components of intent centric applications just so that they're easier for people to write and can compose. Yeah.
00:44:28.808 - 00:45:09.838, Speaker D: The only thing I wanted to kind of ask add is, in some sense, all of that sounds great, but the thing that still is hard for me to deal with is there's so many just difficulty or impossibility results for these types of aggregation problems and just really actually understanding. How do you think about things where someone writes some intent system, but they create a bunch of intents whose aggregation is basically too hard to solve? How do you deal with some of these problems where the developers can shoot themselves in the foot? Because you can easily do that with the very tiny changes. So I'm just kind of. Yeah, like, how are you thinking about that?
00:45:09.924 - 00:45:52.154, Speaker C: Right. I think that we want to still give people freedom, or at least we don't want the architecture to necessarily constrain all these things. What becomes feasible to solve will also change in time. But we're trying to build, say, a language for intents that has very clear termination properties, has computational complexity, that you can reason about stuff like this. So you should be able to check whether or not solving a particular kind of intent is feasible. Nothing in the architecture can exactly prevent developers from shooting themselves in the foot. I mean, I think it's a different, like, the pistol is different, right.
00:45:52.154 - 00:46:29.142, Speaker C: In Ethereum, it's easy to shoot yourself in the foot by assuming that you have this control over ordering that you really kind of don't. Right. And that's. We see these sort of nonmev aware applications, at least implicitly, seem to be making the assumption that people will submit transactions, and that's the only thing that's happening. And there aren't other actors who can influence the ordering of events in the system? Unfortunately, there are. So I think the pistol is different. And primarily, we want to have a language that makes it easy to express these kinds of simple properties, but also just let a market of applications figure it out over time.
00:46:29.142 - 00:46:34.058, Speaker C: They're not going to break any of the impossibility results. But I also think experimentation is good.
00:46:34.144 - 00:46:42.140, Speaker D: The interpretation of this is the second amendment of programming. Like, you have the right to bear arms, including against yourself.
00:46:42.670 - 00:47:18.054, Speaker C: I mean, I do think that there also is the reason, especially that I hesitate to say that you shouldn't do this is that I think sometimes you might want to. You could make a bounty, for example, for computing some kind of solution which doesn't violate an impossibility result, but is just presumed to be very difficult to compute or something like this. Or you can create different kinds of incentives for people to discover certain ways of solving certain subclasses of NP problems more efficiently. So I think that there could be also applications in that area.
00:47:18.252 - 00:47:35.886, Speaker A: Chris, I have a question about the sort of zkps in the system that you've created. Are the zero knowledge proofs here just like a way to make a lot of this private, or are they kind of key to constructing the thing? What kind of parts of the ZK are you using? Basically, yeah.
00:47:35.908 - 00:49:01.270, Speaker C: In the way we use zero knowledge proofs in Arnoma, they certainly do provide privacy. We've also tried to align them with just the separation of computation from verification, so that whether you get privacy is kind of a choice of whether the proof is zero knowledge, and whether you get like succinct compression is a choice of whether the proof is succinct, right. You can kind of separate out these properties in the architecture as they result differently from different properties of the proof scheme. We also care specifically about zero knowledge proofs because we've taken this nullifier commitment to nullifier scheme, originally introduced by Zerocache, and built what we think is an interesting approach to private bridging. In particular, we can use commitments and nullifiers to do a kind of global double spend detection, which is something that IBC doesn't try to do. So we investigated for a while building private bridges on top of IBC, and that turns out to be very difficult, because when IBC sends tokens from one blockchain to another, or some state from one blockchain to another, because it can't reason about the correctness of the state transitions which took place on the other chain, it has to do a kind of supply check at the boundary. So if I'm chain a and you're chain b, and I send you five tokens and you send me six tokens back, I'll say, wait, no, you can't send me six tokens back because I only sent you five tokens in the first place.
00:49:01.270 - 00:49:08.422, Speaker C: That's great, but it requires that you can count the tokens, right? This violates privacy, or privacy is sort of incompatible with this accounting method.
00:49:08.486 - 00:49:17.150, Speaker D: I like to think of this as the border checkpoint of blockchains, where your privacy is always goes to zero. Whenever you leave a nation national border.
00:49:17.810 - 00:49:31.742, Speaker A: In the example you just gave, though, if you're going cross chain, would both chains need to be built in the way that you're building it? Are you picturing kind of like two enomas or two nebadas or something? Like two instances of your system communicating?
00:49:31.886 - 00:49:56.586, Speaker C: Yes, or at least part of it, at least what we call Tyga, which is like the privacy preserving virtual machine. So we do intend for this to be kind of available as separate components. So you could run Tyga as an Ethereum rollup, for example. You could run it in part of a different security zone or as part of a different system and still take advantage of this private bridging function.
00:49:56.688 - 00:50:23.522, Speaker A: Is there a way to implement some of this into like, thinking of the IBC model of putting, I don't know what you call it actually, but like the IBC likeline or some IBC module on a chain that isn't cosmos native, would you be able to do something like that for noma chains or intent centric chains where you'd basically be able to put some module or something on the other chain that can then start talking to it?
00:50:23.576 - 00:51:13.554, Speaker C: Yeah, that's the idea. I mean, the restriction in at least the way we have designed private bridging in the system, is that you can only get private bridging between different instances of the VM. In our case Tyga, you could do something slightly different, which accomplishes the same goal, which understand each other's state system enough to reason about commitments and nullifiers. So the idea with commitments nullifiers is that you represent your state in these zero. Cash calls them notes, but in these atomic units, and that these atomic units are consumed only once, and when you consume them, you reveal the nullifier. So how we plan to implement private bridging in Arnova involves merging nullifier sets. So when you say send a transaction from a to b, you do some stuff on b, then you merge the history back into a.
00:51:13.554 - 00:51:59.026, Speaker C: We can avoid this intermediate border control sort of transparent balance check because we can check the full history privately, but we can check through the zero knowledge proof, the full history of all of those tokens back from all the way when they came from a, and we can check that there are no double spends in that history or no violations of linearity. And that requires standardization of more than what IBC standardizes, right? It requires standardization of this privacy preserving vm layer on top of mean. Tyga is kind of relatively agnostic to the languages in which you write or something. You just need to be able to compile them circuits. So on top of that, you could have other vms or other things going on, but you do need to deal with your state in this way, if that makes sense.
00:51:59.128 - 00:52:45.620, Speaker A: Continuing on that topic of privacy, I actually had a question from before. I think it was like you were speaking about something earlier about kind of hinting at a Dex or a ZK swap. I think when you were talking about that, I started to know like two years ago, Tarun, Guillermo, you guys did a bunch of work, and I think Alex did a bunch of work around these private dexes. And some of the challenges when you get into these intent based systems, is it a completely new landscape where we can start to really think about private swaps in a different way, or are those problems that you had highlighted, and this is also to you to in a little bit, but do they still stand in a system like this? The fact that you'd often have to reveal something in order for a proper marketplace, or at least in the way that we've thought about it in the past?
00:52:46.230 - 00:53:18.426, Speaker C: Yeah, I'm not extensively familiar with that specific paper, but I think in general, intents don't. Intents are a way of designing an architecture and a way of designing, in our case, a virtual machine. They don't break any impossibility, results or whatever. Someone needs to see enough information to combine the intents. Right. So that someone could be like someone inside an SGX, right. Or it could be someone inside fhe, although I still think we're many years away from that.
00:53:18.426 - 00:53:31.822, Speaker C: But some logical party needs to be able to see the intents and see at least the information about what the users want to trade so that they want to trade a for b and b for a in order to match them.
00:53:31.876 - 00:54:21.870, Speaker D: Yeah, I don't think this changes any of that. In some sense, this gets more complicated because it's like non atomic. So you're in fact more likely to have these privacy problems. I think the key thing that people have accepted is that any financial transaction fundamentally has to have some public data, like a price and interest rate, a fee, and some private data, at least like what people expect normally, right? Like people aren't expecting to always be showing that they're making some transaction, and the public data always has some information about the private data. And the key is just like allowing the user to choose how much they make public, and then they get a price based on how much they give publicly. Right. Because obviously if they gave all of their information, you could get the best possible price.
00:54:21.870 - 00:54:45.560, Speaker D: But in reality, it's like the user should be able to decide their trade off between privacy and efficiency. This is, again, why I brought up the efficiency thing earlier. I feel like it is part kind of fundamental to this type of stuff. But I agree, it's not clear how to do it in a way that doesn't just tell people don't make any application.
00:54:46.650 - 00:55:21.220, Speaker C: Right. Well, I think there's privacy and deficiency and security, which is another tricky, like in these cross domain systems where you might have different security assumptions. You also have to trade that sometimes against efficiency. Right. Because you have to agree typically to a set of security assumptions in order to get atomicity. So, yeah, we don't try to answer those questions in the architecture. We try and maybe at least make it clear what the trade offs are and let users, perhaps with the help of developers, pick from them.
00:55:21.220 - 00:56:10.354, Speaker C: I think the privacy efficiency access is also interesting because there's some things that you can kind of get for free. Like you can hide your user account basically without losing any of the properties you might want. But you can't hide. You have to reveal what it is that you have and what it is that you want, in the intent lingo, in order for someone to match that. And then the more, if you have some kind of distributed dark pool of solvers. Let's think of it like that. Like you have a bunch of people with private liquidity who don't post it to a central place, then it's very hard to reason about what kinds of fairness guarantees you can get, right? On the other hand, it seems like many parts of real world systems might be working like this.
00:56:10.354 - 00:56:13.406, Speaker C: So I think it might be. It's an interesting problem to characterize.
00:56:13.598 - 00:56:25.042, Speaker A: I kind of want to redefine efficiency here too, because are you talking about, is this very specific to dex efficiency? Is this like market efficiency?
00:56:25.186 - 00:57:05.254, Speaker D: Yeah, there's two types of efficiency, right? One is just strictly price efficiency. That's more like clearing price. Also very hard to define. You can actually, in some cases show there doesn't exist any market clearing prices, depending on how the market is structured. But there's also just some notion of, like, does there exist in equilibrium, a such that you maximize people's batching and execution? And even if there does exist, one, can you find it quickly, or can anyone find it quickly? And those are like three different. If you made the meme of the person and then the person with the brain, and then that's in that order.
00:57:05.292 - 00:57:05.446, Speaker C: Right?
00:57:05.468 - 00:57:37.040, Speaker D: Like price efficiency is kind of the easiest one, but it's obviously missing a lot of the clearing aspects but then equilibrium existence is easier than equilibrium finding. That's the hardest part, actually. Chris's talk in New York had this example of this fixed point iteration, finding intent. That's exactly the type of thing that you might not be able to find the equilibrium for, depending on. That's why I thought it was a good example, though, of like, it is one of these ones that might just be impossible, right?
00:57:37.890 - 00:58:33.438, Speaker C: Yeah. I mean, one reason I like the concept personally, although I promise after this episode I'll shut up about it, but is that it illuminates a little bit, like, the boundaries of what the systems can actually do. So I think Sam, a friend of mine, Sam Hart, had this great tweet where he's like, the thing about intent systems is that you assume that users know what they. You know, maybe users sometimes don't know exactly what they want. And I think that's probably true, but maybe it provides a helpful way to understand any kind of distributed blockchain system can conceivably do. Right? If you, as a user, don't know what you want, but you commit to some specific preference anyways, then you're definitely going to get something that wasn't what you wanted, because you didn't even say what you wanted in the first place. So I think that illuminating the boundary can be helpful to illustrate what these systems just can't do.
00:58:33.524 - 00:58:56.806, Speaker A: I have, like, a weird idea here, which I don't know if it would fit at all, but as you describe this, I start to think, like, could we somehow, in a system like this, almost have recommendations pop up where you like? Or could you add into an intent system things that people haven't actually asked for, they've left sort of an open blank space that you could then inject something into.
00:58:56.988 - 00:59:47.478, Speaker D: So an interesting IRL example of this is, if you think of food delivery apps, oftentimes they'll send you notifications to be like, hey, we'll give you a 10% discount if you buy from this restaurant right now, because someone is already ordering in the same region or building or whatever. And that actually turns the constraint problem into a better problem sometimes, because it makes their revenue go up even though. But their costs go down on a per unit basis, right, because their costs per unit are a lot lower because I went to the same building, right, but their revenue went up like x percent. A lot of the optimization and marketplace designed for these peer to peer gig economy stuff is exactly doing this. Google flights is also exactly doing this.
00:59:47.564 - 01:00:39.750, Speaker C: Yeah, I just wanted to mention that I actually think a lot of the real world application examples of intent based systems are going to be a little bit more interactive than blockchains are right now. I mean, something like trade token x for token Y and maybe get this specific efficiency guarantee can be made non interactive because the preferences are sufficiently exact. But often in, say, Airbnb, decentralized Airbnb, decentralized Uber, things like this, you kind of want a round of interactivity because you want to see the exact details of the thing before you confirm. So for example, when I book an Airbnb, you could make a non interactive Airbnb where you just specify, I want to go to this city for these dates. I want a place that has these characteristics. Find me one and book it. Don't ask me for any more confirmation.
01:00:39.750 - 01:01:26.454, Speaker C: And Airbnb doesn't do that, right. And I think the reason is that people typically have these sort of approximate preferences and then they want to look at the actual options. They want to look at the pictures of the place and see, oh, it looks nice, or oh, that looks like the room is too small, stuff like this. And I think that not with kind of tokens or very clean abstract sort of objects on blockchains where the things are fungible or you don't really care about the specific properties, you don't need this kind of interactivity. But with trips and an Uber where you want to see how long the ride is as a driver before you confirm, or with Airbnbs where you want to see the exact details of the place, I suspect that you'll have multiple rounds of interaction built into the system.
01:01:26.652 - 01:02:21.510, Speaker D: Yeah. I mean, another way of thinking about it is if you think of it more as like a two sided iterative game of like I place an intent that causes someone to have to try to service it, which causes me to change my intent, it's like, hey, I want to go on a trip to Europe. And then the reply you get is like, here are the five places that are cheapest from your city. And then you're like, okay, I'm going to choose this subset, okay? And then they're like, okay, here's the path, here's your itinerary, right? And you have this thing where the user gives some very coarse thing, the searcher gives something finer. But it's sort of a way of making, in theory at least, Mev work for the user rather than against the user, right? And in some sense that does seem to be the long term vision. I maybe as a curmudgeonly theory lover, just like always, like I look at the formulations of these things. I'm like, everything is like impossible.
01:02:21.510 - 01:02:30.302, Speaker D: It's sort of like one of them. But I definitely get the idea. It clearly is a thing people would like.
01:02:30.356 - 01:02:30.574, Speaker C: Right?
01:02:30.612 - 01:02:39.680, Speaker D: They don't want to think about swapping. They don't want to think about signing 500 openc transactions, right?
01:02:40.450 - 01:02:58.680, Speaker C: Well, no, I think people should be very skeptical of intent systems. And sometimes I see comments where I think people, maybe people take intents to be magical or something like this. I'll just say, give me more money and the system will do it. Right. And that's not going to happen.
01:03:01.050 - 01:03:17.542, Speaker D: Yeah. The ones where people are like, oh, I'll just ask it to make me money. In the stock market, there is clearly some. It needs to be. This is why I said efficiency has to include ability to find an equilibrium, not just exist in equilibrium. That's kind of like the holy grail.
01:03:17.686 - 01:03:25.114, Speaker A: Truan, you just said something about MeV, and I don't think we've really talked about do intense and MeV have any sort of crossover.
01:03:25.242 - 01:04:14.940, Speaker D: Yeah. One simple way of viewing it is like MeV is user says a very precise transaction. Then the MeV searcher is like, hey, I'm going to optimize that and optimize my profit. Now imagine if there was something where the user said, hey, here's my transaction. You can service it, but only up to some threshold, right? An argument is like in uniswap, the slippage limits are like that, right? If I slip the perfect slippage limit, the searcher can't really sandwich attack me or do much. But because I can't figure out what the optimal slippage limit is, someone can kind of front run me. Now, in a world where you can have these verifiable commitments, you could say like, hey, if you're going to use my transaction, you have to prove to the blockchain that you didn't make the slippage more than x.
01:04:14.940 - 01:04:23.742, Speaker D: It's not just like, hey, I said it. It's like anything action you do to include my transaction has some covenants or constraints on it.
01:04:23.796 - 01:04:26.686, Speaker A: But was that described in the intent itself?
01:04:26.868 - 01:05:15.582, Speaker D: That is sort of the intent. Like, I don't want to lose more than x dollars, right? Or like I don't want to be more than x dollars off the previous price in the bot, right? And that's sort of this approximate thing. It's not exactly saying the transaction, but saying some rough version of it because it relies on the other party, sort of the searchers, kind of like optimizing that overall the order flow. And so the idea is you're encouraging people to instead strictly profit, to profit under some constraints, right? Like you're fine with them making some profit provided they meet your constraints and hopefully there's enough volume and aggregation effect that they can actually do that. Chris, am I missing anything? In my mind it's just like Mev working for like instead of the other way, right?
01:05:15.716 - 01:06:07.886, Speaker C: No, I think that's exactly can another way to think about it, maybe, is that there's a spectrum from being kind of very loose about what constraints you impose upon operators, solvers, validators, the other parties processing the intent to very specific. And you can be specific about different things. Like one way of understanding an ethereum transaction is that it's an intent that says that it must be globally ordered with respect to all the other transactions in a block. So in a sense it's actually too specific. Like you're paying for this property, global ordering, that most of the time you probably don't care about, right? Like most if you're doing a trade, you don't care about ordering with respect, maybe to other assets. If you're doing a purchase of an like you don't care about ordering with respect to someone else who purchased a different NFT. But the know, understanding a transaction is a special case of an intent.
01:06:07.886 - 01:07:02.018, Speaker C: The property that the transaction is enforcing and that you're just like paying very dearly to have enforced for you is this global ordering. So in that case, you maybe want to be less specific, like you actually don't care about some of those orderings, but you might want to be more specific about what kinds of slippage bounds. Anyone who includes and builds upon matches your intent has to respect, or how your intent is processed with respect to other intents in a batch, stuff like this. So just kind of getting to more precise specifications for if we think like there's some kind of delegated agency going on, right? As a user, you have an intent and you want the operators doing things in the system, validating, solving, relaying messages on the peer to peer network, et cetera. You want them to do things which kind of like respect your intent, and you can use various kinds of commitment devices to kind of bind them to doing that in different ways.
01:07:02.184 - 01:07:30.514, Speaker A: I actually have one last question, which is about sort of the state of intense architectures, and obviously I think we can talk specifically about yours. But is it a finished idea? Is it mapped out through and through, or do you feel like this is still like parts of it are understood and you've built those parts, but you're going to kind of need some sort of, like, market testing to figure out how to do the other parts. Or is it a complete architecture?
01:07:30.662 - 01:08:49.366, Speaker C: Yeah, I mean, I think there are parts that are sort of clearly generalizable and protocolizable, and parts that are more application specific. So, like the gossip network and consensus and private state transitions, stuff like this you can do in a general way, at least specific to certain classes of applications. Applications using single user private state or multi user private state in different ways just require specific configurations of cryptographic primitives, regardless of what the exact computations they're performing are. But then also, to Turin's point, different solvers, especially solvers where you want to, or classes of intents where you want to reason about concrete efficiency of the solving algorithms, require different specific solvers. The general version of this is something like z three or whatever, but it's not going to be particularly efficient for many of the cases that you might care about. So that will require some more market discovery and testing. I mean, I think a fair amount of this you could understand as already existing in, like, Ethereum, Mev solvers, which have gotten to do pretty general and impressive things, flash loans, like doing a bunch of state space execution, searching cowswap solvers, stuff like that.
01:08:49.366 - 01:08:54.326, Speaker C: So many of those techniques, I think, will kind of port over already, or so to speak.
01:08:54.428 - 01:09:00.454, Speaker A: Interesting. Do you think it'll be the helix team building this, or do you actually see this being more of a community effort?
01:09:00.582 - 01:09:20.654, Speaker C: I really see this as being a community effort. I don't think that we could build all of the solvers or applications, and we certainly don't want to. We also want to make things interoperable with ethereum and cosmos assets and existing change and valid chains and validator sets as much as possible, yeah.
01:09:20.692 - 01:09:27.774, Speaker D: So, I mean, let's say it's been, I don't know how many years since Wyvern. 2018. Five years. Or was it 2019?
01:09:27.822 - 01:09:29.154, Speaker C: Five years. Five, you said. It's right.
01:09:29.192 - 01:10:23.826, Speaker D: Okay, five years since it came out. Now there's kind of in 2023, been this flurry of, like, it became a meme. People were, like, starting companies and projects based on the name. How does it feel personally to be kind of in the limelight from this? Obviously, limelight in a very tiny demographic of people who pay attention to this, don't get me wrong, but it's still in the limelight. Does it feel like sort of imitation is the best form of flattery? Do you feel like it's cool that people are finally realizing this because I feel like it wasn't very popular last year, I think in the world where people were like, oh, we're just going to have. People were losing faith, I guess, in the app chain roll up, because those two thesis are basically the same nowadays. People were way more in the monolithic world, I would say last year.
01:10:23.826 - 01:10:34.360, Speaker D: And then it kind of flipped. And when it flipped people like, oh shit, we need this. So, yeah, how do you feel kind of about that and kind of the increase in interest in this?
01:10:34.970 - 01:11:21.174, Speaker C: That's a good question. I just feel like I'm now under a lot of pressure, like really good pressure from people such as you, Tarun, to write down some math so that my declarations about intents don't seem quite so philosophical and could be concretely falsified. So that part is nice. I think maybe an interesting question for me is I think people sometimes view what the blockchain space is doing in different ways. I think some people view the blockchain space as kind of like startup land, where you sort of experiment with a lot of different ideas and what works is kind of a complex function of market conditions and how things are explained. And there's not like any clear convergence. Right.
01:11:21.174 - 01:12:26.906, Speaker C: But I think personally I understand the ecosystem as more of like a distributed research field. It's not quite so unified as like subfields in academia, and it's more oriented around synthesis of many things which already exist. But I think it's very cool that I come at intense from this thinking about language and philosophy and coordination problems angle, not from the bottom up Mev angle, but the bottom up mev angle, sort of reflecting on these actual protocols which are already deployed in the world seems to point to the same general direction. So it's a very cool, for me, it's a very cool convergence of these two ways of approaching the design questions in blockchain systems. The sort of like what are coordination systems doing? Perspective and this like, well, how do these actual systems evolve according to how users actually use them? Perspective kind of seem to point towards the know at least like many different angles to a similar concept. And I think that that's cool. I mean, I think it's helpful to Uma from succinct put it.
01:12:26.906 - 01:12:56.546, Speaker C: I think at research day, intents have gotten people who think about user experience and people who think about abstract system architecture problems to talk to each other, and that these two people weren't previously like these groups of people weren't talking to each other. And I think that kind of unification of different aspects of the discourse. Realizing that they were kind of viewing the same problem through different lenses and maybe they can now collaborate is really cool and could lead some good outcomes for users.
01:12:56.658 - 01:13:03.970, Speaker A: Nice. Chris, thank you so much for coming on the show and sharing with us your sort of the history of intents.
01:13:04.050 - 01:13:05.778, Speaker D: You mean his intensity?
01:13:05.954 - 01:13:32.960, Speaker A: His intensity about intents. Oh, dear. But, yeah, no, thanks so much for sharing with us. And this is very helpful to give context to these ideas, because I've known about the Noma project since its inception, but this idea of intense, even though I think we've even had it in ads on this show, I wasn't always clear on where this is coming from or what exactly you mean by that. And this has been really helpful to understand that.
01:13:33.270 - 01:13:57.254, Speaker C: Thank you. I hope it was interesting. And, yeah, Tarun, we, you know, speaking here at Sonoma, we definitely owe you some good mathematical characterizations of some of these problems. So hopefully hoping that we can provide those and answer some of the very good questions around, like, what are the bounds for different efficiency classes of intent centric applications? I think that's a good one.
01:13:57.372 - 01:14:30.078, Speaker D: Yeah, for sure. I still think it is the right mental model, though, because I think it does get at this. All the marketplaces that exist that people have apps for do kind of do this right. Like, you're never really saying a precise thing. You just get matched to something. And I think, inevitably, any way of describing that makes sense. It's just more a question of, yeah, what does this look like in ten years? And it does feel like there is some actual new research to come out of that.
01:14:30.078 - 01:14:31.822, Speaker D: So looking forward to it.
01:14:31.876 - 01:14:32.334, Speaker C: Cool.
01:14:32.452 - 01:14:33.758, Speaker A: All right, thanks again.
01:14:33.844 - 01:14:34.526, Speaker C: Thank you.
01:14:34.628 - 01:14:41.970, Speaker A: And I want to say thank you to the podcast team, Rachel, Henrik, Tanya, and Jonas, who edited this episode, and to our listeners, thanks for listening.
