00:00:05.450 - 00:00:53.882, Speaker A: Welcome to Zero Knowledge. I'm your host, Anna Rose. In this podcast, we will be exploring the latest in zero knowledge research and the decentralized web, as well as new paradigms that promise to change the way we interact and transact online. This week I chat with Ravital Solomon, the founder of Sunscreen. We chat about her interest in Latice based cryptography, how this led to her work on FHE, first at Newsypher and then with her own company, Sunscreen. We explore the challenges of building with fhe the power in the combination of ZKPs and FHE, as well as the early emergence of lattice based seronage proofs. Now, before we kick off the episode, I do want to direct you to the ZK Jobs board.
00:00:53.882 - 00:01:11.170, Speaker A: There you can find jobs from top teams working in ZK. So if you're looking for your next job opportunity, be sure to check it out. And if you're a team looking to find great talent, feel free to add your job to the jobs board as well. I've added the link in the show notes. Now Tanya will share a little bit about this week's sponsor.
00:01:12.470 - 00:01:46.558, Speaker B: Polygon ZKE EVM is here. This performant ZK powered open source EVM equivalent roll up launched its mainnet beta last month. Polygon ZKE EVM is making scaling truly frictionless fast finality and EVM equivalents means devs can do everything they can do with the EVM, only cheaper. But a network that really wants to extend Ethereum's block space needs Ethereum's infrastructure. This infra needed to port, build and deploy on ZKe EVM. Oracle's RPC nodes, APIs and tooling are already on board. Two years ago, Polygon Labs bet big on zk technology.
00:01:46.558 - 00:02:04.370, Speaker B: Collaboration among Polygon ZK teams and a build in public ethos has resulted in a big leap forward. Together, Ethereum users will discover what ZK can do to connect to Polygon. Zke EVM visit polygon technology. So thanks again, Polygon. And now here's our episode.
00:02:07.750 - 00:02:14.450, Speaker A: Today I'm here with Ravitel Solomon, the founder of Sunscreen. Welcome to the show, Ravitel thank you, Anna.
00:02:14.530 - 00:02:15.766, Speaker C: I'm glad to be here.
00:02:15.868 - 00:02:36.682, Speaker A: So today we're going to be diving back into the topic of fhe fully homomorphic encryption. But before we do that, let's learn a little bit about you. And also, I just want to sort of figure out when exactly did we first meet? So I know you were a speaker at ZK Summit four and zk summit six online, but yeah, was zk summit.
00:02:36.746 - 00:02:49.022, Speaker C: Four, the first time we met, I don't think so. So I had just joined news Cipher and I had gone to zk summit three, but it was, I believe, tuck speaking, so I was just in attendance.
00:02:49.166 - 00:02:59.558, Speaker A: Cool, cool. So, yeah, maybe start from you joining new Cipher. I want to hear a little bit about your story here. What were you studying before? What were you working on there?
00:02:59.724 - 00:03:37.170, Speaker C: Yeah, so I think my story when it comes to cryptography, starts a lot earlier than new cipher. So I went for my undergrad, I did it in math. I took my first cryptography course as a junior at Berkeley, and I heard about this new emerging area of cryptography called lattice cryptography. It wasn't very popular at the time. There were no courses about it at either the undergrad or graduate level. So I tracked down this math professor and I was like, I really want to learn more about lattice cryptography, I really want to work in this area. So he agreed to work with me and start learning about lattices.
00:03:37.170 - 00:04:16.282, Speaker C: That really started my journey in cryptography and I really loved it and wanted to continue, I assumed, to pursue cryptography, you really had to be an academic. So, oh my gosh, I have to get a PhD. The only way I'm going to get to do this is being a professor. But for reference, both of my parents are academics, or ex academics. They didn't have a lot of good things to say about academia. Yeah. So I was like, well, what should, should I, should I go get a, like, should I see if I even research? So I found a more research based master's program and that was in the UK.
00:04:16.282 - 00:04:53.658, Speaker C: I went there, I did more stuff in lattice cryptography. I did latice based group signatures, and I confirmed that I absolutely loved lattice cryptography. I absolutely loved research, but I hated academia. So I was looking around at the time and I was like, well, I really want to do lattice cryptography, but how am I going to do this? Is anyone going to pay me to work on this area? And I was super open minded. I was like, anything to do with lattice cryptography, I am open to. And I was lucky to stumble across newsypher on hacker News since they're a YC company and they were hiring at the time. So I reached out to them.
00:04:53.658 - 00:05:01.118, Speaker C: The first person I remember meeting was tux there. And that's how I really started in the blockchain and web3 space.
00:05:01.284 - 00:05:10.426, Speaker A: Cool. It's interesting you talk about lattice cryptography, maybe, can you define what that is? And is that the basis of fhe?
00:05:10.538 - 00:05:53.440, Speaker C: So you can think of Latice cryptography as a generalization of some of the math you've done in probably middle school or high school. When you're graphing points on some planes, you think of like an X and Y axis. They're both on the real line. Lattices can be thought of as some sort of subset of these points in the space. So instead of taking arbitrary kind of decimal points, like you can think for the x and y coordinate, maybe you have 1.1, you have 2.1. We're going to restrict it, in the simplest case to just integer points so you can think of it as some sort of discrete space sitting inside some kind of real space.
00:05:56.290 - 00:06:08.258, Speaker A: That's tricky. It's hard to follow. But what general area is lattice cryptography? Is it close to elliptic curve cryptography? Is it a totally different world?
00:06:08.424 - 00:06:45.082, Speaker C: Yeah. So lattice cryptography is totally different from the other areas of cryptography. What differentiates lattice cryptography from elliptic curve based cryptography is that it's post quantum, so it's secure against attacks from a quantum computer. And I would say if you want to think about what area of math lattice cryptography falls under, it probably can be thought of as linear algebra on steroids. So instead of thinking about linear algebra and like matrices and vectors with numbers, you're instead thinking about polynomials.
00:06:45.146 - 00:06:52.138, Speaker A: Oh, cool. So you're saying this is the sort of basis, like fhe, is built around lattice cryptography?
00:06:52.234 - 00:06:52.734, Speaker C: Yes.
00:06:52.852 - 00:07:03.586, Speaker A: Is there other types of math in FHe that one should also be aware of? Or if you have a good understanding of lattice, can you like lattice cryptography? Can you do a lot?
00:07:03.688 - 00:07:17.142, Speaker C: If you have a good understanding of lattices, you can do fhe. For whatever reason. The only known Fhe schemes are based on lattice cryptography. No one has been able to successfully construct an FHE scheme using other types of cryptography yet.
00:07:17.276 - 00:07:25.946, Speaker A: Cool. All right, so you were at Newsypher. Tell me a little bit about what kind of work you were doing there. What projects were you getting into?
00:07:26.128 - 00:08:11.958, Speaker C: Yeah, so I joined the company to really explore if fully homomorphic encryption could make sense for solving some of the privacy problems in web3. It wasn't directly related to new cipher's main work, but the founders were super interested in seeing how fully homomorphic encryption could fit into the web3 space. I have to say, when I joined ucipher, I was not very optimistic about latice cryptography making any sense for web3 in general. It has a pretty negative perception when it comes to efficiency. But I was surprised to see, in terms of the existing privacy solutions in the web3 space, fhe could actually be quite performant and could make sense for quite a few applications.
00:08:12.134 - 00:08:44.174, Speaker A: Were you also watching how quickly it's almost like these cryptographic concepts had been around for a long time. You had seen the progress go in that sort of academic way, slow and sure, but maybe a little bit niche. Once you started to connect it to these highly incentivized networks and throw a lot of funding at it, it started to obviously accelerate really quickly. Did that give you hope, too? Were you kind of like, maybe we don't have to worry about some of these inefficiencies because it could actually be accelerated faster?
00:08:44.302 - 00:09:12.522, Speaker C: No. So I am naturally a super pessimistic person, and I hate this idea. I hate the idea of relying on somebody else to build hardware accelerators to solve my problems. To me, it was like, is there an fhe scheme that makes sense right now as is to solve some of the problems in the space? I am biased. I obviously think the answer is yes, but no. I wasn't looking with optimism or hope towards people building accelerators.
00:09:12.586 - 00:09:43.894, Speaker A: Okay. But when I say acceleration, I don't actually mean hardware acceleration. I mean, just like the acceleration of research and technology. Even in your experience, you've now been in this. I mean, if you're saying you were at CK summit three, that was in 2019, I think, and you were definitely at CK summit four. So, yeah, in that time, you've seen a lot of the proving systems be kind of optimized and become faster and smaller and quicker. All these things have happened.
00:09:43.894 - 00:09:51.402, Speaker A: Do you feel like in that time, have you seen fhe also, or did you see similar growth on the fhe side?
00:09:51.536 - 00:10:24.242, Speaker C: Absolutely not. So definitely not. When it comes to theory improvements, I was really hopeful. I had the same kind of expectation when I was thinking about fhe and compatibility with zero knowledge proofs. Certainly in this long, long time frame, there will be a better zero knowledge proof system that's compatible with FHe. There's so many people working on this, but the answer is there weren't many improvements, and fhe has a lot fewer people working in it than I think, zero knowledge proof. So it's just been a slower time.
00:10:24.242 - 00:10:36.502, Speaker C: We haven't been here as long fhe has been here. I think since 20090, knowledge proofs have had a huge head start. They're from the late 80s, so it'll take us a little bit of time to catch up.
00:10:36.556 - 00:10:49.146, Speaker A: But when you say this, it also makes me think that this is actually a really interesting time to start looking at fHe. So it's a bit behind on the ZKP front, but it seems like there's a lot of space for improvement. Definitely.
00:10:49.248 - 00:11:11.298, Speaker C: So that's why I'm really excited to work in the space. I think this is the really early stages of fhe when it comes to usability and applications. And if you're working in the space right now, you get to really define what the future of fhe will look like versus, I think, zero knowledge proofs. Some people have already defined what that landscape is going to look like.
00:11:11.384 - 00:11:24.886, Speaker A: Cool. All right, so you were working at New Cipher, you were working on this cool thing that would maybe, or maybe not sort of fit into the company's mission, but then you've spun out to create Sunscreen. Tell us a little bit about that.
00:11:24.988 - 00:11:58.642, Speaker C: Yeah, so at some point, it became clear that to really pursue this mission of bringing fully homomorphic encryption to web3, a lot of resources were needed and quite a bit of work needed to happen. And did it make sense for the new cipher team to really pivot from whatever they were working on to working on this brand new? Maybe not. But McLean and Michael were super encouraging of me, kind of going off starting my own venture, finding people to work on these problems. So that's exactly what happened.
00:11:58.776 - 00:12:02.610, Speaker A: Cool. So today, tell us a little bit about what sunscreen is actually building.
00:12:02.760 - 00:12:17.394, Speaker C: Yeah, so Sunscreen's mission is to bring advanced privacy technology to web3 engineers, and we're working on SDK that packages together fully homomorphic encryption and zero knowledge proofs to make privacy accessible to developers.
00:12:17.522 - 00:12:42.926, Speaker A: I did an episode with the CEO of Xama, and we talked a little bit about some of the ideas that they had around, you know, putting computation into this private space. Like what. What is actually. What kind of fhe are you talking about? Like, what would somebody use that space for? Is it almost like this enclave that's like totally cryptographic, where you can do private computation? Or are you thinking about it in a different way?
00:12:43.108 - 00:13:21.130, Speaker C: There's quite a few applications of Fhe, and it depends how you imagine fhe fitting into web3. So one thing a lot of people are interested in is private smart contracts. So the idea that we can do computation directly on encrypted data. In this case, the workflow would roughly look like the following. The user encrypts their data using an FHe scheme. They produce some zero knowledge proofs, verifying conditions on their encrypted data. Then the validators of the system, they check the proofs, and they use the homomorphic properties of the FHE scheme to perform the computation on the user's encrypted data and update the state.
00:13:21.130 - 00:14:06.700, Speaker C: But there are other applications of fhe we've seen quite a bit of interest in in the last few months, and some of those have to do with addressing MEV issues that use case. It's not quite as clear if you need zero knowledge proofs for it, but roughly speaking, you can think of wanting to perform some sort of sealed bid auction, and you would need to combine fhe with some other tools. You'd be looking at maybe threshold fhe, where you can imagine the trust is distributed between a few different parties and they would come together to decrypt things. And you'd run an auction, you'd order a bunch of bids and you'd only reveal the winning bid. That may or may not need zero knowledge proofs. It's not quite as clear.
00:14:07.470 - 00:14:12.286, Speaker A: You just said threshold. Is it threshold fhe or threshold he?
00:14:12.468 - 00:14:38.262, Speaker C: In this case we'd be looking at threshold fhe. Threshold he is something a little bit different. So when you talk about homomorphic encryption, it may only support one type of operation on encrypted data. So maybe you could add encrypted data together or multiply encrypted data together, but you definitely can't do both. When you talk about threshold fhe, you want to be able to do both types of computations on encrypted data.
00:14:38.396 - 00:14:45.000, Speaker A: And when you talk about threshold fhe though, what's the fully, what does that actually stand for in this?
00:14:45.370 - 00:15:23.170, Speaker C: The fully part still kind of is attached to the homomorphic encryption part. So you can imagine there's fhe and there's like this new word that goes in front of it that says threshold. And the reason you'd want that is that for some of these use cases with people thinking about auctions, you don't want to entrust one party with all of the data. So in some sense you can ensure that if we run this auction and we have a bunch of different bids, some parties have to come together to only decrypt the first bid. Otherwise we might be trusting one party to potentially not decrypt everyone's bids.
00:15:23.670 - 00:15:34.294, Speaker A: Tell me a little bit more about the exact use case then of sunscreen. What are you guys doing? Is there some sort of use case that you're very focused on?
00:15:34.412 - 00:16:39.386, Speaker C: Yeah, so right now we're exploring, I would say, three major use cases. We really view ourselves as building privacy tools for other protocols and other people, rather than like we are going to go out there and necessarily solve all of these problems as a company. For the three major applications, we're very interested in private smart contracts that we've already spoken a little bit about. For the second use case, we're interested in doing some sort of sealed bid auction using a variant of fully homomorphic encryption called threshold fully homomorphic encryption. The idea with threshold fully homomorphic encryption is that you're going to take your keys and you're essentially going to break them up into little pieces that you're going to distribute out to a number of different parties. So encryption still works the same. You take, like, the public key, you encrypt it with respect to the key, but decryption works a little bit differently where these different parties now have to come together, have some sort of interaction in some sense, to decrypt whatever the encrypted data is.
00:16:39.386 - 00:16:44.702, Speaker C: So you can imagine it's useful when you don't want to entrust one party with all of your data.
00:16:44.836 - 00:16:53.486, Speaker A: There's two other acronyms that came to my mind. As you described it. One was like a DKG and an MPC. Is either of these related to what you just said?
00:16:53.588 - 00:17:05.498, Speaker C: Yeah, I would say they're pretty similar. You are kind of breaking up the keys and sharing it many times. This version of FHE, which is sometimes also referred to as multiparty fHe.
00:17:05.614 - 00:17:06.774, Speaker A: Okay, there we go.
00:17:06.892 - 00:17:10.118, Speaker C: Multi party computation. So you're correct.
00:17:10.284 - 00:17:23.062, Speaker A: All right, is it a hybrid then? Is it sort of using similar ideas, or is it just actually just providing the same benefits, but it's completely different under the hood?
00:17:23.126 - 00:17:41.342, Speaker C: Maybe it's using some of the same ideas from the other spaces. So you want to distribute trust, you want to have parties interact to do a computation, but you still want the homomorphic properties of that encryption scheme. You still want somebody else able to perform computation on some kind of encrypted data.
00:17:41.476 - 00:17:47.246, Speaker A: Got it. What's the third use case so far? You said private smart contracts and auctions.
00:17:47.358 - 00:18:05.858, Speaker C: Yes. So there's a closely related one to auctions, and we've seen quite a bit of interest in people building dark pools. So the idea here is, can we match, we'll say, orders together in some sort of place that is not open to the regular market. Using fHe.
00:18:05.954 - 00:18:18.058, Speaker A: When you gave the talk at CK summit six, this was online, you talked a lot about the MEV use case. Does that have something to do with the auctions you just described, or is that actually a different construction? Completely.
00:18:18.224 - 00:19:07.046, Speaker C: It is completely different. So for my previous talk at one of those ZK summits it was really this idea that we want to protect users against front running. And specifically, we're interested in protecting users against sandwich attacks. So for a lot of these attacks on amms, it had to do with the fact that you could see the user's orders. So the idea here was, could we use fhe to hide the user's orders and protect them against front running and sandwich attacks? The use case with the auctions is a little bit different. So here we're interested in essentially bidding for block space. So helping searchers bid for block space, how might they do that? Maybe they want to participate in some sealed bid auction, and the winner of that auction, it will be prioritized in terms of the block.
00:19:07.046 - 00:19:42.834, Speaker C: Maybe a way of doing that is using fhe for this auction. So everybody encrypts their bid with respect to some threshold fhe scheme. We order all the bids and we only open up the revealing bid. So you can imagine then that everyone else's bids are still hidden. You really can't correlate their behavior from auction to auction. So maybe, for example, we know Anna always gives really bad bids, so we're not even going to bother with hers. Threshold fhe, we would never reveal the losing bid.
00:19:42.834 - 00:19:50.866, Speaker C: So there wouldn't be some sort of linking or tracking of your behavior across auctions. We wouldn't have like, a profile of how you behave.
00:19:51.058 - 00:20:21.074, Speaker A: It's interesting. I actually just did an episode which I think is going to come out just before this one on auctions. So we have a whole episode where we talk all about auctions. I don't know that we talked about an fhe case, though. We did have some ZK ideas around auctions that were floated, but this is kind of new to me. I want to just go like, one step back to the MeV case. And I know this is not a use case that sunscreen's focused on, but you had presented this sort of fhe approach, and I'm realizing this.
00:20:21.074 - 00:20:35.958, Speaker A: I think that was the first time that I heard that problem space being solved with something like fhe. More recently, what I've heard more about is stuff like threshold decryption as a solution, which is a different technique. I guess they're unrelated, right?
00:20:36.044 - 00:20:36.886, Speaker C: They are similar.
00:20:36.988 - 00:20:38.498, Speaker A: Oh, they're similar. Okay.
00:20:38.604 - 00:20:51.514, Speaker C: Yeah. So you can think of threshold encryption as like, a weaker form, or maybe alternatively, threshold fhe is an extension of threshold encryption where you can now do computation on encrypted data as well.
00:20:51.552 - 00:21:07.358, Speaker A: Okay, so it is actually related, but would you say what you had actually presented then? Was it more of an intense, full fledged version? And now you don't need such crazy privacy so you can actually allow for a simpler construction?
00:21:07.454 - 00:21:07.954, Speaker C: No.
00:21:08.072 - 00:21:08.546, Speaker A: Okay.
00:21:08.648 - 00:21:39.702, Speaker C: So I would say with threshold fhe, it's for solving some very different problem. In the MEV space. This is more about searchers kind of bidding for block space, whereas when I was talking about just fhe more generally in that previous CK summit, it was for protecting so very different kind of use cases and applications meant for different people in the space. One is for searchers, one is for end users who just want to exchange some token.
00:21:39.846 - 00:21:58.770, Speaker A: Okay, how developed are these tools at this point? If there was a developer out there listening and they wanted to actually use some of this fhe stuff, how in the weeds do you have to be? Is there anything that's kind of like, are there any libraries that somebody could already try using? Or would you say we're still a ways off from that?
00:21:58.840 - 00:22:20.274, Speaker C: We're still quite a ways off. So I wouldn't say that it's easy for most developers to use fhe in any web3 application. There are a lot of challenges with FHe performance. You need to be, I would say, some kind of cryptography expert to set up an FHE scheme correctly. Not so much for security, almost entirely to get decent performance.
00:22:20.402 - 00:22:20.754, Speaker A: Okay.
00:22:20.812 - 00:23:00.230, Speaker C: The other issue is that for most applications in web3, you can imagine that if you encrypt data, you're not really sure ahead of time of how many computations you might want to do on that encrypted data. And that makes selecting parameters really difficult, if not impossible in many situations. The other issue is that to really make use of encrypted data in web3, since we're working in a trustless setting, we need to verify conditions on our fhe encrypted data. And it turns out that that is very, very difficult and generally very inefficient with the current zero knowledge proofs available.
00:23:00.380 - 00:23:03.458, Speaker A: What do you mean by that? Checking conditions?
00:23:03.634 - 00:23:46.230, Speaker C: Yeah, so let's imagine that you're feeding encrypted data into an application. I'm feeding encrypted data into an application. We don't trust each other and we don't trust anyone else in the space. How can anyone else verify that your encrypted data meets the conditions of that application? Let's say, for example, that maybe this application requires your account balance to be above a certain value. If your account balance is encrypted and only you have the key, how can the rest of us verify if that condition is met, we can't. So zero knowledge proofs need to come into play here. That way you'd be able to prove to the rest of us that your account balance is above a certain value, without revealing what exactly your account balance is.
00:23:46.230 - 00:24:08.390, Speaker C: The challenge here is that fhe uses something called lattice based cryptography, while the most efficient zero knowledge proof constructions definitely don't use lattices. So how do you combine these two and get good performance? That is actually a really hard problem, and much more difficult than making fhe usable.
00:24:08.550 - 00:24:28.818, Speaker A: Why are they hard to combine? Are you trying to put a ZKP into fhe, or vice versa? I'm kind of trying to understand, what's the interaction point between these two things. What it sounds like is you're creating a proof on one side, and then you're just like, adding it to encrypted data. Why is that hard?
00:24:28.984 - 00:25:24.658, Speaker C: Yeah, so there's a number of conditions you're likely going to want to prove about your fhe encrypted data. If we're thinking about just private transactions and we're working in the account model, maybe some conditions you want to prove is that the amount you're sending to somebody is positive you're not trying to deduct money off of someone else's account. You might want to prove stuff like you have enough balance in your account to make this transaction. Those are pretty cheap and pretty easy to prove with general ZK snarks. The difficulty here is about proving that you have a well formed ciphertext, so you're not just giving somebody garbage, because we need to prove something about lattices. If we try to turn it into a circuit using many of the current VK snarks, you end up with things with millions and millions of gates. So the performance is really bad.
00:25:24.658 - 00:25:41.420, Speaker C: You need either a Latice based proof system, which will allow you to more efficiently prove things about lattices, or you need to find some sort of clever hack of how might you connect a Latice encryption scheme with some non lattice based proof system?
00:25:42.270 - 00:25:57.120, Speaker A: In the work that you're doing, do you have to actually also think about, or even experiment with building ZKPs differently, or are you just like, that's how ZKPs are, we're only going to figure out how to work with them?
00:25:58.210 - 00:26:22.854, Speaker C: It's a little bit of both. So we had to investigate quite a bit into zero knowledge proof systems, both what's used currently in the web3 space, and then also what's being done in academia, also on the lattice based side. So, yeah, I would say that we're doing both research and we're also trying to make use of existing zero knowledge proof systems where we can.
00:26:22.972 - 00:26:30.490, Speaker A: Is there work being done for like, maybe? This is going to sound totally insane, but like lattice based ZKPs? Is that a possibility?
00:26:31.070 - 00:27:05.298, Speaker C: Yeah, so there's actually quite a bit of work in lattice based ZKPs, especially on the academic side. The challenge with lattice based zero knowledge proofs is that while prover time and verifier time might be really fast, the proof sizes are terrible. They're definitely not acceptable for web3. So when I say not acceptable, we're often talking for this kind of use case, megabytes in size for proofs. So it doesn't seem feasible right now to use a Latice based proof system in the web3 space.
00:27:05.464 - 00:27:15.506, Speaker A: Is there any work on then using recursion to try to compress that down? Do you need the output to still be like lattice friendly somehow?
00:27:15.618 - 00:27:40.170, Speaker C: Yeah, I would say so. So some of the more modern lattice based proof systems do make use of recursion, like you're saying. But the challenge here is, it's not quite clear what the prover and verifier time will be like when you start introducing recursion into these proof systems. And the current works are super academic, there are no implementations of any kind, so it's very difficult to get a sense of performance.
00:27:40.250 - 00:28:10.780, Speaker A: Got it. I'm trying to also understand if when you describe the need for a latice based ZKP, does using lattice cryptography under the hood, does it fundamentally change how a verifier is working? I'm trying to sort of picture what the difference would be, and if you need sort of a different kind of output. So you could never use some of the techniques that have been used in existing snarks, because it's so very different.
00:28:11.550 - 00:28:49.362, Speaker C: No, so I would just kind of like off kind of whatever we're saying, they have made use of a lot of the techniques from snarks in lattice based proofs. What we've kind of figured out in terms of what we're working on, is that it almost certainly doesn't make sense to use a Latice based proof system. There is this actually very strange, ugly proof system that turns a Latice space relation into something with elliptic curves. And that really allows you to get better performance than working with regular ZK snark and better proof sizes than using something lattice based, because there's no way anyone's okay with megabyte proof sizes.
00:28:49.426 - 00:28:59.800, Speaker A: Okay so that's basically the direction that you've chosen. Then is it compiling or is it transforming? How does that connection happen?
00:29:00.170 - 00:29:23.678, Speaker C: Yeah, so there is a transformation. You're taking a Latice based relation, which you can think of as some sort of matrix vector equation, and then it's transforming it into a Pederson commitment and doing something that looks a lot like bulletproofs with that commitment. And that allows you to get pretty decent performance and much better proof sizes than working with a Latice based proof system.
00:29:23.844 - 00:29:28.162, Speaker A: Interesting. Is that like the kind of systems that you're then building?
00:29:28.296 - 00:29:44.534, Speaker C: Yeah, that is what we're currently looking at, because we think it offers the best trade offs with regards to proof time and proof size. But maybe in the future there would be like a better lattice based proof system, in which case we'd be happy to move to that.
00:29:44.652 - 00:30:06.842, Speaker A: But in that case, if you're just kind of compiling to make it ZKP friendly, would you say then are there ZKPs that are still better to use for this? Do you feel like there's particular proving systems that you feel like are the right choice, or would you say, actually, any proving system could be used once you've made this transformation?
00:30:06.986 - 00:30:26.562, Speaker C: So this transformation does something that looks like bulletproofs, but it's not quite bulletproofs. And no, you would want to work with this very, very specific protocol. We haven't seen anything better come up for proving ciphertext or well formed than this particular proof system so far.
00:30:26.616 - 00:30:36.406, Speaker A: Got it. How far out do you think we are then, on the fhe front, even with all the work around Zkps? Yeah. How far out do you think we'd be?
00:30:36.508 - 00:30:43.162, Speaker C: It depends for which application. For private smart contracts, probably a year out.
00:30:43.296 - 00:30:43.834, Speaker A: Okay.
00:30:43.952 - 00:30:51.454, Speaker C: I would say for some of those auction use cases, particularly for searchers, that might only be a few months to.
00:30:51.492 - 00:30:57.822, Speaker A: Six months out before they're usable by engineers or implemented. And there's libraries and stuff.
00:30:57.876 - 00:30:59.530, Speaker C: I would say usable by engineers.
00:30:59.610 - 00:31:03.102, Speaker A: Oh, wow. Okay. And you're building these libraries right now?
00:31:03.156 - 00:31:04.898, Speaker C: Yeah, we are working on some of this stuff.
00:31:04.984 - 00:31:12.878, Speaker A: Nice. Is sunscreen then like a tooling company? Is it almost like a company that would build something akin to arcworks?
00:31:12.974 - 00:31:16.626, Speaker C: Yeah, I would definitely say so. We do view ourselves as a tooling company.
00:31:16.728 - 00:31:23.702, Speaker A: Will you have a DSL, or do you just see it as like people can build that themselves to interact with this?
00:31:23.836 - 00:31:28.150, Speaker C: There will be a DSL for some of our zero knowledge proof stuff, unfortunately.
00:31:29.690 - 00:31:34.410, Speaker A: I guess because it's a new system and it's going to need totally new language to interact with.
00:31:34.480 - 00:31:35.002, Speaker C: Yeah.
00:31:35.136 - 00:31:40.006, Speaker A: Damn. What about the fhe part though? Is there such a thing as like DSLs for fhe?
00:31:40.118 - 00:31:50.842, Speaker C: I don't really think so. And for what we've done, at least with our fhe compiler, we just want a developer to write a regular rust program. We don't want them to think about like DSL.
00:31:50.906 - 00:32:13.510, Speaker A: Oh, I see. But how does one actually plug into any of like. So you'd have basically a DSL that can write the ZKP side of things. But then how are you actually using, like, how would you as a developer interact and choose something to set the parameters or make it? Yeah, I'm just kind of trying to picture how do people touch it.
00:32:13.580 - 00:32:46.718, Speaker C: Yeah. So I imagine you'd interact with both the Fhe compiler and the zero knowledge proof compiler at the same time. We envision that these two need to be packaged together in terms of what the interaction would look like. I would say we're still kind of exploring what the API should look like. It is a bit challenging in terms of exposing some of the zero knowledge proof stuff to the developer. The FHe stuff is a lot easier to expose. You're really just asking the engineer like what kind of computation are you trying to run, what's going to be encrypted, what's not going to be encrypted.
00:32:46.814 - 00:32:47.170, Speaker A: Okay.
00:32:47.240 - 00:32:57.702, Speaker C: And that's really it. We can figure out the parameters for you. We can set up all these weird fhe circuits. That's a problem. Our compiler, and hopefully other people's compilers as well will fix.
00:32:57.836 - 00:33:20.810, Speaker A: Are there some use cases that you've heard presented for fhe that are really, really compelling but you think are kind of impossible given that you're so deep in it and because you said you're a pessimist, what do you think is maybe almost overhyped in the fhe world but you don't think is really feasible?
00:33:21.470 - 00:34:10.522, Speaker C: I don't know if there's things I don't think are feasible. I would say there's things I don't think are feasible right now or for the next one or two years. The use case that lots of people will ask me about, and engineers get really excited about is the intersection of fully homomorphic encryption with machine learning. Can we do private training? Can we do private inference? And I always feel horrible when I have to pick people's hearts and say that I don't think fhe in combination with machine learning is really viable at this point in time. When you think about the overhead from using fhe, it's pretty bad. So data blow up will be 10,000 10,0000 x. The overhead in computation is 10,000 10,0000 x.
00:34:10.522 - 00:34:20.286, Speaker C: Can you explain to web two companies, yeah, we're going to blow up your database size by 100,000 x. The computation will be 100,000 x lower.
00:34:20.468 - 00:34:46.166, Speaker A: Is that okay with you? And I guess you get privacy, but I guess there you really get to see if it's worth it. Wow, that's crazy though. Are there sort of like lighter use cases where maybe it could work where obviously, I think when you look at ML, obviously there's a huge range. You could do really sophisticated things, but you could also do really simple things. Do you think there's like simpler examples that maybe could already be used in.
00:34:46.268 - 00:35:01.646, Speaker C: Yeah, yeah. I definitely think for very simple machine learning models fhe could make sense. But trying to combine fhe with modern day machine learning, these super deep neural networks, I don't think that's viable right now.
00:35:01.748 - 00:35:09.086, Speaker A: When do you think it could be like, given the current speed, ten years, five years?
00:35:09.268 - 00:35:42.554, Speaker C: That's a good question. I think for this blow up in terms of size, maybe it'll be acceptable at some point in time if companies decide privacy is important enough, or there needs to be actual improvements to the theory behind fHe. For the performance side, maybe with some of the work in hardware accelerators, the performance will be good enough. I would say for that. I know some companies are working on hardware acceleration for FHe, both very large companies and startups. Maybe in the next three to five years.
00:35:42.672 - 00:35:47.450, Speaker A: Oh, cool, she said it here. No, I don't want to predict.
00:35:49.230 - 00:35:49.642, Speaker C: Yeah.
00:35:49.696 - 00:36:04.462, Speaker A: What's kind of next for you guys, though? You sort of mentioned that there's tooling that you're going to be releasing. At some point, people are actually going to be able to start engaging with it. Tell us a little bit about where you're at and what you see coming up in the next six months or so.
00:36:04.596 - 00:36:17.070, Speaker C: For us, we will be likely adding support for other fhe schemes in our Fhe compiler. Right now, we only support one particular fhe scheme that we think is well suited to a number of web3 applications.
00:36:17.150 - 00:36:17.986, Speaker A: What's it called?
00:36:18.088 - 00:37:07.238, Speaker C: The BFE scheme. Okay, so the advantages of that scheme is that it supports fairly fast arithmetic on encrypted data and quite a bit of precision. So if you're looking to do 32, 64 bit computation, this is probably the scheme for you. In terms of the other pieces we're working on, the zero knowledge proof compiler is going to take a little bit longer than the fhe compiler, we need to glue together some proof systems, figure out what the API is going to look like there, and combine it with our fhe compiler. And there's another part that I haven't told you about, but for fhe ciphertext they're actually quite large. And it's not clear if developers are going to be okay storing those ciphertext directly on chain. So we're investigating some sort of storage solution for that.
00:37:07.238 - 00:37:14.070, Speaker C: Could you store the ciphertext somewhere else and some reference or hash to the ciphertext directly on chain?
00:37:14.490 - 00:37:16.178, Speaker A: Can you explain that a little bit further?
00:37:16.274 - 00:37:52.740, Speaker C: Yeah. So very roughly speaking, instead of storing an fhe ciphertext on chain, what if you were to hash the ciphertext, store the hash on chain, which is very small, and then when somebody needs the fhe ciphertext, they go retrieve it from another location? Maybe you would store the fhe ciphertext on something like IPFs rweave, and you would have to figure out how the validators and users are going to go retrieve it. So I'd say this is more of an engineering problem, like how do you quickly upload, download things, that sort of stuff.
00:37:53.670 - 00:38:06.066, Speaker A: I guess it's taking it partly off chain. Would you ever imagine that being a roll up kind of situation, like where it has its own off chain action and there's like some, and this is the connection point on chain.
00:38:06.178 - 00:38:26.842, Speaker C: You could do roll ups in combination with fhe, but it would be super inefficient at this point in time. I don't know what the timeline is there. I would say I'm even less optimistic for the combination of roll ups and fhe than I am for machine learning and fhe.
00:38:26.986 - 00:39:17.326, Speaker A: Okay, I will say this. For me, this is kind of a space that I haven't had that much of a chance to think about. And even all of the characteristics that fhe enables is still a little bit fuzzy for me. I guess I'm still trying to figure out what an application looks like in this. Would there be an application built on top of this? Or would it be something like you sort of talked about, like fhe smart contracts, but I'm trying to picture what's a user facing thing that lives on top of this that we would use. I understood the auctions idea, but I'm even thinking maybe closer to a user sitting at the computer, like dealing with an interface, not even like a developer user, you know what I mean?
00:39:17.428 - 00:39:29.300, Speaker C: Ideally they wouldn't even know they're using fhe. This is so far away from them. This is completely hidden behind the scenes that maybe they just know that they're getting privacy somehow. They're just clicking a button.
00:39:29.750 - 00:39:34.420, Speaker A: Yeah, it'd be like encrypted chats or something like that. Exactly.
00:39:35.030 - 00:39:43.138, Speaker C: The user just gets privacy. They don't need to know about it. They don't need to know the details. They don't need to know there's fhe and zero and all proofs hiding behind the scenes.
00:39:43.234 - 00:39:53.670, Speaker A: What kind of thing, though? Could you imagine like an end user somehow interacting with this on, though? What would they be giving? Yeah, I'm trying to go even further up the stack.
00:39:53.830 - 00:40:10.298, Speaker C: So I think for a private version of an exchange, ideally there would be very little from the user's end. It would just be like toggling something to execute a private order. Maybe there's a slightly higher fee, but that would be it in terms of interaction.
00:40:10.394 - 00:40:16.750, Speaker A: But under the hood, there would be like this private space where computation is. It's all encrypted somehow.
00:40:16.910 - 00:40:18.100, Speaker C: Yeah, exactly.
00:40:18.470 - 00:40:36.950, Speaker A: That would be one example. In the smart contract example, though, how would somebody. Do you have any ideas for types of smart contracts where this would actually be used? I know it's funny because ZKP people have definitely had ideas around this, but I'm just wondering if the fhe use cases are different.
00:40:37.100 - 00:40:40.426, Speaker C: So I'm not sure how well I can answer this question.
00:40:40.528 - 00:40:42.010, Speaker A: I know it's very vague.
00:40:42.350 - 00:40:55.200, Speaker C: Yeah, it's fairly also early stages for us because we're still trying to figure out what the API will look like on the ZKP side. So it's a little hard to say what exactly will the user experience be like there yet?
00:40:55.570 - 00:41:12.354, Speaker A: Where would you like to see more research? I mean, you've talked about sort of that interaction between ZKPs and fhes, and maybe the lattice based ZKPs would be a place. But yeah. Is there a specific part of the research landscape right now that you would love to see more of? That would really help you guys?
00:41:12.472 - 00:41:28.326, Speaker C: Yeah, definitely. That kind of interaction or intersection of zero knowledge proofs and fhe. We really need better zero knowledge proof systems for proving things about lattice based relations in fhe. So if other people want to join us here, that would be amazing and we would love to have you.
00:41:28.428 - 00:41:36.514, Speaker A: Cool. So, Ravitel, thank you so much for coming on the show and sharing with us the story of sunscreen, as well as exploring fhes.
00:41:36.562 - 00:41:38.774, Speaker C: Again, it was amazing to join you.
00:41:38.892 - 00:41:45.450, Speaker A: And I want to say thank you to the zk podcast team, Henrik, Rachel, and Tanya, and to our listeners, thanks for listening.
