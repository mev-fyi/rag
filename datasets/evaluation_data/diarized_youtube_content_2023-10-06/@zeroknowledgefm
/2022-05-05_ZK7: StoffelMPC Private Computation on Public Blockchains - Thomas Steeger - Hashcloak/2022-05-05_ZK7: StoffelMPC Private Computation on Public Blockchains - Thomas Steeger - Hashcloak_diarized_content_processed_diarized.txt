00:00:08.370 - 00:00:36.334, Speaker A: Hello, my name is Thomas. Thanks for letting me present here. This is my first time at the k summit, but I won't be talking about zero knowledge topics. I will be talking about multiparty computation. In fact, I'll talk about Stoffel MPC, which is a framework for multiparty computation. It brings some form of privacy to public blockchains. Okay, so this is the structure of my talk.
00:00:36.334 - 00:01:51.506, Speaker A: So in the beginning I'll be talking a little bit about multiparty computation in general. We have a look at some introductory examples and also at some protocols. And afterwards we have a short look at current solutions of privacy on public blockchains, and then we'll see why we probably need some other form of privacy like MPC. And what are the benefits and why is it cool? And after that we have a look at our framework stuffel MPC, which basically allows developers to bring some form of privacy to the blockchain, leveraging MPC. And then we will have a look at some general purpose MPC which is needed for this, and we'll have a look at compilers and virtual machines, and in the end we'll have a look at open problems and give some outlook. Okay, yeah, so first MPC. So what is MPC? I mean, MPC stands for multiparty computation, and it's basically when you have several people who have a secret and they don't want to reveal that secret, but they would benefit from some computation over their secrets.
00:01:51.506 - 00:02:44.346, Speaker A: So what you often read is in the papers is this sentence. Multiparty computation allows parties to jointly compute a function over their inputs while keeping them private. Yeah. A funny example is, for example, if you're working at some company and you're an employee there, and you would benefit from knowing maybe the average salary the company pays. So what you can do is the first employee, it takes his or her salary and then masks it with some random number. So he adds the random number to the salary, and then he writes that down on a piece of paper, and then he passes it on to the next person, again adding his salary to it. And then it goes round and round and round, and in the end it gets back to the first person and you can then subtract the secret number and divide it by the people.
00:02:44.346 - 00:03:27.686, Speaker A: And then you have your average salary, which is then broadcasted by one party. But this is somehow, or at least this example is very tied to this specific problem instance. So yeah, we want to do some more general MPC. So what can we, yeah, you probably all know Shamir secret sharing from basically threshold wallets or something like that. So how does it work? I mean, you have a secret and you encode that secret as a point on the polynomial. So basically it's here, for example, you have the 15, it's the evaluation of the polynomial at X equals zero.
00:03:27.868 - 00:03:28.262, Speaker B: Yeah.
00:03:28.316 - 00:03:48.800, Speaker A: And then you give out shares to other people, which are points on the polynomial. Right. So you have here player one, two and three. And if you agree that the X coordinate is always the player number, then you can hand out these shares without specifying the x coordinate. So player one would get, what is it, eight here, player two would get three and player 30.
00:03:49.250 - 00:03:49.614, Speaker B: Yeah.
00:03:49.652 - 00:03:59.550, Speaker A: And then basically the secret is split up and encoded into these points. And then you can reconstruct the secret by using these points with the Lagrange interpolation.
00:04:01.890 - 00:04:02.350, Speaker B: Yeah.
00:04:02.420 - 00:04:29.978, Speaker A: The nice thing about this is here that it depends on the degree of the polynomial, of what kind of reconstruction scheme you have. Because, for example, if you have a parabola, you need three points. And for the general case, you always need n plus one points. So you could even add here p four and p five. And then any three out of five of these shares could reconstruct the secret. Okay. But this was only an example.
00:04:29.978 - 00:05:18.870, Speaker A: Now for the case where you have one secret and you divide it into several shares. So now we have several secrets. In fact, we have two here. And let's say we have now three players who each have a share of these two secrets. And now what gets really interesting is when you want to compute with it, right? So how can you compute in this case? So think of it as points on the polynomial. And if you then consider addition, I mean, if you add these points on the polynomial, then basically you add these polynomials together, which is basically adding these secrets then together. So addition is pretty simple because it doesn't require any form of interaction.
00:05:18.870 - 00:06:01.942, Speaker A: But it gets a little bit more difficult with multiplication. I mean, you have the case where you have some publicly known constant, then you can do it similar to addition, but it doesn't work. If you have basically two shares, you can't multiply that because when you are multiplying a parabola with another parabola, you get another degree of the polynomial, and then your reconstruction scheme doesn't work. So then you have basically to do a new sharing of this combined secret. So this is not nice. It requires a lot of interaction. So what can we do here? There have been some further I should mention.
00:06:01.942 - 00:06:09.370, Speaker A: This is the BGW protocol in the literature. So it's fairly old, and there have been a lot of improvements to this protocol.
00:06:10.830 - 00:06:11.290, Speaker B: Yeah.
00:06:11.360 - 00:06:49.718, Speaker A: So the most, mainly all protocols use this MPC in the pre processing world, where you basically have an offline and an online phase. And in the offline phase, you prepare something for the online phase, which in these case are these beaver triples. And these beaver triples are then consumed for every multiplication. Right. So you have these values, ABC, which you share inside this MPC, and it obeys this relation. C is equal to Ab. And then when you want to carry out a multiplication, you use one of these beaver triples and use the following relations.
00:06:49.718 - 00:07:07.626, Speaker A: So each player takes this share x and y, and then he subtracts the secret shared a and b, and he then opens it as day d and e. And after that you can multiply it locally with this. So this is pretty nice.
00:07:07.808 - 00:07:08.106, Speaker B: Yeah.
00:07:08.128 - 00:07:40.040, Speaker A: And then there have been several other improvements of this protocol. It's called Bedoza speeds, overdrive, high gear. There are a lot of protocols like this, but what they do is they optimize how these beaver triples are constructed. You can use, I think some protocols use somewhat homomorphic encryption for that. Others use oblivious transfer, and sometimes they add these message authentication codes so that this MPC works in a malicious security model.
00:07:43.290 - 00:07:44.040, Speaker B: Yeah.
00:07:45.130 - 00:08:19.380, Speaker A: So here, this is an excerpt which I have taken from the MP speeds repo. I will tell what MP speeds is later, but I just want to show you this slide so that you know that there are different security models under which MPC works. So basically we have this malicious covered and semi honest security models where malicious just means that the players don't stick to the protocol. And covered security is that they stick to the protocol. If they knew. No, they don't stick to the protocol. No.
00:08:19.380 - 00:08:25.730, Speaker A: When they know that, they will be discovered cheating. They don't cheat. That's what it is.
00:08:25.800 - 00:08:25.986, Speaker B: Yeah.
00:08:26.008 - 00:09:06.974, Speaker A: And semi honest is that they just follow the protocol. And then you have these different majority settings, honest and dishonest. Where is there? And the field over which you are operating can be different. And then there are some MPC protocols which are entirely different, like garbling, for example, where you encrypt the circuit and send it around. Okay, yeah, let's now come to blockchain privacy. I mean, everything you do on a blockchain is basically public. So what can we do to avoid this? Or what is done to avoid it? Yeah, I mean, we have this ZK proofs.
00:09:06.974 - 00:09:41.870, Speaker A: We've heard a lot about them. Basically zcash, you can send around money without connecting sender and recipient. This has then been ported to Ethereum with tornado cache. Then you have the aztec protocol which is a ZKZk roll up. So it combines the roll up guarantees you get from zero knowledge proof together with this shielding. Then there's new cipher which does this proxy. So from my understanding this is basically some access mechanism.
00:09:41.870 - 00:10:25.690, Speaker A: So if Alice has some data, she can encrypt it and then she can allow some other party to get access and then other parties can re encrypt it on her behalf for this other party without having some intermediate decryption of it. And they also do some fhe research, I think, but I'm not sure. But this is basically research because it's some sort of holy grail of computing over secret data. Another category are these trusted execution environments. There is secret network and Opskubu and they use these trusted hardware devices. Basically they're in the cpu like Intel SDX.
00:10:27.890 - 00:10:28.206, Speaker B: Yeah.
00:10:28.228 - 00:10:47.620, Speaker A: And then there's MPC. So currently MPC is in most situations used for wallet management. So there isn't really any computation over these secrets. They are just split apart and then reconstructed. Yeah, but we want to change this, right? So that's why I have postophel MPC there as an outlook for the future.
00:10:49.670 - 00:10:50.274, Speaker B: Yeah.
00:10:50.392 - 00:11:02.630, Speaker A: Okay, so why do we need multiparty computation? So I mean, multiparty computation offers some advantages. So the problem with zero knowledge proofs is that you can't do them on shared data.
00:11:02.700 - 00:11:02.934, Speaker B: Right.
00:11:02.972 - 00:11:53.560, Speaker A: So I mean if you think of somehow, for example an order book or something like that, you don't have really anybody who can do this zero knowledge proof for the data. So it doesn't work in this case. The problem with, and you don't have that for MPC, which is quite nice. So why there is some endeavor to build these on chain exchanges using. Yeah, then you don't have these trust assumptions like in the trusted execution environments because you don't have to trust any hardware, you don't have to trust any manufacturer. And to some degree MPC is already used in practice, so it's not that far away like fully homomorphic encryption. I mean there have been some instances where it is used for medical data and stuff like that.
00:11:53.560 - 00:12:53.562, Speaker A: So the problem with MPC is a little bit that you always have this communication overhead and if the parties are far apart you always have this latency between them. So this is not nice. And yeah, the other thing is that general purpose MPC is quite hard because you get this overhead of virtual machines and compilers. Okay, so let's now have a look at Staffel MPC so yeah, Stoffel MPC again, is this framework for a developer to build privacy preserving applications with MPC. And for that we need general purpose MPC. So what does it mean? I mean, it's similar to the zero knowledge case where the developer writes his code or what he wants the MPC to be done in some domain specific language. We'll see later why we need that.
00:12:53.562 - 00:13:21.890, Speaker A: And then a compiler takes care of it and compiles it to an arithmetic circuit. It's also possible to use a boolean circuit and after that it gets further compiled into bytecode for some vm. So the things we need for general purpose multiparty computation is the domain specific language, compiler and virtual machine. But this is only the MPC world, right? I mean, we want to somehow connect this MPC to the blockchain.
00:13:22.390 - 00:13:22.754, Speaker B: Yeah.
00:13:22.792 - 00:14:25.494, Speaker A: And how does or how could this look like? Yeah, I mean, you basically have three parties here, which is the MPC, the user and the Ethereum mainet, or any blockchain. And the interaction between user and blockchain stays basically the mean. You can query data from Ethereum, you can write to it using transactions, but then you would also have this private data interaction with the MPC. And here the MPC operates in this MPC as a service model, which means that the secret data is input by the user to the MPC. So the MPC nodes don't make up their secrets themselves. They basically work for the user and they can also query the output from the MPC for private data. And then you have this interaction between the MPC and the blockchain in a sense that when public data is required or when you want to open these shares, this secret, then the MPC writes it to the blockchain.
00:14:25.494 - 00:14:40.110, Speaker A: And in that sense the blockchain is some sort of coordinator for the MPC, because the MPC is constantly querying or looking at the blockchain if anything is needed. Okay.
00:14:40.260 - 00:14:40.622, Speaker B: Yeah.
00:14:40.676 - 00:14:55.410, Speaker A: So how does it look like? Or what are we doing at hashcloak? So we are building this stuffel MPC framework. It's inspired by MP speeds. MP speeds is basically some form of testing framework for different MPC protocols.
00:14:57.670 - 00:14:58.034, Speaker B: Yeah.
00:14:58.072 - 00:15:55.880, Speaker A: So it offers this general purpose MPC and the developer can, I mean, it already implements this general purpose MPC and then the developer can specifies with which MPC protocol he wants his code to be executed. Yeah, we use some modular crate architecture in rust. I put here the list of the subcreates which we are currently using or what we are thinking of how it will look like and yeah, it would be nice if the developer had the choice to use this framework in two different ways. So on the one hand he would use it like I've shown you before, but on the other hand he would also be able to use subcreates of this. So for example, here in the MPC crates, there would then be implementations of different MPC protocols, and then they could include it in their application how they like. Okay.
00:15:57.930 - 00:15:58.342, Speaker B: Yeah.
00:15:58.396 - 00:16:46.790, Speaker A: So coming back to these three things, you have this language, the compiler and also the virtual machine. So why do we need a domain specific language? Basically, we want the developer that he's able to write his application without knowing anything about MPC. But if you have a look at how this works, I mean, some code of it has to be run in the NPC and the other part of the code has to be run in the blockchain. So the compiler should have to figure out how this is separated and then the developer does only have to put secret types there, or clear types. And the compiler figures out how this is separated and compiles it for Ethereum mainet or for the MPC VM.
00:16:47.290 - 00:16:48.710, Speaker B: You got about five more minutes.
00:16:48.780 - 00:16:50.680, Speaker A: Five minutes, okay.
00:16:51.450 - 00:16:52.200, Speaker B: Yeah.
00:16:53.050 - 00:17:43.910, Speaker A: So here I put some compiler specific problems from MPC. What's interesting about MPC is that you want to avoid these interactions because they are quite costly. And in order to do that the compiler tries to penalize a lot these communications and they want to batch that into a single round of communication. Another thing which is a problem is if you have this execution path dependence. So in this example, I mean, if x is secret shared and you have some comparison like in an if statement, then it's pretty hard to figure out if it's true or false. So what do you do? Is that you somehow defer the evaluation of it. This technique is sometimes known as the branchless programming.
00:17:43.910 - 00:18:22.840, Speaker A: But it's a problem, right, because this then scales linearly with the circuit size, and you have that in your communication. And if you have something like this, for example, where you have an array and you want to set some slot of the array to one, but this is a secret shared value, you run into a problem because your array might be pretty large, right? It could be thousand or 10,000 slots. And then you have to resort to other techniques like oblivious data. And it's sometimes called oblivious rum, where you somehow want to hide the read and write access.
00:18:26.250 - 00:18:26.662, Speaker B: Yeah.
00:18:26.716 - 00:19:12.210, Speaker A: And this is what we think what our virtual machine will look like. So it's inspired by MP speeds and scale mumba scale number is basically some sort of sister project to MP speeds. And yeah, it uses a risk design. So we have these opcodes for, on the one hand you have opcodes for arithmetic circuits, on the other hand for binary circuits. And then you have some opcodes for both, some general opcodes. And we have these type registers which are for every type. So I mean, you have the clear type registers, you have the secret type registers, and you have the core stack.
00:19:12.210 - 00:20:12.386, Speaker A: And these cores then communicate by using the memory. So if core, this core needs to communicate with that core, it would go over the memory. And if the core communicates with another core on some different MPC node, then you would have some network channel between them. Yeah. So here I have put some open problems which we think are quite interesting. So we want to add some zero knowledge functionality so that we get some MPC with public verifiability, which means that basically anyone can check that the MPC is doing correct. Then the next one is much more of an implementation question because basically you want to use several cpu cores for the VM, and then it's a question of how to do it because we probably want to use some work stealing schedule.
00:20:12.386 - 00:20:50.174, Speaker A: And this then leads to using this Tokyo in rust. And we want to support other robust MPC protocols. So there is currently this, or what we are implementing is this honey badger MPC protocol. But there are other interesting MPC protocols. This question is much about this oblivious write and read access. So how do you handle these data types? And this question is that. Yeah, what I've shown is currently much more in this MPC as a sidechain framework.
00:20:50.174 - 00:21:25.790, Speaker A: So you don't inherit the layer one security. It would be nice if you could somehow execute this as a roll up. And the last one is about these beaver triples. If you remember, it was this in the offline phase where you constantly process these beaver triplets and you need this interaction between the nodes. And in there you would just have some soil random function basically, which you seed, but they are correlated with each other, so it would only require an interaction at the beginning.
00:21:29.150 - 00:21:29.514, Speaker B: Yeah.
00:21:29.552 - 00:21:59.734, Speaker A: Okay, so we want to say special thanks to the people at UIUC and ISC three, because what we are doing wouldn't not be possible without their work. So thanks a lot. Yeah, and thanks to you for listening to my talk. If you want to stay in touch, here is the repository for Stoffel MPC. We just open sourced it. And this is hashcloak. You can follow it on Twitter.
00:21:59.734 - 00:22:03.770, Speaker A: And we are currently hiring for MPC engineers.
00:22:12.190 - 00:22:14.586, Speaker C: Time for a couple questions, if there.
00:22:14.608 - 00:22:24.800, Speaker A: Are any in the audience, and just repeat the question. So raise your hand if you have a question.
00:22:27.090 - 00:22:45.078, Speaker C: That's a question. I understand. The MPC model here is that you just have some sort of server. What's the point? What are you trying to achieve, at least from your diagram of having blockchain? Have some public statement and you're supposed to have some private state shared between two parties, right?
00:22:45.164 - 00:22:45.510, Speaker B: Yeah.
00:22:45.580 - 00:22:47.174, Speaker A: Inside the MPC, right? Yeah.
00:22:47.212 - 00:22:52.262, Speaker C: So you want the NPC to be like what? Like a network that sort of jointly holds the secret?
00:22:52.406 - 00:22:53.018, Speaker B: Yeah, exactly.
00:22:53.104 - 00:23:05.310, Speaker A: So you have this private data, and the private data is shared inside this MPC as these shares. Right. So each node holds a share of the secrets.
00:23:05.810 - 00:23:11.710, Speaker C: But is it supposed to be like a cluster with n of n sort of secret shares?
00:23:14.690 - 00:23:17.042, Speaker A: It depends on the NPC protocol you are using.
00:23:17.096 - 00:23:17.314, Speaker B: Right.
00:23:17.352 - 00:23:41.574, Speaker A: So what we are currently looking at, you have this threshold guarantee where you think that one third of the parties inside the protocol can be malicious, and it still works. And the protocol also offers some form of guaranteed output delivery, that you always get an output if you stay in that safety margin.
00:23:41.702 - 00:23:54.930, Speaker C: And the idea is that the client just sort of deals secret shares to the whole sort of decentralized network and then they will perform communications later. Just sort of like a cloud distributed.
00:23:55.110 - 00:23:55.840, Speaker A: Exactly.
00:23:56.370 - 00:23:58.510, Speaker C: And why is the blockchain involved?
00:23:58.930 - 00:24:09.666, Speaker A: Yeah, I mean, you want that, you get this form of privacy to the blockchain. Right. So how do you get privacy to the blockchain? This could be some way to do.
00:24:09.688 - 00:24:25.586, Speaker C: It, like a whitelist of public keys of the nodes. You need somehow anchor the identities of the decentralized sort of entities in the NBC cloud things into the blockchain.
00:24:25.618 - 00:24:25.814, Speaker B: Right.
00:24:25.852 - 00:24:44.074, Speaker C: Otherwise, that's the kind of goal of somebody being able to sort of query inside of the blockchain, like in a smart contract. I want to get some of the data from something or get some computation of it, like a mean of a bunch of numbers that are secret shared. And then the NPC sort of cluster needs to look at the blockchain, see.
00:24:44.112 - 00:24:47.518, Speaker A: That request in that way, sign that.
00:24:47.604 - 00:24:50.266, Speaker C: Output and send it back to the blockchain.
00:24:50.298 - 00:24:50.494, Speaker B: Exactly.
00:24:50.532 - 00:24:58.570, Speaker A: You would have this interaction between MPC and blockchain. Yeah, perfect. Okay, I think we're out of time. So once again, thanks, Thomas.
