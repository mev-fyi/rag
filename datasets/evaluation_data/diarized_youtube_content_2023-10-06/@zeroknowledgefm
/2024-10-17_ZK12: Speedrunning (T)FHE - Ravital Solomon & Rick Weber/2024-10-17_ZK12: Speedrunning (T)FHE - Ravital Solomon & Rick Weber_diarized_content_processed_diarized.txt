00:00:08.119 - 00:01:30.713, Speaker A: Hi, I'm Ravital, the founder of Sunscreen, and in this talk we're going to be speedrunning tfhe.t here stands for torus, not threshold, and it's a particular FHE scheme. So the whole motivation of this talk, and frankly our work for like the last nine months, is to understand how can we beat state of the art performance for tfhe, and what would a winning strategy even look like to accomplish this? So what is the TFHE scheme? Well, it's considered one of the state of the ART schemes for FHE, and by ZK standards, it's pretty old. It's from 2016. It's natural to wonder what fhe folks have been doing in the meantime if there are no new schemes and they've been working on a bunch of other sidequests, so to speak, everything from multiparty, multi key FHE to hardware acceleration of the technology and semi efficient combinations of FHE and zk. When most people introduce fully homomorphic encryption, they talk about it as an extension of public key cryptography, where in addition to being able to generate keys, encrypt and decrypt data, you can now perform computation over the encrypted data itself. So specifically, we talk about adding and multiplying ciphertext together, but the reality is a little bit more complicated than that.
00:01:30.713 - 00:02:21.265, Speaker A: So for certain kinds of FHE schemes, you can also perform comparisons over the encrypted data in a fairly efficient way. And to actually support all of this computation over the encrypted data, there tends to be a lot more algorithms in the background that actually facilitate this problem process. The key thing you need to know about FHE, if you're working with it, if you're a cryptographer or if you're an engineer, is that you need to manage something called noise. I'm not going to tell you what exactly noise is, just the consequence of it. So as you're performing these computations over the encrypted data, this thing called noise keeps growing. And if it grows too large, if it becomes too big, you will no longer be able to decrypt your data and expand back the right result. So we need to make sure we manage noise when working with FHE.
00:02:21.265 - 00:03:09.091, Speaker A: How did we end up at TFHE? Well, very first scheme was about 15 years ago. It was from Craig Gentry, and it wasn't particularly practical in real life, but it introduced this concept called bootstrapping. And if we want to control noise growth, we absolutely have to use bootstrapping at some point in time. So second generation of FHE comes along in 2011, 2012 and it tries to avoid bootstrapping entirely. So the idea for second generation schemes is we're going to work with a leveled scheme where at no point are we going to use bootstrapping and we can only support computations up to a certain depth. After that point, we're basically screwed. The good thing about these schemes is that they're really, really good with arithmetic.
00:03:09.091 - 00:03:45.195, Speaker A: So if you're looking to add, multiply, ciphertext together, this is the way to go. Final generation comes along, this is where TFHE sits, the whole focus of this talk. The nice part about this scheme is that it's very, very good at performing comparisons over encrypted data. So if you want to order things, this is the way to go. It took a totally different approach to bootstrapping than second generation fhe. So whereas second generation avoids bootstrapping entirely, with third generation we're going to bootstrap super often. So basically after every homomorphic computation.
00:03:45.195 - 00:04:36.247, Speaker A: So now that we've told you a bit about noise and a bit about bootstrapping, we're ready to introduce our strategy to beat state of the art performance. And at a high level, our strategy is actually really, really simple. It's just that we're going to be super smart about how and when we bootstrap. So what does that specifically mean when it comes to how to bootstrap? We are going to go see what types of bootstrapping variants actually exist out there in the literature and what are their trade offs on the when part. We're going to see if we can take some sort of middle ground between second and third generation fhe. So we're not going to avoid bootstrapping entirely, but we're not going to bootstrap super, super often. If you don't actually work in FHE or lattice based cryptography, you might think this is actually easy to implement and try out our strategy.
00:04:36.247 - 00:05:18.459, Speaker A: So maybe it looks something like the following. We go look in the literature, we see what types of bootstrapping existing. We then write our nice little FHE program and we replace, we'll say bootstrapping method A with bootstrapping method B. Maybe we'll have to make some fairly minor parameter adjustments, but honestly, how bad could that be? And finally we just run our program and we see how we do that is not what the strategy looks like at all. And you would be very, very wrong if you thought it was that easy. So there are a number of problems with trying to take that Approach. The first problem is that you can't simply write a program, take one bootstrapping method and replace it with another.
00:05:18.459 - 00:06:02.741, Speaker A: They behave totally differently. Problem number two, that noise issue I was talking about, well, it turns out that noise grows differently depending on which bootstrapping method you use. Three, it's not super obvious when you look at the academic literature what the trade offs for performance are going to be in some non trivial application. And four, those parameters. Well, there's not a few of them, there's actually over 10 of them. They're all deeply interconnected and it turns out they handle everything from performance, security and correctness. So when you're working with the TFHE scheme, there's a chance of a decryption error, so you might get back the wrong answer.
00:06:02.741 - 00:06:37.805, Speaker A: What kind of error rate are you okay having? So let's look at what bootstrapping options even exist out there. Option number one is called gate bootstrapping. You can think of it as the original form of bootstrapping in the TFHE paper. You're going to work with binary messages and your goal is to just reduce noise. Programmable bootstrapping builds on top of gate bootstrapping. You can think of it as a generalization here. We're going to work with messages of greater than a bit and we're also going to apply a function at bootstrapping time.
00:06:37.805 - 00:07:11.461, Speaker A: The idea for programmable bootstrapping has been around for a while. It's as early as 2018. Finally we have circuit bootstrapping. And what distinguishes circuit bootstrapping from gate and programmable bootstrapping is that it produces a totally different ciphertext output type. And what's special about this output is that it can be fed directly into a multiplexer. If you need a brief refresher on what a multiplexer is, just think of it as a way of implementing an if condition. But here everything's encrypted.
00:07:11.461 - 00:07:43.221, Speaker A: The idea for circuit bootstrapping is also quite old. It's been around since 2017, potentially even earlier. We're not very interested in gate bootstrapping. It's certainly not going to allow us to beat state, state of the art. So we're going to be interested primarily in programmable and circuit bootstrapping. So naturally at this point we should go see what research exists out there. What are other people saying? A lot of interest has gone into programmable bootstrapping, both on the industry side as well as in academia.
00:07:43.221 - 00:08:35.275, Speaker A: And circuit bootstrapping has largely been ignored by the community at large. We Have a few theories for why this might be, but one potential theory is that if you take a fairly standard security level, so say 128 bits of security, circuit bootstrapping doesn't look that promising. The time's pretty abysmal and it's over two and a half times slower. But looks can be deceiving. So should we actually call it a day at this point? What actually happens when we try to write a non trivial program using these two approaches? So we're going to focus on a comparison program. The reason for that is because the whole reason to use the TFHE scale is to get cheap comparisons over encrypted data. I've chosen 16 bits because it's non trivial and it fits nicely on a slide.
00:08:35.275 - 00:09:21.741, Speaker A: And here we're seeing how to do that program using programmable bootstrapping. You'll notice on the left hand side with that nice diagram, these red nodes, which is where you perform a programmable bootstrap operation. The important thing to note is that there's dependencies between these red nodes. So there are programmable bootstrap operations dependent on other programmable bootstrap operations. What happens if you try to implement the exact same program using circuit bootstrapping? You get a very different looking graph. And while this graph looks incredibly ugly, the important thing to note are the red nodes where we're using circuit bootstrapping. And you'll notice that there are no dependencies between those red nodes.
00:09:21.741 - 00:09:46.385, Speaker A: No circuit bootstrapping operation is dependent on any other circuit bootstrapping operation. Why does that matter? Well, it means in theory, this program can be parallelized a lot better than the previous one with programmable bootstrapping. Can we actually take advantage of this parallelism? What do we need to do to accomplish that? Rick will tell you all about that.
00:09:48.175 - 00:10:43.365, Speaker B: Thank you, Ravital. So circuit bootstrapping has these nice computer science theoretical properties, but unfortunately, at 128 bit security, the performance of the bootstrap operation itself kind of hampers the overall computational scheme. But maybe there's some things we can do to improve the performance of circuit bootstrapping. Such as we can reduce the security of the underlying LWE problems, or we can perhaps accept a higher level of error rate. And both of these things are going to manifest themselves at tweaking the parameters of the underlying scheme. So, to get started, let's look at how does programmable bootstrapping work. You start with an LWE ciphertext that encrypts one or more bits of data, and then you apply a negacyclic function F while you're also resetting the noise in the ciphertext.
00:10:43.365 - 00:11:25.745, Speaker B: And then you do some other things I'm not really going to talk about. But you'll note that there's these L and beta parameters, which I will talk about in a little bit. But first let's look at and contrast with circuit bootstrapping, whereby you start with an LWE ciphertext that encrypts a single bit, a binary message, and then you do a bunch of steps and get this GGSW ciphertext in the middle. And it's important to note here that we have just produced this GGSW ciphertext as a result of circuit bootstrapping. We haven't done any computation yet. We do that by computing a lookup table built out of a mux tree. Multiplex operations are hundreds of times cheaper than a bootstrap operation.
00:11:25.745 - 00:12:12.065, Speaker B: And then finally we do some other boring things I'm not going to talk about. But you'll note here that there's more of these LN beta parameters. So what are they? Well, these L and beta parameters define base decompositions. A base decomposition is a technique used during homomorphic multiplication. And what it does is it limits the noise growth when you apply this operation during the bootstrap process. So to give you an idea of what base decomposition is, you take a value like 125 and you break it into digits so 1, 2 and 5, and they're multiplied by their constituent gadget coefficients. And then when you sum them all up, you get back the original value.
00:12:12.065 - 00:13:22.041, Speaker B: In practice, when FHE and TFHE in particular, we can, we often use approximate decompositions. So if we took the digits 1 and 2 and multiplied by them by 110 respectively, you would get back to the value 120, which is approximately 120 25. So what are all the parameters now that we have to muck with with circuit bootstrapping under tfhe? Well, circuit bootstrapping starts in practice with a programmable bootstrap operation. And this exposes these programmable bootstrap based decomposition parameters. We then do a private functional key switch and this exposes these PFKs based decomposition parameters. And in doing this, after doing these operations, you have produced a GGSW ciphertext which is itself radix decomposed and that produces these CBS radix parameters. Finally, we have key switching, which is another thing I'm not really going to talk about, but it gets you back to the original key under which you started.
00:13:22.041 - 00:14:25.215, Speaker B: So, so you can continue the computation or send the data back to the user. So we have all these different parameters. Let's take kind of a brief look at how do they impact performance, security and correctness. Unfortunately, it's a very complex multidimensional search problem. We iterated through tens of thousands of simulations whereby we would run a synthetic computation and we would measure the performance, the noise, and we would fix the security level to some desired amount. And to give you a flavor of how all this stuff is intertwined, if you take the CBS level and the PFKS level and take the product of these two, this is the relationship for the overall performance of your scheme. So if the circuit bootstrapping level is 1 and the pfks level is 1 versus if they're both two, in the latter case, you'll be four times slower.
00:14:25.215 - 00:15:22.535, Speaker B: And looking at the CBS base and level values. Specifically, if you have a lower CBS level in your decomposition, you'll get better performance, but often at the expense of more noise. Conversely, if you use a higher number of digits in your decomposition, that is a higher level, but with a lower base, you get less noise but worse performance. And then there's this kind of interesting relationship with the log of the base times the level. This represents how approximate your decomposition is. So if you had a 64 bit value and the product of this is 34, then you have capture roughly half the message in your approximate decomposition. This product is very non intuitive as to what the sweet spot is, and it varies from decomposition parameter to decomposition parameter.
00:15:22.535 - 00:16:23.504, Speaker B: And here we have two graphs kind of highlighting as we change the CBS radix and base levels, what happens to the performance in some kind of application. So we see that all the values over here on the right are about twice as large as those on the left because we have held all the other radix parameters fixed and we've doubled the number of levels. All right, so we've run tens of thousands of these experiments, gone through and picked out parameters that work the best for us. And what is all this bias? So we're going to compare TFHARS and its comparison operation. The nice little apple tree that Rabatol showed earlier, running at 128 bit security compared to sunscreen running with circuit bootstrapping at 80 bit security. And we also have slightly different notions of correctness. So with programmable bootstrapping under TFHRS, they guarantee an error rate of 2 to the minus 64.
00:16:23.504 - 00:17:02.577, Speaker B: Conversely, with sunscreen running at 80 bit security, we have an error rates of 2 to the minus 63, after we have done a circuit bootstrap operation and run a depth 512 mux tree, which is pretty deep actually. And what we see is that comparison operations, the whole thing that motivated all this. So again, we're running the apple tree on the left and we're running the hungry caterpillar on the right. Two very different looking things. But at the end of the day they're computing the same function and we are Circuit bootstrapping is 3.5x faster under this setting. Addition is even faster at 4.5x
00:17:02.577 - 00:17:41.835, Speaker B: and multiplication requires multiple rounds of circuit bootstrapping. So it doesn't have nearly as much gain at only 1.5x. But now let's look at, let's put this into some larger application that's more interesting than just comparing two numbers. So we're building a first price sealed bid auction. And if you're a computer science person, you can think of this as you have an array of integers, find the index of the maximum value. Again, we're comparing TFHRS at 128 bit security with programmable bootstrapping to sunscreen with circuit bootstrapping at 80 bit security. And we have the same kind of error rates as we had before.
00:17:41.835 - 00:18:15.755, Speaker B: And what we find is that at 64 bits with 16 bit precision, sunscreen is 5.7x faster. At 128 bits it drops to 4.6x. 256 bids, it's 4x and 512 bids is 3.5x. And this results this kind of decreasing speed up results from Gustavsson's law. As more parallelism becomes available, the larger you make the option. And the programmable bootstrapping algorithm has more parallelism to exploit and starts to catch up.
00:18:15.755 - 00:18:59.131, Speaker B: So some takeaways from all this. Programmable bootstrapping has been kind of one of the most common, commonly researched techniques in tfhe. But it's by no means the only way to perform computation with it. Not all apps require extremely low error rates, so maybe you can drop your error rates by few orders of magnitude. So from like 2 to the minus 64 to the 2 to the minus 50 or something like that. And not all apps require 128 bit of security in particular for short lived little things like an auction where you run the auction, you decrypt, you threshold decrypt the answer. And now it doesn't really matter if everyone's bid's revealed because the auction is over.
00:18:59.131 - 00:19:51.515, Speaker B: So in this kind of setting, maybe you can get by with less security, such as 80 bid. Under these kinds of conditions, circuit bootstrapping can outperform PBS by quite a bit. Unfortunately, using CBS is extremely hard for kind of asinine technical reasons. You have three different type of types of ciphertext you have to worry about and convert between. You have to worry about how much noise you have at what stage of your computation, and so on and so forth. Sunscreen's been building tools to make managing all these problems easier and building applications that you can use CBS significantly easier to do. And we expect that this work will become more relevant and more important even in the future as accelerators come online and expose even more parallelism available for the system to exploit.
00:19:51.515 - 00:20:04.595, Speaker B: And with that, I'll take some room for questions, I guess, and throw that thing on the ground.
00:20:09.175 - 00:20:22.715, Speaker C: Yeah, please wait one second. Yeah, you were a bit faster than I anticipated, so yeah, please go ahead. So what tools did you build for making this easier for engineers to use it?
00:20:25.655 - 00:20:43.755, Speaker A: Yeah, so when you're working with circuit bootstrapping, it's very unlikely you can actually write the low level operations yourself. So you really require some compiler that abstracts away most of the fhe specific parts for you. So we've been working on a compiler for our version of the TFHE scheme.
00:20:45.175 - 00:20:46.915, Speaker C: What's it called?
00:20:47.935 - 00:20:49.355, Speaker A: Sorry, what's what? Color?
00:20:49.655 - 00:20:53.583, Speaker C: How it's called that? This compiler, does it have a name?
00:20:53.639 - 00:21:03.405, Speaker A: We haven't, we haven't named it yet, I'm sorry to say. Yes.
00:21:07.625 - 00:21:09.671, Speaker C: You compared your system with 80.
00:21:09.744 - 00:21:17.645, Speaker B: Bits of security to tfhe with RS with 128. Is there a reason you couldn't parameterize tfhe with 80 bits as well?
00:21:18.265 - 00:21:52.831, Speaker A: So that's a funny question. And we knew we were going to be asked this by somebody because it's a totally fair question to ask. I would ask it as well. So we did spend some time trying to get TFHE with programmable bootstrap to have a suitable error rate for 80 bits of security. But frankly, the simulations and the modeling took too long. So I'm gonna go off of what I've seen from Flashbots work where they were playing around with TFHRS, they dropped the security to 80 bits. They expect about 30 to 50% improvement, which would still not account for what we see there.
00:21:52.831 - 00:21:58.755, Speaker A: So certainly tfhrs with programmable bootstrap would improve, but it's not going to improve by 5x.
00:21:59.215 - 00:22:00.315, Speaker B: Great, thank you.
00:22:06.735 - 00:22:32.465, Speaker C: Anyone else? We have a bit of time. Don't be shy. Okay, so we're just going to take a few minutes break to wait for the other stages. But yeah, stay around if you want to follow up with the next talk of this fhe segment with Michelle just after. But thank you very much, Rabital and Rick.
