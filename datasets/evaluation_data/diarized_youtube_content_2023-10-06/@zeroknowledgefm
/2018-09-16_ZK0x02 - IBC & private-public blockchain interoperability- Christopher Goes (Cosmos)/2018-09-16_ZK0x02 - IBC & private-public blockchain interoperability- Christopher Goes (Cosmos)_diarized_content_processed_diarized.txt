00:00:09.130 - 00:00:44.310, Speaker A: Afternoon. My name is Christopher goes. I work for Cosmos and also Cryptium labs, and I will be talking about inter blockchain communication, or IBC, and how we might be able to use it to enable public private blockchain interoperation. So a little bit about this talk first to lay the groundwork. IBC and Cosmos get conflated a little bit, which is partially our part. But IBC is a protocol, so it's separate from a particular implementation, a particular network. Anyone can implement IBC in their blockchain state machine and communicate.
00:00:44.310 - 00:02:21.530, Speaker A: As I'll explain in a bit with other blockchains implementing compatible IBC, I'll go over our design goals in constructing the IBC protocol, hopefully manage to explain a rapid version of how to do it yourself on your own blockchain, and finally walk through an example of using the inner blockchain communication protocol to connect the Ethereum and Zcash blockchains to allow you, if you hold any ERC 20 tokens, to send those ERC 20 tokens through IBC over to Zcash, spend them privately using the zcash ZK snark circuit, and then perhaps later, perhaps not send them back to Ethereum where they would convert into the original ERC 20. But before we get to that fun demo, I'm going to tell you how it works. So what inter blockchain communication interblockchain communication is a mechanism first and foremost for relaying data packets between two chains which we'll call A and B off chain relayers. So perhaps a server in the cloud on your desktop, it doesn't matter, are responsible for watching the first chain chain A and committing IBC packets which are sent so published to chain A in a cryptographically verifiable way sent to chain B. When published to chain A, they contain some destination data which will allow these relayers to figure out which chain B they should publish the packets to, and therefore route the packets correctly. I'll get to that in a bit. These relayers, importantly are not permissioned, so there are different kinds of fee models you can implement on top of IBC to properly incentivize everybody.
00:02:21.530 - 00:03:14.362, Speaker A: A very simple option is simply that the person sending the sequence of transactions sending the asset over into blockchain communication pays the fee to relay relays themselves. Other options include fee payment in the sending transaction that goes back to the relayer so that maybe a central group of relayers could relay very efficiently. The IBC protocol is payload opaque, so just like say, the TCP IP stack does not define the data payload for the layer on top of it. IBC only defines ordering semantics and sort of correctness semantics for packet delivery. It does not define what the application does. So any kind of application invariants you might want to implement on top of IBC, you can do so, and you can implement these invariants because IBC messages are authenticated. So it's not just that we're sending data from one chain to another.
00:03:14.362 - 00:04:21.040, Speaker A: That would be useful, but much more useful is the ability to provide guarantees across the combined state of two chains, or maybe even end chains. So we have some rule set, right? We have a rule set on the second chain, chain B, and that rule set defines a subset of packets, published packets, from chain A to chain B, which chain B will accept. We can make whatever rule set we want, and the IBC protocol defines a rule set which will be executed in the state machine of chain B. That gives us a lot of really useful guarantees, which I'll get to in a bit. But at the very high level, we know that if a packet has been received on B, so IBC relayer committed a transaction on the second blockchain B, and a transaction succeeded, then we know something about the state of a on chain B. We have some guarantee that chain A, when this packet was sent, had some state, because chain B verifies a proof, you want some way for the state machine. So independent of any trusted relayer, no trusted user, only the state machine of chain B is required to verify the proof that this packet was sent on chain A.
00:04:21.040 - 00:05:21.678, Speaker A: There are different ways you could verify that proof the way we're planning to implement it initially, not quite a bitcoin style like client, but if you're familiar with the bitcoin like client model, it's pretty similar where you have Merkel state proofs for substate. So the IBC packet will contain a proof that it was successfully published on Chain A, and then when chain B receives the transaction which attempts to send that packet to chain B, chain B will check that proof, check the Merkel path, and assert that it was in fact included in a trusted header of chain A. Another way of doing this, which I'll touch upon later, would be an intermediary peg zone. So sometimes you might not have the option to change the state machine of chain B. If you're working with a capable contracting language on top of a VM like the EVM, you definitely can. But if you want to utilize IBC with an existing chain where you can't change a state machine at all like bitcoin or zcash, or perhaps a chain where you just have less control. You might want to use something called a pig zone.
00:05:21.678 - 00:06:08.194, Speaker A: So what must you trust? For IBC, this is integral. You trust the consensus algorithms, and you trust like client verification only. But if and only if those two are correct, can you assert all the invariants that IBC will allow you to assert. Use cases. So the basics, as I've alluded to, IBC will allow you to transfer tokens, fungible tokens, non fungible tokens, possibly other kinds of tokens across multiple chains. You can conditionalize contract execution on Ethereum or transaction output locking, perhaps on bitcoin on the state of another chain. So you could say that some contract on Ethereum can only execute if bitcoin was sent to such and such address and ZCash was sent to another address.
00:06:08.194 - 00:07:09.766, Speaker A: You can conditionalize on the state of multiple chains at once. In some ways, IBC is like sharding. There are many sharding proposals, but it would allow you to split and parallelize the contract logic against multiple chains with compatible virtual machines, so you could shard the code of your contract onto different chains. IBC exposes a channel like primitive if you've ever worked with Golang, or another language which exposes a channel on which you can send and receive, in which sort of blocks, or so to speak, you could write contracts using channels that would translate into lower level IBC calls. You can compose hybrid state machines with different VMs, so you can't really shard a contract against different VMs, but you can still have a sort of virtual contract on top of multiple chains which ends up using different underlying state machines. So Evm, cosmos, and zcash, for example. Another example use case we're really interested in is delegated security.
00:07:09.766 - 00:08:13.418, Speaker A: So since IBC provides proofs of actions on one chain to another, you could use IBC with multiple proof of stake chains to delegate the security of one chain to another. What does that mean? That means that if a validator permits a protocol fault, an attributable protocol fault on one chain, then that chain sends an IBC packet over to the other chain. Maybe a chain with more value at stake, or a chain where all the validators sort of agree to use as a consensus point, and the validator can be slashable on that chain. So even if the chain which you're sort of running your VM on maybe doesn't have as much value at stake, or doesn't have as much security, if you can get your validators to agree to accept being slashable on another chain. That process can be conducted in a verifiable way over IBC. So the key point is that IBC allows for heterogeneous chains. It's not a sharding proposal to split the same chain into multiple pieces and paralyze execution that way.
00:08:13.418 - 00:09:12.294, Speaker A: It's a sharding proposal to split any number of chains into any number of pieces and paralyze or don't paralyze whatever you want. And the advantage of that, we think, is that sovereign chains can have really custom and maybe really risky features. Right? Bitcoin didn't want to add zero knowledge proofs because they were kind of untested crypto, which is a reasonable concern. You don't want to put the bitcoin network at risk. You don't want infinite inflation if the trusted setup was compromised. But this way, with IBC, you can elect to send your assets to the chains which have the features you want to use, make use of them there, send them back or not, and choose which rich profile you want to accept. So how does this work more concretely with implementing what we'll say is a cross chain contract or a model across multiple chains at once? You want to be able to preserve invariance, contract invariance across the combined state of several chains.
00:09:12.294 - 00:09:54.566, Speaker A: So let's say you have a fungible token, which is defined by any number of units of that token being exchanged for any other same number of units. It's fungible and a finite total supply. So you can't mint tokens out of thin air. And maybe you can delete them, but you can't delete them. For the simple example, how would you do that over IBC? So the IBC send packet on chain a would burn the asset or escrow it, perhaps. So if you want to send an EFC 20 token, you would have a contract on Ethereum, and you would send your tokens to that contract which would then escrow them in the contract until later. And it would provide an IBC send proof that those tokens had been escrowed.
00:09:54.566 - 00:10:40.730, Speaker A: Then on chain B, when the IBC packet is received, you can mint what we'll call T vouchers. So T vouchers are another token. They're a native token of chain B, which could have like a different rule set, although it needs to have the same basic fungibility guarantees. And then later on, when you're done with chain B, you've done whatever you want to do there. You can burn the T vouchers on chain B and redeem the previously escrowed t tokens back on chain A. So one interesting question here is which is really the voucher? IBC does not natively have as a protocol one canonical chain or any canonical chain. So is it the asset t on chain a? Is it the t vouchers on chain B, which was original? Nobody knows.
00:10:40.730 - 00:11:46.910, Speaker A: The state machine of B, of course, must verify that the state machine of a actually burned these tokens. So there are different ways to do this. The way we will implement initially in sort of the cosmos IBC implementation will encapsulate most of this knowledge in the state machines themselves, right? So when we write an IBC connection on chain B, we will know that the IBC send can send a state machine on chain A, execute such and such logic, and will know that it burns the tokens. That is a little limited in that it precludes implementing connections in certain orders. Because you have to know that beforehand. You have to know that when you're implementing the IBC connection on chain B, what type of packet corresponds to burning t tokens on chain A? Other future options for less limited versions would involve some degree of compatible VMs where you could verify the code itself. So if the code as it is in ethereum, is accessible in state, and you can prove that some certain code is at some certain address, then you could have more dynamic connection and reconnection logic.
00:11:46.910 - 00:12:56.066, Speaker A: So after a burns T in either case, when sending the IBC packet, a writes some data to approvable store, miracle store most likely, and then B can verify the light client proof of the written data. I'll get to exactly what the data is in a second, but the important part is that the data couldn't have been written if t hadn't been burned, right? That's the guarantee you want on chain B. You want to preserve the total supply across both chains. And to do that you need to know that when you're minting these vouchers on chain B, you burned the vouchers on chain A. Okay, so IBC implementation concept one connection connection is the set of data stored in consensus state necessary to verify packets between two chains. So to open a connection between two chains, you need to start with what we call a root of trust. A root of trust could be a genesis block, an initial validator set at connection creation that needs to be defined when whatever you're using to implement the IBC connection is deployed, which might be a smart contract, which might be a governance software upgrade, which might be something else.
00:12:56.066 - 00:13:49.250, Speaker A: Any connection user, notably, can check the root of trust, so someone has to decide what it is, but anyone else who actually uses this connection can verify that it is what they expect. Then you want to once you start with your connection, update headers. So to verify Merkel proofs in subsequent blocks of packets that have just been sent, you need new headers from the source chain to verify that the packets have been proved in state. So you need some function which allows you to verify an update from header set one to header set two. With tendermint, this function tracks the validator set and checks that 67% of stake has signed the next validator set hash. Subsequently, there's some fancy bisection ways to make that faster if you have infrequent IBC packets, but the essence is simply that you check that each governing stake of the proof of stake network signed the next update. Then you know to trust the next header.
00:13:49.250 - 00:14:43.682, Speaker A: In Nakamoto consensus, the previous chain continues with most work seen as long as it extends that sequence of blocks. Headers allow for packet proof verification, as I mentioned. So closing a connection usually you don't need to close an IBC connection. It can remain open forever, and if you want to continue sending packets between those two chains, there's no need to open a new one. However, in exceptional cases you might need to do so if there were a fork, depending on whether the connected chain was proof of work or proof of stake, this varies, or if there were a safety violation where some chain committed a protocol fault, maybe signed two valid histories. In the case of proof of stake, what and how this must be done depends on the kind of byzantine event that occurs. So if it's some identifiable fault, it could be easily done automatically.
00:14:43.682 - 00:16:23.800, Speaker A: If two headers two valid headers at the same height for tendermint consensus are both published to the IBC contract, you know that a protocol fault has been committed and you can close the connection and stop any further packets from being transferred. So on top of a connection we have messages, and IBC implements a vector clock for two processes, which in our case are blockchains, and then messages can have ordering guarantees over this vector clock. So if we have two chains, a and B, some packet counter I, x and y events on these two chains, which are other transactions, we know that if a sends packet I before b receives packet I, b receives packet I before a gets a receipt for packet I, a sends for packet I before a sends for packet I plus one, and those three things are all guaranteed by the state machines we implement IBC in, right? So we implement that q logic, which I'll get to in a second. Then we know that if x is before a send packet I, x will be before b is received packet I, and if y is before b is received packet I, y will be before a gets the receipt for packet I. And you can see that we can provide counterfactual proofs for how total supply is conserved this way. This is generalizable, although we probably won't do it initially. But it's generalizable to an end process vector clock if you want to order events between multiple chains so that you might all construct a packet sequence so that you would always know that a event A on chain A happens before B on chain B happens before little C on chain C.
00:16:23.800 - 00:17:15.430, Speaker A: So the ordering guarantee can be used to reason about the combined state of both chains as a whole with the example of fungible token total supply. If packet I is sent on chain A, then we burn the tokens. If packet I is received on chain B, we mint the vouchers, and we know because of that counterfactual there, we know that the tokens must have previously been burned on a, so total supply is conserved. Counters and metadata are used to prevent replay. So replay is a concern with IBC because these packets are just data, right? You send a transaction to chain A, which provides an outgoing proof for packet I to chain B, and then that proof is some data. So we only want that proof to be usable once on chain B and chain B only. And we want chain B to know that it came from chain A.
00:17:15.430 - 00:18:27.626, Speaker A: How do we do that? We have four queues, so each chain for each chain A has two queues, one for outgoing packets from A to B, each storing the packet information so it can be proved with a merkopath, including a sequence counter, and an incoming queue for receipts sent from B to A to acknowledge outgoing packets. Chain B has the reverse set of queues, outgoing packets from chain B to chain A and incoming receipts from chain A to chain B. Each queue keeps a counter, and packets can only be sent and received in order. So the state machines on chain A and chain B check that if I'm receiving packet I on chain B that I've already received packet I minus one, and I won't accept packet I plus one till I've seen packet I. Each IBC packet is a five tuple, including a type. So this is used from multiplexing, which isn't important for understanding the protocol, but it easily allows you to reuse a single connection with multiple applications. A sequence, which is the ordering guarantee to prevent replay of the same packet on the same source and destination chain, the source chain which is prevent masquerading.
00:18:27.626 - 00:19:41.094, Speaker A: So you don't want it to be the case that I could pretend to be sending a packet from chain C to chain B, when in fact the packet came from chain a, the destination which prevents the same thing except for replaying on another chain where you masquerade a packet which was intended for B, but instead attempt to confirm it on chain C instead, and data which is the opaque application specific payload. So these, combined with the queues give you the guarantee that packets are committed once, exactly once, in order from only one chain to only one chain. Receipts, acknowledgments and timeouts. So an IBC receipt is an IBC packet back to the source chain which proves the original packet was received and acted upon, right? So what that means depends on your application. In the case of the simple fungible token example, it means that some vouchers were minted on chain B, and then once chain a gets that IBC receipt back, the receipt is just a standard packet. We call it a receipt to distinguish its use case. Once chain a gets that receipt back, it can delete the data for the markle proof, and it can also do some safety things with regards to asset escrow, which I'll get to later.
00:19:41.094 - 00:20:48.454, Speaker A: The IBC timeout on the source chain will allow you to specify in an IBC packet as an additional field. This is optional a timeout T which can be specified as a block height or as a timestamp if you have a consensus timestamp relative to the destination chain state. So in the state of chain B, the destination chain, if you want to implement this safety safely, needs to reject packets past t must be proved back to the source chain if you want to be able to release assets. So one concern with IBC is what happens if chain B is censored or offline, or the transaction fees are super high, or for some reason you can't get the receipt packet. The destination packet confirmed on B and timestamp allows you to guarantee that if that doesn't happen, you can still get like a header proof from chain B that the timestamp was past something and that this packet hasn't actually ever been confirmed. And then you could re release the tokens you escort on chain A and try again. Why? What does IBC give you? First, it gives you one asset.
00:20:48.454 - 00:21:39.514, Speaker A: Many chains assets can be freely transferred. Send your bitcoin from bitcoin to Ethereum to Cosmos to zcash. Then back or not, it's always the same at bitcoin. We're not creating new assets here through that path, going back through zcash, through Cosmos, through Ethereum, and then back to bitcoin. You can always get your vanilla bitcoin back, assuming all those chains are working as usual, or maybe even through another path. If people are willing to exchange IBC assets created through a slightly different path, which we expect to happen. Multi hop routing can reduce the implementation cost, since as long as the APIs between different blockchains implementing some subset of IBC like IBC for fungible tokens are the same, then you can route your IBC packet through blockchains which implement connections to the other chains you want to get to.
00:21:39.514 - 00:22:29.820, Speaker A: As long as the path exists and it's permissionless, you can set up a chain, implement IBC with an existing asset, and add new features without asking anyone's permission, which we think is an important characteristic. New features old security when you need privacy, send your bitcoin to Zcash. If you want maximum security, keep it on the bitcoin chain. You need to be a little careful if you're doing this kind of transactional style IBC about linkability Zcash has a great blog post on this. The linkability of something like transparent shielded over IBC is basically the same as the linkability of transparent shielded just on the zcash chain. So when you send your assets to Zcash, which is the example I'll get to in a seC, they initially start out as transparent, and then you can shield them and transact them as shielded. But when you send them back over IBC, they become transparent again.
00:22:29.820 - 00:23:36.702, Speaker A: Doing it this way using the zcash example, there's no trusted setup risk because the IBC contract on the bitcoin or on the peg zone can track the total supply in or out every time a packet is sent or received, which escrows or unescrows tokens. And so you know, as long as you keep if you don't trust the trusted setup if your bitcoin is on the bitcoin chain, you don't need to accept the risk of inflation, but anyone who trusts the trusted setup can elect to send their bitcoin to zcash and accept that risk. Risk is always opt in. These guarantees are generalizable for most kinds of assets you would want to transact over IBC, and also other more complex contracts. Opt in upgrades this is one thing I am most excited about. There are lots of really interesting governance proposals coming out few of them so far feature minority protections. But there is a way, or an interesting possibility of a way to do chain upgrades over IBC or some part of the IBC protocol which would not require governance and which would provide full minority protections.
00:23:36.702 - 00:24:13.978, Speaker A: So to do this, you would copy let's say I want to change bitcoin. I would copy the bitcoin chain. I would add some new features and create an IVC connection back to the old chain. I wouldn't make a new asset, but anyone could elect to move, and perhaps this is bitcoin to bitcoin through a Cosmo zone, move their existing assets to the new chain if they wanted to, or they could keep them on the old chain. Security. Why that's the concern, right? Is security. So what if the new chain isn't mined by a lot of people or doesn't have a lot of value at stake? With simple proof of stake, it's just less secure initially and you accept that risk.
00:24:13.978 - 00:25:10.442, Speaker A: But it will be more secure as the staking token moves from the original chain to the upgraded chain with delegated security. As I mentioned earlier, since if the new chains validators accept being slashable on the old chain over IBC, then you get the same security because the same value is at stake in proof of stake, no need for a new asset and both chains can peacefully coexist. If half the stake of a proof of stake chain slowly moves over to the new chain of IBC, you end up with two proof of stake chains which can continue on their merry way. Consensus requirements let me quickly check time. Okay, I'm okay. Consensus requirement state finality IBC safety requires finality, otherwise coins could be double spent. So where in the consensus landscape can we work this in? Tendermint and similar PVFT have instant finality, so as soon as a block is confirmed we know it's final, we can send an IBC packet.
00:25:10.442 - 00:26:26.818, Speaker A: Casper FFG has fast finality Nakamota consensus into which I would class proof of work and Tezos and the latest proposal of Orobos preyos that I've read proof of stake have probabilistic finalities, so you need to pick a threshold and a number of blocks after which you accept a transaction and thus an IBC packet is final. You can vary the threshold if you want to based on the transfer amount, which might correspond to risk in your threat model. Proof verification which is a state machine concern with smart contracts with a custom state machine you can do this natively so you can implement all this IBC logic in your state machine, but if you want to use an existing chain without smart contracts, you might need to use a peg zone. What is a peg zone? So a peg zone is something called an accountable federated peg. Federated pegs were kind of all the rage a few years ago, and then they seem to have fallen out of fashion. But the main difference between what we conceive of as a peg zone and some of the previous proposals is that all of the peg zone validators are accountable and splashable if they do anything wrong. So to do this we need a multi signature which could be weighted or KfM depending on the chain.
00:26:26.818 - 00:27:16.386, Speaker A: On the peg chain you want to join with the zone. So on bitcoin or on zcash in the future. This might be a multiparty ECDSA protocol which has some nice advantages, but those are not quite production ready yet. Then you have a second tendermint chain which has the same validator set as the multi signature account. So transactions which are committed to the second tendermint chain must be signed by the multisignature and then can be relayed to the main chain, to bitcoin, or to zcash. Transactions which were signed but not committed to the bridge are attributable and are slashable, or transactions which were not committed but were signed are also attributable and slashable. And depending on the multi signature update, if you have a k of m or a weighted is a little different, but you could also slash for failure to update the multisignature if the validator set has changed.
00:27:16.386 - 00:28:54.022, Speaker A: And there aren't as many concerns about slashing in cases when a transaction has to be confirmed because the people you're slashing are also the validator set of the chain, so it's not in their incentive to censor themselves. And you can configure on this peg zone how many confirmations you treat as confirmed for the purpose of IBC proofs to other chains. So an example how you would use this to join the Ethereum use IBC to join the Ethereum chains and the zcash chains to convert your ERC 20 tokens to and from zcash user issued tokens what are zcash user issued tokens? Zcash user issued tokens are a super cool proposal, and hopefully someone from zcash here can correct me if I get anything wrong, but I did read the latest version of the issue which would implement bitcoin style colored coins on zcash or something very similar. This is not in sapling sadly, but hopefully will come pretty soon and alternatives to this exact example you could implement without a new circuit would be a zcash fork per ERC 20 token which exists just for that token, or implementing zcash, the asset as an ERC 20 contract on ethereum. How do you do this? So first you need to choose how to associate each ERC 20 token contract with a unique UIT identifier, which we presume to be some string. An easy way to do that is IBC ethereumcontract address, and that way of doing it has the advantage that you can create this identifier lazily on demand. So you can implement this whole system without knowing which tokens you're doing it for.
00:28:54.022 - 00:29:26.782, Speaker A: You can just do it for Ethereum tokens generally. Then later on add whatever tokens or new tokens which are created after you implement the peg. So this will allow you to take ERC 20 token vouchers on the zcash chain which are user issued tokens, and do anything you would do with the user issued token on the zcash chain. They can remain shielded. They can be shielded transferred. You get the full privacy properties of the zcash circuit. But then if you want to take them back to Ethereum, maybe there's some Ethereum specific ERC 20 interaction.
00:29:26.782 - 00:30:23.182, Speaker A: With another contract on the EVM, you can convert them over IBC back to the original ERC 20 tokens and do so. What components do you need to implement this? You need a dedicated smart contract on Ethereum that holds the ERC 20 tokens in escrow when people deposit them in order to redeem the vouchers on zcash. That contract provides the proofs that we talked about earlier, the proofs necessary for the IBC packet that some amount x of some token y has been escorted on Ethereum. Then in the peg the peg zone, you verify proof that the user issued token has been burned, and you release the escrowed ERC 20 tokens on Ethereum when you send the Uits back from zcash. So some of the channel ordering semantics I talked about earlier are optional. IVC is a pretty modular protocol. You can take the pieces you need and leave the pieces you don't, and in the case of transfers, you don't need quite so much ordering.
00:30:23.182 - 00:31:17.034, Speaker A: It's fine if they're commutative. So the zcash multi signature peg chain is responsible for maintaining a multi sig account on zcash. And then the signer set of the multi signature account signs the tendermint chain, commits, blocks, verifies the proofs and any of the validators on this chain agree to be slashable if they commit an attributable fault. Signing the run transaction, failing to obey whatever is written to the picchain. So step one if I'm a user wanting to convert my ERC 20 tokens into zcash user issued tokens, what do I do? I send my ERC 20 token. We'll call that t on the Ethereum chain via the usual transfer call to the IBC smart contract. Then the IBC contract escrows that ERC 20 token and logs that escrow event in Ethereum state tree, including all the requisite information to mint the vouchers on the zcash chain.
00:31:17.034 - 00:32:11.922, Speaker A: So the sender, the token, the amount, destination address or public key on the zcash peg chain. What happens? We get this IBC packets, this IBC packet started by this transaction being sent on Ethereum. Then a relayer has copied the proof of that transaction, the event log over to the zcash peg chain, a transaction on the peg chain. Then the zcash peg chain verifies that proof. Once the zcash peg chain has verified the proof, the multi signature account signs a transaction which mints the user issued tokens on zcash in the amount that was proved in the original packet to whatever destination public key was provided. And then that person who had provided the public key, which could be the original user or not, can receive the user issue tokens, spent them as normal go pay. Some people pay perhaps for leased authority storage as was presented earlier.
00:32:11.922 - 00:32:54.686, Speaker A: Then once they're done doing that, if they're ever done doing that, they can send the back to Ethereum in reverse. So burn the UiT on Zcash which will need to be made transparent first. But that doesn't have any privacy implications because you have to do it to send it back over IBC anyways. Burn the UiT on zcash, submit the proof to the zcash peg chain, and then the IBC relayer will submit the proof of the burned UiT to the Ethereum smart contract which will unescrow the tokens and you now have them back on Ethereum. What are the properties of this model? It is permissionless, it's opt in. Anyone can implement it. For any token which chain to keep your assets on and when to move them is up to the asset holder.
00:32:54.686 - 00:33:29.166, Speaker A: No risk for the existing ERC 20 token in this case holders since the contract contract total supply. When the UITs are shielded on zcash, you get the full zcash level privacy, same level of linkability as the transaction addresses and the unshield as transparent addresses when you send over IBC. So you have to be careful about that. But the implementation is also scalable, the same logic. One peg chain can handle probably all of the ERC 20 token contracts that will ever be in existence. And tangerment will always be a faster consensus algorithm. Future research.
00:33:29.166 - 00:34:02.700, Speaker A: Again, let me check time. Okay, I'm going to speed through this. Speed through this. I'm going to take questions. So any questions? Yes, can you talk about 51% attacks on a peg chain? 51% attacks on a peg chain. So proof of work peg chain or a proof of stake? Peg chain proof of stake peg chain. So usually, at least in tenement proof of stake, the threshold is not 51%, it's 34% to halt or 67% to control.
00:34:02.700 - 00:34:41.586, Speaker A: And I'll just go back to my other slide. So what if consensus breaks? There are a few different ways and this could happen. You could end up so IBC cares about some notion of valid, and valid isn't maybe your notion of valid, but IBC's notion of valid is a chain that can provide like client proofs that verify. So in different byzantine scenarios, you might get no valid chain or you might get invalid chains. If the stake splits 50 50 on a proof of stake chain, you will get no valid chains. So no progress can be made. If you used IBC timeouts on the source chain, then any packets were in progress you can recover the assets for, but you'll end up with an asset split across two chains.
00:34:41.586 - 00:35:26.614, Speaker A: Right? So you'll have some ERC 20 tokens on Ethereum, some vouchers on zcash. Right? Now you just accept that risk. It would be possible to implement some kinds of fraud proofs, but that does impose pretty complex requirements on the state machines of both chains because they have to verify much more about each other. Governance on one chain, if the chain has governance could apply an irregular state upgrade and credit tokens at parity with balances on the other chain, right? So if the first proof of stake chain has governance, the second one halts the first one. Governance could elect to mint the tokens back for the holders of the peg token on the second chain. But that's not the ideal case. So we're still working on this.
00:35:26.614 - 00:36:08.318, Speaker A: Does that answer your question? Other questions you? No other questions. All right, big round of applause then. It thanks. So you can find the spec at that link. I'll post the slides. My email is cwgos@tenderman.com and I encourage you to check out the breakout on zero knowledge state transitions 1540 in breakout room two to continue discussion in this vein.
00:36:08.318 - 00:36:09.220, Speaker A: Thank you.
