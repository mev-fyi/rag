00:00:07.450 - 00:00:28.310, Speaker A: Hello, everyone. I'm Brian, and this is Jeremy. We're some of the founders of Risk Zero, which is what we're going to be talking about today. It's a general purpose ZK VM. Before I go into that, I want to talk a little bit about our team, because people always ask what our background is. We're all from Seattle. We met, like, years ago through the Seattle hacking scene.
00:00:28.310 - 00:00:57.118, Speaker A: Jeremy wrote one of the first Wi Fi crackers, or the first Wi Fi cracker. And, yeah, this is our third startup together. Before this, we were doing tensor compilers for AI and genomics and various other things like that. So we have a pretty diverse background. And our last project was also a fairly successful open source project. Okay, hopefully people are roughly familiar with the idea of ZKVMs. I'm going to explain how we think about it in a second.
00:00:57.118 - 00:01:33.370, Speaker A: But Risc five is a general purpose ZkvM. So when we say general purpose, we mean it can run arbitrary code. So zkvms as different from something like alios doing or Circom. These languages are DSLs that produce some kind of circuit, and then you run inputs through them. You get a proof out. When I think about what a ZkVM is, it's something that your circuit is the VM, and the program comes in as an input, sort of the key difference. There's sort of like three classes of ZKVMs.
00:01:33.370 - 00:02:00.690, Speaker A: I mean, they're all broadly similar, but you have bespoke virtual machines like Cairo and maiden. You have people doing zke Evms. There's a lot of those coming out these days. And then you have what we're doing, which is zk Risk V, or instruction set, that actually mirrors a real commercial instruction set. So people. Well, I guess it's not super, but. So RISC five, if people aren't familiar, is like arm.
00:02:00.690 - 00:02:48.450, Speaker A: It's a risk ISA variant, but it's like an open source chip, so they have a lot of verification tests that you can run on your chip, your fake chip. Okay, so Risc five or risk zero, the ZKVM, just like any other ZkVM, you have a circuit. The circuit here actually describes a RISC five microcontroller. And programs come in just like in any other system. But the format that we accept programs in is just a standard Elf file compiled for RISC five. I guess it's slightly not standard, but that Elf file can be generated through LLVM or GCC. And really, like any language and libraries associated with those languages can be run now in a zkvm context.
00:02:48.450 - 00:03:15.580, Speaker A: So we also have this system for interfacing with RAM in a read write manner. Syscalls, limited set of syscalls. And then we also have sort of accelerator units we can add. So we have a very specific fast Shaw 256 circuit that we are fans of. Yeah, so the project is open source. It's released under Apache two. The proverb and the verifier are available.
00:03:15.580 - 00:03:47.650, Speaker A: We have a blockchain integration demo you can see down in our booth. Currently it's on near. That's because it's very easy to port our verifier to wasm chains. So we'll probably support other WASM chains in the near future. We have some examples from different sort of verticals that you can see on our GitHub. And then we just did put out an article sort of explaining how battleship works. Hand it over to Jeremy to actually talk about how we create the sky circuit.
00:03:48.550 - 00:04:13.882, Speaker B: Hello everyone. 1 second. We just get this mic attached. There we go. All right, cool. So basically I wanted to describe sort of how we actually implement the RISC five sort of microcontroller inside of the fry based proving system. We also use plonk as part of it.
00:04:13.882 - 00:05:15.250, Speaker B: So I'm kind of going to walk into that in a little bit of detail. So it's going to be somewhat technical in that I'm going to make some assumptions that people are at least basically aware of how sort of stark based proof systems work. Before I get into that, I wanted to talk about sort of how time works, the sort of set of steps that occur in our VM's execution. So in a stark based proof system, the same sort of circuit is run repeatedly over multiple sort of logical time steps. And those logical time steps, the way that those actually execute arbitrary code in our case, is that at the dawn of time, there's an initialization. One thing to note, by the way, is I'm going to talk about how we emulate RAM using plonk. And one thing to note is that for every logical cycle or for every stark row, we allow one memory transaction to occur in that cycle.
00:05:15.250 - 00:06:08.574, Speaker B: And so at the dawn of time, the program is initialized and then we go into a phase where we basically load the ELf file into RAM. This is done in advance of executing anything. And this would be in the normal computer, a non VM. This would be done by the operating system loading the ELF into RAM. Right. Then we basically reset the chip, which sets all of the registers to zeros. And the program counter to the beginning of the ELF, at which point we enter into this sort of three cycle process by which the circuit loads an instruction from RAM, decodes it, possibly reads data from memory, does some computations, and then writes data to memory, updates all of its registers, and that continues until such time as it terminates by a special call, special instruction in RISC five that basically normally calls back into the operating system, at which point we consider the execution finished.
00:06:08.574 - 00:06:59.300, Speaker B: So this is sort of how we basically embed the RISC five process into the stark. So in terms of the stark's column structure. So the column in stark represents a portion of the witness that is variable. And there are sort of three different types of columns in our proof system, each of which is held in a separate merkel tree. The control columns are actually publicly known to both the prover and the verifier, and that's how we actually encode the data representing the elf binary itself. And the public columns also are used to control execution. So they contain flags as to whether it's in the reset phase or it's in the normal execution phase and that sort of thing.
00:06:59.300 - 00:08:08.790, Speaker B: The data columns basically hold the state of the actual Risc five processor. So, for example, the register state when you're decoding an instruction, how the instructions decoding breaks up into multiple fields and so on, and they basically perform the execution. Additionally, the data columns also hold the memory subsystem, so they also hold what we'll talk about in a minute, which is basically for every row, every time step, there's basically a memory transaction and a memory verification. And then finally, the last set of columns are basically used as part of the planck mechanism to verify the memory. And those have to be in a separate merkel tree because these can't be set until these have been committed, due to the way that planck sort of uses the five Shamir trick to do stuff. So basically, hopefully that will make a little more sense in a minute here. So I want to talk a little bit about the memory transactions.
00:08:08.790 - 00:09:08.342, Speaker B: So the way that we represent memory is that, okay, so in this case, what we have here is this is the witness, and this represents multiple cycles of time. And these are columns in the data section of the witness. And this represents sort of whatever the processor is doing with memory. So this is saying, okay, at cycle zero, the processor is going to write, because this write flag is one, the value 17 to address three. So we're writing to memory at address three. Then later we write subject to address seven, and then we read from address three, and then we write to address seven again, read from it, write, so on and so forth. So basically what happens is during, we actually sort of do the generation of the witness in two phases.
00:09:08.342 - 00:09:55.002, Speaker B: The first phase, we actually execute the risk five processor, and we produce these memory transactions. And there's no specific verification of the memory transactions. We just are recording, we just model ram outside of the proof system and we just record the transactions that happen. Then what we do is we resort all of the transactions so that they are sorted by address first and cycle second, and put them into a different set of columns in the execution trace. So what you see here is that these are of course, all the transactions on address three and all the transactions on address seven. They are all together because they've been sorted by address first and cycle second. And these are in cycle order.
00:09:55.002 - 00:10:39.574, Speaker B: Now what that means is that once you've sorted them that way we can verify that the memory traces are correct, that they represent a normal, actually functioning version of RAM. By just looking at local relations between multiple rows, specifically, we can basically say that, well, okay, if the addresses are the same, then it must be the case that the cycle is going up. And also, if we are not writing, if we are reading, then we need to have the data match the data in the line above. So that basically what happens is actually, this first one is supposed to be a one. Sorry about that. That's a one. So in this case, this was a read.
00:10:39.574 - 00:10:47.478, Speaker B: So it must match, must read, must match. This is a write. So it can be whatever it wants. This is a write, it can be whatever it wants. This is a read. It must match the previous line. Right.
00:10:47.478 - 00:11:37.786, Speaker B: So basically by doing that, we are able to make all of the checking of all of the memory transactions local. Now, of course, we also need to prove relevantly that these memory transactions, which are occurring in order and being used by the rest of the system to actually emulate the risk processor, actually match our permutation of these transactions. And that's exactly what plonk is designed to do. So plonk allows you to verify that two sets of data inside of a zero knowledge proof are in fact permutations of each other. And so in combination with the check that we do on the planck side, that these are permutations, this then verifies that all of our memory transactions are valid. So that's how we implement basically ram inside of the proof system. So I want to talk a little bit about how this system interacts with the outside world.
00:11:37.786 - 00:12:35.530, Speaker B: So in the case of the program code, that's initially loaded. And that's sort of part of a special set of columns that are known to the proverb and the verifier. But in terms of the program data, how does the VM talk to the host that's running it? How do you put your secret data into your system? How do you get secret data out of it? And so in order to do that, what effectively happens is that when you're executing the program in normal order, cycle order, when the guest, the VM, writes to some well known address, the host who's doing the emulation just notices that. And certain special addresses are just considered to be I o addresses. And so when there's a write that's written there, the host is like, oh, some data for me. Right. And so that's how you send data from the guest to the host.
00:12:35.530 - 00:13:08.490, Speaker B: For the host to the guest. We actually rely on the fact that if you looked at our constraints for the memory, there's no check about what the first read of an address that's never been written to is. So when you read an address that's never been written to, it can be any value you want at all. And so what happens is the guest simply, when it wants to get more information from the host, reads from previously unread addresses in a special area, the host detects that there's a read occurring there and just fills in the value with whatever the host wants to communicate to the guest. And so that's how we actually send the data from the host to the guest.
00:13:10.110 - 00:13:17.226, Speaker C: The guest is referring to your VM code, or guest is referring to the risk five code running in your.
00:13:17.328 - 00:13:40.914, Speaker B: The guest is referring to the VM and the risk five code running inside there. Yeah, we like to think of the. So we're trying to like anything running inside the VM is guest code, and it's running in the guest, and anything that's being run outside of the zero knowledge proof system is the host. So the guest is secure. The host is not to be trusted, necessarily, because if the guest code should.
00:13:40.952 - 00:13:43.794, Speaker C: Not care what the host is doing, doesn't even know there's a host like that.
00:13:43.832 - 00:13:44.178, Speaker A: Right.
00:13:44.264 - 00:14:23.010, Speaker B: Well, so generally, the guest code will want to do some verification of some property or whatever you're trying to prove. So, for example, for the battleship game, we have, the guest wants to verify that all the ships are positioned properly and that they don't overlap with each other, and that there's five of them and they have the right lengths and all these other sorts of things. So in order to do that, the first thing it needs to know is where are the ships located? You don't want to put where the ships are into your actual code that you're running, because that's known publicly. Right. By everyone. So the guest has to have some way of getting its initial data from the outside world. And so this is the mechanism by which we get data from the outside world.
00:14:23.010 - 00:15:07.050, Speaker B: And then thereafter, you typically would. Okay, so this represents basically the private data. And then what generally happens is that we have the notion of a journal that it's basically a special area of memory inside the VM that gets written to, that basically stores whatever the prover would like to publicly assert. So whatever. In this case, for example, it would be the hash of the battleship state or something like that. And so we just write that to a region of memory. Then we use our shaw acceleration circuit to shaw that up inside of the proof, and then that's output by the proof and comes along with the proof.
00:15:07.050 - 00:15:24.434, Speaker B: So effectively, the output of the proof, the public part of the output, only displays this sort of journal. So you basically decide what you want to make publicly available on the proof. That was pretty much the memory system as it is.
00:15:24.472 - 00:15:35.474, Speaker A: Right. We were going to have in the booth, we have this battleship demo. It was going to be. We were trying to make it high stakes. That part didn't get done. So we were really hoping you could bet on battleship here. Battleship.
00:15:35.474 - 00:15:40.086, Speaker A: But we'll have to wait for the next conference with that. I just. Questions. I'm guessing most of them are going to be for you.
00:15:40.108 - 00:15:42.234, Speaker B: That's right, yeah.
00:15:42.272 - 00:15:50.570, Speaker C: And so we have plenty of time for questions. We're going to try to sync up with the main stage, so take your time. They're about ten minutes late.
00:15:52.700 - 00:15:53.752, Speaker B: Yeah, go ahead.
00:15:53.886 - 00:15:55.476, Speaker A: How wide is the execution trace?
00:15:55.508 - 00:16:27.360, Speaker B: How many columns do you have? About 160 currently. By the way, this is all open source. You can go to GitHub and go download the prover and the verifier. Oh, yeah, that would have been good. But it's RISC. The number zero is our GitHub handle anyway. So right now, it's about 160 columns wide for the data portion.
00:16:27.360 - 00:17:07.132, Speaker B: But a lot of that right now is actually being used to do range checks via bit decomposition and a bunch of other things that basically, as of the invention of pluckup and some other things, obviously are a little bit old school, I suppose, I would say. And so we are currently in the process of working on a new version of the circuit that we anticipate will be significantly more concise in terms of the representation, the degree of constraints five. So we actually do have an expansion of four, basically for the start. Go ahead. Yeah.
00:17:07.186 - 00:17:14.560, Speaker C: For people less familiar with all the instructions, is it fixed width of code format or not?
00:17:14.630 - 00:17:15.056, Speaker B: Yes.
00:17:15.158 - 00:17:16.800, Speaker C: It's unrelated, but it's just.
00:17:16.870 - 00:17:46.148, Speaker B: No, totally. So the risk five, the question was the opcode for the risk five ISA, the risk five instruction set, whether it's a fixed size. And. Yes. So, Risc five, we picked for a number of reasons. One, it's a very small ISA. The necessary instructions that you required are very limited, but it has extensions, and it has a very principled way to add extensions.
00:17:46.148 - 00:18:10.630, Speaker B: So you can have or not have a multiplier, you can have or not have floating point. Right. It's also got a very simple instruction decoder. It's meant to be implemented in a very small amount of silicon. And while digital circuits and arithmetic circuits don't look exactly the same, they do share enough that it actually is innately a good architecture for implementing of existing architectures. Yeah, go ahead.
00:18:11.240 - 00:18:17.540, Speaker C: And the second one is for curiosity, what is your memory model in terms of addressability?
00:18:22.120 - 00:18:58.592, Speaker B: That's a very good question. Our memory. Oh yeah. So the question is, is the memory model, how does it work? Is it byte addressable? Is it word addressable? And as you notice, we have one write transaction per cycle. And so in order to make that have a decent amount of memory bandwidth, we actually write an entire word, or read an entire word at a time, and they must be read with alignment. Luckily for us, the risk five processor spec allows you to require strong alignment and fault if you're unaligned. So that works out very well for us.
00:18:58.592 - 00:19:27.180, Speaker B: So you can do read a byte or short in risk five instructs as well. But we read the entire word and then actually, by the way, that's also why we also have one. We have a read on one cycle and a write on the other, because if you want to write a byte, you have to read the whole word, modify the byte, write it back out again. Yes. So this is all sort of microarchitectural things. Right. But people who are familiar with ASIC design would certainly know all these types of things.
00:19:27.180 - 00:19:27.580, Speaker B: Anyway.
00:19:27.650 - 00:19:28.972, Speaker C: All right, time for one more question.
00:19:29.026 - 00:19:30.700, Speaker B: I would say go ahead.
00:19:30.850 - 00:19:31.550, Speaker C: Usually.
00:19:37.360 - 00:19:37.820, Speaker B: Yes.
00:19:37.890 - 00:19:41.944, Speaker C: Are there any limitation on what you can buy?
00:19:42.002 - 00:20:21.130, Speaker B: No, fundamentally, because we actually look like a RISC five processor, which is a standard kind of an ISA that's well understood by the industry. There's already versions of GCC that compile to RISC V, and we fully implement the entire processor spec. We are compliant. We pass all of the compliance tests made by the RISC V. We look like a completely real processor running inside of a zero knowledge system. So C plus plus, go rust. Now, we do have some standard libraries that do things like read and write to these magic memory addresses and then turn that into something that looks like operating system read and a write call.
00:20:21.130 - 00:20:35.932, Speaker B: There's some standard library support you want for your language in order to make it easy to use. But fundamentally, anything you can compile with LLVM, you can compile with our stuff. Sweet.
00:20:35.996 - 00:20:36.350, Speaker C: Thank you.
