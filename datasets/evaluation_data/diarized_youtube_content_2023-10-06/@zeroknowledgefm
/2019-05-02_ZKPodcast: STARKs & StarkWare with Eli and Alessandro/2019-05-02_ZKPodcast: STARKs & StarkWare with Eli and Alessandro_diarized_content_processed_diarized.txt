00:00:06.330 - 00:00:18.750, Speaker A: Welcome to Zero Knowledge, a podcast where we explore the latest in blockchain technology and the decentralized web. The show is hosted by me, Anna and me Frederick.
00:00:27.690 - 00:00:33.110, Speaker B: In this episode, we sit down with Ellie and Alessandra from Starquare to talk about starks.
00:00:44.030 - 00:01:35.510, Speaker A: First, I want to say thank you to this week's sponsor, POA Network. POA Network has published a threshold cryptography rust library that is used in their implementation of the honey Badger BFT consensus algorithm. It can generate a set of key pairs such that, for example, any four keyholders can collaborate to sign or decrypt messages, but fewer than four wouldn't be able to. Honey Badger BFT uses threshold signatures to encrypt lists of transactions for censorship resistance and to create random values that can be used as a defense against some attacks. To learn more about threshold cryptography and how to use it, check out the latest POA Network medium post@medium.com slash PoA minus Network so thank you again, POA Network. Lastly, if you want to support this show, or if you want to just get in touch, our links, as always, are in the show notes.
00:01:35.510 - 00:02:23.610, Speaker A: Now here's our interview with Ellie and Alessandro. This is an episode that we've been very excited about recording for some time. Starks first hit our radar when we were doing our research, I think around the first zero Knowledge summit, and it's come up repeatedly through our zero Knowledge series. So the episodes that we're doing on zero knowledge topics, I would say just for our listeners, this is a relatively advanced topic. So if you want some background into zero knowledge proofs, CK snarks, and maybe some other zero knowledge systems, check out the series on the menu bar at Zeroknowledge FM. But now let's start our interview with the guys from Starquare, Ellie and Alessandro. Thank you guys for joining us.
00:02:23.680 - 00:02:24.074, Speaker C: Thank you.
00:02:24.112 - 00:02:25.610, Speaker D: Thank you very much for having us.
00:02:25.680 - 00:02:35.118, Speaker B: Yeah, so maybe we should start with a quick intro. Do our normal thing of kicking off talking a little bit about yourselves and how you got into the blockchain space.
00:02:35.204 - 00:03:35.222, Speaker D: I'm Ellie Benzosan. My involvement in blockchain started many years ago, though I didn't know it at the time. When I was doing my postdoc around 2001 at MIT and Harvard, I started getting interested into something called the PCP theorem probabilistically checkable proofs. And it's a very mathy topic that's related to what later became to be known as the starks. And I've been interested in this topic ever since for the past 17 years or something like that. And slowly over time, what started off as very abstract mathematical theorems and understandings got reduced slowly into code and systems that are very relevant to blockchains because they allow one to solve problems like scalability and privacy in blockchains.
00:03:35.306 - 00:03:42.034, Speaker B: Did you come to it from a computer science background or a math background? Like, what was your angle into it?
00:03:42.152 - 00:03:42.722, Speaker C: Good question.
00:03:42.776 - 00:03:58.814, Speaker D: I was doing theoretical computer science, which is sort of somewhere in between. It definitely uses very mathematical formal methods, but to answer and address questions that are about computers and computation.
00:03:58.962 - 00:04:00.938, Speaker B: All right, Alessandro, how about you?
00:04:01.024 - 00:04:47.826, Speaker C: Okay. Hi, I am Alessandro Quiesa. I'm a faculty member at UC Berkeley, and I do research in complexity theory, theoretical cryptography, and applied cryptography. My background was initially first mathematics, so I did my undergraduate in mathematics, though after that, I switched to theoretical computer science for my phd. And ever since I have done research, I have been involved in research around the topic of probabilistically checkable proofs, which Ellie mentioned earlier, as well as cryptographic proofs, which use these tools to achieve strong privacy and efficiency properties, some of which are, again, strongly related to starks that we will discuss today.
00:04:47.948 - 00:04:56.380, Speaker A: So I'm very curious to hear, when did you guys meet? And how did starkware happen when we met?
00:04:58.270 - 00:05:30.966, Speaker D: So, it was summer of 2010. Alessandro. I was back then a professor at Technion. Alessandro was, I think, starting his PhD under Silvio Mikali at MIT, and he came to spend the summer at Technion, and we worked together back then with Iran. Boma was from Tel Aviv University, and Daniel Genkin, who was a student at Technion at the time, and we sort of started hacking at it. And it's been already eight years since then. A lot of fun.
00:05:31.068 - 00:05:39.400, Speaker C: Yeah, it was very fun. Eight years. And that was certainly a very fun summer. And also should keep thanking Ellie for hosting me then.
00:05:40.010 - 00:05:44.150, Speaker A: Was it then that you kind of realized that you wanted to do something like Starquare?
00:05:44.490 - 00:05:50.640, Speaker D: Hell, no way. It.
00:05:53.890 - 00:06:26.294, Speaker C: Would be an overstatement to say that we had a very fuzzy understanding of applications, and we were barely getting to the point of, okay, let's see if we can even sort of run this in a way that it holds on any nontrivial computation. Things were just too slow back then. We didn't know as nowhere near the number of things we know today about the entire space of applications and possible techniques. A lot has changed, even though we had a good place to start from.
00:06:26.332 - 00:06:47.278, Speaker D: But at least from my point of view, I had no clue in the world and no hopes whatever that any of that stuff would be even close to practical or interest anyone outside of academic circles and even inside academic circles. I had no idea why someone would be interested in what we were doing.
00:06:47.364 - 00:06:59.378, Speaker A: Seriously, that's amazing. It was just this, like, you guys were just very, like, there were very few people into this stuff, I imagine at the time. So it's like, oh, cool, there's other people doing this thing. I'm into.
00:06:59.464 - 00:07:02.274, Speaker D: I don't know what we were thinking when we started to implement it.
00:07:02.312 - 00:07:38.400, Speaker C: I don't mean it's curiosity. The challenge was great, actually. I remember when we submitted a paper about one of our early sort of works on PCP efficiency, and I still remember one of the reviewers from the conference that sort of commented on our paper as something like laying a siege on the problem of PCP efficiency, because the paper just gave off this aura of immense and possibly hopeless work on this problem.
00:07:40.850 - 00:08:01.714, Speaker D: Yeah, like two years or three years after we had so much work and we were able to prove a computation that does four operations where each one of the operations is do nothing. And it took the prover like 10 hours. This was after so much sweat and blood.
00:08:01.842 - 00:08:08.140, Speaker A: What was the beginning of Starkware? When did it start, and what is it for? What is Starkware there for?
00:08:08.510 - 00:08:44.206, Speaker D: So, yeah, let me just say briefly a little bit about the company we incorporated exactly one year ago. Four co founders, Alessando, myself, Michael Yatesev, who's the chief architect, Uikolodi is the CEO. By now, we're about 20 people in the company. Almost all of them are in engineering, and they are steeped deeply in math and writing. Good code. We incorporated to use start in order to solve scalability and also privacy problems. In blockchain.
00:08:44.206 - 00:09:26.138, Speaker D: We raised $36 million in two rounds of equity from a bunch of notable entities. Paradigm led our second round. We also got a sizable grant from the ethereum foundation. And our first move is going to be to deploy at the end of Q one, a solution for scaling dexes by putting a verifier on chain and the prover node being off chain. And later on we would like to offer starts for scalability, later on for privacy as well across multiple blockchains and in as many use cases as we can afford to put them on.
00:09:26.244 - 00:09:35.466, Speaker A: Are you looking into other, like, is Starks going to be the center of all of these systems, or are you also doing research on other zero knowledge systems?
00:09:35.598 - 00:10:13.630, Speaker D: Our focus is on starks, but we're, of course, deeply steeped into zk, snarks and zcash, and we're fully aware of other beautiful developments in our area, bulletproofs and recursive snarks and other things as we, I think, try to explain. We think there are some core attributes of Starx, the transparent nature, post quantum security, the efficiency of the prover and verifier that make them a really good kind of technology for solving scalability and privacy on blockchains. So that's going to be our main focus in the near future.
00:10:13.780 - 00:10:22.530, Speaker A: I have a question, sort of, for both of you. What got you originally into blockchain technology? Or when did that start to really come into your purview?
00:10:23.510 - 00:11:13.534, Speaker D: It was around 2013. 2014. And the culmination of that was the zero cash paper. The point was that if you try, we were already deeply building. I mean, both of us together were working since 2010 on implementing various kinds of proof systems, snarks, and what later became starks. And if you go around trying to look for examples where this makes sense and can be used in the conventional world of banks and healthcare institutions and so on, they are occupied by big trusted parties. And there it doesn't make that much sense to add this new technology as it does for blockchains.
00:11:13.534 - 00:11:48.462, Speaker D: And in blockchains, it makes much more sense. Or to put it more starkly, forgive the pun, if you go to people in the conventional world and tell them, oh, we have this new thing, your knowledge, proofs and so on, someone can prove something to others, then they will start asking, wait, who's going to prove what to whom? Is the bank going to prove to you that they're okay? Or the other way around? And if you go and talk to people in the blockchain space, they'll ask you, where's the code? When can we use it? Here are five things we need to do with it.
00:11:48.596 - 00:11:54.146, Speaker A: I guess the space is just like a perfect trial ground for all of this stuff. That's cool.
00:11:54.248 - 00:12:40.062, Speaker C: Yeah. I would second that. In that earlier on, the theoretical value of these notions of sort of proofs that certify long computations that are themselves very short and easy to verify, theoretical value was very clear. And so the potential use cases could in principle be many. But obviously you want to try to figure out which ones that are actually most compelling and clearest to the public that maybe could have more impact. In this case, an application to money was rather convenient because it is a notion that everybody understands. So it's always hard to look back and rationalize the way things go.
00:12:40.062 - 00:13:17.930, Speaker C: But I think it was maybe not too surprising that the first real application, which was the zero cash protocol, which both Ellie and I co authored with our other great colleagues, was something that not only was, I think, academically interesting protocol, it was the first time you could realize fully nine months peer to peer payments, but also it was an application that many other people found interesting and eventually sort of something that was born purely as an academic paper, eventually became a startup that also, both of us co founded also a few years ago, and eventually turned into something real.
00:13:18.080 - 00:13:21.162, Speaker A: And here you're talking about zcash, right?
00:13:21.216 - 00:13:53.606, Speaker C: I mean, the use of sort of highly efficient, and in this case, also private cryptographic proofs to do something useful. In this case was protecting sort of user privacy because it has to do with the notion that everybody understands money, then this is a great sort of place to start experimenting with this technology, as opposed to some, I don't know, potentially arcane notion of compliance between banks and governments. Who cares, right? I mean, it is important, of course, but it is much less of an easy story to communicate, I guess you.
00:13:53.628 - 00:14:28.580, Speaker A: Also don't have to worry about all the stakeholders and the politics that you'd have to play in order to get those other agencies on board. What you're talking about here is Zcash and the zero cash paper that you guys co authored about two months ago. We had Zuko on the podcast as well, and he told the story coming much more. He was definitely coming from, like, decentralized storage. And it was this zero coin paper that was his first turning point that led to this. Did the zero coin paper also cross your path? Was this something that also kind of brought you into the space?
00:14:29.430 - 00:15:44.998, Speaker D: So it definitely crossed our paths. And the zero cash paper is. In early talks, I often described it as the team of zerocoin meets our team, which was doing back then, ZK snarks. But we didn't wait for bitcoin or for the, you know, as is often the case in science, there are many different efforts that don't necessarily know of each other when they start. So, for instance, Alessandro and I and our co authors have been working on our stuff since 2010. And around 2013, which was before the zero cash paper, we sort of were trying to find places to market our, let's call them ZK engines. Right? It then dawned on us that decentralized cryptocurrencies back then, that was pretty much only bitcoin are an ideal place to sort of market this kind of technology and science, because the lack of trusted parties there really demands powerful cryptographic tools.
00:15:44.998 - 00:16:15.286, Speaker D: And then we did hear of the zerocoin paper, and I guess they also heard of us, and we immediately sort of approached each other. They knew much more about how bitcoin works for us. It was sort of a bit newer. We had this shiny new engine that we've been studying the theory of implementing the ZK snarks, and sort of was a match. I don't know if made in heaven, but, yeah.
00:16:15.308 - 00:17:06.194, Speaker C: In particular, one should acknowledge the zero cash paper was certainly each paper on its own is a contribution, and then zero cash may not have been possible without both the expertise and contributions of prior lines of work, one of them on anonymous digital cash. That includes both zerocoin and other papers that came before it, as well as on the other line of work. All this work on Zkesnarx, it was like a really great collaboration that led to greater efficiency and greater privacy, actually. So, for example, before zerocash, it was not known how to fully hide everything about a payment. But that's something that we did manage to design for zero cash. I wanted to ask if you were.
00:17:06.232 - 00:17:08.546, Speaker B: Ever part of the Zcash company.
00:17:08.728 - 00:17:41.166, Speaker C: Yeah, we are co founders and we took an active role in technology transfer at the very beginning. Obviously, we're also researchers, and so we didn't participate on a day to day basis. But at the conception and when you start a company, there is quite a bit of work that goes into that. Then you try to set it up in such a way that it can be successful through the energy and abilities of early employees, which it has been. And there's a wonderful team working at Zcash now.
00:17:41.268 - 00:18:06.678, Speaker A: Both the zerocoin and zero cash papers. This is all about snarks, which is where you guys were working. I guess that was what you were working on at the time. How did you get from snarks to starks? And I'm really curious about this. At what point did you decide, actually, let's put snarks kind of on the shelf and let's focus more on these Starks, which is like an older concept. Maybe we can also talk about the history of Starks in that.
00:18:06.764 - 00:19:07.398, Speaker D: Yeah, so it may seem from the outside that we were first working on snarks and deploying them in zcash and then moved on to Starks. But this is what maybe the public sees from the outside, from the inside was, if anything, the other way around. And also, it's a more complicated story. So Starks, go back to what's called PCP techniques, and both Alessandro and I have been working on them, actually, even prior to working on snarks, and we never gave up on them. And we never gave up on snark research either. What happened is that snark technology matured earlier and was deployed in zcash. And Stark technology has fewer cryptographic assumptions and hence is a little bit harder to actually deploy in practice.
00:19:07.398 - 00:19:09.418, Speaker D: Took a longer time. Yeah.
00:19:09.504 - 00:20:11.002, Speaker C: I would also comment that zero cache as a protocol doesn't particularly care what cryptographic proof system you use to instantiate it. What matters is that you use something as efficient as possible. So it just so happens that when it was written and when the company started, sort of the most sort of suitable primitive on the shelf was Zikesnarx. But we love all these cryptographic proof systems, and we try to improve all of them because so far, they have slightly different trade offs. Ellie already alluded to the fact that Starks sort of make parsimonious use of cryptography. And so we'll discuss this later how it relates to maybe post quantum security and other advantages, but because in Zika snarks, you kind of make a heavier use of cryptography, you could go farther earlier in terms of efficiency, and that's why they were kind of ready to go earlier. We still work on all these technologies.
00:20:11.002 - 00:21:20.294, Speaker C: And, yeah, right now, maybe there's an emphasis on starks. I should add that, at least in my case, I certainly felt greater personal motivation to make progress and research starks after the experience with Zcash, because it highlighted the difficulties of dealing with trusted setup in the real world. Just to remind the listeners in Zcash, because it uses Zksnarks, there's a need for a trusted party to conduct an operation at the beginning of time to generate system parameters to be used for proving and verifying. And this trusted party, if corrupted, could generate valid looking proofs for sort of false statements. And this is the reason why, in the real world, you get around this problem using sort of real world cryptographic ceremonies, where you distribute the responsibility of generating the system parameters to a collection of parties in such a way that only if all of them are simultaneously colluding, this would happen. But if at least one participating parties is honest, then the setup is secure. In Starks, there is no such thing.
00:21:20.294 - 00:21:48.606, Speaker C: You can just agree on a hash function, which is the only cryptography that it uses and deploy the system. So it was very compelling. The prospect of getting to the point where we have as efficient cryptography proof systems that we can just go and use without any of this mess. I certainly felt a great personal motivation to try to go after this goal that we were anyways pursuing already, but probably there was some sort of time dependency there. In terms of emphasis, I want to.
00:21:48.628 - 00:22:02.450, Speaker A: Know very before we dive in even deeper into Starks, where does Starks come from? We've talked about zero knowledge proofs and we've talked about the origin of Starks, but we've never actually talked about the origin of Starks.
00:22:03.590 - 00:23:16.074, Speaker D: Yeah, so I mean, starks go back to works in the early 1990s, pretty much some of the famous works of Babai researcher, a brilliant researcher from Chicago and Levine Segadi fort. Now from the early 1990s already pretty much said that using these new techniques that are called the PCP theorem and things related to that, you could already reach amazing scalability, in which once approver writes down a proof, the verifier can check it exponentially faster. And this holds actually for any reasonable, conceivable computation, formally for any language in nondeterministic exponential time. Sorry for the math terminology, but it means for any reasonable and conceivable computation, you could speed up the process of verifying it without any trust assumptions by an exponential factor. And this was completely mind blowing at the time. So this was already in 1990, 119 92, in fact.
00:23:16.112 - 00:23:53.890, Speaker C: Maybe just a short parenthesis, sorry, if you pull up the paper and there are certain sentences there that are very visionary. So here's one they state already in the abstract. A single reliable pc can monitor the operation of a herd of supercomputers working with possibly extremely powerful but unreliable software and untested hardware. This is hinting at this exponential speed up, where you have a single pc that by virtue of running a verifier, is able to check the correct computation of a herd of supercomputers, which are supercomputers. They have many more resources.
00:23:54.050 - 00:24:01.974, Speaker D: So already, back in the mid 1990s, it was known how to speed up the verification process exponentially.
00:24:02.102 - 00:24:02.538, Speaker C: Right.
00:24:02.624 - 00:25:00.620, Speaker D: But what took another, what is it, 20 years or so to reach was how to speed up the process of generating the proof so that the verifier could enjoy this exponential speed up in checking. And this took a pretty long while, and a lot of breakthroughs were needed along the way. And all of this culminated in the end in code base and systems that are what we call starks. So again, 30 years ago already, exponential speed up of verification was understood, but generating the proofs was a big challenge. It still is a challenge, but by now we've made enough progress to actually work with such systems that have a lot of other good benefits. They're plausibly post quantum secure. They have pretty efficient proving verification time.
00:25:00.620 - 00:25:21.970, Speaker D: They have no trusted setup and very minimal cryptographic assumptions. And the parts in them that are proven mathematically to be correct are rather a large portion of them. So they're very little or very few assumptions. And the assumptions are kind of pretty well understood.
00:25:22.310 - 00:26:06.914, Speaker B: I remember when, I think it was when Zcash was launched, I started digging into it, trying to understand how it worked, what it was. And I was watching several talks. I watched one talk on Starks. I can't remember if it was ule or Alessandro giving the talk. But anyway, it was a breakdown of sort of experiments with Starks and their performance characteristics and kind of going over how they work and the examples know. It was like, oh, well, yeah, I can see why this is not reasonable right now. Where it was like, oh, to do this simple computation, you needed 130gb of ram or something like that.
00:26:06.914 - 00:26:41.470, Speaker B: And it was just, like, not tractable. Whereas snarks, on the other hand, was completely reasonable to compute, but had this sort of toxic waste thing. Has Starks moved on from there? I know that we're not really talking about even that range anymore. I mean, it's already much better, as far as I understand then, compared to, I don't know how long ago this talk was, let's say, three years ago or what are the boundaries right now for starks?
00:26:42.050 - 00:28:06.710, Speaker C: Maybe to one high level point, there is that something that has changed quite dramatically since maybe, let's say, 2014, 2015, which is around when Zcash started, is that Ellie and I and our colleagues have introduced new models for realizing starks. So while in the 90s, you would build starks from these PCPs that Ellie mentioned today, the way you do it, you would rather instead design an interactive PCP or a multi round pCP. Essentially, it's a more flexible model within which you can achieve your exponential speed ups and within which it is much, much easier to, in relative terms, to make it so that the prover can generate these proofs for the verifier. And so while a few years ago, yes, we did have these prototype systems that would take hundreds of gigabytes of memory, that is some extent not the case anymore. We have much better constructions. And it's not just because more time has passed and we've written more papers, but also something qualitative has happened. There was an inflection point around 2016 where we introduced this notion, which we call interactive oracle proofs, denoting the fact that there is an interaction between the proof and the verifier.
00:28:06.710 - 00:28:31.550, Speaker C: It's just a model. Okay. Where these proofs are generated, and then this interaction gets compiled into, like, a shortened interactive proof. And producing the information for this interaction is much easier than it is for pcps. So the numbers we would have today, we don't know how to achieve with pcps alone. So this was something new that happened from the 90s. It's not just perfecting 90s technology.
00:28:31.550 - 00:28:33.458, Speaker C: It is moving sort of beyond that.
00:28:33.544 - 00:29:20.670, Speaker D: Yeah, it's important for me to add and stress that on this interview. Perhaps it's only me and Alessandro, but we have many very important co authors going a long way back. I mean, specifically, I want to highlight and mention the involvement and contribution of our co founder, Michael Liabsev, who did his phd under MIA Technion. And there are many other co authors that, of course, we're, as they say, dwarfs on the shoulders of giants. And this goes back a very long way. So I just don't want the listeners to get the impression that only those speaking on this podcast.
00:29:21.090 - 00:29:35.874, Speaker C: Yeah, far from. It. Also should highlight, Michael was a student of Elliott Technique. I should also highlight one of my students, Nick Spooner, who also played a major role in some of these works.
00:29:36.072 - 00:30:12.378, Speaker A: So we've started to talk about starks in comparison to snarks and some of the sort of new features of starks, just in terms of its usability. But I'd love to use some time to just dive into starks. You have gone on stages explaining starks. I can just imagine you have to do a lot of education and communication around this so that people understand what it is. How would you explain starks on a podcast with no whiteboard? This is the challenge of this episode.
00:30:12.474 - 00:30:52.254, Speaker D: Let's try to take this challenge. So I'd say, first of all, a stark is a special kind of a proof. So, first of all, maybe. What's a proof? Imagine you're going out of the grocery store and you're holding the receipt, and you're looking at it, and maybe summing up the items and checking if the sum that you were asked to pay is correct. What you are essentially doing is verifying a proof. The proof is the receipt, and it is a proof of computational integrity. It sort of asserts and proves to you that the sum you were asked to pay is correct.
00:30:52.254 - 00:31:46.202, Speaker D: So how do you verify it? You're summing up the items, and you're really just reexecuting the computation. Okay, but it's a proof. Now, for our listeners, who probably know about blockchains, let's jump to an analogy in the blockchain world. You want to verify that someone told you that over the past ten blocks, she earned, or she has gotten hold of ten coins. Right? So what would a receipt or a proof look for? That it would probably be something that has all of the transactions in the last ten blocks, and then some of them are highlighted with a marker. Those are the transactions that account for her funds. And then she would also probably need to prove to you that she controls the keys that hold those funds.
00:31:46.202 - 00:32:42.350, Speaker D: So it's a very long kind of receipt and would be very hard to check, and it would also compromise her privacy. And now you know a whole lot about her coins. So, okay, starks give you a way of generating a receipt for holding ten coins in the last ten blocks without showing you, first of all, which coins they are, and without giving you all of the information in the transactions that went there. But still you get the same assurance that it is correct. So it's sort of a very succinct receipt, very short, much shorter than the computation you would need to do to find those coins. And still it has the same level of assurance that everything is correct and has computational integrity.
00:32:43.190 - 00:33:03.318, Speaker B: So this is a good sort of high level overview and explanation of zero knowledge proofs, how they apply to these systems. But I'm curious to dig into more detail on what the difference is between, let's say, snarks and starks. Because what you just described can be achieved with either, if I understand it.
00:33:03.324 - 00:33:03.686, Speaker D: Correct.
00:33:03.788 - 00:33:33.578, Speaker C: Good point. So maybe one way to clarify the relation is to note that a stark is some extent a special case of a snark. Right? So it is a snark with extra properties that we like. Okay, what are these extra properties that they make this sort of subset of constructions particularly appealing? One is that the trusted setup is, to some extent, trivial. Okay? It's public. There is no toxic waste. You only have sort of public randomness.
00:33:33.578 - 00:34:12.638, Speaker C: In terms of concrete terms. In the real world, this public randomness would simply come from agreeing to use a certain hash function. For example, shut with d six or ketchup or Blake, some hash function that we decide to use to some extent, source of public randomness. Okay, so you see, this is a special case of trusted setup. Now, because the setup now looks like this, then it is very easy to deploy, because we don't need to do ceremonies to agree on a hash function. Now, because this is the only cryptography that a stark uses, you also get additional benefits. One of them is plausible post quantum security.
00:34:12.638 - 00:35:01.398, Speaker C: I say plausible because, of course, we don't know if and when new understanding and efficient quantum algorithms would prove otherwise. But this is normal in cryptography. When we talk about post quantum security. For any primitive, we mean plausible post quantum security. So why is it the case that using this type of cryptography could suggest post quantum security? It is because hash functions such as shattered six and ketchup, they don't use algebraic structure, for the most part, algebraic structure, which is typically what efficient one algorithms exploit to sort of gain speed ups over classical algorithms. So these are two advantages that pop right out from the feature that we're only using sort of these non algebraic hash functions in our construction.
00:35:01.494 - 00:35:36.962, Speaker D: I mean, one way to see a difference between a start and a snart is maybe to look at what the acronym means. So both of them have arc, in which pretty much has the same meaning. The letter n in the snark means non interactive, which means that it must be a one shot proof. In a stark, you don't actually require that you could have it be non interactive, but you could also have it be interactive. So not all starks can be snarks. That's one thing. Not all snarks can be starks, because the letter t stands for transparent, which means that you have no trusted setup.
00:35:36.962 - 00:36:14.078, Speaker D: And basically it only uses what's known as public randomness. So there are some settings in which a start can be a snark and a snark can be a start, but the differences are very important. Start requires no trusted setup. That's one of its core properties. Whereas a snark requires it to be non interactive, only a one shot message. So that's essentially the difference between a stark and a stark. The most important to the public part is the lack of a trusted setup, which is a requirement in starks.
00:36:14.174 - 00:36:34.646, Speaker A: When you say that it can be interactive, would that mean. So we've done an episode where we talked about the interactive proofs and then the non interactive proofs. But if you're saying that starks could be interactive, would that mean then you're having a conversation back and forth between proven verifier until there's, like a probabilistic?
00:36:34.838 - 00:37:40.954, Speaker D: Yes, but probably better would be to use a blockchain. Okay. The transparency in a stark means that all the verifier ever sends is basically public randomness, or as long as you have a source of randomness that you're willing to trust, that could be what the verifier does. So let's move to a blockchain. In a blockchain, you actually have this sort of temporal event of a new block coming with some block header and something that can be assumed, and is already assumed practically by all blockchains to be pretty random. So in a blockchain you could definitely instantiate a stark in a setting where there's a first message from the proverb, then you wait for, let's say, six blocks to transpire, then you get randomness from the latest of these, and this goes back to the proverb and he completes the proof. And this actually has a lot of benefits, both from the theoretical point of view, because it means that actually the systems are a little bit safer.
00:37:40.954 - 00:38:49.550, Speaker D: The assumptions that you are making when analyzing this are a little bit better and more well understood. You only need collision resistant hash functions as opposed to using the random oracle hypothesis. And another even more practical implication is that you could conceivably work with such a start with a lower security parameter, so you could work with a probability of error of only, let's say 60 bits of security, rather than 120 or 80 bits of security, which would be required if you want to make it a one shot, non interactive setting. So there are theoretical benefits to using interaction, especially over a blockchain, and there are actually also practical implications to using it in that way. And we already had a number of projects that we talked to that were telling us, oh, we are anyways, using interaction and randomness from the blockchain, so why not use it to make things both safer and more efficient? And we said, yeah, you could definitely be doing this with a start.
00:38:49.640 - 00:39:28.466, Speaker B: There's a lot of people trying to use blockheaders for randomness, and with varying success. There are a lot of attack vectors, like miners can choose to manipulate the transactions in such a way that they affect the randomness. I'm sure though that you've thought of, and I know many others have thought of other ways to achieve randomness on a blockchain. The hype right now is how to generate randomness, like public randomness, and there's a lot of research and effort going into that, like what's called beacon chains and random beacons and BLS signatures to generate randomness and things like that.
00:39:28.488 - 00:39:49.534, Speaker D: Yes, I would maybe counter that by saying that if a blockchain is already dealing with the issue of generating randomness and says we are generating a beacon of randomness one way or another anyways, because we need it for all those other things, then you could plug that in to a stark.
00:39:49.602 - 00:40:04.938, Speaker B: Right, exactly. I'm just sort of in my head seeing all the people crying out about using block headers as randomness, because it's one of those things that all the core devs always complain about.
00:40:05.104 - 00:40:31.318, Speaker D: But we are, I mean, they're complaining, but we are using them. Even in bitcoin. Right. You are using. Part of the input to the next blockheader is the current block header. So we are already using this, and I think it's pretty unavoidable. I mean, we don't really know of any good way to completely resolve this, but as a practical matter, we're all using various sources of randomness that we understand that they are not.
00:40:31.318 - 00:40:32.760, Speaker D: None of them is perfect.
00:40:33.210 - 00:40:44.838, Speaker B: Yeah, exactly. We currently don't have anything better. I think that's my point, is there are better things in the works, and you could plug that into this structure. I think that's an important note.
00:40:44.934 - 00:40:45.580, Speaker D: Yes.
00:40:46.110 - 00:40:53.610, Speaker A: You had mentioned that starks are post quantum secure. Are snarks not post quantum secure.
00:40:53.770 - 00:41:21.154, Speaker C: The ones that are currently deployed, they are definitely not. Now, there are sort of theoretical constructions that rely on assumptions that are believed to be post quantum secure, but those are sort of mostly of theoretical value so far, and practical value may or may not be fulfilled in the future. But the ones that are currently deployed most definitely are not post quantum secure.
00:41:21.282 - 00:41:24.806, Speaker A: Is that because of the randomness or is that because of just.
00:41:24.988 - 00:41:57.582, Speaker C: Even if you put a trusted setup aside, it simply has to do with the fact that the cryptographic hardness ultimately relies on something called the discrete logarithm problem over finite abilition groups. And quantum computers can actually extract discrete logarithms efficiently while under suitable settings, classical algorithms are believed not to. And so this difference is what creates the sort of quantum insecurity.
00:41:57.726 - 00:43:18.410, Speaker D: Yeah, I mean, to, to add to this, maybe, you know, as, as a good rule of thumb to the listeners, any crypto system that relies on things like, it's hard to factor a number, it's hard to find a discrete log and other things that have this number theoretic flavor, things about prime numbers and factorization. So quantum computers, if they ever reach up to scale, are known to efficiently break such systems. So RSA, diffie, Hellman key exchange, elliptic curve cryptography, and the snarks used by zcash, as well as other more recent suggestions such as the beautiful bulletproofs as your knowledge system, they rely on such hardness assumptions, and they are known to be attackable by quantum computers. As we said, the Starks make much leaner reliance on cryptography, and essentially, they only need things like hash functions. And we don't know currently of quantum computer attacks that completely break the security of hash functions. So that's why starks are plausibly post quantum secure.
00:43:19.550 - 00:43:25.790, Speaker A: Is the post quantum quality something that you think about a lot, or is this just one smaller feature of starks?
00:43:26.290 - 00:44:12.190, Speaker C: Right now, what we really benefit from is the fact that we make a lean use of cryptography. We're only using lightweight cryptography. This means that overall, for example, the prover is easier to optimize because it is easier to bring the relevant algorithms closer to metal. Okay, you can optimize them more and more because you're not making use of heavyweight cryptography. And so overall, sort of things a bit faster. And in the future, maybe it's even an easier task to realize these algorithms directly in some sorts of hardware, which is something that may happen. It would be relatively harder to do that for other things, like snarks that make use of public key cryptography, for example, postgraduate security.
00:44:12.190 - 00:44:39.490, Speaker C: I think it's nice. As researchers, we take a long range view of our work, so it is pleasant to know that whatever we design today may, if efficient enough and interesting enough, withstand the test of time. I think that is wonderful. But whether it has an immediate impact today, that's probably less clear. The post quantum part, the efficiency part, obviously, immediate, immediate impact.
00:44:39.650 - 00:45:21.490, Speaker B: I wanted to just bring back a little bit and talk a bit more about comparison and how these things are actually constructed. So, in all of our previous episodes on snarks and zero knowledge proving systems, we talk about these circuits of logic gates, and this particular algorithm is this many gates or whatever, or this system can handle this many gates. Do you still construct a stark in the same kind of system? And if so, can you take the circuit of, like, let's take the zcash circuit and use a stark instead, or are they incompatible? How does that compare?
00:45:22.150 - 00:46:17.606, Speaker D: I think it's a really good question. So one of the core challenges and core magical attributes of a stark is that the verifier, nor no one on behalf of the verifier, ever unrolls a circuit. So basically, the verifier gets a very succinct program that could specify a very long computation. And that's all the verifier works with. In a snark, someone, it's called the generator, or the entity entrusted with generating the parameters, would unroll this computation into a circuit and generate something, one element per gate. In a stark, this does not happen. So you have to work much harder in order to allow the verifier to check a very long computation without ever unrolling it.
00:46:17.606 - 00:46:44.606, Speaker D: And the way this magic happens is, you use a whole lot of beautiful linear algebra related to succinct representation of groups. So again, I apologize for the math language, but that's really the best way I can explain it. There is succinctness through structure, and the structure is algebraic structure, and that's something that is heavily used in stark, by.
00:46:44.628 - 00:46:54.754, Speaker A: The way, don't worry about using math stuff. I think our listeners are going to love that, actually, even if it's challenging, they'll be like, I'm going to figure this out.
00:46:54.952 - 00:47:47.634, Speaker C: The analogy here is whether you. So you have some statement of interest, a computation, okay? And the way that it is represented in snarks, typically not in all snarks, is you just unroll the computation. You literally lay out every gate and every wire. And actually what happens during the trusted setup is that trusted party looks at this layout of the computation and kind of encodes it. This is basically the system parameters that go in the sky for everybody to use to prove and verify. Okay, but you don't have to do that necessarily, right? There are computations that are easily specified with much less. So think about the difference between the lines of machine code that it takes to specify a program that's just basically specifying the computation at hand versus the cycles it takes on a machine to execute this program.
00:47:47.634 - 00:48:22.602, Speaker C: So you could have many more cycles than you have lines in your machine code. Okay, so starks work with some algebraic analog of machine code. Okay? So the verifier only has in mind this sort of algebraic machine code, even though it is checking the execution of it. Okay? It doesn't have to think about unrolling it. This is where the experiential speed up comes from. Doesn't have to do this work explicitly. It's only all implicitly done using the algebraic structure that Eli mentioned earlier.
00:48:22.746 - 00:48:39.502, Speaker B: That's very interesting. So you can sort of almost think of it as there's this stark assembly language, and you have a stark vm, and every program written in this assembly executed in this vm automatically gets approved.
00:48:39.566 - 00:48:58.314, Speaker C: Yeah, that's exactly. Not exactly, but this is the exact sort of a high level analogy. This is at least what I even think, okay, in my head, you have to associate mathematical concepts, but this is precisely what's going on. So you have some algebraic computer relative to which you're proving statements without enrolling them.
00:48:58.432 - 00:49:17.354, Speaker A: So, Alessandro, I actually saw you speak at. It was in San Francisco at an event that the decrypt capital guys were putting on, and you had used the term snarg instead of snark. Or Stark. So what's a snarg?
00:49:17.482 - 00:49:55.318, Speaker C: So snarg literally means succinct, non interactive argument. Okay. This denotes proofs that are short and easy to verify, that are written down as non interactively. Sometimes we also discuss snarks with the k at the end and the difference between. This is rather important. Technically, though, from a halval perspective, it's not a big deal. But let me just, at high level, mention what is the difference? The cade at the end denotes that actually, all of these cryptographic proof systems, whether we're explicit about it or not, are not just proof systems.
00:49:55.318 - 00:50:37.974, Speaker C: They are so called proofs of knowledge. This essentially means that, for example, that if a prover is proving to you that a certain image of a hash function has a pre image, they themselves know the pre image. It's not that, just it exists. Of course, maybe a hash function has a pre image to a given image. That's generally true, because hash functions, for example, compress. So almost everything in the range has a pre image. But in cryptography, it's important to know that the person generating the proof actually knew the secret or the piece of information it was trying to assert knowledge of.
00:50:37.974 - 00:50:58.000, Speaker C: This is known as proof of knowledge, and sometimes in talks, because this is a technical notion, we just shove it under the carpet, even though we use it all over the place. It's important to know technically, these must be proofs of knowledge to be used in most scenarios, but it's a rather slippery concept, so just sometimes ignore it.
00:50:58.610 - 00:51:37.370, Speaker B: So we've talked a lot about starks. I think we've managed to uncover a little bit of knowledge. But like we said, all this information about, like, starks aren't fast enough. Even snarks are not fast or too big or whatever. There's obviously a lot of work has been done. It's gotten a lot better since a few years ago because of actual new research. But you as a company and as individual researchers, I'm sure, have huge plans.
00:51:37.370 - 00:51:48.058, Speaker B: What are the problems right now that you're trying to solve? And when are we seeing starks in use? Everywhere.
00:51:48.234 - 00:52:41.630, Speaker D: So, concretely, what we're trying to do at starkware is by the end of Q one 2019. So beginning of April, we want to deploy onto Ethereum. Sorry, onto Ethereum. Testnet, not the main net yet. Basically a start verifier for Dexes, for compressing offering and showing scalability through start. So you will have a verifier that will allow a prover node to prove that it processed many, many Dex transactions. And you will thus maintain the noncustodian part of a Dex, but you will achieve far greater scalability than you can in the current state where everything goes on the main net.
00:52:41.630 - 00:53:28.830, Speaker D: So hopefully the world will be seeing real starks in the wild within roughly three months. And after some testing period, we hope this will be a solution that will be integrated into various actual dexes and help them solve their acute scalability problem that they are faced with right now. I just want to emphasize so even though this is the zero knowledge podcast, in this solution, we won't be addressing privacy at all. We won't be using the zero knowledge aspect of the start. We will be using only the scalability attribute of it, which is the exponential compression of computation.
00:53:29.970 - 00:53:48.190, Speaker C: Typically, we refer to the efficiency property alone as succinct proofs. These are sort of proofs of computational integrity, whereby the size of the proof and the time to verify the proof are sort of exponentially smaller than sort of naively re executing the original computation.
00:53:48.350 - 00:54:13.338, Speaker A: And I imagine you can also use this like we had a conversation with Eric Tang from livepeer months ago about off chain computation and how you can do stuff off chain, sort of just like check in with various forms of proving systems. I don't even know what you'd call these, actually, because it doesn't have to be zero knowledge proofs, but it could be all sorts of different proofs.
00:54:13.514 - 00:54:25.294, Speaker C: Instead of on chain computation, you have off chain computation replay, and then on the on chain, you only have the corresponding verifier, which is a much cheaper algorithm to run.
00:54:25.492 - 00:54:29.890, Speaker A: Is that what you're talking about here? Are you using an off chain solution, or is this on chain?
00:54:30.230 - 00:54:54.570, Speaker D: The verifier sits on chain. Okay, I just want to clarify. At the end of q one, it will only appear on the test net, not on the main net. We'll first test it, but the verifier will be sitting always on chain. It will be verifying that an exponentially larger computation has occurred correctly off chain.
00:54:55.950 - 00:55:42.650, Speaker B: And this is something that you always like. If you want to do off chain computation, you always need some on chain verification aspect. And people like Lipier and many others have so far just kind of said, I hope that truebit solves this problem, and I'll just use their solution. And maybe that works, maybe not. But the truebit solution, it's a game. It's like a game, theoretic game of playing out various incentive structures to make sure that the computation at the end is correct. But having something like this where it's an actual proof with very high reliability.
00:55:42.650 - 00:55:58.270, Speaker B: Then it changes the story from, we have to do this kind of back and forth between the chain and off chain and have this lottery kind of thing. We can actually verify that this was done correctly.
00:55:59.410 - 00:56:09.730, Speaker A: Is there sort of a settling on this being a more plausible scaling solution than those kinds of solutions, or is it still debatable?
00:56:10.310 - 00:56:49.230, Speaker D: That's a debate that the larger community should hold. We strongly believe that this is a very good solution that can help address scalability. Maybe it's not the only solution. I mean, probably it's not the only. Just like with the Internet to reach very large scale and so that we can all converse by video chats, it's not one thing that solves it, right? You need fiber optics and better routers and a whole bunch of things. So it's not that starts as one component that solves everything. But we do believe that it's certainly a very important component that should be in the mix of any scalability solution long term.
00:56:50.050 - 00:57:23.820, Speaker B: Obviously, something like a true bit system depends on the size of the computation as well. And you might have a really large machine learning computation or something done off chain, and then you can't necessarily verify everything. So it is also like a reliability thing, right? Where if it's something that requires a lot of reliability, there's a lot of money hanging on it or something, maybe then you want proper proof. If it's just like live peer compressing an image, then it's not that important.
00:57:24.510 - 00:58:04.418, Speaker D: Yeah, I mean, the difference between a truebit system and something like a stark is that in truebit, you need someone that is trusted by the verifier, someone to act on behalf of the verifier and be non succinct. That someone must run a computation that is, as long as what the prover does in a stark. A verifier doesn't trust anyone else and still spends only an exponentially smaller amount of computation than the proverb. So there's an exponential gap between the job of verifying a stark proof and the job of someone doing the verification of a true bit cycle.
00:58:04.594 - 00:58:09.166, Speaker B: Can stark computation be non deterministic?
00:58:09.298 - 00:58:46.470, Speaker D: Of course. Well, okay. It really depends. I think one should understand what nondeterminism means. So a nondeterministic computation, a good way to describe it to the listeners, is a computation that requires also extra auxiliary information, things like passwords, my medical or financial data. There is no real nondeterministic machine as it was conceived or defined in the 40s or 50s as a machine that actually guesses.
00:58:47.050 - 00:58:55.506, Speaker B: We do have that today, though, where executing the exact same computation on x 64 does yield different results.
00:58:55.618 - 00:59:55.926, Speaker C: Sometimes I believe this is the same word referring to two different things. So, in computational complexity, non determinism refers to a very specific feature that actually we do leverage quite a lot, not just in this proof system, but across many proof systems. And then I guess you're referring to the fact that real world computer architectures are under specified and different realizations of the same architecture on different sort of hardware chips. They might behave somewhat differently. Maybe one way to resolve it is that we use non intermittentism in the computational complexity sense, but not in the computer architecture sense, in a sense that it is important. In fact, the proof system is designed in such a way that a correct computation can only have a single correct output. And that's the only thing that the verifier checks.
00:59:55.926 - 01:00:03.946, Speaker C: If there could be multiple outputs, then somehow the security proof system wouldn't really hold. Right, because what does it mean to check the output?
01:00:03.978 - 01:00:33.846, Speaker B: Yeah, so that's something that a lot of these off chain solutions struggle with. Taking live, period. As an example, again, they want to compress video to x 264. And that's what I would call a nondeterministic algorithm, because it depends on how much machine time is spent on each frame, and that depends on which cpu and what speed and how real time you want things to be and what bits per second you want to use.
01:00:33.948 - 01:01:07.282, Speaker C: Yeah, but they're using real architectures. Remember, we are using an algebraic computer that we design. So on this algebraic computer, everything is fully specified, every operation has a specific effect on the computation, and we have designed it to be so. Notice also that our algebraic computer is incredibly simpler than real world architectures, and so is the efficiency also of these alternative solutions. They are much faster because they're running native computation on actual computers. We are sort of running cryptography. It's a much slower process.
01:01:07.416 - 01:01:25.014, Speaker A: So I think we're getting close to the end of this episode. But I'd really love to hear, where do you see general zero knowledge research going? What do you see coming down the pipeline? That's really exciting. Maybe things that you can incorporate into the work that starkware is doing, or just like generally out there.
01:01:25.132 - 01:01:55.380, Speaker C: Personally, I hope that there will be a greater variety of zero knowledge proofs that achieve post quantum security. I think that is an important long term goal. So that's something that certainly there isn't as much of as I would like to see. And I hope the future brings more of that. Right now, we do have starks, but it's just one approach, potentially out of many yet to be realized in the future. And so I'm curious to see what those could be.
01:01:56.310 - 01:02:31.980, Speaker D: I'd add to that two specific things. So, zero knowledge is just the first layer of a bigger theme called secure multiparty computation, where there are several parties, that each one of them has some private information, and they wish to jointly compute some function. So, think of an auction where everyone wants to put in a bid, and you only want the result to be known to the winner. Something like that. So that's one area that could be deployed later on, and a little Sandro, maybe. Talk about recursion and recursive story.
01:02:32.370 - 01:03:18.262, Speaker C: Thank you. The other one is recursion. So the moment you have any succinct proof system, where checking a computation takes less time than running it, you can do sort of a sort of crazy idea, which is to recursively invoke the proof system on itself, where you start running proofs of proofs of proofs of proofs. This is something called recursive proof composition. We understand how this works for snarks. Also in practice, together with Ailey and other great colleagues, Rant Rommer and Madar Zvirza, we demonstrated for the first time a practical recursion of snarks, which is actually today used in the Coda protocol, for example. And in principle, this is also possible for starks.
01:03:18.262 - 01:03:49.558, Speaker C: But if you want to try to make that practical, that probably requires some new ideas. And so this is something that we're actively working on. And I at least think that it will lead to even more applications that weren't possible with only single shot Starks. So this is. I think it's a very exciting direction that, again, Ellie and I have been together, like, two weeks ago, and then we spent almost all of our free time together talking about this topic. So it's something very fun, but also challenging problem.
01:03:49.644 - 01:04:27.634, Speaker D: I want to maybe just add that, in general, I think Alessandro and I, and our many colleagues and co workers also at Starcore, are having a lot of not just fun, but meaningful interaction on pushing forward both the implementation, the engineering, the product size, but also the very core science and math of it forever. And it's tremendously beneficial and fun, seeing that I'm not sure we anticipated would actually happen. It's very sciency and mathy, and that's a lot of fun.
01:04:27.752 - 01:04:33.998, Speaker B: Do you write all of your code in C plus plus? And what part of it are you planning to open source?
01:04:34.094 - 01:05:28.434, Speaker D: So, the verifier for the contract that will work with Dexs is currently being written in solidity. So our programmers are, some of them are writing verifier code in solidity as we speak and making terrific progress on it. And that part will be a smart contract that will be deployed open source. The prover node will there must be a single entity at first that operates it, otherwise you run into further problems of consensus on provers. And that will not be open sourced at first. But we will plan to blog our intentions regarding how we're going to distribute code in a blog post in the very near future.
01:05:28.552 - 01:05:32.520, Speaker B: But the proverbs written in c plus plus then, or something else.
01:05:32.890 - 01:05:36.198, Speaker D: Yeah, the proverbs written in c and other things.
01:05:36.364 - 01:06:10.970, Speaker A: People definitely are excited about Starks. I think you guys maybe know this. Our listeners may or may not know this, but we started a little Starks learning group about a month or two ago, and it was supposed to be like eight people talking about this topic and it's turned into like 75 strong. And people really got very excited about this. If anyone wants to join the group, I'll put the link to the telegram group in the show notes. But definitely you see a lot of excitement around this. We just want to say, yeah, thank you for being on the podcast.
01:06:11.130 - 01:06:11.982, Speaker B: Thank you very much.
01:06:12.036 - 01:06:13.054, Speaker D: Thank you for having us.
01:06:13.092 - 01:06:13.422, Speaker C: Thank you.
01:06:13.476 - 01:06:21.186, Speaker A: And thank you for the work that you're doing. Keep it up. And to our listeners, thanks for listening.
01:06:21.298 - 01:06:22.050, Speaker C: Thanks for listening.
