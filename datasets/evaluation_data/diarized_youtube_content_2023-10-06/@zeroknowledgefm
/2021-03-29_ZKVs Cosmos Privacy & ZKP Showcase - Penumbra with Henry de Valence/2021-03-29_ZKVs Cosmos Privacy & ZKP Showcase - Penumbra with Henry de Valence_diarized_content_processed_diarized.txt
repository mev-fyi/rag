00:00:05.570 - 00:01:12.140, Speaker A: Welcome to the stage, Henry Devilance, who's going to be giving a talk about Penumbra. Take it away. Let me just. All right, let's go. So Penumbra is the project that I'm going to be telling you about today. What this is really? It's a kind of public research project at the moment, and the idea is trying to think about how you could potentially integrate privacy and proof of stake. So my background is more on privacy than proof of stake, but I think most of the people who are already in this event are probably convinced that proof of stake is pretty good in the future and so on.
00:01:12.140 - 00:02:08.240, Speaker A: But privacy obviously is pretty important. There's a lot of detail about why that is in the previous talk. I think the downside risk of not having privacy is pretty underappreciated. If you think back to the 90s, for instance, there was this whole thing of whether or not you needed transport encryption for websites. And it was only after the Snowden revelations that people really kind of got onto that that was a problem. And so there was sort of like ten years of delay, 20 years of delay. But with blockchains, everything is much worse, because instead of ephemeral communication, we're talking about permanent, immutable data.
00:02:08.240 - 00:03:03.966, Speaker A: So privacy is pretty important. How could we integrate it with proof of. So penumbra is just sort of some notes and research on how that might happen and thoughts on mechanisms that you could use to do private transactions, private delegation, private governance, and potentially also private swaps. So I'm going to go through each of these in turn for private transactions. The transaction model, as was just discussed, like a great starting point, is this sapling style shielded Utxo model. So instead of Utxos, you have notes. But unlike Utxos, notes are not going to be part of the public chain state.
00:03:03.966 - 00:04:23.350, Speaker A: Instead, the chain state is going to include only a Merkel tree of commitments to notes called the note commitment tree. And the way that this model works, you spend a note by proving inclusion of the note in the chain state and then revealing a nullifier that would prevent you from spending the same note twice. There's some other steps, but it's not that important. And you can build transactions in this model as a sequence of descriptions of actions, and each action adds or subtracts from the value balance of the transaction. So in the sapling scheme, you just have spend descriptions that spend notes and add value into the transaction, and output descriptions that create new notes and subtract value. And in this model, there's no accounts and there's no long term identity, which is really great for privacy because if you don't have some information, if you don't even have a concept of that information, then obviously it's much easier to not reveal it because it's just not there. So you could think about how you could use this model with IBC assets.
00:04:23.350 - 00:05:46.366, Speaker A: The sapling design can be extended to support multiple asset types, and this work has been done by members of the zcash team in the context of Zcash, where it's called user defined assets. And one of the interesting things about Cosmos, right, is that in the context of zcash, there's some complexity to this design because you have to work out how are we going to do issuance of these tokens, how do we name them, how do we absorb them? But Cosmos already provides standardized means for all of those things. You have issuance by inbound IBC transfers, absorption as outbound, and the naming is also standardized. So a lot of that complexity that was sort of the open questions for the zcash proposal are kind of gone. And what's pretty cool is you can actually do direct shielding of IBC transfers, right? So ICS 20 specifies this sort of fungible token packet data structure with a denomination amount sender and receiver. And these sender and receiver are specifying accounts on the source and destination chain respectively. So if you have only this shielded model, you have this potential problem that there's no account, but it turns out that the receiver is actually just a string.
00:05:46.366 - 00:06:52.310, Speaker A: So you can create an output description that proves the creation of a new shielded note and just stick that right into the receiver field. So that seems like it all works. Before talking about the private delegation and private governance and so on, there's two kind of prerequisites for things to make sense that I'll just mention. The first is we need some kind of homomorphic threshold decryption scheme. And this scheme is we need it to operate on signed integer values. And the reason that you're going to want this is that you can have then validators sharing control of a threshold decryption key and you can basically aggregate encrypted values and then decrypt only the sum. So this is slightly different from what you would have for I know that there's some ongoing work that we're about to hear about for doing encryption of transactions for mempool privacy.
00:06:52.310 - 00:07:34.946, Speaker A: This is related, but slightly different. Instead of encrypting an entire transaction, you're only having some encrypted values and you're going to try and do some computation on those values. And then the other prerequisite is in the mechanisms that I'm going to tell you about. There's an epoch system. So just for convenience and simplicity, we're going to organize blocks into epochs with a duration of approximately one day. The validator set the voting power. Essentially all of the kind of consensus related parameters are going to be determined on a per epoch basis.
00:07:34.946 - 00:08:34.146, Speaker A: And you're going to use the epochs to do distributed key generation for the threshold encryption in the first block of each epoch. So this is slightly inconvenient because it means that there's like one time when you can't make certain transactions, but probably it's worth it. Well, hopefully didn't do that. Okay, so just with the idea that those things sort of exist, there's some details in the notes that I'll link at the end about how you could do those. Let's talk about private delegation, and really let's first start about thinking about what the motivation is. The motivation is that there's some kind of challenge with having private staking. So this is pretty familiar, probably to a cosmos audience, but in tendermint you have stakeholders delegating stake to validators.
00:08:34.146 - 00:09:27.254, Speaker A: The validators actually perform the consensus algorithm with voting power according to their delegations. And the delegators are getting staking rewards in return for taking on the risk of validator misbehavior and having these incentives all aligned. And if we want to have some kind of private system, right, let's think about what that means. If delegations are public, then you have this pretty severe problem that stakeholders have to choose between having privacy or getting staking rewards. So there's a financial incentive not to have privacy for each individual person. So on balance, people are not going to choose privacy. And also to have the system work, you need to have people staking.
00:09:27.254 - 00:10:25.082, Speaker A: So if you don't have private delegations, then the staking part becomes this sort of, or the privacy part becomes this sort of extra sort of opt in thing. And then you have the bulk of the value in an unprivate way. And that doesn't really work out very well for actually getting anonymity. But if you have private delegations, on the other hand, then you have this problem of like how does the chain actually pay out staking rewards. If you don't reveal who has delegations, how do you reward them? Could you build something that could do that? It would probably be complicated. So the idea is actually whenever you have a problem that seems kind of hard to solve. Instead of solving the problem, you could just not solve the problem and then just not deal with the problem at all.
00:10:25.082 - 00:11:10.650, Speaker A: So how could we eliminate staking rewards entirely? The idea is we should treat unbonded stake. So I'll call that pen, which you could think of as the. Well, idea is the staking token for this scheme. We're going to treat the unbonded stake pen and the bonded stake pen B as two distinct assets. And this pen B is going to be actually a kind of first class staking derivative with delegation fungibility. What I mean by delegation fungibility is that all of the delegations to a particular validator should actually be on a completely equal footing. You don't need to record anything else, it's just a share of a delegation pool.
00:11:10.650 - 00:12:06.166, Speaker A: So because each validator's risk is different, pen B is really this shorthand for a class of assets. And we need to specify which each validator is going to have their own pool with their own shares of that pool. And this notation with a V is when you need to disambiguate that. And the idea of how you can eliminate staking rewards is that when you do bonding, you're converting from the unbonded to the bonded token. And that conversion rate should discount by the cumulative rewards from genesis up to the bonding point or the bonding epoch. And when you do unbonding, you should inflate by the cumulative rewards from genesis up to the unbonding point. So I'll give an example of how this works in a minute.
00:12:06.166 - 00:13:09.210, Speaker A: But what this means is that delegators are just going to realize a capital gain or loss on unbonding, not income, which is probably convenient for their accounting. But all of the actual delegations are completely fungible and you can record them just in a normal shielded pool. So to have this system work, there's some delegation parameters. The first and most important one is this base reward rate, which we're going to write as R sub E, and that's indexed by the epoch. So just as in the cosmos hub, you can have a kind of formula that adjusts based on the amount of actual stake. You have a per validator commission percentage. So actually running a good validator means that you need some SREs and that's expensive.
00:13:09.210 - 00:14:04.420, Speaker A: So there's a way to have commission and the commission is applied to the base reward rate to get this per validator rate. So you can think of this base reward rate is sort of like the blockchain Libor. It's like the reference rate for the whole rest of the system. And the per validator reward is the base rate minus some spread that's going to be taken as commission. And this conversion rate that I mentioned is the product of this reward rate over all of the epochs up to E. So this is the formula for the base rate. You can get a formula for the per validator exchange rate by substituting the per validator reward rate.
00:14:04.420 - 00:14:57.390, Speaker A: And this is sort of like the total amount of compounded interest. One thing that's cool about this system is that you don't have this. When do I withdraw my rewards and then redelegate them? Everybody gets compounded at the same rate automatically. And the mechanics of that, right? So if we delegate x amount of unbonded pen at epoch e one, we get x divided by this per validator rate, psi sub v. And when we undelegate, we multiply by psi sub v. But now at e two, the epoch where we're doing the undelegation. And if you compute the total return, you get psi V of E two divided by psi V of E one.
00:14:57.390 - 00:15:59.400, Speaker A: And since these are both two big products, the, the discounting that you do when you do delegation gets canceled away by the inflation that you do on undelegation. And what you're left with is exactly the reward rate for that validator compounded only over the interval during which those tokens were actually bonded to that validator. But you get that without having to actually track that in any way on chain. All of these delegations are still, everything within a particular validator's delegation pool is completely fungible. And it's actually just another token, right? It's a first class staking derivative. So you can move it around, send it, you could even send it over IBC if you wanted to build some kind of pooled risk thing. Potentially you could do that.
00:15:59.400 - 00:17:10.110, Speaker A: There's no compatibility issue. And another thing that this lets you do pretty nicely is you get to do some private governance. So the cosmos hub supports doing on chain voting, but now, because the holders of delegations are anonymous, you can now do anonymous voting. And the way that this is going to work is that the holders of bonded stake can vote privately using these special descriptions. They're going to spend a note, create a new note, encrypt a new note with the same amount of stake, and then encrypt that amount as their vote to the validators. The validators can use this homomorphic threshold decryption to aggregate and decrypt all the votes. And you can prevent double voting by just proving that your note already existed before the voting began.
00:17:10.110 - 00:18:39.558, Speaker A: And there's a way to do delegated voting that's in the notes. And finally, you can also have some kind of private swaps. And the mechanics for that are basically that a user is going to create a swap description revealing only the asset pair that they want to swap and then they're going to encrypt the input amounts and burn those funds. So it's sort of like a provable burn where you don't actually reveal the amount that you have burned and you create this kind of swap commitment that's going to be analogous to a note commitment that allows you to later establish that you did burn funds in a particular way. Once all of these are included into the chain in a block, or maybe you want to do longer batching, then the validators can aggregate all of the encrypted inputs to the swaps, decrypt only the net flow, and then compute a clearing price and some updated liquidity reserves. Include that in a block. And later users are going to use this swap commitment to mint new funds and prove consistency with the inputs that they previously burned.
00:18:39.558 - 00:19:19.320, Speaker A: This is pretty cool because there's actually no interaction required between the users or the liquidity pool that's required. And there's not any actual direct. You don't have to manage coordinating state between these different parties because everybody gets to have their own little private state. And the consensus just proves that all of the burning and minting kind of nets out. So the current status of this is that it's just some ongoing public design research. I want to try and see whether these ideas make sense. There's a lot of details to fill in.
00:19:19.320 - 00:19:39.820, Speaker A: There's a lot of more detail than in the slides in these public notes that are linked there. And there's a discord link on that website that if you want to talk about any of these ideas, you could. That would be a great place.
