00:00:06.330 - 00:00:18.750, Speaker A: Welcome to Zero Knowledge, a podcast where we explore the latest in blockchain technology and the decentralized web. The show is hosted by me, Anna and me Frederick.
00:00:23.570 - 00:00:37.720, Speaker B: In this episode, we sit down is Sean Bo from the electriccoin company for a very special episode where we talk about all the things that he's worked on, from trusted setups and npcs to zero knowledge systems like sonic and elliptic or cryptography in general.
00:00:43.470 - 00:01:20.200, Speaker A: Before we start, we want to say thank you to this week's sponsor, Trail of Bits. Trail of Bits is offering a service where they will staff a security team inside your company. They'll check up on you from time to time and make sure things are headed in the right direction. Have a security expert on design review calls, reviewing your prs, or contributing security improvements where it makes sense. Once you outgrow the service, they'll also help you replace them through prepping the work sample test, hosting some interviews, and giving you an educated recommendation on who to hire. This is not an audit. It's a low cost monthly subscription that will help you build a security team inside your company.
00:01:20.200 - 00:01:29.590, Speaker A: Visit trailabits.com for more info about the service. So thanks again, trailabits. And now here's our interview with Sean Bow.
00:01:32.490 - 00:01:33.278, Speaker B: Hi, Annette.
00:01:33.314 - 00:01:33.802, Speaker A: Hey.
00:01:33.936 - 00:01:49.754, Speaker B: We have a very special guest with us today, Sean Bowe. I'm super excited about this. We've had numerous requests to have you on the show, and we know that you're a very highly regarded person in this sort of a zero knowledge space. So very excited about this episode.
00:01:49.882 - 00:01:57.700, Speaker C: Thanks. I'm really glad to be on here. I've listened to a couple episodes of this podcast. This is really awesome.
00:01:58.630 - 00:02:09.480, Speaker A: Did you actually hear the. There's one episode, I think it's like two, three episodes ago, where we actually did a call out to you hoping that you'd come on our show. I don't know if you actually caught that one.
00:02:13.050 - 00:02:21.160, Speaker C: One of my friends heard that episode and pinged me and said, hey, you should check this out.
00:02:22.030 - 00:02:37.598, Speaker A: Cool. Well, I'm so glad you came on. For those who don't know, I'm just going to give a little intro to who you are, Sean. Sean is a Zcash company engineer. Actually, you're not called Zcash company anymore. You're electric coin company now.
00:02:37.684 - 00:02:42.362, Speaker C: Yeah, right. So I'm a cryptographic engineer working for the electric coin company.
00:02:42.516 - 00:03:00.150, Speaker A: Got it. And you are the person who was behind the sprout and sapling zcash trusted setups, as I understand it. And you also have actually designed some of the elliptic curves and, like, the actual cryptography underlying zcash.
00:03:00.810 - 00:03:36.770, Speaker C: Yeah. So I'm mostly a protocol engineer working for the company. So I've done everything from designing and implementing the elliptic curves that we use at zcash, and also implementing the ZK snarks and the arithmetic circuits and the underlying protocol and other things that anything that's related to ZK snarks. I'm kind of the resident ZK snark person at the electric coin company.
00:03:36.920 - 00:03:40.980, Speaker A: Very cool. You're also doing a lot of this in Rust, as I understand.
00:03:41.350 - 00:04:28.738, Speaker C: Yeah. So it's really awesome that the latest sapling upgrade of zcash is most of the underlying cryptography is implemented in Rust. Originally, it was in C Plus plus for the original Sprout release of zcash, but sapling is completely implemented in Rust, and it was a long journey because I had started actually implementing Rust, ZK snarks, in 2014, long before Rust had even become a stable language. So it took a few years, but eventually I got ZK Snarks and Rust put into production. Cool.
00:04:28.824 - 00:04:35.750, Speaker B: Why did you get into Rust? What was driving your decision to write all this stuff in Rust?
00:04:36.250 - 00:05:13.780, Speaker C: I think Rust melded with my personality a little bit. Rust is. I guess Rust is a different thing to everyone, but it seems to me like it's about writing robust software that is high performance. And those two things are really important goals to me when engineering in general. So I think that Rust kind of inspired me to work on the projects that I do. Sometimes I work on projects that I don't need to in Rust, just because it's a lot of fun.
00:05:14.230 - 00:05:31.974, Speaker B: This brings us into our little bit of an intro as well, of something that we are curious about with our guests is why you're working in this space. What drives you? What's your goal? Why are you here? Why are you working with this?
00:05:32.172 - 00:05:59.978, Speaker C: Yeah, so I think I'm here kind of as a little bit of an accident. I really love cryptography, and I really love rust. I really love cryptocurrencies. I really love privacy. I actually don't have any academic background at all. I didn't go to university, actually, I didn't even graduate high school. I dropped out of high school to study cryptography.
00:05:59.978 - 00:06:56.190, Speaker C: I had a friend of mine that tutored me in cryptography. He went to university, he tutored me in his free time. And so kind of in the early two thousand and ten s, I was able to learn cryptography surrounded by a bunch of really groundbreaking papers that were coming out every other month solving some serious problems in the space. It was a really fun time because fully homomorphic encryption and snarks and all these other things were being addressed, and actually practical implementations were being created for these kind of really exotic cryptographic primitives almost every day. And so it was a really exciting time. And snarks in particular, when they came out, I was fascinated with them. I had already been very fascinated with bitcoin, so I knew the implications.
00:06:56.190 - 00:07:50.366, Speaker C: And so I had started learning about how snarks work and trying to implement them, and around the same time, I was really interested in Rust. So actually, in 2014, I had started trying to implement ZK snarks in Rust, and it was a project that I never finished until many years later. But it caught the attention of Andrew Miller, who's the chairman of the Zcatch foundation, and he introduced me to Zuko Wilcox. I didn't have any job experience or anything like that, so Zuko kind of gambled a little bit and hired me. And so I ended up working for the electric coin company. I was one of the first couple employees, and then I sort of became the resident snark expert from there somehow.
00:07:50.558 - 00:07:51.300, Speaker A: Cool.
00:07:52.070 - 00:07:54.820, Speaker B: Seems like a gamble that paid off.
00:07:56.230 - 00:08:13.260, Speaker A: I'm sort of curious to go back to that time, that 2010 time you'd been studying cryptography with your friend, but can you pinpoint if there was some moment or spark or paper or something that really was like that turning point for you, where you got on this track?
00:08:13.630 - 00:09:07.386, Speaker C: I think it was the zero cash paper, because I had been trying to implement Zksnark cryptography plus blockchain in my free time just as a little hobby project, because I thought, oh, I'm onto something. I can use ZK snarks and make really private. But when Zero cash came out, I looked like a fool, because these incredibly smart cryptographers were working on this exact same thing, and they were miles ahead of me, and they actually knew how to do it and they actually implemented it, and they're going to deploy it. So I decided to just sit back and wait for the project to come out. So I had known about zerocache, and I'd been trying to find information about when it was going to launch and where its code was and things like that for a long time before. Eventually, I stumbled into actually working on.
00:09:07.408 - 00:09:17.134, Speaker A: The project, like, so you mentioned a little bit. We kind of talked about this in the intro. What parts of the zcash protocol have you been involved in?
00:09:17.252 - 00:10:14.510, Speaker C: So when I joined Zcash, I was focused mostly on protocol engineering because we had to deploy Zcash. So I kind of ripped out the current implementation, and we're basically a fork of bitcoin. So I modified the integration between the academic code and the bitcoin implementation to use a more recent version of bitcoin. Then I re implemented the academic implementation of the protocol and the arithmetic circuits and everything touching the ZK snarks, and then deleted all the academic code, and in the process, found a couple serious bugs. And then I was tasked to join the multiparty computation project. So I was the implementer of the first ceremony for Zcash, Zksnark parameter ceremony.
00:10:14.670 - 00:10:24.750, Speaker A: So I guess if anyone has heard that radio lab episode on Zcash and you guys, that whole setup, that was something you designed.
00:10:24.910 - 00:10:58.922, Speaker C: Yeah. So I worked alongside Ariel Gabazon. I was the implementer. Ariel was more of a crypto proof person, and we kind of designed the protocol and implemented the multiparty computation that is featured in that episode. And it was a blast. It took several months to develop, and I was a little bit worried because we were on the edge of our Runway as a company. This was back in 2016, and 2015 is when we got our funding.
00:10:58.922 - 00:11:10.930, Speaker C: So there weren't people throwing billions of dollars at your companies at this time like they did in 2017. So it was a little fun speaking.
00:11:11.000 - 00:11:32.460, Speaker B: About what this work that you've done and your background. And I know the background of a lot of the people at Zcash are phds or from the academic field. What's it like working at Zcash, and how does that balance between engineering and academia play out?
00:11:33.310 - 00:12:31.422, Speaker C: It's really amazing, because when I joined Zcash, I didn't have any academic background, any theory background, really, besides just learning my free time. And the company gave me resources and access to some of the best cryptographers in the world that founded our company or were friends of those people that I could talk to. Anytime I needed to learn about something or a question or how something worked, they were there. And so that's incredible, having the best cryptographers in the world at your fingertips. It's really great. So I learned a lot really fast because of that access, and also the company was focused on the kind of technology I was interested in, which is snarks. So I was able to kind of catch up on everything.
00:12:31.422 - 00:13:15.226, Speaker C: At the time, a lot of academics were working on snarks, but there weren't many down to earth people that were actually implementing and trying to find applications for the software, even though it was out there. There's Libsnarc, but there wasn't anyone trying to actually dive deep and see if they could use it for something. So being able to be one of the few people that were actually doing this at the time, back in 2015 or so, was really a good opportunity, especially for access to these academics, because they were waiting for someone to say, hey, how do I use this thing? They were really excited about, actually.
00:13:15.328 - 00:13:43.906, Speaker A: So we did something different with this episode. We actually put out a call on Twitter asking if anyone had any questions that they wanted us to ask you. And actually there was one question that came up that was related to this topic from Hadrian. He was curious if you thought that getting a PhD was actually necessary, or if maybe having more of an entrepreneurial background would be really useful for kind of entering into this space.
00:13:44.088 - 00:15:06.602, Speaker C: I think having a programming background is really useful. I've been programming and hacking since I was, since as long as I can remember, but I didn't have any rigorous background in the actual theory. And I think having a programming background is really useful because these academics, they post the prototypes, and so you can dive into the code and then figure out how it works and learn the theory, and then bam. Now you're a crypto implementer, expert of some particular subfield. So I think actually, if you don't have much of an academic background or you don't have a PhD or whatever, I think diving into really niche subjects is really a good idea. There's all sorts of things that you could become an expert in easily just by diving into the code that is produced by academics and then learning things, anything from fully homomorphic encryption to snarks and other things like that. Maybe not snarks anymore, because there's so many people tackling that, but all these really new bright ideas by cryptographers seem to sit in a corner until someone actually tries to come and figure it out from the programming background.
00:15:06.602 - 00:15:26.098, Speaker C: Because these academics are not producing extremely high quality code, they're just producing prototypes so that they can get their papers into conferences. So if you know code, then jump in and make this stuff really fast and make it nice and clean and comment it and things like that.
00:15:26.264 - 00:15:53.518, Speaker B: I guess the problem here is, or at least when I went to university, what I found was that to be able to find those things that need implementation, I needed to go to university and go talk to the researchers or find out through some means at these departments, like what these things that I could dig into are. If you don't go to university, how do you find out about this niche that could use a developer's touch.
00:15:53.604 - 00:16:39.420, Speaker C: That's interesting, because I think with cryptocurrency things have opened up a little bit because you can very plainly see the areas where cryptography can help and where improved cryptography will have a substantial impact. For example, if you follow bitcoin, you'll know immediately when new papers are coming out. In cryptography. In cryptography is pretty open. Everything's posted on eprint and so on. When new papers come out that say, hey, I have a way to do a zero knowledge proof that's really succinct, then you know immediately that that can really be used to help improve a cryptocurrency like bitcoin. I think that's what allowed the space to be a little bit more open.
00:16:39.870 - 00:16:53.970, Speaker A: I wonder too, just as an add on to this, do you think that sometimes having the. This is going to sound weird, but do you think that it's possible that having the academic rigor and going through that theoretical thing could actually prevent some creativity?
00:16:54.630 - 00:17:53.182, Speaker C: There's a missing perspective, I think, from academics. It depends on the academic you're talking about. If you're talking about some of them, getting into a conference is really great, but they're really rigorous about making sure that the code they produce is really high quality. But most of them are just interested in new results. And prototypes are really awesome for really enticing to accept a paper into a journal or a conference. But most academics, I think, are not really concerned about that kind of thing, unless they need to be. So the perspective of an engineer is someone who's actually taking that code and trying to use it, and which means that you are trying to tackle problems that are really challenging that the academics weren't anticipating, trying to write a robust implementation, trying to avoid pitfalls that would cause the entire system to collapse that you're implementing.
00:17:53.182 - 00:18:08.300, Speaker C: So these sort of things are not really on the mind of an academic at the time, that they're working on something. But I think academics are really creative. Engineers are really creative. They should work together on papers a little more often.
00:18:09.070 - 00:18:52.614, Speaker B: Yeah, I mean, there is this meme of academic code and it being bad, but I think you're right. It goes from being finding out new information, pushing the boundary of knowledge into what an academic might say is like implementation details. Or it goes into engineering, which is all the things that you're talking about, like how do you make it scalable and fast and secure and avoid bugs and all of these things that we learn in engineering. And most of that is actually not really taught in schools at all, in any field. So, yeah, it's a very different space.
00:18:52.812 - 00:19:44.390, Speaker C: I should say that. For example, there's this paper I'm a co author on called Zexi, and we released code for Zexi. It's basically a programmable version of kind of ethereum programmable, but with privacy kind of idea. And I didn't write most of the code. Well, okay, the code's based on what I've written already for Zcash, but a lot of the code was written by Pratouch. And Howard from Berkeley were students of Alexandro, and they have such a high standard of quality that it blows my mind. They don't release the paper, they don't release the code until everything's really high quality.
00:19:44.390 - 00:19:57.482, Speaker C: And so I'm really astounded by that. So some academics really go for the high quality and really shows. So I'm really impressed by that. So it goes either way, I guess. Yeah, we've actually.
00:19:57.536 - 00:20:01.726, Speaker A: I don't know if you know this. We've had Howard and Alessandro on the podcast before.
00:20:01.908 - 00:20:02.880, Speaker C: That's awesome.
00:20:03.330 - 00:20:21.010, Speaker A: So let's jump into some of the work that you've actually done. I mean, you just mentioned the Zexi paper. This is z e xe P-S-I just gave away my canadian nest there with the z, but, yeah. So tell us a little bit about that. Where is that coming from? Where is that coming out of?
00:20:21.080 - 00:21:05.902, Speaker C: So I can't say much about Zexi, unfortunately. What happened was basically, after Zcash launched, I had jumped into trying to improve the ceremony of Zcash that we used for the first ceremony. I wanted to improve the protocol because our original ceremony only involved six people, as long as at least one was honest and it was secure. I wanted it to be, like, 100 people. So I wanted to design a new ceremony at the same time, I was working on optimizing zcash. So it was efficient enough that you could create transactions on a phone or something, for example. So, in the process, I had designed some elliptic curves.
00:21:05.902 - 00:22:23.946, Speaker C: There's this pairing friendly curve and this embedded elliptic curve. And I was coming up with optimizations for how to do certain cryptographic primitives inside of the circuits for the pairing friendly curve and so on. So I stumbled into this process of creating a new protocol for Zcash, which was called sapling. So I sort of shepherded sapling to the finish line, along with the help with my coworkers, especially Dara Hopwood, who's an amazing arithmetic circuit optimizer, and also strad so in this process, I came up with a couple techniques and they ended up being useful for Zexi. So Zexi was an idea of how do we create totally private, totally anonymous, smart contracts, basically. And that kind of took over my code and started doing some cool things that went out of control and I did not follow it. So I don't know too much about Zexi or how it works, but I could tell you a lot about other things, like things that I've started to work on more recently, like Sonic or the new ceremony that we used for.
00:22:23.968 - 00:22:47.038, Speaker B: Sapling, which, let's get into the setups a little bit. I think they're very interesting topics in general. I want to get back to Sonic as well and touch a bit on that and curve development and a couple other interesting areas. But why are these trusted setups so interesting? Why has that been such a big focus of yours?
00:22:47.134 - 00:24:06.010, Speaker C: Well, unfortunately, they're necessary. A lot of people think that it's just some kind of big production just for public entertainment, but it's really, honestly, absolutely necessary. The first ceremony, as we know now, there was a bug in the ZK snark, a mistake in the ZK snark itself, such that the ceremony, although it produced secure parameters and the trapdoors that were supposed to be deleted or were deleted, the trapdoors that we knew about, there were trapdoors that we didn't know about that weren't deleted. And so the first ceremony failed in that sense, but it was successful in the sense that it was the first incarnation of this kind of concept of bringing people together and doing a multiparty computation and constructing the parameters and going in these round robin cycles and doing all this stuff like this. So that was a really fun time. But obviously, six people cannot make a secure MPC with at least one honest to construct parameters where millions of dollars or billions of dollars are at stake.
00:24:07.310 - 00:24:22.362, Speaker A: Especially not if you're looking for the perception from the outside world. Six people who may or may not know each other. I know that Zuko went out of his way to make sure that they didn't, but we, as the outside parties.
00:24:22.506 - 00:25:17.342, Speaker C: Need to trust that, yeah, this is a real challenge. It wasn't just a challenge for Zcash. I think if you look, I'm not aware of any other projects than Zcash that have actually deployed in production which have millions or billions of dollars underlying them, which deploy, I guess, generic computation, zero knowledge proofs. So Zcache is probably the first project to do this, and it's done it twice now. But I think the reason why, especially because we've deployed ZK snarts, I think the reason why is because these setups, these setups are very expensive, they're very challenging. It's easy to screw up. It's easy for one participant to lose a network connection, and then there's a bug, and then they don't know what to do, and then the whole thing stalls.
00:25:17.342 - 00:25:18.850, Speaker C: Or who knows?
00:25:20.070 - 00:25:43.450, Speaker B: What I find is also that a lot of the projects that I see in this space who are talking about wanting a snark of some sort, they kind of brush that aside as we'll deal with that when we get to it. And then when they start talking about, okay, now we actually want to deploy this saying, how do we do this? They vastly underestimate how hard it will actually be to get the ceremony working.
00:25:43.600 - 00:26:00.430, Speaker C: Yeah, the ceremony is really an extreme challenge, and so improving it, not just for zcash, but also for everyone else, was something that was on my mind when Zcash launched. So I started focusing on trying to improve the ceremony.
00:26:01.170 - 00:26:13.394, Speaker A: Was that what you actually worked on after Sprout had already been deployed? Was it like, after that went live, you then immediately started to think about this trusted setup, or what were you focusing after that went live?
00:26:13.512 - 00:27:01.714, Speaker C: After that went live? My focus was on the. It was on that ceremony, on the new ceremony, but it was mostly on the protocol for an improved version of zcash, which was sapling. So I had designed some techniques and wanted to chain them together in a certain way. And I implemented a prototype and got the company on board to use it in zcash. And we eventually deployed it a year after my prototype was posted, which involved I had to design some elliptic curves, I had to come up with some optimization techniques, I had to implement circuits, I had to implement ZK snarks and rust, I had to implement the elliptic curve arithmetic and rust, and I had to do all this other stuff.
00:27:01.912 - 00:27:07.430, Speaker B: I think you have a hash function named after you, too, right? The bohod Peterson hash or something?
00:27:07.500 - 00:27:58.966, Speaker C: Yeah, I think, honestly, that hash function should mean, okay, well, I participated in its optimization in some sense, but Dara Hopwood came up with most of the really clever tricks for that. So maybe it should be Hopwood bow. I don't know. But yeah, there's a hash function which is based on elliptic curve discrete logarithm problem, which is a collision resistant hash, which is what we needed for the Merkel trees that we use in z cache. Ian Myers had told me, hey, if you could do this efficiently in circuits. I don't know if you can, but if you can do this, then you could swap this out for shot 256 or whatever we were currently using. And so I looked at it and I was able to figure out some ways that we could optimize it.
00:27:58.966 - 00:28:36.286, Speaker C: I posted it. Adara Hopwood came along and was able to have the cost after I was optimizing it. So Z made it really efficient for our protocol to basically prove that you're spending real money and then anonymously. Yeah, so there's that. The elliptic curves that I designed, the BLS twelve, 381 and jubjub. I didn't come up with a name jubjub either, by the way. That's also Dara.
00:28:36.286 - 00:28:37.762, Speaker C: Dara came up with a name.
00:28:37.896 - 00:28:39.300, Speaker A: Where does it come from?
00:28:39.670 - 00:28:50.920, Speaker C: It's from a Carroll book of some kind, one of them. So it's one of those absurdist kind of things.
00:28:56.250 - 00:29:14.320, Speaker B: This is obviously a ton of work across ceremonies, across fundamental cryptography, inventing new things, engineering, optimizing. If you had to put like one theme or one focus of the type of work and the research that you do, what would you say that it is?
00:29:15.170 - 00:29:45.880, Speaker C: So I guess my focus is on ZK snarks and anything that it touches. My focus is on taking academic ideas and implementing them and then improving on them performance wise. Yeah, it's mostly that. It's mostly taking the genius ideas that are in papers and then trying to combine them in a way that actually ends up with a product that is really efficient. I think that that's mostly what I do.
00:29:46.410 - 00:29:46.966, Speaker B: Nice.
00:29:47.068 - 00:30:05.040, Speaker A: So in our episode, we also did an episode with Zuko. It was our 50th episode, and in that episode, we actually did talk about the details of the sapling upgrade and the various things that had been implemented to make it a lot faster. And would you say more succinct? Is that the right word in this?
00:30:06.450 - 00:30:10.046, Speaker C: I wouldn't say more succinct. Faster is. Okay. Yeah.
00:30:10.148 - 00:30:10.702, Speaker A: Okay.
00:30:10.836 - 00:30:42.300, Speaker C: So when people say succinct, what you should think is, at least for zero knowledge proofs, succinct means short and fast to verify. So it should be asymptotically short. So something like polylogarithmic or even constant for most snarks, and it should also be asymptotically fast to verify. So polylogarithmic or constant for most narcs to verify, constant time with respect to the underlying statement. So that's what succinct means.
00:30:43.150 - 00:31:03.338, Speaker A: We've been aware that the sapling update had a much broader trusted setup with a lot more people involved, and I imagine it's more complicated. I think it would be really cool to go into that. What was the big change from the sprout trusted setup to the sapling one?
00:31:03.524 - 00:32:36.654, Speaker C: So there were a couple of things. The sprout ceremony, the reason why it only involved six people was because if we, for example, we added a 7th person, all the other six people would have to wait for that 7th person to do something, which took hours, about an hour, actually, like three times. So in that space of time, they would have to sit with their computer and hug it while their computations are being performed, or while computations aren't being performed, and they're just waiting because some ninja might come and steal it or whatever and try to infiltrate the ceremony, so they have to retain custody of their machine for this long period of time. In the case of the original sprout ceremony, I think 24 hours continuous is how long it took to actually execute that ceremony. That's just not practical. What's really practical is for scaling purposes, for involving lots of people, is if people can just join, contribute, and then leave. And the reason why cryptographically, the original ceremony couldn't support this was because for the security proof, you had to commit to your secrets, to this toxic waste, so to speak, or this toxic waste byproduct, whatever we call it, you had to commit to that before the ceremony began so that you couldn't change your move that you're going to make later on.
00:32:36.654 - 00:33:20.338, Speaker C: And this was just to make the cryptography work. It was clearly not necessary. And so after sprout, I had said, screw this pre commitment stage, let's just get rid of it and find something else. For powers of Tau and for the sapling MPC, we figured out that we could just do a randomness beacon, and that was good enough. But even if that failed, I think it was securing the algebraic group model. And then later on, Mary Mallors and other people have figured out that, oh, you just use fishlin transforms and you get the security proof goes through that way because you get a straight line extractor. So the important bit was getting rid of that commitment round.
00:33:20.338 - 00:34:21.130, Speaker C: But also the ceremony involved multiple phases. So the original ceremony, the sprout ceremony, had three phases. The first phase, you create the powers of tau. So you're encoding some evaluation of different monomials and some unknown tau into the elliptic curve group. Then you do a fast Fourier transform, and then all of a sudden, now you have the ability to create these interpolation polynomials in the group. Then you create the correct interpolation polynomials, and then you do another phase, which sort of adds several other unknowns in order to get the protocol to work exactly like the snark needs it. And then you had to do another phase in the case of the snark that we used for zcash originally, but there was a new ZK snark called Gross 16, which, or grot 16, which was more efficient.
00:34:21.130 - 00:35:03.930, Speaker C: But also you could compact it into two rounds, very trivially, and so you would have a single round setup that could scale forever, which only dealt with the monomials, the original kind of the bottom layer. It's kind of like building a cake or something, the bottom layer. And anyone could use that as a basis to construct their parameters for their own ceremony. So right now, actually, there's a rust library called phase two, which anyone can use to create their own zksnark public parameters with a multiparty computation using powers of tau as a basis.
00:35:04.090 - 00:35:58.330, Speaker B: I'm curious on, when it comes to actually implementing this, how much of the work is split between the requirements of the snark and the cryptography of that versus the MPC part of like, how much of the work is generating parameters? Because we always see, like in Socrates, for instance, you can just download this, you generate the parameters locally on your computer, and it's totally insecure for public use, but generating the parameters are actually pretty easy, whereas it seems like once you aren't to generate them securely in a multiparty computation, it becomes super complicated. Is it that because of the multiparty computation, or because scaling the parameter generation in this way is so complicated?
00:35:58.490 - 00:37:18.650, Speaker C: It's complicated because the multiparty computation itself is a logistical nightmare, because you have to coordinate it, you have to get people involved, you have to implement it, you have to make sure it's secure, you have to write multiple implementations, maybe you have to do all these things, and then the protocol itself is quite expensive. But also, there's a big difference between constructing the parameters in a multiparty computation and constructing them in kind of a solo setup that you do on your own machine. The difference is when you're doing a solo setup, you know all of the unknowns, and so you can evaluate all the polynomials at, at those unknown points very trivially, and then just do a bunch of, I mean, they're expensive, but you can do a bunch of multi point exponentiations in the group and in the NPC. You don't, every person doesn't know every other person's secrets, and so each person needs to do that same process, but with lots of different group elements, and it becomes really expensive in that respect. So that's why doing an MPC is really expensive.
00:37:21.550 - 00:37:55.710, Speaker B: So speaking of trusted setups, you said earlier that it was part of your goal to make this easier and more approachable and sort of better in general. And down the line of other things that you have invented, there's sonic, which as far as I understand it aims to get rid of, quote unquote, the trusted setup even more. You still have to do it, but now it applies to multiple snarks, so you don't have to do an individual one for each snark. Is that a correct description?
00:37:55.790 - 00:38:26.074, Speaker C: Yeah. So one of the follies of our original is folly. The right word? I don't know. One of the downsides of the original ceremony that we did Zcash and then the following ceremony was that it was specific to Zcash. So you couldn't just take those parameters and create your own snark for your own application. If your circuit was different, you had to create new parameters in your own setup. So what people really want are universal parameters.
00:38:26.074 - 00:39:20.430, Speaker C: So someone else does the trusted setup, and then everyone can use those parameters in their project and they don't have to perform their own ceremony. I think that that would explode the usage of ZK snarks in the community, but getting there is really challenging. So last year in 2018, Jens Groh and others, Mary Mallor and Marco Cole Weiss and other people, came up with a universal parameter, ZK snark. And this was really fascinating. Unfortunately, it was really inefficient, the size of the parameters scaled quadratically with the size of the supported statements in terms of the number of multiplication gates in the arithmetic circuit. So it was just totally inefficient. So with Sonic, we're just trying to tackle that.
00:39:20.430 - 00:40:28.806, Speaker C: We're trying to come up with something that has a linear size parameter, just like a normal ZK snark that's updatable, and you get a snark in the end. So that's all that Sonic's about. There's another facet to this, which is great. We have a universal parameters and anyone can use it. It'd be nice if it could be updatable in the sense that someone can join, contribute and improve the parameters of security, and be one of the few people who had contributed to its security, then leave immediately, and then people can do this forever. So the ceremony basically never ends, and in this case, it can scale to a very large number of people, and there's all sorts of settings where you could imagine people contributing as part of a contract or some requirement or whatever, or the ceremony can fork off and people can contribute in different ways or whatever, which is really interesting. And it leads to something I think is really fundamentally as secure as you can get.
00:40:28.806 - 00:40:52.406, Speaker C: And it kind of comes naturally once you have universal parameters, because at least for ZK snarks, if your parameters are universal, they're probably monomials, and monomials are easily updatable inside of these setups. So sonic is a universal and updatable setup where the parameters are linear in size, and you get a ZK snark.
00:40:52.438 - 00:41:09.010, Speaker A: In the end, you referred to Sonic there as a setup. So is sonic the only the trusted setup part of this, or do you need a different snark? I'm kind of curious where that lives. Is it sort of an overlap between a snark and the trusted setup, or is it only a trusted setup?
00:41:09.430 - 00:41:33.020, Speaker C: It's blurry. So sonic is a ZK snark with a certain setup that happens to be linear in size and updatable and universal. Got it. But that updatable and universal part of the requirements of the snark is inherent to this is why we built Sonic. We were trying to get a snark which only required universal and updatable parameters that were linear in size.
00:41:34.670 - 00:41:48.782, Speaker A: For those groups that have already implemented some form of snark that is maybe from a library, what do they have to do to change that? Do they have to redeploy the whole thing? Can they use pieces of it?
00:41:48.916 - 00:42:11.046, Speaker C: So in general, if you have a ZK snark that you've already used, and you want to move to another ZK snark, you're screwed. You have to do a new setup, or you have to change your protocol completely. You might even need to change elliptic curbs depending on what you did. So there's a lot of. Yeah, it gets messy with Sonics, though.
00:42:11.068 - 00:42:20.462, Speaker A: You sort of mentioned this upgradability. Is that what you like? If you then had Sonics, would you be able to change your snark?
00:42:20.626 - 00:43:07.390, Speaker C: A lot of people, when you describe Sonic to them, they think, oh, it's updatable setup. That means when I update the parameters, all of a sudden they're more secure. And then all the proofs that were constructed before, I know that they were secure because I contributed. It's not like that. Proofs are constructed using the parameters as they were at some point in time. And if you update the parameters, you were making them more secure, but all the proofs that were constructed before do not leverage your contribution at all. So updatability is really fundamentally about scaling the process of constructing the parameters so that it can support hundreds of people and very high quality contributions.
00:43:07.570 - 00:43:15.260, Speaker B: But I think the question is also, when I update, can I change to a different circuit at the same time?
00:43:16.030 - 00:43:27.854, Speaker C: Yeah. So because it's universal, at least for sonic, because it's universal parameters, then you can switch circuits anytime you want.
00:43:27.892 - 00:43:28.480, Speaker A: Yes.
00:43:29.250 - 00:43:52.470, Speaker B: I like the upgradability aspect as well, from the point of view, just avoiding tinfoil hat people, because if someone comes along and says, no, I don't trust these 400 people, they all colluded. That person can themselves enter into the ceremony at that point and do the job themselves and trust that they didn't lie to themselves, and therefore it's now more secure and they can trust this thing.
00:43:52.540 - 00:43:53.800, Speaker C: Sure. Yeah, exactly.
00:43:54.970 - 00:44:00.006, Speaker A: I just realized we keep switching the word updatable and upgradable. What is the right terminology?
00:44:00.118 - 00:44:00.950, Speaker C: Updatable.
00:44:01.110 - 00:44:28.850, Speaker A: Updatable. Okay. Just not confuse people out there. I said it wrong the first time around. From what I understand, sonic grew out of the work you had put in for the sapling upgrade. You had sort of already extended and added a lot more participants into that sort of second trusted setup. And then I'm guessing out of that you realized, oh, we could do even more with this new setup.
00:44:29.430 - 00:45:37.160, Speaker C: With the sapling multiparty computation that we performed for constructing the parameters for sapling, we had two phases. One where you embed these monomials into the parameters, and then one where you actually construct the polynomials, and then you add another unknown, and then you get your parameters. What I wanted to get rid of was that second phase, because either of the phases can run indefinitely. And so you get that updatable effect. You also get the universal effect if you get rid of the second phase that has the polynomials that are specific to your circuit. So really the goal of sonic was to, and this was the goal of paper preceding sonic was to get rid of that second phase and just have a ZK snark that only required monomials, for example, that were embedded in the group. So a lot of really clever people came up with techniques, and we sort of just jammed them together to figure out how to get it to work.
00:45:37.930 - 00:45:51.450, Speaker A: So we actually had a few other questions from our listeners on this. So we had one question from Georgia's Constantopoulos, who is asking if there are further steps to improving the sonic protocol that you're working on right now.
00:45:51.520 - 00:45:53.760, Speaker C: I'm not working on any. Well, I'm trying.
00:45:56.930 - 00:45:59.390, Speaker A: You're trying not to work on it, or are you trying to.
00:45:59.460 - 00:46:41.390, Speaker C: I'm trying to work on it. I'm trying to come up with ideas and failing, but there's a lot of other people that are coming up with really good ideas that are kind of orthogonal, but they'll be able to improve sonic. One of the things I'm really excited about is there are people trying to make sonic more efficient, but then there's also sharks. ZK sharks, which are these fun little snarks which are kind of like a bulletproof, so it doesn't require strong assumptions in a setup and snark attached to it. In a sense, I'm oversimplifying.
00:46:42.210 - 00:46:42.922, Speaker A: Sharks.
00:46:42.986 - 00:46:44.478, Speaker C: They're called sharks. Yes.
00:46:44.564 - 00:46:45.680, Speaker A: That's amazing.
00:46:46.930 - 00:46:48.480, Speaker C: Very deliberate, too.
00:46:49.170 - 00:46:53.140, Speaker A: Bulletproofs and snarks become sharks. Right.
00:46:55.430 - 00:47:30.682, Speaker C: So the snark that's attached to the bulletproof just proves that the bulletproof has been verified. So instead of verifying the bulletproof, which could be expensive, you verify the snark and it's really efficient. And if someone verifies the bulletproof and the verification fails, and the snark verification succeeds, then, you know, the trusted setup was a failure. And so you can give that to someone, say, hey, check it out. The trusted setup failed. So I think that this is really. It almost obviates trusted setups for most applications that I can think of.
00:47:30.682 - 00:48:01.400, Speaker C: There's some applications where you still need snarks, and you probably don't get anything from bulletproofs. And also, maybe the bulletproof part of it is too inefficient or whatever. But I think that sharks are really cool, and I think people will want to see sharks using updatable and universal parameters like Sonic. So there's sharks plus sonic, so supersonic sharks, I don't know, will eventually show up, actually.
00:48:02.010 - 00:48:29.870, Speaker A: So something you just touched on and a topic I definitely want to get to in this episode. You just sort of mentioned this, like, with these sharks, you can check. You can check if the trusted setup has failed or been compromised. And this, in a way, kind of leads into a topic that you mentioned earlier in the episode. But I think it would be really interesting to talk about, and that is the bug. Is that the right way of saying it? Do you call it a bug?
00:48:31.810 - 00:48:47.078, Speaker C: It was a fundamental cryptographic mistake inside of a paper that precedes zcash. So I would call it the BCTV 14 bug or BCTV 14 mistake or whatever error of some kind.
00:48:47.244 - 00:49:01.378, Speaker A: This bug, it didn't really have anything to do with the trusted setup, though, did it? The trusted setup that you did was successful in a way that toxic waste was not discovered.
00:49:01.474 - 00:49:45.350, Speaker C: Right. So the goal of the trusted setup is to construct parameters for the ZK snark such that certain variables are unknown to anyone and they're destroyed forever? Well, forever until a quantum computer shows up or something. So I think we successfully achieved this. Unfortunately, the paper that described the ZK snark said you had to produce some other things as part of the parameters which actually weren't necessary for the prover. The prover didn't need them to actually construct proofs, and so we constructed them, and then it ended up being that they are actually not even. It's worse than not necessary. They actually break the soundness of the proving system.
00:49:45.350 - 00:50:06.782, Speaker C: So we weren't aware of this. I think if that mistake wasn't there, then the ceremony would be a success in the sense that it would produce secure parameters. But I think the first ceremony, I'm sure, was successful in producing parameters for a broken ZK snark, but. Right.
00:50:06.916 - 00:50:22.754, Speaker A: Wow. So that's what it was. It was more just like there was extra. Something extra produced, which you didn't think would be in any way relevant. And then was the mistake that that other extra stuff could be used in some way?
00:50:22.952 - 00:51:04.880, Speaker C: Yeah. So I think we call them bypass elements because we couldn't come up with anything better than that. But there are these elements that are produced and exist in the parameters that allow you to bypass everything and just create a false proof arbitrarily. And you could really think of the bypass elements as another trapdoor that you should have destroyed in addition to the existing trapdoors that you knew you should have. So you could call them toxic waste as well. But I just call them bypass elements, I guess.
00:51:05.730 - 00:51:20.102, Speaker A: Would you have needed all of them in the same way with the toxic way? Was it only in the combination of all of it that it would be dangerous, or were these bypass elements something that actually came out at the end of it?
00:51:20.236 - 00:52:08.226, Speaker C: Right. They're at the very end. They appear as part of the setup. Now, it happened to be that the implementation of lib snark deleted these elements because they weren't needed by the prover, but it was defined as something that was constructed during the setup, and so the MPC produced it and then deleted it, because Libsnark prover needed these elements to be removed so the prover would work correctly. So the MPC that we did. Originally, there was a transcript that contained these elements, these bypass elements I'm speaking of in the middle of the transcript somewhere. And these elements could be used to create false proofs.
00:52:08.338 - 00:52:23.946, Speaker B: So how did you guys discover this? And what happened after you discovered it? What was the internal this is found, and then what do you do?
00:52:24.128 - 00:53:22.982, Speaker C: So what happened was, I was at financial cryptography. This is a conference along with Ariel Gabazon and Zuko, which is really useful because having those two people at the same conference, the same physical location, when we discover such a critical bug was probably incredibly important to actually mitigating the bug correctly. So I was at this conference, and Ariel will sometimes message me and say, hey, I found a thing that seems weird about Zcash. Is this broken? I'll say, no, it's not because of this or that. And then he told me about this bug that he had spotted in the paper, and I was a little suspicious. I had to remember how this thing worked. I was like, nah, this is an old paper from 2014.
00:53:22.982 - 00:54:06.570, Speaker C: This is probably okay, but I'll check it out, I guess. And I met him in person and confirmed that the bug was real. So I called Zuko up and I said, hey, you need to get back to the hotel as fast as you can. It's an emergency. And apparently he thought that I meant that someone had been kidnapped or something, so he asked the hotel to ask bodyguards or something to come and check us out. But no, it was just that the zcash proving system was broken. And people could counterfeit coins infinitely if they had access to this transcript that was produced in the original protocol.
00:54:06.570 - 00:54:24.530, Speaker C: So when Zuko came and met with us, we decided to delete this transcript. It was publicly available. Just delete it. And then no one can. There weren't very many people that downloaded it, maybe, like, a dozen. And so you delete it. No one can exploit it.
00:54:24.530 - 00:55:39.574, Speaker C: I had a copy on my laptop, which we eventually deleted. In the process, we come up with some way to actually fix the bug in zcash covertly, because if you tell everyone, then who knows? We didn't know that there was very few people that downloaded it or where it was or if it was archived. So we were worried that if we went public with anything, that someone would exploit it in Zcash before we could patch it. So I came up with a way to patch it covertly in Zcash by using our new setup to the new setup for the sapling upgrade to actually replace the parameters for the old system that were broken. And so we did this, and this had a convincing explanation, so we didn't need to tell anyone besides us three and Nathan, who's a CTO of Nathan Wilcox, who's the CTO of electric coin company. We didn't have to tell beyond us four about this issue. None of the engineers or cryptographers or anyone, because it had an explanation, so to speak.
00:55:39.574 - 00:55:48.860, Speaker C: So we were able to patch it. And once it was patched, it was a matter of fixing it for all the other cryptocurrencies that were affected by it as well.
00:55:53.170 - 00:56:03.354, Speaker B: From discovery to actually patch. I mean, it was quite a long time. Was that a time of just constant panic, or what was the four of you that knew?
00:56:03.492 - 00:56:03.986, Speaker C: Right.
00:56:04.088 - 00:56:06.020, Speaker B: What was the emotion there?
00:56:06.950 - 00:56:50.430, Speaker C: So I think maybe I aged ten years during that one year. Well, okay, so it was about eight months between discovery and patch. I think it wasn't intending to be that long, but there was a delay. But having to keep such a bug secret, which could lead to destruction of the project that you work so hard on, was really difficult. So everyone had serious emotional takeaways from that experience. I think, personally, I didn't get much done during 2018 because of. I mean, I was working on sapling and designing it and things like that.
00:56:50.430 - 00:57:21.260, Speaker C: I had done most of the sapling stuff that I contributed to in 2017, the implementation. And so in 2018, it was just about implementing things, finishing the design work and doing the ceremonies and going through everything and making sure that there's not another bug or trying to make sure that there's not another bug in the code or something or in the crypto. So it was a really difficult time.
00:57:21.950 - 00:57:50.610, Speaker A: I remember it. So, as I understand it, the update or, like, the fix for this was part of the sapling. I mean, when the sapling upgrade happened, this issue was sort of, like, taken care of. But I remember at Zcon zero, you guys were doing this Overwinter update or something. It was like a part of the sapling, like, on the way towards the sapling update. Did you fix it then or did you fix it later?
00:57:50.760 - 00:58:52.982, Speaker C: So the bug was discovered just prior to the overwinter upgrade, literally, like, a week before it was deployed or something like that. So we didn't have a chance to actually deploy mitigation in Overwinter. The actual mitigation that we did deploy depended on the sapling upgrade. We kind of piggybacked on it in order to make it covert so that people wouldn't independently discover and exploit the bug. Yeah. So as part of the sapling upgrade, Overwinter upgrade was mostly a logistical upgrade that was intended to improve the process of performing another upgrade. Back when we used to call them hard forks, we called it hard fork zero, but we don't call them hard forks anymore in the Zcash community.
00:58:52.982 - 00:58:54.658, Speaker C: Call them network upgrades.
00:58:54.834 - 00:58:56.070, Speaker B: Wise choice.
00:59:00.270 - 00:59:47.990, Speaker A: I see. I just want to, like, I imagine that people listening to this episode for the most part, especially if they've listened back to some previous episodes where we explained a lot of. About trusted setups and where we talked about sort of the zcash model in general. We have covered what the bug exploit would mean, but I think it would. I sort of want to just say it here. Like what, what would have happened if someone had actually gotten that, that piece of information? Like what would they have needed to do to actually what you just described, like mine in the shielded accounts.
00:59:48.730 - 01:00:24.546, Speaker C: So what you can do with these bypass elements, it breaks soundness of the proving system and so you can construct false proofs. So what can you do with that? Well, you can create a bunch of money that doesn't exist and then take it out of this shielded pool, or keep it in the shielded pool if you want, and use it to buy things like other currencies or whatever, and rob everyone of their money. So it's very dangerous. If someone had access to this, they.
01:00:24.568 - 01:00:30.838, Speaker A: Wouldn'T really rob, right. It's not that they would take out money from other shielded accounts, they would just print more.
01:00:31.004 - 01:01:03.700, Speaker C: Right. So there's no way to distinguish money that's been counterfeited from money that isn't. And so as a result, in some sense, well, first off, by inflation, you are in some sense robbing value from other people. But in another sense, because you can take all this money and then the counterfeiter isn't distinguishable. The honest participants of the system look like potential counterfeiters and whose money is real, you don't know. So it's a big mess.
01:01:06.310 - 01:01:43.520, Speaker B: The turnstile actually addresses most of this in that you can see how many tokens have moved from sprout to sapling, and you have an account of how many tokens have been created. And so you know that if there aren't more tokens in sapling than have ever been created, then things seem good. The problem is that you don't know if someone is sitting on a huge stack of coins in sprouts just kind of waiting around. Like, I don't know what they would do with those there.
01:01:44.690 - 01:02:38.702, Speaker C: Counterfeiters exchange their money. That's what they do. If someone's counterfeiting it will be discovered because someone will have moved their money from sprout to sapling at some point, and there was more money being moved than there should have been. And so you'll discover it. You could also have a counterfeiter, potentially, who this turnstile that it doesn't detect, like a counterfeiter that only creates a certain amount of counterfeit funds and only takes a certain small amount of it out and exchanges it for another currency or whatever. And that amount happens to be less than the amount that is lost, for example, by all the participants in the network, because people lose their private keys or they just. Whatever.
01:02:38.702 - 01:03:08.300, Speaker C: So you could totally do it undetected, I think today, actually, I'm not really sure how many coins are in the sprout shielded pool, but I don't think it was ever exploited because I think any rational counterfeiter, rational but evil counterfeiter, would probably just take as much money as they could possibly sell at a time without being detected or something like that.
01:03:09.630 - 01:03:42.818, Speaker B: It feels like they would try to move the tokens over to sapling, be the first to ever move it over and then sell it, because then they have a longer time before they get detected. Whereas once the legit people who are slow and don't necessarily follow all protocol developments start moving their coins over, eventually some legit person moves their coins over and the balance tips over. But the first guy, the evil guy, has already moved all their tokens and.
01:03:42.824 - 01:04:23.390, Speaker C: Maybe sold them on because the evil guy can make as many as they want. I think that the rational thing to do for the evil guy is to literally counterfeit as soon as you discover the vulnerability and are able to exploit it, literally counterfeit as much money as you can possibly counterfeit and sell it as fast as the exchanges will allow you to do so without being detected. And that didn't happen at all. So I'm pretty convinced, on top of some other reasons, that no one ever independently discovered it and that no one ever exploited the vulnerability.
01:04:26.450 - 01:04:56.630, Speaker A: Just to be clear, it sounds like there's still a sprout setup that exists in the world. Because as you mentioned, this is like a fork, right? So there still is sprout somewhere, and then there's the sapling fork or update or upgrade. But could somebody actually exploit this after the fact and somehow move it over? Like if somebody's still working in the sprout version and this has all been published, it's out there now. Could they use this and in any way affect the new chain?
01:04:56.710 - 01:05:42.680, Speaker C: So not in Zcash. That was the whole purpose of the mitigation that was included in sapling was to prevent people from doing this entirely in other cryptocurrencies that still are based on Sprout, which there aren't very many, but there is a couple, then, yes, there is a way to exploit that to create counterfeit funds. We tried to disclose to. I mean, you can't disclose to every one of these projects. Hey, here's this bug. You have to kind of pick and choose who you think is trustworthy enough to tell them, hey, there's a bug, you have to fix it. So we chose a couple projects outside of Zcash and had them fix it as part of our disclosure process before we went public in February or whenever we went public.
01:05:44.650 - 01:05:53.870, Speaker A: I think it was February. But what I mean is, you sort of mentioned this movement. Like, you have to move your funds from sprout to sapling. Frederick, you said this, the turnstile.
01:05:54.450 - 01:06:02.080, Speaker B: But sprout transactions are not valid anymore. So you can generate a sprout transaction today.
01:06:02.770 - 01:06:19.926, Speaker A: Okay, yeah, got it. By the way, Sean, this is really interesting, and thank you so much for sharing this stuff with you, because I can imagine it was quite traumatic. So, yeah, really, thank you for kind of coming on and sharing that.
01:06:19.948 - 01:06:24.214, Speaker C: It's nice. Kind of therapeutic, actually, to talk about it.
01:06:24.252 - 01:06:52.000, Speaker A: Oh, I'm glad to hear that. Cool. Actually, that sort of leads me to the next question. Now that some time has passed, though, what's your takeaway? Looking back on this, it's sort of like you can always say, you have to work harder, you have to look closer. But there is human error. I'm just curious, what do you think of that?
01:06:54.790 - 01:07:30.560, Speaker C: I won't answer with, oh, you have to look harder. You have to. Whatever. But I will answer with, this happened to be in the one spot where we didn't reimplement it. We reimplemented almost everything of the academic prototype that was before us, all the code for Zcash. But the one thing that we didn't tackle was this spot of the ZK snark. And so if we would have done that, I think that we would have discovered it or switched to a different ZK snark or something like that.
01:07:30.560 - 01:08:06.120, Speaker C: But we were resource constrained. And so it was just a matter of used. This protocol was out for a couple of years, so it was somewhat trustworthy. People had looked at it. People had based other protocols on it that were also broken, which we didn't know, but it was just an unfortunate mistake. I don't know that you can't really address it much except adding more resources and more people to prevent it.
01:08:07.130 - 01:08:36.960, Speaker B: Yeah, speaking of reimplementing things and sort of on this mean we at parody are working together with the Zcash foundation to write a rust implementation of zcash. And while it's not re implementing everything, we're still using Bellman, but we've re implemented bitcoin since before. What's your take on this? Sort of having multiple implementations and the foundation having one implementation and the company having one? Is this good or bad?
01:08:37.490 - 01:08:59.820, Speaker C: Yeah, I think for cryptocurrencies, having multiple implementations is great. It. It will very likely increase the chance that someone will discover a fatal bug in one of the implementations. I think multiple implementations is generally a good thing for almost everything that I can think of.
01:09:02.430 - 01:09:38.786, Speaker A: It's interesting, too, that it comes back. It's funny. So in this interview earlier on, we were just talking about this academic implementations and sort of the engineer implementations, and as you described, it was like every piece except for that, that you hadn't redone or whatever. This was found in the one that wasn't redone. And do you think that that maybe is the solution to have? This is kind of going to your point, Frederick, that just re implementing, just having people rewrite everything multiple times is sort the best way to assure safe.
01:09:38.898 - 01:10:40.090, Speaker C: It's one way. Obviously, having verifiably correct code is another way. But I think the point I'm making is that the academic code was written to get a prototype out so that you could tell the journal or the conference that you're submitting your paper to that I have an implementation. It wasn't. I want to put a billion dollars on top of this implementation being correct. We found other fatal bugs in the academic prototype, even in just the code, also in the crypto, but even in just the code that we replaced. And so I think if you're going to use academic prototypes, you need to master the crypto, and you also need to completely destroy all the old code, because academic prototypes are laced with mistakes.
01:10:40.090 - 01:11:07.934, Speaker C: It's not because the academics are. I'm not trying to blame anyone, it's just the academics are creating prototypes they're literally putting at the top of their readmes. Do not use this code, for the love of God. You're going to screw everything up. Please don't. Don't, please. We need to destroy all academic code before it ends up in production.
01:11:07.934 - 01:11:26.360, Speaker C: I think that that alone will help make things a little more efficient. It's also nice to have more people tackling the code so every time you re implement something, someone learns every facet of the code, and so they can identify bugs and mistakes and stuff. So there's a bit of both, I guess.
01:11:27.610 - 01:11:54.850, Speaker B: There's another area of work that I'm very interested in that you've worked on, and it's BLS twelve 381, the curve and the jub jub curve, and it's on this boundary of engineering and academia as well. I always thought it was crypto researcher somewhere sitting in their armchair designing this elliptic curve, but here you are making them. What goes into designing and making an elliptic curve?
01:11:55.190 - 01:13:20.618, Speaker C: So I'm actually a little bit surprised that BLS twelve 380 ones, which is a pairing from the elliptic curve, has grown into this really popular elliptic curve for doing anything regarding elliptic curve pairings. Originally, we were just trying to come up with a curve that was more secure than the curve that we currently had, because the one that we had in sprout under some attack, which isn't possible yet, but theoretically in the future, if someone figures out a way to do it, it would have 100 bits of security, or less than 100 bits, something like that. We wanted to make a curve that was a little bit more efficient than that, or, sorry, a little bit more secure than that, without losing the efficiency. After the sprout upgrade, I just looked at the taxonomy of available curves and the different design constraints and came up with one that kind of fit all the pieces that we needed. And then at the same time, building an elliptic curve that's embedded within it was not really much of a challenge. It's just taking these academic ideas and applying everything and trying to make it really efficient and follow all the constraints. It's not that hard.
01:13:20.618 - 01:13:29.630, Speaker C: For some reason, people just don't do it. I don't understand. Just don't be afraid. Make your own elliptic curve. Go ahead. I really don't see that.
01:13:29.780 - 01:13:35.858, Speaker A: Would you describe what you just said there, where it's like a curve in a curve, is that recursive or is that a different.
01:13:36.024 - 01:14:05.130, Speaker C: It's nested. So essentially you have an elliptic curve like BLS twelve 381, which has a scalar field, which is where you do all the. Your arithmetic circuit is built over the scalar field, and you can construct arbitrary curves on any field. So you just construct another curve on that field. And I call it an embedded curve. But I don't know what else to call that. That curve would be judge.
01:14:06.590 - 01:14:31.150, Speaker B: I have two questions from a listener on this one as well, actually from Jeff Burgess, and I really only want to ask them because I think they hint at sort of how to think about this and how to work with curves, like what the engineering effort that goes into it. So the two questions are, when do we get hashing to this curve, and when do we get constant time arithmetic in this curve?
01:14:31.310 - 01:15:00.814, Speaker C: So I've been working on an implementation of BLS twelve 381 that has constant time. Everything is constant time, even the pairing, which is not necessary usually. That's something I'm working on. It's totally feasible. Hashing to the curve. There was a new paper by Dan Bonet and someone else where they had come up with a technique for doing fast hashing to the curve. And so that's really exciting, and I plan to learn how that works and implement it.
01:15:00.814 - 01:15:27.862, Speaker C: So it's coming up BLS twelve 381. Although it was designed for Zcash originally, it can be used by anything. It can be used by projects that just want to have BLS signatures, which are these really fast aggregatable signatures and things like that. So it's taken a life on its own.
01:15:27.996 - 01:16:00.238, Speaker B: I think a lot of projects that are now dealing with these sort of random beacon chains, they're aiming to have BLS signatures in some regard than usually dealing with twelve 381. It sounds like it's a bit of these questions. It's a bit of mix again of like Dan Bonet and his research team are working on trying to figure out a way to do hashing while you're plugging away at the engineering things of getting constant time.
01:16:00.404 - 01:16:43.166, Speaker C: We had already implemented hashing to BLS twelve 381. That is theoretically constant time. It's just not as efficient as Dan Bennett's paper. We hadn't actually implemented. It wasn't integrated into my implementation of BLS twelve 381. But it was implemented in a couple of others that have spawned off people have made their own implementations, and so there was already hashing to the group. It's just now that this new paper came out and it's much more efficient, everyone should probably move to that new thing before everyone starts using hashing in a specific way, because ideally we'd like it to be pretty standardized and so on.
01:16:43.166 - 01:16:44.080, Speaker C: Yeah.
01:16:44.850 - 01:16:53.394, Speaker A: Are you really involved in that standards talk? I know that there's a lot of people who are trying to get some ZK standards going.
01:16:53.592 - 01:17:31.086, Speaker C: Yeah. I was one of the moderators, committee members of the ZK proofs workshop. The first one and the second one. And the second one was just earlier this month in April. So I guess part of those standard. I think it's a little too early to standardize on certain things like elliptic curves, because everyone needs a different elliptic curve. Ethereum, regrettably, is using this old curve that zcash originally used because they just needed something so that they put it.
01:17:31.108 - 01:17:34.990, Speaker B: In because they wanted interoperability with zcash. And then zcash changed.
01:17:36.210 - 01:17:46.686, Speaker C: Well, I did try to warn them, hey, you should probably use BLS curves instead because of the security thing and everything else. And we're going to switch them in zcash.
01:17:46.878 - 01:18:04.360, Speaker B: There's actually a couple of proposals on the table for the next upgrade to Ethereum to add. There's a couple of different ones. They want one generic sort of pairing over any elliptic curve type of function, and another one for, I think, BLS twelve 381.
01:18:04.730 - 01:19:11.002, Speaker C: Yeah, everyone seems to be picking different curves. For example, BLS twelve 381 isn't the end all be all? Because what if you want to do a nested recursion of pairings or something like that? Well, then you have to use the curves that were in Zexi. Or what if you want to do indefinite recursion? Then you have to use this MNT four or MNT six cycle that's used in, for example, coda. So everyone's going to have a different curve, probably with different trade offs of performance and security and features of certain kinds. And so it's really difficult right now to standardize on a curve. But what we can standardize, I guess, right now is language and techniques and things like that, so we can come to an agreement of this is how you construct a curve rigidly to avoid backdoors or whatever other kind of possible things that you could screw around with. Explain everything.
01:19:11.002 - 01:19:22.250, Speaker C: This is the term you should use for some particular topic and so on. So that's currently what the standardization effort has been focused on, but there isn't much else to it yet.
01:19:22.420 - 01:19:46.120, Speaker B: What do you think about trying to standardize the sort of on disk expression of circuits so that you can construct a circuit in some way and then plug in different provers to the same circuit. As far as I understand, right now, your circuit is completely specific to which library you're using.
01:19:48.250 - 01:20:17.520, Speaker C: There's a lot of people really interested in. Oh, well, Bellman has a really fast implementation of Shotgate 56. I'll just use that and I'll implement my circuit in Socrates, and then I'll connect them. I think that this is, my personal opinion is that this is really silly. I think just implement Shaw 256 in your circuit language. Just do it. And if you can't do it efficiently, then your circuit language sucks, or you need to do something to improve it.
01:20:17.520 - 01:20:30.840, Speaker C: There's no production software that I can see which uses interop in that way that's both efficient and secure. It just seems like totally unnecessary to me.
01:20:33.130 - 01:20:51.822, Speaker B: I think it comes from the sort of, we're used to having protobuffs for wire specs and no one has to deal with specifying byte strings anymore. It's just like, oh, we use Protobuff and then we don't have to think about it anymore. I think people want the same thing for circuitry. It just seems like a different thing, actually.
01:20:51.956 - 01:21:38.300, Speaker C: Yeah. I think that it explodes your surface area of fatal mistakes, because think about it, already we're clamoring for some kind of technique to do verifiable circuits. So we're trying to see, oh, is this circuit a correct representation of the computation? You start mixing languages and interops and everything else, and you deploy that in production. How can you even justify that? You really can't. You really just have to have some robust, centralized implementation of the circuit, in my opinion. If you do anything else, you're building a prototype, maybe, and that's okay, maybe different projects. They want to see if something's feasible, then prototypes are cool.
01:21:38.300 - 01:21:46.320, Speaker C: But do you need to standardize in order to get prototypes? No, I don't think so. At whatever.
01:21:46.690 - 01:21:53.514, Speaker A: Yeah. I actually have one little question on who wrote Bellman.
01:21:53.642 - 01:23:03.830, Speaker C: I wrote, that was literally like Bellman was. I started it in 2014, really? I was trying to implement snarks in rust, and it took years, but eventually I was able to do it and get it into Zcash. It started out as Bellman's purpose originally was to try to build a toolkit for building circuits securely, because the way that at the time that you constructed circuits was really error prone. And I had seen bugs in the academic code in Zcash how you could screw up, and I had looked at the interfaces and I didn't like them. So I wanted to create something that was a little less error prone in those respects, in the respects that I was aware of. So I wrote Bellman originally to try to address those for circuit synthesis, and it ended up being just a general toolkit for building, performing ZK snarks. And it's used today in Zcash.
01:23:03.830 - 01:23:04.806, Speaker C: Yeah.
01:23:04.828 - 01:23:19.370, Speaker A: Actually, somebody asked Kobe, asked us if there were other missing tools that you felt were you, as you just described, you started Bellman in order, sort of as a tool set, as a toolkit.
01:23:19.870 - 01:24:17.646, Speaker C: Right. So I think Bellman in the future is going to end up just being a library with some gadgets in it for constructing circuits, but currently it does that. Plus it's also a ZK snark proof generator and so on. I don't want it to be that, it's too specific, so I'm going to move all that stuff out into different crates. But as far as what new tools need to be constructed, I think it'd be nice to see automatic in some of these protocols, like for example, graph 16 or this new sonic protocol. We can work within the algebraic group model, which is a security model where you assume that your adversary is algebraic. So every time they produce a group element, they also produce its representation, or you can extract it.
01:24:17.646 - 01:25:11.418, Speaker C: And in this model, it seems like we can write formal proofs, formally verified proofs of the ZK snarks. So I'd really love to see automatic generators of these proofs, or verifiers of these proofs, maybe not even just algebraic group model. You could also do generic group model, which is a little bit looser. But automatic generators of these kind of proofs would help us write secure designs of new ZK snarks. Then, as far as applications go, obviously having new dsls for writing ZK snark circuits would be really nice. I'm really unsatisfied with the current set of dsls. I think they're really both my library and every other library.
01:25:11.418 - 01:25:32.360, Speaker C: I don't think anyone's figured it out yet, so I think that's a challenge that's probably going to take. If arithmetic circuits are still integral in ten years, which I think they probably will be, it'll probably take a decade to actually figure out how to design ZK snarks in a really verifiable and clean way.
01:25:33.130 - 01:26:04.180, Speaker B: So before we wrap up this episode, we have to wrap up at some point. Let's dig into a little bit of future stuff. We have some questions left from listeners as well, but I'm curious to hear what your take on Starks is in particular, because that is like the buzz of Starks will replace snarks because they don't have to have this trusted setup and still have all the nice properties. Kind of, sort of. No one really knows yet, but what do you think about it?
01:26:04.790 - 01:27:12.550, Speaker C: I think Starks are really awesome, and all these other proving systems that are surrounding them. I haven't been living in symmetric land for four years now, so I don't know what the hell they're doing, but they're really interesting, and they keep making them more efficient. I think snarks will always be cream of the crop in terms of performance until they can't even be used anymore because quantum computers or whatever shows up and breaks everything. So right now I'm living in denial that that'll ever happen and trying to enjoy the pairing friendly world that I live in. So I don't really know much about those things. I'm really interested in other snark proving systems. I think in terms of future things for snarks, I'm really interested in new proving systems like sharks, like I explained earlier, and then also improvements that can combine sharks and sonic maybe, but also parameters that are small.
01:27:12.550 - 01:27:49.858, Speaker C: So we have ZK snarks where the parameters are linear with respect to the circuit size. I would love to see a ZK snark with parameters that are logarithmic or something, or constant with respect to the circuit size. That would be really amazing because that would make the process of updating parameters really efficient. So that's something that I'm hoping that someone will figure out in the next year or two. Probably won't be me, but maybe someone will. I've been trying, but Dara Hopwood, your.
01:27:49.944 - 01:28:06.310, Speaker B: Colleague, actually asked on Twitter, besides the systems you're involved in developing yourself, what developments in ZK proof systems are you most excited about? But maybe we take the twist of, like, things that exist, not things that could exist. What are you most excited about?
01:28:06.380 - 01:28:53.160, Speaker C: Things that exist. Well, I guess seeing recursive snarks deployed in coda will be really fun. Coda might be the second project in production that deploys with general purpose zero knowledge proofs. So that's really fun. Seeing more projects actually do npcs would be really cool because it would lead probably to more reimplementations of the protocol for the NPC. And so you'd have more robust software and people come up with cool ways to perform ones that. Those are the things that I'm particularly excited about besides future things that don't exist yet.
01:28:54.410 - 01:29:03.866, Speaker A: After these years of working in the space, are you still getting that thrill from when these things work or discovering these things?
01:29:04.048 - 01:29:59.926, Speaker C: So originally I fell in love with snarks because they're just magical and they really are magic. The fact that you can have a proof that's a couple of hundred bytes in size and it can verify a computation that is enormous within a millisecond is incredible. Eventually, I get a little bored with that, and I want to go a little bit further. And now I think things are exponentially increasing in terms of the productivity of the crypto community. So we have new papers coming out every month or so that completely blow everything away. For example, with Sonic, I'm a little scared to do a sonic NPC, like a universal, updatable sonic NPC, because I fear that in a month or two someone will release a paper that blows it away in performance. So it's really just increasing.
01:29:59.926 - 01:30:10.000, Speaker C: It's out of control, and I don't know what to do. So maybe I'll start sitting back and waiting for everyone to figure it out before I start contributing again or something.
01:30:10.770 - 01:30:20.500, Speaker A: I think we're kind of at the end here. Ariel Gavizon did leave one last question, which is like, what does Eb full mean? Your Twitter handle? But I don't know if you want to answer that.
01:30:21.510 - 01:30:41.980, Speaker C: I really don't want to answer that. It's a silly story. I don't know why. I had a piggy bank that was named e when I was younger and I needed to pick a username, so I said e will be full, and then I shortened it to e be full. I don't know. It's totally ridiculous. That's actually great.
01:30:43.630 - 01:30:50.906, Speaker A: Cool. Nice. So that was so nice chatting with you about all of this.
01:30:51.088 - 01:30:53.530, Speaker C: Yeah, it was really awesome to talk about this stuff.
01:30:53.600 - 01:31:04.078, Speaker A: We'd love to have you on again sometime on maybe a deep dive in one of these topics as they develop. So, yeah, cool. You're always welcome on the zero knowledge podcast. Good to know.
01:31:04.164 - 01:31:07.040, Speaker C: Yeah, I'll let you know when I come up with something new.
01:31:08.450 - 01:31:10.078, Speaker A: So, yeah, thanks again.
01:31:10.244 - 01:31:11.006, Speaker C: Thank you.
01:31:11.108 - 01:31:13.626, Speaker B: And to our listeners, thanks for listening.
01:31:13.738 - 01:31:14.410, Speaker A: Thanks for listening.
