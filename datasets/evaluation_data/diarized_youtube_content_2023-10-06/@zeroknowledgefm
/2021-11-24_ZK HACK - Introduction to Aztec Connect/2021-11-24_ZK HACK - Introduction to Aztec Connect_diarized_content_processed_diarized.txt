00:00:01.930 - 00:00:02.986, Speaker A: Hey, Joe.
00:00:03.178 - 00:00:05.440, Speaker B: Hey, how's it going? Hi. Hi.
00:00:06.210 - 00:00:07.374, Speaker C: Hey, everyone.
00:00:07.492 - 00:00:19.120, Speaker A: Hello. Okay, I'm taking this down. Welcome, Zach and Joe. Today we get to learn about aztec connect. Zach, actually, who's going first here? It's Zach, right?
00:00:19.890 - 00:00:20.542, Speaker B: Yes.
00:00:20.676 - 00:00:24.334, Speaker A: Perfect. So why don't we get your slides set up and then you can take it away.
00:00:24.532 - 00:00:24.966, Speaker B: So.
00:00:25.028 - 00:00:35.670, Speaker C: Sounds good. Yeah. Let's get this show on the metaphorical grid. By jumping in halfway through the presentation.
00:00:36.410 - 00:00:40.506, Speaker A: We can see both of your slides here. I think you mean to show the other one.
00:00:40.608 - 00:00:40.874, Speaker B: Yeah.
00:00:40.912 - 00:00:49.900, Speaker C: Okay, 1 second. Let me just. I'm just going to kill my second monitor because I don't think my web browser is actually.
00:00:50.530 - 00:00:56.366, Speaker A: When you do the share, you can actually choose which browser sometimes or screen.
00:00:56.468 - 00:01:05.058, Speaker C: But if this works, I think it works. Joe's around, so, Joe, can you just heckle that people are asking questions because I can't see the chat at the moment.
00:01:05.224 - 00:01:09.060, Speaker B: Yeah. I can also post them as perfect.
00:01:10.950 - 00:01:33.286, Speaker A: For anyone who is asking questions. Put them in the sessions chat, not the events chat. If you see there's event my agenda sessions just pick sessions chat. There's also the Q A. The Q A will potentially bring that more to the forefront. Sometimes questions can get a bit lost in the chat, but, yeah, take it away. Now we get to learn for Zkhack all about privacy.
00:01:33.286 - 00:01:36.202, Speaker A: Defi with aztec connect. Looking forward.
00:01:36.256 - 00:02:04.574, Speaker C: Awesome. Thanks, Anna and yeah, hi, everyone. Yeah, super excited to be here and be a part of this with you all. So I'm Zach. I'm here with Joe. We're both the co founders of Aztec and we want to talk about our latest project that we are deploying to mainnet in the next one or two months called Aztec Connect and going through how to build with it and what it is and all of that. Goodness.
00:02:04.574 - 00:03:10.550, Speaker C: This might be a little bit of a more higher level workshop than some of the other ones because this is all about, as I get, is all about how do we interact with layer one smart contracts from a L2 in a privacy preserving way. And specifically around. We're going to be talking about the cryptographic protocol that we've developed to do this and how one actually interfaces with it in the form of. By creating layer one smart contracts that effectively perform a translation step that maps, takes tokens coming in from the asset network, puts them into a layer one smart contract, gets some kind of output and returns it back to the network. We call these things defi bridges. And we're pretty excited about what they open up on Ethereum and in theoretical and other blockchains. As a way of both scaling Ethereum, adding privacy without some of the drawbacks associated with L2s, like liquidity, fragmentation and all of that jazz.
00:03:10.550 - 00:03:46.514, Speaker C: That's kind of the high level what we're going to be doing. We're going to split it into two talks. I'm more kind of theory. Joe's going to be then doing some on the applied side, running through, actually. How does one program with Aztec Connect? How does one build these privacy preserving bridges and doing an interacting coding session? So, Joe, would you mind sharing some links in the chat? Because if folks want to get kind of set up with that, we have some tooling and resources in a starter kit that Joe will be using quite heavily. Yeah, just paste. Awesome.
00:03:46.514 - 00:04:38.786, Speaker C: So, yeah, basically, high level background, what are some of the issues? Well, I think we've all probably used ethereum or at least heard about some of its problems. It's crazy expensive to use because of the extremely high demand and limited throughput. And on top of that, something which is going more of an issue day by day is the more that people, individuals kind of economic activity is being put on chain, the more information that's being leaked about their identity. And if we don't solve this fairly soon, then web3 is going to go the very same way of web two, where the primary monetization model is going to be farming people users information, which I don't think any of us here want. That's why we're here. So that's what we're trying to. So one of the steps along this very long pathway is this aztec connect project that we're building effectively.
00:04:38.786 - 00:05:28.078, Speaker C: It solves these two issues on Ethereum today. It enables users to interact privately with DeFi protocols on layer one without having to fork or migrate a protocol to a L2. And the goal is for it to be easily integrated into existing projects with very little actual cryptographic knowledge required to use the interface. So, briefly, we talk about Defi pooling. How does it work? Well, imagine you've got a bunch of people that want to do the same kind of transaction, like, say, swap eth to die on unitswap. Well, if they will have funds on the asset AI two, what we will do is we will aggregate all of their transactions together, and we do that through ZK Snox. So each of these transfers is a private transfer where each individual transaction is itself a ZK snark proof.
00:05:28.078 - 00:06:43.286, Speaker C: And then inside our L2, we have something called a. Well, it's a Zk roll up. And in our roll up circuit we verify the correctness of a large number of these individual transaction proofs, and in the context of d five pooling, this means that everybody's transactions get effectively added together, so that when this rollerblock gets processed on layer one as part of the public input, there'll be an instruction to send a single transaction to a layer one smart contract to swap the aggregated sum of everybody's eth for DAi. In this case, this will happen through a bridge contract where the idea will be that the bridge contract understands the aztec L2 interface, it understands the smart contract interface it's talking to. It'll perform the UnisoP exchange, send the tokens back to Aztec, and then the proceeds will be disseminated back to the users in the correct ratios again via some zeros proofs, and the output of this will be encrypted notes where the identity of the individuals transacting has been hidden at every step of the way. So I mentioned bridging a lot. How does it work? Well, we model a one smart contract interactions as either synchronous or asynchronous token swap.
00:06:43.286 - 00:07:34.110, Speaker C: So the idea is you have a couple of input tokens, a couple of output tokens, the addresses can differ, the exchange rate doesn't have to be known ahead of time, and the bridge contract will receive these tokens from our aztec wallet. Smart contract. The bridge contract will then do some kind of predefined deterministic interaction with a layer one smart contract or multiple smart contracts, and then return the funds back into. Return the output tokens back to aztec. Anybody can write these bridge contracts. The end state of the network is going to be completely permissionless and we're quite excited about some of the applications. This opens up things that you can't really do on Ethereum right now, things like fully blind auctions or private voting, anonymous voting, as well as the more standard use cases like being able to cheaply and privately access trading and lending protocols.
00:07:34.110 - 00:08:44.178, Speaker C: So I would like to go a little bit into the actual circuit architecture because this is Zika hack. So I imagine folks are a bit more interested in the lower level governance of how this actually all works. Particularly what are the ZK stark circuits constructed as? Because actually executing this kind of protocol is fraught with challenges, both to ensure that it's efficient to use as a lot of xenon's proofs have to be constructed on the client. These proofs are relatively complex, but also to ensure that no information is leaked at any step of the way, whilst ensuring validating the security of the entire architecture. So aztec connect consists of four ZKsnark circuits. So the left hand ones are kind of what we call user circuits, because they represent individual transactions. And the right head ones are circuits whose proofs are generated by third parties that have a reasonable amount of resources, say like a 32 core machine, and they aggregate batches of individual user proofs together.
00:08:44.178 - 00:09:27.726, Speaker C: And this is an untrusted component where there's no sensitive information they have access to. By that point, all information has been obscured by the user proofs. And so we have this joint split transaction, which is its genesis came from Zcash and the zerocoin paper that they implemented, where you have two kind of input encrypted UTX objects that represent value. They get destroyed. You create two UTX objects in their place, and you validate that the sum of the input nodes that have been destroyed matches some of the app notes that have been created. And the app inks can have different owners. And this is how you do transfers.
00:09:27.726 - 00:10:34.840, Speaker C: You can modify it relative trivially to also handle deposits and withdrawals of ERC 20 tokens and Ethereum from layer one. And we've also modified our transport circuit to perform these DFI deposits. And then the DFI claim circuit will basically, it'll take the result of a layer one interaction, presumably a DeFi interaction doesn't have to be though, and convert the notes created from the defi deposit, step back into fungible output token nets. And finally, we have our roll up circuit, which will aggregate all of these transactions into a single proof. And we actually have on top of that, a root roll up circuit, which will aggregate roll up circuits. And so instead of doing doing so, if you say, want to aggregate 512 transactions in one shot, instead of making one big circuit to do that, you split it up into this kind of tiered hierarchy to make it more efficiently parallelizable. And so this makes very, very heavy, heavy use of recursion using syntax that we developed roughly twelve months ago.
00:10:34.840 - 00:11:15.250, Speaker C: So, yeah, I've kind of combined two slides and one I'll skip over the slide length because I've already said this as a diagram. This is what it looks like to do a Defi deposit. So the idea is the traditional way that you represent value in Aztec is using these value notes. They're commitments to a public key, which defines the owner of a note, an asset id and a token. And the value of the note I've left out here. There's also a secret associated with the note that you need to prove knowledge of in order to spend it. And that's what makes the commitment hiding.
00:11:15.250 - 00:11:57.090, Speaker C: So you have two input value notes, they get destroyed, and in the place you have an output value note, which is kind of like your change note remainder node. And a claim note. And claim note is a bit of a weird construction because what it is is it represents a claim on a future transaction that has yet to be processed. Specifically this layer one defi interaction. Its components are, it has a value, the amount of value that's been deposited. This thing we call the interaction nonce, which is just basically a unique identifier for the DeFi interaction. So every DeFi interaction that Aztec makes will have a unique interaction nonce.
00:11:57.090 - 00:12:15.826, Speaker C: But we do some rather. I've abstracted away a fair bit here, because when you're making one of these proofs using RSDK, you don't require knowledge of the interaction nonce that gets added in later when the rollout block is created, because otherwise you'd have a bit of a race condition.
00:12:15.858 - 00:12:16.440, Speaker B: There.
00:12:18.270 - 00:12:38.270, Speaker C: You have this bridge id, which describes what DeFi traction you're performing as well as this thing that we call the partial state. So the bridge id is the easy one to explain. It basically describes what's the input asset, what are the two output assets, and what's the contract address of the bridge.
00:12:39.090 - 00:12:40.880, Speaker B: That'S being talked, spoken to.
00:12:41.890 - 00:13:27.274, Speaker C: But the partial state is a bit more complicated. What it really is is it's half of a value note commitment. Because what we want, the main goal that this solves is this claim note represents some future transaction that's going to happen. And when that transaction happens, we're going to transform this claim note into some value notes. So for example, if you're doing an ETH to die swap, then you're destroying eth. And the claim note represents a claim on some future die that'll then have to be in a later transaction converted into a die value note. But we don't want the user to do that because that's a pain in the neck, right? Like if you're transacting with ethereum or another layer one or even L2, and you perform a DeFi transaction, you expect that as a user to be non interactive.
00:13:27.274 - 00:14:21.738, Speaker C: If I trade on uniswap, I don't want to have to come back a while later and then kind of perform this kind of conversion proof to convert a claim to a value note. And so we're taking advantage of the fact here that our commitments to value notes, they're pedicin commitments, so they just use, they're created over elliptic curves. Elliptic curves have this very nice property that they're homomorphically additive. And so it's possible to create a partial commitment to a value node. Basically, it's a value node that doesn't have a value and it doesn't have an asset id, but has everything else has the secrets, it has the user public key. And then at a later stage, we're going to complete the commitment. Once we know what the value of this note ought to be and what the asset id ought to be, we will then create that partial commitment and mash that together with the partial state to create a value note.
00:14:21.738 - 00:14:30.210, Speaker C: And this can be done completely trustlessly by a third party. The user that created this deposit circuit proof doesn't need to be involved.
00:14:32.470 - 00:14:32.786, Speaker B: So.
00:14:32.808 - 00:15:15.870, Speaker C: That'S why we use it. Obviously, this does leak some information. Specifically, the user identities here are all hidden, but the value is not. Because in order to perform this deFi aggregation, you need to know how much value is being put into the defi, into a bridge contract in a given rollerblock. And so that's public. Its components are public. So in terms of your privacy, anonymity and anonymity, a defi interaction or an asset connect interaction can be very much modeled as a traditional withdrawal interaction or an unshielding interaction from a privacy preserving network.
00:15:15.870 - 00:16:11.102, Speaker C: It has the same properties where you expose a value that you're extracting from the network. And therefore, if one is not being careful about when they do this and the values being used, then it can leak some information that can allow transaction graphs to be extracted in a similar manner in proper use of the zcash protocol. So anyway, those are claim notes. That's our DPI deposit flow. The roll up circuit will then aggregate all these claim their values together per bridge id, and that's what gets spat out as public inputs. Each aztec roll up block can process four DeFi interactions, up to four, as in can talk to four unique bridge ids. And each one assumes that each interaction will have a relatively large number of batched aggregated transactions.
00:16:11.102 - 00:16:52.474, Speaker C: This is valuable because the expensive cost of that layer one interaction gets shared across all the users in the batch. And so when it comes to actually redeeming this claim node, yeah, this is the redemption circuit. So if you create a deFi deposit proof, you send that to the Aztec network that gets aggregated by a rollup provider, and then in an Aztec rollup block that gets processed on chain, the layer on smart contract will perform as defi interaction, and it'll generate this data structure we call the interaction result, which just basically has to describe what happened.
00:16:52.612 - 00:17:10.086, Speaker B: Zach, we've got one question quickly, just on the partial state. Yes, just any other places where this is used or kind of literature about this idea of kind of a partial commitment and then extending it, guess is the question.
00:17:10.268 - 00:18:07.270, Speaker C: Not that I know of. I don't think this is particularly common, although I suspect it's also quasi folklore. So as like fancy cryptographer term for just. It's probably been done before, but not written about in an academic journal, because these partial state objects, so you're creating like part of a commitment and then combining it later on. You wouldn't do that in a traditional kind of cryptographic protocol, like a commit reveal type scheme, because it leaks information. By creating this partial state and then completing it later on, you expose some of the plain text for that thing, the data that you're encrypting, specifically the value of the note. And in most kind of like basic cryptographer protocols, that would kind of be a bit of a deal breaker.
00:18:07.270 - 00:18:54.338, Speaker C: But in our case, it isn't because of the way that the anonymity network is structured. It's the same anonymity guarantees as withdrawal from the network. The important thing here is that the identity of the not owner is hidden, which is fortunate. Yeah, so that's. Yeah, so, yeah, cool. So get back to the interact interaction results. It basically describes like, what was the bridge id that was, that was spoken to? What was the interaction nonce, how many tokens were shoved into it, and how many tokens were received.
00:18:54.338 - 00:20:00.730, Speaker C: There can be up to two appetite tokens or two appetite values, and also a success variable, a boolean, which describes whether this interaction result was successful or not. Because one of the properties that we wanted from this architecture was that you could kind of successfully fail a transaction. So if you do a Defi interaction that fails for some reason, because some conditions weren't met in the DeFi protocol, your funds aren't lost, you get back your input asset. So we're kind of taking advantage of the fact that you can kind of, inside an Ethereum smart contract, you can transaction, you can partially revert a failed transaction. So whenever the roll up contract performs a defi interaction, if that deFi interaction fails in any way, then that component of the roll up transaction will get reverted. And so it's like the tokens never left the network at all. And so for a failing DeFi interaction, you can take your user claim notes and effectively convert them back into the input.
00:20:00.730 - 00:20:54.494, Speaker C: You can use them to create a note whose value is the same as the value notes that were destroyed to create it. But if the interaction did succeed, then use this interaction result data to take claim note and convert it into its allotted output notes. Just doing a simple ratio check. So you take like how much is this note worth as a proportion of the entire amount of tokens that were sent into this in this defi direction and whatever that percentage is, that's how many of the alpha tokens for each asset type they're also due. I did have some formulas here, but they didn't get correctly copied across to the slide and I've really just noticed that. But this is basically the. Yeah, it's just you take the user's input value divided by the total input value.
00:20:54.494 - 00:21:35.020, Speaker C: That's your ratio, and then you multiply that by either the output value for the a or b output token to get these output values, v one or v two. And additionally those asset ids of the output nodes, they're also conditional whether the interaction succeeded or failed. If the interaction succeeded, they're going to be defined by the output token ids of the bridge id. But if the interaction failed, they'll be equal to the input token ids. And so the important thing here is that from the user's perspective, this entire transaction flow is not interactive. They don't have to worry about making this claim conversion proof. The roll up provider can do it.
00:21:35.020 - 00:22:37.100, Speaker C: Something I missed out here is we've embedded some information in the claim note to ensure that the roll up provider gets paid a fee for performing this conversion step. So isn't there economic incentive to do so? Specifically in this defi deposit flow? I've mentioned here that the transaction fee paid to the role provider. It's the difference between the sum of the input and the output values. What I didn't mention is that fee gets split across two transactions, so the roll up provider will get half of that fee when this circuit proof is aggregated into block. But the other half of the fee is recorded inside the claimant directly and is only kind of released to the roll up provider when this claim conversion proof is processed, which provides the economic incentive for this second component to happen automatically from the user's perspective. So yeah. Any questions before I move on?
00:22:37.630 - 00:22:47.860, Speaker B: That's one question. I'm not sure I fully understand it, but could we have a case where u one is negative while u two is positive on layer? I'm not quite sure, no.
00:22:48.630 - 00:23:42.530, Speaker C: So yeah, we explicitly forbid negative values because that creates problems. So yeah, we use a ton of range proofs here to make sure all the token value, all the values have to be positive here. There can't be any overflows. There can't be any underflows. Technically, note, values in a stake are 252 bit integers, so a token value is a 256 bit integer in allowance. Smart contract. So in theory you can't represent a complete token balance, but in practice you can, because apart from some very niche custom created token, it's unlikely that you'll have individual transaction values that extend beyond two to the two five two, because that would be one 16th of the entire potential maximum valuation of that number of tokens in that network.
00:23:42.530 - 00:25:05.338, Speaker C: To summarize this, the goal is to create kind of composable L2 to layer one transactions that are aggregated via ZK Snok proofs. This allows relatively cheap access to layer one DeFi protocols without splitting liquidity across multiple networks. Because the actual liquidity of the DFI protocol that all stays on layer one, the only thing that changes is the ultimate kind of like the assets that individuals hold move to the L2, but the actual default protocols and their logic and the execution of that protocol stays on layer one and including all of the associated liquidity. So the goal is for this to be to create a very pleasant user experience where the transaction is relatively cheap and they know they're getting the best rates and the best prices because they're not having to take a risk by porting migrating to a fragmented liquidity pool on IoT. But most importantly for us at least, identities are hidden when used correctly. It's completely privacy preserving with a sufficiently large anonymity set. And our target is this is a little outdate.
00:25:05.338 - 00:26:25.906, Speaker C: We're going to be targeting roll up blocks every 10 minutes on the network, but this is very much a function of throughput and demand. And yeah, anyone can write these bridge contracts and then get a roll up, have a roll up block, kind of aggregate those bridge transactions. And this is why we're part of the CKhag workshop, is because we want to encourage folks to experiment, play around with these bridge contracts, try some novel applications, if any of these are kind of igniting any brain cells, because it can enable some rather interesting flows that aren't possible at the moment. Things like time weighted purchases, subscription services that are private, being able to do blind bidding, private voting kind of genuinely enables some genuine anonymous dowels where you don't have the issues of kind of social peer pressure or group pressure influencing how stakeholders vote. So yeah, I think this is where I'll hand off to Joe who's going to go dive into how one actually goes about programming these privacy preserving bridges and doing a bit of an interactive coding session.
00:26:26.098 - 00:26:40.410, Speaker B: Thanks, Zach. Yeah, just on the blind auction one just before you go, is it worth doing? What could have happened if constitution Dow had been inside Aztec? I think you had a good analogy to that. That's maybe worth sharing.
00:26:42.670 - 00:27:24.780, Speaker C: Yeah, I can remember it. The constitution. Dow was an awesome project. Right? It really showed the potential of what web3 technologies enable disparate groups of individuals being able to coordinate and organize with one another towards a shared purpose in a way which is really just isn't possible using any other technology. But the downside of this was that, well, everything was public and everything was transparent. So when they were trying to buy the constitution, but all these competing bidders could see exactly how much money constitution Dow had to spend on it, which is a bit of a problem in an auction. So we're not saying, oh, there should have been zeta, because asset keg isn't launched yet, so they couldn't have.
00:27:24.780 - 00:27:51.794, Speaker C: But the end goal is that dows like these can accept deposits from users through privacy preserving network like aztec, and so that nobody, apart from some kind of coordination committee within the DAO, would actually know what the total amount of deposited value was. Cool.
00:27:51.832 - 00:28:19.958, Speaker B: Thanks, Zach. Before I start, I'll just dive into these questions on the block time. So this is a ZK roll up. So there's no kind of withdrawals like the optimistic roll ups. So there's no kind of withdrawal time. The reason we've picked a target of a 30 minutes block time is just for batching of transactions. The layer one roll up costs around 400 to 500,000 gas to validate.
00:28:19.958 - 00:28:47.080, Speaker B: So if someone wants to pay the full cost of that, we can do it every ethereum block, they just will be paying a lot more for the cost of privacy. So we're trying to get several hundreds of transactions batched together and split that over a number of defi interactions. But there's no real theoretical limit on kind of getting this down. I think the current proof cost takes about 3 minutes to make. So that's kind of a latency that you could expect if you're willing to pay.
00:28:47.610 - 00:29:26.980, Speaker C: Yeah, just to add on for that, like the current latency, 3 minutes, if that was a bottleneck, we could get it down significantly. But the reason I mentioned 30 minutes is because basically you need to aggregate a relatively large number of transactions, say 100 to 200, to make these transactions economical for the user. And so how many blocks you can process in an hour depends on how many transactions you have. So, yeah, if we had high throughput, then we would go down from 30 minutes to 10 minutes to 5 minutes, down to 3 minutes. Then we'd have to do some work on the core architecture to get it lower than that.
00:29:28.150 - 00:30:21.170, Speaker B: Yeah. Just for the current state, Suziki money, which is using slightly older system, is able to do 112 transactions in around 20 minutes. We currently don't send those proofs, so unless the roll up is full, and we kind of do blocks every two to 6 hours. Currently on the current system, if the roll up is full, it will go in around 20 minutes. It takes about 20 minutes to construct the proof, but, yeah, it's not paralyzed at all. And if you were on a chain that kind of had cheaper gas prices and people were willing to kind of pay, then, yeah, you could have cheaper, much faster latency. Yeah, I think banned smart chain, I think has the required opcodes.
00:30:21.170 - 00:30:56.350, Speaker B: Maybe later next year we'll do some analysis on kind of which other side chains or optimistic roll ups we want to deploy to. But for now, the focus is layer one liquidity, because we think the strongest demand for privacy is on l one with l one defi protocols. Cool. I want to get started. I don't know how far we'll get through this. Just a quick agenda. We're going to kind of do a quick demo of the Uniswap bridge on the gurley test network, kind of see how you interact with this with RSDK.
00:30:56.350 - 00:31:47.470, Speaker B: I'll run through some more slides just to kind of hammer home some of the things Zach was saying on how this actually works. When you're thinking about coding up one of these contracts. And then we'll dive into the starter kit, run through the code behind the Ugswap contract, and then if we have time, we'll start looking at how we're planning on implementing the element finance bridge contract, which is going to be one of our launch partners. They do stable lending, so the last part is going to be like a completely live coding, so please forgive any errors, but it should be quite fun. So let's get started. Just reiterating what Zach was saying here. Depending on the d five protocol, we can bring ten to 30 times gas savings directly to layer one.
00:31:47.470 - 00:32:31.830, Speaker B: This is using batches of kind of around ten to around 100, depending on kind of how much savings you want to give to the actual user. And all of these interactions are anonymous, so great privacy to existing l one smart contracts. It's just a quick schematic on how this works there for the Uniswap example, which we'll see in a bit more detail in a minute. Just again to run through some stuff that Zach said. I think this has all been explained in terms of actual gas costs. I think the one thing we didn't go into in the earlier slides are kind of the cost of one of these interactions. We're targeting around 8000 gas per transaction at launch.
00:32:31.830 - 00:33:14.406, Speaker B: That's the cost of privacy. So kind of the shared cost of being in one of our roll ups, you then will split the cost of the layer one transaction between all users who are in your batch. You always have the option of kind of going it alone. I think of it a bit like a private Uber and kind of being in a roll up with other people, but doing your own d five interaction. If you don't want to kind of wait for that kind of aggregation to happen and wait for kind of ten to 50 of the other users. These gas savings pretty significant when you're looking at layer one d five protocols. Because an average unisor transaction is around 170,000 gas.
00:33:14.406 - 00:34:25.538, Speaker B: Some of the more expensive lending protocols come out at close to 350,000 500,000 gas. And we'll see. In the case of element finance, the end to end flow for some interactions can be close to 750,000 gas. When you're kind of dealing with complex year and vaults and complex interactions, the costs add up quite quickly and have priced out a lot of users from layer one defi in a bit more detail. We'll do this with the code, so I'm going to skip this slide for now. The interface, I think is an important thing to go through because it's kind of written in solidity for people who are interested in kind of ZK programming, but maybe don't have kind of the deep cryptographic knowledge. The Aztec connect SDK and the bridge enable you to kind of get started with using and bringing privacy to users, but not necessarily having to worry about the kind of deep cryptographic implementations on day one.
00:34:25.538 - 00:35:08.618, Speaker B: So any developer who knows solidity can write a bridge contract that conforms to our interface. There's only three functions on the interface as a convert and a finalized function, and we'll go into that in a bit more detail. But the interface supports up to two input tokens. Those are shielded tokens coming from Aztec, and you can give back up to two output tokens back to kind of the aztec network. And those are distributed pro router to every user who took part in the original aggregated transaction. Cool. So just a bit of background on element, which we'll dive into in a minute.
00:35:08.618 - 00:36:12.530, Speaker B: We're likely launching with element through our ZKE money interface. Element is a great kind of target when you're thinking about building a bridge contract, because in the early days, when the roll ups are going slightly less frequently, you're doing fixed rate lending. The interest rate doesn't fluctuate drastically over time. So if you're putting in a small amount of money into one of these lending protocols, the difference of kind of 30 minutes to 2 hours being in a batch doesn't actually affect kind of the overall return you get from being in this protocol. So it's a great target for batching. And also the fact that these are kind of fixed rate interest protocols and fixed term mean, the maths behind this is actually lends itself quite nicely to batching. And they support a lot of popular assets that people usually would like to hold because they're long that asset, but also want to earn additional yield just from holding those assets.
00:36:12.530 - 00:37:25.018, Speaker B: And in terms of the gas costs, it's quite expensive. So end to end for some of these flows, for large notionals, you're talking around 750,000 gas, which if you split that between 50 to 100 users, huge gas savings and enables kind of l used by smaller users who have been priced out, which is a bit more aligned with the original, I think, ethereum ethos, which we've moved slightly away from because ethereum is slightly becoming a whale chain. So we're trying to kind of use some of this technology to enable people to interact with all these amazing protocols that have been built on top of layer one and a bit more battle tested on main net. So if people haven't done this already, and you kind of want to kind of code along with me, there's a starter kit at aztec protocol, GitHub, Aztec Connectstarter. We also have a grants program. I will share the link in the chat shortly. The grants program is something we're kind of very excited about.
00:37:25.018 - 00:38:40.140, Speaker B: We're going to be giving kind of engineering resources to helping people write bridge contracts for their favorite DeFi protocols. And we'll also be kind of funding, both in a monetary perspective and subsidizing successful bridge contracts when they're deployed to the network. So if you have an interest in kind of helping code up a bridge contract for popular deFi protocols that you know about or a part of the community, apply to our grants program, and even myself or Lisa or John from our Grove team will be in touch to kind of schedule a call to chat through what you want to do, and hopefully we can get some really exciting bridge contracts written to share the link in the chat right now. All right, I'm going to try and switch screens. It's coming through okay.
00:38:44.670 - 00:38:45.420, Speaker C: Yes.
00:38:46.430 - 00:39:29.146, Speaker B: Fantastic. Cool. So Zach mentioned this a little bit on the earlier call, but the way you interact with a bridge, I think is important because it's just something that sometimes gets forgotten about. All of these interactions at the end of the day are zero knowledge proofs, so they run in the browser. In order to be privacy preserving, you need to construct this proof in the browser. So the starting or the entry point for a user who wants to interact with your proof is not a solidity or ethereum transaction. They're going to be making an aztec L2 transaction using our SDK, which under the hood is constructing Azure knowledge proof.
00:39:29.146 - 00:40:29.674, Speaker B: In this example, I'm about to do a demo of we're just running the SDK locally, kind of in node Js. It's just a typescript SDK and it runs in the browser. The way you kind of interact with a given bridge is you have a bridge id, which kind of defines the smart contract address you want to call and the assets you're willing to transact with. So you can see here down on line 76 in JavaScript talking about, I'm just coding up here the Uniswap bridge id, and I'm passing in the address of the d five bridge, which we define up here as our uniswap bridge. We'll go through in a second while we're waiting for the transactions to settle. In this case we're going to be depositing ETH and getting back some test die on a kind of gurley test network. And you can see that the client code is about this does a full deposit.
00:40:29.674 - 00:41:34.806, Speaker B: So the user here is starting with ETH, shielding the ETH, and then they're going to take some of their shielded balance, deposit it to the deFi protocol, and then do a deFi deposit and wait for it to claim and end up with a die on the Aztec network. So there's a little bit more code here because there's that deposit step, but it's pretty simple to actually integrate into a front end. So let me just run this, and whilst it's kind of running, we can pull up etherscan and kind of watch what's happening and then we'll talk through the code in a second. So the first thing the SDK does is it creates the proving keys to enable you it to construct these proofs on our testnet. There's been some roll ups previously, so it's just doing a quick sync of our balances and then it's already starting to generate my ETH deposit proof. And in a second you can see what I've done here. I've shielded 0.2
00:41:34.806 - 00:42:13.838, Speaker B: e. We're waiting for that to settle before it actually does anything to do with DFI. And if I head over to 1 second, if I head over to ETH scanning, we can see here I was playing with this earlier. This is the roll up contract. My deposit has just come into the roll up contract. We can see zero point 20 e, so my shielded amount plus the network fees. I've got a message from Zen.
00:42:13.838 - 00:42:15.730, Speaker B: Is the video not coming through clearly?
00:42:19.030 - 00:42:20.580, Speaker C: I can see it.
00:42:21.030 - 00:43:23.560, Speaker B: Oh yeah, I'll keep going. So here you can see basically that this has come from me. Any deposits into the shielded pool are public, but what we're trying to do here is show that the interactions inside the pool are obviously private. So still waiting for that to settle. Our roll up provider on Gurley is a little bit slow and takes around 2 minutes to construct one of these proofs. But in a second we should get a roll up proof coming out on the gurley roll up contract, and that will effectively give me as a user my shielded balance that I'm then free to spend in one of these shielded DeFi transactions. Whilst we're waiting, I can pull up what the contract actually looks like.
00:43:23.560 - 00:44:31.160, Speaker B: So the interface for the Defi bridge contract has kind of three main functions. The main one that most bridges will use is convert. This is called by the aztec roll up contract. Whenever a roll up provider sends a roll up that contains an aggregated defi interaction. So when that roll up is received and validated, the aztec roll up contract will call out to your defi bridge contract and it will kind of pass in the deconstructed bridge id. And the bridge id, as we talked about before, has two input assets and two output assets and some input value. Oh, so we just got a transaction so we can head back and see the shield just a secondary.
00:44:32.800 - 00:44:33.870, Speaker C: There we go.
00:44:38.770 - 00:45:25.550, Speaker B: No, not yet. I'll come back to that in a second. I think maybe ether scan has to wait for a few transactions a few blocks to go through before it adds it. But the SDK does it instantly. So you can see that the SDK already got its encrypted note here you can see when the block was published, it managed to decrypt this note, which had index five nine three in the note tree, decrypted it and you can see that it was worth 0.2 e in way. Once that's kind of been settled, we can now spend this in a future defi deposit or join split.
00:45:25.550 - 00:46:04.934, Speaker B: So we're doing that here, buying some die privately. We create another effectively join split proof again here, where instead of this being funds sent to another user, we're sending funds to this bridge id, which will be aggregated by the roll up provider. And the roll up is going to wait for that to settle. Here we go. So you can see the roll up here looks fairly bland. It's paying some fees out to our fee contract, but at this point you can't see anything. Nothing interesting has happened at this point except the roll up has been validated, giving me my shielded eth.
00:46:04.934 - 00:47:08.170, Speaker B: The exciting thing happens in the next roll up block, which I'll show you shortly. So if we go back to the interface, in the case that we're just talking about, we're not using input asset b, we're only using input asset a, and output asset a is also being used. Output asset b is not being used. So in our example, input asset a is this aztec asset type that represents EtH, and output asset a is an ESC 20 asset, which is die. And the input value here is the total aggregate input value on behalf of all of the users who took part in this bridge interaction. In our case, it's just one user, but if there were 100 users, it will be summed up and be the total input value. And you can also pass in kind of extra data into the bridge id, which is useful for doing stuff like purchasing nfts, maybe setting the slippage on uniswap.
00:47:08.170 - 00:47:52.240, Speaker B: If you want to kind of have a slightly wider slippage or do some more obscure things. The Orcs data is quite useful for passing in that data. Looks like we just got another roll up, just came through. So we destroyed our input notes and we created these claim notes that Zach was talking about earlier. So you can see we nullified down here the Eth input note. And I think we also had to nullify a second note for our fee. Second, when ether scan loads, we'll see the actual swap taking place.
00:47:52.240 - 00:49:43.744, Speaker B: Ether scan is slower when you're doing a democrat. It's turning away in the background, so I'll check it again in a few minutes. Going back to the interface, all of this information is kind of provided by the roll up contract, and the expectation of the convert function is in most normal cases, it's going to interact with the defi protocol. So in our case, Uniswap, and it's going to return the tokens back to the roll up contract to be disseminated via the claim node process to all the users who took part. So if your default protocol is synchronous, meaning the transaction executes in one ethereum block, you will return an output value a, which is the amount of outpass a here, and if output value b is not used, it's just zero. There is a more advanced flow which we're going to get onto in the element demo, where your defi interaction can be asynchronous. So in this case, funds have left the aztec network.
00:49:43.744 - 00:50:29.584, Speaker B: They're sitting in your defi bridge contract, and at a later date, something in the wider defi ecosystem could prod the defi bridge contract and cause it to settle its previous defi interaction back to users on Aztec. So something like a fixed term loan, this is really useful for, it's also useful for limit orders, those sorts of things. So in that case, you would return nothing for output value a and b. And this boolean would be true to denote to the roll of contract that it's asynchronous. And the other two functions on the bridge are just for asynchronous interactions. They basically just allow previous call to convert, which returned. Is async true to be finalized at a later date.
00:50:29.584 - 00:51:04.750, Speaker B: So we'll go into that in more detail in a minute. Cool. So the SDK is a little bit ahead of ether scan, but we can see that there's another roll up block now. And if we go into this one, that's the previous claim proof. Here we go. So this is the roll up block, which effectively took the aggregated all the transactions in a roll up. In our case, it was just one.
00:51:04.750 - 00:51:47.150, Speaker B: Those transactions were particular defi bridge interaction calls out to our bridge contract in order to swap ETh for Dai on uniswap and does the transaction. I think in my testing, maybe someone else is also playing with this, because this actually put out four. So there's actually been someone else playing with this. Maybe one of our engineers or someone else is playing with the testnet right now. But you can see that there was a transaction from our address, which is zero xa seven b. This is the address of the asset roll up. We put this into wrapped ETH because that's what the pool is using.
00:51:47.150 - 00:52:45.436, Speaker B: And then we swap that kind of for this test token, which is basically die and send that back to the roll up. So you can see here we sent back, exchange rate is not very good, so we sent back a pretty poor amount of die in this actually interaction. But that was some split pro rata to the users who participated in the roll up. So you can see that down here, which is the end to end flow of doing a private uniswap transaction. We're in a code freeze with Aztec at the moment, so we're polishing up some of these interfaces, making sure this is all kind of working and scalable. You can see this is kind of ready to go, putting the finishing touches to it at the moment. And really the interface is now final.
00:52:45.436 - 00:53:00.396, Speaker B: So the next stage for us is actually getting on to writing bridge contracts, which I will start sharing now. Has anyone any questions at that point before I dive into some of the synchronicity code?
00:53:00.518 - 00:53:07.460, Speaker A: There is a question, actually, from Frank. How do you configure vs code for development?
00:53:10.440 - 00:53:11.590, Speaker C: Oh, you answer.
00:53:13.960 - 00:54:17.580, Speaker B: Our lead engineer, Charlie, has some very good configs that he's got me using. But one thing to note for kind of ZK development is we do all of our development on a mainframe computer, so we have a large 64 core instance in AWS, and everyone kind of sshs into that. Constructing roll up proofs and testing roll up proofs on a Mac, even with the new M one, Macs, is not enjoyable. So we have this very large machine, and all of our development is done on that remote machine. So there's a few interesting plugins for vs code that let you kind of run on a remote machine. All of this is actually running on a remote machine right now. So the whole team does that, which helps cut down developer wait times when waiting for proofs to be constructed, or kind of computing proving or verification keys from our proving libraries.
00:54:17.580 - 00:55:23.330, Speaker B: So cool. So, in the aztec connect starter kit, there's a uniswap bridge, and there's some tests that kind of help simulate what the roll up is doing. I'll just show you what the tests do quickly. So the tests are going to basically run a local blockchain, and they're going to run one test which calls, in our case, deploy uniswappool, and it's going to simulate your bridge contract being called from a hypothetical roll up contract. So for the starter kit, you don't have to worry about kind of deploying aztec, creating proofs or anything. You just need to kind of write solidity code, make sure it handles the edge cases of the particular default protocol that you're running with. And then you should be good to go.
00:55:23.330 - 00:56:21.190, Speaker B: So I'll just dive into these tests a bit more in a second. But this is our Uniswap bridge that originally was written by one of our engineers, Leila. I think we've changed a little bit for this demo to update it to the new interface, but it's fairly simple. It's around 100 ish lines of solidity. It doesn't support all use cases in Uniswap, but you can kind of get a feel for how easy these bridges are to write. And I'll run through this before we start going into the element idea, if we have. So in the Uniswap example, as I said before, you can see that the input asset and output asset are the only assets that are used, and we don't use any of the kind of auxiliary data, we just have the input value.
00:56:21.190 - 00:57:27.210, Speaker B: And secondly, on return, we're setting is async to be false, because this interaction is settling instantly in the same Ethereum block as the roll up verification, and we're only returning output value a. So this particular implementation only allows swapping from ETH to ERC 20, or ERC 20 back to eth. There's obviously way more pools on Uniswap than that. One of the to dos here is to kind of extend this to be a bit more generic. We actually were at the Unicode hackathon a few weeks ago, and we had a few people hacking together Uniswap v three bridges, which was quite exciting. We had people doing kind of lp pools. So LP positions, range orders, and people putting in custom slippage and custom fees, which was really cool to see using the Orcs data.
00:57:27.210 - 00:58:54.960, Speaker B: So all the content is actually doing is it's taking the input value and depending on which way round it's being called. So in this case, e for ERC 20, what we just did, we're going to call out to the Uniswap router, swap exact e for tokens for the input value, and we're going to set the amount that we've received back as output value a and return that to the roll up contract inside kind of the Defi proxy, which is actually kind of essentially run inside the roll up processor contract. We check that we've received the amount we specified. So I'll run over that in a second. But we check that the roll up contract's balance has actually gone up by output value a and you can see that in the uniswap transaction to save gas instead of sending it to the bridge contract first we directly send it to the roll up processor address on line 67, which is just hard coded. So that's pretty much the Uniswap bridge. In this repo we have, as I was saying before, a bit more complicated contract, which is our Defi bridge proxy, which is the contract that sits before your defi contract.
00:58:54.960 - 01:00:25.170, Speaker B: And it's actually going to call out to your bridge contract and it does those checks. So you can see that on the way in and convert, it's going to transfer any tokens that are required to your bridge address, and on the way back it's going to check down here that it received the correct amount of those assets. Our actual implementation of this is heavily optimized in inline assembly by Zac, but this is just a kind of human readable version, so we can have developers just understand what's going on and make it a bit easier to use. And then in the tests, we have some tests that can run that basically just simulate the roll up calling the convert function as if it was done inside a normal roll up block. And the tests are quite simple. We're expecting the proxy balance to be what was returned for the bridge contract, and a few other things to be false, just as we expect, because this is only one output asset and it's not an asynchronous interaction. So yeah, that's what we get here.
01:00:25.170 - 01:01:57.230, Speaker B: In terms of element, I think the best place to start is this spec document that we wrote as a team. So 1 second, for those who are not familiar, element is a fixed rate lending protocol, and usually you interact with this through their UI. I think in our example, the simplest thing to kind of try and code up, if we've got time, is dealing with the dai kind of pool. And what this offers is if you have shielded die tokens on Aztec, the goal of this kind of bridge contract would be to enable you to deposit it in this element pool and earn 3% APR. You can see this is fixed term, so they have a few tranches. I think the next one's ending at the end of January, and.
01:01:59.460 - 01:01:59.936, Speaker C: It has.
01:01:59.958 - 01:03:06.000, Speaker B: A fixed APR of about 3%. The way element works is they actually invest the underlying assets into kind of variable rate defi protocols such as yearn, and they split out the principal tokens, which is your dai that you're putting in, into one asset, and they separate it from the yield tokens, which is kind of the variable yield that's coming off that particular investment. And the way they make it fixed rate is they have a market maker, amm, a bit like uniswap that lets you trade your die for principal tokens and they trade at a discount. So if I've got 100 die, I can buy principal tokens at an exchange rate of zero point 95. So I get, in this case, I get 103.1 principal tokens. And on the 20 eigth of January, 2022, those principal tokens will be worth one to one for die.
01:03:06.000 - 01:04:05.008, Speaker B: And there's a redeem function to convert the principal tokens back into die. So you end up with, as a user who put in 100 die here, you'd end up with 103.1 die by kind of going through this flow. So it's relatively simple that users have been priced out. Given the gas cost of creating principal tokens or buying principal tokens and then redeeming them, it's quite an expensive end to end flow. How are we doing for kind of confusion levels? Are there questions that people want to ask at this point? Are people following along, or should I back up and explain a few things a bit more clearly? I think silence could be a good thing.
01:04:05.094 - 01:04:14.580, Speaker A: That might be good. I don't see any action, but I guess if people do have any further questions, they can put them in there in the chat.
01:04:15.480 - 01:04:29.690, Speaker C: Yeah. Feel free to shoot out anything that your folks are curious about, or if they're not following, or if anything is unclear or casual heckles anything, we'll be around to answer.
01:04:32.300 - 01:05:26.630, Speaker B: Cool. Let's start coding then. I have not done this before, so we have a spec on what we think we need to do for this particular bridge contract, but let's start coding and see where we get to. I think if we can define in comments what the convert function is meant to do in terms of element. Maybe someone in the community can take it on, apply for a grant, and we can help you kind of finish the work. Cool. So I'm just going to base this off of the Uniswap brooch and copy and paste everything.
01:05:26.630 - 01:06:48.216, Speaker B: Just clean up all of the uniswap stuff. So when we wrote the spec and I can share this quickly, just we looked at a few flows for how this is possible. And because element principal tokens are ESC 20 tokens, there's two options. So one option is kind of the most simple option, which is the one we're going to implement, which is the bridge is asynchronous. You put in die, and then when the element tranche expires. So in the die case, the next tranche expires on the 20 eigth of January finalizes triggered and the user just gets back die plus interest. On Aztec, there's a more complicated flow where you can kind of purchase principal tokens, receive principal tokens back.
01:06:48.216 - 01:07:44.568, Speaker B: On Aztec, you can then send those around, they're fungible, and then at a later date, you would do a second bridge interaction to redeem the tokens for dai. The trade offs and benefits to both. Yeah, I'll show the hackendi. Sorry, there's trade off and benefits to both. At a high level, the first flow is way simpler to implement, but it does mean that kind of, you're locked in for the term. So if you get buyers remorse at any point for some of these longer terms, your assets are kind of stuck for those 30, 60, 90 days, depending on how long the term is. The second flow, obviously, if you decide that there's more favorable things to do elsewhere in DFI, you can always kind of exit early.
01:07:44.568 - 01:08:31.572, Speaker B: You may get not the advertised interest rate, but you'll be able to get your diet back and do something else with it. Pay a friend or do something else on Aztec or send it back to l one. So in our case, we're going to implement this direct kind of async bridge flow. It is used with all element assets. We're only going to code up die just for simple cases. And we can talk a little bit about the user flow here, but there's some ideas here around if there's multiple tranches or pools for a given asset. So in the dye case, I think there's like a pool that expires in January and there's another pool that expires in April.
01:08:31.572 - 01:09:25.630, Speaker B: You may be able to use the orcs data to pick the correct pool expiry date. And, yeah, this really just kind of goes through all the steps we think need to happen. One caveat. Let's start coding and I'll talk about the caveat actually in a minute. Cool. So I guess the first thing that's going to change from the uniswap interaction is async is going to be true. So the first thing we want to probably set is, is async true, which means that we don't need to define this.
01:09:25.630 - 01:10:34.028, Speaker B: And those are both effectively zero. What this means is when your bridge contract is going to be called convert is going to be called, you're going to receive input assets on behalf of all of the users who decided to do this bridge interaction on Aztec. But nothing is getting sent back because we're waiting for the term to expire. And, yeah, effectively at a later date, someone needs to call finalize to let the transaction settle back on Aztec. So the convert function in this case is probably actually going to be quite simple. I'm going to write some comments on what I think we need to do. If anyone's got any better suggestions, please message in the chat, because I've only just started looking at the element contracts, but at a high level, I think element runs on balancer.
01:10:34.028 - 01:11:44.410, Speaker B: Balancers like the exchange works a bit like Uniswap, but it's basically an amm. And the way that users get the principal tokens in this case is they're going to swap die for principal tokens on balancers amm. So let me just write a comment here. So we want to swap input value in input asset a for the equivalent principal tokens on a balancer. Let's not have a very long line. So that's kind of the sole goal of this conversion function. Before we kind of figure out how to do that, there's a few other things we need to do.
01:11:44.410 - 01:12:16.530, Speaker B: So, to do the swap balancer, assuming we can figure out how to do that, I think there's a few things to note. Given this is an async interaction that we need to take care of to enable someone else to call finalize once this is settled. Just got a question.
01:12:18.180 - 01:12:18.592, Speaker C: Yeah.
01:12:18.646 - 01:13:08.800, Speaker B: The first half of the session where Zach went through kind of some of the circuits to power this is over. We're just doing a live coding session now on how to write bridge contracts in solidity. If you're joining late, it's all recorded. We shared on where was. Yes. So once we've got the tokens, let's just do it as an example. Principal tokens are called, I think they're called PY is their prefix.
01:13:08.800 - 01:14:59.184, Speaker B: So this is the state kind of the world after we've done the swap on balancer. And we need to record this somehow because after we've done the swap, this particular interaction has a balance of, in this case, 100 die, which we swap for 105 principal tokens. And we need to kind of attribute that to this particular DFI interaction so that when finalize is called at a later date, we make sure these 105 tokens are redeemed back for 105 die and get split pro rata between any user on Aztec who decided to take part in this interaction. Let's just make the numbers slightly more interesting. So to do that, there is a parameter in the interface which is interaction nonce, which is globally unique. So every time converts called for any bridge, the interaction nonce globally will have increased by one. And we can use that to be like an id and we can use that to kind of record the transaction that's happened and also make a note of kind of the future transaction that needs to happen in order to settle the asynchronous interaction.
01:14:59.184 - 01:16:07.650, Speaker B: Back on Aztec later. So the easiest way to do this is probably have a mapping, how to do mappings in solidity. It's like this. Don't think we want a mapping actually, because, well, let's do the simple case first. So in the complex case, there can be multiple input assets. So a mapping is maybe not sufficient for us because if someone puts in die and someone else puts in BTC, we're going to get, maybe get in a world of pain. So let's just stop that for now for the simple case.
01:16:07.650 - 01:18:30.340, Speaker B: So aztec assets have the following structure. We can just, in this simple case, just use the ERC 20 address which will be set and we can just block out all of assets in the pseudocode example. Now we can set for our given interaction nonce what we've returned from balancer. So assuming the balancer is going to return some sort of amount swapped. And we'll have to check the interface for this in a minute. But it actually have the contracts up, I think. Let me just find, this is the element gear hub.
01:18:30.340 - 01:19:55.870, Speaker B: We can just look at the interface here and figure out what's going on. Yes. So the pool is basically one of these convergent pools, I believe, which has somewhere on it. Okay, so this is going to be a little bit more complicated, but this is what we're going to be doing. But we're getting back a un two five, six, which is the culture of our swap. So we will just do to do here's. And we can now take the principal tokens returned and we need to associate them with the interaction nons that we just defined up here, set by the roll up contract.
01:19:55.870 - 01:21:46.230, Speaker B: So assume the mapping is called pending interactions and it interaction balances it. Second part, let's just write down what we're doing here. So one, record the amount of element principal tokens. We also need to record the maturity of this particular loan to do yet. But the goal of these two steps is so we can set up the contract so that a later date we can implement the can finalize function which just returns if this particular interaction is ready to go. And also the finalized function which is actually going to settle on aztec. So, Zach, have you got a comment?
01:21:47.390 - 01:22:35.190, Speaker C: Sorry, I mentioned it dripped off. Sorry, I just accidentally clicked the share screen button. Yeah. For an async interaction like this. So the bridge itself would have to kind of store it, I believe. How long it's going to wait until the limitures. So for example, one could define like a constant which will be added onto the current block timestamp, and that would describe the threshold at which you could then like, after which you could resolve the whole interaction with joy alone and return the proceeds back to Aztec, the asset network.
01:22:36.510 - 01:23:04.014, Speaker B: Cool. So I need to figure out just how to store these quickly in these mappings, but pending interaction balances. And then we've got another mapping which is going to be cooler. Some of the solicitity wizards. I'm having a brain meltdown. How do you do a mapping as Lizie again?
01:23:04.052 - 01:23:14.740, Speaker C: Hey, what do you put up a live. If you show a live stream, I can hop in and basically like scribble graffiti all over your code.
01:23:16.470 - 01:23:58.270, Speaker B: Yeah. One of the perks of vs code for the person who was asking earlier. I'll send it on Zach. Zach. So whilst Zach's fixing up these mappings, I'm going to switch back to the element docs and try and work out where we can get the expiration from.
01:24:09.140 - 01:24:25.300, Speaker C: So we have mapping interaction nonsense to balances and explorations. So I'm going to be like super bit. Let's just find a little structure and be a little bit more efficient on gas.
01:24:42.480 - 01:24:45.070, Speaker B: Bank. Cool.
01:25:07.320 - 01:25:56.160, Speaker C: It's just some loose code. I mean, if you wanted to optimize this, you might be able to mash both of these state variables into a single storage slot. If you were willing to do some kind of truncation of represent store tokens as like a un one two eight. Because the goal here would be to reduce gas costs as much as possible. So if you could get away with say like one stored slot per aggregated call, then that's gas that you're going to save your users.
01:26:00.100 - 01:27:02.100, Speaker B: So I'm just going to add a to do here, which is we've got to query the element tranche, which we just found out here. It has this unlock timestamp, which is, I believe the timestamp at which post that point, the principal token which we get back has just pull up the interface for it, but it has a method on the principal token. It's here withdrawal principal. This becomes unlocked at that point. So we don't know how to do that yet, but let's just say query the tranche to get the expiry. And if we have all of this stored, we can kind of move on to the next step, which is implementing can finalize and finalize.
01:27:09.900 - 01:27:11.320, Speaker C: Sorry, I'm just trolling.
01:27:13.020 - 01:28:07.010, Speaker B: Where were we? I'm just doing the camp finalized function. So this one's pretty easily easy. We get a interaction nonce back and we're going to require. What did you call thing? Expiration it.
01:28:16.960 - 01:29:04.140, Speaker C: So while you're doing this, I could chat a little bit about the actual contract architecture. So the way this works effectively, like kind of by using callbacks for asynchronous transactions where if you want to finalize an async interaction, you go through the aztec robot smart contract. That way we can ensure that all these bridges conform to a unified interface which makes interacting with them a lot easier, particularly if almost, for example like crane incentive mechanisms. The goal for this is for the role of the entity that's actually finalizing these asynchronous calls so that british developers don't have to worry about it. And so that's much easier if everything just gets called through a sound interface.
01:29:04.480 - 01:29:59.692, Speaker B: That's a good point. Yeah, someone's going to have to pay. So the way that finalize is actually called, this is in our docs, but there's a public function on our roll up contract called process async defi interaction. And you give it a interaction nonce under the hood, this will kind of check that the cam finalize is ready and then it will call finalize. And as Zach was saying, we need to set up some incentives to do this. So likely what will happen in the finalize function, if you want to set up some good economics, is you'll shave off a little bit of a fee. So whoever kind of ends up calling finalize maybe gets a percentage cut of the rewards or there's other ways to do it.
01:29:59.692 - 01:31:05.044, Speaker B: That's one way to kind of incentivize this being called. So we may have an additional function on our defi bridge which is like expired tranches or something. And this, this would just, it could loop through, it could do this. And under the hood what's going to happen is this function would kind of pay whoever calls it. It's going to call out to the aztec roller contract for any tranches that are ready. It's going to trigger can finalize and finalize to be called and finalize you can think of as just a delayed conversion convert call. So if we go back to our kind of original uniswap thinking when we were doing the interaction and sending tokens back, this was an async call.
01:31:05.044 - 01:32:25.180, Speaker B: So we now have to kind of actually return assets in the finalized function, which in elements case is a little bit more complex because we first need to get those assets at this point. So just as a reminder, I'll write some notes of what we have at this point. Let me just define some of these. So we have principal tokens for this interaction nonce in order to kind of give the user what they originally signed up for 60 or 90 days ago. We want to make sure that they have their die back on Aztec. So we want to redeem the principal tokens for the underlying. And just as a note, because now the tranche has expired.
01:32:25.180 - 01:34:01.380, Speaker B: The tranche has expired. The principal tokens are now one to one with the collateral. So, Ed 1050 p y die equals its element principle. Change these. So we've got to the end state at this point and we just need to effectively withdraw it. And I think the way we do that is we want to call withdraw withdrawal principle on the actual token. So let's just say assuming we have an interface for this token, we can call withdrawal principal and we expect our balance to go up 1050 die if we just quickly look into the contracts.
01:34:01.380 - 01:34:47.708, Speaker B: Yeah, we can actually do a shortcut here to save a bit more gas and we can send this directly to the roll up contract. So just do pending interactions. Interaction launch. It's called balance. So we called it Zach balance. So we're going to ask it to now withdraw the balance of the previous interaction and we're going to send it to the roll up processor. And this returns an amount.
01:34:47.708 - 01:34:55.180, Speaker B: So we can grab that out here. Output.
01:35:01.940 - 01:35:30.990, Speaker C: There's a few ways you can slice this, but we're using a pattern where we're avoiding requiring this kind of approved transfer from mechanic because that's a little bit more expensive than just directly sending the tokens to the roll up. And by creating this kind of callback structure where the roll up calls finalized in this contract, we can ensure that if you just directly send the tokens to the roll up, everything can be correctly counted for.
01:35:35.200 - 01:36:04.630, Speaker B: Great. That was actually a lot simpler than expected. We'd obviously want to do a bit more checks here to make sure all of this succeeded, but we need to kind of instantiate all of these structs. But I think the high level pseudocode version is done. Some of the incentives are not in place yet. Might need this. That's a very good point.
01:36:04.630 - 01:36:39.170, Speaker B: It's a good point, actually. So the security model of these contracts is everything needs to be scoped to the roll up contract. Like you don't want users to be able to interact with these bridge contracts because otherwise, unless specifically through defined function like expired tranches, because if someone else can come along and finalize a previous defi interaction, they can easily just steal the tokens, which is hacks are bad, even though ZK hacks are good.
01:36:39.940 - 01:36:43.250, Speaker C: Yeah, we don't want to put the hack in Zkhack right now.
01:36:46.180 - 01:36:54.470, Speaker B: How much more time do we have? I'm conscious that we could keep getting this polished, but we've covered quite a lot right now, and maybe it's time to give you a bit of a break.
01:36:55.000 - 01:37:04.584, Speaker A: You have another 20 minutes, and then we come on with the announcement of the new puzzle. So it's up to you.
01:37:04.702 - 01:37:30.480, Speaker C: Awesome. Well, I think we can keep going if folks want. Maybe we can get a show of hands in the chat to see if anybody's brain isn't a pile of blueberry jam at the moment. Because maybe we should wrap up if nobody is particularly keen in chat.
01:37:32.980 - 01:37:33.296, Speaker B: To.
01:37:33.318 - 01:37:35.540, Speaker C: Be subjected to more solidity programming.
01:37:36.520 - 01:37:38.710, Speaker A: Well, let's see what people are saying.
01:37:39.640 - 01:38:19.490, Speaker B: In the meantime, I'm going to just show this form again. So someone wants to submit a grant for any of these kind of protocols or any other protocols that are not here. We're happy to kind of talk you through some of the bridge contracts we think would be useful. Work together on a grant application and give you the help to kind of code up one of these bridge contracts. They're quite fun to make. It requires a slightly different way of thinking in terms of facility coding. So, yeah, if you want to kind of hack around with some pretty cutting edge technology, this is the best place to go.
01:38:19.490 - 01:38:21.744, Speaker B: Yeah.
01:38:21.862 - 01:39:09.840, Speaker C: And the interface needs a little bit. Obviously, we're going to be polishing up our documentation and our onboarding, but the goal of this is that you can write effectively like a privacy shield. Both a privacy shield and a way of reducing the cost of interacting with an entire deFi protocol in about a day with a few dozen lines of solidity, if that tickles anyone's senses, shield us a grant application. We'd be very happy to sponsor you to write a bridge contract for a DeFi protocol of your choice that you're particularly fond of, that you want others to ape into privately.
01:39:12.020 - 01:39:17.060, Speaker A: And actually, you guys are also supporting the Gitcoin grant effort that we're doing, eh?
01:39:17.640 - 01:39:18.836, Speaker C: Yes, we are.
01:39:19.018 - 01:40:00.850, Speaker A: Yeah. So also, maybe something to re mention that Aztec is a matching partner with ZK validator and a group of awesome matching partners who are helping to fund some open source ZK stuff. So if anyone has projects, as I mentioned earlier, would be awesome. If you do submit, keep your eye out for that. Joe and Zach, if you do have anything else to share, you do have some time to do it. And if you don't, what I would actually do is we have this networking feature in hop in that we can do where people can actually meet each other and then we could come back in 20 minutes or if there is anything else that you want to share.
01:40:04.920 - 01:40:22.730, Speaker B: Just trying to think if people are interested, we can go through kind of our current roll up throughput privacy sets, which is CK related. Maybe that'd be interesting, but I'm also keen just to chat to people and maybe some informal chatting will be fun.
01:40:24.060 - 01:40:36.140, Speaker A: Actually, I think that would be cool. This is also going to be a video, so people who might want to see this afterwards, do you want to maybe spend, I don't know. If you have 10 minutes, could you do about 10 minutes on that and then we do a bit of networking?
01:40:37.760 - 01:41:10.600, Speaker C: Yeah, I think that sounds good. Although I just lost Joe might disconnect it, so maybe I can do some of that then. So I could talk a little bit about ZK money and how the current roll up architecture, how Aztec connect fits into this and the user experience and user flows. So the current. In March, we launched our original, well, what we're calling Aztec two. It's the first L2 that we produced first private roll up.
01:41:10.670 - 01:41:10.904, Speaker B: Why?
01:41:10.942 - 01:41:13.930, Speaker C: Everyone's leaving. Maybe I'll get dropped off soon as well.
01:41:14.300 - 01:41:20.604, Speaker A: No, I just wanted to let you speak. Go ahead, I see I can jump back.
01:41:20.722 - 01:42:50.790, Speaker C: Okay. Where was I? Yes, so we launched that in March, and it enables shielding and unshielding of tokens of native ethereum on layer one, giving a privacy to Ethereum, where transactions are substantially cheaper than if one were to do it without the benefit of a L2, without the aggregation techniques of zk starks. So, for example, depositing ETH costs about 40,000 gas and a withdrawal is about 30,000, which we were very happy with at launch. The current prices of ETH at the moment, gas prices mean that it's still a work in progress, but unfortunately, bridging to and from a L2 from ETH is always going to be relatively expensive because you have this layer one transaction you can't get rid of. But we're confident that we can get this down to ensure that deposits are about 30k, withdrawals are about 20k gas. In Aztec Connect, where for sufficiently large batches, you can do DFI interactions in 10,000 gas, even if you don't have any funds inside the L2, and you want to interact with the DFI protocol, just doing it through Aztec, doing a deposit to Aztec, the DeFi interaction, and then a withdrawal back to layer one. That whole round trip will be cheaper than the majority of DeFi protocols natively on layer one.
01:42:50.790 - 01:42:53.404, Speaker C: Great. You're back, Joe.
01:42:53.472 - 01:43:06.190, Speaker B: I'm back. I did the thing where you put the address you want to go to in the address you're sharing from. So accidentally closed the window, but I'm back now.
01:43:06.880 - 01:43:07.244, Speaker C: Cool.
01:43:07.282 - 01:43:44.296, Speaker B: So this is our block explorer. Someone else was kind of asking earlier around, what is the state of play today? We're doing around kind of 112 transactions every kind of two to 6 hours. We just do this when the roll up is full. So you can see right now we've got 67 transactions in the queue. And when it gets to 112, it will spit out the roll up block. We're actually computing kind of the inner roll ups in 28 blocks as and when they're full. So the actual final step is really quick.
01:43:44.296 - 01:44:22.336, Speaker B: We just need to kind of compute the root roll up. We can see this on efascan. There's quite a lot of people kind of withdrawing and using this. A bit like a mixer. Back to l one. And in the future, you'll see kind of all of the defi interactions down here on ether scan, which will be pretty cool to kind of see what we saw earlier on the girly test network, but with a lot more users. So, in terms of the privacy sets, let me just pull up this June dashboard that's been in the works for ETh.
01:44:22.336 - 01:45:14.900, Speaker B: Things have been growing quite quickly. The one ETH privacy set is getting pretty great. There's quite a few users who are still depositing and then withdrawing to the same address, which obviously breaks privacy for them. And we have to discount them from the privacy set, but we can see there's a lot more smaller users and then decent amount of bigger users kind of going through. And we have the same for, obviously, the DAI and RembDC privacy sets, but they're slightly smaller. The great thing about aztec connect privacy sets is that you kind of have new ways to get ETH into the system. So ETH could have come into the system by someone kind of depositing ETH directly, or you could have swapped some dies ETH using the Uniswap bridge.
01:45:14.900 - 01:46:42.450, Speaker B: And that kind of has the effect of expanding the privacy sets. And John, who's on our content and growth, just wrote a really cool piece trying to explain what we're calling infinite privacy, which tries to explain kind of how the privacy set grows when not only do you have kind of new forms of assets coming into the roll ups through defi interactions, but you also have yield generating assets. Things get a bit hard to imagine when you can suddenly have assets growing inside Aztec because they're now yield generating. And you have to start doing pretty complex number crunching to figure out where the potential set of places someone could have got a withdrawal amount from, because it's now not just deposit amounts it could come from. I had in the element case, like, if I'm withdrawing ten die, I could have deposited ten die, but I also could have put 1000 die on element and earned a fixed yield for a period of time and withdrawn some of that die. So the world of kind of the privacy set explodes when you start adding in these defi interactions, which is something we're really excited about. Anything else that's useful to go through? Zach, on.
01:46:46.020 - 01:46:55.488, Speaker C: Mean, I think. I think that's pretty much covered. Unless folks have questions, maybe we can jump onto the. I've forgotten the name of it, the thing that Anna suggested.
01:46:55.584 - 01:46:58.376, Speaker B: If anyone wants to networking, that's the one.
01:46:58.478 - 01:47:41.990, Speaker A: Okay, I have one question before we do that, though. And Zach, we talked a little bit about this, so I've been talking a little bit in groups, maybe on a few shows about doing ZK nfts. And my question, and when I say that, yes, there's a few small projects trying to do it, but so far, when you say ZK NFT, it might be like an NFT on a ZK roll up, but not necessarily a private NFT in its generation. And I wonder if this is very like future, but is there a way that with aztec connect you could actually do something like that at some point? Tell me what that even looks like.
01:47:43.080 - 01:49:08.764, Speaker C: We can use connect to create to enable the holding of nfts privately. The downside is it won't be particularly cheap because you don't get any batching effects because nfts are single owner. But what we are going to be, something we have loosely in the pipeline, is effectively the ability to have what we're calling like a private art vault, effectively a layer of smart contract that is a custodian nfts where the owners are hidden and it makes purchases and bids and trades on your behalf. And you submitted instructions from the aztec network. And because your identity is hidden, it means that nobody knows who owns or controls the nfts until the user chooses to reveal that the way it would work is, for example, you would use the asset connect to send an instruction to this contract saying, like, I want to buy crypto punk. Here's a fixed amount of ETH, like ten eth or four eth or whatever they're going for these days. And you provide like, a token, like an identity which is linked to an aztec identity.
01:49:08.764 - 01:50:07.140, Speaker C: But that linking happens within the aztec network, inside our. That's what that effectively does is it binds ownership of the NFT to you, but nobody can see that on layer one. And then what would happen is you could then, through these bridge interactions, emit a transfer transaction as well, which would then. So if this contract is bidded and bought an NFT on your behalf, you could then choose to transfer it to a public ethereum address of your choosing, or you could choose to leave it inside the vault if you didn't want to reveal that you owned it. So basically, it will be a way of acquiring and trading NFTs privately, but it wouldn't be a way of shielding ownership of existing NFTs without. Well, there may be ways of doing that, but it's difficult because the anonymity sets are very low given that these assets aren't fungible.
01:50:09.720 - 01:50:14.470, Speaker A: Kind of time frame. Like, at what point would we actually be able to use this?
01:50:15.480 - 01:50:58.592, Speaker B: You can write a bridge contract for this. Now, there's a few technical hurdles that mean that at the moment, you don't have a guarantee that you are the sole owner of the NFT. Okay, I don't know if you're familiar with party bid, but it's a bit like party bid. So you could write a contract today where we all put some Ethan and it just goes and it decides to purchase an NFT. And that NFT will be owned by your bridge contract and using the output assets. One of the output asset types here is a virtual asset, which is basically used to cover all assets that can't go inside Aztec. So Aztec works with Utxo or fungible assets.
01:50:58.592 - 01:51:39.170, Speaker B: So we basically take your NFT and we split it into shares. And you could do that today or when we launch, we probably need to make a few slight tweaks to make it a bit more usable so that you can also have the option of not sharing the NFT. If you're kind of purchasing an expensive crypto punk and you end up with 99% of it, it may be a bit annoying, but, yeah, the tech is pretty much good to go on that. It's just kind of getting the use cases down and opening up to the community ready to start building some of these bridges. Cool.
01:51:40.820 - 01:51:57.560, Speaker A: All right, well, that was my question. We have only about 7 minutes until we are meant to reconvene and announce puzzle five. Shall we? Do you want to wrap up? And then we can just actually spend a few minutes meeting some other folks?
01:51:58.060 - 01:51:59.210, Speaker B: That'd be great.
01:52:00.540 - 01:52:20.172, Speaker A: Thank you so much for doing this workshop for us. The Aztec connect workshop. So, yeah, this is the kind of wrap up of this part of the event. I just turned on the networking area. You can just pop in there. Basically. I believe it just matches you with another participant for a few minutes.
01:52:20.172 - 01:52:47.736, Speaker A: I think there's like a timer, and then it will kind of reshuffle that. So if you want to meet some of the other folks here, this is a cool way to do it. And I recommend coming back in about 6 minutes. So maybe do two of these or just do a couple, I don't know, try to come back on time. Because what we're going to do in 6 minutes is basically launch the fifth puzzle in the ZK hack of six. So we're getting kind of into the last few here. So, anyway, hope to see you back here.
01:52:47.736 - 01:52:50.052, Speaker A: Thanks again, Zach and Joe.
01:52:50.196 - 01:52:50.552, Speaker C: Awesome.
01:52:50.606 - 01:52:50.776, Speaker B: Thanks.
01:52:50.798 - 01:52:51.444, Speaker C: It's been a pleasure.
01:52:51.492 - 01:52:51.912, Speaker B: Thank you.
01:52:51.966 - 01:52:52.600, Speaker C: Cheers.
01:52:53.580 - 01:52:54.070, Speaker A: See you soon.
