00:00:06.570 - 00:00:47.530, Speaker A: All right, good afternoon, everyone. Today I'm going to talk about Pacedon VM, ZK app friendly blockchain VM with EVM compatibility. And I will just give a brief intro of where I'm from. We're from Pacedon Labs as a of the Pacedon Labs is to bring privacy to every web3 project. So currently we're working on deploying a mental network and the Kalamari network on both Kusama and Polka Dot. And today I'm going to talk about Pacedon VM, which is our research project. And the talk is brought you by me.
00:00:47.530 - 00:00:55.006, Speaker A: I'm the co founder of Pacedon Labs and also Brandon, he's our CTO. Yeah, let's get into the talk.
00:00:55.108 - 00:00:55.566, Speaker B: Right.
00:00:55.668 - 00:01:25.874, Speaker A: So what's the goal here? I think the goal is to bring the next 70,000 zk apps. Hey, you may ask me why you come with these magic numbers. And first, I just coming up with number arbitrary. And second, and if you are into kind of like a programming language research nerd group, you actually can get a joke. And if you get a joke, I'll buy you a beer afterwards. Yeah. So let's briefly look at the ZK application landscape.
00:01:25.874 - 00:01:53.662, Speaker A: Right? So I think the first category, I would say for the ZK application is for privacy. So you have the sort of OG privacy cryptocurrency zcash like Mancha. We're building some cool stuff in Polkadot Kusama for private asset. And there is Alio. And there is zk optimistic rob by PSE from Ethereum foundation. And there is aztec, there is expresso. And sorry if I don't include your favorite project here.
00:01:53.662 - 00:02:40.698, Speaker A: I only have so much screen realist. And I will say the second category of zk applications is scaling. Right? So there went for a ZK event project like ZK sync, Scroll and Polygon Hermes. And also we've seen a new class of emerging applications on basically using ZK for attestation oracles. For example, you have Sysmo, they have a ZK tester, and there's like a ZK graph hyperoracle. Right. I think the question we are asking today is that how can we further democratize zk applications? Why isn't there like 70,000 ZK application today? So we think there are like three problems from the kind of like a democratization of zk applications.
00:02:40.698 - 00:03:06.070, Speaker A: The first is that high barrier to entry for zk development. Right. In our team, we actually hire like zk cryptographic PhDs. But I don't think every ZK app development should have that. Right. So I think that's the first barrier. The second barrier is actually for high gas fees and high prover costs, I think for high gas fees, even in L two, right.
00:03:06.070 - 00:03:56.194, Speaker A: A lot of ZK applications you still have a very prohibitive gas cost. And let alone a lot of zk circuits, they have like millions or hundred minutes constraint which incurs a very high proverbial cost. And last but not least, so there are lack of tool chain support. So if you're looking at how people are programming zk today, you're either using very high level language with like circum, which is great, but once you want to deploy it, so it's very hard to get nitty gritty of optimizing the circuit. Or you are using some wonderful libraries like arcsworks, but you kind of like a writing assembly code and you are spending a lot of time to do security audit, spend a lot of time to hand optimizing the circuit. Right. It seems that this have kind of like a dichotomy of how do you programming zk apps.
00:03:56.194 - 00:04:31.262, Speaker A: Right. So we're here to solve the question. So then let's come to the Persidone VM goals, right. I think Pasadon VM have this explicitly three design goals to solve these three issues. So first for high barrier to entry for zk development. So our solution is that we want to bring layered programming abstractions and we think we need to provide programming abstractions in three layers. The most bottom layer is storage layer, which we want to have a unified and convenient storage APIs for zk applications.
00:04:31.262 - 00:04:54.106, Speaker A: The second layer is circular layer. We want to bring compostable ZK circle pre compiles. And the top layer is the app layer. We want to enable. You can do a lot of composition using pure solidity. I think Brendan later will dive into detail of all these three layers. And the second issue is higher gas fees and high proofer cost.
00:04:54.106 - 00:05:49.754, Speaker A: I think the second design goal here is that we want to bring dirt cheap zk transactions. So we need to do a lot of work in order to make this happen, but in a very high level. So also all these optimization works need to get into these three different layers. Just give you an example, right? For example, in the storage layer we're actually using zk friendly hash functions like pasedon to replace the catch in the Ethereum storage. So the last point is lacking tool chain support. And our solution is that we want to actually maximize the leverage of existing Ethereum toolchain systems, which means that the VM itself should be compatible with existing Ethereum apps. And for the ZK part, we want to work with existing toolchain providers like hard hat, truffle and you name it.
00:05:49.754 - 00:06:00.090, Speaker A: So that's three design goals. And let's actually take a step back to think about a little bit about the design philosophy of the VM.
00:06:00.250 - 00:06:00.766, Speaker B: Right.
00:06:00.868 - 00:06:50.910, Speaker A: So where we are taking here is we're actually learning from the best, which in my view is a Unix operating system. We want to make the design modular, which means we write simple parts that connected by clean interfaces. We want to make it simple in a sense that we only add complexity where you must. And we want to make the rule of separation which clearly reflects in the layered abstractions where we want to separate policy from mechanism and separate interfaces from engines. Right, next, Brandon will tell you how can we achieve that's good. Can I also just put it in the pocket?
00:06:58.070 - 00:07:21.862, Speaker B: All right, so I'm going to tell you how we are able to achieve those three goals. So first let's look at the general architecture. So we have those three layers that Shuma described, the storage, the circuits, and then the DAP layer. And we'd like to make this analogy with Unix as well. So at the bottom layer you can think of having the file system API. So think the calls that you can make to direct files. And then above that lives like the C programming language.
00:07:21.862 - 00:07:57.838, Speaker B: So if you are really hardcore trying to optimize, make really performing code, you write C code that lives and calls the file system API. And then above that you have, let's say bash scripts. So bash scripts, the individual scripts themselves, could be written in C, but they're called in this higher level language. And so you don't really have to know how C works to enable to build bash scripts and build programs using your computer. So this is sort of the kind of analogy we want to make with the three layers. So first let's talk about the storage layer at the bottom. So the first abstraction that we want to build here is called elastic anonymity sets.
00:07:57.838 - 00:08:18.586, Speaker B: So what are those? So first just think of a set. I have a collection of items and it's a dynamic set. So I can insert and remove items. And I can also have a notion of membership whether the item is in this set or not. And then we want to add anonymity over it. This is where the ZK part comes in. So if there's an item in this set, I can do a membership proof of it without revealing which item I'm referring to.
00:08:18.586 - 00:08:51.750, Speaker B: And when I remove an item I'm not telling you which item I'm removing. I'm like nullifying the item so that contains will always return false, but nobody knows which item I've removed. So you can see here this API we have those three methods, contains insert and remove. And for contains you need a ZK proof. You provide a ZK proof so that you don't reveal which item you're referring to. And then for remove you also need a ZK proof to build the nullifier so that you don't reveal which item you're removing, but you still remove it. So for insert you don't need a ZkP, you just insert the item.
00:08:51.750 - 00:09:21.534, Speaker B: So that's the anonymity set part. The elastic part refers to the fact that we don't need to give the developers the API for growing this set. The set can grow dynamically underneath inside the VM itself, and it preserves the anonymity ratio that you provide. So let's say you want one in 1 million anonymity. The set can grow over time. It can support more than a million items while still keeping one in a million anonymity. So this is the API we give here.
00:09:21.534 - 00:09:44.754, Speaker B: And so where does this live? Inside of the state of the state tree. So on the left you have the EVM compatible storage. This is still using the Keshak hash function. This is the MPT that you're usually familiar with if you're using EVM. And so we just build a side tree here that has the eas inside of them. And you can see there's those three there, the three different color ones. Each one will be given to a contract.
00:09:44.754 - 00:10:22.174, Speaker B: A contract can read and write from either one of those, and then other contracts can read from other contracts state using the contains method. So of course for zkp we need to have a zk friendly hash function. So Poseidon, which is about 2000 times faster you can think just than catch up in circuit. So this is sort of the main structure of the state tree. So once we have the storage layer, now we have a notion of adding and removing items from a storage without revealing which items we're removing. So now let's look at the kinds of applications that build on top of this. So first we have zk assets.
00:10:22.174 - 00:11:11.390, Speaker B: These are programmable private assets. So if we start with something like say Zcash, where we have the notion of private transactions, we want to extend this to applications so that we can, given the assets that we have, we can give them to applications like Uniswap or Opensea or what have you, and they can operate on those assets without having to, for us to unwrap them, put them in some public account and then do it, and then put it back. So we want to find some automatic way to do this. So let's say for now we're only supporting the standard tokens. DRC 27 20 111 55. And we build an abstraction on top of those assets that lets you privatize them and lets you forward calls to contracts so they can use those assets without revealing their owner. So that's the first part of the programmability.
00:11:11.390 - 00:12:03.874, Speaker B: The second part is that these should also be compatible with other ZK applications, stuff like semaphore and espresso. So this is sort of the overview of that. So let's look at the API again. So for the shielded pool we have the familiar deposit, transfer, withdraw functions which take you from the account model world of Ethereum, or whichever system you're on, into a private Utxo model like zcash. So that's deposit. And then of course withdrawal, you can come back into the account world or you can transfer internally within the Utxo world. And the fourth thing here which is special, is the fact that given a Utxo we have, we can give this Utxo to a contract, and the contract can modify the state of the Utxo to do whatever it's supposed to do, like swapping, and can return the Utxo back into the shielded pool without, for example, the user having to know what the final state of the Utxo is.
00:12:03.874 - 00:12:55.806, Speaker B: So this is the part that we can provide here with zk assets. So how does this work? So we have the notion called transparent Utxos. So you see at the top there we have a zcash style private transaction, where inside of the commitments you store the actual value of this Utxo. And the purpose of the ZKP is to make sure that you're preserving the value as you're taking inputs and outputs so you don't create money out of nowhere, and to also ensure that when you nullify those objects that you're not double spending. So that's the purpose of the ZKP up there. So instead what we do is we extend the UtxO not just being a commitment, but also containing some public value externally to it. And we just extend this notion of transfer where you can move the amounts inside and outside of the Utxos.
00:12:55.806 - 00:13:25.998, Speaker B: So still here you can see on the left we have two fully opaque utxos, like nine and six. And then we transform them into one of them, which is transparent, which has eight value outside and seven inside. So now this one with eight can be given to a contract, and the contract can modify that outside part so that you can perform, say, a swap. So we'll see an example. And this design is inspired by flax by way Dai. It's slightly modified, but it's inspired by that. So let's go through an example.
00:13:25.998 - 00:14:18.618, Speaker B: So let's say we want to call uniswap without revealing our address. So first we select one Utxo we'd like to spend, we'd like to swap with. So let's say we have ten wrapped ETH. So we select one of these, we make it transparent using one of those transfer mechanisms. Then we give it to this ZK asset router, which we can say, okay, given these Utxos and given this contract, I'd like to call, please execute it for me. And so the zk asset router, given the UtxO, knows the value that's stored in the transparent part, withdraws those funds from the shielded pools account itself, performs a swap, and then can rebuild the other transparent Utxos that should go back into the pool. So let's say you're taking one wrapped Ethan creating 2000 die, so you create those two output transparent Utxos and then just insert it into the pool.
00:14:18.618 - 00:14:53.370, Speaker B: So because you know that you're able to spend that first one, you create the transparent Utxo in such a way that those final ones you can also spend. But the contract doesn't know who it is. Right? So basically you're saying let the shielded pool act in my behalf instead of me revealing my address. So this is sort of the main example that you can look at here. So that's revealing the entire state of the Utxo that's fully transparent. But maybe we only want to give a few details about it. We want to just prove some smaller property of it.
00:14:53.370 - 00:15:32.066, Speaker B: So we call these configurable asset disclosures. So an example perhaps is you have some NFT. Let's say you have an ape NFT and you want to prove inside of a contract that it is an NFT. Sorry, that it is an ape NFT, but you don't want to reveal which one you have, right? So you could have, this is NFT disclosure, where you pass in the address of the ape contract, you give your Utxo and you give a proof that if you were to open the commitment, you would see that there was ape in there without revealing which one you have. So this is a little component you could use. And then another one, it doesn't have to be just about the ID. You can also prove other kinds of properties.
00:15:32.066 - 00:16:20.690, Speaker B: So, for example, that you have at least five wrapped ETH where you could have more than five, right? So these kind of little modules, these can also be pre compiles that are built in at this circuit layer so that you can build more complex applications than just spending and transferring. So the third category of applications, sorry, the third category of pre compiles that live at the circuit layer is stuff like signaling. So this is inspired by semaphore. It's slightly modified. So you can think of signaling as anonymous on chain messages. And so the way you build one of these systems is you build some context where you give some set of rules on who is allowed to make messages and how often they're allowed to make them, and the rules for those messages. So let's look at two examples.
00:16:20.690 - 00:17:03.298, Speaker B: The first example is the polling example. So let's say you want to run some vote on chain, and the rule is that one identity, one vote. So you build some set of identities which you consider to be the allowed participants. And the signaling protocol will ensure that when they sign their vote that they are, in fact, it's a valid signer that they've only signed one vote and not multiple votes, and it still keeps them anonymous. Right? So this is a kind of system you can build with signaling. Another kind of system you can build is a message board. So on a message board you want to still allow multiple messages, not just one, but maybe you want to rate limit them, right? So you don't get spam in your message board.
00:17:03.298 - 00:18:02.870, Speaker B: So these kind of rules you can encode and the signaling level, and then the signaling ZKP is just ensuring that you're following the rule of that context. So that was the circuit layer where we build sort of these pre compiles that are optimized for this VM so that developers can use these primitives when they're building their sort of bash scripts at the solidity level. So let's talk about how we can build those. So the first thing we need to figure out is how do we compose ZKPs. So before we saw, we had a bunch of these different circuits, like the shielded pool transfer or the is NFT circuit or the signaling circuit. So we need to find a way to compose them so that we can know that we're calling those circuits on the same private data. So here's a naive solution is, let's say you have these circuits, c one and C two, and they operate on this private data w and the public data X.
00:18:02.870 - 00:18:55.430, Speaker B: And so if you do these separately, you produce two different proofs, right? So one solution is, okay, I'll just combine both circuits so that I know that I'm actually operating over the same w, right? You could think in some malicious prover they could just put a different W in C one and different W in C two. You'd have no way of knowing. So instead, let's just put the circuits together, right? But this doesn't scale, because let's say if we have 100 or 1000 of these little modules, you'd have to build every combination you could expect, which doesn't, it grows too much, right? So that doesn't work. It's non modular. So let's find some other solution for this. So one solution is called re randomized commitments. And so what we do is we take that original circuit that operates on W and x, and instead we add an extra constraint inside of it where we basically just commit to the private data w and we reveal that commitment.
00:18:55.430 - 00:19:52.554, Speaker B: We make the commitment value, the actual commitment, public input, so that now we can compare those and make sure that they're the same for multiple circuits. So at the bottom here, we have that original scenario. We have the C one and C two, and we'd like to transform them into this RC form. So now, because W is still private, RC is public, and because of the binding properties of these commitments, if RC is the same on both, then you know that W is the same up to the security of the commitment scheme. So let's look at an example of how we can use this RC system, the re randomized commitment, to build an example contract. So let's say you have the Apefest 2023 event and you want all the ape holders to vote on where the venue is, but you want them to vote anonymously. So if we build this contract here, first you build your mapping of all the votes, right? You have some set of proposals, let's say five different venues, and you count how many votes you got.
00:19:52.554 - 00:20:29.398, Speaker B: So first, for anonymous vote, the first object is the RC. This will link together all the different proofs that we provide, and then you have the proposal you're trying to signal on, and then the proof that it's a valid vote. So the first thing we do is we take the shielded pool contract and we check that the RC binds to some value in that pool. So I just prove I own some asset. I don't know which one it is yet. But I own something, right? Then the next line is saying, okay, let's check that it is an ape NFT. So we take the same RC, because we know that the same witness is being used here.
00:20:29.398 - 00:21:08.546, Speaker B: So we take the same RC and we say, okay, now that I've proven I have some asset, I know, no, it's an ape NFT. I still don't know which one it is, but I know it's one of them. So now we're saying, okay, those are the valid credentials for someone to vote in this protocol. So now that we know that they're a valid voter, now we check their proposal, okay, because it's using the same RC, we check the signature of the proposal, that it matches the signal that we're allowed in this context. So once you've checked all those three things, we just increase the number of votes for that proposal. So this is how you would build one of these at solidity, right. You don't have to build any circuits yourself.
00:21:08.546 - 00:21:48.106, Speaker B: You just compose these smaller modules in this Unix like way that lets you build some more complex application on top. So that's the story of composing sort of at this conjunction level where you have multiple properties you'd like to prove about a single piece of data. This is the conjunction kind of composition, but there's other kinds, and the other kind is chaining. So let's say you have some proof that someone gave you about something. You'd like to prove that you know that that proof is valid, right? So now I'm proving something about a proof, and you can keep chaining these things. And in general, this is known as proof aggregation. So so far, we haven't talked about aggregation.
00:21:48.106 - 00:22:23.818, Speaker B: We just talked about conjunction based composition. But aggregation is also something we'd like to support in the future. So the way we're going to build that is instead of just having pre compiles for specific circuits that you'd like to compose, also have pre compiles for different curves. So you can build your own proof of aggregation primitives yourself. So stuff like the pasta curves, stark verifiers, or also the BLS curves. So the pre compiles that live with that circuit level don't also just have to be circuits, they can also be cryptographic primitives, so you can build your own aggregation systems. So that's sort of the overall design.
00:22:23.818 - 00:23:03.430, Speaker B: Now let's just talk about the different trade offs that we've made to try and position, trying to make the decisions that we made clear why we made them. So first, let's look at Vitalik's classification of ZkevMs. So this is not a ZKVM necessarily, but we think it's still helpful to look at the spectrum here. So we've also put optimistic roll ups there as well. So if we look at the different categories here, the first is Ethereum equivalent, so exactly the same as Ethereum supports exactly the same execution. And this is sort of what the PSE group is working on with their ZkVM. Still a work in progress.
00:23:03.430 - 00:23:22.918, Speaker B: The second category is minor changes, so you don't break any existing applications, but it's not exactly the same as Ethereum l one, then you have category three, which is maybe you're missing some hash functions. So maybe instead of just replacing some of the state tree like we did with Poseidon, maybe you replace the whole state tree with Poseidon.
00:23:22.934 - 00:23:23.066, Speaker A: Right.
00:23:23.088 - 00:24:09.206, Speaker B: So in that case you can't be exactly the same as EVM. So you're in sort of category three, and maybe you're missing some pre compiles, like you don't have the BN precompile in your system, so that's sort of category three. And then category four is just okay, just forget the EVM entirely. Let's work on a high level language like solidity, or maybe even solidity, or Viper, or also Cairo for Starknet. So this category four, so we think Poseidon VM lives in category two, where we still support every EVM application, but we're providing more pre compiles so it won't match all the existing tooling just yet. So this is sort of where we live on this compatibility spectrum. And so let's look at some other trade offs that we've made against other projects.
00:24:09.206 - 00:24:56.378, Speaker B: So the three categories I'd like to talk about here are on chain execution, the way that you build composite systems and the programming model. So we just look at optimistic rollup like optimism or arbitrum. The execution is EVM, and you compose using the EVM composition, and the programming model is solidity, right? Or other kinds of EVM, high level languages. So in those systems you can also build ZKP, you can build zk apps, but you need, let's say, using circom. It won't be as fast as the system we've built, because we have the pre compiles that let you optimize the gas costs of individual circuits. So you can do it there, but it's not going to be as efficient. So that's why we've, for example, used zk pre compiles over, not using them.
00:24:56.378 - 00:25:31.750, Speaker B: And then you have something like Alia or Amina where you have the verifier as this on chain execution and the rest is done off chain. You build your proofs off chain and then you do the verification on chain. And the way that they compose is by proof of aggregation, right? So you have this notion of when I'm calling another contract, I build a proof that I executed that contract correctly off chain. And then if that contract calls another contract, then I just pass the proof of the first one into the second one and verify in the second one. And I just chain these together. So that's just purely using proof aggregation. And you have to sort of use a custom language for any of these systems.
00:25:31.750 - 00:26:13.214, Speaker B: So something like Leo or typescript in the Mina's case. And then Poseidon VM sort of somewhere in the middle where we still want to have EVM as our main on chain execution, but we want to support making zk apps themselves faster, not just trying to do something like arbitram, where we make everything faster, sort of by scaling everything. So this is sort of the middle ground that we've chosen. And so at first we can support for composition because we're making zk apps faster. We can use re randomized commitments immediately to get composition at that level without having to resort to something like proof aggregation. In the future. We of course want to support it, but at first we use it just re randomized comments.
00:26:13.214 - 00:27:02.420, Speaker B: And so you can also, again, use solidity and you can in this case use circum to build your circuits as well. And we're working also on something called OpenzL, which lets you not just use stuff like circum, that lets you build, let's say, your solidity verifier for you, but also integrate with other systems that are sort of less connected in this open source world, like Halo two or plunky two. And maybe you wanted to write some code in solidity and then compile it, sorry, write some code in circom and then compile it in halo two. So this is sort of the kind of space that OpenZL lives in. And this is an experimental project also alongside Poseidon VM. So just generally the strengths of these two protocols, right, Alio and Mina, they're able to get this perfect uniform interface across ZK apps. You just have to think just Leo, and then you can build everything with that.
00:27:02.420 - 00:27:35.226, Speaker B: Whereas for Poseidon VM we want to give compatibility with EVM, so we sacrifice that uniformity for compatibility. So this is sort of the space of the trade offs that we're making here. So just a summary of what we've talked about. Right. So first thing is to make Zkaps accessible. First, you build these layered programming abstractions, the storage, the pre compiled circuits, and the composition at the top up. Then we make sure that these pre compiles are making zk apps faster.
00:27:35.226 - 00:27:48.960, Speaker B: So to get dirt cheap transactions and make sure that this whole system is as compatible as possible with the EVM. So join us if you're interested. We're always hiring for all positions to build the next 70,000 zk apps. Thank you.
