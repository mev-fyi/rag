00:00:06.330 - 00:00:18.750, Speaker A: Welcome to Zero Knowledge, a podcast where we explore the latest in blockchain technology and the decentralized web. The show is hosted by me, Anna and me Frederick.
00:00:25.210 - 00:00:35.350, Speaker B: It in this episode we sit down with Tomash from parade Technologies to talk about what a mempool is and the lifecycle of a transaction on the Ethereum network.
00:00:42.810 - 00:00:43.606, Speaker A: Hey guys.
00:00:43.708 - 00:00:44.454, Speaker B: Hello.
00:00:44.652 - 00:00:45.254, Speaker C: Hey.
00:00:45.372 - 00:01:28.802, Speaker B: Today we're going to do another 101 episode, which I'm pretty excited about. This was originally a listener request and it's a good topic. It's about the quote unquote mempool or transaction queue or transaction pool. Like it has a lot of names and there's a lot of confusion around this. But basically we're going to talk about the lifetime of a transaction, like from leaving your computer to being in a block, what happens to it? And we have a special guest with us, which is probably one of the best guests we could possibly have for this topic, because he wrote the transaction queue implementation in parity. Welcome, Thomas.
00:01:28.946 - 00:01:45.854, Speaker C: Hi there, Fred. Thank you for the introduction. I actually wrote the transaction queue twice already, once when I was starting Pinpariki, but then I figured that it's a good time to do a rewrite after sometime and I saw how shitty the previous code was.
00:01:45.972 - 00:01:47.450, Speaker A: When did you do that rewrite?
00:01:47.530 - 00:01:51.342, Speaker C: So the rewrite happened like two months ago, I think.
00:01:51.396 - 00:01:52.554, Speaker A: Oh wow. Pretty recent.
00:01:52.602 - 00:02:02.370, Speaker C: It has been released with parity 111. Yeah, and I'm pretty happy about it. But now know a couple of things that could be improved further.
00:02:02.790 - 00:02:13.926, Speaker B: It was a big improvement. Did get a couple of comments from Miner saying that it was performing a lot better and they were getting better block prop times and stuff like that.
00:02:14.028 - 00:02:23.850, Speaker C: Yeah, but it was like a couple of changes contributed to this. It wasn't only that transaction fully, right. But yeah, it was pretty significant release actually.
00:02:24.000 - 00:02:33.790, Speaker B: So let's start maybe by defining some of these things. What is a transaction queue and why is it sometimes called a mempool?
00:02:35.730 - 00:03:28.042, Speaker C: Yeah, so pretty much all the three things you mentioned. So transaction queue, transaction pool and mempool, they signify the same thing. So the mempool is sort of like bitcoin nomenclature. In parity we call it transaction queue mostly, and I think in gas it's called transaction pool, but they all mean the same thing. So if we are talking about mempool in context of Ethereum, it means that the thing that stores the transactions on your node locally and propagates them to the peers. And also if you are mining, it's used to determine what are the best candidates for the next block. That you are actually mining.
00:03:28.186 - 00:03:55.350, Speaker B: I guess the name Mempool would come from sort of, you have all these transactions floating around on the network, and you can only capture and store in memory a certain amount of them before your memory pool is exceeded, and you can't really accept any more transactions, and you kind of have to prioritize this queue and not accept any more into the queue. So I guess that's where the terminology comes from originally.
00:03:55.770 - 00:04:04.554, Speaker A: I do like that word, mempool. It sounds like it should be the name of a band throwing it out there in the world. I like it.
00:04:04.592 - 00:04:08.454, Speaker B: Maybe it's a future podcast name or something. The mempool.
00:04:08.502 - 00:04:10.874, Speaker A: Yeah, that sounds like that too. Cool.
00:04:10.992 - 00:04:28.386, Speaker B: So yeah, we were talking about these transactions and how they get into this transaction queue, but maybe we take a step back and look at the network. What is the Ethereum network exactly? And how do these computers connect together?
00:04:28.568 - 00:05:38.010, Speaker C: Yeah, Ethereum network is just a bunch of computers connected together. Obviously we cannot connect to all of the computers running Ethereum client because there is too many of them and no hardware will be able to handle so many connections. So we always only see only couple of nodes that are nearby us and we only connect to a couple of them. So we create this kind of mesh of connected computers. So if you want to send something in the network, it actually has to propagate through the network because you only send it to the peers that you know about and you hope that they will propagate it further to their peers until finally it gets to the recipient. And there are a couple of ways how we can connect to this network. So because it's completely decentralized, we don't really have a single server that you can go to and everyone can connect to.
00:05:38.010 - 00:06:31.750, Speaker C: You actually have a couple of special peers which are called boot nodes. And those nodes, they have many peers, and they are able to kind of show you the other part of the network. So you only know these peers as the first point of contact, and then they tell you, hey, there is a bunch of other guys in that network, so maybe you will try to connect to them. You might get better connection, lower latency to those other guys. So we are discovering that network by first connecting to boot nodes, then connecting to other nodes, and they also can give you their peers. So you're discovering the entire network through this way. And the second way to discover the network is to run the discovery protocol, which is just kind of like broadcasting.
00:06:31.750 - 00:06:43.386, Speaker C: Hey, I am an ethereum node. Is there anyone else here running an ethereum node? And the other guys can reply and you can get connected.
00:06:43.498 - 00:06:55.010, Speaker A: When you mentioned these boot nodes, maybe I didn't fully understand that, but are these like special nodes, like individual special nodes, and it's always the same. It's not like it would change for different individuals.
00:06:55.350 - 00:07:28.810, Speaker C: Boot nodes are just nodes that are hard coded in the client and they doesn't have to be fixed. So that boot node list can be managed and can be changed by anyone. You can actually override the boot nodes when you are connecting to the network as well. It's just the nodes that we kind of see that are there are maybe run by some companies like we parity, we also run a couple of boot nodes so people can connect to them, but it doesn't mean they are required to connect to the network, if that makes any sense.
00:07:28.960 - 00:08:48.980, Speaker B: So on a sort of basic level, the network is a distributed hash table or a DHT, or runs on a DHT. And this is similar to how BitTorrent runs and how you can discover peers in BitTorrent, but in this sort of DHT structure, if you imagine the DHT, the distributed hash table as being like a long list of all the peers in the network, then to discover this DHT and to get the information from it, you need an entry point into the network. So you need someone to first tell you where do I find information here? And either you can do what Tomas said, just like broadcasting widely and pinging all local ips and then trying to ping all public ips, or search some IP space for another ethereum node that can be your entry point, or you pick one of these boot nodes. So Geth has a set of boot nodes, parity has another set of boot nodes. We have some overlapping servers in each, and these are just servers that have been shown to be reliable and well connected in the network. And so they serve as that entry point to give you the first sort of entryway into discovering the rest of the network. They don't have any sort of special trust.
00:08:48.980 - 00:08:55.640, Speaker B: It's not that you're downloading the blockchain off of these and you trust what they're telling you or anything.
00:08:56.570 - 00:09:11.434, Speaker C: So it's pretty much just to speed up this process, right? Because the completely decentralized way would be just to find a peer, a random peer that is connected to the network. But it might take quite a long.
00:09:11.472 - 00:09:30.002, Speaker A: Time maybe to continue. So you started talking a little bit about the beginning of a transaction there, or you've talked about how a network first gets connected. But I think it would be really cool to follow the journey of a transaction. Maybe you can walk us through where it goes and how it gets to a miner in the end.
00:09:30.136 - 00:10:08.362, Speaker C: Okay, yeah. So with the transaction. So the first step to actually have your transaction included is to generate the transaction. And that happens locally on your computer, because every transaction in ethereum network has to be signed with your private key. So obviously a good security practice is to never share your private key with anyone. So on your trusted computer, you are signing the transaction and then you are submitting that transaction. In a perfect situation, it would be submitting to your local node that is already connected to the network.
00:10:08.362 - 00:11:13.540, Speaker C: And what happens is that that signed transaction tries to get to the pool, so it has to go through first the verification pipeline. So we check if the transaction is correct, if there is enough balance on your account to actually send that transaction, if you declared enough gas for the transaction. So if the gas limit is set correctly, the gas limit also cannot exceed the block gas limit. There is also a parameter that controls how much you want to pay for transaction execution. But when you are submitting that transaction to your local node, it doesn't matter that much in how fast it will get propagated through the network from your local node. Because we prioritize local transactions always. So your transaction gets like a priority boost because it's just yours and you want to get it out first.
00:11:13.540 - 00:12:11.558, Speaker C: Yeah. So when it gets to the pool, then we start to propagate that transactions to other peers. So what happens is that imagine that you are connected to 100 of peers. We don't spam the network, we don't send it to all the hundred peers at once. Rather we select some random peers from all the ones that you are connected to, and we propagate first to those random peers, and we repeat that process every second, I think, or a second and a half, and then we select more random peers and send to them again. We also store who did we send the transaction to, and also who did we receive the transaction from, so that we don't really send the same transaction twice to other peers. It's considered like a bad behavior, so the other end might actually penalize us for doing that.
00:12:11.558 - 00:13:14.870, Speaker C: So they can disconnect us if they don't like it. So yeah, we start at your local node, we send to random peers, we do it every second or every 2 seconds. We select more random peers, we send it to our local neighborhood, and then we hope that those peers will propagate that transaction further in the same fashion until we get to a node that is actually running, that is a minor. So it's running some kind of mining pool, and that particular node will do exactly the same thing. So it goes through the verification pipeline and then tries to figure out what is the priority of your transaction. And the priority is actually determined by how much they can earn from including that transaction. So what is the fee that is paid for that transaction? And they create a block if your transaction is like at the beginning of the queue.
00:13:14.950 - 00:13:37.380, Speaker A: Okay, so I have a question there. You sort of mentioned a transaction, a node transaction gets priority, sorry, a local transaction gets priority in your own clients. So that's the first thing that goes out. Then it goes to a random number of people, but a random number of nodes, how many?
00:13:37.830 - 00:14:17.978, Speaker C: So the precise formula is like x over square root of x, if I remember correctly. So it's just like a percentage of what's there? Yeah, it's a percentage, but it's a function that grows because percentage is linear. So if you have like 10,000 peers, it would be 1000 peers, if we are speaking about 10%, for instance. But we are trying to keep this very limited. So this function is growing slowly. So even if you have a network of and you are connected to thousands or tens of thousands of peers, you will only send to up to, I don't know, like hundreds.
00:14:18.074 - 00:14:18.718, Speaker A: Okay.
00:14:18.884 - 00:14:24.180, Speaker B: What's the reasoning behind doing this rather than just instantly sending to everyone?
00:14:26.470 - 00:15:05.742, Speaker C: Actually, I'm not quite sure. I think it's just like politeness and preventing network contention, because those other peers, they are connected between each other as well, so there is a good chance that they going to gossip that transaction between themselves in the future. And then because we are monitoring the transaction that the other peers are sending to us, so we kind of send a bunch of transactions, we save your bandwidth so you don't spam the network with your transaction, because then there is a high chance that it will get propagated anyway.
00:15:05.876 - 00:15:25.300, Speaker A: Is it sort of to avoid duplication of work, or you only want, once you send it out to that first group of random nodes, how many do you need to pick it up to keep it going? Are you looking for a certain percentage to keep pushing it, or do they all push it? That's, I guess what I'm kind of confused on there.
00:15:26.250 - 00:16:27.682, Speaker C: Every peer in the network have their subjective view of what the mempool is, so you don't really have this global consensus on the mempool itself. So every node is able to choose any transaction they want to propagate faster or to propagate slower. This kind of like game theoretic, agreed upon way of doing that is to prioritize transactions that are paying the most fee to the miners. And this is what other peers are also doing, because they have a good chance of including a block. But yeah, this is just like the expected behavior of the peers, because there is no way to prove that you actually received that transaction and didn't propagate it further. So you cannot really penalize other peers for not following the protocol. This is completely subjective.
00:16:27.826 - 00:17:33.258, Speaker B: I think this is all sort of within the definition of what a gossip protocol is. And gossip is a very broad term, it's not a specific defined protocol. And there's been a lot of analysis done on gossip style protocols where you look at how fast do things spread, and exactly those questions of like, how many people do you need to pick it up to actually propagate to the whole network and stuff like that. I've not seen any conclusive answers on like, this is the exact number that you should have and expect them. It's a very generous protocol in that you don't really need all that many people to pick it up and propagate it for the gossip to actually spread throughout the whole network. And yeah, if you just send to 25% of people, and most of those pick it up and send it to 25% of their people, then it has this sort of exponential increase anyway. So highly likely that it'll propagate throughout.
00:17:33.274 - 00:17:51.202, Speaker A: The whole network, just sort of to go back to that thing about prioritizing the local transactions. So if a node picks up just a different transaction from a mem pool, and then it's also sending its own transactions, it would prioritize its local transactions over that?
00:17:51.336 - 00:17:59.750, Speaker C: Yes, even if you are paying smaller fee, your local node will send your transactions first.
00:17:59.820 - 00:18:00.102, Speaker A: Okay.
00:18:00.156 - 00:18:12.860, Speaker C: But it doesn't mean that they propagate faster in the network, because the other end that is receiving that transaction, they don't really have that information, that they are not of a higher priority for them.
00:18:14.030 - 00:18:28.590, Speaker A: So a node is pushing out its own transactions and then propagating other transactions. How many transactions, maybe per second, does a node deal with? Or maybe, I don't know what your time frame is, but I'm just curious.
00:18:29.650 - 00:19:24.994, Speaker C: I think we didn't really do benchmarks, how fast we can propagate transactions or how fast we can receive transactions. But I think there was a point in time when in Ethereum main network, there was like 150,000 transactions floating around in the network because the blocks were full, the fees were increasing, and there was a lot of pending transactions. And yeah, at that point in time I was spending some time doing optimization of the transaction queue because we saw increased cpu usage of the nodes. But yeah, it was handling that amount correctly. But I don't have numbers in terms of throughput, how fast we can provide it.
00:19:25.032 - 00:19:33.620, Speaker A: Do you have even like a sense of it though? I'm just trying to imagine if it's like twelve or hundreds or like thousands, anything.
00:19:35.850 - 00:20:41.046, Speaker C: I would have to check the numbers. But if you are creating an Ethereum block, right, current gas limits allow you to, I think, store 200 transactions. So even if we could send more, it doesn't really make sense to propagate more transactions than for the next like two or three blocks. So actually in parity, currently the limit of how many transactions we propagate to the network is current block capacity multiplied by two or by three. So we try to propagate transactions for the next free blocks. But if you want to be selfish, you can actually send your transactions as fast as your hardware supports that. The only issue might be that the other peers might not be able to keep up with all the transactions that you are sending to them, and they may decide that they don't want to be connected to you because you are spamming them with the transactions.
00:20:41.046 - 00:21:05.854, Speaker C: So I don't really have the numbers, but we are sending like 600 transactions every second currently in parity Ethereum on the main net, because this is like how much we actually have to send, but it would be really easy to send way more. It would just increase your cpu usage and bandwidth on the node.
00:21:05.902 - 00:21:56.690, Speaker B: Yeah, so there's a difference here between what a node can do and what a node needs to do. So I just looked up on ether scan, and there's currently 60,000 pending transactions in the mem pool. And it's quite a lot, but it's not like outrageously long. Like Thomas was saying, there's been 150,000 plus sometimes. And I know we've run some benchmarks on not only propagating transactions, but actually including them in blocks, on POA networks, in closed environments, between two nodes or whatever. And the bottleneck is never the propagation time. We could probably propagate 50,000 transactions in a matter of a couple of seconds.
00:21:56.690 - 00:22:06.066, Speaker B: So the slower thing is like validating these transactions, running them like including them in blocks and all this other stuff.
00:22:06.168 - 00:22:38.586, Speaker C: Yeah, actually validation is kind of two parts, so one part can be done completely in memory, and it's just like cpu bound. And this was never a limit as well, but the heaviest part is actually running the transaction. So writing something to the state tree or reading something from the state tree, because it's usually stored on the disk and it requires a couple of random disk reads or disk writes and it's really slow. It's currently the limiting factor for Ethereum network.
00:22:38.778 - 00:23:07.430, Speaker A: So the reason that I'm asking the question I first asked, which was like I'm just trying to imagine what the node is doing, kind of at what frequency it's doing that. So the node itself, it's sending local transactions, it's propagating other transactions that it's picking up. And I'm just wondering, is it pinging at a beat of like this? That's sort of what I'm trying to get to. I'm just trying to envision how that thing itself is working.
00:23:07.580 - 00:23:50.694, Speaker C: Yeah, it's like interval based. So every second we are doing quite a lot of work. We are taking the best transactions that we have in a pool. We are taking up to let's say 1000 transactions from the pool and we are trying to send it to this random peers. But first we need to figure out, or if we send some transactions in a past to that peer as well, or we maybe receive some transaction from that peer. So we are doing this difference, what has to be sent, what that peer already knows about, and it happens every second. And also in between that time we are actually handling all the requests that other peers might sending to us.
00:23:50.694 - 00:24:11.040, Speaker C: So they either propagate transactions to us, so we need to verify them, include them in the pool, or they might request some data from us like block headers or block bodies of the past blocks as well. So there is quite a lot of things happening in the note every second.
00:24:11.570 - 00:25:21.598, Speaker B: So your question, I think it's a good one because it also sort of highlights we get quite a lot of questions or complaints about parity getting slower over time. And from a normal user's point of view, it's like using more disk, it's using way more cpu than it used to do, and it's just like it's way slower. Like why every release it seems to be getting worse. And that's not because parity is getting worse, it's because the network is getting more congested and the blockchain is getting bigger. And a common misconception of the cpu increase is actually there's now so much transaction spam, there's all of these bots like trading on decentralized exchanges, trying to overbid each other on gas prices and things like that. So what happens in a bidding war between two bots, for instance, is they send a transaction with one g way as their gas price, and then another bot sends one with 1.1 g way as their transaction gas price, the exact same transaction.
00:25:21.598 - 00:25:48.522, Speaker B: And so the bot number one says, hey, you're not going to beat me to this because this trade is still profitable if I get it through. So they send another transaction at 1.2, like superseding their previous transaction. So they keep doing this biding war in the transaction pool. And this only happens in the transaction pool. It's never shown on the blockchain that this happened. The blockchain only sees the one that was actually included at the end.
00:25:48.522 - 00:26:14.180, Speaker B: So Phil Dyan, multiple guests on the show, he keeps tweeting out every once in a while, like the highest gas price paid, and the last tweet from him was 17,000 g way. And that's a profitable trade for a bot to make. So it's gone up like probably thousands and thousands of transactions in a trade war to get to that point.
00:26:14.630 - 00:26:26.342, Speaker A: In that example, then are there some transactions that just die? They never do anything. They just sort of sit there, fill it up and do they get removed at some point?
00:26:26.476 - 00:26:39.610, Speaker B: Yeah, I think this is a good question as well, because it ties into what happens when a transaction gets stuck and you want to redo it at a higher gas price or something to make sure that it gets included.
00:26:40.530 - 00:27:41.200, Speaker C: In Ethereum transactions doesn't really have an expiry date, so they can be in a mempool forever pretty much, if other transactions are actually higher priority, so they pay more fee and they are included first. And also in Ethereum we have something that is called nons that serves two purposes. First purpose is to have replay protection for your account. So when you are doing a transfer transaction, you actually want to do only one transfer to a specific person, right. You don't really want anyone else to take that transaction, put it in a blockchain again, and do the transfers for the second time. So this is what we have noms for. Every sender has this particular number that has to be included in the next transaction that is originating from that particular account.
00:27:41.200 - 00:28:42.882, Speaker C: And also, nons allows you to order the transactions. So first you have to process transactions with lower nonsense, and only if transaction with, say, nons five is processed, you can only then process the transaction with nons six. So if you send a transaction with a very low gas price, and then you try to send more transaction from the same account, and even if you try to increase the gas price, so you try to increase the priority of the next transaction transactions. This one first one might actually be blocking all of these other transactions because it has to be included first. It's what the protocol says, but it's not included because it's like low priority and it's blocking this higher priority transactions. So what you can do is actually you have to resubmit that same transaction. So use the same nums for the second time, but specify higher gas price.
00:28:42.882 - 00:29:28.770, Speaker C: And this is what Fred already mentioned, this is how this trading war happens. So they are sending a next transaction, but they are then sending an update for that particular transaction, trying to overbid themselves. So increase the gas price, and then that actually pushes out the old transaction from the pool. We also have a DDoS protection there because you could just increase the gas price by one way and it should replace the transaction. But to prevent the nodes from doing too much stuff, and especially miners from actually replacing those transactions from the block, we specified that the minimal gas price increase has to be at least like 12%.
00:29:28.920 - 00:29:43.030, Speaker A: This nonce question. So when we did an episode about blocks and block headers and there was nonce was used there as well. Is this related or is that a completely different use of a nonce?
00:29:43.370 - 00:30:24.740, Speaker B: It's a different one. So nonce is a general term, it just means nonsense number that's sort of increasing in the transaction. It's a transaction numbering scheme, so it is strictly increasing thing, whereas in the block header the nonce is what produces the proof of work result that you are looking for. So when a new transaction with the same nonce gets posted, what happens? Does the node just remove the old one from the transaction queue and forget about it? Or is there some procedure happening there?
00:30:25.130 - 00:31:11.662, Speaker C: Yes, the new transaction, if it occupies, let's say the same slots, so the same sender plus non slots, we actually replace the old transaction, we forget about the old transaction and only include the new one. Yeah, but those transactions will never really die. I mean, for them to die, you would have to kind of force every node in the network that has ever seen that transaction to forget about that transaction and to stop propagating that. But it's something that won't really happen for sure. Impossible. So they never die, but they are just never included and never get to any block. So they kind of stuck forever.
00:31:11.806 - 00:31:15.310, Speaker A: Where do they live? Somewhere. Do you see them? Can you see them?
00:31:15.400 - 00:31:57.090, Speaker C: I mean, it depends on the peers that are storing it, because the pool is limited. So if you have enough capacity to store all those transactions, that won't really be included will never be included. Then, sure, from time to time you might even propagate that transaction to some other peers. And we have a couple of nodes in the network, for instance, etherscan. They are having really large pools, and they are storing all transactions that they have seen and repropagating all the transactions that they have seen in the past. So they are kind of like making sure it won't die.
00:31:58.150 - 00:32:04.334, Speaker A: But most nodes, mem pools will be smaller, and so it will just drop off. Like it just won't be included.
00:32:04.382 - 00:32:16.614, Speaker C: Yes, but it might drop off at some point and then reappear at some other point just to be pushed out by some other transactions in the future again. So it might be kind of like.
00:32:16.652 - 00:32:24.806, Speaker A: Flipping, by the way, is that correct? Does a node have its own mem pool, or is there a mem pool that a node taps into? Like, is it individual to the node?
00:32:24.918 - 00:32:57.474, Speaker C: Okay, so every node in the network has its own mempool, and it's like this subjective view of all the transactions that they have seen ordered by the priority and the nodes. So there is no global mempool that everyone is using. It's just like I saw those transactions. They seem valid to me. They seem useful for others, like miners. By including those transactions, they can earn fee. So I'm going to propagate that to my other peers.
00:32:57.602 - 00:33:32.880, Speaker B: I had a question on the propagation part. We talked a little bit about this sort of gossip structure and propagating to a portion of them, but there seems to be a flaw here in that you can produce this sort of infinite loop. If I tell a about a transaction, or let's say node a tells node b about a transaction, node b tells node c about a transaction, and then node c tells a, then obviously a shouldn't be telling b again, because you've entered this infinite loop. How do you prevent that happening?
00:33:34.310 - 00:34:54.426, Speaker C: So every node actually tries to remember what transactions has been already sent to its peer, and also it stores what transaction it has received from that other peer. So we try to never send that transaction twice if we know that a peer already received that transaction from us, and also if we know that a particular transaction has been sent by this node. So we got that transaction from that node, we don't really propagate it back because it doesn't make much sense, although randomly we also choose peers that we kind of forget that we propagated the transactions to them to just keep the transactions flowing. Because if we send the transaction to a peer, we don't have any guarantees that they received it and included that in their mempool because their mempool could be full. And we are thinking, oh yeah, they should have that transaction because we sent it, but they didn't have time to process that transaction or their mempool was full. So they don't really propagate it further. So from time to time, we select random peers where we kind of repropagate the transactions to them again.
00:34:54.608 - 00:35:06.480, Speaker B: So is this sort of metadata that's attached to a transaction, and then when the transaction leaves the queue, this all gets removed as well? Or is this stored somewhere else?
00:35:07.010 - 00:35:15.890, Speaker C: Yeah, technically I think it's stored on the node table. So it's part of the node metadata. Not really transaction metadata.
00:35:16.870 - 00:35:34.834, Speaker A: So there you were talking about gossip. But I guess I have a quick question about gossip. When you talk about sort of communication going from node a to node b, would it also go backwards? Is there like something coming back in gossip or is it a one way propagation?
00:35:34.962 - 00:36:30.634, Speaker C: Yeah, it's one way. We are just like broadcasting what we know, what we have learned, like this hot rumors to all the peers that we have. And it could go back if we go through, as Fred said earlier, if we go from node a to b, then b to c, and then c to back to a, because node c doesn't really know that this message originated from a, but it doesn't really change anything. I mean, it's not something that is bad for the protocol necessarily, because the important thing is that that process ends at some point, right? So either the message that we are spreading becomes obsolete and we should just all forget about it, or we keep to propagate that the entire time because we just have resources to do so.
00:36:30.752 - 00:36:39.674, Speaker A: Also, a little question about the word gossip. Is gossip like a traditional computer science networking word, or is that something that's more coming from this space?
00:36:39.792 - 00:36:54.320, Speaker B: I guess it's become that, but it comes from analyzing actual gossip, and the name comes from studying how gossip spreads in offices and social networks. Wow.
00:36:55.750 - 00:37:02.450, Speaker A: But the question here is, has it been used in other just networking things?
00:37:02.520 - 00:37:46.180, Speaker B: Yeah, it's been a networking term for a long time. Okay, I wanted to touch a little bit on the security properties of this network. So we obviously have this DHT discovery network where we gossip out transactions. And this looks very similar to a lot of other types of networks. I mentioned bittorrent, and typically these are quite resilient networks. It's very hard to sort of take them down. But also something that's very common in networking is having net splits, for instance, where you kind of split this network into two halves, and they kind of start acting on their own, and they don't see what the other half is doing.
00:37:46.180 - 00:37:52.498, Speaker B: What is done on the networking level to avoid net splits? Is there anything done?
00:37:52.664 - 00:38:43.102, Speaker C: So there's nothing done to prevent the network splits on the network level, because that's actually the whole point with the decentralized networks, that we only see a subset of the network. We are never connected to all the peers, we never form this fully connected graph. So we only see this small part, and we hope that the network is connected at some. And even if we disconnect for a short period of time, if the network split happens, when we reconnect back, we will still get into a consensus, like what the world should look like and what's the state of the network after that split.
00:38:43.246 - 00:39:24.850, Speaker B: Yeah, so a net split would essentially mean that you're creating a temporary fork until that net split is resolved, and then you might have to reorg in varyingly long chains, depending on how long the net split was. But something that, like, curious about it, and if anyone has done any study of, is we have a lot of the mining power in China, and China has the great firewall. What if they suddenly managed to split off all western miners from all chinese miners? You could potentially have a very long fork to deal with.
00:39:24.920 - 00:39:44.262, Speaker A: Yeah, but here you're talking about the miners splitting. But what if just nodes, could nodes just go in different directions? Nothing gets written to the blockchain, it's just the mempools change, or maybe the priorities in them are different. Do you actually have to reorg anything from that?
00:39:44.396 - 00:40:21.918, Speaker B: No. So what would happen if a bunch of just normal clients net splits, like say you have a small group split off for some reason, all the transactions they're trying to send and trying to propagate out would be stuck in just their little group, and it would be stuck in their little group, and never really propagate to a minor until they can reconnect to the whole network. And then they propagate all of this at once, and it would spread to a minor at that point. So the worst case scenario of a net split for a normal person is that their transaction gets delayed, which I mean, could be bad, but it's less bad than a long fork.
00:40:22.094 - 00:41:07.346, Speaker C: And the network part and the mempool part is not really part of the consensus. So we don't really need to have a shirt and common view that we all agreed upon. It's just like subjective to every note. It's just, as I said earlier, all the things that I have seen and think that might be useful for others. But I can make my own decisions on how do I prioritize that if I propagate the transactions further, and so on. For instance, in ethereum we have light nodes, and light nodes pretty much don't have the state, so they are not really able to verify the transactions entirely. So what we do, they don't really propagate the transactions at all.
00:41:07.346 - 00:41:36.186, Speaker C: They receive the transactions, they just ignore them. And they never send other transactions than your local ones to other peers because they are not able to verify if they are correct or not. Or maybe they are able to verify that, but it would take too much resources for them to do so because they would have to pull the verification, the data that they need for the verification from other peers anyway, which makes.
00:41:36.208 - 00:41:52.080, Speaker B: Sense for transactions that you really care about like your own, but it doesn't make sense for all the transactions flowing through the network. Exactly. Given the design of this network, why can't I just send a billion transactions and take this whole thing down?
00:41:54.770 - 00:42:43.226, Speaker C: You could send those transactions, you probably couldn't take the whole thing down because first you are only connected to a limited number of peers, so you are just like spamming those peers. Then these peers like the transaction is received by them. And it goes to this verification pipeline. And we make sure that this verification pipeline first does all the checks that are really cheap to do. So for instance, checking the structure of the transaction, the consistency, the minimal, the base gas, if it's enough to cover the base gas for the transaction, then the signature. And this is actually like pretty expensive part. And then we check the, the balance and the state.
00:42:43.226 - 00:43:15.350, Speaker C: But anyway, all those checks are really cheap compared to actually running those transactions. So if those transactions are not valid in one of those checks, we will reject them really fast. So you would have to have really huge computing power to generate and sign thousand transactions that would not be rejected in this early checks. In the verification pipeline.
00:43:15.430 - 00:43:26.880, Speaker A: In this verification pipeline, do you also look for identical transactions? If it was just like the exact same thing over and over and over and over again, would that also be something that's found in that process?
00:43:27.810 - 00:44:14.106, Speaker C: That's actually one of the first checks that we are doing. So we are checking if the transaction is already in the mempool. We are using hash of the transaction for this, and hashing is quite cheap. And then we are checking if that transaction is already in the blockchain, which is a little bit more expensive but still cheap. And recently with the changes that we did with parity 111. We actually also have cache for transactions that we have seen in the past, but we know that are going to be rejected from the pool. So we are going through this verification pipeline, then we figure out, okay, this is an invalid transaction, so we reject it, but we also store the hash so that when we see it again, because it's like through this gossip protocol, we receive that somehow.
00:44:14.106 - 00:44:17.802, Speaker C: Again, we actually reject it much faster.
00:44:17.946 - 00:45:05.786, Speaker B: It's all those checks. Plus the fact that even if you were to try to mount a successful attack in this way, you're only attacking your peers. So even if you manage to ddos and take down your peers, so what? You've taken down 25 of the thousands on the network, you kind of have to move on and try to take down the next. Even if you connect to 1000 and take down 1000, then yeah, you're kind of messing with people. It would be annoying for those that you're sending shit to, but you wouldn't take down the network because you would have to move on and take down the next set. And by that time you're not attacking the first set anymore. And so you are kind of, you've.
00:45:05.818 - 00:45:12.958, Speaker A: Let them be free. But what about those? Is there any mechanism to sort of shun a bad actor, a bad node?
00:45:13.054 - 00:46:09.986, Speaker C: I don't think we have anything implemented currently, but we could implement some kind of reputation system. It could either be like off chain and subjective. So if you see a node that is sending you too many transactions and it's actually causing you a lot of it generates like a resource usage on your side, you can disconnect that node and change the reputation of that node. Or we could also build something on chain. We would just have to provide some proofs of this kind of like misbehavior so that other nodes can also know that. But the problem is that it's subjective to something that is called civil attack. So the attacker, if they see that they are kind of like blacklisted or someone figure out that they are malicious, they can just generate a new identity and start all over again.
00:46:10.088 - 00:46:24.200, Speaker A: So you just explained sort of a scenario where somebody would attack the network, but I'm not really clear from what you said. Is it possible to actually take it down or is it possible to actually affect it?
00:46:26.650 - 00:47:05.410, Speaker C: But you can't really attack the entire network, but you can do a targeted attack, right? If you actually somehow figure out that that particular peers are mining, you can target your attack to the miners and they are kind of like this weak part of the entire network. Right. But hopefully the miners are protecting themselves correctly. So there are a couple of ways to avoid that, like mining on two nodes in parallel or preventing too many peers from connecting to your mining node.
00:47:06.550 - 00:48:01.270, Speaker B: So it would obviously theoretically be possible to attack the network and actually take it down. It just requires enough resources. Let's say there's 10,000 nodes on this network. You can lurk in the discovery process for months, try to discover all of these 10,000 peers, and just keep running the discovery algorithm for months and months. Eventually you'll have a significant portion of the network discovered, and then you launch a massive DDoS attack with like tens or hundreds of thousands of computers with unlimited bandwidth on all of those existing pairs, then yes, you can certainly affect it. I mean, it would be a super costly tack, and it's very unclear what you would gain from doing it other than to fuck with the network.
00:48:01.770 - 00:48:05.734, Speaker A: And that would just knock it offline for like a little bit.
00:48:05.932 - 00:48:32.538, Speaker B: Yeah, I mean, it would probably knock it offline until everyone can sort of take their nodes down and rekey their identities and get it back up again or something like that. And even like miners might not actually be part of the discovery process. So the question is, you could probably prevent transactions from being propagated, but you probably can't prevent blocks being produced.
00:48:32.634 - 00:48:44.820, Speaker A: Now this is a super extreme case, but say there are glitches or something. Are there times where transactions are sent and they're just actually lost before they hit anything? Are there cases of that?
00:48:46.010 - 00:49:48.918, Speaker C: Oh yeah, sure. Because either you're propagating that to a peer that just goes offline right after it receives the transaction, or your transaction fee is too low to get that transaction propagated over the network. Because when you are choosing a fee, we also have something that is called gas price fee oracle. And we are using transactions that are in the last hundred blocks and we are trying to average the gas price for that. So if you choose too small, if the fee that you choose is too small, your transaction might look okay in your subjective view of the mentor, in your mentor, but then if it's propagated to some other peer, they might drop it because there is way more transactions with higher fees. So it kind of never goes out of your node. So you're trying to propagate it, but.
00:49:49.004 - 00:49:58.554, Speaker A: It'S never accepted what would happen on the side of like, is there a ping back? Are you told that it wasn't propagated? How do you track that?
00:49:58.752 - 00:50:44.646, Speaker C: So if you think that you are paying high enough fee and your transaction is not accepted in the next few blocks, then you probably start to think, yeah, maybe I did something wrong. You can either try to increase the fee or you can try to look in one of those widely known kind of centralized services that allow you to view their mempool. So for instance on Etherscan, or I believe my crypto as well, you can go there and see if the transaction actually got from your nodes to their nodes so it's visible in their memphis. It doesn't guarantee that it's going to be mined, but at least you know that it went through the network and it propagated to some other peers.
00:50:44.838 - 00:50:53.558, Speaker A: But in this case you'd have to search for that transaction, you'd have to check it yourself. There's nothing that comes back and says like oh, your transaction is lost.
00:50:53.734 - 00:51:00.446, Speaker C: Yeah, there is no way to figure that out. So yeah, you have to check it for yourself.
00:51:00.628 - 00:51:16.758, Speaker B: So we've been explaining all this from the perspective of running your own node, but obviously there's other ways to get transactions onto the network, like submitting it through, you just mentioned my crypto, what's the difference there? How does that work?
00:51:16.924 - 00:52:02.370, Speaker C: Yeah, so when you are using some other services to send your transaction, you are actually submitting the signed transaction to someone else's node. So you are kind of bypassing the Ethereum network propagation protocol and you are just going directly to your browser and submitting to someone else node. And this is also a way to propagate that transaction faster. So you don't really need to only rely on Ethereum networking for that. It's sufficient. But if you want to do it faster, you can also look for some other ways to submit your transaction to different parts of the world or different parts of this network?
00:52:02.950 - 00:52:23.290, Speaker B: One could expect that big services like Mycrypto et cetera are reasonably well connected to the miners as well, so that you have maybe a little more security that it gets to the miner. But is there any downside in centralizing this transaction propagation?
00:52:23.790 - 00:52:57.080, Speaker C: Yeah, obviously there is some trust involved, right? If they see that you are trying to submit a transaction that overbids them in some kind of auction for a crypto kitty or whatever, then obviously they can censor your transaction and never propagate it. If you trust them, then sure, if you have multiple services you can also send to all of them, and there is probably a high chance that at least some of them won't censor you.
00:52:57.530 - 00:53:05.734, Speaker B: Is there any performance or scaling bottleneck involved with trying to send all like say everyone sent all their transactions through.
00:53:05.772 - 00:53:43.170, Speaker C: My crypto, obviously, it's like dedosing their service because it's like one centralized server somewhere there in the world. So if everyone starts to send transactions using their service, it will probably go down. And if this is the only way or the only meme you are using to send transactions, you will be cut off the network and won't be able to send more transactions. So it's just like an additional option that you should use. But you should always consider running your own nodes so that your transactions are propagated.
00:53:43.830 - 00:53:50.198, Speaker B: Even if it's just a light node, you have all the security and everything that you could want.
00:53:50.364 - 00:53:55.560, Speaker C: Sure, for sending or propagating your transactions, light node is more than enough.
00:53:56.010 - 00:54:06.650, Speaker A: Maybe just given that this is a blockchain 101 episode, maybe it would be helpful for our listeners to have just a quick kind of recap of what we've covered in this episode.
00:54:07.630 - 00:54:58.486, Speaker C: We were talking about how you can create and propagate transactions over the network and how it happens. So just to recap, when you are creating a transaction, you are signing it locally, you are using a correct nons, which determines the order of the transaction. You can also choose a fee for the transaction, which is gas price pretty much. And this also determines the priority of your transactions compared to other transactions that are in the mempool. Then you are submitting the signed transaction to your local node. That local node is actually taking care of gossiping that transaction around and propagating it to other peers. Those other peers, they have their own subjective view of the mempool.
00:54:58.486 - 00:55:31.480, Speaker C: So what they seen on the network, they verify your transaction, they insert that transaction to the pool, they figure out what's the priority of that transaction and then propagate it further until it gets to the miners. And miners are this kind of like terminal nodes that actually take the transactions from their mempool and they create a block from that transaction. So they actually execute those transactions and propagate the block back. So that's how it happens.
00:55:33.530 - 00:55:49.638, Speaker B: Hopefully people learned something in this episode and were able to follow along. And if you have any questions or thoughts or feedback, please send them to our Twitter or email at zero knowledge FM on Twitter, or hello at zeroknowledge FM.
00:55:49.814 - 00:55:54.138, Speaker A: And we're also going to probably link to Tomax's Twitter. Do you have a Twitter?
00:55:54.234 - 00:55:55.102, Speaker C: Yeah, I do.
00:55:55.236 - 00:56:20.630, Speaker A: Cool. So we'll link to yours in our show notes as well. Maybe quickly we can say thank you again to Christopher from one KX for putting these questions forward, because it definitely helped shape this episode and we really want to encourage our listeners to do that, to send us, if there's topics that you're really into, please send it to us. Send us questions that we can ask on the air with some people that we're interviewing.
00:56:20.970 - 00:56:27.990, Speaker B: And thank you to Thomas very much for being on this show and being patient with our questions and helping to explain this stuff.
00:56:28.060 - 00:56:29.880, Speaker C: Thank you so much for having me.
00:56:30.730 - 00:56:49.950, Speaker A: Oh, one last thing before we go. I just want to say that I may be starting a new band called Anna and the Mempools, if anyone wants to be part part of it. As this episode has gone through, I just realized the name is too good to pass up. Yeah. So that's going to happen. Cool. Okay.
00:56:49.950 - 00:56:55.402, Speaker A: So, to our listeners, thanks again for coming on this journey, and thanks for listening.
00:56:55.466 - 00:56:56.090, Speaker B: Thanks for listening.
