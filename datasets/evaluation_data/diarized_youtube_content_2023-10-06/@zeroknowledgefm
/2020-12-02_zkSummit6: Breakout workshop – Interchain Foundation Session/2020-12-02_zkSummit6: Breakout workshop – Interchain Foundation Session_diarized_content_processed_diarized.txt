00:00:06.970 - 00:01:12.930, Speaker A: I've asked Anya to come and talk about some work that she is doing at NiM. The Interchain foundation also has a grant with you guys to develop this as a general purpose cosmos SDK module. So we're hoping this becomes a piece of public infrastructure that other cosmos chains can deploy. And this is kind of complementary to the work that you're doing at NIM, so it helps. Nim is a state of the art mix network, and it uses tenermint to ensure mixing, quality and service provision. So we thought this kind of paired well with the talk, or rather the workshop that Chris will be giving after Anya's talk. And he's going to be talking about multi chain shielded pools that are based on a zcash circuit design.
00:01:12.930 - 00:02:26.470, Speaker A: And we're hoping to potentially fold in maybe insights from your conversation into Chris's discussion. Chris works at Interchange game Beha here in Germany. He's a colleague of mine, and he's also the co founder of Metastate, which has a focus on cryptography. And notably, Chris is the lead protocol designer of the inter blockchain communication protocol, which ensures the kind of primary feature of IBC is to ensure kind of fault isolation between different chains. And we think this is particularly well suited to developing and deploying new cryptography. So I hope that Chris kind of inflects that and describes how that property can be retained with shielded assets. And for Chris's session, he's going to give a short intro to kind of frame the problem and then open it up for discussion.
00:02:26.470 - 00:02:37.438, Speaker A: So please put your questions in the chat, and I will get rid of my audio and video and hand it off to you, Anya. Thank you.
00:02:37.524 - 00:02:52.140, Speaker B: Great. Thank you so much. Let me now try and share my screen. Give me a second.
00:02:56.990 - 00:03:16.930, Speaker C: It and let me know. I'm also here. I just turned off my video, so people don't just watch, but I'm happy to read questions off the chat. You can read them if you'd like, if you have a second monitor, or Sam, you can feel free to as well. So, again, if you guys need to leverage me at all, I'm right here. I'm just going to turn off my audio.
00:03:17.990 - 00:03:24.020, Speaker B: Sure. Quick question. Can you guys see my presentation? Did the screen share work?
00:03:24.790 - 00:03:25.540, Speaker C: Yes.
00:03:26.230 - 00:03:59.578, Speaker B: Great. Okay, so, hello, everyone. My name is Annie Petrovska. I work as the head of research at NEM Technologies. NEM is a company which is building a decentralized and incentivized communication infrastructure, or network, to give the Internet users privacy. And during today's talk, I will introduce you an outline of two main components that NIM is using. The first one is the Nim mixnet.
00:03:59.578 - 00:05:04.050, Speaker B: The Nim mixnet is used to ensure the network level privacy for the users. The second component, which I'm going to present you is denim credentials, which are the anonymous selective disclosure credentials, which, in very simple words, allow you to anonymously prove that you have a right to access certain service or to use a certain service, and so on. So let's dive into it. So, let's start with the name Mixnet. Why, in general, do we need network level privacy? So, if you're into privacy, you are probably familiar with applications like Signal, Telegram, WhatsApp, maybe protocols like PGP, which you probably use to encrypt your communication. So such applications or protocols like PGP allow for the end to end encryption, which means if you're sending a message or any type of communication, you can protect the content of your communication. So the end to end encryption gives you confidentiality.
00:05:04.050 - 00:05:53.454, Speaker B: Or maybe, for example, you are interested in cryptocurrencies and you want to use them, but you want to use them in more privacy preserving ways. So you might be using Monero zcash, maybe some coin tumblers, maybe the lightning network. So such private coins, or the techniques which enhance the privacy of coins, give you privacy on chain. But both end to end encryption and any on chain privacy techniques, they don't give you privacy at the network level. What it means, if you have the adversary who is observing the flow of the packets in the network, he'll be fully able to de anonymize you. So he will just observe which IP address is sending a message or transaction to each other IP address. And that's how your privacy is broken.
00:05:53.454 - 00:06:50.306, Speaker B: And this is very important because privacy is a bit of like a holistic property. If you have a system, if you're leaking information in one layer of the system, doesn't matter how fancy cryptography or encryption schemes you're using in the other layer of the system, the leakage in one layer will undermine the privacy properties which you're having in different layer. So how can we protect the network level privacy? The NIM is using a mixnet for that. And what is a mixed network? Mixed networks are around already for quite some time. They're pioneered by David Chum. In the mixed network is just a set of cryptographic relays which process and forward the packets. And the traditional mixed networks was just a multi hop network in which the mixed nodes were arranged into a topology to which we refer as a cascade.
00:06:50.306 - 00:07:41.910, Speaker B: So they created, like, a long chain, and the packets were flowing from the first to the second, third, and so on, mixed nodes. So the packets were flowing through the whole cascade. And how the mixed network protects your network level privacy. So when you're sending a packet via the mixed network, it's layer encrypted, or, as we refer to it, also onion encrypted. What it ensures is that if I'm the adversary and I'm observing the flow of the packets in the network, I cannot correlate those packets based on their binary representation, because after each mix node, the binary representation of each packet is changing. So it gives you something to what we refer as bitwise and linkability. So we cannot correlate the packets based on their binary patterns.
00:07:41.910 - 00:08:50.746, Speaker B: But protecting the binary representation or hiding the binary representation of the packets, is not enough to actually give you anonymity at the network level, because the adversary can still perform the timing analysis, which means he can just observe the mixed nodes. And if the mixed nodes are processing the packets at the first in, first out order, what happens is that the adversary can correlate the incoming and outgoing packets. So at the end, although your packets will go via multiple hops, the adversary will be still able, based on the times he observed the packets coming in and out, to correlate who is communicating with whom. And that's why the mixed notes protect against such timing analysis. What happens is that a mixed note, each one of them in the cascade, instead of forwarding the packets at the first in, first out order, what they do is they, instead of batch the packets. So what happens is that a mix node is running, and he is waiting for a certain number of packets to arrive, let's say 1000. So he's waiting for 1000 packets to arrive.
00:08:50.746 - 00:09:48.878, Speaker B: And once he gathered 1000 packets, what he does, he is processing them cryptographically. So he removes this, like, one layer of onion encryption, and then he shuffles them, following a secret permutation, and forwards to the next hop. So what happens right now is that the adversary cannot correlate the packets, neither based on their binary representation, neither based on the timing of the packets. And what the mixed network ensure is that you're anonymous at the network layer, even if the adversary is able to observe all the links between the mixed nodes. Moreover, you're also fully anonymous if all the mixed nodes, except one in the cascade are dishonest. So as long as one mix is honest, you're anonymous. So you might ask why, although the mixed network gives you such a strong anonymity, we actually don't have any mixed networks deployed like how this happened.
00:09:48.878 - 00:10:34.974, Speaker B: So, as it turns out, the early chamber mixed networks had a few very severe limitations. The first one was scalability. As you can probably imagine, the cascade topology doesn't scale good. So the only way to scale your cascade is to make your mix nodes more and more and more powerful, which means for the people who are running the mix node, just pay more for the servers and pay more. So this obviously doesn't really help to deploy the system on a large scale. The second limitation was that the mixed networks imposed very, very high latencies. For those high latencies, there were two reasons to happen.
00:10:34.974 - 00:11:40.126, Speaker B: First one was that the onion encryption scheme used by the traditional mixed networks was using the public key cryptography, which is quite expensive. The second reason why the traditional mixed network had very high latency was that the batch and reorder mixing techniques, which the mixnodes were using, were imposing very high latencies. And you can think about it intuitively, in the sense, let's assume your batch size is 1000, and now the volume of traffic in the mix network is low. What it means is that mixnode will wait a very long time to gather those thousand packets. So automatically your latency at each mix node and then your end to end latency will be much higher. But even if the volume of traffic is large, still your latency, the end to end latency at the mixed network will be also large, because although the packets are coming very quickly, you process the batches one after another. So a lot of packets will be queuing to get into another batch and be processed.
00:11:40.126 - 00:12:45.142, Speaker B: So the high latency made mixed networks completely unusable for any applications which are latency sensitive. And the first limitation of the traditional mixed networks was that the anonymity size offered by the mixed network was limited to the size of the batch in each mix node. So again, if your batch was 1000, it doesn't matter. Even if you had 5 million users using the mixed network, you were anonymous only among those thousand packets with which your packet was mixed in the batch. And also, as research showed, the traditional mix network were vulnerable to the traffic confirmation attacks and to active attacks. The traffic confirmation attacks are those attacks which some of you might know from Tor, when the adversary is controlling or observing the entry and exit node, and he can observe the sending and receiving patterns of the users, and based on that, he can correlate the flows. So how Nim is fixing those problems? Let's start with this collabability issue.
00:12:45.142 - 00:13:42.022, Speaker B: So instead of using the cascade topology Nim is using this stratified topology. A stratified topology is a topology in mix node, in which mix nodes are grouped into layers. And each mix node from one layer, the first one is connected with each mix node in the second layer, and then each mix node in the second layer is connected with each mix node in the third layer, and so on. So the traffic is flowing always from the first to the last layer. And the advantage of this topology is that it scales horizontally, meaning, by adding more and more nodes, you can increase the overall capacity of the network. And obviously, when you're building an anonymous communication network, you want your network to scale, because anonymity loves companies, so the more users you can support, the better. And actually, the stratified topology was shown to be optimal for scalability and anonymity.
00:13:42.022 - 00:14:32.310, Speaker B: So, out of all the possible topologies which you can consider, like cascades or multicascades or peer to peer, the stratified topology is the best. And the packets in them are source routed, meaning that the sender picks the path which the packet should take, and the sender does that by picking randomly one mix from each layer. So that's how he composes the path. Okay, so, once we cover the scalability issue, let's look into the latency, and that's much more complicated problem. Now, we have here two things. First of all is the onion encryption, and how can we make it a bit faster? And the other is the latency, which is imposed by the batch and reorder mixing technique. So, at Nim for onion encryption, we use the Sphinx cryptographic packet format.
00:14:32.310 - 00:15:41.630, Speaker B: Some of you might know it from, for example, the lightning network. It's a provably secure cryptographic packet format, which not only ensures that the packets are bitwise unlinkable, and they're the same size all the time, it's also very compact and very computationally efficient, which means the processing or creating of the packets is much faster than it used to be in the traditional mixed networks. And on top of that, sphinx also gives you a few properties which are very important. Like, for example, it gives you resistance to tagging attacks and replay attacks. So these are attacks in which the adversary tried to, for example, tag a packet to be able to trace it later in the network, or tries to enforce the user to send multiple times exactly the same packet to try to increase his chances to de anonymize the users or de anonymize where is he sending. And another important property of sphinx is that the intermediate nodes which are processing the packet learn only the predecessor and the successor. So they only learn from whom they receive this packet and to whom they have to send.
00:15:41.630 - 00:16:33.774, Speaker B: But they're not learning any other information about the path or about the sender and receiver. So that's the first part. We've made a choice to use sphinx to make the cryptographic operations much more efficient and in such a way that they don't impact negatively the overall latency in the system. But what about the mixing technique? So, I told you that the patch and reorder mixing technique had this problem, that the end to end latency was unbounded. The user had no control over how long it will take for his packets to get to the destination. So that's why name is something what we refer to as continuous time mixes and what it means. It's simply that instead of batching the packets together, each mix delays each packet independently before forwarding it.
00:16:33.774 - 00:17:22.900, Speaker B: So how it works is that if I'm the sender and I want to send a packet for each mix in the path which I selected, I also pick a random delay. And this delay is drawn from the exponential distribution. And once I've picked those delays, I put them inside the sphinx packet format so that when the mixnode receives a packet and strips one layer of encryption, he can see the delay, so he knows how long he should keep the packet before forwarding it. And using such mixing technique has two important properties. First of all, because the sender is picking the delays, I, as a sender, can estimate the end to end latency of my packet. So I know how long it should take my packet to go through a network, assuming that there is no congestion. Right.
00:17:22.900 - 00:18:17.330, Speaker B: Another advantage is that because I control the delays which I pick, I can adjust the end to end latency which I would like to achieve depending on the application for which I'm using the name mixet. And how it works is that there's a bit of math behind that, but it's very simple. The average delay which the exponential distribution will give you is determined by the mean parameter of the exponential distribution. So you can tune up and down, depending on your application or service, this mean parameter. So either your delays, which you're picking still randomly, will be lower or will be higher, but it gives the senders the control to really control the end to eight latency. And because of that, the Nimixet can support applications or services with very different latency constraints. Okay, so we covered this scalability.
00:18:17.330 - 00:18:58.880, Speaker B: We covered the high latency. Let's look a bit closer into the anonymity. So I told you that in the traditional Chowman mixnets, your anonymity is limited by the size of the batch which the mixnode is using. So how do we solve that problem at nim? Well, it also boils down to the mixing technique. I told you that when the sender picks the random delays, he's using the exponential distribution, and we pick this distribution for a reason. The exponential distribution is actually the only continuous distribution which has a property called memorial lessness. What it means, it means that the past has no bearing on the future.
00:18:58.880 - 00:20:12.162, Speaker B: So, in simple words, imagine that packets are arriving into the mix node and you're the adversary, and you observed, let's say, 10,000 packets arriving to the mix node, and now one packet is leaving. What happens here is that from the perspective of the adversary observing the mix node, this packet, which is just exiting the mix node with equal probability, can be any of the packets which arrive to the mixed node. So the ones which he observed arriving to the mix node. This is because the time at which the packet will leave the mixed node, from the perspective of the adversary, is completely independent on the time when the adversary observed this packet arriving. So what it gives us, it ultimately tells us that your anonymity set is not anymore bounded by the size of the batch. Your anonymity set can be much, much larger, because now each packet coming into the mix node contributes to the anonymity of your packets. And this is very important, because what our study shows is that while in the traditional cascades, the size of the batch was determining your anonymity.
00:20:12.162 - 00:21:22.538, Speaker B: And it doesn't matter how many users are using this mixed network, at NIM, it's different. The more users are using the mixed network, the better the privacy properties. So you can see it on this simple plot, which I did, you can see that while the number of users is growing up, the anonymity in the name mixnet is also going up, whereas in the cascade topology, which is using the patch and reorder technique, it remained all the time constant, and there is nothing you can do about that. And the last limitation which the chami and Mixnet had was that they're vulnerable to traffic confirmation attacks and active attacks. And this is quite a serious problem, because users tend to have very distinctive behaviors and sending or receiving patterns. So based on that, the adversary would be able very quickly to de anonymize the user. So how do we protect against that? Imagine the adversary who observes the entry and exit points of the mix network, and he sees a sudden burst of packets from Alice and at the same time, suddenly Bob starts to receive many more packets.
00:21:22.538 - 00:22:05.738, Speaker B: Probably you can correlate that Alice and Bob are communicating. So in order to protect against that, the Nim client uses something, what we refer to as Poisson process to schedule packets to send. In a nutshell, how it works is if I want to send a message, and I click on my application, the button, send the name client. Instead of immediately sending this packet, it adds it into a buffer. It's an internal buffer which works like a queue for the packets which are scheduled to be sent. And in the backward round, there is a Poisson process running which from time to time checks this buffer. If in the buffer there is a real message to be sent, it just grabs this message and sends it.
00:22:05.738 - 00:23:01.710, Speaker B: But if there is no message to be sent, the nel client sends something, what we refer to as a loop cover packet. A loop cover packet is a packet which is indistinguishable from real messages. It's a packet which goes through the mixed network and as destination, has your own address. So it's like a loop which is coming to you. What it gives you is that if the users have very distinctive patterns of actually communicating and sending and their behavior once they submit their messages to the NEM client, from the perspective of the adversary, they all behave the same. So as long as the user is online or his NEM client is online, the adversary is not able to infer any information about your behavior, because the only thing which he observes is that you're sending some packets, but he can't tell whether you're actually communicating. Or are those only cover packets.
00:23:01.710 - 00:24:18.470, Speaker B: And the other properties of those loop packets is that it not only hides your sending pattern, but because those loop packets are coming back to you, you're actually also hiding your receiving patterns. So we're obfuscating the sending and receiving patterns, so we're making the traffic confirmation attacks much more challenging to the adversary. But on top of that, the loop cover traffic also allows to detect the active attacks, both for clients and mixes. Active attacks are attacks in which the adversary controls some nodes and is trying to, for example, drop or delay your packets, or he's trying to inject more packets, all these type of active attacks, which would allow him to increase his chances to de anonymize you. And such loop cover traffic allows to detect them. And we actually use this loop cover traffic to measure the quality of service provided by the mixed nodes in the network. And we later use that for our proof of mixing, which is a scheme which we use to not only detect the misbehaving nodes and kick them out of the network, but also to reward the mixed nodes which are doing a good job in processing the user's traffic.
00:24:18.470 - 00:25:23.286, Speaker B: So here you have a quick comparison between the Nim mixnet and other anonymous communication systems. And as you can see, the Nim mixnet is currently the only system which provides you both scalability, strong anonymity properties, support for application of both high and low latencies. But in addition, it also gives you incentives. So while for example, Tor is fully based on volunteers running the nodes, the NIM approach gives rewards to the operators of the mix nodes. And we also use the decentralized PKI, which is in contrast to the previous designs which had centralized approach towards that. Our decentralized PKI is in a blockchain and as was mentioned, we are building this using tendermint. So let's now look into the NiM credentials because the Nimmixnet gives you the network level privacy and this is great and this really boosts your privacy overall.
00:25:23.286 - 00:26:23.760, Speaker B: But imagine you want to use your Nimmixnet to, let's say, read your favorite magazines at New York Times, right? Probably to read them, you need a membership. Now, if you use the Nimmix network to access the service provider, which gives you access to the New York Times articles, and then you show the membership which identifies you, probably that's not what you wanted to have. So you'd like to have a way to somehow prove that you have a certain membership or that you're over 18, or some other information about you. That you have some rights to use a certain service in a way that does not allow the service provider to identify you. And this is when the new credentials come. The new credentials are based on the coconut scheme. But before I will tell you about the properties of the coconut scheme, let me give you a little bit of a background of what the selective disclosure credentials are.
00:26:23.760 - 00:26:55.110, Speaker B: The idea behind this is very simple. Imagine that you would like to go to a bar and you would like to have a drink. You obviously have to prove that you're over 18. So what you need is that you go to the issuing authority and you would like the issuing authority to issue you a credential. A credential might be a passport. And in this passport you have multiple attributes like your date of birth, your nationality, your name, your surname and so on and so on. The issuing authority issues you such credential.
00:26:55.110 - 00:28:06.938, Speaker B: And now you go to the bar or you go to any website in which you have to prove that you're over 18, and you're showing this credential to prove that you can have a drink, or that you have a certain membership, or you have certain access, the verifier can verify your credential to confirm that indeed you are over 18, or maybe you have access to a certain service, and so on. So the basic properties of selected disclosure credentials are two. First one is the verifier is always convinced that the credential is valid. So the proverb cannot forge a valid credential. And the second property is that even if the issuing authority and the verifier are colluding, so they are both malicious and they are cooperating with each other, they still cannot learn anything more than just the information which you disclosed. So whatever the prover is showing to the verifier, that's the only thing which the verifier is learning. Okay, so the selective disclosure credentials, there are different schemes, but they have a few limitations.
00:28:06.938 - 00:29:33.046, Speaker B: The first main limitation among all of them is that they rely on the centralized issuer, which means there's only one issuing authority, which is a problem, because a malicious one can just forge a lot of credentials, which then can be used, although he shouldn't do that. The second problem or question, is that not all of the selective disclosure credentials allow you to issue credential on private attributes without learning the value. So usually you have to go to the issuing authority and show exactly the attributes on which you would like to have credentials, and you cannot blind them in any way. And the third problem is that we would like to ensure that if I have a credential and I show it multiple times, so, for example, I access the New York Times service provider multiple times, I would like to make sure that the verifier is not able to link those different showings, that they come from the same person. And this is where the coconut credentials, and hence the NiM credentials, come. So the NiM credentials have a few properties, the blindness, the unlinkability threshold, authorities, non interactivity and efficiency. So what it means, first of all, the blindness means that you can ask for a credential on a private attribute, which means the issuing authorities can issue you a credential without learning on what attributes they're actually signing.
00:29:33.046 - 00:30:14.418, Speaker B: The credential. The unlinkability ensures that even if you have a credential, which you show over and over again, those showings cannot be linked between each other. The big thing of the name credentials is that we have the threshold authorities, which means there is no more centralized authorities. Instead of that we have a set of them and only a subset of them has to be honest and cooperative to issue you a valid credential. Each one of them can issue a partial credential and then you can aggregate it into one big credential. Also, the authorities don't have to interact with each other. They can issue the partial credentials completely independently.
00:30:14.418 - 00:31:25.070, Speaker B: And importantly, the NIM credentials are very efficient, which is important, especially the verification is very fast. And what makes the NIM credentials so good is that they can be used by platforms which support smart contracts because the threshold issuance allows issuing credentials through smart contract. So how those two combine is that if I want to access a service and I'm using the NiM network, not only I protect my network level anonymity by forwarding my communication via the mixnet, but also the service provider doesn't really learn my identity. So I can anonymously access services and be anonymous vis a vis the service provider, but also any global network adversary. So if you would like to learn about NEM, we have the very detailed documentation which also can help you spin your own mixnode. Our code is open source, so you can go check it out. If you would like to know more details about things which I was talking here on medium, we have a lot of blog posts covering that, even more in detail.
00:31:25.070 - 00:31:33.250, Speaker B: So check it out and if you have questions, you can always send me an email and I'm happy to answer it. And I think I just run out of time.
00:31:33.400 - 00:31:47.560, Speaker C: Thank you very much, India. Really interesting talk. Thank you for sharing. And now I think we have up to the plate Christopher, who's going to be presenting. Christopher, if you can hear this, over to you.
00:31:48.570 - 00:31:50.120, Speaker D: Hi there, can you hear me?
00:31:55.210 - 00:31:56.310, Speaker C: Yes, we can hear you.
00:31:56.380 - 00:32:25.540, Speaker D: Awesome. Never quite sure. All right, let me see if I can share this. So I will give a quick overview of the problem and then my hope is to have this be a somewhat interactive workshop that may or may not be a success, but we'll try. I have an online whiteboard tool which I can share with people so we can work together on the whiteboard to brainstorm solutions to this problem. But first, let me just give a quick overview. Let's see.
00:32:25.540 - 00:32:54.102, Speaker D: Let's do it this way. Cool. Can you see? I realize it's not the presentation view, but I don't think I could find a way to do that. You can at least see the slides. Yes. Awesome. So I'm going to talk about fault isolation and privacy in crosschain shielded transfers, which are two desiderata that happen to be slightly at ODS.
00:32:54.102 - 00:33:38.454, Speaker D: And my hope is that in this workshop, we can brainstorm some ways to potentially make them a little bit less at ODS. So a very basic overview of the problem is that we want to design for a multi chain ecosystem where there are lots of different chains, and many of them have different privacy features. Those privacy features might be based on sapling circuit like Zcash, and that's the model I'm most familiar with. But they might also be based on something like the coconut anonymous credential scheme, which Anya just talked about. And my hope is maybe we can, in this workshop, figure out whether those might even be able to work together. But right now we have multi chain ecosystem with lots of bridges, but only single chain shielded pools. So maybe there's a coconut credential scheme running on one chain, or there's sapling on zcash.
00:33:38.454 - 00:34:54.798, Speaker D: Or maybe the sapling circuit is being added to tezos in an upcoming protocol upgrade. Potentially different blockchains in the cosmos ecosystem will adopt privacy features. But all of these privacy features right now only exist on one chain. And that means that when you transfer over a bridge, if this is regardless of whether this is a bridge constructed using ICMP or IBC or some sort of trust approved authority you are losing currently, then the advantage of these bridges, or the advantage of having completely transparent bridges, is that they can provide fault isolation by tracking the supply. And that fault isolation requires that the supply tracking be done in public, which means that these need to be unshielded transfers. So my question, or the question I want to brainstorm in this workshop, is can we get some measure of both of privacy? So, can we combine somehow the anonymity sets, or partially combine the anonymity sets from multiple chains, so that instead of having a lot of little anonymity sets split all across the multichain ecosystem, we can have some. One larger one, or at least some partially combined ones, while still preserving this extremely important fault isolation.
00:34:54.798 - 00:35:38.558, Speaker D: Because usually here we're talking about different chains with different consensus algorithms, different proof of stake tokens, different validator sets, different security models, and they don't want to be exposed to each other's consensus fault risk. So I'll get into why those are at ods in just a second. But I also want to note that this is separate for now from the problem of network privacy. So anya just gave a presentation on the Nimmixnet. Network privacy is also absolutely integral. Luckily, it is pretty much orthogonal, and it's probably much easier to combine network privacy for different blockchains than it is to combine the shield pools. Although maybe I don't want to make that statement in high confidence because I do not work on mixed stats, but hopefully it's easy.
00:35:38.558 - 00:36:50.658, Speaker D: So what I want to work with for this workshop is a pretty abstract model of what a shielded pool is, so that we don't need to get into the nitty gritty of the particulars of these zero knowledge circuits or even anonymous credential schemes, because I don't think it is all that relevant to the problem except in the abstract model of what we can and cannot do. So when I say shielded pool, I'm talking about a pool of tokens that have been shielded using. You can think of it using like a sapling style circuit, or using an anonymous credential scheme such that when someone is looking at the public chain, the owner of those tokens is unknown. Transfers within the shielded pool are indistinguishable from each other, except that they're going to this particular shielded pool, and that they came in at some timestamp or something like this. If a single chain has a single shielded pool, there will be some supply in what's called the unshielded pool, and some supply in the shielded pool. And although you don't know the particular balances users have in the shielded pool, you can subtract if you know the total supply, just subtract the balance of the unshielded pool from the total supply and you'll know what the total size of the shielded pool is. So here we're kind of talking very roughly.
00:36:50.658 - 00:37:53.830, Speaker D: You could say that the anonymity set is proportional both to the size of the shielded pool and to the frequency of shielded transfers. How many times per block are people sending transfers to the shielded pool? And you can't distinguish them other than they are a shielded transfer operating on this particular pool. Now, depending on what kind of analysis you're interested in, depending against whether the adversary, whether you assume that the adversary has access to network level data about transactions, or has partial access to the transaction graph, and maybe could eliminate transactions from the subject trying to search, you may have more specific statistical criteria, but here we're just working at this high level. So the basics of a bridge in this abstract model are that it's a way for two trains to transfer tokens between each other. By default, these bridges are public, meaning that supply is tracked at both ends. For example, this is what's implemented in the ICS 20 standard and IBC. And I believe that ICMP has a close equivalent this public token tracking means that supply inflation is preventable.
00:37:53.830 - 00:38:58.526, Speaker D: What do I mean by supply inflation? I mean that when my chain, let's call it Chris chain, sends tokens to another chain, let's call it Anya chain. Sorry for including you involuntarily in all these examples, but figure it's polite since you're with the prior presenter and you have a different privacy technology, which is awesome. So if I send tokens from Chris chain to Anya chain, then I can track how many tokens I've sent when they leave my unshielded pool, because that amount is public, and I can ensure that no more than that number of tokens ever comes back. That's what I mean by preventing supply inflation. So even if Anya chain has some kind of consensus fault, the worst that can happen is that the people who transfer their tokens to Anya chain will get them stolen. But supply inflation for crisp token is prevented because I simply block transfers past the tracked amount of supply that originally went out. Of course, however, this means in order to do the supply tracking, that tokens must be unshielded when they are sent over the bridge, which means that the two shielded pools operate in complete separation, as if they were two different blockchains with no bridge between them at all.
00:38:58.526 - 00:39:57.534, Speaker D: You could transfer tokens between them through the unshielded pools, but you don't get any additional privacy. So what we want is to find some way to combine anonymity sets from both chains in ways that increase privacy or some degree of privacy for users, but preserve some modicum of fault isolation, which is very important. Then I will share the sort of two easy approaches, and then some advanced approaches I've thought of so far, and then I want to see if we can brainstorm anything else, or brainstorm how in particular this might work with anonymous credentials, because I haven't thought too much about that yet. So the default approach, which is sort of what is currently going to happen if no one does anything in particular to solve this problem, is that transfers will happen over unshielded bridges, which provides full fault isolation because the supply can be tracked but provides no increased privacy. So that's what will happen at the moment in the first version of IBC, as far as I know. Same thing for Polkadot. Even if there are shielded pools on all these different blockchains, they're going to be completely separate.
00:39:57.534 - 00:40:35.678, Speaker D: Then another possible approach. I don't know if anyone's pursuing this, but it would be possible to completely combine the shielded pools in a sort of naive fashion where you ignore consensus assault risk. So then you can combine by combining the node sets and nullifier sets, et cetera. So then you can run shielded transfers over the bridges, but you don't get fault isolation. And there are some other slight difficulties, but this is at least possible, you just give up fault isolation. So an advanced approach, and I'll pull up a diagram to explain this. Alistair says we'll be doing combined shield pool as soon as possible.
00:40:35.678 - 00:40:43.362, Speaker D: Do you want to join, Alistair? Maybe you have more up to date information than I do. I don't know if you can click.
00:40:43.416 - 00:41:02.840, Speaker C: Like, hey, so Alistair, if you're in here, you should be able to just share. Okay, yeah, and I actually think we might have. Oh wait, Alistair says he's going to wait and listen, and in the meantime I think I have to increase the number of participants. So you go ahead, Christopher, and then if Al wants to come up, let me fix that and make sure that's possible.
00:41:03.530 - 00:41:46.030, Speaker D: Gotcha. Okay, so more advanced approaches. One advanced approach. So the key restriction here is that in order to enable shielded transfers over some of these bridges, when we enable shielded transfers, we no longer have access, of course, to the balance transferred in each cross chain transfer because it's shielded. So what we can do is that we could change the circuit, right? So we can require that maybe the balance goes somewhere else first before it just gets released into the shielded pool in the second chain. And maybe the user has to submit an additional proof of something. What we cannot do, at least not just with ckps, is encrypted supply tracking.
00:41:46.030 - 00:42:41.798, Speaker D: So if we had some kind of fully homomorphic encryption, then maybe we would have to do this in the circuit. So it's probably going to be incredibly inefficient, but at least in principle, we could require that the user encrypt their balance, encrypt the balance of the transaction, and then add that homomorphically to some tracked counter. And somehow some check needs to be performed over this encrypted value that it doesn't exceed that the amount transferred back in over some bridge doesn't exceed the amount transferred back up. I am not familiar enough with fully homomorphic encryption to know exactly how that would be implemented, but it's certainly you can't do that just with ckps because you need to be keeping this encrypted counter. But one thing you can do with just ckps is create a sort of temporary purgatory. And this is the best solution I've thought of so far. So I'm hoping we can come up with something better.
00:42:41.798 - 00:43:30.226, Speaker D: But it is perhaps a nice point in the trade off space between the two extremes. So a temporary purgatory means that you basically create what I'm calling this purgatory. And I'll pull up a diagram in a second, which will probably make it more obvious. But what I'm calling this purgatory is a place where once tokens are transferred over a shielded bridge, they will sit temporarily. And in this purgatory, instead of when you transfer tokens over a shielded bridge, you'll provide a zero knowledge proof that you had the Utxos to spend on one end, and you'll send them over the bridge. That proof will be verified on the other side of the bridge, but then that new note will not immediately go to the regular shielded pool on the second chain. Instead, it will go to this purgatory.
00:43:30.226 - 00:44:41.974, Speaker D: And this purgatory basically means that it will be locked for some period of time. And that period of time could even be dependent on the value of the note, because this proof can be done in the circuit. So just for simplicity's sake, say that it will be locked for a day, and during that day, you can't transfer it to the second shield pool. So in order to transfer it to the second shielded pool, you need to provide a proof and zero knowledge that some amount of time has elapsed since you created this note. Because the timestamp is public, so they're included in the public input, and that proof won't be able to succeed until a day has passed. So for this day, this new note is locked in this purgatory and no one can see what amount it is. But if there's some kind of consensus fault, let's say it's discovered that the other chain which sent this zero knowledge transfer had a fork, then someone can provide a proof of that fork in regular clear text, using some light client verification algorithm to the chain which received this note, and that this purgatory can sort of be locked such that some state variable would be changed on that chain and then all attempts to transfer from purgatory to the regular shielded pool would fail.
00:44:41.974 - 00:45:54.562, Speaker D: So you can think of this purgatory as like this temporary shielded pool with an additional requirement that tokens are locked in it for some period of time. And this doesn't give you supply tracking, but it does give you the ability to deal with to prevent supply inflation caused by BFT consensus faults which are detected within a bounded period of time. So this may make particular sense for bridges like IBC and ICMP, which have the ability to detect faults and handle them in some fashion. Now, this doesn't specify anything about if you have a fork. What do you actually do with these tokens in the purgatory? How do users potentially recover them? That is out of the scope of this kind of design. But at least in the happy path you end up with, the statistical analysis becomes more complicated because it's not exactly the same shielded pool, but at least after the delay period, they could be transferred to the shielded pool, and you never needed to unshield them along the way, if that makes sense. So I want to pull up a whiteboard here because I think spatial view will help.
00:45:54.562 - 00:46:27.360, Speaker D: And theoretically, this whiteboard is one that I can share. So I'm going to paste this link, but I'll also screen share, and if you could open the link, you should be able to stop. Okay, I'm going to switch my tab. All right. Can you see this? Hopefully, yes.
00:46:29.090 - 00:46:30.320, Speaker C: We can see it.
00:46:32.210 - 00:46:35.140, Speaker D: Awesome. Can you read the text? Is it zoomed in enough?
00:46:35.750 - 00:46:42.242, Speaker C: I can't really read when you're screen sharing it, but I clicked on the link. There you go. That's a little bit better for me.
00:46:42.296 - 00:47:00.290, Speaker D: Gotcha. Thank you. Okay, this is my experimenting with live whiteboards. So here is a spatial rendering of what the simple bridge looks like. We have Jane A on the left here, spa. That's shielded pool a, USPA unshielded pool a. The unshielded bridge between the unshielded pools.
00:47:00.290 - 00:47:16.110, Speaker D: Jane B, with its own unshielded pool and shielded pool. Does that make sense to people? These sort of logical divisions of shielded and unshielded pools make sense? I'll take that as a yes. I can't see anybody.
00:47:16.180 - 00:47:17.950, Speaker C: Yeah, you're getting yeses in the chat.
00:47:18.690 - 00:47:56.714, Speaker D: Awesome. So if we then implement this kind of. I can see people's Cursors. That's pretty cool. Okay, so if we implement this kind of more complex purgatory, then what we're going to have here is got the shielded pool, got the unshielded pool, we've got the purgatory. This is chain a. Purgatory on a.
00:47:56.714 - 00:48:34.120, Speaker D: This is the shielded pool on a. This is the unshielded pool on a, which is no longer going to be involved in the bridge. Then we've got chain b over here. We've got purgatory on b, we've got the. Yeah, someone's helping me out. That's awesome. Shielded pool on b, and we've got the unshielded pool on, uh.
00:48:34.120 - 00:48:44.442, Speaker D: Oh, man. You already know how to draw these arrows, whoever the purple cursor is. Cool.
00:48:44.496 - 00:48:47.660, Speaker C: Chris, is this a plant? Did you put a plant in.
00:48:48.990 - 00:49:21.398, Speaker D: No. No. I thought my PowerPoint presentation would be so confusing that I would need to pull up a whiteboard, but clearly someone has already figured it out. Maybe they just solved the problem years ago and I'm already behind the times, but, yes, that is exactly correct. So, except that these arrows should not be going from. You drew them to the right place, but not from the right place. So these arrows should be going from the shielded pools, because in this bridge, we don't actually need to touch the unshielded tokens at all.
00:49:21.398 - 00:50:00.226, Speaker D: So let me just straighten these out a little bit. So if we think about what's going on here, when you send a. We'll call this the purgatory bridge. So when you send a transfer over the purgatory bridge, you're providing a proof that you've removed the note from one shielded pool. So one shielded pool on chain a, and then you transfer it to this purgatory on chain b. And after some delay period, you can transfer from the purgatory on chain b to the shielded pool on chain b. Just write delay, then.
00:50:00.226 - 00:50:46.402, Speaker D: The same holds true for transfers in the reverse direction. So you can create a proof that you've spent some note in the shield of pool on b, send it over the purgatory bridge. You'll get a temporary note in the purgatory on a, and then after some delay period, you can spend that temporary note in the purgatory on a, and get a regular note in the shielded pool on a. So you could go all the way around and keep your token shielded. You can see my cursor circling counterclockwise here in the direction I do the arrows. Although you will need to tolerate this delay in transferring from the purgatory to the shielded pool on both chains. So then let me just copy all this stuff.
00:50:46.402 - 00:51:31.650, Speaker D: Let's say a fork happens. What do we do? So let's say we have tokens coming into the purgatory. We're just going to look at one side here. So on chain b, we discover that there's some fork, and at that point in time, we have, like. So we don't know exactly what the balance of spiritory is, but we know, like, abstractly, it's some n tokens. So when we have a fork on chain a, then that proof of fork gets submitted to. Submitted to some light client.
00:51:31.650 - 00:52:18.990, Speaker D: And what we do is we draw a. I don't know quite do this. Well, we get rid of this arrow, so we block the transfer from the purgatory on b to the regular shielded pool on b. Color that red. And that means that these end tokens are locked. So if there was some fork, then as long as we get the fork proof within a bounded period of time, it can't be used to mint tokens. Or it can, but they will never get out of the purgatory.
00:52:18.990 - 00:52:48.730, Speaker D: Does that make sense? Yeah. Cool. Do you want to chime in? Anya? Does this abstract model also make sense for shielded tokens, or whatever you call them, when created by anonymous credentials? Would you have the same logical separation of shielded and unshielded pools?
00:52:50.510 - 00:53:02.320, Speaker B: Yeah, I mean, it makes sense. I think that would be quite similar, although I'm not really familiar with this topic, so I can't say for sure, but it actually makes a logical. So.
00:53:05.650 - 00:53:15.010, Speaker D: Cool. Sam, you said, seems like the end game with this approach is something like a cross chain mixture that does periodic swaps. Do you want to expand on that? Curious.
00:53:15.830 - 00:53:41.340, Speaker A: Sure, I can expand too much. But if you're considering many chains, then maybe you would want to have a daily or an hourly kind of transfer that had a regular amount or something. You end up with this kind of multichain mixing service that you enter into.
00:53:44.030 - 00:54:03.826, Speaker D: Do you mean like automatically transferring tokens between the shielded pool just to increase the anonymity set? Exactly. So maybe if there's. It seems like that's a public good, which would need to be subsidized somehow, for sure. Like, individuals might not want to do.
00:54:03.848 - 00:54:09.010, Speaker B: That, but sounds ended as a good approach.
00:54:11.990 - 00:55:07.640, Speaker D: Right? So I guess one question I have is this purgatory approach doesn't provide supply accounting, so it can only deal with explicitly detected forks. And it introduces kind of bad ux because users have to wait. You can make that at least dependent on the amount. So you can have the amount. It's encrypted, it's private, but you can require that when some note is transferred from the purgatory to the regular shielded pool, that someone proves that if their amount is less than five an hour is elapsed, or if their amount is more than 500 a day has elapsed, something like that, that works, but it's still a delay in user experience. Am I missing some way in which you could track supply without really fancy cryptography, or is it just. Yeah.
00:55:07.640 - 00:55:17.926, Speaker D: Dara, do you want to chime in here? That's possible. Sounds like you've done something similar.
00:55:18.028 - 00:55:44.014, Speaker C: Just quick note, Chris. So there's like a little bit of a lag. And Alistair said he can join too. If you stop sharing, I think you have to. I tried to update the settings, but I don't think I can do it while it's ongoing. So if you stop sharing your screen, I think if Aldera wants to raise their hand or just share, then I can let them in as a moderator and then they can chime, have just a note. We only have a couple minutes, and so we'll probably make this the conclusion.
00:55:44.062 - 00:55:46.290, Speaker D: Here, I got you.
00:55:46.360 - 00:55:47.620, Speaker C: Hopefully this works.
00:55:49.750 - 00:55:52.740, Speaker D: I stopped screen sharing, I think. Okay.
00:55:56.250 - 00:55:56.934, Speaker C: All right, cool.
00:55:56.972 - 00:55:57.586, Speaker D: Oh, sweet.
00:55:57.618 - 00:55:58.438, Speaker C: It did work.
00:55:58.604 - 00:55:59.800, Speaker D: Hey, awesome.
00:56:03.370 - 00:56:07.610, Speaker C: So maybe restate the question that you wanted Alistair to address, Chris.
00:56:08.510 - 00:56:38.180, Speaker E: So the first thing I was saying is if you're forced to use unshielded amounts, people can still split the amount they're trying to send and get some privacy, but you still know the amount that's being gone over. So one solution you might consider is to let's reveal to one person, like the validate, who is slashable, my amount, and have them do something crazy. And then if I combine that with splitting, I don't have to trust any one person.
00:56:44.810 - 00:56:47.830, Speaker D: So you would, like, encrypt your amount to a single validator.
00:56:49.050 - 00:57:06.220, Speaker E: So we have been supervising Fatima, a master student who's trying to do a collateralized bridge shielded, which is also impossible. And we think of doing things like that.
00:57:09.070 - 00:57:16.000, Speaker D: But how does the validator, does the validator submit a secondary proof or they're just slashable if they fail to perform.
00:57:16.450 - 00:57:22.020, Speaker E: They just be slashable checks, like more than the amount if something happened.
00:57:25.110 - 00:57:50.826, Speaker D: I see. But how do they provide supply other than to the chain? Or how would they provide, like, let's say the validator doesn't allows you to double spend because you paid them on the side. If I'm understanding this model correctly, if you encrypted your amount to just them, would they have to publish the amount to the chain in order to, or would someone have to something about the.
00:57:50.848 - 00:57:56.134, Speaker E: Amount, like they did have enough collateral to cover it. They were slashing.
00:57:56.262 - 00:57:58.662, Speaker D: I see. And you know their amount. So you get a bound.
00:57:58.726 - 00:58:07.840, Speaker E: So they'd be a bound, but then you'd split it. If you have lots, you'd have to split it. If you have lots, you should split it and then no one would.
00:58:12.930 - 00:58:35.862, Speaker C: So with that, I got to actually, sorry, Chris, I got to cut you off there because we're out of time for the session. That said, you can create your own session. That's actually possible too, if you go to the sessions tab. If anybody wants to follow up on this discussion, you can either go point to point video chat, or you can create your own session and you guys can continue. But we got the next session coming up. CKV, folks. But thanks, everyone, for watching.
00:58:35.862 - 00:58:41.080, Speaker C: Thank you, Chris. Thank you, Anya. Thank you, Sam. And hopefully we'll see you around the event.
00:58:42.250 - 00:58:43.046, Speaker D: Thanks.
00:58:43.228 - 00:58:43.890, Speaker B: Take care. Bye.
