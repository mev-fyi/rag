00:00:04.810 - 00:00:39.762, Speaker A: Good. Wonderful. Cool, great. So, hi, everyone. I'm Zach. I'm the CTO of Aztec. And what we focus on is building privacy preserving technologies on public blockchains, specifically Ethereum, with an end goal of enabling cheap, efficient private transactions and to provide very expressive anonymity for users so that you can have private wallets and also eventually, which is the subject of stalk privilege and preserving DeFi protocols.
00:00:39.762 - 00:02:22.060, Speaker A: And so I just want to talk a little bit about the mechanics of how such a system can work on a platform like Ethereum, which by its very nature has to be at some level quite transparent in order to verify the correctness of transactions. Being a bit slow, I just like to open by just explaining what exactly are private transactions? What do I mean by that? How do they work? What are the mechanics of them? Because it's not quite as simple as just encrypting user data, because there are kind of three types of privacy, which this was actually originally Anna Coin, I was talking with her about a year ago. And that's data privacy, user privacy and code privacy, where data privacy is, the actual values of transacting on a blockchain are hidden, so people know who you are, but they don't know how much you're sending around. Then you obviously have user privacy, where the actual user identities are anonymous on top of this. So you don't know who the ascendant recipient of a cryptocurrency transaction are, and you don't know the values contain, like being transferred or even ideally, the asset itself. And the final kind of ideal goal of what we're building towards is code privacy, where you have a very feature rich programmable ecosystem like you do on Ethereum with smart contracts, except that those contracts are by their very nature private, so that users, when you transact with the blockchain, people can't see, even see, they can't just see who you are, but they can't even see the address of the smart contract you're transacting with. And that gives you a very strong anonymity set, because effectively all your transactions are kind of pulled together in this encrypted anonymous pool with everybody else.
00:02:22.060 - 00:03:46.930, Speaker A: However, if you want private transactions, there need to be some modifications from a traditional transaction because of some of these anonymity requirements. Specifically, a private transfer can't produce any kind of paper trail or leak some information, which allows you to build up a transaction graph. And so your transfers and transactions can't produce linkable database updates. So even things like Ethereum's account based model is extremely difficult to implement in a privacy preserving manner without compromises on user privacy, because just their act of updating somebody's balance, even if that balance is encrypted, is going to leak some information. So the way that we're doing it, and the way which is commonly done so for example, zcash is doing it this way too, is by using bitcoin's concept of an unspent transaction object. And by that I mean instead of users having accounts with a single value that defines how much they own of a certain token, you instead have discrete notes where a note represents some defined value of cryptocurrency, and notes have an owner, and a user's balance is just defined as just the sum of all the notes they own. So I could have like a ten Ethereum node and a 15 Ethereum nodes.
00:03:46.930 - 00:04:39.822, Speaker A: And this construction makes it much easier to perform private transsteps using this concept called a joint split transaction, which gets encoded into one of these fancy ZK snark circuits. So just to run through basically a little bit of how this works, the idea is you have two input nodes where from the perspective of an observer, these notes don't leak any information. They're all encrypted. So if you could decrypt the note, it'll tell you who owns it and how much they're worth. But unless you have a private key, you can't see that. And so the idea about how you do a private cryptocurrency transfer is you have two input nodes that you own as a user, and you effectively destroy these notes. And in their place, you create two new nodes where you use Zeronold's proofs to prove that the values in the encrypted output notes is equal to the values in the encrypted input nodes.
00:04:39.822 - 00:05:22.014, Speaker A: And because your encrypted output notes can have different owners, that allows you to perform a private transfer. As how I could send tokens to Anna by destroying ten Ethereum that I own and then creating like two, five ethereum notes where one is owned by Anna. That would be a private transfer, as long as nobody can identify. Well, it's a little bit more complicated than that, but at a high level, that's how it works. And you can get extremely strong privacy guarantees from this kind of construction. But there's a problem with this, which is that Xeronor's proofs are extremely expensive. They're computationally expensive to verify.
00:05:22.014 - 00:07:30.650, Speaker A: And on Ethereum, I think with current gas prices, verifying a ZK snark proof could run you up to $100, which is not particularly scalable if you want cheap private transactions. And so the way that this is one of the ways that you can solve this, and the way that we're trying to do it, currently doing it, is using this concept of a ZK roll up, or I guess in our case specifically, it would be a ZkZk roll up, because generally ZK roll ups refer to kind of rolling up public transactions. And what we're doing is rolling up private transactions anyway. So the idea is, instead of having a zero knowledge proof, which processes one of these transactions, where you destroy some notes and create some notes in their place, you have an extremely complicated zero knowledge circuit, which verifies a very large number of these zero launch proofs. So the idea is, you have this architecture where users can deposit cryptocurrency and withdraw cryptocurrency from this roll up, very much like you would deposit and withdraw onto a layer two, except that any kind of private sense that you make within this roll up architecture are completely hidden from the world. And because withdrawals are not linkable to deposits, it makes it very easy to obtain a high degree of privacy if you want to use your cryptocurrency for some kind of public application, like in a smart contract, because you can deposit some ethereum into this roller architecture, and then at some later date, you can withdraw it to a different address and nobody can link the two. This is also quite a useful method of funding anonymous addresses as well, if you have any need for that, just at a high level, how this architecture works is you take that joint split ZK snot proof I mentioned before, and you just create another zero knowledge circuit, which verifies a very large number of these joint split zks nut proofs, which is a little bit easier said than done, because verifying zero knowledge proofs is a very mathematically intensive task.
00:07:30.650 - 00:08:21.846, Speaker A: And the zero launch circuits are not traditionally like the proving algorithms for zero launch proofs are relatively slow. So this would take quite take a lot of computational power to perform. But there's been several advances over the last few years which has made this practical at scale. But, yeah, anyway, if anybody has any questions about this architecture, I'm happy to discuss after the talk. And then one extra step to this is basically a ZK roll up. Roll up circuit, which is getting a bit ridiculous now, but the idea is it's just a way of massively parallelizing zero proof construction, because typically constructing these proofs is not very easy to parallelize. Irresponsible devices.
00:08:21.846 - 00:09:17.210, Speaker A: But by using this recursive technique, we have, we make that very possible and plausible. The idea is you have a roll up circuit which aggregates 32 private transactions, and then you just have another roll up circuit which aggregates 32 roll up transactions. And then you can build that in a tree like structure to scale your roll up to extribute large volumes. So that's how one can enable private transactions on a blockchain like ethereum. But how does one actually do defi decentralized finance? Because that's a very different kettle of fish. The next step, it quite naturally follows that if you can do private value transfers, can you do something a bit more expensive? Can you actually program the logic in these circuits to create private smart contracts? Because a note in one of these joints, bit transactions, it can represent more than just token values. In many ways, it functions a bit like a storage slot in a solid leaf smart contract.
00:09:17.210 - 00:10:12.490, Speaker A: And so those rules around that joint spit transaction can be modified because these zero non stackers are programmable. However, that does massively complicate the role of architecture, because you're adding untrusted code execution into your problem. And so you need safeguards to make sure that users are protected from malicious actors. So the way that you can do this is by creating this concept of a kernel snark circuit. To achieve this concept of code privacy, where you can have private smart contracts, you program in the context of a layer two roll up and have users transact for these private smart contracts completely anonymously. The idea around the kernel snark circuit is basically it contains a record of all of the. So your private smart contracts are encoded as zero snark circuits that you can construct proof server to central transactions.
00:10:12.490 - 00:11:23.510, Speaker A: And what a kernel snark circuit functionally does is it verifies the correctness of one of these single private smart contract transactions. The value of this is that an individual user transacting with this network would construct this kernel ZK snap proof locally on their device, and in doing so, obscures the address of the smart contract they're transacting with. So, where are we at so far? You can do programmable private smart contracts. So what about programmable private defi? It's a very tempting prospect and something that we very much like to achieve, ideally this year. However, there are problems when you want full privacy. Specifically the fact that all of the state in your system is private and it's owned by users because it's encrypted and somebody needs to know how to decrypt it. And you can't have public state in your smart contracts, things like the total supply token or metrics around which you can construct a liquidity pool, because modifying these global variables will leak information about user's transaction.
00:11:23.510 - 00:12:52.820, Speaker A: And so for example, if you wanted to make a private makerdao, that would be quite difficult on the surface, because if you have one of these collateralized debt positions, you need some algorithm to determine whether your CDP is under collateralized and then liquidated. But if your CDP is encrypted, how is an algorithm supposed to figure out whether you're under collateralized? And even if it can, how is it supposed to liquidate that position if the only person who knows what that position is worth doesn't want it to be liquidated? See, you can do private defi in a very direct manner in a way that you can, for example like port, making it out to some private system or port something like Uniswap. But it's quite difficult because it requires multiparty computations. And you need additional trust assumptions, because you effectively need to replace the function of an algorithm in a smart contract with a decentralized kind of set of users, validators that you need to somehow trust will act honestly and not collude and use staking incentives to ensure that. So that seems a little bit unfortunate, right? Because it's not ideal. Certainly that kind of advanced multiparty computation in the context of ZK roll ups on Ethereum is quite some way away. So is there some kind of shortcut that we can do? Is there some kind of cheat to interface to be able to get privacy with existing DeFi protocols? And the answer is yes.
00:12:52.820 - 00:13:55.938, Speaker A: And that's basically by interfacing private transactions with public Defi and acquiring very high degrees of user privacy. So the way that this works, what we're trying to build right now, is a lot of DeFi protocols can kind of be modeled as time delayed token swaps, where you don't know the exchange rate between the tokens you're swapping until the point that your transactions mined. So some examples are like Uniswap, the Uniswap liquidity pool, or trading on Uniswap. These are functionally, you call a contract, a smart contract, and you trade token pairs, maybe with some additional logical checks. And so, can you create a privacy preserving bridge to layer one existing Defi protocols? The answer is yes. So what you do is you have a ZK roll up architecture where you aggregate a large number of user deposits. So the idea would be users can kind of deposit notes of a fixed denomination into a pool.
00:13:55.938 - 00:14:55.690, Speaker A: So, to give an example, you have like 100 Ethereum that you want to trade into Uniswap. Then you and 100 other people could deposit 100 Ethereum into a pool, which will have 10,000 ethereum in total. And the idea is, because all the deposits are of the same value, and all of the identities are randomized and anonymous, nobody knows who is actually deposited into the system. And then once you put that 10,000 ethereum together, you then interact with the layer one network, and you call the d five protocol as an aggregated construction. And then once your d five protocol has you sent your transaction, you've received whatever token in exchange that you expect. Every user can then withdraw their allotted portion of the process of that transaction and convert them back into private zero knowledge nodes. And that kind of system can give you a very strong degree of privacy.
00:14:55.690 - 00:15:47.466, Speaker A: So this is a little bit how it would work. The idea is, inside your zk roll up on the left, you have notes for fixed nomination. They get aggregated together in this aggregation circuit. The idea is then once the amount of value in that circuit has reached a certain threshold, it gets sent across the layer two, layer one boundary to a defi bridge contract. And then this defi bridge contract will trade with Unisop or RV or whatever, and then send the proceeds back into the aggregation circuit. And then the depositors will withdraw their new notes, where, because you know what percentage of the pool you own, you can trustlessly extract what you've earned without any risk of double spending or somebody taking more than their due. So that's what we're building.
00:15:47.466 - 00:16:47.654, Speaker A: And one of the other advantages of this is you get quite cheap interactions to layer one, because you're sending this expensive layer one transaction. It represents a very large number of users instead of just a single user. And this process of depositing and withdrawing into the aggregation circuit, because it happens exclusively on the layer two, it costs very little gas. It's quite cheap to do. So how do you actually power this private defi? Because the concept I've talked about here are quite complicated to pull off in practice, you need quite specialized cryptography, because when I've been talking about these things like kernel stark circuits and aggregation circuits, these are all zero circuits that perform an extremely large amount of mathematical number crunching. Specifically, they're verifying the greatness of hundreds of zero knowledge proofs, which is not trivial to do. And so this is where the latest R and D that Ariel and I, our chief scientists, have been working on is going to hopefully come in quite handy.
00:16:47.654 - 00:17:42.826, Speaker A: So plonk is a universal snark proving system that Ariel and I published in 2019. And we haven't been idle since then. We've been working on it and refining it and approving it, and also taking in all of the brilliant ideas that have come from the wider cryptographic community to improve this thing. And we've developed what we call an ultraplunk, which is what we think it's pretty much the state of the art when it comes to universal proving systems. It allows you to relatively efficiently verify the correctness of a zero knowledge proof inside a zero knowledge proof. So this concept of recursion, and you can do it on Ethereum today without needing access to advanced cryptographic premises that aren't supported by the Ethereum protocol. And you also have constructions like things like, you can represent random access memory inside your circuit, so you can have things like dynamic arrays, which for a typical programmer probably sounds extremely trivial.
00:17:42.826 - 00:18:29.358, Speaker A: I mean, dynamic arrays, we've had those since the 1960s, back when people were programming in cobalt or in regular computers. But this is something which is extremely hard to achieve inside a zero knowledge circuit, because what you're effectively doing with Zeke is not, is you're taking an imperative computer program and trying to turn it into some algebraic formula, some mathematical representation. And so things like array access is not particularly easy to do, but we've got a way to do it. And that, along with other techniques, is why we think we can build this provision preserving system. And so, yeah, anybody who's interested in general, has previously worked in this. This is just a table of the constraint counts for any proving system. And anyway, yeah, happy to go back to that if anybody has any questions.
00:18:29.358 - 00:19:22.080, Speaker A: We're also building a private smart contract, domain specific language for programming these circuits so that you can program in a natural high level, relatively natural high level language that then compiles down to a zero's proof without you having to worry about the cryptography behind it or having to understand the cryptography yourself. And the idea is that this can be used to create very feature rich, programmable private smart contracts so you can have a lot of logic that encodes the correctness of your private transfers. So we're releasing that this week, I believe. Actually we're releasing an offer of it. So, yeah, we'll be publicizing this fairly soon, and if anybody wants to have a go. And this is what we're building, releasing next week. It's called ZK money, which is a fully private crypto payment using our ZK roll up technology, which we're deploying on Mainet this week.
00:19:22.080 - 00:20:32.950, Speaker A: So for us, it's been quite a long development process, but it's finally, hopefully going to arrive next week. And this is aggregated private cryptography, Ethereum Transactions on Ethereum using our ZK technology, completely trustless, with one of the strongest, with an extremely strong anonymity set, where we're aiming to get the average cost of a private transfer down to about 15,000 gas. So very competitive with regular Ethereum transactions. So, yeah, that'll be coming next week. And longer term, what we're aiming for is build everything that I've just talked about. So halfway through this year, we're going to be building this aggregation circuit and this ability to interact privately with existing D five layer one protocols, and to do so relatively cheaply. And then finally next year, we will be publishing our full vision of the normal programming language and have the ability to directly program circuits inside our snark role of architecture.
00:20:32.950 - 00:20:49.740, Speaker A: So, yeah, that's pretty much. Pretty much everything I have to say. That's kind of our roadmap for getting privacy into defi. Thanks for listening, and yeah, if anybody has any questions, I'd be happy to answer.
00:20:50.750 - 00:21:09.746, Speaker B: This is so exciting. I actually have a question for you about the rollout. Like, you have this plan to roll this out next week on main net, but are you deeply affected by the crazy gas prices? It's a tough time right now.
00:21:09.848 - 00:21:55.780, Speaker A: Yeah, we've had to reset our expectations. We were hoping to say that you could do a private transaction for $0.10, but now it's merely the cost of a regular Ethereum transaction, which is unfortunate, but it's something we're working on. I don't think we're as value effective, because I think the people who will use our protocol desire transaction privacy quite strongly, given that the price of it is going to be pretty much equivalent to an existing Ethereum transaction. It means that anybody who wants privacy will hopefully be able to afford it. But yes, it certainly is not going to be. Not yet.
00:21:55.780 - 00:22:01.300, Speaker A: At the point of extremely cheap private transactions. Hopefully that's coming later this year.
00:22:02.470 - 00:22:17.350, Speaker B: If anyone has any other questions, you can leave them in the. Hop in. Oh, there is one here. Yeah. Is noir DSL named after the french cabinet noir?
00:22:18.810 - 00:22:35.790, Speaker A: No, it's not. It's named because it's the. God, I feel so unconscious. The French were black. And because what we're doing is privacy and shielding transactions from the public, we thought it was very appropriate.
00:22:36.450 - 00:22:48.850, Speaker B: Although now I'm curious what this cabinet noir is, maybe we can look that up. After John asked, do you see a path to achieving similar functionality, but without a trusted setup?
00:22:50.070 - 00:24:05.180, Speaker A: Yes, although it would require the Ethereum protocol to add support for new cryptocurrency parameters, and also probably Ethereum. Certainly when Ethereum 2.0 comes online and the cost of call data drops, then they'll be very plausible. So the zero streaming system that we're using and which the ones that most people are using these days, things like Ploncor, Marlin, they're very amenable to being ported over to proving systems that don't require a truster set up. However, the trade off of doing so is that the proof sizes scale to hundreds of kilobytes, up to even a megabyte. And at that data size, it's extremely expensive to process one of its transactors on Ethereum, because adding 100 data, it costs millions of gas with current gas prices, is quite punishing. Whereas using a trusted setup, the proof size is only like 1 we've got at the moment we hope is a bit of a halfway house where we do require a trust setup, but it's just one trusted setup for every single circuit that gets programmed, so we won't need to repeat it.
00:24:07.550 - 00:24:13.706, Speaker B: Are you using the same kind of parameters as you created in the ignition ceremony, or are you making a new one for this?
00:24:13.808 - 00:24:25.920, Speaker A: No, we're using the ignition one. Cool. Yeah, it's quite fortunate we created our ignition ceremony for a very different protocol, and it just so happened that we could reuse it for plonk. Very cool.
00:24:26.950 - 00:24:42.818, Speaker B: John Smith, the person who asked about the cabinet noir actually answered what that is, so maybe I can tell you. It was apparently used to read encrypted mails for the king's court. A dark room where the cryptographers of that day secretly worked on private letters.
00:24:42.994 - 00:24:46.870, Speaker A: That is fantastic. I wish we did name it after cabin in the 1 hour. That's brilliant.
00:24:47.450 - 00:25:19.214, Speaker B: Isn't that neat? Yeah. I think you should probably back call. If anyone asks again, you'll be like, actually. Okay, there's one more question here. Are you considering releasing on top of l two, maybe an OVM? Like the optimistic roll up instead of layer one? So working, I guess. Wow, that would almost be like a ZK ZK roll up on top of an optimistic roll up. I think that's what that would mean.
00:25:19.332 - 00:25:37.540, Speaker A: Yeah, absolutely. We're considering it. Certainly we're. Our tech is very. Any OBM that supports smart contract execution, we can very easily port a protocol to and that's certainly something that we're exploring right now. Cool.
