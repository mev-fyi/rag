00:00:06.250 - 00:00:13.950, Speaker A: So next up, we're going to hear from ravital Selman and beating the flashboys with fully homomorphic encryption and DKPs.
00:00:16.690 - 00:01:22.594, Speaker B: So today we'll be looking at front running on exchanges, and the title of this talk is beating the flashboys with fully homomorphic encryption and zero knowledge proofs. For those of you who don't know Flashboys, as a reference to a Michael Lewis book dealing with high frequency trading, this is a joint work with Gada, who was previously at New Cipher and is now an assistant professor at Yukon. So we're going to first look at front running. In traditional markets, many financial applications involve buying and selling goods. Maybe the most popular example is the stock market. In an auction, potential buyers submit bids, and in its simplest form, a bid consists of two values, n the number of items the buyer wishes to purchase, and p the price per item that the buyer is willing to pay. In front running, some malicious actor sees a concrete transaction's details before it's been processed, and then reacts before the transaction from this innocent user is executed, usually for some sort of financial gain.
00:01:22.594 - 00:02:27.366, Speaker B: The traditional solution to front running is either sealed bids, in which you hide the bid value itself, or dark pools, which can be thought of as private exchanges. Additionally, front running is actually illegal for most securities, so you can, of course, threaten people with lawsuits. There are a couple different types of front running, but for the purpose of this talk, we are going to focus on insertion attacks. So we assume Eve has already front run Alice's order, meaning that she's seen an order Alice has submitted and reacted before Alice's order has been finalized. So in insertion, we really require Alice to still want to run the same function for this to be an insertion attack. So an example of this might be ticket scalping, where Alice wants to buy some concert ticket. Eve sees this, buys the concert ticket first, and then sells it back to Alice at a higher price, thereby making some sort of profit.
00:02:27.366 - 00:03:38.622, Speaker B: So here, Eve really needs Alice to want to still purchase the concert ticket for this attack to be successful. However, there are a couple different types of front running attacks that we will not be concerned with in this talk. So what does front running look like in blockchain? Well, the first thing to note is that front running is primarily a problem for the account based model, not so much for Utxos. So if your solution to front running is just to ditch the account based model, it's probably no value in listening to the rest of this talk. The interesting thing to note is that since we're not in securities markets, we don't have the same regulations for front running and blockchain, and we cannot threaten people with lawsuits necessarily. And additionally, dark pools don't really work because we do want some kind of decentralization, so we don't want some trusted party to maintain the order book on the right is an image and caption from Eskandari et al's Sok on front running from previous year at financial crypto that I highly recommend. You can see here that this is on the Ethereum network.
00:03:38.622 - 00:04:45.120, Speaker B: A user submits some order, say to buy 1000 shares of some stock along with a gas price. The front runner sees the user's order and then submits his own order for the same number of shares, but with a higher gas price, thereby bribing the miners to work on his order over this innocent user's order. So what are potential solutions for front running your blockchain? So we have three major categories that solutions could fall into, the first of which is trying to enforce some sort of transaction order. But this can be quite tricky and opens up a whole can of worms. Another potential solution is redesigning the market itself, maybe to disincentivize front running, but this falls more under economics, which is not my specialty. And then the final potential solution is trying to offer some sort of privacy. That way malicious users can't see the bid in the first place.
00:04:45.120 - 00:05:35.170, Speaker B: This might fall under creating a private blockchain which could potentially hide the inputs and outputs of transactions and functions. It could potentially hide the function itself and even the identity of users. Or we could have some sort of sealed bid auction. But it's important to note that we have to have some sort of way to prevent early aborts. That way users can't just submit bids that they have no intention of acting on. So we're going to look at how can we design a cryptocurrency scheme that offers privacy and protects against front running attacks? Blockchain designs offering privacy are definitely not new, and there's quite a few previous designs. These are some particularly popular and potentially well known ones.
00:05:35.170 - 00:06:34.896, Speaker B: The interesting thing to note is that a lot of them use trusted setups or some sort of trusted party for efficiency, which we see as Zexi, ZK and hawk. In this case, the construction either will use an encryption scheme with zero knowledge proofs or some sort of commitments with zero knowledge proofs. They have different issues. So while Zether does not use any sort of trusted setup or trusted party, it has limited functionality. Zexion, the other hand, has quite a bit of functionality, offers a large amount of privacy, but it's pretty expensive for the user to implement and a trusted setup is needed for each application. ZK has a similar issue in the sense that there are expensive computations that the user has to do. Finally, Hawk is a very recent work, not recent, it's a very old work in this area and probably one of the first looking at private smart contracts.
00:06:34.896 - 00:07:49.260, Speaker B: But it requires a trusted manager, so our design will not use any sort of trusted setup or trusted party. Our construction differs from the previous ones in that we are going to use a fully homomorphic encryption scheme along with zero knowledge proofs. The main issue with our construction is efficiency, especially with regards to space, as there is an issue of ciphertext expansion for fhe. And finally we're only going to offer input and output privacy for our solution, which suffices for sealed bid options and front running there. Here we just have kind of graphical representation of how the solutions really compare, or like buckets you can put the solutions into. On the left we see that most of them require some sort of trust assumptions, either a trusted setup, trusted hardware, trusted party and here we've also included echaden and arbitrum. We have Zether, which has limited functionality but no trusted setup, and ours which probably has the largest efficiency loss with regards to space but does not have any sort of trusted setup hardware party and has much more functionality than Zether.
00:07:49.260 - 00:08:32.920, Speaker B: There's no one solution fits all here. It really depends on what's most important to you. We're going to look at some of the design assumptions and our solution. So we are going to build on top of Ethereum's design, even though our scheme is not immediately compatible with Ethereum. By that we mean we are going to take some of their design principles. We are going to assume that we have an account based model, we have a nonce associated with each account, some sort of signature scheme. We can support smart contracts, every operation is associated with some cost, and there are fees attached to each transaction that affect priority.
00:08:32.920 - 00:09:27.180, Speaker B: Our scheme is going to assume the use of a public account with this key pair, unencrypted balance and some nonce. But additionally add private accounts in which we have an fhe key set and this fhe key set is going to be used to maintain an encrypted balance. That way the balance is hidden from other users. We will also have a nonce associated with this account that will be incremented with each transaction. The private accounts will be used to support private transactions, which will allow us to send currency between public and private accounts. We will introduce a locking mechanism to prevent conflicts between concurrency and private operations. And additionally we note that fully homomorphic encryption can be used to create smart contracts providing input output privacy, since we can operate on ciphertext.
00:09:27.180 - 00:10:22.892, Speaker B: So for those of us that don't know or need a refresher in fully homomorphic encryption there are two main ideas behind fully homomorphic encryption. The first is that the scheme is additively homomorphic, meaning that adding the encryption of A and b together is the same as having added a and B in the plain text space and having encrypted that. And additionally the scheme is multiplicatively homomorphic. An interesting thing to note about fully homomorphic encryption is that it's lattice based, so it's naturally post quantum. Fully homomorphic encryption schemes fall in three major categories depending on how it models computation. It could be either boolean circuits, arithmetic circuits, or floating point arithmetic. We are going to be using a fully homomorphic encryption scheme using arithmetic circuits, and below is just a diagram illustrating how fhe works.
00:10:22.892 - 00:11:36.388, Speaker B: You feed it some encrypted inputs, you can perform computations on these inputs and you get encrypted outputs. So what are the challenges with using fhe? The number one challenge is that fully homomorphic encryption is incredibly expensive. However, this is not huge problem in our scheme because we note that basic transactions between users don't really require the full power of fully homomorphic encryption. We only need the simpler ring LWE encryption scheme from reggae. Additionally, for using homomorphic multiplications, we can outsource these more expensive computations to the miners to perform for us. Another issue with fully homomorphic encryption is how do we ensure that these homomorphic computations were even performed correctly without checking it ourself? This will not be a problem in our design, since we assume an honest majority of miners. Another potential issue is that fHe is single key, meaning that it only supports computations on ciphertext encrypted under a single key.
00:11:36.388 - 00:12:35.076, Speaker B: How might we perform operations on inputs coming from different users? This will require a bit of ingenuity in our part in design, and there may be additional logic needed in smart contracts. Another problem is that fhe uses lattice based cryptography. Lattice based cryptography and the zero knowledge proofs for lattice based cryptography are not very efficient. So what zero knowledge proof can we use that's relatively efficient? And by that we mean producing proofs less than 100 kb in size on average. So the interesting thing here is that there was a pretty recent construction called short discrete log proofs, and it allows us to prove lattice based relations using Pedersen commitments. So we'll make use of this scheme in our construction. Just to recap, the cryptographic tools we're going to use is a fully homomorphic encryption scheme using arithmetic circuits.
00:12:35.076 - 00:13:21.888, Speaker B: This would narrow us down to the BGV and BFV scheme. And it's important to note that for simple transactions, we don't need the full power of fully homomorphic encryption. We can just rely on the basic ring LWE encryption scheme of reggave. In terms of zero knowledge proofs, we're going to use the short discrete log proofs construction and we can use bulletproofs. Once we have the Pedersen commitment, we will also use a digital signature scheme, but that's not particularly interesting. So what might a private transaction in our scheme look like? Well, we have the sender with a private account, meaning that he has some fhe key pair and he maintains an encrypted balance. And the balance is encrypted with respect to this fhe key pair.
00:13:21.888 - 00:14:13.632, Speaker B: The receiver has a similar setup. He has his own fhe key pair and his own encrypted balance. For a private transaction, we want to send some amount of currency from the sender who has a private account to the receiver who also has a private account, while hiding the transfer amount and the balances of the users involved. So what's going to go into a private transaction? Well, the sender is of course going to need to specify who the recipient is. He is going to encrypt the transfer amount under his own key with some randomness. He is then going to encrypt the transfer amount under the recipient's key using the same randomness, and he's going to need to provide a couple of proofs. The first proof is that these two ciphertext C and C prime encrypt the same transfer amount using the same randomness.
00:14:13.632 - 00:15:36.316, Speaker B: He's going to need to also prove that the transfer amount is greater than zero, and he's finally going to need to prove that his remaining balance is also greater than zero. Assuming everything is correct, the sender's balance can be updated to his encrypted balance b minus the transfer amount C and the recipient's balance can be updated to his previous encrypted balance B prime plus this transfer amount C prime so what will a sealed bid auction look like in our scheme? Well, we're going to first go over how a sealed bid auction would work. The seller is going to post some items for auction, and then the buyers will submit sealed bids, hiding the number of items they're interested in biding on and the price per item they're willing to pay, and then they will reveal their bids at the end of the auction. So previously in Zether, buyers can only bid on a fixed number of shares, assuming they want privacy for their entire bid. By this we mean that if the seller posts, say 100 shares for sale, the buyers or potential buyers have to bid on 100 shares. They don't have an option of bidding on a fewer number of shares. Our scheme will be different in that we will allow buyers to bid on a variable number of shares.
00:15:36.316 - 00:17:28.192, Speaker B: So assuming again that the seller is posted up to 100 shares for sale, buyers can bid on anywhere between one to 100 shares while hiding their bid price and the number of shares they're interested in buying. We are going to need a zero knowledge proof showing that the buyer has enough currency in their account for the total bid value, which can be computed as the encryption of n times the encryption of P. We'll also need some sort of zero knowledge proof showing that the encryption of P is in the posted range that the seller has offered. We will have a locking mechanism to prevent early abort and here on the right you can see that the first solution is, well, the first box with hiding P and like PI for the zero knowledge proof details how the scheme might work. If you're only interested on bidding on a fixed number of shares and your scheme only supports a homomorphic addition, this is precisely the setup of Zether. In the middle you can see what would be an alternative construction not supported by Zether but supported by Zexi and ZK, where you have some sort of encryption or commitment to both the number of shares you're interested in buying and the price per share. Since your scheme does not support homomorphic multiplication, you would additionally need to post what the total bid would be and encrypt or commit to that value, along with a proof showing that this has been done correctly, as in the update has been done correctly and it satisfies certain conditions, such as being able to afford the bid and p being within the posted range of the seller.
00:17:28.192 - 00:18:42.510, Speaker B: Our scheme will only require posting the encryption of the number of shares you're interested in buying, an encryption of the price per share, and simpler zero knowledge proof because the product of the two ciphertext encrypting n and p can be computed by the miners. So here we're just going to look at a comparison of these two approaches where you're interested in hiding both the number of shares and the price per share. So one potential construction, and this is roughly the construction used in Zk and sexy is the user computing the encryption for NP and the encryption of the product n times p. The user will need to produce a more complex zero knowledge proof showing that this update has been done correctly. The user here will perform the bulk of the computations and the idea is really to rely on a zero knowledge proof to ensure that updates are done correctly. Our scheme will not require computing all three of these values. Users only need to compute the encryption of n and the encryption of p.
00:18:42.510 - 00:19:45.020, Speaker B: Miners then can compute the total value, which is the product, since our scheme supports homomorphic multiplication and the idea here is to rely on fully homomorphic encryption to perform updates. That way we can outsource these more expensive computations to the miners to do no one approach is, I would say, superior to the other. It really depends on what you're looking for and whether or not you're really interested in hiding the price per share. One reason you might be interested in hiding both the number of items and the price per share is if you're bidding on a very large number of items and your bid could potentially affect the market itself. Otherwise, you might not need to even worry about hiding the number of shares. So just some numbers to end on. For the basic ring LWE encryption scheme, which is used for all the transactions, you can see that encryption and decryption are pretty fast and it's on a very reasonable machine.
00:19:45.020 - 00:20:22.460, Speaker B: For the short discrete log proofs construction, the performance is dependent on the elliptic curve chosen. We just do an application of verifiable encryption here, and the proof sizes are approximately 1.3. You can see that for six threads the prover time is under 10 seconds and the verifier time is around 5 seconds for curve 25519. So we don't have numbers fully for fhe yet, which would be interesting to see to get a better sense of how competitive our scheme is. That's it. Thank you for listening.
00:20:24.320 - 00:20:57.130, Speaker A: So thank you for this talk, and thanks for those who've left some questions. I want to recommend that if anyone has any questions to put them in the chat now so that we can actually talk about Rafitel's presentation. I know that one of the questions I had right off the bat, you showed the three different categories of ways to actually prevent front running. Do you think, given the work you've done, that using privacy is the strongest, or do you think it's just a way?
00:20:58.380 - 00:21:07.610, Speaker B: I don't know if it's the strongest solution specifically for front running, but I think private blockchains offer so many advantages if you can additionally solve front running.
00:21:11.120 - 00:21:21.440, Speaker A: Cool. McKara had a question here. What does the implementation of this construction look like? What components are off chain and what components are on chain?
00:21:22.500 - 00:21:36.150, Speaker B: That question is a bit difficult to answer since we haven't fully implemented it, much less even fully benchmarked the scheme. That's something in progress. So hopefully I'll have news to share in a month or two on that, but not right now.
00:21:36.520 - 00:21:47.400, Speaker A: I'm curious, where did the work come from? What inspired it, especially in the context of new cipher? Specifically what inspired it within that.
00:21:49.340 - 00:22:17.168, Speaker B: I think it was our interest in fully homomorphic encryption. And originally I was supposed to look more at proofs of correctness for fully homomorphic encryption, but I instead became interested in the private smart contract space. And then I noticed that all of them, maybe not all of them, but they mostly rely on additively homomorphic encryption. So it was just kind of a what if? Like, could this be done? Oh no.
00:22:17.334 - 00:22:18.370, Speaker A: Am I back?
00:22:19.240 - 00:22:19.990, Speaker B: Yeah.
00:22:20.600 - 00:22:43.076, Speaker A: Okay, cut. I'm trying to think if I had anything else here. So it sounds like this was more to do with using fhe. Does the new cipher system as it exists right now, do you think it'll tie together? Do you think it'll be used in tandem somehow?
00:22:43.188 - 00:22:53.900, Speaker B: I don't think there's any way to implement the work as it is here with the new cipher network. It would really require a different blockchain and a different construction entirely.
00:22:55.520 - 00:22:59.970, Speaker A: Do you plan on implementing it though? Anyway? Is this something that you're working on?
00:23:00.500 - 00:23:23.808, Speaker B: That's really hard to answer just because we don't have the numbers. So trying to compare it against sexy is a question I saw. Replacing Zexi with the untrusted universal setup. Understanding how the numbers compare. Does this make sense? That's necessary first before understanding whether we should put it into production or deploy it.
00:23:23.994 - 00:23:32.184, Speaker A: Got it. And does that also refer to Dara's question here? Do you have an order of magnitude estimate for the performance? I guess you don't yet.
00:23:32.382 - 00:23:54.960, Speaker B: No. I think the most concerning parts, of course, like the FHE and the ciphertext expansion. I don't think the zero knowledge proofs are too bad. I guess it depends what it means by too bad. We're talking about very efficient zero knowledge proofs and this workshop. So people want single digit kilobytes, which we may or may not have, but we're definitely under 100 kb for proofs.
00:23:56.340 - 00:24:02.470, Speaker A: Because I was listening to your talk on a different screen, I didn't actually hear that much about the type of zero knowledge proof that you were using.
00:24:04.760 - 00:24:33.710, Speaker B: Since fhe uses lattices, there's a little bit of a challenge in finding a good proof system to prove things about lattice based relations. So we used a paper called short discrete log proofs and it was from public key cryptography 19, and it allows you to use Patterson commitments to prove lattice based relations. So that's the main proof system we relied on. But once you have those Pedersen commitments, you can use standard bulletproofs to prove additional relations.
00:24:35.040 - 00:24:38.668, Speaker A: Cool. Well, I don't know if there's any other questions.
00:24:38.754 - 00:24:40.784, Speaker B: I'm not seeing any look like it.
00:24:40.902 - 00:24:50.320, Speaker A: I'm going to assume that everyone understands. I guess the last question that I have is where can people find out more? Where can they maybe get involved?
00:24:53.060 - 00:24:57.820, Speaker B: That is not yet done. Where the paper has just been submitted to a conference.
00:24:57.980 - 00:24:58.688, Speaker A: Okay.
00:24:58.854 - 00:25:05.720, Speaker B: About a month back. And then we'll probably post, post it like on Eprint. And then also put up a link on Usifer's website.
00:25:05.870 - 00:25:10.104, Speaker A: Cool. So we should look out for a link then. Yes, a lookout for a paper.
00:25:10.222 - 00:25:12.440, Speaker B: Cool. Very good.
00:25:12.590 - 00:25:22.740, Speaker A: Thanks everybody. And we'll see you. The next talk will be in, I think, 30 minutes and it's going to be the lightning talks on this stage. See you soon. Bye.
