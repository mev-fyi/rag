00:00:07.530 - 00:01:14.530, Speaker A: Hey everybody, I am Josh from Enoma and this is going to be a workshop on vampire LlvM for polynomial circuits. This event is going to be really interactive. I'm just going to do like 510 minutes max of intro and then we're just going to start using vampire and try to build something with it. I have some ideas of what to do, but it's pretty open for interpretation. So hopefully we have lots of questions and people can bring some ideas as well. But I do have backup in case no one does before I do my introduction. If you brought a device, you can go ahead and get a head start on getting vampire.
00:01:14.530 - 00:02:12.050, Speaker A: Probably the best way to get it is to go to GitHub.com anoma vampire. There is a branch there called Zksummit and that branch has a code space that I set up. And if you use the code space version, you will get semantic highlighting with vampire because it has an extension built in. If you don't use that, you can also get the binary under releases or you can build it from source if you wish. If you use those options, you won't get the syntax highlighting. So I recommend doing the code space, but the choice is yours.
00:02:12.050 - 00:02:48.020, Speaker A: So if you brought a device and you want to play along, go ahead and you can start getting that and I'll just go through my first few slides. Just going to be a brief introduction. Oh, this is really important. We have some exclusive vampire stickers available today, available only to participants in this workshop. They're really cool. They are our cat logo. See if I can.
00:02:48.020 - 00:03:02.850, Speaker A: I'm bringing this up now because I don't want to forget to hand these out. So if this thing ends and I have not handed these out. Somebody say something.
00:03:05.060 - 00:03:06.610, Speaker B: How do we launch the course?
00:03:09.380 - 00:03:25.090, Speaker A: There should be a button called code green button and go down and launch it. You do have to be signed into GitHub, I think, for that to work. Okay.
00:03:27.800 - 00:03:30.310, Speaker B: But I can also just clone it and.
00:03:30.840 - 00:04:42.154, Speaker A: Yep. Okay, so I'll just start with introduction to vampire. The agenda basically covered this. For the live coding, I have Blake two s hash as like an abstract goal. We probably wouldn't finish it, or maybe we would, I don't know. But at least components that would be used there would be useful in many different circuits, so it's a decent thing to start. So why make language for arithmetic circuits? A while ago I was asked to see if our MAsP, it's a multi asset shielded pool circuit, would be more efficient using plank with lookups than it was with R one cs and Grote 16, which is what it was originally written for.
00:04:42.154 - 00:05:33.360, Speaker A: The MAsp is just version of sapling with a couple of extra things to allow multiple assets. So I went and I tried to rewrite this in plonk with lookups, and it was really, really annoying. It was kind of a challenge. I never actually finished that project. And the most frustrating thing about it is that the underlying circuit that you are checking is the exact same. If you're using R one, cs or plunk, there's a relation that you are checking the same relation. You just have to express it a little differently depending on the back end that you're using.
00:05:33.360 - 00:06:40.886, Speaker A: There's differences in the expression based on proof system, but then also implementations of proof systems can change the way it needs to be expressed. So you have all these different possibilities for how to express one thing, which is fundamentally the same thing in a bunch of different places. And you shouldn't have to rewrite the same circuit in two different ways just to test to see if it's better in one proof system than another. It's just too much time. So what is vampire? This is kind of aspiration here. We can have vampires in IR. The white circles are like front end languages, ZK languages, you are probably familiar with socrates and circum.
00:06:40.886 - 00:07:32.354, Speaker A: They've been around for a while. Noir is from Aztec. Heliax has a language called Juvix, which we're going to use as a front end for circuits. And so you can start from any of those front end languages that you see there. And there is a path to vampire, and then there's a path out of vampire to any of the back ends, which are the black circles on the other side. So any front end language that wants to hook up to this graph, they can do so by targeting vampire, or they could target the IR used by noir. Asir, I think, is how they pronounce it.
00:07:32.354 - 00:08:20.980, Speaker A: Or if you want to use starks, you can target airscript. If we can compile back and forth between these things, then hitting any one of those targets gets you all the options here without having to rewrite anything. That's the big goal. So I'll just talk very briefly about arithmetic circuits and what they are. An arithmetic circuit is a representation of the computation of a polynomial. Here are two circuits. They compute the same polynomial polynomials are equal, but the circuits are different because the steps are done in a different order.
00:08:20.980 - 00:09:31.498, Speaker A: The circuit on the left is a more efficient way of computing that polynomial uses fewer operations. So two different circuits, same polynomial circuits, are really good word for these objects, because they really do function a lot like an actual circuit. If these were printed circuit boards, then you could, I don't know, hook a volt meter up to one of the nodes and read the value at that node. So each of these nodes has some kind of value that will be applied, the witnesses, and either the circuit runs correctly or gets fried or something if you don't satisfy it. Another thing is that you can join arithmetic circuits together by basically just wiring them up. Here I have two representations of circuits. This one is div mod.
00:09:31.498 - 00:10:40.320, Speaker A: So I take x and y, and you get the quotient and remainder out of x divided by y. And then over here, we have a range function that tests if something is four bits, fits in four bits. So by wiring together r and z, you're forcing those values to be the same value. And so you can compose arithmetic circuits like you would functions. The only thing is you have to designate what the inputs and outputs are. Unlike functions which have this feature built in, circuits basically only have inputs, but you can designate certain ones to be considered inputs and outputs and wire them together and still get some composition. And this is the last slide, I think, on this.
00:10:40.320 - 00:11:19.850, Speaker A: Arithmetic circuits are also just systems of polynomial equations, and nothing about them is more difficult than stuff you did in grade school. This is the system for a range. Proof of four bits. Here, maximum degree is two, and we have one polynomial with five variables. That's it. It's not that challenging. That's just polynomials underneath.
00:11:19.850 - 00:12:02.600, Speaker A: Okay, so now we're going to move on to the live coding portion with our goal being Blake two s. We'll see if we get there. We may not so a little bit about Blake two s. This is the more important stuff that we need to do. Blake two s. Actually, what's on the screen will only get us the function that you repeat over and over again for many rounds. This function g.
00:12:02.600 - 00:13:06.720, Speaker A: To do the full Blake two s hash, there's a couple of steps at the beginning and a couple of steps at the end that I didn't put on the screen. But if we get there, then we'll include those as well. If you want to see the full spec for Blake two s has a link up here, or you can just google Blake two s spec or rfc or something, and it'll come up. Okay, so before I switch over to the code, I just want to show what's going on here. This g function, you have a vector of 16 words. Each word is 32 bits. And on each iteration of this function, you select four of those 16, and you're only working with those four.
00:13:06.720 - 00:14:02.720, Speaker A: So most of these inputs here are not actually used. A-B-C and D are the indices of the four that you are using in that round. And then elsewhere in this, there's a schedule of which ones you use on each round. So b of a and b of b, those are just two of the words that we're using. So we'll probably start this just with four inputs and not really worry about the whole 16. Then x and y, I believe, is some extra data that comes in from somewhere else. So we have basically 632 bit words.
00:14:02.720 - 00:14:50.894, Speaker A: And with those, we will add three of them together here, do mod to the 32 just to keep the result as 32 bits. Then we have xor and we have a rotation. And then all the other steps are just the same. So we need to do mod two to the 32. We need to do rotations and xor and addition. If we can do all of those, then we have the building blocks for this g function. These rotations are.
00:14:50.894 - 00:15:13.842, Speaker A: They're all rotations, right. And down here at the bottom of this table, I have the actual amount that supposed to rotate. So you rotate 16 bits, twelve bits, eight, and then seven. Okay, so we may need to come back to this a couple of times just to see what we're doing. But what are the rounds?
00:15:13.906 - 00:15:18.054, Speaker B: It says like rounds and word rounds in f. And then we have them.
00:15:18.172 - 00:15:18.646, Speaker A: Yeah.
00:15:18.748 - 00:15:20.386, Speaker B: What is f? Is that a field?
00:15:20.508 - 00:15:55.540, Speaker A: No, f is another function. F basically has the beginning steps, then ten rounds in this case of g that you do over and over. And then there's some final bits to f. So f calls g in the middle. Yeah. Any other questions over this before we clear it from the screen? We can always come back to it. Okay.
00:15:55.540 - 00:16:50.350, Speaker A: All right, these are some slides that I'm probably not going to use very much showing how vampire works, but we can just do that in the code space. And of course, while I was having you guys get code space and everything opened up, I could have been doing that myself. Let's see. Hopefully it doesn't take too long. Oh, perfect. Okay. Yes.
00:16:50.350 - 00:17:36.322, Speaker A: That's exactly what doing. Okay. Yeah. Well, okay. Bigger or okay for now? Slightly bigger? I don't know. I didn't try it. That works.
00:17:36.322 - 00:17:36.980, Speaker A: Okay.
00:17:40.950 - 00:17:44.790, Speaker B: That's fine. Go a little bit smaller.
00:17:46.170 - 00:18:30.790, Speaker A: We'll see how it works. Okay. All right, so first we'll just write our first maybe vampire statement. We'll write our first vampire statement here. Vampire has basically two kind of atomic statements. One is a binding and one is a constraint, and even though those words are synonyms, they're treated differently. In vampire we use the keyword def for binding, and a constraint has an equal sign in it somewhere.
00:18:30.790 - 00:19:52.440, Speaker A: Okay, so let's start. We're trying to do mod two to the 32. In order to do modular arithmetic you need a range check. You have to check that the remainder is less than the divisor, otherwise it's not the correct version. So eventually we'll be doing a full range check of 32 bits. To get there, we're going to start with a range check for a single bit. So how do you tell that a variable is one bit? Does anyone know what constraint you need? Say like the x is one bit, zero, or one? Yeah, okay, so, okay, that would be a constraint that shows that x is a bit.
00:19:52.440 - 00:20:55.370, Speaker A: This constraint is added to no, not quite, not quite equals zero. The vampire compiler will add this constraint to a list of constraints, and the x there will be solicited from the prover in the proving phase, and a value would be put in there. Then it generates a plank or halo two or whatever constraint on the backside when you compile the circuit. So that's all that we'll do there. But we don't want to keep writing this over and over again with a new variable name each time. That's annoying. So we would like to use a definition to bind this to something so that we can just reuse it, right, so this is a constraint, but we will change this into a definition.
00:20:55.370 - 00:22:02.260, Speaker A: So we do def, let's call it bool x equals curly braces need a semicolon at the end, outside of the braces, and then inside here. This is basically just a closure that has its own constraints that are generated inside, and then those are appended to the full thing inside here. You can put other definitions if you want constraints, whatever. So what we will do is the x we have def bool x. So we are defining a function called bool on an input x. Then we can use x inside, and the compiler will know where to find x because it's the input here. But you can also just conjure up whatever variables you want inside of this as well.
00:22:02.260 - 00:22:40.190, Speaker A: And all that's happening there is instead of temporary variables being generated by the compiler, it generates the same temporary variables, but gives some of them names if you choose to give them names here. So I could say y equals t or something inside here. I wouldn't, but I could. The compiler would add y equals t into the constraint system. It'd be pointless here, but you can do it. You don't have to declare every variable.
00:22:41.970 - 00:22:45.360, Speaker B: Like y and z would be defined globally somewhere else.
00:22:46.050 - 00:23:16.070, Speaker A: Yeah. I mean, the variables here are just placeholders that will eventually hold values. So, yeah, they're just added to like a big hash map of variables. And at the end, in the proving phase, the prover will supply values for those and they'll take on some value. So when you use a variable, even without declaring it, it just gets added to the map. Yeah.
00:23:16.140 - 00:23:24.314, Speaker B: If you were to write y equals t here and then use rules to generate a lot of constraints, y equals t will just have no effect in the end.
00:23:24.352 - 00:23:24.554, Speaker A: Right.
00:23:24.592 - 00:23:31.098, Speaker B: Because effectively you have two variables that are only constrained by being equal to each other, so you can assign any value to them.
00:23:31.264 - 00:23:37.642, Speaker A: They would almost not have an effect, but the proverb would still need to provide values for y and t that are actually equal.
00:23:37.706 - 00:23:40.480, Speaker B: Yeah, sure. But they're not constrained by anything else, right?
00:23:41.250 - 00:24:24.442, Speaker A: Exactly. Let's go ahead and put in our boolean constraint here. So x times x minus one equals zero. In the last version of this, I put a semicolon at the end here. I'm not going to, because the last line of every definition does not have a semicolon, and it's the return value. When the return is an equation, essentially, I mean, if you know functions, it's returning a unit. It doesn't do anything functionally.
00:24:24.442 - 00:25:22.914, Speaker A: There's nothing that happens after that. Instead, that constraint is just like as a side effect added to the constraint system. But you can also put a semicolon here and put x after it. And now as a side effect, the constraint x times x minus one is added to the constraint system. But then if you call this bool x, you actually get a return value that you can use inside of other constraints and definitions. Had previous one when you left off the same code. What does an equation return? An equation doesn't really return anything at all.
00:25:22.914 - 00:25:47.674, Speaker A: It's like I'm losing the words for it, but it's just a function with no return. It just has a side effect of adding things to the constraint system. This one has the same side effect, but it also enables bool x or bool whatever if you call it, to have a value that you can use.
00:25:47.872 - 00:25:52.320, Speaker B: Yeah, very practical question. Can I comments in this vampire code?
00:25:53.330 - 00:26:30.202, Speaker A: Yeah, two slashes. Also, you can do asterisk for block comments if you want. Okay, so here's our boolean constraint. And now I can call bool, let's say bool a. Okay, so this will call this, but with a in place of x. I mean, you guys get this. I'm sure it will add a times a minus one equals zero to the constraint system.
00:26:30.202 - 00:27:13.640, Speaker A: And it has a value of a which is not being used. That's fine, but it could be used. Let's just go ahead and compile and prove and verify this. Why not? So to compile, the command is if you're in the code space, you can just use vampire. It's got the binary loaded into it. If you did this some other way, of course you'll have to do this a little bit differently, but we'll just use vampire. Then we choose the back end that we want.
00:27:13.640 - 00:28:06.558, Speaker A: We have two back ends available now. We have halo two and plonk from Zk garage. If you use plonk, you have to do a setup. So let's use halo two instead so we can skip that process. We'll do a plonk one later, but for right now when we're kind of messing around, we don't want to have to do that every time. Okay, so we'll do vampire, halo two, compile then s for our source. And source is Blake two s vampire.
00:28:06.558 - 00:29:02.182, Speaker A: Or if you created your own file, change it appropriately. And then we need to store the output somewhere. So o little o. Let's call this Blake two s halo two. Okay, so this is compilation. What's going on in compilation is the list of constraints is being generated. Definitions are being expanded, and things are being unrolled and added to a constraint system, which is just a list of binary relations you have like z equals x times y or z equals x plus y.
00:29:02.182 - 00:29:56.520, Speaker A: And everything is broken down into constraints like that. We do have a type checker you can see, I know it's small down here in the terminal, but it says bool ten is int to int. So it's a function taking an integer and returning an integer. Then if everything type checks, we synthesize the arithmetic circuit. Synthesis is our word for basically calling the back end and loading the constraints that we generated into the back end. And then it's done. So we just got a binary of a representation of the circuit that was put into halo two.
00:29:56.520 - 00:30:26.334, Speaker A: Then we can do a proof. So let's do that. Next. The command is vampire, halo two prove. To do a proof, you include a circuit. So it's c. Our circuit was the output of the previous one.
00:30:26.334 - 00:31:18.260, Speaker A: So Blake two s halo two. And then this will also output a proof in halo two. So we need to do o wig two s proof, I guess. So we'll run that command if you don't include other options. There are some other options for this. If you just run the one that I did, it will solicit the values for the variables from you in the terminal. You can also input the values into like a JSON file and it will just read them out.
00:31:18.260 - 00:31:58.550, Speaker A: But since this is short and easy, terminal is fine. So it's asking us for the value of a. Okay, a is one. Okay, proof is generated here. This is the point where we're really just calling Halo two with their API. You could also just do this in Halo two itself at this point. Okay, so we've generated a proof.
00:31:58.550 - 00:32:28.790, Speaker A: The proof has not been checked at all at this point. So you could put in whatever you wanted for a, you would still generate a proof and it would say proof generation success. Doesn't mean that the proof is going to be valid. It just means that you successfully generated a proof. But next we will verify. So you can probably guess what this is. Vampire, halo two verify.
00:32:28.790 - 00:32:59.050, Speaker A: We need the circuit. So C Blake two s. Halo two. We need the proof as an input. So P for proof, Blake two s proof. I misspelled everything. Okay.
00:32:59.050 - 00:33:23.484, Speaker A: We don't need to output anything. It will just tell us the proof is valid or not. Okay, so here we go. And proof is valid. So we're good. I put in one, so the proof is valid. I can easily go back and put in something else, see if we can get an invalid proof.
00:33:23.484 - 00:34:06.430, Speaker A: We already did the compilation. We don't need to do that again because the witnesses are not involved in the compilation step. So we'll just do prove again and this time going to punch some numbers in proof generation success. But when I go to verify, I get constraint system failure which indicates that the proof is invalid. Some of our error messages are a bit esoteric still, but yeah, that's proof invalid. Okay, sure.
00:34:07.300 - 00:34:10.690, Speaker B: What we have proved here is that one is a bit right.
00:34:11.060 - 00:34:56.000, Speaker A: What we have proved is whatever number the proverb put in is either zero or one, but we don't know which one. Okay, so that's the basics. We're going to build up from this and see how far we can get with Blake two. We have some really cool new features in vampire, including mapping, folding, iterating. We have tuples and lists. We can curry functions. We have higher order functions.
00:34:56.000 - 00:35:57.830, Speaker A: And that's all enabled by the type checking system. Yeah, table lookups are not supported directly in vampire, but it doesn't really matter because what you can do there is put a definition in like this and a back end compiler that translates this into say halo two or plonk or whatever can see that definition. And if it has a lookup available, it can ignore the constraint system stuff in the inside that we told it about and just do the same thing with the lookup. So the back end can make that decision. If it has it available, it can swap anything out that it wants. As long as these functions are specified, then yeah, it can make that change and use lookups. And from the vampire side of things it's the same.
00:35:57.830 - 00:36:45.490, Speaker A: Well, here we, I mean we wrote the, the back end compiler that translates to halo two. And right now we don't use any of Halo two's lookups. But we recently found out that at least the way that we're using Halo two, maybe we can change it, but it's automatically generating a big lookup. Table for something, we didn't even know that, but it does that apparently automatically. And so we could then use lookups in our compiler to halo two if we want.
00:36:46.580 - 00:36:56.116, Speaker B: Yeah, maybe a silly question, but if you would have chips or Anybody want to use that SuPporter thing or how.
00:36:56.138 - 00:37:11.176, Speaker A: Would you do that? Yeah, in the back end compiler you can choose to map any of these definitions to a chip, custom gate, whatever gadget, whatever it's called in the back end.
00:37:11.278 - 00:37:13.290, Speaker B: You can specify that in the back end.
00:37:16.560 - 00:38:08.380, Speaker A: The vampire language itself is intended to be very minimal so that it doesn't need to know anything at all about front or back end. The less it knows the better because it's more easy to target it from multiple front end. Back ends. Yeah, so it doesn't know about lookups, it doesn't know about custom gates. A back end compiler that does know about those features in its own back end can make decisions there. Okay, so let's add some more functions here. The goal is to get a first goal should be to get a range proof of 32 bits.
00:38:08.380 - 00:39:17.770, Speaker A: So here's a range proof of one bit. We're going to kind of iterate on this and get a range proof of 32 bits. So one way to do that is we will next make a range circuit for two bits. And with that we can jump up to four bits and then eight bits and just go up like that. So let's try it that way. Okay, so this bool function that we already have, we could also say that this is like range one of x, just to remind ourselves it's a range of one bit. So let's Go ahead and try and make a function that does a range of two bits.
00:39:17.770 - 00:40:23.080, Speaker A: Okay. All right, so the strategy here is we're going to take the input x. We're going to split it into two bits. We're going to check that each of those bits is a bit, and also that x actually is the result of packing those two bits together. So what we'll do is inside here we're going to do a new definition. We'll call this b zero for the low bit. And what we need to do here, this is where it gets a little bit funky in the constraint system.
00:40:23.080 - 00:41:33.580, Speaker A: What we would need after this is, well, we don't need anything after this. B zero is just a variable that the prover will supply the value for. However, unlike this expression up here, X times x minus one, our evaluator will not know how to take this input x and compute the correct value for b zero. Our evaluator is something that's called automatically in the proving phase. It's not necessary to use our evaluator. Any prover, once they know the circuit, if they know how to generate the witness values, all the values of all the intermediate variables, they can just do that themselves. Really, the necessary part of vampire is already done by that point.
00:41:33.580 - 00:42:32.080, Speaker A: But if you use the vampire approver, it has an evaluator, and it may not know how to generate some of the values of intermediate variables. So we have a command to give advice to the evaluator on constructing these values. That command is called fresh. Fresh needs parentheses after it. And then inside fresh you can write an expression that computes the witness value from the input here. So we want this to be the lowest bit of x. So we just want to take mod two.
00:42:32.080 - 00:43:25.040, Speaker A: So we'll do x. We use percent for mod. So fresh means we are adding a fresh, unconstrained, absolutely free variable into our variable map, and then x mod two is saved for later during the proving phase. That way the prover only needs to give x, and then this is called to help compute b zero. Another way to do it is the proverb just gives values for x and all the intermediate values in between. There'd be a pain. So we have this extra thing.
00:43:25.040 - 00:44:14.960, Speaker A: Yes, we have a restricted library here of operations. You can do inside fresh. You can do addition multiplication, you can do field division, integer division, mod, of course. And we also have another operation which is basically division or zero. If the denominator is zero, it won't fail the division, it will just put a zero instead for that value, which is actually useful in conditionals. Like if you want to do an if statement, you need that.
00:44:15.490 - 00:44:20.930, Speaker B: Do you have a way to access this fresh variable in our circuit.
00:44:26.270 - 00:44:28.954, Speaker A: Now we can refer to it as b zero. Right.
00:44:28.992 - 00:44:31.718, Speaker B: And you can add further strength.
00:44:31.894 - 00:45:17.370, Speaker A: Yeah, this is extremely important and also a reason why we're thinking about removing fresh or rethinking this system. This is a definition. This line has not added any constraints to our system. There is nothing requiring b zero to actually be the first bit of x. We're just saying that when the prover gets to that phase, that's what they should put in in order to satisfy the circuit. But no constraints are added at this point. So let's go ahead and add a constraint.
00:45:17.370 - 00:46:50.062, Speaker A: We can do that just by saying bool, b zero. And then, Chris, this calls bool adds a constraint, constraining b zero to be a bit. And now it's good. So, yeah, this is a tricky spot where if you forget to add the constraint, then you'll have an under constrained circuit, which is really bad. And so we're thinking about removing fresh and having witness generation handled outside of this document, so that if you're in here, all you see is constraints, and you won't accidentally think that, okay, well, x mod two is b zero, so it's constrained because it's not. Okay, then we're going to repeat this again with b one, the high bit of x. Yeah, I haven't used circum enough to confirm that, but witness generation has to happen for both.
00:46:50.062 - 00:47:25.050, Speaker A: There's got to be some way of specifying that. So it sounds like that's doable, but don't quote me too much on that. Okay, so we'll repeat this again. Def b one equals fresh. This time we need to get the second bit of x. So we'll do x. Integer division is backslash.
00:47:25.050 - 00:48:36.160, Speaker A: So X divided by 2% two, and then, bool b one. Okay, so we're dividing by two, so that gets rid of the lower bit. And then we do mod two to get the single bit that's of what's left. Okay, all this does is makes approver supply two bits called b zero and b one. It doesn't have any connection with x yet, so we need to do that for sure. To do that, we just say x is equal to b zero plus two times b one. And we will put a semicolon and our return statement can be x.
00:48:36.160 - 00:48:41.508, Speaker A: That way we can use this and get a value out of it.
00:48:41.674 - 00:48:47.140, Speaker B: Okay, can we iterate under microscope of definition?
00:48:47.480 - 00:49:50.010, Speaker A: Can you iterate? Yes. So we'll get to that. Yeah, you can do iterations so you can supply an integer value to a function and it will iterate that many times. So this is kind of like vampire's version of a loop, but instead of like for loop, you just give integer. Yeah, we'll do that. Okay, so here's our range. Two, if we want to, if we want to turn this into something that we can iterate on, we'll need to rewrite this a little bit.
00:49:50.010 - 00:51:17.012, Speaker A: Let's see. Let's actually, you know what for right now, just because my, my instructions for iterator is on the other screen, let's do a copy and paste and we'll go up to four. I'm going to change b zero to low and b one to high. These bools will change to the range that we just did and change b zero, b one to low and high. So our goal here is to split x into two two bit values and then call the range two on those. Right. So for fresh here, we'll need the low half is a two bit thing.
00:51:17.012 - 00:51:51.570, Speaker A: So we'll do mod four and then the high is we'll do x divided by four, mod four, and then we'll change. This should be range. Yes, thank you. Thank you. These should be eights, not fours because they are half of two to the fourth. That's where they come from, not the exponents themselves. Okay.
00:51:51.570 - 00:52:40.566, Speaker A: All right. And then we change this instead of a two here we need eight. Defining. Yes, this should definitely be four. All right, well, let's figure this out. Range two is two bits, so zero to three. If we put in X, that is in range four bits.
00:52:40.566 - 00:53:02.980, Speaker A: So that's 16, right? Yeah. So we need two values from zero to three for the low and the high. So yeah, so this is four.
00:53:08.870 - 00:53:14.440, Speaker B: But you do need to multiply. Multiply by the same thing.
00:53:16.250 - 00:53:36.926, Speaker A: Yes. And should. What? Thank you. Okay. All right. Hopefully that's good because we're just going to copy and paste again and do it again. Yeah.
00:53:37.028 - 00:53:45.780, Speaker B: So what's the difference between division and integer division here? All of the variables, integers here.
00:53:47.830 - 00:54:56.412, Speaker A: Inside of fresh. Inside of fresh. Ah, I think it wouldn't matter in this case. Yeah. Okay, so this is where it gets a bit funky because in vampire all these values are just integers, just big ints. You can use really large integers, but in the back end everything is converted to a field element. So if you take two integers and you do like regular integer division, there's a remainder.
00:54:56.412 - 00:56:00.630, Speaker A: But if you're in a field and you do the division on the field elements represented by those integers, then you don't have a remainder because you can always do division and you get a different result. So that is why we have division and integer division. Even though everything here is an integer when it gets to the evaluation phase, we're working with field elements at that point. So it's important to specify integer division versus field division. And the integer division will do the regular integer division before converting into a field. And then the results are the field representations of the quotient remainder. If you want integer division, you got to make sure that you're using the integer division symbol because the other slash will give you something different.
00:56:00.630 - 00:57:02.940, Speaker A: Okay, so let's copy and paste this again, and this time we'll go eight. Well, this is the easy part. These should be fours, the range two should be fours. And let's just think carefully about what these integers should be. We're giving x as an eight bit value, so we're trying to break it into two four bit values. So we want to do mod 16, and we'll also do the division there. Okay.
00:57:02.940 - 00:57:09.840, Speaker A: 16 at the bottom. Right. Do we agree with this?
00:57:14.130 - 00:57:15.760, Speaker B: I'm already checked back.
00:57:16.690 - 00:57:30.660, Speaker A: Great. Perfect. Okay, so we have 16s everywhere. We have range force here. Looks good. We'll keep going. We only have two more.
00:57:30.660 - 00:58:13.194, Speaker A: I don't think we have to talk about these as much. Copy and paste eight to 16. Change the forest. Eight. And then here, this will be 256. Right. Okay, so, yeah, I'm on the, on the last one.
00:58:13.194 - 00:59:04.030, Speaker A: Range 32. Change these to 16. Okay, now what goes here? Yeah, well, let's just do two to the 16 and save ourselves some mental energy. Okay. Use parentheses. All right. Okay.
00:59:04.030 - 00:59:55.592, Speaker A: Yeah, we better stop here and just double check that everything works. So let's go down here and call range 32 a. And since we've changed the code, we need to recompile course. Oh, yeah. Okay. All right. Yeah, this happened recently with exponents we need to fix.
00:59:55.592 - 01:00:40.580, Speaker A: There's an issue on it. What's two to the 16? 6536. Okay, we'll use this in the meantime. Now it compiles fine. We see all of our functions there, taking integer to integer. That's good. All right, then we can just go back up to prove it's the same command and it's asking us for a.
01:00:40.580 - 01:01:20.580, Speaker A: Let's choose something that should work. You can, you can put things in, in hex if you want. That should work. So 32 bits is how many in hex. Each byte is two characters. So, like eight. So if I do fff should work.
01:01:20.580 - 01:02:06.500, Speaker A: Verify. Okay, it's valid. Let's prove again, and then we're going to do zero, X-F-F proof generation success. Okay. Failure. Okay, so yeah, it appears that our range proof is working. You'd want to test this a little bit more, but seems like it's okay.
01:02:06.500 - 01:02:58.364, Speaker A: All right, so now we can constrain things to a range. And honestly, this gets us most of the way to what we need for our Blake two s. Most of it is ranges, weirdly enough. So let's go back to my slide here. Okay, so now we can do mod two to the 32. So we can do our first line of this function here. Okay, so that is called g in RFC.
01:02:58.364 - 01:03:45.196, Speaker A: So we'll keep that as well. We're just going to start with four inputs. Actually there's six, right. There's four from the words that are in like the state vector, and then there's two other ones. So we'll just do abcdxy. Yeah. Because of our type checker and the way it works, you can just put spaces in between all these and the type checker will know that g is the function that we're calling because we have querying.
01:03:45.196 - 01:04:57.790, Speaker A: So this is just automatically handled and it treats everything essentially the same. Okay, so the first line is we take a plus b plus x and then we do mod two and 32. So we'll do, oh, and we're putting that back into a. Okay, if I say a equals here. Sorry, if I say def, a equals, this will make a new variable, also called a with a different id than the a that's up here. If you use def, it's going to create something new. So what we will do is.
01:04:57.790 - 01:05:23.510, Speaker A: So that means we can just leave this. We're not overwriting a, it's just a new variable, also called a with an id that's different. So we're going to save the results of this into a new variable. Okay.
01:05:27.720 - 01:05:32.340, Speaker B: Original a shadow.
01:05:35.180 - 01:06:03.090, Speaker A: Let's see. That's a good question. Really. Honestly, we should just use a different variable name. Yeah. So let's just do a next. All right, so this will be a plus b plus x.
01:06:03.090 - 01:06:34.360, Speaker A: And we want to do the range 32. We need the parentheses there because of the addition that we're doing. Otherwise if these were like separate inputs, we could just use spaces. Okay.
01:06:36.410 - 01:06:40.950, Speaker B: Sorry, you're saying all these operations are by default modulo?
01:06:45.960 - 01:06:50.230, Speaker A: They're only modulo two to 32. If we put the range 32 in front.
01:06:53.090 - 01:06:56.350, Speaker B: You mean that we haven't overflow overflows?
01:06:57.670 - 01:06:59.220, Speaker A: No, but.
01:07:01.190 - 01:07:08.594, Speaker B: The Blake formula had this mod two to the 32. Is that blake specific or is that yield that are.
01:07:08.792 - 01:07:35.840, Speaker A: Yeah, it's part of the Blake spec. They just use 32 bit values to represent the message and everything else. The integers that we have available here are much larger, so there's nothing naturally constraining them. Like when you allocate a variable and say it's un 32 or whatever. There's nothing like that. We have to put the constraints in that. Do that.
01:07:35.840 - 01:07:44.062, Speaker A: Okay, great. So that's the first line. What's the time?
01:07:44.116 - 01:07:47.460, Speaker B: Okay, maybe in the interest of.
01:07:49.110 - 01:08:21.130, Speaker A: Yeah, sure. I think this was supposed to be an hour. Am I wrong about that or did I just make that assumption? I mean, obviously you can feel free to leave if you need to go somewhere else, but I think it was originally planned to be an hour. Are we? Oh yeah, we are. Wow. Okay. All right, well, thanks for sticking with me.
01:08:21.130 - 01:08:59.240, Speaker A: I apologize. All right, well, no, I'll just briefly explain the rest of this. There's a bunch of things that we can already do. We can do this step, this step, and this step. Right now. For Xor, you can return a tuple from a function. So you can take an input and split it up into all its bits and then actually get the bits back.
01:08:59.240 - 01:09:59.500, Speaker A: And then you can do zip and xor all the bits together for rotations. You could also get the bits, unpack it and then just define equalities for like the new bit stream. But there's actually a better way to do it, which is just use mod again. So if you're rotating 16, it's almost the same as a range bait. You split it into the 32 bit thing, into 216 bit things, and then you repack it together in the reverse order. And now you've done the rotation. And you can do that for twelve, eight and seven as long as you have the ability to do mod two to the twelve, two to the eight to the seven.
01:09:59.500 - 01:10:13.520, Speaker A: We already have two of those. And that pretty much does it for one round of this g function. Sampling two. Okay.
01:10:18.930 - 01:10:23.626, Speaker B: Would you mind completing that and committing to the repository?
01:10:23.738 - 01:10:50.418, Speaker A: Yeah, sure. Let's go to this. We'll wrap it up here. If you are interested in using vampire. Want to learn more? We have a discord and personal GitHub as well. We're chatting on discord about design changes we want to make. We're writing vampire.
01:10:50.418 - 01:11:47.600, Speaker A: We're trying to include a couple of popular back ends, but we really want other people to be able to add their own back ends they want to use and make that easy. So we're thinking about the design of the interface for that. So yeah, if you have questions or suggestions for what you need to see in vampire, definitely talk to me or visit the discord if you want. It's a separate discord from the models. I don't know if that's readable here, but that's the invite link. I made it a couple of days ago and it lasts for seven day, so if you want to join during the next couple stickers, I thanks everybody.
