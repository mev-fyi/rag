00:00:09.290 - 00:00:39.510, Speaker A: Hello, everyone. We are the polygon team members that will be here at Lisbon. Well, my name is Ektor, he's Roger, and the last one is Jesus. And in our daily bas, this, I would say we are like proverb engineers. Prover engineers, more or less. But today we're here just to introduce you our workshop. We have the clicker.
00:00:39.510 - 00:01:43.200, Speaker A: Well, let's start with just a brief introduction of what we are and what we do. And I normally like to introduce Polygon Gtak Vm, as a very simplified version, is that we are a layer two GTa K roll up. Okay, so here we have like three different words that everybody has to understand to be able to understand us. The first one being, what is a layer two? And very simply, a layer two is. I like to say that it's something that you build on top of a layer one that is connected in some way to a layer one. And in particular, for example, you can inherit some properties of the layer one network, like, for example, the security of a layer one, like Ethereum. But in particular, in our case, we can see ourselves like another chain on top of the Ethereum chain that does whatever it wants.
00:01:43.200 - 00:02:40.190, Speaker A: But whenever we do transact from one state to another state, we have an insurance in Ethereum that what we are doing is consistent and correct. With Ethereum in particular, I like to say that we are like an EVM inside an EVM, but our EVM is tailor made to support ZTEk related applications. Okay, the second word is a roll up. And, well, a roll up is very simple. It simply means that instead of sending all the transactions that we receive, instead of being sent to Ethereum directly, we roll them up into a single transaction. And the single transaction is the one that we include in layer one. Okay? So we are paying for a huge number of transactions, the same that a normal user will pay for a single transaction, okay, that's what roll up is.
00:02:40.190 - 00:03:32.886, Speaker A: And the third one is zero knowledge. The zero knowledge part comes from the fact that apart from sending the transactions for sure, we cannot believe that the transactions has been executed correctly. Okay? So apart from that, we generate a proof of the correct execution of this transaction. Then we send this proof on chain and we verify this proof on chain, okay? With that, if the proof is checked to be valid, that means that all the tax actions that has been proven are also correct. Okay? Okay. In particular, to be slightly more precise, we do not send one proof per batch. We do not send one proof per group of transactions.
00:03:32.886 - 00:04:26.370, Speaker A: We do something slightly more harder. So, as you can see in this very funny diagram we have on the bottom layer some amount of batches. Batches are just a group of transactions. We generate a proof per each of them. And instead of sending each of these proof to the blockchain, we just run another proverb on top of these proofs just to aggregate them and outputting a single proof in the sense that if you verify this proof, then that will mean that all the bottom proofs are correct. And on top of that we generate another proof, checking that all the groups of all the batches are correct in the same sense. If I disprove, then all the bottom are verified to be proven and so on and so forth until the bottom one.
00:04:26.370 - 00:05:24.930, Speaker A: Okay? And finally, we are just sending one proof per all the batches in the bottom layer, okay, so we generate as many as we want. And just to let you know, a little bit of the match bar, because intuitively this has to be a lot of expensive, but it's not. So, as you can see here, we take around 2 minutes to generate a proof, use a batch proof. Then we take like 10 seconds to aggregate all these proofs so used to concatenate all the proofs. And finally, to generate the last proof, use a couple of minutes more. Okay, so in total like less than 5 minutes to generate all this proof, okay. And regarding the cost, we are just paying almost nothing just to be able to not only send in the transactions, but proving the transactions.
00:05:24.930 - 00:06:15.746, Speaker A: The number of transactions are 500. Okay, this is the number for 500 transactions. Okay, I don't want to stop here too much because this is like the real architecture that we have in our system. It's not only about the proverb, the proving part, the smart contracts and so on, but we have like a complete overflow starting from when the user sends transactions to us until it ends up being proven in a batch. These batches get aggregated. And finally, we just interact with the smart contracts on layer one by sending these transactions and the proof. Okay, but we have here like the pool database, which is basically the place where we store all the transactions.
00:06:15.746 - 00:07:10.486, Speaker A: We have the sequencer, which is the entity that decides in which order we're going to prove the transactions. We also have databases in which we store our state transitions. We have the Jekutor, which is the one which is in charge of executing all the transactions. And finally, we have the proving part, which is the part that is more interesting to us in this event, okay, so in the last presentation, it was presented the Thilicon DSL that we typically use in our stack. But in fact, we have more dsls that we encourage you to use if you would like to use something different from tircom. Okay. And in particular, our architecture, or the way we interpret the transactions and are able to prove them, is by having something that we like to call.
00:07:10.486 - 00:08:07.430, Speaker A: In fact, it's very similar to a machine processor. It's totally structured like a processor, meaning that we, for example, have a ram, we have a room, we have a model for checking that the storage instructions are being executed correctly. We also have an arithmetic place where we do binary operations, hashing and so on. Okay. And to implement all of that, we have used two additional dsls, one being PIL and the other one being CTK assembly. In our bounties, we will be focused in using the thircom in order to prove. Well, in particular, we are very interested in improving the monolith transaction, but we also encourage you to take a look at these languages and see which ones you prefer to use, either circum or using PIL and CTK assembly.
00:08:07.430 - 00:08:14.760, Speaker A: Okay, so you want to do it? Let's jump now to the.
00:08:19.310 - 00:08:46.210, Speaker B: Hi, everyone. So basically, we'll have two tracks at the end. We'll have like six k to share between the tracks. The idea a little bit is like just put to these two challenges. Usually will be like three k and three k. But the idea a little bit is like to check the projects that comes out and share the proper amount to each project. So basically, one track will be like using circum, make the monolith hash, as Hector just said.
00:08:46.210 - 00:09:17.930, Speaker B: And the other one is like using basically as ector just explains. For building the polygon JKVM, we build a couple dsls and we also use circum. So basically use whatever stack of the ZkVM that we use on polygon EBM to build another dap and deploy whatever you want. Can be a game, can be whatever you want. Like can proof a hash, whatever. And we also encourage you to check this out. The Montess distribution.
00:09:17.930 - 00:09:37.940, Speaker B: Well, I think the idea, and I said it will be like six k total. Three k. Three k. But see, the acceptance that every project have and share the amount of money, like share a little bit between the projects that came out.
00:09:44.110 - 00:10:43.434, Speaker A: Okay, so the first track, even if it looks like very specific, there is a very good reasoning why we want to build the monolith. Okay. And the main reason is because right now, underline all the CDKVM. We are using Poseidon, like for everything except for where you have to use shadow 56. We decide to use Poseidon because at that time, Poseidon was the one that was easier to express using an arithmetic circuit, meaning that proving the correct execution of Poseidon inputs and outputs is very easy compared to other alternatives. Okay. So in particular, we are interested in monolith because it looks like a very good replacement to monolith, because it not only improves in the proving site.
00:10:43.434 - 00:11:27.530, Speaker A: Okay. It's not only easier to spread in a circuit, and therefore being able to generate proofs on that, but it's easier to compute monolith inputs and. Okay, so, well, basically the objective is computing them. Implement the monolith hash function in thercom. But as I said before, if you take a look at PIl, or you already know Pil and you're excited about this language, you can do it as well. In PIl, PLA and silicon are very distinct in how you express constraints. And in some parts of monolith, it will be easier in silicon, and in other parts will be easier in PIl.
00:11:27.530 - 00:12:42.580, Speaker A: Okay. And for the criteria, for sure, we expect you to make a correct implementation. But overall, we expect that implementation from one side is sound, meaning that you do not miss any important constraint, and on the other side, we expect it to be as succinct as possible, meaning that you do not add more constraints that are still necessary in order to verify monolith implementation. Okay. And use it as a bonus thing that we will very consider is, for example, if you're using theecom, it will be awesome. And in fact, it will be easy for you, if you decide to use thercom, to use very recent features, income like anonymous components or tax. Okay, so I'm going to go fast through this, but basically, as you can see in the table, if you take a look at monolith and try to compare monolith, for example, against Poseidon and Poseidon two, which were the past candidates, to do the very same thing.
00:12:42.580 - 00:13:28.318, Speaker A: In terms of how many time do you need to compute monolith inputs and outputs, it's almost ten times faster than the previous candidates. Okay. And if you compare monolith with very well known and very widely used hash functions like Sachs 56, their timings are very tight. Okay. So that means that this hash function is really fast. Okay. And just as a crisis light on monolith, this is what you will need to be able to implement in circum, nothing else than that.
00:13:28.318 - 00:14:16.318, Speaker A: Monolith is used a recursion of more rounds than what you see here. For example, the second part and the third part, the bricks and the concrete part, I would say, are very straightforward in thircom and the most challenging pang is the first one because the authors recommend to use what we know as a lookup argument to be able to implement this part, but you can do it anyways using arithmetic operations. Okay, this is the part where is more like invention is up to you. Okay. And for example this is from the actual paper of monolith. These are the expected numbers that you are supposed to be able to obtain. For example, they got these numbers using the plunkey two system.
00:14:16.318 - 00:14:27.540, Speaker A: And as you can see, if you compare monolith and poseidon, the proving time and the verification time is double better from the former to the second one.
00:14:35.130 - 00:15:31.980, Speaker B: Hi again. So the ZK tab track, as I say before, it will be like using the ZKBM stack, which basically it's or zkassembly, whatever version of these three, it will be okay to do it. Well, the idea will be like make, adapt if it's complementary with the smart contracts better. So for sure this will be a bonus and a little bit we will measure how secure is your adapt, if it makes sense and stuff. And of course if you end up having an end to end flow it will be much better. And well we encourage the code that must be open source for sure. And well if it in case of the smart contracts you can deploy it in whatever testnet, just share us the link at the tip and if you have any questions about whatever this tooling is, we are at the booth and you can come for sure.
00:15:31.980 - 00:15:36.010, Speaker B: And now we'll do a live tutorial.
00:15:37.550 - 00:17:09.974, Speaker C: So in order to help you, I don't know if you're familiar with circum or not, but even if you're familiar sometimes it might be overwhelming if you have not done a circum project in a while to just get all the tools back together and do all the setup part and get all the comments and go through the documentation again. So what we have tried to do, we'll send this link later in discord, I think it was telegram maybe. We have tried to create an example repo which will provide the link and basically has several examples and has a lot of few scripts that you can use just to get started easily instead of trying to go from scratch and try to search for our documentation. So here in this repo, what you will see, let me check, let me organize 1 second, let me close things. So basically here I need to change the layout, whatever, but here you can see the repo. In the repo what you will find basically is like a few, probably not the best documentation, but still enough to get started. And here we also provide many links about Snarkjs Circum and also some links to our repos and documentation about Peel and Ziggy Wasm.
00:17:09.974 - 00:18:07.260, Speaker C: Because even though it was not originally the main idea we had, as Hector and Jesus said, you are always encouraged to use PiL or Ziggy ASm. And if you want to go that way, we are happy to help you. And if you have any questions, you can reach us and we can discuss together, we can try to help you understand how everything works, how to connect things. And so what you will find in this repo, basically there's like a few examples that they are kind of described here. The first one you will see is Poseidon, one writing in circum. Basically this is the exact poseidon that's on Circumlib. Because if you're not familiar with, as I think Thor said, there's a lot of libraries that are already writing in Zircom, most of them under the repo, Circumlib I think it's called.
00:18:07.260 - 00:19:16.094, Speaker C: So basically we have a Poseidon, which is another hash function that you can use and see how that works, and you will see that. And now I will show you later that there's two implementations of circum, because as ector said, if you want to go for the monolith path, you will face one challenge. That's lookups, which are quite tricky to do in circum, but you can do what's called custom gates. And in this repo you will see some documentation about custom gates and you will see how, for example, the whole poseidon hash was also right. We had a custom gate for the whole Poseidon, which is not intentional for monolith, but can give you some ideas on how you can use custom gates. And then, as we said, we are trying that of course for new developers. But if you have been familiar for a while, there's been new features going on that as Hector said, anonymous components and tax, and also the inspectionality, which are some features that are what we consider is that good practices.
00:19:16.094 - 00:20:14.950, Speaker C: So if you're new, that's perfect, because then you will learn from scratch and that's even better. But if you have already done circumcise before, it's good to introduce this because as I will show you now, it gives you more clarity to the code, it improves the security, the readability, which is also good, right? So if I go to the repo and see if I can show you a bit, where's my mouse. Yeah, here it is. So as I said, you can see here under circum there's different circuits. I think the screen is big enough for sure. So you can see here in Poseidon, as I said, this is a real Poseidon implementation that's used in production in many services. And you can see how it was implemented.
00:20:14.950 - 00:21:13.554, Speaker C: And you can also check, there's this Poseidon custom, it uses custom gates, but it's actually the same. So there's two different ways of implementing Poseidon, both of them different but equivalent, if that makes sense, because at the end the result is the same. And we have where is this test circum in which there's a. I'm assuming that all of you have seen a circum tem template before. If not, I will also provide the link for the basic tutorials. Although it's true it's a low level language, I think it's pretty easy to understand and move forward. And so what I was saying is here, as you can see, we're just comparing those two versions and that's the first example then we have here in the package.
00:21:13.554 - 00:22:09.500, Speaker C: Json, come on, come on, whatever. I think I'm going to go down like this. So here, as I was saying, even though you have developed circumcise before, it's usually annoying because you need to remember what were the exact comments, what you need to write to compile to generate a proof, to verify the proof, depending on the proverb you want to use. So we have put together a bunch of these scripts. So for example here you can see compile which is basically instruction to compile any circuit. Then you can either generate witness with Javascript and C Plus plus, and this way you don't need to waste time because it's not a lot of time, but we're in hackathon, we're time constraints. So it's good for you to have some tools to get started right away.
00:22:09.500 - 00:22:54.850, Speaker C: And also as you can see, we have different type Zerocom, you can generate different types of proof. Right now we support flunk, plunk and gross 16. Here we have the scripts for flunk and gross 16. But plunk is literally the same as flung, just changing a few letters and we can update it later. But here by just running NPM run flung, it will generate the whole setup proof and verify that proof. And then if you want to use it, you can get this and just use it however you want. And also that's one way to generate the proofs using scripts.
00:22:54.850 - 00:23:24.526, Speaker C: But we also have added a test in which you can. Let me see if I can. Yeah, here flung test and graph 16 test. That's basically the same, but it's just how you would do it in a Javascript program that you want just to random. And this is probably more useful for the ZK. Well it's useful for ZK if you want to go for a ZK app. Here you can see how snark JS is called, because Snark JS is another library that silicon has to generate the proofs.
00:23:24.526 - 00:24:22.398, Speaker C: And here you can see how you can do the different calls from generating the setup to generating approve or verifying it, both with cross 16 and flunk. And what you will also find in this repo is some examples of good practices. What we're saying encourage people to use tags, your anonymous components. So for example, you can see here we picked a random, it's just a template that was in circum leap, it's not important. The template itself, it's just a multi. And basically you just given a number of inputs, you just check if all of them are one or not. But this was the original template that was written a long time ago, like probably three or four years ago in the circumlib.
00:24:22.398 - 00:25:14.502, Speaker C: And then we have a second version which is, as you can see, much more compressed and much more at first line, if you check this version, you can much more easily, at least for me, understand what's going on. So you can check event equals one, there's one thing, event equals two, one thing. And otherwise you just do a split in two and then do a recursion on it. And so that's why you say it's important to use it, because everything will be the same, the proof will be the same, nothing will change. But from the developer perspective and from the other people that's watching it, I feel it's much more easier to read and understand what's going on here. That's four lines, and it's like organized that here that you can just. Okay, so here's a nine.
00:25:14.502 - 00:26:25.702, Speaker C: What's happening? You're setting each one variables individually, which is kind of annoying. And then also one other thing that's quite interesting to know is the usage of the inspect when compiling. And here I'm going to put an example that I don't know if you heard, like it was earlier, there was a posting medium about, it was called a million dollar zkback code early. Basically it was about circuit comparing library that just did and allowing BLS signatures. And there was an issue in the circuit. So basically this is actual real code of that library and what was happening, and it's obvious, but not obvious when you write because you can see here, this is all code. So maybe if this was with anonymous companies would be like one line each, here's like seven lines and not that clear, but what was happening here, I just don't care about what's going on, they're just verifying some signatures wherever.
00:26:25.702 - 00:27:06.386, Speaker C: But here you can see lines between 103 and 107. It says check all lengths that are qualified. Basically it was checking that all the numbers were well constrained, were less than a week in number. And the problem is here, and that's one of the things that ector was mentioning, that it's very important that the thing is sound, is that there's constraints for everything. I think it's better to have extra constraints rather than missing ones. Although of course if you can achieve the same with less constraints and be sound, that's perfect. But it's preferable to have more constraints than necessary and maybe checking things twice than rather not checking.
00:27:06.386 - 00:27:47.122, Speaker C: And what was happening here, if you see line 106, and you are a bit familiar with circum, you will see that you are just doing big less than. Basically big less than is a template that returns zero or one wherever. And you wanted to check that all numbers were less than, but you were not checking the output. So then you were doing a check, but you were not checking the output. And then there was a huge bug here. And why I'm telling all this because a few months ago there was a new functionality that was added in circum and let me see if I can write. I think it's NPM.
00:27:47.122 - 00:28:26.190, Speaker C: Run compile. No, not this one. Yeah, this one. And there was a new functionality that just that when you compile, instead of doing a straightforward compilation, you add minus, minus, inspect, it will explore or use and do this automatic check that I'm using all the variables. Is everything constrained then the constraints may be wrong, that's another thing, but at least you will not miss constraints. And for example, if I run it, you will see here, it's obviously saying what I was saying, that. Okay, so in this template, this output, basically the less than does not appear in a constraint.
00:28:26.190 - 00:29:21.426, Speaker C: And that was originally like a huge finding. Oh, we have a huge bug, very difficult to find code early. Now with circum, when you just compile it right away you can detect all those bugs like in a second rather than having to explore the whole code. And maybe if the project is not too big, it's fine. But when you have some projects like circumparting that were huge, it's very useful because you will make sure that everything is constrained and this will be available. As I said in discord, I think we will also add there's two folders, one that's called circum. With all these circum examples there will be another which is more for the small part, we will also add, I think it's already there, but we need to check that everything works fine.
00:29:21.426 - 00:29:57.840, Speaker C: Ziggy DaP example basically how to create a ziggy dap and maybe use a circum and then integrate it with a smart contract. So also you have something to start with and to get some inspiration, see how things are connected. And regarding other dsls that we use, as I said, there's not specific repos like this for you to play, but there's the main ones. And feel free to ask any of us and we will try to help you explain how everything works and all of this. And I think that's it.
00:29:59.090 - 00:31:25.020, Speaker A: Use a couple of notes that you can do these things a little bit much more harder. If you're interested in going through ThirCom, even if you are new to circom or you are very experienced, I would recommend you to take a look at the official documentation of Thercom because it has recently been updated with the recent features that the owners of the compiler have been adding during these mounts. And on the other side, if you're interested in dslrs like PIL, or maybe you just want to build a zero knowledge application on top of the polygon stack, I will recommend you to go to the official Polygon documentation, Polygon gtkvn documentation, because there you will find everything that you will need. You will have specifics at how PIL works and how you have to think in order to implement something in PIL. And also you will have how we interconnect all of our stack. If you remember the slide with all components in the SDK VM, you will see the documentation exactly what we use and how we connect all these components. And just to rephrase a little bit, Roger, the inspect command will not always prevent you for doing things wrong.
00:31:25.020 - 00:32:20.480, Speaker A: In some scenarios, or in some examples it will be super useful, like the scenario that Roger has shown, because thickom by itself will be able to detect that you were doing something wrong. But in other scenarios, for example, if you decide to go for monolith, maybe the compiler will not be able to say you what you exactly are doing wrong, but at least this flag will tell you that there is something that makes no sense for the compiler, but it will not be able to decide what you are doing wrong. So in some parts it will be super useful. Super useful. In other parts, let's say the process of correcting all these mistakes will be a little bit more handy. Okay. And do you have the presentation? No, it's okay.
00:32:20.480 - 00:32:29.120, Speaker A: So yeah, I think that's basically it. So let's hack together. Thank you.
00:32:36.990 - 00:32:59.380, Speaker D: So since we are actually, this is a little earlier than we had scheduled, if there are any questions we can actually take them now. I don't know if anyone has any specifics. I know this is very detailed and maybe you don't yet know if you want to hack. Oh, there's a question back there. You got it. Just wait for the mic so we get it on the video.
00:33:03.010 - 00:33:04.480, Speaker A: Where the question came.
00:33:08.390 - 00:33:17.670, Speaker E: Yeah. So there's a library called circumspect. And what's the difference between circumspect and inspect flag? In circum.
00:33:19.930 - 00:33:21.430, Speaker C: Can you repeat the question please?
00:33:21.500 - 00:33:32.460, Speaker E: Yeah, I used to use a library called circumspect before the inspect flag was released for circum. So I would like to know what's the difference between those two.
00:33:34.030 - 00:33:35.894, Speaker C: Don't know the difference, honestly.
00:33:36.022 - 00:33:36.458, Speaker A: Okay.
00:33:36.544 - 00:33:59.822, Speaker C: But I don't know how circum inspect works. I think inspect is a lot more detailed and provides a more detailed exploration integrated directly in the compiler itself. So when you compile it will do all this instead of having to prefer to external libraries.
00:33:59.966 - 00:34:09.400, Speaker E: I see also like for the monolith hash. The monolith hash. So do you need the benchmarks to be compliant with what we showed us?
00:34:11.770 - 00:34:33.786, Speaker A: I mean the numbers that we show were just, I will say, speculative. Okay. What we expect are that at least that the number of constraints that you use, let's say, to implement the monolith are at least better than those that you obtain with Poseidon. Poseidon two and variants.
00:34:33.898 - 00:34:43.954, Speaker E: Okay, one last question is like for testing, we need also compliant hashes, for example test cases for the integrity of the hash function that we want to develop.
00:34:44.072 - 00:34:44.978, Speaker A: Yes, exactly.
00:34:45.144 - 00:34:49.186, Speaker E: And you provide that, I assume there.
00:34:49.208 - 00:34:56.038, Speaker A: Are libraries where they have implemented the model if you need to? Yes, for sure. Just ask us and we can provide to you.
00:34:56.124 - 00:34:57.320, Speaker E: Okay, thank you.
00:35:02.060 - 00:35:07.832, Speaker F: Okay guys, do we have any other questions by any chance? Now is a good time to ask them?
00:35:07.886 - 00:35:08.490, Speaker A: Yeah.
00:35:11.040 - 00:35:11.884, Speaker F: Hello.
00:35:12.082 - 00:35:48.008, Speaker A: I'm asking about the arithmetic of the two prime number used. I don't see other prime number. Yes, Mercena 31. And I think the Goldilock. The first one is the Goldilocks one, which is very well known, and the other one is one that is trying to be used, which is called the Mersen 31 one, which is a 32 bits prime number. It's another one that is also being tried to use as a replacement for Gordilocks. But it's something that is still ongoing research.
00:35:48.008 - 00:36:53.230, Speaker A: It is possible to use other prime number or just these two for the implementation? Yes, I mean the tool that were mostly used by the original authors. And in fact there is a part in the moly which is called the MDS metrics multiplication. And in the paper you can find those which are more optimized for these two prime numbers. Can I ask about the algorithm of the multiplication and aversion in the prime number? Can you say it again? Because which algorithm is used for this implementation, for example Montgomery, or for the permutation matrix you like in the diagram that I show with three different operations in order to implement the monolith, the MDS multiplication is like the last part of the permutation. So you will need to implement in theorycom this matrix multiplication in order to implement monolith. Okay, thank you. Welcome.
00:36:55.600 - 00:36:59.228, Speaker F: Thanks for the math questions. We have another one up there.
00:36:59.394 - 00:37:00.540, Speaker A: Thanks Eddie.
00:37:03.060 - 00:37:13.810, Speaker G: So the last time I looked into this code of Circom, I thought it was maintained by the team called iden three, but somehow it's now polygon, am I right?
00:37:16.200 - 00:37:40.440, Speaker A: Right now the guys who are behind the Sikon compiler are from university in Spain, from aid university, which are in collaboration with ident three. But yes, right now those who are working in silicon are those guys and polygon team members.
00:37:40.510 - 00:37:48.670, Speaker G: I see. So my question is, just out of curiosity, do you have a plan to add sec p as a field?
00:37:49.600 - 00:38:08.870, Speaker C: I think that there's many fields that are going to be added in the near future. I think right now you can specify in circum like the prime you want to use, and I think at least there's VN 128 and Goldilocks, and I think they are finalizing the test with a few extra ones.
00:38:09.880 - 00:38:30.284, Speaker A: So in the close future you will be able to decide which prime you want to use in thergom. Right now we have a small set of prime members. In fact, those prime members are the ones that we are using in the CKVM. But we expected that in a near future you'll be able to decide which prime member you want to use in particular.
00:38:30.402 - 00:38:36.652, Speaker G: It's going to be awesome if it's supported out of the box without some crazy gimmicky extension out of it.
00:38:36.706 - 00:38:37.884, Speaker A: I completely agree.
00:38:38.082 - 00:38:38.830, Speaker G: Thanks.
00:38:40.560 - 00:39:08.330, Speaker F: Okay, some. Quite an announcement here, I guess. Vicky Hack, any other questions from the audience? Yeah, in the back. Hi. How ZKS assemble related to the circum, or are they related or not? The ZKS is a part of your ZKS stack.
00:39:08.690 - 00:39:25.426, Speaker A: So the ZKE assembly, which is another DSL, which is very low level, it's the language that we use to interpret the Ethereum opcodes. Okay, so we have you use the.
00:39:25.448 - 00:39:31.058, Speaker F: ZK assembly for implementing the ZK, EVM Hermes or something like that.
00:39:31.224 - 00:40:06.160, Speaker A: We use the ZDK assembly not only to interpret the EVM opodes, but also to prove some part of them. So ZDKSM is able to prove some parts of the opcodes that we interpret, but then the rest of the parts, because they are not easy to implement in GTK assembly, we do it in PIL. Okay, so I would say that the interpretation or the proving part of the EVM is done with PIL and GTK assembly, and then we use silicon in the recruitment step of our proving system.
00:40:06.610 - 00:40:07.920, Speaker F: Okay, thanks.
00:40:09.970 - 00:40:19.250, Speaker C: And we are able to generate stark proofs using PIL, which we cannot with circum.
00:40:23.210 - 00:40:31.740, Speaker F: Okay, thank you. Do we see any other questions? Yes, it's fine. That's what we're here for.
00:40:34.430 - 00:40:39.174, Speaker E: Regarding testing in circum. So there is the library called circum tester.
00:40:39.222 - 00:40:39.386, Speaker A: Yeah.
00:40:39.408 - 00:40:40.202, Speaker C: And wasn't tester.
00:40:40.266 - 00:41:05.270, Speaker E: Yes, and I did the benchmarks. It's ten times faster than snark JS Grot 16, for example. And I wonder, do you sacrifice security to have such faster testing framework for that compared to snark GS, for example? Because once you fetch the signals and the results you want to compare with circum tester, it's pretty much faster and with the same results.
00:41:05.610 - 00:41:17.926, Speaker C: Circum tester is just not generating a snark proof, it's just compiling the secret and then checking that a witness is valid or not, but it's not generating the proof for that witness.
00:41:18.038 - 00:41:22.214, Speaker E: Okay, so it's doing the same calculation as circum but not generating the proof.
00:41:22.262 - 00:41:46.530, Speaker C: So when you use circum tester or you are just compiling the circuit in everyone cs, and then you provide a witness and the program executes that witness and check that all the constraints are satisfied. And when you call snarkjs, you need to specify which kind of proof do you want, either snarkjs or flung or plonk, and you actually generate the proof.
00:41:46.950 - 00:41:50.660, Speaker E: Okay, so the difference is proof generation. Yes, I see. Thank you.
00:41:51.190 - 00:42:42.318, Speaker A: Just to be a little bit more specific, the silicon test term, what it does is generates, let's say, the trace or the witness of the circuit. And this, in fact, is express what we call the air one cs constraint system. And the. The tester, what it simply does, it checks that this witness satisfies the l one cs constraint system that is supposed to satisfy. And in contrast, snrgs do much more than that. In fact, in snrgs you could have, like, I would call it a pres setup or preprocessor step in which you actually run the circum tester just to ensure that the witness that you are computing is actually a valid witness. But then you have the process of generating the proof and verifying it, which is completely different from verifying that the witness satisfy their one cs.
00:42:42.318 - 00:42:43.220, Speaker A: Okay.
00:42:46.730 - 00:43:03.420, Speaker F: Great. Thank you, guys. So, yeah, just in case you actually come up with more questions, there's going to be a QA tomorrow on the main stage here at 130. So, yeah, feel free to sleep on it and come back tomorrow with actually more questions.
00:43:04.270 - 00:43:29.906, Speaker C: And just as we said, there's two tracks. And even though at the website it was originally saying, like, the bounties were five k, one k, that's not actually true. We're thinking more of a three. Three. And also, it will also depend on what you guys, if you want to play with circum, you can either go for Molit or go for another, for another kind of project. And depending on the different submissions, we'll decide how we split the boundaries. So don't think.
00:43:29.906 - 00:43:38.018, Speaker C: Okay, so maybe if you want to do something with circum, you don't need to be attached to monolith. You can do whatever you want. And then we'll see, depending on the.
00:43:38.024 - 00:43:53.990, Speaker F: Submission, just do something, I guess, is the message. So, yeah, thank you very much. We're going to actually have a short break now since the next workshop is 10 minutes. So, yeah, deploying zero knowledge proven. Leo, we'll come back in 10 minutes. Thanks, guys. Bye.
