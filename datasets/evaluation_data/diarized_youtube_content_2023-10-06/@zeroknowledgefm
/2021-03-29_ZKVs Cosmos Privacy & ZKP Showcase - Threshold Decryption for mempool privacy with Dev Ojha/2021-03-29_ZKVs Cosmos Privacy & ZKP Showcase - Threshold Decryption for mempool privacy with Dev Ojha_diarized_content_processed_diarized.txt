00:00:02.910 - 00:00:19.060, Speaker A: You okay? Hopefully you can see the screen. Yes. Looks good. So, hello all. I'm Dave Oja. Today I'm going to be talking about threshold decryption for mempool privacy. I'll give you like maybe a brief intro for myself.
00:00:19.060 - 00:00:59.380, Speaker A: I've been working in, I started working at Cosmos things around three years ago, working a variety of things around l one, scaling and research and just also design for things like V distribution. And I don't know, I've done a lot of things across stack. If you check the GitHub, you'll probably find a variety of issues for me. And then I've also been working on like snark research, naming personal snark research the last couple of years, currently help maintain libiop, lib snark, and kind of the arcworks repos. So I'm very excited about zero knowledge proofs and the like, but today I'm not talking about zero knowledge proofs, despite them being near to my heart. We're talking about threshold decryption for mempool privacy. So here's the plan for the talk.
00:00:59.380 - 00:01:46.622, Speaker A: First, I want to kind of motivate what is privacy mempool and why do we care? And it's just going to be two reasons, censorship, persistence, and Mev. Then I kind of want to talk about what is special decryption, and some of the subtleties that I don't think have really been gone into, like preventing silent failure, which I'll explain later, how to handle gas and fees and some notes on the DKG. And then I'll conclude by just a slide on the trade offs of different private mempool solutions. Okay, so let's dive in. Oh, I guess maybe it's a bit of a spoiler, but on the trade off, I think special decryption has the most appealing trade offs. Hence that's the overall focus. Okay, so privacy mempool.
00:01:46.622 - 00:02:51.270, Speaker A: Currently, mempools look like this, where we have a bunch of transactions that are public, and a private mempool, roughly, is like, we want to make it so that you have no idea what's in the transaction. All you see is the fee, and you basically need the fee in order to do simple resistance. So, informally, I'm going to be using the term private mempool to mean like a blockchain where you can make such that only the transaction creator knows the data until the transaction is included in a finalized block. And once it's in a finalized block, there must be a guarantee that the transaction data will be decrypted. And if it's not decrypted, then the blockchain will literally halt. This is important to just stop the miner from just withholding a decryption. For instance, I'm also going to be using minor and validator interchangeably along block proposer all the same for this talk, but threshold decryption is really only going to make sense in the proof of stake setting.
00:02:51.270 - 00:03:28.770, Speaker A: Cool. So here's one of the use cases of it, censorship resistance. So there's two kind of properties of blockchains today. Miners can choose any transaction that has, can choose any transaction, conclude that have some minimum z in cosmos. This minimum is literally zero. In Ethereum post eip one five nine, it'll be above this network threshold minimum for burning. And then second property is that the miner can see the entire transaction content prior to choosing what they want to include and combine these two properties.
00:03:28.770 - 00:04:20.980, Speaker A: And then we get that a miner or a validator can censor my transaction for whatever reason. They just not like me and want to block me from accessing my funds. Maybe my transaction caused them some financial loss, like I don't know, I'm buying something on uni that would make their token go down in value and they don't want this. This is bad. Maybe here's another serious reason is that maybe there's a government agency who wants to block some certain subgroup of people from accessing the financial network for nefarious reasons. And so we don't want to let them do that. And things like feather forking makes this actually very plausible, even if you have a small percentage of stakehash rate.
00:04:20.980 - 00:05:25.974, Speaker A: So the goal is we want to eliminate the ability for block proposers to see transactions like transaction data before the transaction is finalized. And we're going to be using mempool privacy to eliminate that and therefore eliminate this censorship opportunity. Quick note, there's still more you can censor on like the IP, the transaction sender, and we're going to need some p to p anonymity tricks to fix that. This is why Nim is very exciting, or tor for p to p things. Okay, so then I want to switch to motivating the second thing, which is you may be more familiar with, it's like MeV or minor extractable value, where essentially block proposers in blockchains have some special powers that normal full nodes don't. They can read transactions from their mempool, which I guess everyone can control inclusion of transactions in their block proposal and reorder them. And they can do like some consensus boat censorship like selfish mining things.
00:05:25.974 - 00:06:11.922, Speaker A: But I'm going to ignore that for this talk. But these three properties, reading transactions, controlling inclusion, and reordering, gives them some kind of scary powers. Not scary, nefarious. So you may remember the Ethereum is a dark forest post from Dan and Georgios. Basically, on Ethereum, there were some hacks and people wanted white hat return the funds, but there were bots where basically stole the hacked money and gave it. You know, you can steal arbitrage opportunities and you get financial incentives to do so. The second thing that's bad is like front running, where I'll switch this to the blockchain context.
00:06:11.922 - 00:06:52.030, Speaker A: I'm going to explain the simplest form of front running. Where I want to buy, I don't know, a million ETH on a Btc ETH unisoft pair. So the miner sees that I want to buy a million ETH, so then they instead will buy some ETH right before me, I don't know. And then I buy ETH, the price goes up and they sell their ETH. And so the buyer got a worse price, but the miner got kind of risk free profit. There's a large amount of things you can do front running, but I think this is the simplest one for now. Yeah, that kind of has a slide because doc is asking for business use cases and I didn't have much on it earlier.
00:06:52.030 - 00:07:40.930, Speaker A: So to quantify how much of a problem this is, there's this group called flashbots who've been doing lots of MEV research. And so there's this post from February. He's showing that in their initial tooling to underestimate the amount of MEV that's on Ethereum, they found over 300 million that could be stolen like this. So this is actually a real problem. So we're going to want to use mempool privacy to fix this. So of those powers I listed earlier that kind of implied those above attacks, we can solve reading transactions to the mempool by just having mempool privacy. This is kind of like a direct implication by the definition, because you can no longer see the transaction data, therefore you can't really front run or arbitrage.
00:07:40.930 - 00:09:04.670, Speaker A: We can also block your ability to control inclusion of transactions in your block by having multiple validators or contribute transaction data for a single block. It's kind of like we take leader election or leader block proposals and make them a little bit more leaderless, or like a multileter. And then we can solve their ability to reorder transactions in the block proposal by one mempo. Privacy kind of eliminates the useful things they could reorder based off of. So with just that, they could just try to make themselves the first transaction, the block and last transaction. But by also adding, having multiple nodes, confirming transactions, and doing approvably randomized ordering of transactions, we kind of eliminate their ability to choose the order. Because you can imagine that to get approvally randomized ordering, once some encrypted transactions are finalized and decrypted, you kind of take the decryptions and basically you see that into some pseudoram function and then get a new order and you can prove that this is, or then you just execute across using this new reordered version.
00:09:04.670 - 00:09:48.634, Speaker A: So basically, if we have Mempo privacy, we can kind of use these generic techniques in the proof of stake setting to eliminate these other powers or significantly lower their concern. Hence this is why Mempool privacy is an important thing to be going for. So now I'm going to switch to threshold encryption and kind of try to explain what this is. But before I can explain that, I'm going to explain classical BFT consensus. So classical BFT is kind of like tendermint or hot stuff. So maybe a bunch of validators and they all have the same block proposal. Okay, so then everyone votes on swap proposal.
00:09:48.634 - 00:10:34.554, Speaker A: There could be multiple rounds of voting, but for now we're just going to care about the last round of votes. Then they gossip around the votes. And once you get a threshold of votes on a given block proposal, you can finalize that block. So note this, by having a nice little lock here. And then once we have a finalized block, we basically finalized block, we just go to the next block and then keep proceeding. But the key thing is we need a certain threshold of votes to be given. And in tenormint or BFT in general, the best you can go or you kind of want two thirds to be of votes.
00:10:34.554 - 00:11:40.050, Speaker A: This is just because of some things where in BFT this is the best you can achieve or this gives you the best fault tolerance. So now threshold encryption within tenorint. So what we do is before the block proposal had just plain text transactions, now they're going to have encrypted transactions and these transactions are each going to be encrypted to some threshold public key that validators have. So like as a client, when you make a transaction, you encrypt it before gossiping on the network. Okay, then what we do is before we used to all just vote on a block, but now when I vote, I'm going to vote with a decryption share included. So a decryption share is like what it's doing is for every transaction in the block, I'm including, using my private key, some extra data, and then if I have enough of these extra data, enough of these decryption shares, you can combine them to get the underlying data. So everyone includes decryption shares along with their votes.
00:11:40.050 - 00:12:27.858, Speaker A: Then we all gossip our votes and decryption shares, and then we gather all the votes and decryption shares together. So we need a given threshold of votes for finalizing a block. And now we're going to make the decryption threshold the same as the voting threshold. So since I've received two thirds of votes, I'll also receive two thirds of decryption shares. And then using those two thirds of decryption shares, I, as the next block proposer, can then decrypt these transactions that were finalized. So the important thing is that since I had the votes on this block, we know it was finalized. So when I decrypt it, I can still see, oh, there's minor here.
00:12:27.858 - 00:13:23.540, Speaker A: Okay, so I can decrypt these transactions using this. So I, as a necklock proposal, can see the transaction plain text. Okay, I guess these should still be blue and green. It's my bed. So now when I propose a next block, what I'm going to do is I'm going to include these plain texts along with some new ciphertext, like this red and purple thing is my new block proposal. So I'm including the last block's decryptions and the new blocks like ciphertext, and I gossip this to the network. Now, everyone else, every other validator, upon receiving my new block, is going to check that these decrypted transactions are equal to the encrypted transaction are a valid decryption of the transactions they had before.
00:13:23.540 - 00:14:14.850, Speaker A: And then we proceed with consensus on both this pair of new encrypted transactions and old plaintext transactions. And so then we've done a full round of consensus and gotten new plain text along with a new set of ciphertext to start consensusing on. So I guess summarizes a bit because that's kind of technical. When a block is proposed, all constituent new transactions are going to be encrypted. Then when a validator votes on a block, they include their decryption share for those new transactions in the block. And then the next block proposer uses the decryption shares they got along with those votes to create a plain text like the plain text of the transactions. And then when they propose their next block.
00:14:14.850 - 00:14:56.194, Speaker A: They include these plain texts along with the new set of encrypted transactions. And then basically all full nodes are able to verify that the plain texts correspond to the finalized block's ciphertext. So there's a kind of cool property here where only the next block proposer had to receive all the decryption shares. The full nodes, and even technically other validators do not have to. So these decryption shares don't actually blow up like the cost to sync or cost to be a full node. It's only extra bandwidth cost for the validators, though. I guess someone asked for this is actually a kind of notable extra bandwidth cost.
00:14:56.194 - 00:15:41.818, Speaker A: Like per validator is around like 200 transactions, sorry, 200 bytes per transaction, and it grows the number of transactions. If you want homomorphic threshold encryption, it grows even more. But this is still like a very nice property to be having. So a question we have is that can we slash misbehavior? We need a threshold of validators to not be colluding. So in proof of stake, what we do is we say that if I detect you colluding, you get slashed. If I detect colluding, here's like double signing in proof of stake. And we say that we write things such that oh, sorry, I got a ping.
00:15:41.818 - 00:16:23.280, Speaker A: I don't know if this is from John. Oh, okay. I am told I am running out of time. Okay, so I'll just go through this part and maybe skip the other things. So, typical strategy for proof of stake is that once we have class, we say if one third of cabal doesn't form, because if it does, because anyone in the cabal can report everyone else, get them slashed, and then keep proceeding. So an idea is maybe if I see decryption share. So to stop colluding here, maybe I can say if I see decryption share for a transaction that's not already finalized, I'll slash who created that decryption share.
00:16:23.280 - 00:17:14.880, Speaker A: But there's a problem. Validators can collude to decrypt transactions within an SGX. Since the decryption shares never have to be sent to other users, they can only exist inside SGXs. So this means that the validators can collude inside SGX, and then each validator can then just get the decrypted transactions and see them if they colluded and not be slashed for. Thus we can't actually slash validators like this. But there is something cool where we can use SGX and threshold encryption together in order to basically block validators from being able to collude, I guess I'm still running out of time. I will skip this actually, since I'm running out of time, maybe I should just blaze to the end.
00:17:14.880 - 00:18:05.546, Speaker A: Okay, I guess there's another problem. I want to talk about where for gas and fees, we need the gas and fees to be public. So you basically need to prove that the transaction sender wanted a given gas amount and a given amount of fees. So we can solve this by making an AAD like scheme in this threshold setting. I'm skip DKG notes as well. Okay, so I guess I'll switch to hop in and see the questions. Okay, so from patous, what properties do you need of threshold encryption? Does it need to be non malleable somehow? Okay, so yeah, I guess that was thing I skipped with the Aad slide.
00:18:05.546 - 00:19:24.418, Speaker A: So what we need is that when I have a threshold encryption ciphertext for a given transaction and no one else, we need two things. One is that anyone can publicly verify that this is a valid ciphertext. A second thing I need is that it's non malleable and it's non malleable, including this public text data, namely the gas and the fees. If the gas wasn't was malleable, then basically you could use this by changing the gas to be one, including the block having the transaction fail and you get to see the transaction, the decrypted contents. Second question from Henry is why does the data per transaction grow in the encrypted in the homomorphic case? So this is because the way threshold decryption works, or encryption works is that the user makes like an, a symmetric key and they make a symmetric key and they encrypt to the, and they do special encryption on the symmetric key and then they encrypt their transaction content with the symmetric key. So you only have to do threshold decryption on this nice symmetric key. But if you want to be homomorphic, you actually want to have kind of two bulbs.
00:19:24.418 - 00:20:16.950, Speaker A: One is the symmetric key and the second is whatever you want additive homomorphism on which then requires more data per share. You have to basically do special properties on both homophobic thing and the symmetric key. Can you make your slides available? Yeah, I will do so. Okay, so are you writing your own homophobic encryption scheme or is there a library? I'm not writing a homophobic encryption scheme or for threshold encryption we don't need that. There is this paper that we're collaborating with heliax folks. Oh, I also want to give a shout out to Joe Bevel who's been doing a great job on designing the Joe Belt from heliax, has been doing a great job designing a DKG that's suitable for this use case. And so we're collaborating with them to write a kind of threshold encryption library using this paper called BZ three, which is kind of based on BLS.
00:20:16.950 - 00:20:41.422, Speaker A: You might not need to do pert from another question, Henry, is you might not need to do per TX decryption in the homophobic case. Oh, that's valid. Okay. If you only wanted to threshold encrypt just what you want to be, then it's probably his equivalent. Yuri. We'll go ahead and wrap it up there. Thank you so much, Dave, for the talk.
00:20:41.422 - 00:20:48.780, Speaker A: Super interesting, and we look forward to getting your slides once they're online so folks can check out the rest of the talk.
