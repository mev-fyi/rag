00:00:06.410 - 00:00:29.640, Speaker A: And we're back for the first talk of day two of the ZK summit. We're here with Daniel Benarosh from Kedit. He's going to be talking about privacy preserving insight generation across siloed databases. So take it away, Daniel. And if anyone has any questions, please remember to put them in the stage chat. And we're going to do a Q A after the talk. Cool.
00:00:30.410 - 00:00:58.766, Speaker B: Thank you so much Anna, and thanks everyone for being here. I'm very happy to be talking today at the CK summit. It's actually the first time I'm talking here, which is really exciting for me. I'm the director of research at Kedit, a company building enterprise products for privacy data collaboration. Private data collaboration. Some of you may know me from zk proof. I'm a co organizer there.
00:00:58.766 - 00:01:39.718, Speaker B: So happy also to answer questions about that if you have. But anyway, this talk is not about zk proof. Just throughout the presentation, please feel free to ask questions on the chat. Feel free to sort of. I won't be looking at the chat, but if there is anything important then I'm sure we can talk about it either at the end or during. But anyway, I would like to talk today about sort of how to generate insights across from private data that is distributed or that is coming from different sources.
00:01:39.814 - 00:01:40.460, Speaker C: Right.
00:01:42.270 - 00:02:28.218, Speaker B: So the goal is exactly that. You have sort of different parties, say Alice and Bob and Charlie, that have their own databases. And of course these is databases that must be kept private. But we want to essentially be able to compute on the sort of having these databases as inputs, right. Of course we know that there is a primitive called multiparty computation that does this. And there is today a lot of interesting products and work being done. The only sort of challenge here or requirement is that when you do MPC in a cryptographic way, you know that you need to have the actual sort of server that will enable the computation on your end.
00:02:28.218 - 00:03:28.986, Speaker B: And many times these generic NPCs are very interactive, so you need to be online, right. We know this from several settings, whereas what we need when we're selling products to enterprise is something closer to software as a service, right, where you're just sort of logging into your account on the browser and you have all the data and all the product available just a click away kind of thing. So we don't want the clients, the customers to have to sort of install servers that they need to maintain. We don't want them to have sort of interaction between the servers, which is one of the biggest requirements that we have here. And that kind of says that the reason for that is that we don't want to force them to stay online, right. Because it's definitely sort of against the business or usability proposition. And if possible, we would like them not to have to maintain private keys.
00:03:29.018 - 00:03:29.214, Speaker C: Right.
00:03:29.252 - 00:04:35.074, Speaker B: Permanent private keys. So aside from this. Yeah, so no private keys. And in terms of sort of the product itself, like, what does it mean to generate insights? Well, there are sort of two different ways of generating insights across databases, right? You have one where you could, for example, say, okay, I'm going to sort of compute an insight or aggregate data from two different sources about the same entity, right? It could be a company, it can be an individual, et cetera. Or you could essentially say, okay, I'm going to collect data from say like an industry specific use case or something, and I'm going to give back some industry statistics or benchmarks to give like a high level picture of the industry, right? These are just sort of two of these, but these are the ones we kind of focus our product on. And here really the challenge is that we want to actually compute cryptography in a secure way, right? We don't want to give in, sort of have the data and then just give insight. Like, there's plenty of companies for that.
00:04:35.074 - 00:05:55.950, Speaker B: This is not the premise. And we do privacy by design, right? And so the key challenge is how do we do cryptography securely on a decentralized sort of server, on a centralized server? Sorry, not decentralized as we are used to thinking. In cryptography, of course, you can think of several things, cryptographic primitives like homomorphic encryption, which is already practical. A lot of people are using it, but it's not really usable, right? The difference there between practical and usable is that it will take you a few hours, maybe a couple of days to compute on really large data, maybe some large circuits and so on. But it's not usable in the sense that if I'm a user logging in and going online and uploading some data to get some insights from my data, I don't want to have to wait a day, right? I want to upload it, get some data, maybe maximum, I don't know, an hour, maybe a couple of hours, I go get a coffee, go get lunch, something like this. But I'm working, right? It's my day work, so I need to do this. And of course we could use other more specific purpose ones, but we need to think that the functionality there is really limited by the cryptographic scenes, for example, like functional encryption, attribute based encryption, order preserving encryption, all of these things are well known and used in some settings.
00:05:55.950 - 00:06:35.962, Speaker B: And so what are some of the insights that we could generate? While data ownership is key, really, the collaboration part is where the value generation is going to be for companies, right? So we have something like sharing insights in general, where, for example, the goal is that Alice will share with Bob some insights from her database. And here, maybe the key is sort of saying, okay, how does Bob trust the insights? Right? And this is also somewhere where zero knowledge comes in. Right. We're all aware around this issue of integrity of data and computation. There is a different use case which is more around aggregating data.
00:06:36.016 - 00:06:36.186, Speaker C: Right.
00:06:36.208 - 00:06:58.302, Speaker B: If you have Alice, Bob and Charlie who want to sort of compute the average of some values, either their own values, or, say, about some specific individuals for, say, fraud prevention in financial settings. And the challenge here is that you want to skip all of those values private and actually receive the correct average.
00:06:58.366 - 00:06:58.930, Speaker C: Right?
00:06:59.080 - 00:07:05.902, Speaker B: And the last sort of use case example that we have is matching identities.
00:07:05.966 - 00:07:06.194, Speaker C: Right?
00:07:06.232 - 00:07:55.730, Speaker B: So again, Alice and Bob want to have companies, and they want to know what are the clients that they have in common. Maybe they're going to have some kind of joint marketing campaign. They're partners, and they want to generate more assurance, for example, for KYC purposes. And here the challenge is, again, that Alice cannot learn the clients that are not common, Bob's clients that are not in common, and vice versa. And for this last one, we also use sort of this idea of Psi, right? Psi is private set intersection. And what we do at kenned, we call our protocol, the delegated psi protocol, where we're going to actually do the sort of two steps, right. We're going to first match some specific entries between data sets that are distributed across parties.
00:07:55.730 - 00:08:45.410, Speaker B: And then we're going to use other tools to aggregate that data or values that come associated with that data in order to generate insights. So just a quick sort of overview. I'm going to talk about sort of the different primitives that we're going to use. I'll present them and introduce them as we go. First, let's talk about what is private set intersection. So, as I said, it's a very powerful technique for detecting matches and duplicates across databases. So if you have Alice, for example, Alice's customers on the left and bob customers on the right, you really want to get to know all these sort of red triangles in the middle, right? But the key point is, as I said, that Alice should not learn the white triangles and Bob shouldn't learn the blue triangles, right.
00:08:45.410 - 00:09:25.802, Speaker B: And how do we do one, you know, going back to sort of reminding the requirements, the design requirements, is that we have sort of these usability models, right? Where we want the participant, essentially, to have offline communication. Where we want the participants to just send one single message to kind of upload the data and one message to receive the results of the matches and insights. We call that the offline method, offline model. We also want, in terms of state that the only state that they will maintain, that the participants will maintain is their actual database.
00:09:25.866 - 00:09:26.238, Speaker C: Right.
00:09:26.324 - 00:09:32.542, Speaker B: We don't want them to have permanent keys. And if there are any keys, maybe we can get them to be like per session, for example, per upload.
00:09:32.606 - 00:09:33.026, Speaker C: Right.
00:09:33.128 - 00:09:39.554, Speaker B: Just temporary and local. And in terms of server, as we said, we don't want them to have any server.
00:09:39.602 - 00:09:40.006, Speaker C: Right.
00:09:40.108 - 00:10:14.638, Speaker B: So at a high level, what we do, essentially, is that we're actually delegating sort of. If you think about the generic PSi protocols that exist out there, we're delegating the interaction between the participants in the MPC to some servers that are kind of sitting in a secondary line. And we call these the delegates. So the clients are the participants. And then we have another set of servers that we call the delegates. And this is how it really looks like. You have the participants that are sort of connected to a single entity, which acts as a proxy, which we call the matcher as well.
00:10:14.638 - 00:10:26.002, Speaker B: And also you have the delegates connected to that. So the participants interact only with the proxy as well as the delegates. And there are secure communication channels between the delegates and the participants.
00:10:26.066 - 00:10:26.246, Speaker C: Right.
00:10:26.268 - 00:10:46.714, Speaker B: So that the matcher is not sort of an eavesdropper. And this allows us to essentially remove all interaction and all servers and things like this from the participants. Now, there are a lot of existing works in PSI, but we actually deviate from those a little bit.
00:10:46.752 - 00:10:46.954, Speaker C: Right.
00:10:46.992 - 00:11:58.834, Speaker B: We do reuse some of the components because actually most of them require these interaction that I'm talking about that we don't want in our product. There are some works that are like server aided PSI, like Google and Facebook have done some work in that area. But there is still the component of having to interact several times from the side of the participant. And for our delegated PSI, what we use is sort of a combination of secret sharing scheme and oblivious PRs and some other nice tricks around this interesting architecture, right? So let's start by talking about secret sharing, right? Specifically, secret sharing that we use is very convenient. And it's sort of this multiplicative secret sharing where essentially you have here sort of these delegates. D each delegate is going to generate their own key, right? Key one, key two, and key three. And then what's going to happen is that, for example, the first delegate is going to take some group element g, that is public or known to everyone, and he's going to compute g to the k one, right? And then he's going to send g one to the delegate two.
00:11:58.834 - 00:12:28.506, Speaker B: And delegate two is going to add on the exponent his secret or her secret. And similar for the third delegate. And at the end of the day, the third delegate is going to output the aggregated key, right. G to the k. That's a typo. It shouldn't be g here. It should be g to the k, where k is essentially the product of the three values, right? Of course, there is also like additive secret sharing and things like this.
00:12:28.506 - 00:12:56.926, Speaker B: But we're interested in this specific secret sharing scheme because it doesn't have actual interaction and things like this. It's easy to generate and it's also secure by the discrete logarithm. Then we're going to use the pRf, right? PRf stands for pseudorandom functions. And the specific PRf we're going to use is sort of a hash to group function, where we take a hash function like shatu 56, which we call here h, and we're going to map it into a group.
00:12:57.048 - 00:12:57.430, Speaker C: Okay?
00:12:57.500 - 00:13:28.186, Speaker B: So this is going to actually be a hash to group. If this is reminiscent like in the sapling protocol that was introduced. Also, there is actual standards around this for specifically the Ristretto group. And then this hash to group. Now, being inside of a group, we can actually exponentiate by some integer value, right? Or fill element. And this is, we call this f of kx because it's a keyed hash. And then it becomes a PRF.
00:13:28.186 - 00:14:17.546, Speaker B: And there are like two main properties that we're interested. First, one is really pseudorandomness, where as long as k is uniformly random, then f of kx is actually super random and hides x. And you disable sort of brute forcing. And then you have this property of linearity, right, which is sort of key homomorphic in some sense. And then what happens is that if you do fk one of X to the k two, you actually get fk one k two of x, right? Similar to how you would do the secret sharing operation, right? And so what we use is actually not sort of a pure pRF per se. We use something that is called more like an oblivious PRf. We actually use a different version of an oblivious PRF.
00:14:17.546 - 00:14:36.462, Speaker B: But let me build that concept. So in an oblivious PRF. What happens is that there is a participant and a delegate or a server in this case, I'll call it the delegate. And the participant is going to compute this PRF by using sort of a random element.
00:14:36.526 - 00:14:36.898, Speaker C: Right.
00:14:36.984 - 00:14:57.242, Speaker B: A blinding factor. Let's call it R. And so it's going to output C, which is this fr of X. And it's going to send C to the delegate. And then the delegate is going to add the k to C. Right. So it's going to send back c to the k, which is really f of Rk to the x of x.
00:14:57.296 - 00:14:57.900, Speaker C: Sorry.
00:14:58.430 - 00:15:13.902, Speaker B: And here what we see is that basically the participant inputs a value x, the delegate inputs a value k. And what happens at the end is that the participant is going to remove the blinding factor that it added in the first place in order to hide x.
00:15:13.956 - 00:15:14.174, Speaker C: Right.
00:15:14.212 - 00:15:31.862, Speaker B: It's really there for doing that. But now the output is really Fk of X. And now we can see that sort of Fk of x is the output of the protocol for computing the PRf where the participant doesn't know k and the delegate doesn't know x.
00:15:31.996 - 00:15:32.390, Speaker C: Okay.
00:15:32.460 - 00:16:18.138, Speaker B: And this is very important. Specifically, I can give you sort of a glimpse into the next slides where if you think about doing this oblivious PRf for x and y at the end of the process, fkx and fky, you can check whether fkx and fky are equal because if they are equal, then the Prf, being deterministic, is going to give you the same value while being secure and not being able to learn the actual values. But in our Psi, because we said that we actually delegate sort of the MPC and the matching, we actually need the delegates to see the output of this oblivious PRF. And in the process, why don't we try to remove one round of interaction?
00:16:18.174 - 00:16:18.374, Speaker C: Right.
00:16:18.412 - 00:16:31.974, Speaker B: So here we have sort of three rounds. Right, sorry, two messages. But if we wanted the delegate to see the PRF, we would need sort of a third round where the participant sends the output.
00:16:32.022 - 00:16:32.234, Speaker C: Right.
00:16:32.272 - 00:16:57.854, Speaker B: Well, actually we want to remove sort of two messages completely. So it's going to be purely based on one message. And how do we do that? Where now the participant, instead of sending only C and this is, by the way, is a strawman. You'll see why it's a Strawman example. But we'll see the real thing in a second. Instead of only sending C, he's going to send C and R being the blinding factor. And of course, now that's why it's not secure.
00:16:57.854 - 00:17:37.902, Speaker B: The delegate can already brute force and get X. But just bear with me for a second because there is some insight to be shared here. And the delegate is going to again add the key. So it's going to compute Frk of x and at the same time is going to remove the r, right. And at the end he's going to see fk of x. But again, of course this is not secure. So what is going to be, our solution is going to be to distribute R and k using a secret sharing scale, right? Because again, if you had the delegate, even without seeing R, if the delegate could compute fk of x and it knows k, it can again get x.
00:17:37.902 - 00:18:22.282, Speaker B: So we need to distribute both r and k using secure secret sharing. And that really just brings us to the actual protocol flow where I hope you can see this sort of big enough. But essentially here we have again, like the participant data being x. And what happens is that the participant is going to blind, sorry, sample some random values, some random shares r one to Rm because now we have m delegates and the multiplication of these, the product of these is going to be called R, which is our blinding factor. And then the participant is going to do two things. He's going to compute the PRf, right, h of x to the power of one over R. Right.
00:18:22.282 - 00:18:50.882, Speaker B: So just for convenience of later removing the R. So it's going to exponentiate by the inverse of r in the field. And we're going to call this d zero, right. And at the same time it's going to send each of the shares of R, right. The blinding factor to each of the delegates. And now let's start, for example by the first delegate in series. As we saw in the secret sharing scheme, by making the shares multiplicative.
00:18:50.882 - 00:19:01.526, Speaker B: The way it works is that d zero is now going to be sent to the delegate to delegate one. And each delegate is sort of going to remove a little bit of the blinding factor.
00:19:01.558 - 00:19:01.850, Speaker C: Right.
00:19:01.920 - 00:19:33.742, Speaker B: The corresponding share of that blinding factor that they own. And they're going to add their share of the key, right. So k one, as you can see here, d one is just d zero to the power of k one, r one. And this is going to be sent to the delegate two, who's going to do the same with their own key and blinding factor share until we get to the last one, who is going to do exactly that. D. Sorry, m minus one. This should again a typo, so sorry about that, to the power of KMRm.
00:19:33.742 - 00:20:20.994, Speaker B: And that's going to remove the last part of R and is going to add the last share of K. Right. Where k again is k one to Km. And now this is going to be sent to sort of this proxy or matcher. Like we sort of overload that proxy sort of party in the middle of the network and I'll explain why and I can answer some questions around that as well. But this is essentially the delegated psi protocol. Well, the point is that now the matcher, who is going to receive several of these elements from different x's for a given participant, but also from different participants, can actually compute some matches over encrypted data.
00:20:21.112 - 00:20:21.780, Speaker C: Right.
00:20:22.630 - 00:21:12.350, Speaker B: And here the important part to keep in mind is that as long as one delegate is honest, none of the delegates nor the matcher is going to be able to see the actual data x, they cannot retrieve it. And of course by the discrete logarithm as well. So that's about the delegated PSI. Just to kind of close this for a second, let's review the actual protocol in steps. So the setup is really that the delegates sample sort of a ki, right, a share. The participant then computes the blinded PRF, generates the secret shares and sends the shares to the delegates. And then the delegates are going to add sort of the shares and remove the R shares.
00:21:12.350 - 00:21:27.010, Speaker B: This all happens as part of the upload, what we call the upload. And that's sort of one message interaction from the side of the participant. Right. If you're a customer using this, you can kind of go offline after this happens and then you're going to have the matching.
00:21:27.090 - 00:21:27.382, Speaker C: Right.
00:21:27.436 - 00:22:03.122, Speaker B: The matching is going to happen at the matcher. And then maybe I could have added a fourth here where it's sort of download where when the customer is signing in again, logging in again, the results from the matches and the intersection are going to be sent back to the customer. And it's almost seamingless. Right, sorry. So now we have these matches, right. The matcher has ability to compute matches. And maybe I'll say one thing here, and that is that it is clear.
00:22:03.122 - 00:22:51.426, Speaker B: I'm sure you've all noticed that the matcher has some leakage of this data, right? And that's because it can see, for example, the actual size of the intersections and other metadata like that. But in some settings it's not critical. So I'm also happy to talk about that. But now we have these matches and as we said, now we want to do something with this data, right? So how do we aggregate data? Well, let's use homomorphic encryption, but let's see how we can use it. So for those that are not really sort of familiar with homomorphic encryption. This is really like the kind of whole concept of homomorphic encryption in this table. I really like to think about it because essentially wherever you start, you really start in m.
00:22:51.426 - 00:23:47.686, Speaker B: But no matter what path you take here, all the way through the encryption or from here, you're going to end up getting f of M. So the idea is that this layer is where the party lives and then this layer is where a server, a delegated server, lives. And the idea is that I would encrypt m using some homomorphic encryption function under maybe my private key. And instead of computing f by myself, because it's potentially an intensive function computation, then the server would compute this evaluation function based on f. It's actually based on sort of circuit evaluation and would essentially get the encryption of f of m. Right. So the equation really is that the evaluation of the encryption of m is equal to the encryption of f of m.
00:23:47.686 - 00:23:59.926, Speaker B: And once this is sent to the client or the customer, then they can decrypt and get f of m back. But now this is really for sort of one client and one server.
00:23:59.958 - 00:24:00.154, Speaker C: Right.
00:24:00.192 - 00:24:56.966, Speaker B: But we are talking about several clients. So how does that work in an application? Well, let's add that client, right. So we have sort of one message from Alice, who's going to compute some ciphertext and another message, m two from Bob. The key point here to observe is that they both need to encrypt their messages based on the same, using the same public key. Because if not, the aggregator party is not going to be able, the server is not going to be able to add those ciphertext unless you're using something even fancier like multi key homomorphic encryption, which is less practical today. But yeah, that's a whole different conversation we can have. And then when you encrypt under the PK, you send these ciphertext.
00:24:56.966 - 00:25:03.822, Speaker B: So c one Pk and c two Pk to some server. And then the server is going to evaluate based on some function.
00:25:03.876 - 00:25:04.190, Speaker C: Right.
00:25:04.260 - 00:26:39.606, Speaker B: And the idea is that you want to get sort of the encryption of the function of the messages by computing this evaluation circuit. And what happens now is that, okay, well this encryption is actually under PK, right? So maybe I definitely should add here PK. But now the question really is who has the Sk, the secret key corresponding to this public key? And if you say, okay, these two parties have Sk, then, okay, so why did they even encrypt it? Like if they have a common secret, could they have not done something by themselves? Or what if they encrypt different things. And now you say, okay, maybe you would have wanted that every pairwise party has a common key, but what if you need to aggregate things from three different sources? So the key here is that this can get complicated very fast. And the best thing to do is to use this kind of re encryption method where this aggregator is going to actually have the secret key. If that triggered a bell because it can be insecure, I'll say that in a second. But assume for a second that this is a server and it has the secret key, then in some sense what can happen is that this party is going to re encrypt the ciphertext C that is encrypted under PK, to be encrypted under PK one and PK two, where now PK one is the public key associated to a secret that is unique to this party.
00:26:39.606 - 00:26:43.334, Speaker B: And this is also SK two is a secret unique to Bob.
00:26:43.382 - 00:26:43.930, Speaker C: Right.
00:26:44.080 - 00:27:16.706, Speaker B: And of course, as I said, if the owner of SK, if the aggregator has SK, it can decrypt all the values which we don't want. So what do we do? Again, we use the same model as before. We reuse the flow and architecture of the delegates and we distribute the secret key. So how does that look like? Well, I'm going to sort of say a few things about the actual scheme that we use. I won't get into the concrete math. I did put the pictures there because I think it can be interesting to some. But before we see the whole protocol, I want to share these insights.
00:27:16.706 - 00:27:29.334, Speaker B: So the idea here is that again you're going to have a distributed key generation where essentially each delegate is going to generate a different ski individually.
00:27:29.382 - 00:27:29.942, Speaker C: Right.
00:27:30.096 - 00:27:43.438, Speaker B: And then there is sort of a common public key, right. CKP or CPK, sorry. That is going to be generated but for a single message.
00:27:43.524 - 00:27:43.726, Speaker C: Right.
00:27:43.748 - 00:28:21.882, Speaker B: So there is not even interaction between the delegates. It's the one message that is sent to a coordinator and it's securely generated. And then each participant is going to input their data. Xi and you want to essentially have a collective output of f, of x one to x n. And you can see here the functions, right, where you're going to encrypt using the common key. And then you're going to sort of evaluate all of these, be able to evaluate these and have the output be the encryption of these things. And of course if you want to decrypt, you need the secret keys.
00:28:21.882 - 00:28:55.714, Speaker B: But what we said, right, is that we're going to want to re encrypt this ciphertext c prime to the public keys, or the secret keys of each individual participant whose data was aggregated. And the way we do that is by using this sort of re encryption or key switching method. Again, I'll say the following, which is that we don't want the delegates to be able to decrypt.
00:28:55.762 - 00:28:55.974, Speaker C: Right?
00:28:56.012 - 00:29:44.578, Speaker B: So the key switching protocol sort of actually happens. Sorry. So this is actually the generation of the public key, the common public key, just to show that it is done in a single round, where each party samples some randomness and computes something, and then this is publicly aggregated. And what happens is that we can use this idea of collective key switching, where essentially, if you have some ciphertext, you want to essentially compute the partial decryption or the decryption of this ciphertext, and at the same time encrypt it under a different public key, PK.
00:29:44.674 - 00:29:45.320, Speaker C: Right.
00:29:45.850 - 00:30:00.670, Speaker B: But the key here is that we want this to happen purely without the delegates or without the party that does the collective key switching without them seeing the value under the ciphertext. Okay. And this is, by the way, the paper.
00:30:00.740 - 00:30:01.470, Speaker C: Sorry about that.
00:30:01.540 - 00:30:50.650, Speaker B: This is the paper that I'll share the slide at some point. So what does this key switching look like without getting into the details, because again, the homomorphic encryption scheme we use is the BFV scheme, if you are any familiarity with it. But it's based on lattices, and it's definitely not easy to start explaining lattices, at least not in a short time. And the idea here is that again, you have some public key PK prime and some ciphertext encrypted under PK. And each party that owns a secret key is going to compute these values, these h zero I and h one I. And no need to think about the math explicitly, but just to know, to see that it's actually, again, a one round.
00:30:50.730 - 00:30:50.974, Speaker C: Right.
00:30:51.012 - 00:31:00.506, Speaker B: So the parties are using their own secrets as a private input. Si, this is a private input. The rest is all public inputs.
00:31:00.538 - 00:31:01.214, Speaker C: Right.
00:31:01.412 - 00:31:18.174, Speaker B: And what's going to be outputted is the ciphertext encrypted under PK prime. And as you see, the delegates computing this key switching do not know the secret associated to PK prime.
00:31:18.222 - 00:31:18.434, Speaker C: Right?
00:31:18.472 - 00:31:35.766, Speaker B: Because in order to do public encryption and encrypt, you don't need to know a secret. So that should be kept as a heuristic here. And so what happens is that they compute these two elements and then they're going to output those so that there is a public aggregation phase that is going to output the new ciphertext.
00:31:35.878 - 00:31:37.180, Speaker C: Sorry about that.
00:31:38.910 - 00:31:59.154, Speaker B: So you can see that again, this sort of happens in one round. And what you get at the end is this new ciphertext. And now when you encrypt these, you can send these to the different parties. Okay, so maybe these couple of last slides were a little bit math heavy or intensive, but let's kind of put it all together.
00:31:59.272 - 00:32:00.034, Speaker C: Okay.
00:32:00.232 - 00:32:37.274, Speaker B: So again, what happens during this homomorphic encryption flow is the following. At the beginning you have a setup where essentially you have the delegates keys. Each one of the delegates generates a different secret, individually, independently, SK one to SKM. And then let's say the coordinator, again, we can overload, the proxy in the network is going to do the aggregation of the public key. Okay. And again, it's public operation, right. So that can be done and it's secure.
00:32:37.274 - 00:32:55.194, Speaker B: And then what's going to happen that we're going to get, say, Alice, Bob and Charlie? But let's just focus on Alice and Bob for a second, that they're going to each encrypt a value A and B, they're going to encrypt it again using the public key of the delegates PKD.
00:32:55.262 - 00:32:55.494, Speaker C: Right.
00:32:55.532 - 00:33:22.738, Speaker B: The common public key. So they're going to send the ciphertext to the coordinator. And then here, this is where sort of the psi flow and the homomorphic encryption flow come together, where after there is a match, right. The matcher, or the coordinator is going to aggregate the values associated with those matches in the specific way that it's defined.
00:33:22.774 - 00:33:22.974, Speaker C: Right.
00:33:23.012 - 00:33:32.954, Speaker B: Using the specific function. It could be additions, it includes multiplications, it could be sorting, it could be other kinds of things. And the matcher is going to add the ciphertext.
00:33:33.002 - 00:33:33.214, Speaker C: Right.
00:33:33.252 - 00:33:41.022, Speaker B: Again, it's a homorphic scheme. And these are going to be then sent to the delegates.
00:33:41.166 - 00:33:41.858, Speaker C: Right.
00:33:42.024 - 00:34:22.314, Speaker B: But now the key here is that, for example, once Alice, say, signs in again into the system, the system is going to generate the pair route locally. She's going to generate a pair of keys, a new pair of keys, ski and pKi. And then these keys are going to be sent again as well to the matcher, who then is going to send to the delegates, to each delegate the ciphertext, the aggregate ciphertext C and the public key pKA of Alice. What happens is that each delegate, this now is not in series.
00:34:22.362 - 00:34:22.574, Speaker C: Right.
00:34:22.612 - 00:34:33.422, Speaker B: Last time we saw in the PsI setting that there is an in series protocol in some sense. And in here it's actually in parallel. So each delegate is going to have sort of a partial decryption.
00:34:33.486 - 00:34:33.714, Speaker C: Right.
00:34:33.752 - 00:35:23.698, Speaker B: They're going to compute their h values, which are these h values. I just abbreviated them to have to one. But these exact values, and each one of them is going to do the same, and send these h values to the coordinator. And then the coordinator, as you can see here in blue, is going to do the aggregate step, right. If you see here, this aggregate step of adding the different values and outputting the new ciphertext, that's what the coordinator is going to end up doing. And the nice thing about this is that throughout all of this process, neither the matcher nor the delegates actually saw or got to be able to see the underlying values, not a, not b, and not a plus b.
00:35:23.864 - 00:35:24.580, Speaker C: Right?
00:35:25.030 - 00:36:08.994, Speaker B: And then once this process is done, the matcher is going to send, or the coordinator is going to send this newly encrypted ciphertext c prime a, which is the re encryption of the ciphertext c under the public key of Alice. And then Alice finally just takes the secret key and decrypts it and gets the actual result of a and b. In this case, the function is just addition, to simplify it. But again, this could be any function, and it would still give her the actual result of the function. And again, the next nice thing is that all of this is actually secure, as long as one delegate is honest.
00:36:09.112 - 00:36:09.682, Speaker C: Right?
00:36:09.816 - 00:36:43.514, Speaker B: So making sure that the delegates are distributed and then you get the full security is important. And you can now see how sort of the Psi comes together with the homomorphic encryption in order to get some matches and then compute on those matches. And just to kind of wrap up, I know I'm a little bit over time, but hopefully we'll have time for all the q A. We are, of course, thinking about these sort of two next steps. I would say one of them is sort of the idea of proving correctness.
00:36:43.562 - 00:36:43.726, Speaker C: Right.
00:36:43.748 - 00:37:36.750, Speaker B: I've talked to you about security, and that's amazing, because you know that no matter what happens, neither the matcher nor the delegates will be able to get the data. So that's full security on the privacy of the data. But then you get that if one of the delegates even doesn't compute the exponentiation correctly with the right key, or switches key in the middle of the process, or the matcher just decides to leave aside some of the matches, things like this. Of course, that is not detectable at this point by the participant. And that could be a problem, right, in some settings, in some contexts. So correctness is important. And the way we want to solve that is actually by using zero knowledge, zero knowledge proofs, which in the ZK summit event mostly talks about zero knowledge.
00:37:36.750 - 00:37:41.562, Speaker B: And as much as my talk wasn't exactly around zero knowledge. This is definitely an important component.
00:37:41.626 - 00:37:41.854, Speaker C: Right.
00:37:41.892 - 00:38:04.722, Speaker B: So this idea of putting together a lot of different privacy enhancing cryptographic techniques is important. And essentially, if we think about what would the zero knowledge look like? Well, we would need to prove two main things, right. One is that at the matcher, the matches are really done correctly, meaning that there is no false negatives or positives.
00:38:04.786 - 00:38:05.400, Speaker C: Right.
00:38:06.330 - 00:38:23.594, Speaker B: And there are also several techniques for that. And the second point to be proven is around, of course, the integrity of data, right. Because the data that is input by the participant is different from the data that is handled by the matcher. We need to prove that the conversion was done correctly.
00:38:23.642 - 00:38:23.806, Speaker C: Right.
00:38:23.828 - 00:38:33.262, Speaker B: So essentially, we need to prove that the delegates computations was done according to the algorithm, based on some pre committed keys.
00:38:33.326 - 00:38:33.602, Speaker C: Right.
00:38:33.656 - 00:39:16.314, Speaker B: Key shares. And this is definitely an interesting direction. There are many ways of actually instantiating this proof. You could use recursive composition, or you could use multiprover systems. And it's a very interesting direction. And of course, we also have more engineering problems and challenges like data normalization, because different resources and databases will definitely not have the same kind of data. And if you have a name with capitals, letters or numbers with dashes or not, things like this are always important to keep in mind and also ease of deployment.
00:39:16.362 - 00:39:16.718, Speaker C: Right.
00:39:16.804 - 00:39:49.590, Speaker B: When we're talking about combining so many cryptographic schemes, one needs to really be careful around the security and also around sort of what aspects can be automated and whatnot, right. Because here we want to make sure that all the encryption and all the decryption happens locally, say, on the browser or actually local on the computer. Right. And this is really it. There's, of course, a lot of more to talk and to share, but I'm happy to take some questions. So thank you again for listening.
00:39:53.310 - 00:40:18.420, Speaker A: Hey. Okay, there's some great questions in the chat. It's possible some of them have already been answered, so if that's the case, maybe we can move quickly through them. Like for example, Robert asked, but maybe a little bit of a way ago in the production, what real world entity is represented by a delegated. And I think you meant delegated PSi protocol or delegated obvious. I know that you had on the slide at the.
00:40:21.190 - 00:40:52.250, Speaker B: Yeah, I think I get the end. The question which is who represents the delegate or who holds the delegate? And the key here is that they need to be distributed, right. Different Amazon accounts, AWS or Google Cloud, and that different companies, different organizations. And of course, this is a challenge that we need to keep in mind. We are sort of working through that. But that's sort of the main idea, right, that the delegates really need to be distributed for this to be secure.
00:40:52.590 - 00:40:58.510, Speaker A: The next one is, do all delegates need to be online, or does this approach support an N of M scheme?
00:40:59.490 - 00:41:27.030, Speaker B: Do all the delegates need to be online? So the next version of this is definitely kind of a threshold version. So far we're really only doing full delegate online, if you wish. We actually know how to do threshold, but we didn't implement it yet because it's just a little bit more complicated and we have product priorities.
00:41:28.750 - 00:41:33.530, Speaker A: Do delegates refresh their PRS keys per psi instance?
00:41:35.950 - 00:41:51.886, Speaker B: The delegates? Yes. Here I'll just sort of make a translation where by PSI instance we mean essentially all the types of data or all the data that needs to be sort of matched together.
00:41:51.988 - 00:41:52.640, Speaker C: Right.
00:41:53.970 - 00:42:31.754, Speaker B: We do allow for sort of adding more data at a later time. And that's an interesting feature that we have. We have some methods there, but we could also say just refresh the keys for every time some data is uploaded inside of, quote unquote, an instance, or what we call like a topic, essentially. But you need to have some permanency over those keys in order to be able to do the matches.
00:42:31.802 - 00:42:32.400, Speaker C: Right.
00:42:33.890 - 00:42:41.230, Speaker A: Akash asked, doesn't the coordinator have to be honest if it's doing the aggregation of the delegate secret keys?
00:42:42.950 - 00:42:57.794, Speaker B: Yes. So this comes back to correctness. It has to be honest. And the only way to ensure that in this current setting would be to use something like zero knowledge, or at least just a proof.
00:42:57.842 - 00:42:58.150, Speaker C: Right.
00:42:58.220 - 00:43:14.940, Speaker B: It doesn't necessarily have to be zero knowledge because the computation is not secret. But there is a component here of, as I said, correctness is important and we're working through that, but it comes at the expense of other things at this point.
00:43:16.270 - 00:43:25.646, Speaker A: What about the matcher being dishonest? Is the Hepsi, I think this is the same question. Okay, coordinator and matcher here.
00:43:25.828 - 00:43:50.950, Speaker B: Yeah, because essentially one is about the aggregation of the secret keys to generate the correct public key, but the other one is about sort of actually doing the computation on the he or the, again, like the matcher at this point is a trusted entity, but even if it's malicious, it cannot sort of get the actual data of the participants.
00:43:51.450 - 00:43:59.850, Speaker A: Cool. Hubert asked, what circuit depth for the he function have you tested as being practical?
00:44:02.750 - 00:44:43.960, Speaker B: So we've been working mostly with really large amount of additions and some multiplications, maybe like averages and things like this. So it's not like we have a large depth. We are aware that maybe using a fully homomorphic encryption scheme is a bit of an overkill if that's sort of the only computations that we have. But there is definitely a scenario where users are going to start asking for a lot more complex stuff. We're testing some things. They're not ready to be shared at this point. Not optimized enough.
00:44:44.410 - 00:44:58.346, Speaker A: Okay. Victor was asking, is it possible that the coordinator exclude individual records? I guess this kind of goes back to that dishonest question.
00:44:58.448 - 00:45:19.322, Speaker B: Right, so here, this is exactly what I meant, sort of in the. No false negatives or positives, right? Because what this means is that we want to make sure that the matcher, exactly. That does not leave any matches out and does not add any matches that are not supposed to be matches.
00:45:19.386 - 00:45:19.578, Speaker C: Right.
00:45:19.604 - 00:45:30.002, Speaker B: Because if I'm a customer and I just get some matches, I need to trust that those are the actual matches, especially if I'm not interacting with my counterparty.
00:45:30.066 - 00:45:30.680, Speaker C: Right.
00:45:32.650 - 00:45:41.820, Speaker A: Victor actually clarified this question, saying, can the coordinator distinguish individual records, or are all the records bundled and encrypted together?
00:45:44.910 - 00:46:19.614, Speaker B: Well, they all look sort of random to the matcher. The matcher can distinguish in the sense of they know that two records are different. It just doesn't know what the delta is. It doesn't know anything about it. Yeah, it's just sort of random strings all the way. Right? The matcher does get some leakage, in the sense of it knows exactly what two records match. It also knows what set of hashes belong to which party, because he's also acting as the proxy.
00:46:19.614 - 00:46:32.810, Speaker B: So next version, I guess, could also be separating between what we call the matcher, what we call the proxy, and what we call the coordinator, or something like this. I hope that clarifies it. Victor.
00:46:34.670 - 00:46:49.230, Speaker A: Maddie asks, do delegates execute the same partial decryption algorithm independent of their secret keys, or is it to be run under their own secret keys? Their own secret keys.
00:46:50.610 - 00:47:31.254, Speaker B: So here, I think what you mean is this partial, if I understand the question correctly. But please do correct me, Madi, if I'm wrong, is, yes, it's independent. I mean, each delegate has their own secret key, Sk one, Sk two, and so on. And the partial decryption that they do happens completely independent, without any sort of interaction with the other delegates. And that's the nice thing, that there is like a one message to a coordinator or something like this that will aggregate these h values from each of the delegates.
00:47:31.302 - 00:47:31.900, Speaker C: Right.
00:47:33.810 - 00:47:46.050, Speaker B: When designing this protocol, we always try to kind of have a one message interaction in the different parts where interaction is needed because of the distribution of the secret keys and shares.
00:47:49.430 - 00:47:52.900, Speaker A: Doran asked, what psi construction does he support?
00:47:56.410 - 00:48:33.182, Speaker B: Not sure what you mean by mean. We sort of built our own Psi based on several components from different psi papers. And in some sense, what I explained here was that there is like two flows, really. One is the psi flow and the other one is the homomorphic encryption flow. So they can really just be put together as long as you have this ability of. We use the same architecture just in a different order. Let's say first the PSi happens first.
00:48:33.182 - 00:49:09.820, Speaker B: So the first flow for PSi is that the participants talk to the delegates on the upload. And when I say talk, I mean like sort of quotation marks, talk to the delegates on the upload phase. But then after they've gone offline, when they go online again and they want to get the download query, then that's when they interact again with the delegates in order to get the homophobic encryption done right. So I hope that clarifies that. But there is no sort of specific construction in the he.
00:49:11.970 - 00:49:20.000, Speaker A: And I think we have a great kind of last question here. Is this operational or currently in development? Is it live?
00:49:20.850 - 00:50:13.920, Speaker B: So I will say both. You can actually go today and try this out using an Excel sheet. If you go to like Microsoft 365 and go into the Excel there, you can actually download the credit plugin or add on. I don't remember what they call it. And you can use this and try it. I don't think we implemented there the homework encryption, but going back to the answer, like the question, it's operational in the sense that we are working with several customers to sort of work through their use cases. And we're running real data through this, but it's not in deployment yet in the proper sense of the word, where you just go into the website and pay with a credit card and use it or something like this.
00:50:19.270 - 00:50:28.246, Speaker A: Maybe after this chat, if you want to put any links or something into the chat that might actually be useful for any documentation or any way for people to start accessing it.
00:50:28.268 - 00:50:30.454, Speaker B: Yeah, absolutely. I would love it.
00:50:30.652 - 00:50:52.620, Speaker A: All right, so thank you so much, Daniel. Thanks for doing this talk and your first talk at the ZK summit. Very cool. It's a crossover episode. All right, so to everyone else, we will cut the stream here and we'll be back here in about eight minutes for Alex from matterlabs'talk. Cool, see you soon.
