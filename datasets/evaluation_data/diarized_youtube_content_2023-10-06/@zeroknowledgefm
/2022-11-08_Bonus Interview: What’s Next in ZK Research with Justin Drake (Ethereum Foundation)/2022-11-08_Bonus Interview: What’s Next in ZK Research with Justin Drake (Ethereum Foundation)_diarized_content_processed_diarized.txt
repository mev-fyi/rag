00:00:10.970 - 00:00:29.142, Speaker A: Hey everyone, I'm back with Justin and ZK Maven expert interviewer Anna Rose. And we just wanted to talk to you, Justin, about kind of the other things that you're working on in ZK with the EF and sort of any exciting projects that you might have.
00:00:29.276 - 00:01:54.858, Speaker B: Right. So in ZK, specifically where ZK means zero knowledge, we are working on something called secret leader election. And you may have heard of SSLE, where not only is it secret, but also you have a single leader at every round. And basically the problem that we're trying to solve here is that right now on the beacon chain, you know, and everyone knows what the next proposals will be, you know, their cryptographic identity, the pub key, and if you observe the pit to pin network, most likely especially for home validators, you'll be able to assign an IP address to that validator. And so what you can do as an attacker is mount a denial of service attack. And this is bad, because if we have, let's say, 50% of the validators running from home, then basically an attacker can take down roughly 50% of the blocks. And that could be used and incentivized through MEV, basically, there could be attacks that are actually rational to do, and not only is there attacks for external people to come in, but there's actually incentives for validators to start ddosing their other fellow validators.
00:01:54.858 - 00:02:20.200, Speaker B: And the reason is, let's say we have two blocks in a row, so two slots in a row. I know I'm the second proposer, I have an incentive to go ddos, the proposer just before me. And the reason is that all the transactions that come in and all the juicy transaction fees will go to me, if I can ddos and prevent the formation of a block just before.
00:02:20.970 - 00:02:32.874, Speaker A: So this isn't really even theoretical. I think in Solana this is sort of happening by accident, where people are so desperate to get their transactions in, that they're like going to the future proposers and just ddosing them.
00:02:32.912 - 00:02:34.540, Speaker C: Oh, wow. Like the threat is.
00:02:36.110 - 00:02:38.094, Speaker A: Think. I think I could be wrong on that.
00:02:38.132 - 00:03:09.270, Speaker B: No, you're right. I guess it's ddos for a separate reason. So in Solana, they have this optimization where as a user, from what I understand, you send your transaction directly to the next block proposer. And so that's kind of a DDoS vector, but in Ethereum, we actually have a mesh network for gossip. So you send your transaction to all your peers, these peers send the transaction to all the other peers, and so it kind of more evenly spread out to build the mem pool. So it's a different architecture.
00:03:10.990 - 00:03:12.780, Speaker C: At what stages of research?
00:03:13.710 - 00:03:58.982, Speaker B: It's fairly advanced, actually. Okay, so the research I would say is done or very close to being done. And now we have proof of concepts which we're trying to bring to production, basically. Now maybe I should explain where the zero knowledge comes in. Yes. So what we have, the primitive that we have is what we call a re randomizable commitment. So basically every validator has a commitment to their pub key, which they put on chain, and the beacon chain will basically keep track of these commitments in a list.
00:03:58.982 - 00:05:10.366, Speaker B: And what we want to do is we want to re randomize them in such a way that when a re randomization happens, the validator can track their own commitment, but everyone else that's observing can't. It looks like a random shuffle to them. And basically what we do is that we allow every proposer to perform such a randomization, but we need them to prove in zero knowledge that they've done a permutation, meaning that they haven't kind of taken away commitments or inserted their own commitments. And yeah, this is basically where the zero knowledge comes in. And so we have a custom proof system which is kind of a variant of Bayer graph which Mary Mallor has designed. And it's basically the only ZK kind of primitive that we have on Ethereum layer one, except if you consider signatures to be ZK in the sense that they don't leak the private key.
00:05:10.468 - 00:05:17.506, Speaker C: Would you call this like ZK inconsensensis or what part of the stack would you call this?
00:05:17.688 - 00:05:53.690, Speaker B: Yeah, so it's using zero knowledge proofs as a tool for one of the building blocks, one of the modules. So the way that I think about the layer one is that you have multiple modules. You have the randomness module, you have the secret leader election module, you might have the registry module, you might have the finality gadget and all of these other modules. And from the point of view of an application developer, or from the point of view of a user, you don't get to see all these modules. They're kind of abstracted away and packaged to you through the properties of the EVM.
00:05:54.050 - 00:05:55.406, Speaker A: Cool, very cool.
00:05:55.508 - 00:06:03.774, Speaker C: At what point does that actually get implemented? Would it come with the merge or are we thinking it's going to come way later?
00:06:03.892 - 00:06:11.362, Speaker B: Great question. So for the merge we have a strategy of a minimal merge, meaning that we do the merge and nothing else.
00:06:11.416 - 00:06:12.020, Speaker C: Okay.
00:06:13.430 - 00:07:07.090, Speaker B: If the attack that I described in a lot of service attack happens, then that could be an incentive for us to accelerate deployment of secret leader election. So we kind of have this in our back pocket if we do see the attacks. If not, then I guess there might be higher priority things, for example, deploying what's now called dank sharding, or the first step being proto dank sharding. But I am a little bit worried because this denial of a service attack vector is probably the lowest hanging fruit for an attacker with just a few thousand dollars and some investment. From a development time perspective, they can relatively easily harm the ethereum chain.
00:07:07.510 - 00:07:12.050, Speaker C: Can you say the name of the Zkeg thing again, just for our listeners?
00:07:12.130 - 00:07:23.942, Speaker B: Yeah, sure. So you have various proof systems. Where we have planck, we have graph 16, and here it's kind of one of the earlier ones called Bayer Groff.
00:07:24.006 - 00:07:25.930, Speaker C: Is this before graph 16?
00:07:26.270 - 00:07:28.182, Speaker B: Yes, I think it's before graph 16.
00:07:28.246 - 00:07:28.522, Speaker C: Okay.
00:07:28.576 - 00:07:50.622, Speaker B: And the reason why we can use kind of one of the older proof systems is because the statement that we're proving is very structured. Is this proving that you've done a permutation properly? And so instead of having a general purpose SNOC proving scheme where for arbitrary circuits or arbitrary empty statements, we're only proving this very structured statement.
00:07:50.766 - 00:07:53.678, Speaker C: Would you need a trusted setup for this somehow?
00:07:53.854 - 00:08:03.970, Speaker B: Great question. The answer is no. Okay, so you can basically use a bulletproof style commitment, the same commitments as with Nova.
00:08:04.050 - 00:08:04.630, Speaker A: Cool.
00:08:04.780 - 00:08:12.330, Speaker C: Nice. Very cool. So I guess if people want to find out about this, where can they read up on this type of stuff?
00:08:12.480 - 00:08:24.870, Speaker B: Great. So we have a full spec of secret leader election, which we call whisk. Because you're whisking the set of validators.
00:08:24.950 - 00:08:27.600, Speaker C: You didn't want to use the term mix, I guess.
00:08:28.290 - 00:08:29.758, Speaker B: Yeah, we have so many, I feel.
00:08:29.764 - 00:08:33.198, Speaker C: Like that's loaded somehow. Whisk is good. I haven't heard that.
00:08:33.284 - 00:08:58.946, Speaker B: Whisk is great. So we have George, who basically came up with whisk, and he wrote an e research post which has all the links to the paper by Bear Groff, but also the modification by Mary Mallor, as well as proof of concept implementations of WISC in rust.
00:08:59.058 - 00:09:09.350, Speaker C: Cool. Yeah, that's awesome. So, yeah, thanks so much for sharing with us this kind of like update or something else to look for in the work you're doing with CK.
00:09:09.430 - 00:09:31.358, Speaker B: Yeah, absolutely. It's an important incremental security upgrade for Ethereum. And if you look into the roadmap, actually a lot of it is just incremental security upgrades. VDfs is one of them, data availability sampling is one of them. And yeah, there's a few more out there as well.
00:09:31.444 - 00:09:32.080, Speaker C: Nice.
00:09:32.450 - 00:09:34.398, Speaker B: Very cool. Thanks.
00:09:34.564 - 00:09:38.630, Speaker A: Thanks, Justin. Thanks. Z came given Anna Rose.
00:09:39.130 - 00:09:40.680, Speaker C: New name every time.
00:09:42.330 - 00:09:44.050, Speaker A: Thanks everyone for watching. Cheers.
