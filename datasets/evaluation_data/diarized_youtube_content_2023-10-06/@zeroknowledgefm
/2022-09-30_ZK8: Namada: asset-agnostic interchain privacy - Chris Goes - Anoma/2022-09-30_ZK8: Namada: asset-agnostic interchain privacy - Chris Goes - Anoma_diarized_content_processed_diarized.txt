00:00:06.730 - 00:00:24.240, Speaker A: So next up, we are going to be inviting Christopher goes from Inoma to the stage to talk about asset agnostic interchange privacy. So welcome, Chris. Give him a hand.
00:00:27.130 - 00:00:47.994, Speaker B: Thank you. According to the schedule, at least lunch is directly after this talk. So now is a good time to sit back, enjoy, let your brain process a little bit of cryptography and prepare for lunch. And if you're really tired, lunch is coming soon. If you're standing out there talking, you could sit here and then you could go to lunch. It would be a good prep. Okay.
00:00:47.994 - 00:01:14.558, Speaker B: I'm Christopher. I work on enoma. Confusingly, because this talk is about something else, obviously called damata. We name all of our products different things and give them different color schemes to be determined whether this is the correct strategy. But it is on purpose. And this talk, in contrast to many things here today, which have touched upon what you might call like new, shining, cutting edge, as in both it's new and shiny and it might actually cut you if you use it improperly. Cryptography.
00:01:14.558 - 00:02:10.706, Speaker B: Namada is about old and boring cryptography, except that old and boring in blockchain time means like two years. So not really old in other sorts of cryptographic time. But Namada is here. I'm going to refer to an excellent blog post by, I think, moxie Marlin Spike, the original creator of Signal, which talks about how in order to craft products which actually protects users'privacy and practice, you need to strike a really nice synthesis between designing the cryptographic scheme and thinking about the user experience. And you need to think about those both at once, because if you don't think about them at once, you're going to end up with fancy cryptography that nobody uses, or you're going to end up with something usable that doesn't provide any. You know, it's easier to do that when you use things which have been around for a little bit longer and think about a very particular product. So Namata is our effort to do that for interchange privacy.
00:02:10.706 - 00:03:05.602, Speaker B: Let me explain what that is, but first, let me give credit. Nemada is built mostly by people who are not me at heliax. And you can see very small pictures of, I think, almost all of them here, but particularly you can find Abba and Adrian and myself, who are larger, not because we are more important, but because we are here, at least so you can find us and please ask us any questions. Heliax also does a lot of other stuff, and we're happy to talk about that as well. So I'm only going to spend one slide on this because I think it's preaching to the choir. But why does privacy matter? Why might you want to care about it or spend time designing systems which are private? I think there are more reasons than just protecting individual privacy is not only individual, it's also social. And perhaps sometimes the individual aspect is overemphasized.
00:03:05.602 - 00:03:58.866, Speaker B: Particularly, privacy is important for national community defense, for defending against kinds of propaganda which really rely on the ability to collect a lot of data. Privacy is important, of course, for the protection of individual rights. That's probably the most common argument. I think it's important to protect against not necessarily not only violations of sort of civil rights, but also surveillance capitalism, leading to a kind of profit driven nudging or mass propaganda which doesn't in the individual instance necessarily seem so egregious, but can have pretty bad impacts over time. And last, but certainly not exclusively, at least, privacy is kind of the historical default. It's easy to forget that until recently, we didn't live in a world with nation states and great amounts of surveillance. And if you took someone from 50 years ago and plopped them in today, they would find us all very strange and wonder why we haven't overthrown our governments.
00:03:58.866 - 00:04:43.862, Speaker B: And I've got to agree with them, to be honest. Okay, so probably you're already convinced, and I don't need to convince you. Anyways, let's talk a little bit about what choices would you have as a user if you wanted to get privacy today in blockchains. And of course, many of the things people have talked about today offer additional options that aren't on this slide. This slide only includes things that are live and in production. So so far users have had the choice of really two kinds of privacy options. Looking at the interchange landscape, they've had the choice of a sovereign chain which reissues assets, of course, first to this space, and really the pioneer of zero knowledge proofs in this distributed systems context at all was the zcash project.
00:04:43.862 - 00:05:23.230, Speaker B: Then ironfish and some like ycash forks as zcash. Other kinds of sovereign chains based as zcash was on the bitcoin monetary policy and sort of single asset, single blockchain mentality issue their own assets. And at least at the moment, the only asset supported on zcash, ironfish, ycash, these other chains is the native asset. So if you want to, you can achieve full transactional privacy using these systems. But somehow you have to get the native asset zec in the case of zcash, and you have to use it. And that comes with some trade offs, which I'll discuss in a second. The other options available are privacy preserving solutions which are built on some smart contract chain.
00:05:23.230 - 00:06:07.330, Speaker B: So tornado, Cash, Masstech. There's some others on Ethereum which offer usually not quite as good privacy as zcash, mostly due to gas costs and just the difficulty of constructing these circuits and interoperating with the curve supported by Ethereum, but much better privacy than you would get using public Ethereum. But both of these options come with trade offs. So if you as a user choose to use a software chain which reissues assets, you have to use the asset, and often the asset is not the one that you want to use. Like this is not a super complicated argument. In particular, the economic properties of bitcoin, while interesting, are just awful for spending money. Usually you don't want to hold a very volatile asset.
00:06:07.330 - 00:07:18.280, Speaker B: Deflationary monetary policy is an interesting economic experiment, but it's not necessarily going to be correlated at all to the cases or scenarios or sort of everyday contexts in which you as a user want privacy in particular, and like transactional contacts, often you want privacy for payments or privacy for things that you're doing other than holding the asset. And this monetary policy is not really well suited to that. Privacy solutions on smart contracts chains are generally much more flexible with regards to which assets you can use, but they tend to offer less privacy than zcash. They are more expensive, at least on average at the moment. And as we've seen recently, they're somewhat more vulnerable to censorship, both perhaps because there are real reasons they're more vulnerable to censorship, like the cost of censoring and the ability of, say, ethereum block producers to deep censor tornado cash transactions. It's easier to do that. And also, I think, the optics of smart contract privacy solutions, as opposed to baking privacy into a full system by default, make it sort of more likely to be censored based on the way these systems are understood at the moment.
00:07:18.280 - 00:07:50.718, Speaker B: So what do users want? We postulate that users want simple, understandable privacy. They want it for any asset, most notably the asset they want to use. But we don't really know what that is as systems designers. They want it to be fast and cheap and strong security guarantees. Users want everything. Of course they do. And then the final piece of this kind of puzzle of trying to sketch what the design problem is, is that users nowadays live on the interchain, which is this sort of ephemeral space of a lot of blockchains, connected in a lot of different complicated ways with a lot of assets.
00:07:50.718 - 00:08:51.958, Speaker B: It's all very heterogeneous, but users live there, so we have to go there. Users are going to use many assets. They're going to use them across many chains and many applications. And most relevantly, with regards to how we design private systems, users are going to interact with those assets across those chains, kind of like automagically, by which I mean there will be, of course, systems of bridges and messaging protocols mediating all of these interactions. There's a specific way in which it happens in practice, but users are not necessarily going to understand it all of the time. They are going to click buttons and deposit into bridges and send funds, and they're going to have an asset because they know assets and they're going to want it in a place like an application place on another chain because they know applications and they are going to click the buttons that gets their asset there. And the user is not going to think every single step of the way on like what bridges are my assets being sent through? Do I lose privacy sometimes? What are the complex implications of this whole imperative execution chain? Users are just going to kind of click buttons and their assets will move.
00:08:51.958 - 00:09:15.546, Speaker B: So we need to design for this world if we want to provide privacy to users. We need to expect that they will not understand all of the functional details of how these systems work. Yeah, and adversaries are going to be smart and they will target the weakest link. The weakest link is probably not your cryptography assumptions. They would be great if it was eventually. Hopefully we get to that world. The weakest link is going to be a bridge.
00:09:15.546 - 00:09:47.858, Speaker B: It's going to be an implementation bug. It's going to be like the query system by which users are fetching state. The adversaries are going to go after the weakest link. And the time to head off a future surveillance, as long as we're not already too late, is now. Okay, so this is what Nomada is trying to do. Nomada is trying to provide privacy to users in this interchange world, making these kind of very rough assumptions about how those users behave. And Nomada has three phases of deployment, which I will outline in the rest of these slides, focusing mostly on the first.
00:09:47.858 - 00:10:20.002, Speaker B: The first is a sovereign chain that provides asset agnostic privacy. The second, sort of codenamed privacy like company, adds a lot of bridges to interoperate with other systems. And the third hint Hint makes those bridges private because that makes privacy win win. And later I will explain why. So let's go to the first phase. First phase one is simply a blockchain that provides asset agnostic privacy. Most of this is old in the sense of like a year or two old.
00:10:20.002 - 00:10:48.374, Speaker B: So old in blockchain terms, Nemata is built on top of tendermint consensus. Well, actually we use an unreleased tendermint version, but we will be using tendermint with Abci plus, which is not Abci Plus plus, but soon it will be. Marco's going to kill me. Sorry, Marco. Tendermint's amazing. It has so many ABCI versions that we can choose exactly the one we want. Nemada features both cubic slashing and a trust minimized Ethereum bridge, which I'll talk about briefly.
00:10:48.374 - 00:11:23.874, Speaker B: But mostly I will talk about how we do multi asset private transfers and how we crafted a incentive scheme to treat privacy as a public good and why. First, multi asset private transfers. So Namata features something called the multi asset shielded pool. The multi asset shielded pool allows users to do kind of exactly what it sounds like, which is send money privately using any asset. In particular, the multi asset shielded pool allows us to provide a shared privacy set for all fungible and non fungible assets, just tokens. And it has small and efficient proofs, keys for optional disclosure. It's available on the Internet.
00:11:23.874 - 00:11:45.854, Speaker B: I know you can't. I considered making the links like the full thing, but then it was just super long. So you can find the slides online and click the links. It really is online. It's not fake. But the basic idea of the MASP is to provide one large shielded pool for everything, so that when an observer looks at the blockchain, they have no idea what asset you were using. And even anyone validating the model has no idea what asset you were using.
00:11:45.854 - 00:12:17.494, Speaker B: So it's quite difficult to censor. How do we do that? Well, basically a way of summarizing how the multi asset shielded pool mechanism works is it's like multi asset privacy with just one weird sort of cryptography trick. The masp starts from, as I said, old crypto, quote, unquote, the sapling circuit. All of the really hard work in the sapling circuit was done by the electric coin company. Some reason I wanted to call it the elliptic curve company. I wonder if that was intentional. Okay, the elliptic curve company, also known as the coin company, they did like all of the real work.
00:12:17.494 - 00:12:37.790, Speaker B: We just kind of modified it a bit. So all credit to Dara and stradd and some of the amazing circuit designers at ECC. The masp works by adding an asset type to each node, calculating an independent value base for each asset type. And that is surprisingly enough. So let me explain why. Let's go back to sapling. I know sapling is old.
00:12:37.790 - 00:13:03.474, Speaker B: Do some people remember sapling? Who remembers sapling? If you've used zcash in the past few years, you've probably used, you know, slightly in the past or to turnstile your assets. So sapling in two slides. First slide notes. Value in sapling is stored in notes. So it's like the Utxo model. And notes in sapling consist of four elements. You can think of notes as a tuple with four elements.
00:13:03.474 - 00:13:42.638, Speaker B: The first element and second element are the diversifier of the recipient's shield of payment address and the diversified transmission key of the recipient's shield of payment address. So these are just to specify who can spend the note. V is the value of the note just a integer, and RCM is a random commitment trapdoor. So we see here that there is no specification of what asset because sapling only supports one asset. Zcash or a sec. How do we check that a transaction balances? So sapling uses this cute balance check based on homomorphic Peterson commitments. And the cool thing about homomorphic Peterson commitments is that they are homomorphic.
00:13:42.638 - 00:14:10.026, Speaker B: So you can do this. You compute commitments, value commitments for each you see here, there are four notes involved. So these are two spends and two outputs. And you compute value commitments using something called Gzac, which is the value base for zac, which just in the sapling protocol is just a constant. Then v one, v two, v three, v four. Those are the specific values involved in your transaction. And r one, r two, r three, r four along with a value commitment randomness base.
00:14:10.026 - 00:14:55.018, Speaker B: Those are randomness like traptos. So you can use this to compute the value commitments. And then the second check actually happens public because these are like homomorphic, so they don't reveal your values. You check that when you sum the spends and subtract the outputs and subtract the value balance, the transparent difference. So if you're like shielding or unshielding value balance is nonzero, you check that that's equal to h raised to the binding secret key. So this because these commitments are homomorphic. Hold if and only if your values actually balance, which means that the sum of your spends less your outputs is equal to the difference in transparent value change.
00:14:55.018 - 00:15:32.354, Speaker B: And you actually knew the randomness. So we can modify this by just adding new value bases. The first way we do this. So the first thing we want to do in the masp is to add an asset type. And this is quite simple, just take our four tuple note all the way back from the original sapling and add. We're actually going to create three things here because we need to do some user friendly derivations. So we first start out with the asset name, and the asset name you can think of as like bitcoin or ethereum or like my fun penguin token.
00:15:32.354 - 00:16:25.286, Speaker B: The asset name is the thing users are going to know and refer to the asset by from the asset name. Using it doesn't really matter from the circuits perspective, but using a hash function we can derive the asset identifier, which is a 32 byte string, so fix length string that uniquely identifies the asset. A slight caveat to this, or just a point note, which I'll explain in another slide, is that the asset identifier, not every 32 byte string is a valid asset identifier. We want it to be a valid, sorry, we want it to be a blake two s pre image of a valid asset generator. So we use some simple rejection sampling to derive asset identifiers from asset names. And this just simplifies our life, otherwise it would be more annoying. The asset generator is a valid twisted debris curve point on jubjob and that's what we actually use as the value base.
00:16:25.286 - 00:17:09.822, Speaker B: So if we go back here to this balance check and sapling, you see that thing Gzec, that's the value base for zec and it's just a constant. And the only thing we're really changing in the MASP is that we're computing that value base now kind of dynamically, and we're computing separate independent value bases for different assets. So how do we do that? We take the asset name and we derive deterministically some asset identifier that needs to be valid. And for it to be valid, we need the blake two s image of the asset identifier to be a valid twisted embrace curve point. And there are actually three ways that can fail. So what are they? One, it could be a small order point. This is very unlikely, but we still need to test for it.
00:17:09.822 - 00:17:53.586, Speaker B: Two, it could be an integer, which is at least the order of the underlying field, which you would think we could take modulo the order. But the problem is that's not uniformly random, and we want it for security property reasons, to be uniformly random. So we reject those and we reject when there's just like no point with the given y coordinate, which happens approximately but not exactly 50% of the time, and just iterate anonce until the asset identifier is valid. So using that method, we can derive from an asset name which is going to be like tracked in the protocol. There'll be some registry of assets. We can derive asset identifiers that correspond to valid asset generators. Any questions on this so far? Cool.
00:17:53.586 - 00:18:30.714, Speaker B: So now we modify the balance check and the only thing we're doing is we're just using our additional value bases. So here instead of Gzec, we have ga one and ga two. Those are the value bases for asset one and asset two. We compute the input and output commitments as before, just using these different value bases. And the only thing we do to modify the balance check is that we add there can now be vb one and vb two are transparent changes in asset one and asset two. And as many assets as you have, there can be that many transparent balance changes. Of course we can look at what the zero ones we don't need to bother computing.
00:18:30.714 - 00:19:34.158, Speaker B: But because the value bases are independent and we still have homomorphic Peterson commitments, this holds only if the assets balance independently. So if I have five x and five y and spend to create five x and five y, this first v one minus v three will check that like five x equals five x, and the second v two minus v four, will check that five y equals five y, which is the property we want. We want to check the balances are independently conserved. And the basic security property here is that assuming the elliptic curve discrete logical problem is hard provers could not obtain a relationship between these generators. So we have the kind of regular security here, and as a result we get multi asset privacy. Multi asset children pool transactions can include spends of any number of assets. The observers cannot, including the validators of namata, cannot distinguish which assets are involved.
00:19:34.158 - 00:20:26.906, Speaker B: And we retain all the great benefits of sapling, viewing, key derivation, et cetera. But let's go back to our users, and our users are lazy and they are strategic and they want to do things which are cheap and they want to only pay for something like privacy when they need it. So we can think about privacy as a public good in the following way. For most transactions, users probably don't care about privacy or if they consciously reflect on it. Do I really need privacy for buying coffee? I mean, am I going to get prosecuted for buying coffee in this specific instance? Probably the answer is no. And if I have to pay for this, I'm only really going to pay for privacy. Or if I have to go through extra trouble to get private transactions, I'm only going to do that when I have some strong reason to do that, because the private benefit for me of transacting privately is low or kind of negligible.
00:20:26.906 - 00:20:51.574, Speaker B: Or hard to think about except in specific cases. But there's a public benefit to my transacting privately. Which is that even if I don't care about whether this specific transaction of buying coffee is private. When I choose to do that transaction privately instead of publicly. Other people get a larger shielded set. So there's this public benefit. And for this reason, we think that this public benefit of privacy.
00:20:51.574 - 00:21:09.490, Speaker B: Should be somehow captured. In the incentive design of private systems. Because when a user makes this choice. We want them to. If they are giving benefits to other people by transacting privately. Even if they don't receive private benefits for doing it. And if we can find some way to send a little bit of that flow of that value.
00:21:09.490 - 00:21:25.718, Speaker B: That other people are getting back to the individual. Then we have a system which is better incentive aligned as a whole. And people will have more privacy. So for this reason, we made another circuit. And a traditional to no modest tactic. Of taking the sapling circuit. And modifying it.
00:21:25.718 - 00:21:42.490, Speaker B: In the minimum amount of ways possible. This is a separate circuit. But it kind of interoperates very cleanly with sapling. And I will explain how. So the basic idea here is that designing incentives for private transactions. Is actually really hard. For some pretty fundamental reasons.
00:21:42.490 - 00:22:01.442, Speaker B: There are kinds of. You have to balance between wanting to design an incentive mechanism. That gives people a reason to transact privately. And not suddenly making yourself vulnerable to denial of service. And not incentivizing garbage. Because the thing you want to incentivize is like real transactions being private. And the protocol has no idea what a real transaction is.
00:22:01.442 - 00:22:21.430, Speaker B: So it's like there's some fundamental impossibility there. But what you can do, which is slightly more limited. Is incentivize value at rest being private. Which means that if people keep value in the shielded pool. They can accrue some incentives. And if people sort of transact, there's a layer of indirection here. But if people are transacting privately by default.
00:22:21.430 - 00:22:42.190, Speaker B: And keeping their value in the shielded pool as a virtue of that. They will receive incentives for this. So we built a circuit called a convert circuit. Which just does that. It distributes rewards proportional to the amount of a particular asset. And the length that amount has been in the shielded pool. Multiplied by some proportionality constant for the asset.
00:22:42.190 - 00:22:56.590, Speaker B: This works by. Actually, it works by making assets non fungible. But because we're in the shielded pool. We're okay with this. Because it doesn't entail loss of privacy. So basically, we tag in our system. We have quantized time, but it doesn't matter.
00:22:56.590 - 00:23:25.662, Speaker B: You could also do this without it. We have proof of stake epochs, say once a day, and we tag assets with an epoch. So instead of it being like Xcoin, it will be xcoin epoch one, xcoin epoch two. Users can use the convert circuit to upgrade their assets to the latest epoch, and when they do that, they can claim some rewards. So what this means is that assets earn a kind of I'm not sure about this term. We're going to have to think about it. Yield is dangerous, dangerous word.
00:23:25.662 - 00:24:03.594, Speaker B: But assets earn a sort of privacy yield over time, which differs from defi yield in that it is risk free. You're not like taking amm, impermanent loss risk something else. It's just a subsidy for providing privacy for other users as a virtue of holding value at rest. And it's important to note that this is not. I mean, there are multiple kinds of privacy. So if you think about the zero cash style, zcash style, and masp style transaction models, you might care about privacy in terms of what inputs could your transaction potentially have come from. And this incentive mechanism is very good for that, because it incentivizes value at rest.
00:24:03.594 - 00:24:54.454, Speaker B: And value at rest corresponds pretty directly to potential inputs which your transaction could have come from. But you might also care about privacy, like how many people sent transactions within this ten minute time window? And given that I sent a transaction, how big is my anonymity set there? This cannot be incentivized, so we can't provide that, except indirectly by this incentive mechanism, giving users a reason to have more transactions just be private in general. I can repeat the question. The question was, before I go on, can I explain what users upgrade assets to the latest epoch and claim rewards means? Yes. Can you give me one slide in between? Thank you. So how do we do this? I promise we'll explain it. We made the circuit called a convert circuit.
00:24:54.454 - 00:25:38.306, Speaker B: The convert circuit does another magic trick with homomorphic Peterson commitments. It's the same magic trick, we just do more of it, actually, that allows minting and burning of assets according to fixed and public ratios. So the masp alone, if you recall to the balance check earlier, just checks that the homomorphic value balance is zero. But the Masp with the convert circuit checks that either the homomorphic value balance is zero, or that it is an allowed non zero conversion. How do we do this? So the convert circuit, very simple, it takes an allowed conversion, is just defined as a list of tuples of some asset and integer. And these can be negative. So you might take one asset and convert it to another asset.
00:25:38.306 - 00:26:26.022, Speaker B: Then the first would be negative, the second positive. The convert circuit takes a public input of a Merkel route, and the value commitment that you want to prove is valid. It takes a private input of path and position, which are just inputs to the Merkel proof, the conversion commitment, value commitment and some randomness trapdoors and checks that the commitment that you're using is a valid commitment inside the Merkel tree. So why do we need a circuit at all? The reason why we need to circuit at all is because we don't want to reveal what conversion you're using. If we revealed what conversion you're using, it would reveal which assets are involved in the transaction. And that's the thing we wanted to make private. But all this allows you to do is change the balance check.
00:26:26.022 - 00:27:16.440, Speaker B: So now we get to add this term to the balance check. So if you recall back to the multi asset shielded pool balance check, we just had these like value commitment in minus value commitment out. And here I emitted the transparent balance change equals zero with the convert circuit. Now we check that the value commitment in plus this new term, this value commitment convert minus the value commitment out is equal to zero. So this means that the difference here can be, because we have the Cb convert term, and Cb convert can be a valid value commitment for any conversion which is in the Merkel tree, which we just proved with the convert circuit. This means that the difference is allowed to be a multiple of an allowed conversion. And because again, these are homomorphic commitments, we can check this while preserving privacy of the assets involved and which conversion, relatedly, which conversion was used.
00:27:16.440 - 00:27:55.134, Speaker B: So let me explain a little bit more about the epoch mechanism. So the idea here is that when I, as a user, deposit assets into the shielded pool, those are going to get, you can think of them as getting tagged with the epoch. So I have Chris coin, right? Who wants to accept Chris coin? I have Chris coin and I deposit Chris coin into the shielded pool. The current epoch is ten. So this now becomes Chris coin ten and Chris coin ten. If someone deposits Chris coin tomorrow, that will become Chris coin eleven. So these seemingly seem to be non fungible assets, which is weird.
00:27:55.134 - 00:28:39.518, Speaker B: But because we have this masp, we already have asset privacy. So you're not really losing any privacy by doing this. You're just always converting to the current epoch. Then in this convert circuit, or in this conversion merkel tree, we add tuples. And these tuples allow you to convert assets of past epochs to assets of the current epoch, and they might, if you're lucky, allow you to claim some additional asset. So particularly in Nemata, we have a native asset called Nam, and Nam can be minted via some calculation as rewards for keeping assets locked in the shielded pool. We do this with PD controllers, which I'm going to skip because I don't have enough time, but it's like EIP 1559 plus plus just with an additional D term.
00:28:39.518 - 00:29:16.714, Speaker B: So as a user, I can convert from assets of some old epoch to assets of the current epoch, and I can claim some rewards. And this can be mostly abstracted away from users. When you withdraw from the shielded pool, you'll always convert asset of the current epoch, just the regular asset. So it's as if you were using something without this epoch tagging. The epoch tagging is a pretty invisible mechanism to allow these rewards to be calculated. So phase one asset agnostic privacy chain I'm going to skip these two slides, sorry. Phase two is adding bridges to other privacy ecosystems.
00:29:16.714 - 00:29:56.970, Speaker B: Why privacy loves company we actually put together a proposal for a bridge to zcash. You can find it on the Zcash community forums. We might build a bridge to alio unless someone else does, in which case we don't need to. Penumbra thankfully uses IBC, so all of our work is done for us. And the important part here is starting to think about privacy as a promise to users. So safe use of technology is conditioned not only on the cryptographic capabilities of the underlying protocol, but also on users understanding how it works and what kind of privacy they get. And I think it would be good if we start thinking about a wallet that only supports chains which offer this strong privacy model, right? Because that's a credible promise you can offer to users.
00:29:56.970 - 00:30:53.686, Speaker B: But now in this world of separate privacy chains, we live on privacy islands. And you can admit you've also done it. Once I looked up, okay, are there private islands in the world? Can I get a private island? And there are all these advertisements for private islands in the Bermudas. And I thought about it, I think these people don't understand what privacy means, because if you were the only person who owns an island and I have satellite photos, you have an anonymity set of one, right? So privacy islands kind of suck. And they also suck in this case because private islands mean that we're competing on privacy. If you lose privacy whenever you move between islands, then if I use your chain instead of some other chain, you get more privacy, but the other chain, and users of the other chain get less privacy so these private islands have to compete for users to maximize the privacy they can offer, which is sad. So, in phase three of Namada, we're trying to make privacy win win, and we just do that with private bridges.
00:30:53.686 - 00:31:29.750, Speaker B: How do private bridges work? Well, in principle, it sounds very simple. You just keep the transfers over bridges private. If you have a zero cash style note model, you could just send the notes over IBC or something. And this allows all chains to share a privacy set, which means that if I use one private chain which is connected to another private chain, both their anonymity sets increase, which is great. The one small stag we hit here is fault isolation. So let's go back into IBC's security very quickly to explain what this means. So IBC provides very strong fault isolation because it was designed by paranoid people.
00:31:29.750 - 00:32:10.422, Speaker B: And so far, this has not been necessary. But IBC is designed for a world where not only validators, but also whole blockchains are byzantine. And this design allows us to provide permissionless interoperability, which otherwise very hard. Fault isolation in IBC works via something called balance tracking, which is exactly what it sounds like, which means that each chain tracks balances of other chains. When I send from chain a to chain b using IBC, chain a tracks which assets have been sent to chain b. When chain b sends them back, chain a makes sure that chain b is not trying to send back more assets than it was originally sent in the first place. So this requires metering of how many assets are flowing from one chain to another.
00:32:10.422 - 00:32:56.790, Speaker B: Privacy, of course, seems like it will just break this. Because if you want to provide privacy on amounts and assets, then how can you meter which amounts of which assets are going to the other chain? And without fault isolation, at least in the long term, bridges just probably won't work because there will be byzantine chains. So what do we do? We add more cryptography. Simple way of doing that is that we keep an encrypted counter for chain balances, and we increment and decrement the encrypted counter in the standard ICS 20 as a reference to the IBC crosschain transfer spec. We increment and decrement the counter in the standard ICS 20 fashion. And then we somehow make sure that we can test that it is non negative when we send back from b to a and to somehow. Here, the third bullet point is the part that's actually hard.
00:32:56.790 - 00:33:27.566, Speaker B: And we're currently trialing a few protocol designs, one based on NPC and some threshold decryption. To do this non negative test as efficiently as possible. The great part about this design, it requires some fancy cryptography, but it gives you both things that you want in all of the ways that you want them. You retain full privacy and you retain the full IBC standard fold isolation. So we actually do have a draft protocol for this on hackamd. I think you can find it if you click that link in the slides. Okay, very quick shout out.
00:33:27.566 - 00:33:45.700, Speaker B: There's a namada. I have 1 minute left. There is a namada trusted setup. It's happening like very soon, in a few weeks. Please participate in it. It would be super helpful and hopefully phase one will launch later in the fall. Thank you, and I probably don't have time for questions, but thank you very much.
