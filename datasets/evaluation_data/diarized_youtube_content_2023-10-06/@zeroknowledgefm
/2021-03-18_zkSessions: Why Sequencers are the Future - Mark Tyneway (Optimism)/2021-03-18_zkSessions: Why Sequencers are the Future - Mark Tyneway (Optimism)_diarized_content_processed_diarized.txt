00:00:05.400 - 00:00:12.510, Speaker A: Next up, we have Mark Tineway from Optimism PBC, talking about why sequencers are the future takeaway. Mark.
00:00:12.880 - 00:00:58.632, Speaker B: Cool, thank you. Yeah, so like anna said, my name is Mark, and I'm here to talk about sequencers and why I believe sequencers are the. Yeah, I work for optimism PBC. We are working on optimistic roll up, and part of our architecture is based on a sequencer. So real quick, just what is a roll up? Everyone here probably knows what a roll up is, but basically it's a method to increase stateful blockchain throughput and throughput. Because scalability versus throughput, you got to be on point with your words. Some interesting things is that it decouples the execution from the consensus.
00:00:58.632 - 00:02:05.330, Speaker B: Right. It allows us to build systems where we can just come to consensus over the data and then we can kind of change the execution model and users can opt in whether or not they want to perform that execution or not. So basically, validating a roll up means that you have to basically validate all of l one and the roll up, if you choose to opt into executing that roll up. And if there's a roll up state that you don't care about, you don't need to execute it. So it gives this nice property of users being able to opt into what they want to basically verify the state of or get the state of. And it allows us to make alternative runtimes without major changes to layer one, which is cool because the EVM is great for some things, and maybe there's an alternative runtime that is better for other things. So what is a sequencer? So it's basically this off chain entity that users can send transactions to.
00:02:05.330 - 00:03:20.840, Speaker B: And basically this sequencer will then take those transactions and batch them up and send them to layer one. And the sequencer is responsible for the ordering of the transactions. And the design space for what a sequencer is, is very large. So in particular, the optimism sequencer is responsible for receiving the transactions from the users. And then it takes the transactions themselves, the actual data, and submits them to one smart contract on layer one called the canonical transaction chain, which is just basically, you can think of it as like a list of transactions, and then it also takes the state routes, and it basically publishes all the corresponding state routes to a different contract called the state commitment chain. And basically you have these two lists that correspond with each other, and where for each transaction in the canonical transaction chain, there's a corresponding state route, and this is the post state route. So after the execution of the transaction in the state commitment chain.
00:03:20.840 - 00:03:43.472, Speaker B: And just a shout out to Giorgios. He actually wrote this. I took it from his awesome post. You can see the link research paradigm. XYZ slash optimism. It's like a really good resource if you're interested in the low level details of the system. Cool.
00:03:43.472 - 00:03:44.930, Speaker B: So any questions?
00:03:49.700 - 00:04:02.970, Speaker A: None, actually. Thank you, Jessin. I hope I'm saying name right for sharing all those links. Yes. So all of the links you've just mentioned, there's actually somebody who's sharing those in the chat as well. But no questions yet.
00:04:03.420 - 00:04:27.840, Speaker B: Awesome. Cool. Yeah. Thank you. All right, so I think this mental model really helps when thinking about sequencers. So basically, a sequencer is a service provider, and the contracts on layer one are the service level agreement. And users can send transactions directly to the sequencer.
00:04:27.840 - 00:04:37.196, Speaker B: And it's really the contracts on layer one that the sequencer must play by the rules of the contracts on layer.
00:04:37.228 - 00:04:37.810, Speaker C: One.
00:04:39.880 - 00:05:22.544, Speaker B: Because you could imagine that sending transactions directly to the sequencer, the sequencer could, in theory, front run your transactions and such. So you really need to use some game theory and kind of design the contracts on l one to prevent things from happening like that. So you can see, I made this little emoji diagram. And we have users who send, they can send transactions to the sequencer, which maintains like a L2 chain. And then from the crystal ball that is the sequencer. And then. Sorry if it's getting loud, there's just a garbage truck driving by right now.
00:05:22.742 - 00:05:29.328, Speaker A: I was about to type. So this time around there's no fire alarms, but there's a massive garbage truck.
00:05:29.424 - 00:05:37.220, Speaker B: Yeah, I'm just going to step inside real quick. All right, cool.
00:05:37.370 - 00:05:43.210, Speaker A: Sorry about that. I think everyone's so used to it in this community, so no problem at all.
00:05:43.660 - 00:05:50.184, Speaker B: Yeah. All right, so just going over this diagram, we have the sequencer, who then.
00:05:50.302 - 00:07:00.860, Speaker C: Submits the transactions to the l one contract. So we have Ethereum up here on the left. And basically the users, they can run a verifier which basically will kind of sync the contracts and play all the transactions, and it lets them submit a fraud proof. So this is kind of like a high level overview of a good mental model for a sequencer. So basically, why use a sequencer? So basically, there's this concept of ordering transactions, right? And there has to be some way to come to consensus over the ordering of transactions, right? So right here I just pasted in a snippet of geth where you can see at the bottom of the code, it says if the header time is less than or equal to the parent time, it returns an error. So this is basically the consensus rule in Ethereum that shows that time must increase from block to block. And here's another snippet from GEF.
00:07:00.860 - 00:07:33.548, Speaker C: And this just shows the way that you can see kind of in the middle. We're iterating over the block's transactions and we're basically executing them one by one. So this is just going to show that ordering is very important in blockchains. So there's massive financial incentives to influence the ordering of these transactions. And there will always be super users that have a high ordering preference, right?
00:07:33.714 - 00:09:28.190, Speaker B: And basically what we're observing today is that when the super users compete, then it results in the regular users losing, and it's really the miners that are winning, right? So through priority gas auctions and out of band transactions, if people aren't familiar, a priority gas auction is just when, say, there's some sort of transaction that you can send to the chain that will be profitable and somebody else sees your transaction in the mempool, then basically they will submit a transaction with a higher gas price. And it's kind of this back and forth thing where you end up with a ton of transactions, just like spamming the mempool, pushing up the gas price for all users. And as the sharks are competing for the profits, and they end up losing profits themselves because they're just willing to push the gas price up as much as possible so that they still make a little bit of profit, their profit gets cut out and it ends up going to the miners instead. And then people start considering, oh, maybe out of band transactions are the solution, so that other people can't learn what exactly the transactions basically keeps your transactions secret. And then it kind of devolves into the system where the super users have special relationships with the miners, and it becomes less kind of meritocratic and less open, and it becomes to mirror kind of like the current system. So a lot of this work was kind of pioneered by flashboys, and flashbots is currently working on some really interesting stuff. And there's also this other project, keeperdow, that's kind of working on.
00:09:28.190 - 00:10:04.430, Speaker B: So basically, using a sequencer, it kind of opens up the design space around transaction ordering, and it allows us to iteratively design mechanisms without needing to change the consensus rules themselves around the ordering of transactions, because we can now put rules about the transaction ordering into smart contracts themselves, and we can iterate on these smart contracts over time and find something that is better for the ecosystem. Any questions?
00:10:09.120 - 00:10:14.220, Speaker A: Skyhard, is ordering happening on a separate consensus layer?
00:10:15.380 - 00:11:05.180, Speaker B: Yeah, that's a good question. So in the optimism implementation, there is no separate consensus layer for the ordering of transactions. Basically, you send transactions directly to the sequencer, and the sequencer can choose the ordering of the transactions that are batch submitted to layer one. And basically, it sounds a little crazy, but we just need this series of checks and balances where the layer one contracts are basically the service level agreement. And you have to just make the kind of game theory, design it in the layer one contracts to prevent the sequencer from ever wanting to act poorly.
00:11:09.780 - 00:11:24.340, Speaker A: There's sort of a up here. How will it help with reordering on l one? On l one level, how will it help with ordering? Reordering was actually the question from Jacob.
00:11:24.920 - 00:11:54.910, Speaker B: Yeah, I guess this isn't necessarily like a solution for l one today. And there are other projects like flashbots and Keeperdao that are kind of working on l one right now. But this is kind of just looking at l two and kind of as we move to e two, when it kind of becomes more amorphous and l one is less of a thing, and it's more like all roll ups kind of on e two.
00:11:57.680 - 00:12:08.070, Speaker A: Cool. There's one last thing. What do you mean? I can code transaction ordering up the smart contract level without changing consensus rules. And then the other question is, can I do this now?
00:12:08.760 - 00:12:09.172, Speaker C: Yeah.
00:12:09.226 - 00:13:04.230, Speaker B: So you can't do this now necessarily on l one, but this is kind of the system that we're designing here. Optimism is in kind of the l one contracts that make up the roll up. The idea is that the way that they're designed, the users get certain guarantees about how the transactions that are sent directly to the sequencer, they get certain guarantees about how those transactions will end up getting submitted to layer one. And over time, we're looking to kind of improve and iterate on kind of the game theory that is built into the system so that we can have really good guarantees for the users when they send transactions directly to the sequencer. So all of that mechanism design would happen in smart contracts on l one.
00:13:07.000 - 00:13:13.252, Speaker A: There are two more questions, but I'm wondering if. Do you want to keep going? And we come back to them in a minute?
00:13:13.396 - 00:13:14.330, Speaker B: Yeah, sure.
00:13:14.700 - 00:13:16.952, Speaker C: Okay, cool.
00:13:17.006 - 00:14:22.392, Speaker B: So this is basically one of the main kind of ideas that we've been working on, and Carl came up with this. It's an incredible, like, it really opened up the design space for me. And the basic idea is that you separate the concept of ordering the transactions from the concept of selecting the next set of transactions to come to consensus over. So basically what this would allow is for a system where the sequencer auctions off the right to order the next set of transactions. And because MeV is always going to be a thing, we can design systems that kind of take that into account. And basically, if the sequencer is auctioning off the right to order the next set of transactions, then the sequencer can charge a tax on that or charge some sort of fee. And that fee could be then used and repurposed towards funding open source development.
00:14:22.392 - 00:15:04.780, Speaker B: Or it could be used to fund the development of the sequencer, or it could be used in kind of like gitcoin like grant. Like a gitcoin like grant system. So another possibility. So this is just like a picture of a transaction that's been waiting for six days. It's kind of really annoying. Whenever this happens to me, we can improve on the user experience of using blockchains quite a bit. So kind of the idea here is that the sequencer accepts transactions instantly and gives you a receipt back instantly.
00:15:04.780 - 00:16:10.690, Speaker B: Right. So if we could build into layer one, the ability to basically submit a fraud proof based on this receipt that the sequencer gives back to you. Because the sequencer can give back to you a receipt that commits to submitting the transaction, batch submitting the transaction to layer one in a particular way. So the simplest form of this would be the sequencer would say, okay, I commit to batch submitting this transaction to layer one within five minutes. And basically, if your transaction is not batch submitted within five minutes, the user would be able to submit a fraud proof and the sequencer would get slashed. So this is just like a way to kind of, in layer one, design a system that allows for instant confirmations when you send transactions directly to the sequencer. Any questions?
00:16:13.300 - 00:16:37.368, Speaker A: Actually, and just FYI, we are almost at time for this session, and then there is going to be the panel, but we'll keep going until you're for sure finished with this talk. I'm trying to think going back, Lassa had asked what would happen if everyone is well behaved for a longer period of time. But slashers are nothing in this period. Would it make sense to have slashers? Basically, yeah.
00:16:37.454 - 00:17:07.840, Speaker B: You always need a bond with an optimistic roll up. It doesn't really make sense to not have a bond, because if there was a time when you didn't have a bond, then the system would be not secure during that time. So we do have some smart contracts in our repository that manage the bonds. And if you're curious about how it works, definitely go check out on GitHub. It's GitHub.com, ethereum, optimismcontracts.
00:17:09.540 - 00:17:28.890, Speaker A: One more. There's actually a lot of questions, so I would say I'll ask, answer, keep going. And then it sounds like you might just want to keep having a conversation with some of these folks after and gather. So sky asked, if a miner does not like what he gets from the sequencer, why should he mine it?
00:17:29.660 - 00:18:30.830, Speaker B: Oh, that's a good question. So there is this whole idea around miners basically censoring transactions. So if I understand this question correctly, it's on the topic of when the sequencer wants to submit a batch of transactions to layer one, and the miners on layer one are censoring it. And this is why basically the window, the fraud proof window, is so large for at least optimism's optimistic roll up. And this is a topic that people are very opinionated on. And there's a lot of kind of back and forths, but basically there is an assumption that miners will not censor. And basically it kind of becomes users need to.
00:18:30.830 - 00:18:53.060, Speaker B: So the sequencer will basically up its gas price. And assuming that the network is decentralized enough, eventually one of the censoring miners should defect and include the transaction. But this is definitely the type of conversation that goes back and forth because it's very in depth and there's a lot of little gotchas.
00:18:57.560 - 00:18:58.950, Speaker A: Do you want to keep going?
00:18:59.320 - 00:19:00.790, Speaker B: Yeah, I'll keep going.
00:19:01.480 - 00:19:49.936, Speaker C: Okay, cool. So this is kind of my vision of what a sequencer could be in the future. And so it's like the sequencer is a service provider, right? So the sequencer wants to provide the best user experience, which is instant transaction confirmation and additional services that the user would like. Right, where there's key management in different regulatory and tax tools, because doing taxes is so annoying. So imagine if you were all the transactions that you sent to the sequencer. The company that's behind the sequencer can just help you out with all those things. And then it kind of becomes this organization that makes this vertical integration of the blockchain Internet experience, where they can make open source tooling, like web.
00:19:49.936 - 00:20:11.884, Speaker C: Three providers, there could be like a login system, Kyc, they could start to provide search or other existing kind of Internet things that are used. And this is really like, in the long term, where I see the concept of a sequencer going, okay, so I'll start to go a little bit more.
00:20:11.922 - 00:20:12.876, Speaker D: Quickly because I don't want to go.
00:20:12.898 - 00:20:40.644, Speaker C: Over too much, but what about a malicious sequencer? So the sequencer can choose to censor calls to contracts on l two. So what this means is we need to be able to send transactions permissionlessly that impact the l two state. So what this means is in the optimism system, we can send transactions from l one to l two. So this basically means you get the l one guarantees to be able to.
00:20:40.682 - 00:20:42.330, Speaker D: Modify state and l two.
00:20:42.780 - 00:21:36.088, Speaker C: And this is done through this in queue function. And then there's this append q batch function. I won't go into too much detail about how they work under the hood. And if you're curious, come hang out in our discord and we could answer more questions there. Okay, so then there's this problem of sequencer front running, right? So the l two contracts, basically when you send transactions directly to l two, the sequencer can technically front run any of your transactions that you send to l two. So we need to give primitives to prevent this from happening, right? One primitive is you can basically, in l two, you have this l one message sender concept. So you can kind of put this little modifier on your code that is deployed to l two.
00:21:36.088 - 00:23:13.736, Speaker C: The optimism l two. And you can basically prevent an l two transaction, like a transaction the sequencer created, because this will basically only allow transactions that come from l one. If the sequencer did want to front run you, then they would have to participate in a priority gas auction on layer one to modify the l two state. So another thing that the sequencer could do is they can sell your consumer data, right? So the solution to this is the sequencer's information should be highly available so that there isn't like an asymmetry in the sequencer or like the sequencer's friends learning the information before everyone else does, because they would be able to act on that. So we're trying to design the system in a way where it's really easy to kind of make all of the data available even before it has been batch submitted to l one. So something that could really help to prevent sequencers from becoming too powerful is a competitive ecosystem of sequencers where users can opt into the particular sequencers that provide the best services. And this kind of creates an ecosystem where the sequencers continue to innovate over time and users have options.
00:23:13.736 - 00:23:45.360, Speaker C: So it's really important that the sequencers that choose to have an open governance, that users can go there and kind of vote and participate in the governance of that sequencer. And also it's important for users to be able to easily exit to a different sequencer. So it's really important to kind of develop, like, standard interfaces and kind of common tooling that can be used across sequencers.
00:23:48.580 - 00:23:49.330, Speaker D: Cool.
00:23:50.920 - 00:23:52.164, Speaker C: This is basically the end of my talk.
00:23:52.202 - 00:23:54.112, Speaker D: I just have, like, a little philosophy.
00:23:54.256 - 00:23:55.444, Speaker C: Blurb at the end.
00:23:55.562 - 00:23:55.940, Speaker A: Sure.
00:23:56.010 - 00:24:31.010, Speaker C: And this is basically just about how I think it's important to build systems that act as a balance against the growing wealth inequality. And basically, I think that the world as a whole is a happier place when there's less wealth inequality. And this is because we do know that money does improve a person's happiness, but there is a diminishing return on happiness with more money. So therefore, if we can build systems where money is spread more equally across people, then we can make the world a happier place.
00:24:33.540 - 00:25:10.350, Speaker A: That's a really nice way to end that talk. Thank you so much, Mark. By the way, there's a lot of questions still in the chat, but we actually do have to hop over to the other session now and the panel maybe, I don't know if you want to take a moment to maybe answer some of them in the chat, and then you join us over there as well. And to the folks who want to switch over, we actually are going to go to reception or to the sessions, and you'll see now there should be, like, a different button to go in. I'm going to head over there now. Mark, you're actually welcome to also stay on this. I think this just keeps going until you sign.
00:25:13.440 - 00:25:19.840, Speaker C: And I'll answer some questions. And then once all the questions are going, then I'll pop out and then.
00:25:19.910 - 00:25:20.384, Speaker A: Sounds good.
00:25:20.422 - 00:25:22.256, Speaker C: Hopefully, the panels are going on.
00:25:22.438 - 00:25:30.884, Speaker A: Yeah. And also, if I accidentally shut down the entire thing, then I apologize in advance. But maybe everyone can talk to you after and gather. I hope you'll head over there, too, after.
00:25:31.082 - 00:25:31.812, Speaker D: Cool. Awesome.
00:25:31.866 - 00:25:32.804, Speaker C: Yeah, thank you.
00:25:32.922 - 00:25:33.590, Speaker B: Cool.
00:25:35.560 - 00:25:38.390, Speaker C: All right, I'm going to scroll up on these questions.
00:25:40.200 - 00:26:17.120, Speaker D: Okay. So I will answer kind of. There is a question around the sequencer, and the sequencer does run on L2. The sequencer is kind of responsible for maintaining liveliness of the entire system, the l two system. Marcel, I'm looking for your question. How could a user prove that their transaction was withheld? Okay, so basically, let's say that you submit a transaction to L2, and the sequencer receives it. Then the sequencer executes your transaction, and they give you back a receipt.
00:26:17.120 - 00:27:29.850, Speaker D: And then they can commit that. They will submit this transaction to layer one within five minutes, if they wanted to. And in this receipt that they give you back, they would basically tell you what index in the canonical transaction chain of transactions that your transaction would be placed in. So the way that the fraud proof would work is it would basically look at the canonical transaction chain and it would see that there's nothing at that particular index, and then you'd be able to prove fraud on the promise that the sequencer gave you. What if the sequencer won't exit? Okay, yeah, that's a great question. So if the sequencer doesn't execute in the first place, then basically that will increase the latency, right. So there's always a trade off where if you are sending transactions to the sequencer and the longer the latency is, that's kind of like worse user experience.
00:27:29.850 - 00:27:44.788, Speaker D: So there's kind of got to be this threshold of when the acceptable amount of time that a sequencer can basically run an mev solver in the background before they give back. Like a receipt.
00:27:44.904 - 00:27:45.136, Speaker B: Right.
00:27:45.158 - 00:27:51.504, Speaker D: Because a receipt contains the state route. So once the sequencer gives you back.
00:27:51.542 - 00:27:52.640, Speaker C: Your receipt.
00:27:55.460 - 00:29:15.004, Speaker D: The sequencer can't really go back on it. So assuming that there's like an ecosystem of sequencers, there will be a sequencer that steps up, that does less mev solving and users will migrate to that one because it's providing a better user experience. In the same way where people that did Google searches every extra 100 milliseconds that it took longer for a Google search to return, there were much less users. So it's really like this competing ecosystem of sequencers that's really important. And right now we just have one sequencer and we're running the sequencer, and we are a public benefit corporation, so we have no intention to extract Mev and kind of play those games. We just need to figure out how to basically bootstrap this whole system of competing sequencers. Cool.
00:29:15.004 - 00:29:34.460, Speaker D: Yeah, no problem. Thank you for watching and definitely if you want to say hi, just like pop into our discord. We usually are hanging out there. You can find our discord on optimism. IO, like on the bottom, there should be some social links.
00:29:36.240 - 00:29:36.604, Speaker B: Cool.
00:29:36.642 - 00:29:37.204, Speaker C: Yeah.
00:29:37.362 - 00:29:41.760, Speaker D: Thank you for your time. I appreciate you all watching. Bye.
