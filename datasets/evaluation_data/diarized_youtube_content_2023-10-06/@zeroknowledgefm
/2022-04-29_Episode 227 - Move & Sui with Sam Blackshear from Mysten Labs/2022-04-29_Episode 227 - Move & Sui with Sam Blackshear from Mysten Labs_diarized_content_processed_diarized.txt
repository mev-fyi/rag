00:00:08.610 - 00:00:58.130, Speaker A: Welcome to Zero Knowledge. I'm your host, Anna Rose. In this podcast, we will be exploring the latest in zero knowledge research and the decentralized web, as well as new paradigms that promise to change the way we interact and transact online. This week I chat with Sam Blackshear, co founder and CTO of Mistin. Sam has a background in programming language research and is the author of the Move Language, a programming language that can be used to implement custom transactions and smart contracts. We chat about their concept of programmable objects and what this makes possible. We also cover Sui, a generalized L One, with a new asset centric data model for parallel transaction commits being developed by Mistin.
00:00:58.130 - 00:01:26.494, Speaker A: Before we kick off, I want to highlight the ZK jobs board for you. If you're looking to jump into ZK professionally, I want to remind you to head over there. You will find job posts from some of the top teams working in ZK, teams like Alio, Anoma and Mina. Find the next project or team you want to join. Now, since we always have so many things to mention in this little intro block, you should also check out the link tree we've put together. There you can see all of the channels that we have. So if you want to jump into ZK, this is probably a good place to start.
00:01:26.494 - 00:02:03.242, Speaker A: Now I want to invite Tanya, the podcast producer, to tell us a little bit about this week's sponsor. Today's episode is sponsored by Polygonmiden. Polygonmiden is a layer two scaling solution for Ethereum. MidN relies on zk starks to roll up thousands of layer two transactions into a single Ethereum transaction, which increases throughput and reduces fees. At the heart of polygonmiden is Midnvm, a touring complete stark based virtual machine which provides a level of safety and the support of advanced features not currently available on Ethereum. Visit polygon technology to learn more about polygonmiden and other polygon solutions. So thank you again.
00:02:03.242 - 00:02:17.226, Speaker A: Polygonmiden now here is Anna's interview with Mistin Labs. Today I'm chatting with Sam Blackshear, the co founder and CTO at Miston. Welcome to the show, Sam.
00:02:17.338 - 00:02:24.462, Speaker B: Anna, thanks so much for having me. I'm really excited to be here. A big fan of the show and excited to be on it for the first time and to be the first guest for Miston.
00:02:24.606 - 00:02:38.806, Speaker A: Yeah, Miston. Maybe we should start a little bit with that. This is the first time I'm exploring this project. It was somewhat stealthy for a while. I feel, and I want to hear, yeah, tell me what Miston is.
00:02:38.908 - 00:03:20.894, Speaker B: Yeah, absolutely. So Miston Labs is a startup in the crypto space. We officially started in November of last year. Our mission is creating a foundational infrastructure for crypto. And what does that mean? I think it's actually easier to start by talking about the origin story of mist, and then you'll understand what we're doing and why we are where we are today. So myself and all my co founders, we were all part of the Novi research team, which was a subdivision of Facebook or meta, that worked on Libra and worked on move. And so for many years we were there from the beginning of the project, and we had built a lot of the, done the research and development and a lot of the implementation for much of the core tech behind Libra.
00:03:20.894 - 00:04:07.758, Speaker B: So we created and developed move. We did a lot of work on the consensus protocol, on the parallel execution bits, and this was an amazing experience being at Facebook and working on this stuff. We really got to take a very blue sky look at blockchain tech and figure out what's genuinely new here, and what are cases where fundamental computer science, things that you can bring in, and there are insights from elsewhere that make sense, and where are cases where this is like some generally new thing, where there's new problems to solve. And so we worked on all this stuff for a number of years and I think built some really cool things. But as I'm sure the audience of this show knows, like a Libra DM or there were many renamings, never ended up launching for reasons that weren't related to the core tech. So there were both things that we worked on there that, and Libra is sort of old tech. Like it was designed in 2019.
00:04:07.758 - 00:05:09.154, Speaker B: And there's a lot of things that have changed in the crypto space since then, and we've really understand some things a lot better and would do things differently. So it was both wanting to take some things that we'd built at Facebook that never saw the light of day, like move, and to take those out into the crypto space they're really needed, and take some next gen ideas for, like what can we do beyond we? There's some things about the Libra design that are good, but really, if you want to design a scalable blockchain from scratch, there are a lot of things we'd want to do differently. And that was never going to happen inside of Facebook. So this is the genesis of Miston, is to take some of those ideas out there. And the problem that we're focused on solving our problems is really just looking at the crypto space as a whole and just seeing that there are amazing, amazing things that have been done, but there are also giant gaps in terms of problems that need to be solved for enterprise and consumer grade adoption. And so we don't think of this as a problem that's solved by one blockchain or one network, but something that needs to be solved by a lot of improvements throughout the entire stack that are between users and crypto. So of course you need a fast layer one blockchain with low fees and with high throughput.
00:05:09.154 - 00:05:45.246, Speaker B: You need a better, smart contract programming language that's more accessible to mainstream developers. You need key management to be less high stakes and more of like. You don't worry so much about losing your password and losing your life savings. It needs to be more of that kind of experience. All of these sorts of things, I think, and more are problems that need to be solved to get to consumer enterprise. Great adoption of crypto, and so, like Miston is focused on, it's sort of a meta company where the first thing we're doing is sweet, launching this network. But in the longer term, we plan to launch many networks, many SaaS companies, many spinoffs to address all of these different big problems that we think need to be solved to get to broader adoption of crypto.
00:05:45.438 - 00:05:50.260, Speaker A: What were you doing before Facebook? What's your pre blockchain story?
00:05:50.730 - 00:06:41.906, Speaker B: Yes, so I trained as a programming languages theorist. I was doing a PhD at the University of Colorado Boulder, working on scalable static analysis tools. So my PhD thesis was on goal directed static analysis, where you have a particular problem that you have a particular kind of bug that you're looking for, and you want an analysis that can automatically identify that in other programs. And I went straight from my PhD to Facebook and worked on static analysis for many years. And so I looked at things like finding null dereferences, finding array index out of bounds errors, some stuff on C memory safety, and enjoy this work a lot. It's really, really like you get to design these little languages that are tailored toward finding these particular kinds of bugs or properties that folks care about. And at Facebook, we got to do this.
00:06:41.906 - 00:07:44.006, Speaker B: We had to make it run really fast so it would go in CI, so it could happen in 15 minutes, even though you're analyzing tens of millions of lines of code. And I worked on this for about three years and loved it. But also, you develop a lot of opinions about language design when you spend all day trying to patch basically design flaws in existing languages or existing frameworks. What you're doing there is basically trying to accommodate the usage of something that already has a large amount of code written in it. But then, of course, you have opinions about, if I were doing things from scratch, either from a language design perspective or from a framework perspective, how would it do that differently? And then sort of at the same time, these deep questions about what makes it hard or easy to reason about a program, and especially with different programs that compose, because that's where a lot of bugs come from. And if you're starting over and doing these things from scratch, how would you do it differently? And so that was my background, both leading up to Facebook and leading up to crypto. I was having these thoughts, and then Libra started up, and they needed someone to look after the smart contracts part of it.
00:07:44.006 - 00:07:57.646, Speaker B: And I was like, this seems like a great way to put some of these ideas about blue sky language design to work. And then also in a space where correctness, which is what the static analysis stuff is all about, is super, super important and folks are willing to invest in it, because the stakes of getting.
00:07:57.668 - 00:08:13.250, Speaker A: Things wrong are very high in Facebook. This group, the Libra group, was it connected to the general cryptography group? Basically, the question is, did you meet Bobbin from Winterfell through your work on Libra, or is that in a totally different department?
00:08:14.070 - 00:08:34.886, Speaker B: I did meet Bobbin from Libra. I did meet Bobin through the work on Libra. There actually isn't or wasn't a general cryptography group at Facebook, which is interesting. There are several cryptographers at Facebook, but they tend to be integrated into particular teams rather than having the general cryptography consulting team. I think that may be changing, but, yes, I did meet Bobin through that and get to work with him. He's fantastic.
00:08:34.998 - 00:08:50.800, Speaker A: Cool. I mean, that's the only other person I've had on the show that knows anything from the inside. Leaving Facebook and moving off on your own, were you? I mean, it sounds like you had been at Facebook for quite a while at that, like, and that was your first gig, so, yeah. Was it hard to leave?
00:08:52.530 - 00:09:31.162, Speaker B: Yeah, I guess it had been a while for me. It had been five or almost six years. It really wasn't because I was just so excited to get the chance to work with my co founders, who are basically my favorite folks of the many very strong and impressive folks that I worked with at Libra and DM. And just because the work that we had started with move felt unfinished, and this felt like the way to give it a second life and to really get it out there and then. I was also incredibly excited about some of the new ideas that we've since been working on in Sui. And just to get those out there and see what folks sell to them to see how they would work. So the big decisions are always easy for me.
00:09:31.162 - 00:09:38.826, Speaker B: Smaller ones, like deciding what to eat for lunch. So this one, it wasn't too difficult of a choice, I thought, funny.
00:09:38.858 - 00:09:51.578, Speaker A: And your crew is not the only team to have left or to have spun out from there. I just recently heard about two other projects, and maybe they're related to what you're doing, but, like Aptos and Zeph.
00:09:51.674 - 00:10:28.142, Speaker B: Yeah. So we call ourselves the Libra mafia. I think there's a number of folks coming out of there that have gone on to do different things. So, yes, you mentioned Zeph and Aptos, and then, of course, you have folks at Riaz and Nas who are very talented folks working in custody at Facebook who are now at a 16 Z. There's a guy, Frederick, you may not know, who's also doing a crypto startup. There's Dalia Malki, who we also worked with at Facebook, who's now the chief scientist at Chain Link, and Kristen Catalini, who is the chief economist there, who also worked with them. So I think, although this project unwound, I think a lot of the ideas and folks are now making their way into the broader crypto space.
00:10:28.142 - 00:10:31.854, Speaker B: And I think hopefully you'll be hearing from a lot of them going forward.
00:10:32.052 - 00:10:37.614, Speaker A: Is the project done internally, or do you know what's happened to it?
00:10:37.732 - 00:10:44.766, Speaker B: Yeah, Facebook announced that they were no longer working on the project. I think the Libra association also announced that it was dissolving.
00:10:44.958 - 00:10:45.410, Speaker A: Wow.
00:10:45.480 - 00:10:46.434, Speaker B: So it is done?
00:10:46.552 - 00:11:04.390, Speaker A: It's done, man. I remember, like, a few years ago on the show at one of our New Year's episodes or something, we were definitely like. It was like the boogeyman a little bit. People were scared, but it ends with a little. Not with a bang. I don't know. Bit of a shame.
00:11:04.970 - 00:11:35.220, Speaker B: It's a bit of a shame. I mean, the folks always announce the good parts very loudly and the other things less loudly. But I feel that the project really well. There's the technical things that are produced, which I'm very excited about, but I think it also made a lot of folks take CBDCs more seriously in advance discussions that might otherwise have happened over a series of many years or decades. And even though that wasn't what succeeded, it hopefully laid the groundwork for some important things that will come later. So I feel good about that part of it anyway.
00:11:35.830 - 00:11:47.960, Speaker A: Well, let's dive into some of the pieces that you are bringing with you. I kind of want to start with the move language, because that's obviously something very dear to your heart. Tell us, what is move?
00:11:49.130 - 00:12:20.362, Speaker B: Yes, move is very dear to me. So move is a language for programming with scarcity. That's the way I would explain it. At the very highest level, where in a conventional programming language, right, everything under the hood is just bytes that have no inherent scarcity. When you say something like, let X equals Y, what you're really saying is copy the value stored in Y and put it into X. But when you're programming with money or assets or anything that needs some inherent scarcity, that model isn't going to be appropriate. You don't want to be able to copy coins or money or anything along these lines.
00:12:20.362 - 00:12:50.490, Speaker B: You need the language to have some way for talking about scarcity and objects that exhibited. And so the genesis of move was, this is way back in 2019, but looking at solidity and the EVM, the other smart contracts out there today, and just thinking like this is a bit strange. When I look at the kinds of programs folks are trying to write, they're all about assets. It's about encoding the structure of assets. It's about logic for transferring them. But there's no vocabulary in the language for talking about assets. The data model is very strange.
00:12:50.490 - 00:13:36.762, Speaker B: You have a big hash table where the keys are addresses and the address values are basically the entries in that hash table. If it's for coins, that's an integer. And for an NFT, maybe it's some things about the structure of the NFT, but there's no type or value that represents an asset. And so you can't do something like return an asset from a function or store an asset in a data structure, or pass an asset as an input to a function. You can't even have an asset leave the contract where it's created. And so to me, this just seemed like it's not going to be the right language for expressing this sort of stuff. And this isn't just an ergonomics thing, it leads to safety issues as well, because it's really hard to talk about something like an atomic transfer when that requires touching one entry in a table and then touching another entry in the table, and then making sure that something doesn't happen in between.
00:13:36.762 - 00:13:57.786, Speaker B: Like this is how the Dow hack happened, for example. And so the purpose of move was really, if you had a language that's centered around the idea of being able to program with scarcity, providing a structured representation of assets and having that be safe, what would that look like? And there's a lot of other things that move is doing, but I think that's really the core. And what makes it different from other smart contract languages and general purpose languages.
00:13:57.978 - 00:14:06.978, Speaker A: Did you look at other smart contract languages though? Past solidity? Are there any that maybe even influenced a little bit move?
00:14:07.144 - 00:14:44.558, Speaker B: Yes. So at the time, and this was 2019, solidity in the EVM was definitely the largest one. And so we looked at other general purpose languages and other smart contract languages. There were some research smart contract languages that influenced the ideas a lot. So there's one called Flint that was sort of trying to take Java and add a little bit of this notion of asset like types on top of it as so like, that was certainly something that was an influence on move. And then in mainstream languages there's of course rust, which a lot of folks use in the blockchain space. It has this notion of move semantics or substructural types in PL lingo, where you have restrictions on.
00:14:44.558 - 00:15:11.320, Speaker B: When I move this value in the caller context into the callie, then I no longer have it and I can't touch it again. And this is very related to some things that move does in terms of the way it represents assets. And then that idea in turn comes from C plus plus. Or there are other languages too, mainstream languages that have this idea of substructural types, usually to represent memory, which is also something that has to have scarcity properties. But then using it to represent assets was something that was new in move.
00:15:12.010 - 00:15:31.598, Speaker A: If the goal here is to bring more developers in though, wouldn't you want to use an existing something like JavaScript, which is very, very popular? Because it sounds like you didn't take that route. You're not doing JavaScript plus, you're doing something else. Why did you decide not to sort of piggyback on existing popular things?
00:15:31.764 - 00:16:28.046, Speaker B: Yeah, so this is a great question. I think if you can piggyback on existing popular things, you always want to like language communities, language tooling, having existing developer base are much more important than language design. Yeah, all of these things. So I think this is a question we asked ourselves early on, and this answer is going to be a bit long, but I hope it'll be interesting. And that there are these properties that I like to call the table stakes properties of a smart contract language that if your language doesn't have these things, then it can't even satisfy the basic requirements of doing this so one thing is that the language has to be deterministic, right? Like all of these smart contracts are running the context of you're running some byzantine fault on a replication system. If you have non deterministic semantics, even if validators agree on everything else, they may get different answers, and then you aren't going to accomplish the goal, this whole thing, which is advancing the state of the system in a predictable way. Another thing is this metering concept, right? In smart contracts we talk about gas or metering or all this stuff.
00:16:28.046 - 00:17:49.654, Speaker B: Conventional languages, including JavaScript don't have this, and so you need to have this of course in the blockchain context, because you don't want someone to send a transaction with infinite loop, install the entire system, or even less extremely, just something that occupies an extreme amount of time or more resources than it can pay for. And then the final thing which I kind of already touched on is this notion of assets or scarcity, where in a normal language, like right in JavaScript you have objects, but you can copy objects and you don't have to have something like move semantics. It's just not intended for this setting where you're programming with assets, but you really need that here. And the way to enforce that is that you have type safety protections that are enforced not at the source language level, like if you're writing your Java or your rest code and the source compiler is telling you when you're doing something wrong, but actually at the executable level, at the bytecode level in move's case, where even if somebody wants to skip the source compiler and write code directly in the bytecode language, you have to make sure that the properties you care about from a type safety and from an asset safety perspective, hold there as well. And so these are these three table stakes properties that you need to have to play as a smart contract language, and mainstream languages don't have any of them. Now of course you can try to address this by I'll take JavaScript and I'll add metering on top of it, and I'll restrict it to get rid of the nondeterminism. And maybe I'll add some libraries for asset types.
00:17:49.654 - 00:18:39.050, Speaker B: But anytime you do this, you're basically taking something that's already very complicated, and then you're adding restrictions that's going to stop you from using some of the existing libraries that exist in that language, or stop you from using the tooling that's available. And then you're adding something else, like say, metering that this existing stuff may not be compatible with. So we looked into doing this, we looked at doing this extend and restrict game for WASM, for the JVM, even for Skylark, this sort of build language that you use for Python and then for JavaScript as well. And we just concluded that especially in this setting where you care so much about correctness and you care so much about safety, simplicity is really of the essence. So it makes way more sense to start from scratch with something that has exactly the properties you want than trying to take something and play these games to shape it into what you want. And then it's going to be a challenge to build a developer ecosystem around that. But if you've really built the right tool for the job, then this is something that you'll be able to do in the long term.
00:18:39.390 - 00:18:55.870, Speaker A: Interesting. It's sort of a bit of a throwback for me. Like a few months ago, a month ago I had dean from Agoric. Come on, they did something like they also have this language of hardened Js, right? So it's JavaScript, but made more compatible to blockchain. Are you familiar with it?
00:18:56.020 - 00:19:01.778, Speaker B: Yeah, I'm familiar with Agoric and spoken to those guys a bit and I think what they're doing is very interesting as well.
00:19:01.944 - 00:19:07.006, Speaker A: Cool. But you decided to go a different route. After evaluation, we decided to go a different route.
00:19:07.038 - 00:19:42.480, Speaker B: I mean, I think with hardened JS the thing is you'll run into this issue that I was just describing where there are many, many tens of millions of lines of JavaScript code out there, and there are many JavaScript programs and tooling developers. But a lot of these things are not hardened JS and these things are not Js that has these agoric specific libraries. These things just aren't directly applicable. And I think really that's an approach worth pursuing as well. But I think taking something that's already complicated and trying to build a dialect of it that's specific to blockchain is just going to lead to a result that is more complex than starting from something simple.
00:19:43.490 - 00:19:53.086, Speaker A: You've sort of mentioned the testing, or like the verification is happening at a different point. Would you still need to do testing like tools to test?
00:19:53.268 - 00:20:30.026, Speaker B: Oh yes. Nothing frees us from the need to test. So let me talk about that and move a little bit. So there's a few different levels of things going on. One are the protections you get from the type system, so that of course happens at the source level, but then there's a component called the bytecode verifier. This is similar to technology that's in the JVM or CLR, where when the bytecode gets loaded from disks there's some, or on the blockchain, in this case there's some set of checks that run that enforce basic things like type safety, and in our case that also enforce asset safety. And so these are very cheap and lightweight checks that more or less make sure that whatever the source compiler was doing, that also happens for bytecode that for some reason didn't go through the source compiler.
00:20:30.026 - 00:21:01.158, Speaker B: Then of course you have testing. And so in move we have built in unit testing that you can write directly in move. And then the most interesting and important thing is that we have this thing called the move prover. This is a formal verification tool that we've co developed alongside the language. There are still folks at meta that are working on this move prover tool, although we have some at Miston as well. So what you do with this thing is that you can write formal specifications. You can say something like there will only ever be 100 objects of this type in the world.
00:21:01.158 - 00:21:39.634, Speaker B: And then the prover can show that for all possible sequences of calls, for all possible transactions, this property will continue to hold. And so you can write all the things that matter for your particular use case as specifications. And then the prover does a bunch of very fancy math, very much like the stuff I used to do before joining Libra to show that this happens. And so this is something that's quite different for move than for other languages. Like there's a little bit of work on solidity verification, but the things like reenterrancy and the language and dynamic dispatch make this hard. Whereas move was specifically designed with the ability to enable simple and scalable formal verification in mind. And then we've also built the tooling to match with this.
00:21:39.634 - 00:21:59.370, Speaker B: And so this is something like for JavaScript, JavaScript is one of the hardest languages to reason about. From a static analysis and verification perspective. It's so, so dynamic. Like, you add new properties at runtime, you add new methods at runtime, and you can do things like using a subset that tries to restrict these things, but then you're going to have to build tools that specifically understand this subset instead of general JavaScript.
00:21:59.790 - 00:22:03.610, Speaker A: How many people built move? How many people work on that?
00:22:03.760 - 00:22:28.530, Speaker B: Yes, it's quite a few. I think at one point there are probably at least 15 folks at meta working on it, and there are more now, some of those folks are still at meta. We have lots of folks, maybe like five or six, working on move at Miston. And then of course move is a cross platform language. It's not specific to one blockchain. So aptos is using move. So they have folks that are looking at it.
00:22:28.530 - 00:22:51.370, Speaker B: There's this zero L open labor project that's a fork of Libra, similar to Apdos, that's also using move. They have some folks working on it. There's a project called Starcoin in China that's also proof of work. Blockchain using move that have a bunch of folks working on the core language. So worldwide, there's maybe like, I would say like 20 or 30 people working on it. And this is working on the core, the developers building on top. Of course, there are probably a bit more.
00:22:51.370 - 00:23:00.634, Speaker B: I would say that's about the number. And then at Facebook, I'm not sure if I know their team size thing, their team size numbers. I shouldn't talk about it, but there are still folks that are working on both move and the prover.
00:23:00.762 - 00:23:04.922, Speaker A: I just realized that I just kept calling Facebook Facebook. I should have been calling it meta.
00:23:05.066 - 00:23:13.378, Speaker B: I couldn't adjust to change either, to be honest. I left just before it happened, and it was Facebook for so many years that it's still Facebook to me.
00:23:13.544 - 00:23:21.540, Speaker A: It's an open source project, right? Like, could there be external contributors, or were you kind of careful with who could add to it?
00:23:21.990 - 00:23:44.938, Speaker B: There can be external contributors in our. It's very much like any other open source project, especially one that's security critical, where you accept pull requests from anyone, you accept issues from anyone, but you want to keep the set of folks who are allowed to press the accept button small and then make sure that you get things carefully reviewed. Just to make sure that no one is introducing vulnerabilities or backdoors or any of these other things you have to worry about in a blockchain project or a high security project.
00:23:45.104 - 00:23:58.074, Speaker A: Are languages also these? Like, are they something where with a lot of use, you kind of find all the edge cases? I guess the question here is a little bit like, since it's kind of new, is it as battle tested as something like solidity?
00:23:58.202 - 00:24:25.234, Speaker B: There are two things to worry about with a language, I think. One is about the design and validating the design of it. And this is something that you can do without so called battle testing. Like, you write the formal semantics down with pencil and paper, and this is the part that I really love doing training as a programming language theorist. You write down exactly what the semantics of each instruction are. You write down what the key properties you want to ensure are. For us, these are things like type safety, but then also things like what we call resource safety.
00:24:25.234 - 00:25:10.722, Speaker B: Like if I have this type, then I know it can never be copied except by this privilege copy instruction. Or I know that when I move this type between procedures that it exists in exactly one place. Or I know that if this thing doesn't have the drop attribute, it can only be destroyed by a privileged destructor and not just sort of accidentally left on the floor. So you can write these things down on pencil and paper and prove that the language semantics satisfies them. And so that part you can feel very, very confident in, as confident as you can feel about anything in the world, then there's actually making sure that the implementation respects those properties. So that's something where battle testing becomes quite relevant, where you both, of course, you test the language very extensively and you do things, you do unit testing, you do fuzzing. You have lots of example programs.
00:25:10.722 - 00:25:22.300, Speaker B: And so that's something that, of course, we've done as we're building up move. But then you have to be very careful about the edge cases to make sure that you conform to the specification everywhere. And that's something that can only happen with time.
00:25:23.310 - 00:25:35.738, Speaker A: How long do you think it takes a language to be battle tested? How much volume? Maybe it's not time. It's more like, yeah, edge cases tested somehow in the wild.
00:25:35.834 - 00:25:54.466, Speaker B: I think as long as the language is still evolving, the job is never done. And languages must evolve. Like, you're always adding new features or deciding that something you've done in the past needs to be shifted. I don't think there's any specific period of time where you start to feel confident about that or where you can be fully confident about that, especially as something is evolving.
00:25:54.578 - 00:25:56.578, Speaker A: Cool. So what is Sui?
00:25:56.674 - 00:26:10.842, Speaker B: So Sui is a smart contracts platform, and it's a smart contracts platform that's specifically designed to be extremely high throughput and extremely low latency, and then also to be horizontally scalable to handle the increase in demand and throughput over time.
00:26:10.896 - 00:26:20.650, Speaker A: When you say horizontal, do you mean sharding? Because I heard that you are not doing sharding. So tell me what horizontal means in this context.
00:26:20.810 - 00:27:08.726, Speaker B: Yes, that's a great question. So by horizontal, we just mean that you add more machines and you get more throughput without degrading other key metrics like latency or other things you might care about or at least not doing so specifically. So sharding. Right. Sharding is a technique that can, you can talk about sharding computation, you can talk about sharding state and then you can also, and this is a blockchain thing, talk about sharding as part of the protocol, where everyone. You go and look at the protocol spec and it talks about sharding and how it works, or you can talk about sharding, what we like to call intravalidator sharding as an implementation strategy that you don't need to be aware of at the validator level. So in SuI, and in contrast to, say, what ETH two or serenity, I think is the name of this project now is doing or what near is doing, we do not have sharding at the protocol level, but we do have sharding.
00:27:08.726 - 00:27:49.340, Speaker B: Of course, the only way to scale beyond what a single machine can do is to have some form of sharding. And so what we do instead is intravalidator sharding, where a validator could consist of a single machine, or it could consist of multiple machines where some of the computation happens in each one or the storage is spread out among each one. But different validators need not be aware of how other validators are sharded. And there doesn't need to be a protocol level or community decision to decide how sharding could work. It's just much more of a conventional computer science problem where, okay, if you're Facebook or Google or anyone, you have the sharding inside your data centers. But as a customer of the system, you don't need to be aware that there's sharding happening or how it works. And you have the flexibility to change this very dynamically as well.
00:27:49.790 - 00:27:53.414, Speaker A: So it's the smart contract platform. Is it a VM?
00:27:53.542 - 00:27:56.314, Speaker B: It has the move VM inside, but it is not itself a VM.
00:27:56.442 - 00:28:00.058, Speaker A: I see. So it's the move Vm in sui.
00:28:00.234 - 00:28:00.960, Speaker B: Exactly.
00:28:01.410 - 00:28:03.840, Speaker A: Okay, and what does Sui stand for?
00:28:04.450 - 00:28:29.782, Speaker B: So it's not an acronym. The origin of the name is that it's the Japanese for water. And so it's like there's a connection to liquidity or things that are free flowing or an essential resource that you must have. And then also it's very nice and short and easy to say. It's very hard to find names that are not already taken up by other currencies and networks in the blockchain space today. So we're lucky to happen upon this one.
00:28:29.916 - 00:28:39.462, Speaker A: I'm going to ask a bit of a dumb question here, though. You just said it's the move VM, but we don't call it the solidity VM. Is this a naming choice or is it built differently?
00:28:39.606 - 00:29:05.534, Speaker B: Yes, a good question. Move is both the name of the source language and the virtual machine, whereas you have the Ethereum virtual machine and the solidity source language. You could, in principle, have other source languages for move, but we call it the move virtual machine, and we very intentionally called it that, instead of the Libra virtual machine or the Ethereum one. Because this is a cross platform thing. It works for everywhere that you have move. Like if you go and look at Starcoin or zero L, they're also using the move virtual machine, not some specific version.
00:29:05.662 - 00:29:10.350, Speaker A: Is that something that the language provides out of the box, or is this a separate library?
00:29:10.510 - 00:29:57.540, Speaker B: This is something that the language provides out of the box. The design of the language and how it's able to be cross platform is that things like the account structure and the transaction structure and the cryptography and the consensus that the network uses those aren't hard coded into language like they are, say, in the EVM, like in the EVM, you say something like, you can look at the hash of the current block, which implies that there is a notion of blocks and they have a hash. And here's how it's computed or like an account structure in a move. None of those things live in the VM or in the core language. What you do is you take the VM, which only knows about things. Like it knows about structs, it knows about integers, it does know about addresses. And then it's the job of a particular platform, like Sui or like Zero L, to add this thing that we call it an adapter where they say, hey, I'm a platform.
00:29:57.540 - 00:30:12.146, Speaker B: Here's my notion of accounts. If I have that, here's a cryptography I'm going to use. Here's a consensus. And then move lets you do whatever you want underneath that. But you can make those decisions, and you can have platforms that look very different. At the top level, they're using the same move under the hood.
00:30:12.338 - 00:30:23.114, Speaker A: I kind of want to understand how this lives as a blockchain. Is it like the account model? Is it a UtxO or is it something like, let's. Let's talk about Sui specifically here.
00:30:23.152 - 00:30:46.898, Speaker B: Yeah, let's talk about Sui specifically. Yeah. So move doesn't enforce anything, but I'll talk about how it works for Swee, where swee is a little bit of a hybrid between a Utxo and account model. The global state of Sui is a pool of objects. So objects or move values might be something like an NFT, it might be something like a fungible token, something like a dex, that's an object as well. And there's this pool of objects. All of them have a globally unique ID.
00:30:46.898 - 00:31:21.918, Speaker B: And when you have a transaction, it needs to declare the objects that it's going to operate on. If I'm going to transfer an NFT, the transaction says, I'm going to touch this object with this ID, and then that's what the transaction looks like. If you were going to make a trade in a Dex, you would say this transaction takes the ID of the deX, it's going to make a trade with, and the ID of the object that corresponds to the coin. And then that's what it would do. So that's the data model of Swiss. There are objects, you pass objects into transactions. The transaction also is a pointer to a code object, which is a move, smart contract, and then it tells you what it's going to do with the data, objects that you've passed in.
00:31:22.084 - 00:31:41.106, Speaker A: But what is actually written to chain then we're still talking about blockchains. So what's being put in? Sorry, I know I must sound kind of silly, but it's like there's always something to do with the account, the transaction, something that inevitably is being written to the ledger. So, yeah, what is it in this.
00:31:41.128 - 00:31:58.362, Speaker B: Case here, it's the object or objects, a transaction. It declares the objects. It's going to mutate. It might also create some new objects, or it might also transfer an object. And maybe that's a helpful thing to explain to see how it works here, because that's where something like account will come in. Here there's a notion of address. A transaction does have a sender or address.
00:31:58.362 - 00:32:20.400, Speaker B: And of course there's a signature check that makes sure that some signature corresponds to that address. But then part of the object metadata is who owns the object. And so there's a rule that says if I own this object, I'm the only one who can send a transaction that's touching it. And then the way a transfer works is that you just mutate that owner metadata to be someone else's address.
00:32:20.850 - 00:32:24.626, Speaker A: Can you do stuff to these objects? Can you affect them?
00:32:24.728 - 00:32:45.622, Speaker B: Yes. Whatever code you can write and move, you can do that thing to that object. So this includes the basics like mutating the object's fields, destroying it, creating new objects, doing some action that you can only do if you have some particular combination of objects, putting objects inside of each other. Like if you want to have composable NFTs, any of these sorts of things, you can do.
00:32:45.756 - 00:32:58.950, Speaker A: So usually when you talk about destroying something, I always think of sending it to a burn wallet, right? A burn address. It's just like you send it to nothing. No one can ever use it again. But in your case, if you were to destroy something, is it really destroyed?
00:32:59.030 - 00:33:28.406, Speaker B: It is really destroyed. So the state of suite, right? It's this pool of objects. This pool begins empty, or not exactly empty. It begins with some pool of genesis objects, and then over time, objects will be added to that pool, they'll be removed from that pool, or they'll persist in there. I think really the helpful way to think about it is that you have this pool of objects. You have a transaction, it temporarily removes a lot of objects from this pool, and then at that point, the transaction owns the objects. And so it might mutate them, and then it might destroy them.
00:33:28.406 - 00:33:39.114, Speaker B: And then what destroying means is that it doesn't actually go back in the pool. It just disappears forever. And then if it does a mutation, it's conceptually it's taken ownership of it, it's mutated a little bit, and now it goes back into the pool at the end.
00:33:39.232 - 00:33:40.906, Speaker A: It's proof of stake, right?
00:33:41.008 - 00:33:41.658, Speaker B: That's right.
00:33:41.744 - 00:33:48.502, Speaker A: In this model, do the validators do anything different, or are they just kind of acting like validators as we've known them?
00:33:48.576 - 00:34:22.866, Speaker B: So they don't need to do anything different. But there's something that having this object centric data model enables us to do. And let me describe what that is. So, backing up for a second, if you think about the way other blockchains work, there's always this step of, you have a bunch of transactions, you order them, and then you execute them. And some folks are clever about trying to discover parallelism in these transactions and execute them parallel. But there's always this constraint of, first you order transactions, and then you do other things. And so in suede, the thing we're doing that's interesting is that we observe there are some classes of computations that do not require ordering.
00:34:22.866 - 00:35:07.714, Speaker B: So, for example, if I'm going to send you a token and someone else is going to send someone else a token, those transactions don't have to be ordered with respect to each other. They can be executed in parallel, but they can also even be committed in parallel without going through full consensus. And so in Swede, this is what we do. When you have transactions that touch distinct objects, we don't order them with respect to each other, and then we can both execute them in parallel and commit them in parallel, which really reduces the latency compared to going through full ordering. And then for use cases that do require full ordering, like, say, if you have a dex, this inherently requires ordering, right, like you and I are hitting the decks. At the same time, we have to determine who gets what price. We have a scheme there where there's a notion of instead of objects having a single owner address, they can be shared.
00:35:07.714 - 00:35:24.710, Speaker B: And so if you have a transaction that's touching a shared object, it goes through full consensus. It gets sequenced and then executed just like normal. But if you have these transactions that don't require ordering, then we can use byzantine consistent broadcast to commit them in parallel instead of going through full consensus.
00:35:24.870 - 00:35:32.846, Speaker A: Does it mean it gets committed later? Like you assume that it's okay and then it will be committed at some point? Or does it never really hit the.
00:35:32.868 - 00:36:17.770, Speaker B: Blockchain at all, so it gets committed earlier? It's just that this is a proof of stake system where you have to have, I'll say for simplicity, two f plus one validators sign off on a given transaction. So if you're not one of the validators who signed off on this particular, the byzantine consistent broadcast transaction, then the other ones outside of that set may not know about it immediately. But as soon as a client sees signatures from two F plus one validators on that transaction, it has been committed. And then those validators know about it. They know about it. And for anyone else who doesn't know about it, you can show them. We call this the certificate, the transaction that carries those two of us, one signatures, and then they can then use that object in a subsequent transaction, or provider's proof of payment, or any of the other things that you would like to do in a normal setting.
00:36:18.510 - 00:36:36.462, Speaker A: I think you just explained this, but now I'm like. Because I thought what you were saying was more like there were some less important transactions that you just sort of, like, let float around and eventually got in. But what you're saying is different. Can you actually walk me through this again? And sorry to the listeners if you got it the first time, but I didn't.
00:36:36.606 - 00:36:44.446, Speaker B: These transactions, I wouldn't describe them as less important, but you need less computational power to deal with them, or less agreement power, let's call it.
00:36:44.488 - 00:36:51.046, Speaker A: What would be an example? Would this be like connecting an NFT to another NFT, like making them composable? Or is that very.
00:36:51.148 - 00:37:37.106, Speaker B: I think a basic token transfer is the simplest one. And I think for folks familiar with Utxo, this is fairly easy to think about if you have a single balance. And I'm trying to send in a non Utxo model, if I have a single balance and I'm trying to send outgoing transactions to lots of folks at once, there's a potential conflict because my balance may go below zero. But if I instead take that balance and I split it into a bunch of independent Utxos, then I can do a bunch of those things in parallel. So basically what we have is everything is split not into utxos, but into objects. And in these transactions that touch distinct objects, you can commit them in parallel without full consensus because there's no need to do that ordering. Whereas in something like a Dex or an auction, you do need that ordering.
00:37:37.218 - 00:37:58.700, Speaker A: You need the ordering, but where does the data go? Like you're saying, it's happening in parallel, but are they then hashed into one thing that then gets put into the blockchain or not? This is the part where I'm kind of confused. What happens to it after you've parallelized it? It's happening at the same time. They don't all know each other. They don't know what each other is doing. So at what point does that become like the global state?
00:37:59.310 - 00:38:27.714, Speaker B: Because of these transactions that don't go through full ordering at any given point in time, the validators may not agree on the set of transactions that have been committed. They will eventually agree, and the set of validators have signed off on a particular transaction, agree on that transaction. But it's a much more asynchronous kind of setup than you'd see in a blockchain where you have a total ordering. You have blocks that are coming out. Now. Of course, in sui we do also have blocks, and we have them for the transactions that require ordering. In addition to that, we do state checkpoints that are asynchronous.
00:38:27.714 - 00:38:44.042, Speaker B: And so there every now and then, either at epoch boundaries or perhaps more frequently, you have a list of all the transactions that happened, and then you'll, after the fact, build some canonical ordering among them. But you didn't have to build that ordering to commit the transactions because the ordering isn't going to change their effect. That's sort of the key thing here.
00:38:44.096 - 00:38:59.182, Speaker A: You're doing almost like in every epoch, you're doing some sort of lock in, like now. This is where it lives. Would you call this a dag? What is it? Decentralized acyclical graph. Oh God. Right.
00:38:59.316 - 00:39:36.294, Speaker B: What was the directed acyclic graph? Directed, yeah, that's exactly what it is. So, right, these transactions that don't go through full consensus, they're not unordered, they're causally ordered. They're only ordered with respect to transactions that have happened beforehand or transactions that are conceptually related. And so you can think of the state of the world instead of being this set of sequential blocks. There's a dag where you start with the objects in Genesis, and then you have the edges or transactions that take those objects and then put into something else, and then you build that out. And then occasionally these things join together when two objects are previously unrelated, go into the same transaction and then become separate. That's how you should think of the history of suite.
00:39:36.294 - 00:39:48.690, Speaker B: But then I think the confusion I was causing is that I was talking about the state at a point in time, which is this global object pool. And then what you're pointing out is that the validators do not necessarily agree on the object pool at any given point in time, which is true.
00:39:48.840 - 00:40:01.314, Speaker A: Okay, how are validators being chosen in this consensus? Actually, is it like the 66% must be doing something? Yeah, I'm just curious, how is this working?
00:40:01.432 - 00:40:24.810, Speaker B: What we do here is very conventional, where it's a proof of stake system. You have stake, and then you have validators that can vote. Their votes are weighted by the amount of stake that they have. And then in order for a transaction to be committed, whether it's in this fast track mode where you commit things asynchronously without going through consensus or going through full consensus, you have to get two f plus one of the weighted stake vote to get your transaction committed.
00:40:25.230 - 00:40:32.078, Speaker A: There was another project that I believe came out of a similar group, which was like, hot stuff. Does it have any relation to that?
00:40:32.164 - 00:40:53.506, Speaker B: So hot stuff is a consensus algorithm and one that was used in DM, or at least like a variant of it was used in DM in what we're doing with suite. I haven't even talked about the. I'm saying we have consensus for these shared objects, but haven't mentioned which consensus there. You can use anything. You could use hot stuff. You could use tendermint, you could use narwhal Tusca, which is. I wish my co founder George was here to talk about this.
00:40:53.506 - 00:41:08.362, Speaker B: Probably what we're going to use in Sui, this next gen consensus that separates the notion of the mempool from the notion of actually ordering things and then gets a lot of speed ups related to that. But. So there's no direct relationship with hot stuff, to answer your concrete question.
00:41:08.496 - 00:41:28.320, Speaker A: Got it. Now let's bring it back to move, because now that we have some sense of sui, how do these things work together? Why kind of going back to that initial thing that I had sort of hinted at, like, does Sui allow move to act differently, or does actually move allow Sui to act? I think it's the first, right?
00:41:28.930 - 00:42:12.478, Speaker B: I think it's the latter move allows the latter to act differently. So this data model is describing where you have these structured objects and they go into transactions. You need to have a data model that can encode that. So like thinking about Ethereum, the data model is contract centric, where there's no notion of an object or an asset, right? Like you have a hash map, and then the object is some entry in there. So if you wanted to say, in ETH, for example, I have a transaction that's going to be touching these three different NFTs. The way to express that is that you provide the address of those three contracts, and then you maybe provide indexes into the hashmap. Like there's no vocabulary for saying that sort of thing, or for saying, take this NFT and bring it out of the contract into somewhere else.
00:42:12.478 - 00:42:43.830, Speaker B: All you can do is switch the owner or things like that. And so in move, we have a notion of structured objects that can flow across contract boundaries. Like I can take my object type and make it a field of another object type. And then it's not just that I write it that way in the source code, it actually looks that way in the data model. It's move that enables this object centric data model. If we wanted to do this with the EVM or with any other kind of language that doesn't allow you to pass structured bytes across trust boundaries, then you wouldn't be able to express the things that we're doing in sui.
00:42:44.270 - 00:43:01.120, Speaker A: Does the language actually offer this ability to parallel lives somewhere in it as well? Because you mentioned it in the context of sui having the sort of like multiple non confirmed things happening at the same time, different validators seeing it. But yeah, does the language take advantage of that?
00:43:01.490 - 00:43:30.226, Speaker B: So this happens on the layer above the language. The language provides the data model that lets the layer above do that. But the move VM is single threaded and usually does short running computations as smart contracts are. Maybe eventually it'll run things in parallel once we have smart contracts doing machine learning or other fancy stuff. But for now, I think we get a lot more leverage by having the VM be single threaded and be optimized for these short computations and putting all of the parallelism and high performance stuff in the layer above that just uses the VM as a subroutine.
00:43:30.338 - 00:43:37.510, Speaker A: When you say going above the language. Do you mean like the smart contracts being deployed on the VM?
00:43:37.850 - 00:44:24.938, Speaker B: Yes. So when I say above the language, I mean the system that is invoking the VM, like the validator software that is going to ingest some transaction and then decide how am I going to schedule these? Which of these am I going to. Well, in our case, we run all of them in parallel, but which of these am I going to run in parallel? And then how do I organize the structure of the computation inside the validator? That's what I mean by the layer above, not by the smart contracts. The smart contract program model is very much the same in terms of you write your code, you just have this nice abstraction where the entire world is yours and you can touch whatever you want, you can call whatever you want, and then it's the job of the validator software, the runtime, whatever you'd like to call it, to take that in and figure out, can I commit this in parallel? Does this need to go through consensus? What object IDs do I need to specify as dependencies and all of these sorts of things?
00:44:25.104 - 00:44:37.806, Speaker A: Cool. A colleague of mine at the zero knowledge validator, Philip, encouraged me to ask a little bit about a new transaction payment protocol. Tell me about is this fast pay? Is that this part?
00:44:37.908 - 00:45:09.314, Speaker B: So, right. I think he's probably asking about the Byzantine, consistent broadcast thing, which does come from. Let me explain. Fast pay. And at Facebook, my co founder George, as well as Alberto, who works at Miston and a number of other folks were tasked with this problem of, okay, we want to have a really high throughput payment system and we only care about doing payments. Like how would you design a blockchain from the ground up? Basically with these constraints in mind. And the design they came up with was this fast pay thing where they observed that for payments you don't need ordering.
00:45:09.314 - 00:45:51.806, Speaker B: And I think other folks have observed this in the past too. If you don't have a single balance, but you think of coins as like distinct chunks, then you can send them in parallel and commit them in parallel and not have to need this full consensus. And what we did in Sui was basically taking that Fastpay idea and say, we actually start off by thinking, okay, Fastpay idea is very applicable to NFTs, so maybe we can just take Fastpay and layer some nice APIs for specifying NFT metadata and things like that. But then we started talking to potential customers and of course they want much more than this. They say, okay, we don't want static NFTs we want things that are mutable. I want restricted transfers. I want to be able to say I can create NFT number three only if I get number one and two as input.
00:45:51.806 - 00:46:08.810, Speaker B: And just basically they wanted full programmability. So what we did is tried to squeeze as much programmability as you can into the fast pay model via move and just see what could be expressed there. And then we add full consensus on top to be able to express the rest. Things like Dexes or stuff that fundamentally requires sharing and ordering.
00:46:09.150 - 00:46:42.610, Speaker A: Cool. I want to understand a little bit more about kind of the go to market or like the ecosystem side of things, because you're an L one. And back in 2017, everyone was raising money for L ones that have since come to fruition. But a lot of them now are seeing that they must interconnect, they must actually link up to each other, to other parts of the ecosystem. So you're now an L one, but are you also considering, are you right off the bat thinking about how to link to the other networks?
00:46:43.030 - 00:47:21.162, Speaker B: Yes, we are. So let me talk first about the go to market a little bit, and then I'll talk about how linking to other chains plays into that. So the use cases we're most excited about are where we think we can offer a lot over existing platforms. And these are cases where use cases where you really need high throughput and the low fees that come along with it, and also really low latency. I think the most logical thing here is gaming, where there are many, many different folks in the gaming space. And we've been talking to a lot of them who they want to do NFT based assets in their game. They want to move some aspects of gameplay online, and they're just finding that it's really, really difficult and expensive to do that on existing platforms.
00:47:21.162 - 00:48:08.942, Speaker B: And a lot of what gets talked about here is throughput. But for games, latency is the beginning and ending too, right? You don't hear as much about latency as a performance issue in the blockchain space, but full consensus has these multiple round trips to achieve an ordering. There's a lot of latency that comes in as an ad. So we're focusing very heavily on games in our early partnerships and in our go to market because we think that's where we can especially add a lot of the value over existing platforms. And of course, part of making games work well is you need to bring in the liquidity that's already in the blockchain ecosystem. And this is where connecting to other chains happen. So of course you want to be able to sell NFTs on Ethereum, where a lot of the liquidity is, or bring liquidity from Ethereum to sui, probably similar for Solana and Polygon and some of these other ecosystems where a lot of things are happening in the coin and NFT space.
00:48:08.942 - 00:48:17.342, Speaker B: So we're thinking very much about games from the use case perspective. And then, of course, part of what makes that compelling is connecting to other chains.
00:48:17.406 - 00:48:34.466, Speaker A: What are the networks that you are actually looking to integrate? Like, would you integrate potentially just with one of these bridging solutions or interoperability zones, networks which are already kind of connected to all the other ones, things like Nomad or Axelr? Or would you do direct bridges to these networks?
00:48:34.658 - 00:49:18.934, Speaker B: So we're still finalizing our plans for that. And of course, I think the best thing for us to do is make the smart contract platform as usable as possible so folks will build bridges to all the places where they need in terms of us, we may or may not end up implementing and operating bridges ourselves, but I think, of course, the ones I would expect to see emerge, whether we do them or someone else does, is, of course, you want a bridge to ETH for the token liquidity from there and for all of the NFTs that are there. I think Solana is also gaining a lot of momentum in this area, possibly to Polygon as well. None of these are things that we've worked out, and we hope and expect that there will be multiple bridges between suite and other platforms, as there are for all these other blockchains that exist. And for us, it's really just about building the ones that our early partners will need, or at least making it possible for someone else to build those, if it's not us.
00:49:19.132 - 00:49:41.182, Speaker A: I read somewhere that there was plans to work on something with sommelier. Sommelier is the project of a kind of repeat guest on the show zucky. So, yeah, I'm just curious, how are you working with them exactly? Because they're not an L one, but they're like a meta L one or something.
00:49:41.316 - 00:50:14.578, Speaker B: Yes. Our collaboration with Somalia isn't about suite. It's about this Narwhal and Tusk next generation consensus component that I mentioned. So Miston has relationships both with Somalier and with cello to integrate Narwhal and Tusk into their setup and basically give a massive throughput boost by pulling in this new consensus under the hood. So we're working closely with the Somalia team to experiment, swapping out tendermint with Narwhal and Tusk to really get the throughput boost and help them achieve the increase the effectiveness of the liquidity cannon they're building over at Somalier.
00:50:14.754 - 00:50:22.246, Speaker A: Cool. The way I read it was, it was like to bring smart contracts to Cosmos. Was that a different thing? Maybe it was just a headline.
00:50:22.438 - 00:50:32.766, Speaker B: I think maybe that was a different thing. But I mean, who knows where that could go in the future. I know some of the folks there are big fans of move, there aren't concrete plans to go forward with that at some point, but would definitely be.
00:50:32.788 - 00:50:46.270, Speaker A: Open to that in the, you know, we kept forgetting to call Facebook meta, but do you have, like you're talking about gaming, do you still have your eye towards the metaverse? Is that on your roadmap?
00:50:46.430 - 00:51:29.166, Speaker B: So I think to me, the gaming is just the part of the metaverse that already exists, or is like the preview of the metaverse that will come next. Like, in games, you're already multibillion dollar businesses that work by selling digital assets and providing virtual worlds for folks to play around in. And the size of these has increased a lot over the recent years, and I think will continue to. And to me, the metaverse is just about expanding that into our work lives and social lives and in other areas where that makes sense, I guess. I'm a big fan of the real world, and I like the metaverse to the extent that it helps make our physical lives more meaningful and more connected. And I think gaming is one part of that. But gaming can also be, it can be very social, but it can be very solo.
00:51:29.166 - 00:51:38.580, Speaker B: And I'm very interested in ways of socializing outside of gaming and the ways that blockchains as a collaboration technology and as a social technology can enhance that.
00:51:39.670 - 00:51:49.398, Speaker A: Let's talk a little bit about future plans or what's coming up. Like so far. Is there any zero knowledge anywhere in your stack? Not really. Eh, I don't think we've heard anything like that so far.
00:51:49.484 - 00:52:18.606, Speaker B: So far there is not. Right. Our scaling strategy is based more on just improving the base layer rather than trying to do ZK, roll us on top of that in the long term. I'm sure that's something that we could look into. I think ZK, for privacy, as a smart contract programming primitive, or for light clients is something that we might definitely want to look into. Costas, my co founder, is our lead cryptographer, and it's going to have much more interesting ideas on how that could fit in there. But for now, yes, there's no zero knowledge, which I feel a little bit bad about being on this show.
00:52:18.606 - 00:52:20.558, Speaker B: That has so much great zero knowledge content.
00:52:20.724 - 00:52:33.570, Speaker A: Maybe by next time, next time when I have someone else on from Miston, there'll be some other ideas in the works you just mentioned, though, that that sort of reminds me of like Plumo, and I wonder if you're at all familiar with that work.
00:52:33.720 - 00:53:17.954, Speaker B: Yes, of course, Miston has this engagement with Celo, and we know Kobe well and we know Plumo and the very cool stuff that's going on there. And so I think as we think about our like, client influence ecosystem and ways to reduce the bandwidth of that or reduce the computational cost of doing replays like plumo like approaches are certainly something that we might want to think about. We're also thinking a little bit, and I should have said this part earlier, about random beacons, which are useful both from a program perspective, because you can do things on chain that require true randomness, and also some of the consensus options we're looking at totally benefit from having a random coin for leader election. And so this is a little bit further down the road, but definitely like in the zero knowledge wheelhouse, in terms of things that are interesting that you might see coming later, is there any.
00:53:17.992 - 00:53:23.950, Speaker A: Other kind of things we should look out for in the next little while? Maybe non ZK future tech ideas?
00:53:24.030 - 00:54:11.734, Speaker B: Yes. One thing that we think is very interesting about this object centric asset model is that it enables a lot better things in terms of wallets and sort of client experience in general. For example, one big issue with wallets today is that signing requests are not human interpretable. You get a bunch of RLP bytes and your wallet says, do you want to sign this? And you're like, yeah, I don't know. I guess it came from uniswap or alleged to, so it's fine. Whereas we'd really like to provide something that's more like an Android or iOS permissions model where you say, hey, this app would like to permission to touch your board ape and this coin and to do that. And because of the object centric data model, we can do that quite easily, where when a transaction comes in, you know what objects is going to touch, you know their types, you know their shape, and then often you can pre execute the transaction and predict exactly what it's going to do.
00:54:11.734 - 00:55:16.006, Speaker B: So you can provide a much better user experience. This is important both for security and just in terms of predictability and knowing how things are going to go where you can say it's going to touch these assets, I know it's going to touch these and no other ones is that okay with you? And I think this can help a lot with preventing some of both the security and usability issues that you see elsewhere. So I think this is one item, and I think another one is that having these structured types from a programmability perspective just makes it a lot easier to do things that you can't do without establishing a common standard in Ethereum or in other places. Like for the things that you get in something like, say, ERC 721, the community has to come together and agree on the standard, and it works well. But then if someone wants to do something a little different, you have to go through a whole nother round of let's talk about how to actually make this fungible, or how to make the URL immutable, or something along these lines. And with structured types, you write your type that has the properties you want, and other people write code that just uses that type either embedded in their struct or they take it as input. And it just makes it a lot easier to sort of define standards without everyone having to agree on it.
00:55:16.006 - 00:55:29.840, Speaker B: People who want to agree on the standard use that type, and other ones use some other type. And then I think it just should just make it a lot easier to experiment with things that are new use cases without having to go through the rigmarole of standards, which I'm very excited about.
00:55:30.530 - 00:55:36.718, Speaker A: Cool. Well, I think we've reached the end of my questions. Sam, thank you so much for coming on the show.
00:55:36.804 - 00:55:46.180, Speaker B: Anna, thank you so much for having me. It's been a blast to be here. I've listened to this show many times, and it's a little bit surreal for me to be on the other side of the mic. So thank you for having me. It's been a.
00:55:48.710 - 00:56:06.802, Speaker A: I mean, just as a side note, we did actually have your colleague George originally planned to come on the show. He couldn't make it. I would love to explore this again. Maybe kind of when a new milestone is hit. In fact, maybe I could ask you that question, like, what is the timeline? When could people actually play with this?
00:56:06.876 - 00:56:08.202, Speaker B: Yes, this is a great question.
00:56:08.256 - 00:56:12.140, Speaker A: So, currently putting all the pressure on you right now, what we have now.
00:56:12.670 - 00:56:39.074, Speaker B: When is it coming? It's there. What we have out now is an SDK, where we have an SDK in the white paper. You can run a node locally, you can start writing move smart contracts, you can look at our examples, you can connect a wallet. What we have coming, hopefully by the end of this month, is a public devnet where there'll be a network that's up and running. You can do all the things you can do locally now with a Devnet. Publish smart contracts, call them. There'll be a connected explorer within a few months.
00:56:39.074 - 00:57:11.070, Speaker B: After that, we want to have a public testnet where instead of the Devnet, which will only be run by missed and operated validators, we'll add in validators from the community and start building up a large validator set and developing the experience of operating the network and dealing with issues together. And then we're hoping to go to a main net launch by the end of the year. So we're hoping to move quite quickly. Things are going well from a tech perspective, and it's really just a matter of both making it easier to build on top of the network and really getting to the point of stability and security and hardenedness that you need to launch a new L one.
00:57:11.220 - 00:57:13.098, Speaker A: Cool. Thanks again, Sam.
00:57:13.194 - 00:57:15.274, Speaker B: Thank you, Anna. It's been fantastic.
00:57:15.402 - 00:57:31.250, Speaker A: And I want to say thank you to the podcast producer, Tanya, the researcher on this episode, Chris, who I think this is the first time I'm mentioning him. So thank you, Chris, for helping put together a lot of the notes. And I want to say thank you to the podcast editor, Henrik, and to our listeners ers. Thanks for listening.
