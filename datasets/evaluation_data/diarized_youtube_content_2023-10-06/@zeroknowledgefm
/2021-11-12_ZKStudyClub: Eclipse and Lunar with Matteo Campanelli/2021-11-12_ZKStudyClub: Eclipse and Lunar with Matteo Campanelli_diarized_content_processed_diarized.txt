00:00:00.680 - 00:00:14.537, Speaker A: So today for the ZK Study club we are here with Matteo Campanelli who's going to be presenting Lunar and Eclipse, the Commit and prove snarks with universal srss. Please take it away, Matteo, and welcome.
00:00:14.601 - 00:00:51.977, Speaker B: Thanks, Anna. Hi everybody. I'm going to tell you a little bit about two binary works. They came one after the other, although they were sort of concurrent in different ways and they had lots of cross pollinations. The topic is roughly snarks with focus on very, very small proofs and universal srs, if you know what it means. Great. Otherwise I'm going to explain that in a second and the focus is going to be on what we could call commit and prove snarks.
00:00:51.977 - 00:02:06.855, Speaker B: So snarks were that deal efficiently with commitments as inputs. This is a joint work with a bunch of people tariffior Antonio Fanio, Anais Carol from there and Eurocom and a bunch of people from OSE University. Diego Rania, Emin Benison, Chaya Ganesh, Claudio Orlandi and Kira Takashi from Owes University in Concordium. And I hope I'm not going to bore you too much if you know lots about this and if I say things that you know about, I hope I'm not going to bore you with those or I'm not going to confuse you. Feel free to jump in with any question in time. I think we can benefit from that. That said, yes, quick recap, but we're talking about just as a setup, if I say zero knowledge proofs, even in interactive setting, I'm talking about two parties approver and the verifier and we're getting is out of this protocol is that the verifier can be convinced after a run that prover knows some data, some witness as we call it, W such that a certain relation property RW holds.
00:02:06.855 - 00:03:15.177, Speaker B: So basically one way to paraphrase this is you're trusting someone else's claims on the property about the property on some data that you're not even seeing. You haven't seen them, you're not supposed to see them, but you know that they know after that. Our setting is sort of a specialization of that. And what I mean by commit and prove here is you're trusting someone else's claims on data that you haven't seen, but they can be pointed to. What do we mean with this? So think about the setting from before PMV interaction. But here we're gonna assume that P ahead of time, maybe so just going to commit to the data, we're gonna represent these commitments as an envelope and just Gonna put it on say a stool, a table, whatever, like it's gonna public publish it on a bulletin board or a blockchain. Commitment is again a cryptographic primitive that allows us to enclose an object without revealing it.
00:03:15.177 - 00:04:04.635, Speaker B: So it hides usually what the data are and it's binding. You cannot. There's no way you can open in two different ways, right? So P does that and then it can at the later time, doesn't have to be right afterwards interacts with V. And at that point V is convinced that that envelope opens to some data such that a certain property holds. So in what we're trying to say is that or the way I'm defining commit to zero knowledge is that we provide relation and we open a commit at the same time, which is could be seen as a larger relation, of course. But we're going to care about this setting for reasons I'll say there. Why do we care about this then? So often this is useful for compression and fingerprinting.
00:04:04.635 - 00:04:57.143, Speaker B: So imagine that the commitments commitments sometimes can compress a lot the data and we can use this fact. Here's for example, a toy example. Not so toy, not so toy. Imagine that the top three, four, five hospitals in the United States or your favorite country are holding some sensitive database of health data of their patients. And the government wants through some public money, for example fund some machine learning been trained on this sensitive health databases. So asks some researchers to train some models on these databases. Let's assume this is sort of semi deterministic process whatever, since it's public money.
00:04:57.143 - 00:05:52.105, Speaker B: Maybe we want to prove to the public or to be able to audit that these machine learning models have been trained correctly. We could do that through zero knowledge, for example and commitment for zero knowledge proof as follows. There's a public commitment to the data to the databases, signed by the government, the hospitals, whatnot. And then whoever trained the model is able to provide a proof that zero knowledge proofs of correct training. Another setting, we could call it commit ahead of time, which I'm going to sort of exemplify in a specific way. Imagine that today I can publish on the bulletin board on the blockchain a sort of my credentials, a commitment to all data about me, my credit history, who I am when I was born. A commitment signed by some authority of sort.
00:05:52.105 - 00:06:18.675, Speaker B: Cool. I can keep living my life. And then sometimes I will need to prove something to my next employer. I want to prove that a certain my history data satisfies certain property. And I can do the N0 knowledge using this commitment sort of as a placeholder. I see there's a question on chat, but I cannot see it.
00:06:20.175 - 00:06:21.479, Speaker A: I can read it to you if you want.
00:06:21.527 - 00:06:22.995, Speaker B: Okay, thanks.
00:06:23.455 - 00:06:26.915, Speaker A: Do we need cp? If there is simple hash and sign.
00:06:28.495 - 00:06:48.085, Speaker B: If there's simple hash and sign, you still need to hide that hash and sign. I'm not sure it tells me anything about the hiding thing. So if you need zero knowledge. If you need hash and sign just for compression. Yeah, maybe the needs or knowledge. Am I missing something?
00:06:48.505 - 00:06:53.565, Speaker A: Well, actually. So Gustavo asked that. I don't know if Gustavo. If you want to add more in.
00:06:55.545 - 00:07:36.031, Speaker B: The first example was interesting of sensitive data and then the machine learning models want to verify that that was the original data set. Why not just hash and sign that sensitive data? Oh, it is. It's as you're saying. So although it's a. I admit it could be slightly contrived given the how machine learning training occurs most times. But what we're proving is not that the data are the original data that happens through a sign. So you ashens, you commit to them and then you sign that commitment.
00:07:36.031 - 00:08:12.373, Speaker B: Basically it's a hashing sign which you're proving is whoever is training the model is proving to anybody else, say to me and you and the public that the training happened correctly on those hash and signed, committed and signed data. That makes sense. There was. Maybe there was. That's helpful. Okay. So in comito ahead of time I have commitment to some data again and I can prove things later in time.
00:08:12.373 - 00:08:54.619, Speaker B: I don't know what I'm going to prove about this data. I don't know what proof system I'm going to use. It could happen in 30 years and so on so forth. Like company could commit today to some data and 50 years from now I have to prove something to the government of the future and so on and so forth. Another example, and I need to apologize because I think I have this chat here, I need to remove it. Another example is commit improve. Certain flavors of commit improve can allow us to obtain modular or efficient composition proofs.
00:08:54.619 - 00:09:26.445, Speaker B: Here's an example. Let's assume we have a circuit which is sort of a heterogeneous. That's one way to put it. So it's made of a very algebraic part, takes three hidden inputs, three witnesses, A W and B and W is shared, right? And let's assume it's made of two heterogeneous different parts. A very algebraic one, the one on top and very. We could call it Boolean part. An example of this is.
00:09:26.445 - 00:10:02.225, Speaker B: Imagine you want to prove for Public input Y that you know X such that the hash of G to the X is equal to Y. Now SHA may not. SHA itself may not be the best Boolean flavored sort of. It's not so algebraic flavored but it's more blue and flavored than others. But you can think of that as some hash of sort and G to DX is a very algebraic flavored expression. Right. So the example here what entrance says Imagine you have two proof system.
00:10:02.225 - 00:11:10.865, Speaker B: You have no proof system that specializes in both. You have some proof systems that specializes in algebraic statements and some proof systems that specialize in other flavors. Which one do you use? Right. You get this whole circuit the end of these two things you need to compromise. Do I compromise? Sometimes is both sure. Now you are doubling the roof size but if you care about say proving time and you're saving significant factors then and that's a trade off you can afford you should do that. And then the intuition is that you take this intermediate state W or intermediate witness, you commit to it and then you do one proof with one specialized this red break over here system and one proof with the other and this together with the commitment is the proof that the whole relational Any questions so far about this? All right, so pushing a little more still on talking about the background more concretely.
00:11:10.865 - 00:12:45.179, Speaker B: Commit ahead of time allows you to do anonymous credentials if you're familiar with them Basically what I said before and these have other applications commit approval appearing cryptocurrencies blockchains with privacy properties think a favorite example is probably zcash where we're committing to what's the commitment is a coin, right? Or you're committed to the coin or the coin is a commitment itself according to how you want to see it but you commit to something and then later you proving your spending it right and this close to generalized to proofs and data posting blockchains and anywhere you need data to reference in a private manner. We need zero knowledge and succinctly so I don't want to give you something as big as I want to have a fingerprint of sort so hope yeah hopefully that's. I thought there was a question. Sorry. Hopefully that's clear and this is sort of the general setting of commit improve but I haven't even started to get into what what we're going to talk about which is commit and proof snark. So no interaction so far I assume there's any type of proof and I'm going to talk about certain trust model, the universal SRS setting universal structure reference String model. So what we care about in these works is committed proof snarks.
00:12:45.179 - 00:13:22.307, Speaker B: So not committed proof, zero knowledge in general, but commit improve systems with various very small proofs and an efficient verifier. This is a seamless and non interactive. So this is just a string we're giving around. How do CP snarks differ from snarks? So in snarks you can model the property you're proving as a relation of sort here, represented as this big block. This is the circuit R. It's going to take a public input X and a private input W. As an example, the X could be a message and W a signature.
00:13:22.307 - 00:13:55.519, Speaker B: And you can prove the signature and the syntax of a snark looks a little bit like this. Right, Forget about public parameters here and just keeping them. But the prover gives a proof, the verifier takes, it uses the public input on the algorithm, verify and checks if it outputs one in CP snark. I'm sort of spelling out what the relation looks like. Right again. What are you proving? You're proving that there's an envelope. The envelope here is this as a commitment.
00:13:55.519 - 00:14:42.277, Speaker B: There could be different envelopes, different coins, different databases, different commitments to databases, different commitments to credentials. And these are these C1CL. You get all of them and your commitment relation is proving that given in the public input X and this public input C1CL, the relation is satisfied. So again, I have. You have these public commitments use the verifier have them. And the proverb wants to prove to you that he knows a property for what's inside these. And the syntax is as representing the image, except that there's a type.
00:14:42.277 - 00:15:20.989, Speaker B: And the proof should also appear. So on the right should be verified X, C1CL and PI. And below you can see we're doing the same thing. There is a relation R and we're proving that X and W holds. But also you have these commitments to portions, small parts of W. This is very abstract, but one way to think about it is again, you're proving a machine learning model on the training of machine learning model on different databases. They're all committed, the commitments are public, and these are the C1CL.
00:15:20.989 - 00:15:39.455, Speaker B: And the witness would be, say, the concatenation of these databases. Right? And they appear in different places. Maybe the witness is something else as well. So, any question on this before I move on?
00:15:43.715 - 00:15:56.575, Speaker A: It doesn't look like it. I think just so anyone who's just joined knows, feel free to sort of jump in as this is the study club. It's Quite casual. And you're welcome to ask a question when you have one.
00:15:57.815 - 00:16:27.705, Speaker B: Thanks, Sam. So if this setting is clear, you could ask. Look, the setting on the right is a special case of the setting on the left. So you're about to tell me why this work on CPS narcs is interesting. Why wasn't this just narcs? And the reason is that this extra ingredient we have the commitment, right, which could be, say, a Pedersen commitment. Normally there's something very algebraic flavored. It could also be a Merkle tree.
00:16:27.705 - 00:17:08.185, Speaker B: We care about two properties often or that are handy, that are useful, that it's nice to have, that are important to have in certain settings. And these properties are efficiency and interoperability. And I'll say more about that. So basically we. And this is a vision we push with, for example, in the legosnar paper with Darifiore and Anis Carol, who I believe is in the audience. And also it's being standardized as a vision. There's a working proof at the Zika proof standard working on this.
00:17:08.185 - 00:17:59.725, Speaker B: And basically you could always do this commitment opening in a circuit, right? You have a Merkle tree, which is your commitment in. Just encode the opening there. This is expensive that you are adding these extra constraints. If you do, if your commitment is a Pedersen commitment also you could do some tricks, and I'm going to mention that and that will help you. But in practice, this is hard to do. Can you do better than that? Can you sort of specialize this extra part? If you look at the bottom right, picture these, the dashed orange lines, right, that sort of intuitively are trying to say, oh yeah, this commitment's open to this part of the W. Do you need to prove that explicitly in your circuit or no? And the answer is no, you do something else.
00:17:59.725 - 00:18:30.631, Speaker B: And the other thing you care about is interoperability or commitments. So maybe you have proof systems that has some type of commitment scheme for which is very friendly. I'm going to give an example in a second. But can you. How does it relate to other types of commitments? Let me clarify that. I'm sorry. So, for example, suppose you want to prove.
00:18:30.631 - 00:19:12.401, Speaker B: Think of the commit ahead of time setting. Today you want to commit to some data and five years from now you want to do proofs on those data and you want to post this commitment on the blockchain. Today the timestamp is going to be that. Do you know what proof systems you're going to use in five years growth? 16 was five years ago. And how do we know what Proof systems we're going to say is going to be the most popular proof system five years from now, in 10 years from now, and so on and so forth. Do you know what commitment you're going to do? You already know the commitment you're going to use. What plausibly is going to happen is that you would like to use a commitment that's going to stick around.
00:19:12.401 - 00:19:52.419, Speaker B: You're not going to use a hash function, say Merkle Tree with the hash function. You don't know if it's going to survive scrutiny. You're going to use something very standard, standard groups, standard pattern, maybe something some type of standard today. So therefore you would like your proof system to be as compatible, the CP snarks thingy. If you like it to be as compatible as possible with standard commitments, our focus is going to be on better sample. Thanks. So there are some solutions that here I write unsatisfactory, but there's a lot of qualifications there.
00:19:52.419 - 00:20:32.851, Speaker B: I mean they're unsatisfactory as general solutions, as solutions that can be applied in general so that are in general interoperable and efficient. So please take that with a lot of salt. But exactly what I say. You could put Merkle Trees or Patterson opening inside the circuit and then there you go. Like you can use standard commitments and so on and so forth, but then that's expensive and I apologize for the handwriting. But in something else you could do is some very clever tricks. For example, you could use smart arithmetic and elliptic curves tied to your proof system.
00:20:32.851 - 00:21:26.785, Speaker B: Think of what's been used in Zcash. For example, use JubJub, which is really friendly to PLS12 3D1 and it's going to give you some speed ups. There are other works that talk about curves that are so called stark friendly. Coco has one, a work I co author with Matthias Al Anderson. Pexel has a curve for curve embedded in the restrictive curve jobber walking. And this is going to give you more efficiency, but still you are losing interoperability, you're losing generality. So you, you may want to find solutions that are efficient in, in general and interoperable in general.
00:21:26.785 - 00:22:24.729, Speaker B: Okay, any questions on this? That's it. So this is why I'm going to push. All I said so far is try to do the following. We care about proving stuff on commitments, business applications and we care about doing that designing protocols that work efficiently in a general manner. Okay, it's fantastic to have special specialized approaches to this, but there could be caveats, there could be limitations to that. Okay, Narrowing Even more, the type of snarks we're going to talk about are snarks that try to have a slightly weaker trust model. So if you're familiar with snarks, you know that they need some type of reference string.
00:22:24.729 - 00:22:57.935, Speaker B: There must be a reference string. Maybe the reference string is just random, a uniform random string or just the parameters of a hash function. You can see it that way for if you're in the random oracle model. But you need some type of reference and usually it's a so called structure reference string which I'm going to talk about in a second. So we have the best trust model we can hope for is narc. Is this called transparent model? Right, which shows up in a bunch of works. Should also mention starks here.
00:22:57.935 - 00:23:49.363, Speaker B: It's got no trusted setup and so you can just use them right away without an authority confusing this. Or you could think of a system like Groth 16 and others in the ballpark. They have a so called structure reference strength. So you need in principle in authority that comes around, samples a big secret. Sorry, samples a secret and does a big computation on top of it and publishes this very nice string, the common reference string which is structured and everybody's going to use. And now you need to be careful with a bunch of things you may want to do NPC ceremony maybe or some other tricks. And normally the key generation step is here is dependent on the relation R.
00:23:49.363 - 00:24:38.185, Speaker B: So you take give this authority the relation R and they're going to give you a structural reference strength which is dependent on that, right? What does it mean? You cannot use it for other relations. And why do. What you could say is why don't you just give a very general relation like the universal, so called the universal relation which has nothing to do with the universal. We'll talk about later. But so the relation that takes circuit and basically computes any circuit on that. Well that's pretty expensive, right? You are having asymptotically you're having a logarithmic additional factor here, multiplicative. So a model introduced crypto 2018 instead of universal SRS.
00:24:38.185 - 00:25:15.405, Speaker B: Basically it looks like the one in the middle, but the key gestat does not depend on the relation, it just depends on the bound on the relations you're going to prove. So basically there's still authority to input this bound and outputs nsrs a structure reference string and nothing. And now you can use it for anything. In what way? You can specialize it for any relation. And the specialization step is deterministic. You don't need trust anymore. So you do this step once and you can use it for anything.
00:25:15.405 - 00:25:50.845, Speaker B: And this step does not incur the overhead I talked about. This is the setting. This is what's underlined here. This is the setting we're going to talk about here. We're going to try and obtain commit improve flavor snarks with the universal SRS of a nice size. Yeah. And also I should say universal trust models are often paired with another property updateability, which just means I don't really need authority.
00:25:50.845 - 00:26:22.475, Speaker B: Anybody can contribute to the srs, to the randomness of the srs. And if there's at least one part that's honest in this process, we can trust that the SRS is done correctly and this is the setting we're in. More specifically, we care about universality. And to the bill, there's a chat question. Let's see if I can open it. The sourcing plan necessarily entrusted setup or any NPC ceremony. It's sort of.
00:26:22.475 - 00:26:53.493, Speaker B: Yeah. So Gustavo asks if I interpret the question correctly. If when you talk about structure reference string I always will need to talk about some trustee authority or mpc. Yes, yes. That's basically what we need in those settings. It's sort of a shortcut name for that setting. There are other intuitions in the name the fact that it's not random, it's got some structures or trapdoor from which the structure comes from.
00:26:53.493 - 00:27:32.635, Speaker B: But yes. Did that help? Yes, thank you. Thanks. Cool. So after I don't know how many minutes of background I am able to give a flavor, give a little bit of taste of the results we have in lunar eclipse. But then we need more background to understand them. But I hope I'm not going to lose you the scope of my presentation sort of to give an introduction to the general techniques that are used here in our tweaks.
00:27:32.635 - 00:28:25.905, Speaker B: So one way to look at the results in these papers from very very high altitude is we provide new ways to construct CP snarks with the universal inactivable structure reference strength in a general manner. There's some caveats to how generically but it's arguable. These are pretty general. They can be applied to several proof systems before giving more details of course more background for that. And this is going to bring me to a little bit of a digression that's important which is where do CP snarks or CP snark really come from? Right. And you may have some opinions on the topic but really they come from none of the above places but they usually come from compilers on information theoretic objects. And I'll tell a little bit more what they mean here.
00:28:25.905 - 00:29:00.009, Speaker B: I hope you're not shocked by that. But this is. So these compilers on information theoretic objects is a paradigm paradigm by which we can construct snarks, but it's also sort of really what naturally happens with natural. Where naturally snarks come from. There are some theoretical results. I'm not putting the explicit references here. We showed that if you have snarks, you're basically obtaining information theoretic objects of the flavor I'm going to talk about.
00:29:00.009 - 00:29:40.403, Speaker B: So there is the statement this is where snarks come from is morally true in computational complexity theory, if you wish. So what do you mean with this? Usually snarks what we do in practice, it's also private. What we do in practice, often implicitly or not, is there is a nice information to read the object. I'll tell you more about that. We use a nice crypto primitive or tool such as a commitment or a very dumb or simple proof system. Think polynomial commitments or vector commitments. And then we put them together in an interesting way.
00:29:40.403 - 00:30:10.917, Speaker B: We obtain a cryptographic persistent such as a snark. So our information theoretical object is something like a probabilistically checkable proof, a pcp. I'm going to give some flavor of that later. And it's an object here. It's represented as a. As a blueprint of sort, as a hologram, holographic. This word is going to show up again of here, the urban landscape of an actual building, for example.
00:30:10.917 - 00:30:38.185, Speaker B: But you need something to make it concrete. This something is a cryptographic tool of sort. The one on the left is a very lightweight object. It doesn't have any, usually doesn't have any harness assumptions. It exists out there mathematically without any assumptions. But then you need to move a little bit into the crypto world. I want discrete log to be hard and so I can prove something and so I can compile things.
00:30:38.185 - 00:30:47.865, Speaker B: Before I enter, I'm going to try and clarify a little bit of this. Have I lost many of you? Do you have any comments or questions?
00:30:50.335 - 00:30:56.635, Speaker A: I think we're doing okay. I think if anyone has questions, feel free to leave them in the chat or jump in.
00:30:58.935 - 00:31:33.925, Speaker B: So moving on, let's look at an example of. Before I tell you about the type of information threading object we're going to talk about as a warm up, I'm going to talk about the classic information threaded object here, which is probabilistically checkable proofs. If you heard about Interactive Oracle proofs Iops Iops are sort of a general and more general object than PCPs. PCPs have a long history and basically look like this. I hope you've seen them before. Maybe it's a little hard if you never seen them. But they're a proof system.
00:31:33.925 - 00:32:17.225, Speaker B: But they're sort of abstract in the following way. We have a prover that has an input public input X and a witness prior witness W. And what it does, it sort of pushes, puts up in the sky a big string, the pcp, the probabilistically checkable proof, which is a proof that he knows a witness W. But differently than the usual setting where we. The verifier text in the proof reads it, does some computation on it and checks if everything goes. If everything goes correctly. Here the verifier is just going to sample a few points of this pcp.
00:32:17.225 - 00:33:04.045, Speaker B: The PCP could be really large, but the verifier just needs to sample a few points and okay, I'm going to look at this point. Is there a point? Is that a point randomly sampled usually or with some distribution? And it's going to perform some tests on them and it's going to accept or not. What's the key? Intuition. That the proverb does not know the queries of the verifier. It puts this thing in the sky, it cannot change it, it's there, it's locked. And then the verifier can ask very few queries. Of course, the obvious question is this is a nice obstruction, but how do you ensure in practice that something is locked? Right, something is there, it's not going to change.
00:33:04.045 - 00:33:37.637, Speaker B: And here we start entering a more concrete vision of that. That's why this object is not very concrete. But nice thing is that these objects do not come from cryptographic assumptions. So how do we compile them? So we have this object and we want to get to the setting on the right. I have PCPs on the left as information threaded objects. And I want to get to an argument system. I want to get to a succinct, let's say for now, interactive arguments.
00:33:37.637 - 00:34:35.472, Speaker B: Right? So just a proof to a knowledge proof maybe where back the back and forth gives me and convinces me. And I'm going to use the classic compiler for this again. I'm just warming up to what I'm going to tell you later about our work is through vector commitment. You can think of vector commitments as merkle trees. Merkle trees are a vector commitment. And the syntax here in this very ugly font is the following so you have a Vector of objects U1, VN and then the vector commitment again think of it as a Merkle tree, for example, gives you a short commitment of this root of the Merkle 3, say. And then there's an opening algorithm by which I can show you that I can open to subset j, subset of indices, this vector, this commitment and it provides you proof of open.
00:34:35.472 - 00:35:04.199, Speaker B: Thinks of this as a bunch of paths in the Merkle tree. And then efficient verification algorithm takes an input, a commitment, the subset j, the claimed vector j. And again same type as before. There should also be the proof of open here actually, in the last algorithm. Yeah. So we can use this to compile everything. How do we do that? If we have a PCP think this is how we compile it.
00:35:04.199 - 00:35:59.841, Speaker B: I'm going to explain that in a second. So the prover of the argument we're obtaining, instead of pushing the PCP up in the sky, say, computes computer Merkle root of it, it does a vector commitment on it and it gives it to you. So it gives you the root of this Merkle tree, which is a commitment to the big string. If you know Starks, if you've seen iops, this is a concept, a type of compilation, that technique that you definitely seen before. And then we do the same thing as before. The verifier now samples a bunch of queries, but it gives them to the proverb and the prover answers with the same. The PCP is this big string and PCP queue means just the queue open the queue points the queue.
00:35:59.841 - 00:36:41.935, Speaker B: Projections of the PCP string plus a proofs of opening should be on the left. PyOpen is VC open. And the verifier does two things, checks the PCP thingy and use the proof of opening of the Merco tree as follow. This is Killian's compiler, Joe Killian's from Ability 95. It's one of the first examples of this. Now this is a interactive argument. How do you obtain a snark or snark out of this? Use via mirror normally, so you can compress all these steps.
00:36:41.935 - 00:37:04.321, Speaker B: So this is a general compiler that represents the pipeline. I told you before this one, but let's get back to our settings. So cool. This is a very interesting result. And this basic technique based on Merkel trees or vector commitments used in different places. But we're going to use different specific elements here. These three elements for us are going to be different.
00:37:04.321 - 00:38:17.695, Speaker B: What are they going to be? We're going to move from PCPS to phps so PHP stands for polynomially holographic proofs. And they're introducing lunar really stands for polynomial holographic RFPs. But they really their generalization, they're they build on the work of algebraic holographic proofs present in Merlin fractal idealized low degree protocols, ILDPs in Planck or polynomial Ps in the compiler papers. So if you know these given all these work, PHPs are just a little step that generalizes these approaches in meaningful manners. I'm not going to get into these presentations but sort of bring together unifies these approaches, for example and they're going to be useful for us because they're. Now there are these abstract templates and they're our information theoretic object. They're like PCPs where in PCPs you have this big string.
00:38:17.695 - 00:38:40.471, Speaker B: But now they're going to be interactive. There are iops if you're familiar with them. So the verifier can send challenges. And I'm going to give oracle access to things after each challenge. There's going to be a visual depiction of this later. And again, these are oracles. Yes, the responses of the prover are oracles, but not to strings, to polynomials.
00:38:40.471 - 00:39:32.717, Speaker B: We're going to exploit algebraic facts and polynomials and the queries that earlier were specific points of the vector. Now there are algebraic properties of these polynomials, for example they say the later but they are evaluations of the polynomials and random points, degree checks and such. Now for compilation, remember our wrench earlier was vector commitments. Now we're going to switch to polynomial commitment commitment. So if you have this, you can obtain universal SRS snarks. So snarks with a universal SRS that are efficient in practice and they have nice properties. And what you get just to this is just a very partial and out of date for example sample of the typos narcs.
00:39:32.717 - 00:39:55.575, Speaker B: You get sonic. Marlin, Planck. No 100% sure about Sonic, but definitely for Marlene Planck. You can straightforwardly. Yes, also sonic. You can straightforwardly put them in this framework. And this is just to give a flavor of the efficiency you get right.
00:39:55.575 - 00:40:26.505, Speaker B: These are snarks with universal srs. There are others of course here this list is focused on constant size, proof size and other measures of efficiency. Those for snarks. So our focus is on CP snarks. Can we have these nice general compilers that just tell you told you about for CP snarks and I'm going to check how we are on time.
00:40:28.065 - 00:40:29.445, Speaker A: I think you're doing good.
00:40:34.025 - 00:41:22.749, Speaker B: So we have general compilers for Snarks we'd like to have general compiler for CP snarks and efficient CP snarks coming out of them with Universal S and Lunar and Eclipse introduced them. So this is all this long background to explain what the contribution here is. Now let's look a little bit more to what we do. We propose new information theoretic objects. In Lunar we propose a compiler. In new information theoretic objects obtain CP starts with this property. And in Eclipse we showed that polynomial holographic proofs with a certain we can call it decomposition property.
00:41:22.749 - 00:42:23.129, Speaker B: I'm going to give a rough intuition, but that later can be compiled or can be compiled in some manner with polynomial commitments. The interesting thing about you can ask how general is this? So in general enough to obtain interesting proof systems. In Eclipse we basically take variations of Marlin, Planck and Sonic, or rather the information theoretic equivalent of these systems. And in Lunar we build on some of the Marlin ideas to provide a family of PHPs with different trade offs and different properties we show to compile them. So the Lunar compiler is a little bit more general, but rely and they're very similar and all of these are similar to other compilers in literature. But there are. There's some tweaks here later.
00:42:23.129 - 00:43:04.905, Speaker B: For example, Eclipse relies much on homomorphic properties or commitments. That's a key point also really in Lunar, just to. This is a caveat. Maybe there is a little bit. There's an extra property we need from php's not going until later, but arguably this property is basically I cannot think of persistent without the property and it's easy to bring them to the property with certain tweaks. What I'm saying is Lunar's compiler is fairly general. Also on the bottom of this slide you can see the cutesy acronym we have for Eclipse.
00:43:04.905 - 00:43:35.995, Speaker B: The intuition about that is that this is a commitment from Snark. Right? The commitment is a Patterson and it's also a wink to Luna. Cool. So what do we get out of this? Remember, we're trying to. Let's look at the asymptotics for a second. For example, how efficient are these things? We have a relation that looks like the one on the right and our public input is X and L commitments. Okay.
00:43:35.995 - 00:44:28.945, Speaker B: And each of these commitments is committing to a portion of the witness which is say your size D. So this is our notation and Right. So as far as we were aware, general purpose proof systems with with this property. So SRS certain type of verification and proof side, for example these three in the table over here In Eclipse improvement. Eclipse and lunar improvement, the state of the art for proof size and verification time. You can see how while they have similar asymptotics in terms of proven time. Very close actually.
00:44:28.945 - 00:45:24.765, Speaker B: And this sort of a general thing because it depends on the sensation, the proof size and verification time offer a trade off of sort. So for example, in lunar, in eclipse, Eclipse you have this logarithmic dependency on the number of commitments in the size D of what they're committing to, but you paying verification time. So if you're committing to many things. Sorry, if you're committing too many things, sure this is inherent, you need to read them. But if you're committing to things that are big, you're paying for it. Whereas this dependency, for example doesn't occur in lunar, but you have a crucifix which is lunar right now. Okay, is this notation trade off clear? If you have any questions.
00:45:24.765 - 00:46:14.771, Speaker B: So this is sort of a summary of the results and what I'm going to do next is I'm going to give a. I'm going to get back to the high level. Sorry, the blueprint we talked about in case of PHPs, we're going to open the box and I'm going to show in very abstract terms like very high level, how we tweak that Eclipse. So we're going to see compilers from PHP to snarks. This is prior work. And then the tweak to log completion in Lunar compiler and the decomposition property we need. This is all going to be very high level.
00:46:14.771 - 00:46:47.407, Speaker B: And then a couple comments on these specific techniques. Maybe I'm going to go fast on all the blueprint stuff and then maybe so I can spend a little bit more time. Remember pcps? There was this. Here's an ugly picture of php. You may remember the ugly picture of the PCP which had this prover with the big string. The verifier had the Oracle access to the php. You may remember tweaks PCPs with two ways.
00:46:47.407 - 00:47:20.085, Speaker B: There's interaction. So here you can see that the verifier can ask challenges. And after each challenge the proverb pushes something up in the sky, pushes a P, a polynomial PI. Yeah, so think of iops, but with polynomials instead of strings. And at the end the verifier, this is the information through the object. The verifier comes up with a bunch of queries. Q But these queries and these queries are not.
00:47:20.085 - 00:48:09.545, Speaker B: These are not projections of a vector anymore. These are algebraic questions. The verifier is asking to display normals in the sky it can ask questions such as Is the degree of P2 lower than this? Then do these polynomials satisfy this equation here Q can include two random points and it can query the polynomials in a way, say in the example on the bottom right. So some linear, some combination is not the of the polynomial. So you can ask equations of this sort. So if we need three things, right, to compile we need the information through the objects and the PHPs. But we also need this ingredient, this cryptographic primitive to obtains NARCS on the right.
00:48:09.545 - 00:48:55.325, Speaker B: What I'm about to describe is a non compiler. This is polynomial commitments. And what we care about is that if you have a commitment to a certain degree polynomial certainly agree the commitment is very small and it's sort of a proof system. Indeed this is not the language we use in Lunar. We don't talk about polynomial commitment, we talk about specialized proof systems or snarks for only commitment to polynomial. And this should allow you to proof evaluation of a committed polynomial. Give me a point and I'll tell you prove to you that the polynomial agree and other properties.
00:48:55.325 - 00:49:33.847, Speaker B: I'm going to introduce this notation for polynomial commitments. If you have a polynomial PI, I'm going to represent with the circle the polynomial commitment to it. And this is in contrast to the square commitments from before. The square commitments are the input to my relation, the input to the verifier that these commitments, these are part of the transcript, these are part of the proof. So we have a php, right? How do we compile it to an interactive argument and then to a snark. We're going to do what we're already doing. We are going to do what we do with IOPS.
00:49:33.847 - 00:50:20.633, Speaker B: We're going to do what we do with PCPs. What I told you later with the merkle trees, but in a different way. So every time the verifier asks me a challenge, I as a prover, instead of putting something in the sky, I commit to it and I give you the commitment to the polynomial. And we do that again for all challenges that until we have exhausted all rounds and finally we can say, okay, I'm going to ask you query a bunch of queries. And normally the verifier is oracle access to this, right? But now it doesn't. So the proverb says, cool, I'm going to show you that these queries are satisfied and with respect to these commitments. So it gives an additional certificate.
00:50:20.633 - 00:50:52.795, Speaker B: Earlier it was a proof of opening write the paths to the merkle tree, but now it's going to get this additional certificate and calling Pipoly. It's a proof of certain properties of the commitment, an opening of polynomial commitments, if you wish, with query skew. That's it. And the verifier checks them. This gives you an interactive argument. Cryptography. Do you make a snark out of it? You use fishermere, for example.
00:50:52.795 - 00:51:50.985, Speaker B: But why? Let's get back to this. The important point is we're talking about universal SRS snarks. How come the structure reference string is universal here? What's the universe? What's the SRS here in the first place? It's actually. It's the parameters of the polynomial commitment. So the setup of the SNAR is the parameters of the polynomial commitments which just depend on the maximum degree of the polynomials. So and that's why it's universal, it doesn't depend on specific relations. The setup takes input abound on the size of the relation and there would be a degree, a bound on the degree of the polynomials you're going to use later, right? So that's how you can use this blueprint to obtain USRS nux.
00:51:50.985 - 00:52:42.971, Speaker B: This is prior work. How do we do the for CP snarks who use the same recipe, for example, remember, we want to talk about commitments, right? And we are sort of. We want to give commitments the verifier can use to verify these things. We are using commitments, these circles over here in the transcript, right? Why can't TARI use them? These commitments are encoding the witness after all. So they depend on something the in the witness in some way. And this is a straw man. I'm about to take this slide, right? Just as intuition, could we just reuse them as commitments for the commitment can we use the circle commitments as a squares.
00:52:42.971 - 00:53:51.925, Speaker B: So basically I prove something to you today about witness W and you give me this transcript, this proof that depends on this CIs, right? This, the circle CIs. Can't I use them tomorrow in some way to talk about the same witness again with different property? Well, there's a few problems with that. One problem which I mentioned in this slide explicitly is in general, this may break through knowledge and the intuition is that what you're doing with this PI poly queue in the bottom right is you're proving certain things about what's in C1, what's in the circles. But these commitments can, for example, keep being hiding, keep the whole thing, zero knowledge only if you ask a certain amount of information. So you cannot query them again in general. That's what I'm trying To say, so we need to come up with something else. I'm taking time again, but we're sort of approaching up here and so there's.
00:53:51.925 - 00:54:50.863, Speaker B: There's a little bit of something extra I need to do here. And let's think about this setting a little bit more first. What's the syntax you want difference between the snark syntax, specialized CP snark syntax, that we have this input commitments here. I'm going to assume there's only one square and we know how to use the previous recipe for the R part, right? A relation CPU relation is made of two parts and to do with the opening end in the other, the big block R. The blueprint I just showed you can be used for the big blue for the big R part, right? That's what the compiler that gives me a snark for the relation. So if I have an input X, W and whatnot, I use the snark part to prove something about X and W. But I still need to prove something about the relation between W and this square thingy.
00:54:50.863 - 00:55:54.565, Speaker B: I need to prove that the square is open to W. How do we do that? We add the next string gradient. Sorry for the handwriting again, which is sort of a link improve piling, which depends on the squares and the circles basically links this input, this long term commitment, you can think of it as this commitment that you made 30 years ago or last year on the blockchain or the coin or like a state of the blockchain, if you want to. And you want to link it to the transcript, to the commitments in the transcript. Give me a proof how they're linked. Give me a proof that what's in the square is connected to circles. More specifically, what does it mean in practice? Right? So in Lunar, for example, basically we need an extra property from the PHP which is we call straight line extractability.
00:55:54.565 - 00:56:51.011, Speaker B: You can think of it as a special extractability of sort. It says that given the polynomials of the transcript, you don't need any rewinding. Given the polynomials, I just look at them and I know what the witnesses and this is in practice, this is true of many systems, of all the ones you can think of. Because, for example, these polynomials in code say they if you have a witness deploying elements are use the witness components as coefficients or they interpolate the witness the interpolation. So given this property, what you do in PI link, PI link is a specialized proof for the following proofs. Knowledge of this W such that the square thing opens to whatever fraction right portion of W and this is one of the important part. And in each of the circles open to the polynomial, the right polynomial.
00:56:51.011 - 00:57:56.015, Speaker B: So it's sort of polynomial commitment opening and that this extraction property satisfied by the PI is committed in CI in this. So in. So that's a Lunar compiler and Eclipse is similar but uses explicitly homorphic properties. A commitment saying needs this additional property, which I'm not going to discuss so much, but basically says these, these polynomials you're getting the transcript can be composed in a nice way through addition. All right, so that's a very, very high level view of these two compilers. If you know how compilers for snarks work for snarks based on holographic techniques, you want to move them to the commit improve setting. That's sort of a template of how you can do that for Engine General.
00:57:56.015 - 00:59:09.289, Speaker B: I'm going to say a few other things about linking specific linking lunar and the challenge is this. So you have these long term commitments, right, which are. You can think of them as KZG polynomial commitments to the encoding of the witness and they appear and you're proving a certain property about them. So for example, you have a commitment to a database and the computation is some circuit that depends on some other private witness of the database, right? Now the opening of this database could be anywhere in the witness. Part of what you need to prove is that it's sort of some in some offset, it's in some representative. So given that you know that W is also encoded in the transcript commitments the subaltern circles. So basically this is not really informative really, but you need to decompose.
00:59:09.289 - 01:00:12.835, Speaker B: These are all polynomials and different usually their interpolation polynomials in different domains. You decompose them appropriately and what we obtain is it's a is a pairing based linking proof that since we do this for each of the committed inputs is of L size, each of these given a commitment square commitment CI, this link improves going to be a constant size by l times. This is where the asymptotics come from in Eclipse there are some similarities in the technique. So overall be hard to summarize it here, but there's an important. There's a divergence in techniques at some point. So first, although I haven't said that explicitly, the square commitments are different species here. Here we're talking just the CI square are normal Patterson commitments.
01:00:12.835 - 01:01:27.771, Speaker B: And so given all these CI hats over here in the equation, you can think of them as the square commitments and they have these sub witnesses W1WL and what you basically do, you give an additional commitment the squash system around and you give a Sigma protocol like scheme to prove that these new commitments here on the left is basically opens to a concatenation of these guys. But then this is since given the techniques this will be. What's the asymptotic communication complexity of this? It's LD because you have this W1WL and they're each of size D and you have all of them. But then you can use compressed sigma protocol tricks and get to logarithm, which is what we're doing to get to a logarithmic size. But there are some other approaches. Lunar is other things. It's not only about commit improve.
01:01:27.771 - 01:02:05.781, Speaker B: I'm just going to mention a couple things. It also introduces this PHP's framework which generalizes previous approaches and it's been used in other systems to introduce a new constraint system. You may know rank one constraint system and R1CS Lite is sort of a simpler version. It's got one less equation. But it turns out this is. This can be helpful to obtain more efficient snarks. It's also started to be used and we offer concrete constructions which improved on the state of the art in several metrics.
01:02:05.781 - 01:02:51.671, Speaker B: Although by now all I believe all of the metrics in which we improve. Although maybe there's a more fine grained comparison. One could they've been further improved by Basilisk. This paper by Calarafos and Arantia Topico that appeared at crypto21 and basically represents the state of our force Knox in universal SRS as far as I'm aware. Okay, so what did we see? We saw how to build generically CP snark with universal srs. There's a couple differences between these two papers I told you about. One is uses very modeling flavored proof systems and uses KZG as a proof systems as these commitments.
01:02:51.671 - 01:03:36.761, Speaker B: Pardon me, where is the other Eclipse? This is Pedersen but offers committed proofs narcs for other proof systems besides Marlin Flavored Funk and Sonic. Actually the techniques in Eclipse could be used on top of Lunar as well. And one could obtain something else. Okay, and I'm just going to close with some open questions. So the table, the first two rows of the table on the right represent what we obtain in these two Persistence. Right. And if you look at the verification, can we improve the verification time? Say among these two, the best is Lunars, which is all.
01:03:36.761 - 01:04:14.765, Speaker B: Well, that's inherent because your input is commitments. You cannot do better than that if you're in the input. But can you Improve, say, improve size. So can you obtain something which got the best of both worlds? So, and even better, can you get something which is not dependent on the number of commitments? And probably this could be done. I mean, not in a trivial way, of course, you can always do that putting a proof system on top. But can you use some. Do you have proof system that's friendly to the type of things we do? And I believe there could be.
01:04:14.765 - 01:04:53.915, Speaker B: There are already existing techniques or could use that basically will use one level of specialized recursion on this. The other open question is, so can we have some. Which I gave you some linking techniques. Linking meaning how do you go from input commitments to the transcript commitments? Right. And are there other techniques besides the one we use? And these techniques we use, can they be used for something else? Wherever we have polynomials in different population domains, such and such. Yeah, that's it. Thank you so much.
01:04:53.915 - 01:05:01.315, Speaker B: That actually ends the talk. Let me know if you have any questions. Cool.
01:05:01.735 - 01:05:08.155, Speaker A: Thank you so much, Mateo. Oh, I don't know if you can see me.
01:05:08.495 - 01:05:10.135, Speaker B: Yeah, I can see. Cool.
01:05:10.175 - 01:05:23.635, Speaker A: Cool. Okay. A question related more to applications. This is from Gustavo. Where to get more info on proof correct training in machine learning. Preferably non academic articles.
01:05:24.335 - 01:05:41.781, Speaker B: Thank you for I came back to you. I'm not an expert on the topic, but I know some people who work actively on that here at Ocean University, for example, if you can write. Fantastic. I'll take a note of that. Cool.
01:05:41.813 - 01:06:04.245, Speaker A: Yeah. And actually if you do share any of those links, maybe we can also share some of Those in the YouTube video in the show notes underneath. Cool. And I think that wraps up the presentation. So thanks again for coming on the ZK study club session video stream and sharing this with all of us.
01:06:05.785 - 01:06:07.165, Speaker B: Yeah, no problem. Thanks.
01:06:07.625 - 01:06:26.265, Speaker A: Cheers. All right, so now we can just stop the video. You can hit the stop button up at the top. I think yours is still on.
