00:00:05.450 - 00:01:02.558, Speaker A: Welcome to Zero Knowledge. I'm your host, Anna Rose. In this podcast, we will be exploring the latest in zero knowledge research and the decentralized web, as well as new paradigms that promise to change the way we interact and transact online. This week I chat with Zach and Joe from Aztec Protocol, the folks who recently released ZK Money. We talk about this exciting new private ZK roll up or ZKZk roll up and explore how this is built and what role it aims to take in the ecosystem. But before we start in, I want to share two quick notes. First, if you're looking to start working on ZK tech and you are a student cryptographer, software developer, practitioner in blockchain or privacy, tech researcher or engineer, or even if you're not working in the ecosystem yet, be sure to check out an upcoming event that I'm putting together called ZK Jobs Fair.
00:01:02.558 - 00:01:29.342, Speaker A: This will be an online social event giving you the chance to connect with some of the coolest ZK companies in the space. You can follow the zero Knowledge Twitter account for more info and be sure to apply today to get access to this event. It happens on April 22. I've added the link in the show notes. Hope to see you there. Secondly, I want to say a big thank you to this week's sponsor, Ave. Ave is an open source, decentralized, noncustodial liquidity protocol on Ethereum.
00:01:29.342 - 00:02:08.418, Speaker A: With Ave, users can participate as depositors, meaning they provide liquidity to earn a passive income, and they can also act as borrowers to borrow in an over collateralized way or in an under collateralized way. Think one block liquidity flash loans that we've discussed a few times on the show. Avi has also deployed a new market on polygon sidechain to let users pay much lower gas fees. Assets can be transferred from Ethereum to the Polygon bridge and put to use on Ave's Polygon markets. You can learn more about it in a blog post that I've shared in the show notes. And if you want to find out more about Ave, visit ave.com. So thank you again, Ave.
00:02:08.418 - 00:02:21.226, Speaker A: Now here is my interview with the guys from Aztec. So today I'm chatting with Zach Williamson and Joe Andrews from Aztec. Hi guys, welcome to the show.
00:02:21.328 - 00:02:24.106, Speaker B: Hi. Yeah, it's great to be on. Thanks for having us.
00:02:24.288 - 00:02:33.110, Speaker C: Yeah, likewise. Very excited to be here. This is actually my first podcast ever, I think, so I've listened to. So exciting.
00:02:33.270 - 00:02:38.960, Speaker A: That's very cool. So yeah, Zach, you've already been on this show. I think this might be your third time coming.
00:02:39.490 - 00:02:50.706, Speaker B: Yeah, I think it is. I was on a while ago, back when we just launched our first iteration of, I guess, what was ZK money using a very different kind of crypto protocol. A lot has changed since then.
00:02:50.808 - 00:03:12.598, Speaker A: You also came on with Ariel last year to talk about plank, and it was a very crypto heavy one. I'm going to add links to both of those in the show notes, I guess, if people want to hear a bit of the history of this project. And Joe, as you mentioned, this is the first time you're on the show. Let's start with you, actually. Why don't you introduce yourself? What are you doing at Aztec? What's your gig?
00:03:12.694 - 00:03:40.222, Speaker C: Sure. So me and Zach originally met nearly three years ago, now back on the entrepreneur first accelerator program. And I guess my role at Aztec is trying to hide away all of the zero knowledge cryptography that Zach's been coming up with over the years and make it either user friendly or developer friendly. So really focused on, I guess, the go to market and putting this technology in the hands of everyday people, which is super exciting.
00:03:40.366 - 00:03:42.260, Speaker A: Would you call yourself a product person?
00:03:42.790 - 00:03:59.574, Speaker C: Yeah, I'd say so. I'm kind of originally technical, but not to the same degree as Zach or of. I put the cryptography in black boxes and vaguely understand what each one does, but can then wrangle that into, hopefully a nice to use product.
00:03:59.772 - 00:04:09.830, Speaker A: It's true that working in this space, the term like a technical person kind of changes. Like, the level of technical you need to be considered a technical person definitely increases.
00:04:09.990 - 00:04:16.830, Speaker B: Yeah, it's a bit weird because in a normal company, Joe would be considered an extremely technical person. It's just a different kind of technical.
00:04:17.250 - 00:04:36.930, Speaker A: Yeah, some people think I'm a technical person, but in my mind, I'm the like, that's the level of technical that I get to be. But, yeah. Zach, I want to hear from you, given that it's been over a year that you've been on the show, what's new? What's happening for you on the aztec side?
00:04:37.080 - 00:05:31.494, Speaker B: Yeah, what's new? A lot's changed. So last time I was on the show, Ariel and I were very excitedly, I believe, talking about this cool new research project we'd published called Plonk, which is an extremely fast, universal ZK snark proving system. And since then, we've been building plonk and actually implementing it, turning the paper into something real. And this has culminated in the launch of what we're calling ZK money. It's the world's first private roll up that we launched on Ethereum in March this year. And so basically, it's scalable private transactions running on top of Ethereum blockchain, which uses our state of the art proving system to combine both strong user privacy using zero knowledge proofs, so that when you're performing cryptocurrency transactions, all the information is encrypted, but you can still prove that you followed the rules, that you're not double spending, et cetera, by serving a zero knowledge proof proving this. And we've also used our technology to do some scaling as well.
00:05:31.494 - 00:05:52.198, Speaker B: So instead of sending these private transactions to a blockchain like Ethereum to be validated one by one, what we actually do is we aggregate a large number of private transactions inside a ZK roll up. So we have the snark circuit, which verifies the correctness of a large number of other snark circuits. And what that allows us to do is basically just post one transaction to Ethereum that represents hundreds of transactions.
00:05:52.374 - 00:06:05.646, Speaker A: Wild. I want to dig in on this, but I do. Before we do that, I want to kind of follow the path from aztec one to aztec two, because. Is that what you're calling it? Is it like aztec version two that is currently live?
00:06:05.828 - 00:06:15.166, Speaker C: Yeah, I'd say so. There is an Aztec three in the works as well, but, yeah, so we could talk about that as well. But the current live version is Aztec.
00:06:15.198 - 00:06:30.006, Speaker A: Two, but like Aztec one. Going back to that really first episode that we had you on, there was this different zero knowledge proof construction. Have you thrown all that out? And now it's plonk. Is that what replaced what was there? Or is there other changes?
00:06:30.188 - 00:07:11.794, Speaker B: Yes, so there are other changes, but, yeah, we've completely rearched the protocol and thrown out the old proving system. Aztec one was kind of, I guess it was our first attempt at privacy on ethereum, and that was, it feels like a long, long time ago, but I guess it was only about two and a half, three years. But back then, universal snarks weren't really a thing. Like, if you wanted to take a general abstract program and turn it into a zero proof, you needed to use snark constructions that required trusted setups for every single program that you were writing. And for what we wanted to do, which was we wanted some level of programmability so that users could kind of create their own private crypto assets and program how they get transferred around. We thought that this requirement to do all these trusted setups was a little bit untenable. So we were looking for workarounds.
00:07:11.794 - 00:07:35.998, Speaker B: And so ASIC one was a zero knowledge proof which tried to solve some of those issues, but in a very different way to modern ZK snarks. It was what's called like a Sigma protocol. It was quite an old fashioned bit of tech, I guess, looking back, and it had a lot of compromises that we weren't happy with. It's why we started researching universal snarks. It's why Ariel and I put together plonk. So once we had plonk, basically, that immediately obsoleted all of our old tech, so we thrown it out.
00:07:36.084 - 00:07:36.622, Speaker A: Cool.
00:07:36.756 - 00:08:12.650, Speaker C: I think it's worth, like, even though we kind of stopped supporting it publicly, it's had some resurgences. Aztec won in the private blockchain space. We don't kind of really support it as a company, but it's been used by the bank of Thailand for a pilot on kind of CBDCs, which is really cool. And they basically just took it as is as an unsupported piece of tech to get a form of privacy on a private version of Ethereum, which was pretty cool to see that even the kind of old world tech, as Zach's probably thinking about it these days, is still useful in some applications.
00:08:13.790 - 00:08:43.086, Speaker A: I want to talk about plonk and kind of the impact that plonk had generally in the ecosystem, because when you presented it last year, I remember Ariel and yourself, you were excited about this finding. And since then, what I've seen is so many more teams get excited about it. It's almost become like, at least maybe not the de facto, but a de facto for a lot of these teams, especially the new ZK teams. What have you seen around that? Did you expect that? Are you excited?
00:08:43.198 - 00:09:23.658, Speaker B: Yeah, we're really excited by it. Certainly when our eyelet put it together, we realized it was kind of, it solved a real need that we had, and we knew that other teams in the space had the same need, which is like, we want a faster ck snug that doesn't need a ton of trusted setups, but it still needs to be succinct. So you need to be able to efficiently verify proofs in an Ethereum smart contract. And we knew that plonk was the only thing that really fit the bill. I guess when we first published plonk, we knew we were onto something good. We've worked a lot on it since then. So we created another version which we call turboplunk, which has these things we call custom gates, which is really taking off, and our latest version using this lookup research we've been working on is called Ultraplunk.
00:09:23.658 - 00:10:10.814, Speaker B: But yeah, it's amazing. It's really quite kind of heartening to see it take off in this space and see the number of awesome projects using it. So I think the electric coin company is building plonk based things. Mina protocol are using a variant of plonk, Matlabs are using plonk and many others, which I'm forgetting. I think one of the reasons why it's taken off so much is because I think this is really the first ZK snark brewing system that was kind of engineered because all of the other systems kind of. They've come out of very academic contexts, which means that they have some trade offs which, for use in industry, make them a little bit less than ideal just because the designers had other priorities in mind when they were putting them together. But with plonk, because we kind of combined Ariel's deep theoretical crypto knowledge with some of my experience as a software engineer, and we really created it to solve some problems.
00:10:10.814 - 00:10:30.018, Speaker B: We're like, we actually want to write real world programs with this and put them on a blood blockchain. How do we actually kind of mangle and mutate the mathematics to get this working in a way that you can engineer meaningful programs? Yeah, I think that's one of the reasons why it's taking off, because we're not the only team with many, many other teams have the same problems that we have with regarding needing extremely fast, snap proof constructions.
00:10:30.114 - 00:11:02.622, Speaker C: I think it's also just great to see the amount of brain power that's kind of collectively being poured into it is actually making it think more trusted as a technology base for the whole community. So if it was just an aztec project, still today, I think be hard to kind of convince people around its kind of security guarantees, but now the underlying technology is pretty widely understood. That burden, I think, is shared, and there's a lot more kind of community resources helping people understand the kind of really complex cryptography behind it.
00:11:02.756 - 00:11:19.254, Speaker A: Another kind of big finding, I feel this year was like the introduction of Halo, but also this sort of formalization of what Halo does. Did that influence, or is there any sort of impact on the way you're thinking about Planck, given some of those new findings? Have you incorporated anything like that?
00:11:19.372 - 00:12:03.022, Speaker B: So we would like it to impact how we think about plonk, because Halo is like a really impressive and cool piece of tech. So this idea of proof aggregation is certainly something which is on our minds for future versions of plonc to see if we can jerry rig some version of it into what we're using. And it's certainly like the plonk proving system is really ideal to be adapted and to be used with this halo star recursion, because you can create all these custom gates which kind of make these very niche prime field operations that halo requires efficient. Because we're working on Ethereum, we have some rather unusual constraints we're working under, which is that right now Ethereum only really supports one elliptic curve that's pairing friendly. It's going to support two in the future. Bn two five, four and BLS twelve, three eight one. But neither of these are particularly halo friendly.
00:12:03.022 - 00:12:25.162, Speaker B: So the problem is, if we implemented halo as is the verification gas costs would be hundreds of millions of gas, if not like maybe tens of millions, but either way, a little bit too high for us. But yeah, if there were any protocol changes to make halo verifiers practical on Ethereum, we'd jump to a heartbeat for sure. And there's certainly a lot of meat on the burn regarding prefabrication that can be adapted by other halo like systems, for sure.
00:12:25.296 - 00:12:44.142, Speaker A: This is actually interesting, because from what I understand you're saying is like a plank vanilla plank, not on Ethereum could already be used with some of these proof aggregation techniques alone. But because of the particular curves that are available on Ethereum, it becomes, I guess, just more expensive. You can do it, but it would be just not worth it.
00:12:44.196 - 00:13:06.294, Speaker B: Exactly. Yeah. So we've had to use a different kind of way of doing recursion. Technically, formally it is a proof aggregation scheme, but that's kind of more semantics. Well, because basically with this private role we're doing, we do need this thing called like recursive proof composition. You need to basically create a ZK snark circuit that can verify ZK snark proofs, which is typically very hard to do if you only have access to one lifter curve. It's really hard to do.
00:13:06.294 - 00:13:47.762, Speaker B: But that's one of the things that we really engineered plonk to solve, particularly this version we call turboplunk. So the way that we do it is kind of we take a brute force approach, where if you want to verify a snark proof, you've got to do all this very complicated and expensive theoretical operations and prime field operations that aren't easy to do in a snark, and we kind of just brute force it. Plonk is fast enough to get the job done. Regardless, we do do a little bit of proof aggregation to reduce so basically, the plonk proofing system, to verify a plonk proof, you need to do elliptic curve bilinear pairing. But if we're doing this recursively, we aggregate a bunch of plunk proofs together, so we only ever end up doing one pairing. So it's got overlaps with Halo, but Halo has a much more elegant solution for how to verify proofs that unfortunately, we can't really use because Ethereum only supports one curve.
00:13:47.826 - 00:14:20.926, Speaker A: Got it. Recently, I think it was in a talk that I did with Justin Drake and Isaac Meckler from Mina, we talked about sort of these three layers of the ZK stack plonk kind of fitting in that middle layer, the IOP layer. What we're talking about now is the aggregation layer, which is layer three, but on the layer one, on the polynomial commitment side, is that where that Ethereum, like what Ethereum supports is a problem or not a problem, or is that something else? I'm kind of curious how you're dealing with that part.
00:14:21.108 - 00:14:32.530, Speaker B: It's slightly something else. So the curves that Ethereum supports constrains what aggregation schemes we can use. It also constrains what polynomial commitment schemes we can use, but the two are kind of uncorrelated.
00:14:33.510 - 00:14:39.830, Speaker A: Yeah. So it's something even like above that that's basically determining which track you're going to be able to use.
00:14:39.980 - 00:15:20.034, Speaker C: It's actually for the private roll up context, it's the client prover, because these proofs are running on user devices in our roll up, compared to kind of a normal ZK roll up when they're running on like a big AWS machine. It's the memory footprint of the prover being able to run on the client device that lets us select the correct polynomial commitment scheme. And the team's been doing a lot of work on that to kind of shift the polynomial commitment scheme to try and get under the WASM memory limits for actually running this on mobile devices. So we've got a lot of constraints from Ethereum to kind of old Android phones or old iPhones being able to run these.
00:15:20.232 - 00:15:44.426, Speaker B: Yeah, yeah, definitely. So, yeah, there's been some iterations on the commitment scheme side, too. Plonk was published. It was kind of deliberately commitment scheme agnostic, but the version of the protocol will be described in full use. This commitment scheme by Aniket Kate. But our latest versions that are in development, we're migrating to the commitment scheme that was described in the Schlunk paper by Ariel Gavazon and Justin Drake. And yeah, there's also been some really cool innovation on the commitment scheme side.
00:15:44.426 - 00:15:58.880, Speaker B: I know, like Mary Mallor's published recently a paper where a commitment scheme where the asymptotic performance is strictly better than the existing schemes. But again, the problem with all of the new stuff is that it requires new cryptographic primitives, which you just can't access on Ethereum right now.
00:15:59.490 - 00:16:25.318, Speaker A: So I feel like we jumped in really deep for our listeners pretty quickly. Maybe we take a little bit of a step back and start to describe on a higher level what ZK money is and what that product is, and then maybe we can fit back in where plunk and all of these things exist within it. So why don't we go through what does Zkmoney look like?
00:16:25.484 - 00:17:14.402, Speaker C: So Zkmoney is just a front end, really. It's our flagship product of what's possible with the aztec kind of technology stack. And I think we built it because scalable private transactions weren't possible on Ethereum before. So we felt we needed to kind of show what was possible. And all of the work that Zach and the team's been doing on getting plonk to be super efficient on the client side has kind of, I think, reset the user experience expectations of kind of clients running ZK snarks on their devices. So we built ZK money to kind of show that you can get almost like a web two kind of experience, like a venmo style experience for paying people. But this is running on kind of a web three ZK stark stack.
00:17:14.402 - 00:17:27.846, Speaker C: That's why we built it. And the goal of it is to kind of showcase to users and developers what's possible on the network. And we've had pretty incredible uptake and demand from users trying to kind of get privacy on Ethereum.
00:17:28.038 - 00:17:36.510, Speaker A: So you're saying the ZK money, that's sort of the front end to this thing, behind the scenes is what's running a ZK roll up, or is it something else?
00:17:36.580 - 00:18:08.822, Speaker C: Yeah, so it's a ZKZk roll up. So as Zach was saying earlier, we're kind of calling it a private rollup. So we have very, very optimized WASM code, which runs in our SDK, in the browser. And that's kind of the first, I guess, gateway into this kind of proving system. The client there is creating proofs to obscure transaction data from a roll up provider. So we're processing transactions that contain ZK snark proofs rather than just public Ethereum data. So that's step one.
00:18:08.822 - 00:18:20.460, Speaker C: And then that transaction, once it's constructed on the client is then fed into our roll up prover, and they're all bundled together to validate hundreds of thousands of transactions in one go on main net.
00:18:20.910 - 00:18:43.074, Speaker A: I'm trying to kind of picture how a token moves through this thing. So you send something to a contract on the l one, it locks kind of like the same way we understand a ZK roll up, but somewhere in that there's this privacy element, and I kind of want to understand even closer where that is and where that happens.
00:18:43.192 - 00:19:30.210, Speaker C: Sure, I'll take a stab and Zach can fill in the technical thing. We have a different state model to Ethereum, so Ethereum is obviously account based, and it's quite hard to do privacy or full privacy in an account based model. So once the tokens are deposited to the layer one smart contract, the ownership record is stored in effectively two Merkel trees. So all state is recorded as these Utxos in two Merkel trees. So it's a similar design to kind of the original Zcash protocol, but kind of retrofitted to an Ethereum smart contract. And then users can prove existence of value in those merkel trees. And if the leaves are encrypted, you can get end to end privacy.
00:19:30.630 - 00:19:44.600, Speaker A: And so there is when you move that you've put one token into the smart contract, a new one has appeared in the roll up, but it's not private yet, right? It's like it's this sort of unshielded version first.
00:19:44.970 - 00:20:27.166, Speaker B: Well, ish, you get a little bit of privacy from the start, because what happens is, so as Joe says, you deposit into Aztec, our aztec roller smart contract, acts kind of as a custodian of your tokens, and in return it issues you a zero knowledge note. So it issues do with this encrypted object, which is a claim on the tokens you've deposited that you can freely exchange back into tokens whenever you want. And then obviously you can trade around this claim to other users, you can split it up, you can do whatever you want with it. So obviously if you make a deposit, everyone knows how much you deposited because that transfer is public. But the zero knowledge note you get issued, nobody knows when you've spent it, and nobody knows the identity of the aztec address which owns the note. So you get some obfuscation straight off the bat by making a deposit.
00:20:27.278 - 00:20:30.566, Speaker A: But is that all roll ups? That's kind of something that all roll ups already have or.
00:20:30.588 - 00:20:46.794, Speaker B: No? Well, no, because with all roll ups, you would have like a special roll up identity, like a roll up address that would be public. So what happens now is in ASIC, when you make a deposit, you get your zero knowledge note. It has an owner, but that owner address, that ASIC address is encrypted. No one knows what it is.
00:20:46.832 - 00:21:00.430, Speaker A: I see, okay. Yeah. And actually what I've seen on most of the rollups is like you'll have the equivalent address on both the roll up and the main net. And here you don't. I guess you have the main net address that you're using for that wallet. And on Aztec you already have something else.
00:21:00.580 - 00:21:00.990, Speaker B: Exactly.
00:21:01.060 - 00:21:39.290, Speaker C: Yeah, I think that's an important point. It's kind of, on Zkmoney, we've given users aliases. Eventually they'll be replaced with EnS domains. But it's the first time when you can actually say, hey, pay me at this address, but you can't see anything about my payment history when you look up that address. So yeah, we're kind of using that style of system to allow us to tell users where to send funds. But because the actual ZK node is end to end encrypted, there's no kind of further information that can be gleaned from the alias other than the public key that's used to encrypt the value. So it's a pretty cool system.
00:21:39.290 - 00:21:46.606, Speaker C: I like to think of it like kind of the signal end to end encrypted messaging, but for payments. So it's a similar design, I'd say.
00:21:46.708 - 00:21:58.100, Speaker A: Although we haven't quite finished the journey though. Right. This is just that first jump. Where does it go after? Why do you even have shielded as an option? I have checked out the website, by the way.
00:21:58.870 - 00:22:20.182, Speaker B: Yeah, this is just kind of what we consider the end of the beginning with regards to what we're building ASIC to become. So right now, the main value is privacy. Private transactions you can shield. And then once you've shielded your tokens, you can either within our roll up, you can privately send them to people. And I had this rather an interesting experience that when we launched ZK money, somebody sent me 0.1 e ZK eth. I had no idea who it was.
00:22:20.182 - 00:23:06.950, Speaker B: So whoever that was, thank you. And then when you withdraw from the system, when you convert your note back into tokens, the withdrawal address can be any address you want. And nobody can link your deposit transaction with your withdrawal transaction, because when you create one of these zero notes, nobody knows when you spent it other than you. So that's kind of where we are at the moment, where we want to be, where we're going in the future is programmable privacy. Because right now we think fundamentally, privacy is necessary for blockchains to really fill their true potential. Because the more that people's economic lives and financial activity move onto a blockchain, the more important privacy is going to become, because the more information you're leaking. If we live in a world where your salary gets streamed on a blockchain, or where a lot of your payments and your payment history is being made on a blockchain, that's not going to be something you want to be broadcast to the world.
00:23:06.950 - 00:23:45.826, Speaker B: We want ASic to fill that, fill that gap, basically, where in the future we can use our technology to make fully programmable private smart contracts. So not only can you create your own private cryptocurrencies, you can also define the kind of the semantics around how they're transferred. You can add terms and conditions and logical checks like regular ERC 20 tokens. You'll be able to create private, non fungible tokens where the owners are private. Or also importantly, you can kind of obscure certain bits of information about the NFT and kind of conditionally prove things. For example, you could say, in total, I've spent less than a certain threshold amount into this month. You can do other things which are kind of a little bit more boring, but quite important things like KYC, know your client and anti money laundering checks as well.
00:23:45.826 - 00:24:17.758, Speaker B: You can have things like identity tokens. So you can have KYC tokens to prove that you're on some kind of approved list without revealing who you are. Things like that are going to be key for working in kind of regulated environments. But as well, you can use this programmability to create a very feature rich ecosystem of DeFi protocols that kind of work in concert with these private cryptocurrencies to enable effectively private DeFi, where you can engage in similar DeFi protocols as today, or even exactly the same DeFi protocols as today, working on layer one whilst hiding who you are.
00:24:17.844 - 00:24:35.838, Speaker A: One question here though, you sort of said that the ZK money and that ZKZK roll up is more utxo based. How do you then reincorporate programmability into that? Because I always understood that as sort of like, that's one of the reasons why Zcash isn't as programmable, because it has that format.
00:24:35.934 - 00:25:14.202, Speaker B: It certainly does make life a little bit harder. But I think most of the reason why you can't program private privacy systems right now, it's mostly a technical obstacle, because adding kind of user defined programmable circuits hasn't really been possible until the last few months, really, just because you need universal snarks, you need them to be extremely fast. Because you're making these trips on the browser, you need to be able to handle recursion efficiently. There's a whole host of technical ingredients that were required that have only just really come together. The state model does make things a little harder, though, because you can't easily have a kind of account model. You can certainly apply an account abstraction layer above a Utxo model, but that's something that your front end or depth has to handle. It's an extra layer of complexity.
00:25:14.202 - 00:25:19.022, Speaker B: It's something that our SDK handles, for example, so that we try and abstract away this Utxo stuff from the user.
00:25:19.086 - 00:25:19.522, Speaker A: Got it.
00:25:19.576 - 00:25:53.194, Speaker B: But it does certainly require a different way of programming things. It's why we're putting together our own zks programming language. Because in a private world, state variables have to be owned by users. Everything is encrypted, and only specific people will be able to decrypt those objects. And if you want something which is fully private, you can't have global variables like you can, as smart contracts like that are publicly visible to everybody. If you're doing some kind of token or amm, you can't have a total supply that's public because that leaks too much information. So there are a host of difficult issues that need to be solved to make programmable privacy practical, but we think we're well on the way to solving them.
00:25:53.194 - 00:26:27.570, Speaker B: And there's also just to finish on this, I think one interesting thing is actually, when creating DeFi protocols that you want to interact where you want to protect users of privacy, you can still do so. Basically, what's most important is that the actual representation of value, the cryptocurrencies that they are private. And once that's happened, you can build public defi protocols that interact with this private, these private assets and private pools. And to do so in a way which is still privacy preserving, because if you can see everything that's going through the DeFi protocol, but you don't know who owns the trades or the positions, then you still have extremely strong privacy guarantees.
00:26:27.650 - 00:27:06.658, Speaker A: You have some sort of privacy there, for sure. We did an event about two months ago, and Zach, you gave a talk there. It was actually about privacy and Defi. Maybe we can actually talk a little bit about that, because in that talk, you did present some ways that you could incorporate privacy into DeFi protocols, even like these amms, something that I feel we've also seen a lot of counter research saying you cannot just blanket add privacy into an amm because it actually breaks some of the things that one needs. In order for these things to function, it needs some sort of transparency. But you had some ideas around how to fix for this.
00:27:06.744 - 00:27:43.818, Speaker B: Yeah, privacy is hard, and there's a lot of things you just cannot do privately that you can do in the public world. You certainly can't make a fully private Amm right now without using extremely advanced multiparty computation techniques, which are not really practical the present day and most DeFi protocols right now, you can't just magically make a private version. Like take for example makerdao. If I want to make a CDP to borrow some dai, imagine you want to do this privately. So you have an encrypted CDP. So basically you've effectively staked some of your ethereum privately to create a private amount of die. Now in order for the DAI system to work, you need to know, the contract needs to know when your position becomes under collateralized.
00:27:43.818 - 00:28:26.314, Speaker B: And once you become under collateralized, it needs to automatically liquidate your position. Neither of these things can happen if it's encrypted, because if the contract has the information to understand what it's worth, so does everybody else. So you don't have privacy. And if you do have privacy, then the contract can't liquidate your position. Yeah, so basically our position is, for the time being, it's not really practical to create private versions of DeFi protocols. What is much more practical and achievable is to interact privately with public DeFi protocols to basically anonymize your holdings before you engage in these DeFi protocols. So if you, for example, use Aztec to, let's say you wanted to put 1000 ETH into compound, if you use Aztec to anonymize your holdings so that you have these random addresses on Ethereum that hold eth, no one can link them to your original accounts.
00:28:26.314 - 00:29:26.910, Speaker B: And we think that the most important thing for enabling privacy preserving techniques on DFI is to ensure that transactions are uniform. If you imagine you have like an ETH die pair on compound, and every single trade is say 100 ETH or ten ether, or like, you have these fixed denominations, now that does limit the user experience somewhat. But because if the identities of these holdings are all anonymous and the values are all uniform, you have no real meaningful information about who's controlling these trades. And obviously, if you want to make large trades, then you submit lots of smaller trades as a batch, which is typically how a lot of traditional markets work. For example, we're planning on using this technology to solve kind of the front running and issues in DFI, and the fact that if you're trading large notionals, you move markets, because right now, if a so called whale wants to do a trade on DFI, then typically the way you do this in the web two world is you split your big trade up into lots of little trades and put them out onto the market slowly over time so that you don't massively shift the market. But the problem is, because of analytics on chain everyone, if you start selling your position. Exactly.
00:29:26.910 - 00:29:53.386, Speaker B: So everyone's out, look, the whale's trading, let's move the market, let's take advantage. And the only other solution is to push your entire trade through as quickly as you can to prevent front running. But then you're taking a horrible spread on your trade because there's not a lot of liquidity to satisfy huge trades. And at sex Saltus, instead, what you do is you can now split up your large holding into a lot of smaller holdings that are anonymous, that nobody knows, they're all linked. And so you can then put those trades out into the market slowly over time without people realizing that you're doing.
00:29:53.408 - 00:30:25.060, Speaker A: So it changes the dynamic. Actually, I did an entire episode with Guillermo and Tarun all about the private amm work they're doing. I'm going to link to that in the show notes if anyone wants to kind of hear that in even more detail. And I think Guillermo actually spoke just after you, Zach, and he was really kind of impressed that your thinking had already reached sort of those levels that they had been working on in terms of ways to actually fix this. But what you just said is this is still a future thing. This isn't something that's implemented today. Right.
00:30:25.060 - 00:30:28.374, Speaker A: Where are we at with the product right now?
00:30:28.492 - 00:31:19.954, Speaker C: No, it's in progress, I'd say. I think we've laid the groundwork. So our private roll up today has kind of more than one transaction type. So we have kind of the standard we join split transaction, which allows you to send private funds, but we've got kind of the early versions of programmability in there with another type of transaction, which is an account transaction. So users have, like, accounts, and they can kind of modify the state of their account, change which keys can spend on their account, change their username, and change their kind of encryption keys. And if you kind of fast forward a few months, there'll be a third type of transaction, which is kind of, we're calling it the DeFi bridge users will be able to kind of send their value notes to almost like a kind of contract address on the roll up. And that contract will have a predefined kind of layer one outcome.
00:31:19.954 - 00:31:46.330, Speaker C: So it could be, as Zach said earlier, deposit 1000 die into compound. It could be swap one eth on uniswap, and all of these kind of uniform events will be bundled up in one roll up. And you get this kind of privacy effect by everyone looking the same but doing aggregate transactions. So we're well on the way to achieving that. Probably having an early summer launch is the roadmap.
00:31:46.410 - 00:31:49.418, Speaker A: Whoa. Okay, that's a lot faster than I expected.
00:31:49.514 - 00:32:19.974, Speaker B: Well, I think we got all the ingredients because our architecture is already programmable. It's just that right now we have to program the circuits because it's a lot of extra architecture, and it's going to be quite a complex operation to make these circuits user programmable. So we're planning on launching that. So in the meantime, we're going to write our own Defi bridge circuit, as Joe says, that allow people to talk to layer one protocols, but to do so as a batch. So astrology, making like one transaction to uniswap to represent a trade, but that will be shared amongst like 100 or so users. So the cost of that transition gets.
00:32:20.012 - 00:32:27.258, Speaker A: Amortized over lots of users on the DFI side. Do those DFI protocols have to do anything in order to interact with this?
00:32:27.344 - 00:32:27.594, Speaker B: No.
00:32:27.632 - 00:33:09.922, Speaker C: So we're going directly to layer one. I think the layer two landscape is a pretty exciting space to watch, but right now there's kind of last check. I think it was close to 100 billion of capital on the layer one contracts, and we don't see that going anywhere anytime soon. So our approach is for users who care about their privacy. Those users are probably willing to pay slightly more for a transaction, still cheaper than Ethereum mainnet, obviously, but they're willing to pay a bit more to have strong privacy guarantees. And it's just like they're doing that transaction on Mainnet, but with privacy. So it's kind of a hands off approach for layer one DeFi protocols.
00:33:09.986 - 00:33:43.506, Speaker A: Is it kind of like, because, I mean, reading the documentation basically to sort of finish that journey that we started earlier in this episode of these tokens? And you did hint at this, it was the idea that once you actually have moved funds off the l one into aztec into a shielded environment, you can then send that directly back to l one without having to unshield. And then even though I guess somewhere behind the scenes, it is unlocking and unshielding, but you, as a user, could just send it right in. So you would basically, as a user, just send it right into one of these, I guess.
00:33:43.608 - 00:33:44.290, Speaker B: Yeah, correct.
00:33:44.360 - 00:33:58.914, Speaker C: So it would look like very much like kind of, if I was sending it to you on your username, the end user kind of user experience would be very similar. You'd create a proof on your client. The destination is just a predefined defi action rather than a user.
00:33:58.962 - 00:34:00.134, Speaker B: So we're pretty excited about that.
00:34:00.172 - 00:34:53.386, Speaker C: And I think that where things get more exciting is kind of as developers start to think of the new types of defi that are possible once you have kind of a uniform set of users, because Uniswap has. It's a good model for public Ethereum, but kind of the slippage costs and all of these things that occur based on large trades aren't necessarily applicable when you have privacy. You can start to kind of design systems that maybe are a little bit more stable in terms of price. And that's where, I guess, stage three comes in of noir and full programability. We kind of take the training wheels off the network and let other people define what you can do with these destination contracts on the network, and that's when things get really exciting. I think it's worth talking about that for a little bit, because there are a few kind of cryptographic hurdles to overcome there, but that's on the way to doing it.
00:34:53.408 - 00:35:25.886, Speaker A: I'd say, let's introduce, or I did an episode recently with Alex Osdemir where we went through kind of a survey of languages, and noir had just like, I had just pinged you, or I'd pinged you, Zach or Ariel, and just said, like, do you guys have a language? And then you were both like, oh, yeah, but it's not out yet. I was like, okay, so I think we mentioned it, but there was nothing. We couldn't really look into it. So why don't we talk about noir, this language, and what that means for your next steps?
00:35:25.998 - 00:36:08.622, Speaker B: Yeah, absolutely. We need programmability. So right now, the way that we're building our snark circuits, you can't need to be in a cryptographer to really do it securely, which is not sustainable in the long run. And so we want to be able to give developers and users the ability to program snark circuits in a high level language that's intuitive, that you don't need to know all sorts of crypto knowledge. And so there's a lot of other languages which are trying to solve this problem. But we have some rather unique requirements, which we think means that the only real solution is to develop our own language, which is basically because this language is designed explicitly so that all the ZK proofs you're building with it are constructed client side, probably in a web browser using webassembly, which is much slower than native code for cryptography. So it needs to be incredibly fast, it needs to be optimized to produce really, really tight circuits.
00:36:08.622 - 00:36:49.022, Speaker B: And it also, longer term, we want to add semantics into the language, which kind of abstracts away private state management, so that you can have kind of a little bit like a solidity smart contract where you can have storage variables, but they're private and owned by individual users. So we have a lot of custom semantics that we need, and we need the cryptographic backends to be extremely fast. So the approach we're taking with noir is. So the project's being led by Kev Wedebaum is our kind of language guru. It's an open source project where we have this language front end, which kind of compiles down to an intermediate representation. It's a bit like LLVM for ZK proofs we're calling SCR. And the idea is to have multiple cryptographic backends because this is an open source project.
00:36:49.022 - 00:37:08.546, Speaker B: So you can have a plonk back end, you can have gross 16 backend, you could have a Marlin backend to make it kind of a very flexible language that can be used by a lot of different teams. Right now, the other backend, the only backend is plonk because it's a very new language. So we just wire our own back end into it. But the goal is to support other cryptographic protocols longer term, what made you.
00:37:08.568 - 00:37:23.334, Speaker A: Make the decision to write your own language? Because this actually was something we talked about, where there's a lot of teams that have built kind of their custom architecture and then creating a language to interact with that. Is there a reason you didn't decide to use some existing out of the box language?
00:37:23.462 - 00:38:03.382, Speaker B: Yes, and that's because of the abstraction layers that they used to compose circuits specifically, especially at the time, all the existing languages they used. I guess you can call intermediate representation, called R one cs for sense of rank, one constraint system. It's a way of defining your snark circuit as basically a series of linear additions and multiplications. It's a very efficient representation of circuits for non universal snark systems like cloth 16, like the slightly older snark grooming systems that came out between 2013 and 2016. But universal snarks like plonk don't really. They're not really very friendly to an R one CS abstraction. It creates quite inefficient circuits, and it doesn't leverage any of the core strengths that plonk has.
00:38:03.382 - 00:38:28.462, Speaker B: Plonk strength is these things we call custom gates. It's basically, you can define your own custom little arithmetic operations, like, as you can call them, mini gadgets that are extremely efficient to evaluate inside a plank circuit. So you can do things like do elliptic curve point addition in a gate. You can do things like efficient Poseidon, hashes, pedals, and hashes. You can do parts of a shardy of f six hash. You can do things like eight bit logical exclusive or operations. All of these explicit instructions which are needed for real world circuits, but they're all quite custom.
00:38:28.462 - 00:38:44.898, Speaker B: And so we wanted a cryptographic backend which understood what these custom gates were and be able to convert this high level language directly down into these custom gates to make extremely optimized and tight plunk circuits. The existing solutions out there didn't really do this because they had this one r one cs abstraction layer, which wasn't really suitable for us.
00:38:45.064 - 00:38:55.990, Speaker A: But, I mean, since then, there are languages now that can do that as well. Right? Like, I feel like there's some projects that are coming out where they also removed the r one cs aspect.
00:38:56.730 - 00:39:17.706, Speaker B: I think so. But they're still quite very in development, and I think most of them, the ones that I know of, very much, kind of don't really have privacy in mind. Their main focus is on constructing circuits that can be web proofs constructed by third parties with a lot of computational resources, so they don't have the kind of the focus on optimization that we really need for our circuits.
00:39:17.818 - 00:39:34.786, Speaker A: Got it. How do you feel? Like, kind of. Just the last question on this point, but it's like something like arcworks. Is there any way for you to incorporate what you're doing into that? Or does it have to remain sort of these separate language ecosystems so they.
00:39:34.808 - 00:40:15.646, Speaker B: Don'T have to remain separate? We're completely open to collaborating with other teams to build a kind of a more general purpose language, because there is a lot of fragmentation in the ZK language space that one way or another needs to be resolved. I guess the problem is, because right now we're still in a really early stages where every team has very, like, the proving systems, there's a huge trade off space between performance, ease of use, synchronous. There's all these parameters that you can tweak with your ZK proving system to optimize it for your individual use case, and because the overarching systems are still relatively inefficient. Right. Like the difference between doing a computation and making a ZK proof for a computation. For most common algorithms like that, the difference is a factor of about a million. And because of this, all these teams have very specific use cases in mind.
00:40:15.646 - 00:40:43.270, Speaker B: They have to really tweak the parameters of their ZK proving systems to be optimized for their specific use case, and therefore their languages as well, which means that you have all these slightly different languages that are all not completely compatible with each other, because all these teams have very different needs. So I think a lot of this will get resolved as these premium systems become more efficient and you can take a more universal approach. So we're kind of happy to see how things shake out, but in the meantime, we're completely open to collaboration with other teams if we have kind of mutual goals.
00:40:43.430 - 00:40:44.138, Speaker A: Makes sense.
00:40:44.224 - 00:41:44.314, Speaker C: I think Noir is also the first kind of best effort of trying to, I guess, bridge the gap of that fragmentation. We're saying that you should use this open source project as your kind of front end for language, so everyone's working on the same syntax, and then if you have a slightly different kind of need for your proving system, you can hook up the intermediate representation to a different proving system. That may not be blanc, it could be something else. And if we can start to kind of get that methodology working within the community, the project should take off. And, yeah, Kev's got some thoughts about this in terms of if the language itself has a lot of. Kind of a standard library that's very feature rich, I think it can attract developers to use that language because they don't have to re implement a lot of standard functions, which kind of people are doing all over the place, like a range constraint or a particular hash function. There should be kind of one repo with the fastest or the best Poseidon hash function, or shark two, five, six hash function.
00:41:44.314 - 00:41:54.894, Speaker C: And if you give that to the community, I think you can kind of encourage people to work on the same project rather than different ones. And to do that, it has to be fully open source. So that's what we're committed to.
00:41:54.932 - 00:41:58.338, Speaker A: Cool. Is it rust based, or is it based on something else?
00:41:58.424 - 00:42:09.138, Speaker B: It is rust based. So, yeah, our cryptographer backend is written in c for a few reasons, but because we want it to be more compatible with other teams of building, we just decided to build it in rust.
00:42:09.234 - 00:42:17.560, Speaker A: So you mentioned WasM earlier, and now I'm curious, what does this actually mean for the construction? Is there any limitations that come along with that?
00:42:17.930 - 00:43:02.838, Speaker B: When you're programming for the web, the programming languages you have access to are very, very limited because code executed in web browser needs to be secure. So you can't just like, you know, you can't just directly manipulate a user's cpu because you know, you can get hacked that way. So webassembly is basically a new standard for extremely fast computation on the web. It's an assembly language for an imaginary computer that kind of closely maps to instructions that you find on real computers. So the idea is that if you have webassembly code, and running Webassembly code is kind of almost as fast as running native code on your cpu, because there's not much kind of an interpretation that has to happen between turning webassembly instructions to real cpu instructions. However, that's the ideal. The reality of it is that for cryptography, WebAssembly is really slow compared to running code like Nate, that's natively compiled onto your computer.
00:43:02.838 - 00:43:43.278, Speaker B: Because modern cpus have very niche mathematical, the maths that we need for cryptography and those instructions are not available on Webassembly, which means that if you have a snark grooming system, if you compile it to run on a computer, and then you compile it to run with Webassembly, the Webassembly version will be about eight times slower than the native version. On top of this, it's extremely hard to do multi threading in webassembly because you can't run multithreaded webassembly code because that's a huge security risk. So you have these kind of parallel problems where webassembly, you can't easily do multi thread instructions on them that we use heavily to do slow to begin with. So once you have all these extra slowdowns, how do you make the whole thing work? How do you deal with this lack.
00:43:43.294 - 00:44:25.666, Speaker C: Of speed, basically, and the memory limit as well. So that's what we were kind of hinting at earlier with the differences in the commitment schemes is it's a wasm problem. In most kind of devices, you have between one to 4gb of available kind of proving memory, and that really limits you on the expressiveness of your program. In a normal kind of snark world, plonk has issues as well, but we really need to get to ultraplonk to kind of break down those barriers. And I think to go back to the question, by the time ultraplunks kind of in the wild, we'll have usable webassembly provers with full programmability. So it's probably six to eight months off yet.
00:44:25.768 - 00:44:35.218, Speaker A: Cool. You just called it ultraplunk, right? Yeah, for some reason, I just heard octoplanc, and I was like, whoa, that also sounds very cool.
00:44:35.384 - 00:44:38.900, Speaker B: That's a good name. Maybe that's what our next version will be called.
00:44:41.210 - 00:44:48.706, Speaker A: Can you elaborate? What did you have to do then to do the workaround, even now, like, with what you have pre ultraplanc?
00:44:48.818 - 00:45:21.870, Speaker B: Yeah. So there's a lot of work that we need to do. For example, the most time consuming part of constructing ZK proofs is basically prime field arithmetic and prime field multiplications. You've got two large prime numbers and two large numbers, and you got a multiple modular big prime number. So we have these really tightly optimized, regular assembly algorithms, implementations for that that you can't use in Webassembly. We had to write these prime field operations in a way which kind of compiled into maximally efficient webassembly, which is actually quite counterintuitive to do that. But the main thing we managed to do is we managed to get a form of multithreaded webassembly.
00:45:21.870 - 00:45:59.934, Speaker B: Like if you have a C program or rust program that's multithreaded and you compile it to wasm, you lose your threads, because since the spectrum meltdown attacks, browsers have had to disable multithreading in webassembly code. So what instead we do is we actually spawn separate web processes in your browser. Each one of them kind of takes on computing a little part of a plot proof. And so it's kind of a coarser version of multithreading, but we get similar results out of it, and that gave us, like, a factor of like, four speed up compared to what we had previously. So that, combined with the algorithms that have basically been designed with webassembly in mind, have made our premium system fast enough for basic privacy, ZK snark proofs. We think with a bit more work in the future, it'll be more than fast enough to handle fully programmable smart contract proofs as well.
00:45:59.972 - 00:46:08.622, Speaker A: But then you mentioned sort of the ultraplunk. Is that the difference that you're describing, that once that's in, it'll be easier? Or is there something else that Ultraplunk offers?
00:46:08.686 - 00:46:42.842, Speaker B: Oh, yeah, it's all ultraplunk. So Ultraplunk doesn't help with speeding up webassembly. It's just a much, much faster preming system because you can do common, like all of the algorithms that we're running, they require far fewer gates to evaluate using ultraplunk, because ultraplunk uses lookup tables. This sounds really primitive by regular programming standards. Basically, what we've done is we found an efficient way of being able to access lookup tables inside a plunk circuit. And so you can use that to do things like model dynamic memory. So you can have, in your programming language, you can have, like, vectors and dynamic arrays without them being incredibly inefficient.
00:46:42.842 - 00:47:11.798, Speaker B: So this is like, really primitive stuff, right? Normal programming languages have had dynamic arrays since the 1960s, but that's where we are. And you can use lookup tables to do snark, unfriendly algorithms. So snarks generally are really bad at doing binary operations, like doing exclusive or operations, or, like logic operations, because you have to work on individual bits. And lookup tables kind of solve this problem for us, because you can just have a big lookup table of your boolean logic to kind of do these operations kind of eight bits at a time instead of one bit at a time.
00:47:11.884 - 00:47:26.118, Speaker C: What it enables, though, is calling it the kernel snark. But in order to get to this kind of end state of full programmability and have that run in a wasm prover, you need to kind of define the rules by which developers can write their programs.
00:47:26.214 - 00:47:27.098, Speaker B: So you can think of it a.
00:47:27.104 - 00:47:43.082, Speaker C: Bit like a vm, but it's how we allow user defined noir circuits to interact with this private state. And that's kind of the last bottleneck that we need to kind of overcome with ultraplunk to get this really working at high speed on client devices.
00:47:43.226 - 00:47:59.222, Speaker A: I feel like you've mentioned words with the word plonk in them a few times throughout the show, and I actually just wanted to run down, and maybe you can just help me position it in my mind. There's plonk, regular. There's turboplank, which is what you're using now.
00:47:59.356 - 00:47:59.894, Speaker B: Yes.
00:48:00.012 - 00:48:07.558, Speaker A: Okay. There's splunk, which I don't know if that's a thing or that was just a paper or a joke or what.
00:48:07.724 - 00:48:28.842, Speaker B: It's splunk. Ariel and Justin's one of mean. I can't comment on silly names. I'm throwing rocks in a glass house. So, yeah, splunk is a variant of plonk that. Yeah, it's currently a paper we're borrowing, stealing the commitment scheme from it. But the actual full paper is kind of a different way of constructing plonk snarks.
00:48:28.906 - 00:48:32.350, Speaker A: Okay. And then ultraplonk is the next iteration.
00:48:33.010 - 00:48:33.566, Speaker C: Yes.
00:48:33.668 - 00:48:36.306, Speaker B: So ultraplonk is turboplank with lookup tables. Pretty much.
00:48:36.328 - 00:48:38.322, Speaker A: And then maybe octoplanc after that.
00:48:38.456 - 00:48:42.514, Speaker B: Maybe. Yeah. Octoplanc, megaplanc, sky's the is.
00:48:42.552 - 00:48:45.790, Speaker A: Okay, one last question is, what's pluckup?
00:48:45.950 - 00:49:10.954, Speaker B: So, it's a paper that RNI published last year. So the paper describes how to use polynomial commitment schemes to kind of define lookup tables into access lookup tables. And so what ultraplunk is, is basically us taking our pluckup research and mashing it into the planck snark proving system, so that instead of working with abstract polynomial commitment schemes, you can have a plonk circuit where you can have specific gates that reference lookup tables. Cool.
00:49:11.072 - 00:49:14.394, Speaker A: Is there any other sort of term that I missed from that?
00:49:14.592 - 00:49:19.194, Speaker B: Not that I'm aware of. I mean, I'm happy to invent a few more if you want to inflate the jargon.
00:49:19.242 - 00:49:22.714, Speaker C: I think Ariel was working on Covid plonk, but I'm not sure if that.
00:49:22.772 - 00:49:23.780, Speaker B: Oh, my God.
00:49:26.070 - 00:50:13.050, Speaker A: Well, we hope that we'll never have to see that one. Maybe we get to just have post Covid plunge anyway. Okay, I think the last point I want to talk about with both of you is a little bit how the aztec zkzk roll up kind of matches up with all of these other roll ups that are coming out and how you're thinking about them. When you were talking about having a user be able to send funds directly into, like, an l one DFI building block, one of the thoughts I had is some of those projects are actually going to be moving on to different l two s soon, apparently. And so I wonder, with all of these l two s emerging, a lot of them zk, some of them optimistic, how do you see yourselves fitting into this kind of new landscape?
00:50:13.130 - 00:50:52.182, Speaker B: Yeah, so our main focus is privacy. So we're a private roll up, and currently, the only private roll up around. And the users that we want to serve are users that care about transaction privacy and not revealing all their information on chain. We're a little bit different to the other layer two s in that regard, because we're not really just chasing the absolute cheapest transactions possible, because adding privacy means that you're broadcasting more data because your data is encrypted. Instead of users that want transactions for $0.01, we're chasing users that want private transactions for makes any sense, certainly. I think as these other layer twos get deployed, there's going to be a lot of work on kind of cross layer two swaps to allow people to efficiently migrate funds between layer twos.
00:50:52.182 - 00:50:57.210, Speaker B: That's something we'd be very happy to work with. We'd be very happy to kind of create efficient bridges between aztec and other layer twos.
00:50:57.290 - 00:51:00.522, Speaker A: Is that what they're going to be? They're going to be like new bridges?
00:51:00.666 - 00:51:05.866, Speaker B: I think it's inevitable because otherwise you're going to get this kind of intense fragmentation of liquidity across all of these layer twos.
00:51:05.898 - 00:51:21.590, Speaker A: But it will be intense, right. Because it's not that all these l two s and not all of these kind of roll ups are actually consistent with one another. If you were to have to run a light client on those l two s, each one of those may be quite bespoke.
00:51:22.410 - 00:51:55.166, Speaker B: Yeah, well, we're going to focus on l two s with have EVM full EVM compatibility, things like optimism, because what we want is we want to make sure that our users have access to liquid DFI pools, and so you can only really have those on EVM compatible layer twos. So right now, we're waiting to see how this plays out, because right now the liquidity is on layer one. We'll see how much migrates to layer twos and how much stays on layer one. But our focus is on users, and we want to make sure that our users can interact privately with the Dapps and the contracts that they want to talk to. So if they're on layer two, we'll talk to the layer two. If they're on layer one, we'll talk to layer one.
00:51:55.268 - 00:51:55.950, Speaker A: Makes sense.
00:51:56.020 - 00:52:33.690, Speaker C: I'd like to model that as kind of optimism, or an l two just becomes quite a complicated DAP. So in the same way we have kind of this d five bridge that we're building, it doesn't really matter where we point the bus leaving to go and do an interaction, it's going to go and do that interaction and bring whatever the result of that interaction is back to the aztec network in order to give it privacy. So we kind of see us growing with the l two landscape alongside it. And, yeah, it's going to be exciting to see where the different Dapps end up and where the different d five protocols kind of merge. And some of them will end up on Aztec, I'm sure, because they require privacy.
00:52:33.850 - 00:52:51.710, Speaker A: I have one last, maybe controversial question, but you had sort of mentioned some of the limitations of Ethereum as an l one in building all of this, like, have you at all looked out at other l ones? Please don't hate me, Ethereum community, for asking this question, but I just am curious.
00:52:52.450 - 00:53:11.946, Speaker B: Yeah, I mean, the reason we're building, I mean, I don't want to, like we're dumping on Ethereum. You're saying Ethereum has some limitations we have to work with, but really we need to work with a layer one that is both programmable and expressive, but also has the ability to support these quite advanced cryptographic protocols. And right now, Ethereum is the only game in town. There are other layer ones. I don't think there are other layer ones which have the kind of advanced crypto parameters we need, as well as.
00:53:11.968 - 00:53:14.266, Speaker A: Smart contract or the tooling mostly, I'd say.
00:53:14.368 - 00:53:50.934, Speaker B: Yeah, exactly. So if another layer one pops up with a lot of users, a lot of liquidity that we can easily port asset to, we wouldn't rule it out, but right now, Ethereum is the place to be. Right. It's the ecosystem with all the users, all the dapps, all liquidity. It's got the expressibility and programmability we need, and they've also really pushed the boundaries with regards to what's kind of possible. Sure, Ethereum has only a limited number of cryptographic perimeters available, but they still have those perimeters, right. You can still do pairing based cryptography in an Ethereum smart contract, which is quite, I mean, I was on some of the s dev calls when that was happening, and it's quite a difficult thing to coordinate and pull off.
00:53:50.934 - 00:54:02.410, Speaker B: So, yeah, I mean, for the time being, we're very happy with the Ethereum ecosystem. We don't really see might. It's easy enough to port Aztec to EVM compatible chains, but we think Ethereum is the home for us in the future.
00:54:02.560 - 00:54:24.318, Speaker A: Got it. Cool. Well, Joe, Zach, I want to say thank you so much for coming on the show and sharing with me and the audience this update of Aztec, the introduction to ZK money, which just came out, it's actually like live now. People can actually play with it. Do you have anything you want to kind of share with the audience before we sign off?
00:54:24.404 - 00:54:44.406, Speaker B: Love to. Yeah, we are hiring. We have a lot of open roles because we've got some ambitious plans that we're executing on. So, yeah, if you're interested in the space, we're hiring pretty much the whole technical stack, front end devs, back end devs. We're hiring ply cryptographers. If any of those roles tickle your fancy, get in touch we have a jobs page on our website. It'll be great to hear from anybody who's interested.
00:54:44.588 - 00:54:50.150, Speaker A: And I guess people should go to. It's actually ZK money. That's the website, right?
00:54:50.220 - 00:55:03.418, Speaker C: Yeah. If you go to ZK money and check it out, get your username registered, and you'll be able to kind of really take control of your privacy. And, yeah, we can't wait to deliver more feature to you over the coming months. And stay tuned for private Defi.
00:55:03.514 - 00:55:11.690, Speaker A: Very cool. So thanks again to both of you. I want to say a big thank you to Henrik, the editor, Andre, the producer, and to our audience. Thanks for listening.
