00:00:02.570 - 00:00:12.910, Speaker A: To this talk. This is the last talk in this room for today. So let's welcome Shane Viterana from Stargaze. So Shane, all yours.
00:00:14.850 - 00:01:22.860, Speaker B: Thank you. Hey guys, how's it going? So I'm Shane from Stargaze and I am going to talk about in NFT primary markets. So let me go ahead and share my screen. Okay, so MeV in NFT primary markets. So what am I talking about here when I'm talking about meV? So in this context, M stands for minter extractable value. And when I'm talking about a primary market, I'm talking about the first sale between the creator and the collector. So this is not about the secondary market which is something like Opensea where you have bids and asks, this is only about MeV in the very first sale.
00:01:22.860 - 00:02:25.980, Speaker B: And the minter is the person in this case is minting the NFT for the first time. So just a note about MeV in tendermint. Because tendermint uses an ordering of first in, first out, it eliminates a whole class of MEV that you get in other blockchains where you have priority gas auctions. So in this case, Mev is only contained to the NFT minting size and the order of the minting. So to understand this a little better, we first need to understand the anatomy of an NFT which has both on chain data and off chain data. So first let's talk about the on chain data. Now the on chain data is in the NFT collection.
00:02:25.980 - 00:03:22.790, Speaker B: In the case of Stargaze, it's SG 721. And you have this mapping of token ids and token Uris. The token Uris is the metadata file that is stored on ipfs. For a lot of the generative collections like you see on stargaze for like starch odes and stargaze punks and a bunch of all the other collections, the way it's stored is that you have a base URL which is a URL to the folder and then you have a token id. And every time you mint it just goes to the next sequential token id. So that kind of long string of characters you see over there is the ipfs content id and this is basically a hash of the content. So this is how content addressing on ipfs works.
00:03:22.790 - 00:04:02.172, Speaker B: So now if someone goes to ipfs and changes the data, it also changes the link that the data points to. So this is how you know if the data for the underlying NFT changed or not. So on chain you have a record of the ipfs content ids that are associated with each token. So let's look at an example of this. Right? So this is starchode or baby Chode 1829. You have the NFT on the left, you have the metadata on the left side. And this is just a JSON file.
00:04:02.172 - 00:05:10.790, Speaker B: It has a name image, and then it has a bunch of attributes or traits, and you can kind of see the representation on the website on the right hand side. So the traits is what gives the rarity for an NFT. And this is how nfts are typically valued. So, for example, in this NFT, this baby toad has a head of Aquamohawk, and only 1% of nfts in this collection have an aquamohawk. So this is represented in this metadata. So anyone looking at this can look at the whole collection, compile all the rarities, and figure out a rarity score for each NFT in this collection. So given that the problem we have right now is sequential minting, right? So now if you go and mint an NFT, ethereum also started this way.
00:05:10.790 - 00:06:36.720, Speaker B: You have a problem of sequential minting, where every time you mint it just increments the token id by one, right? So let's break it down to like a very trivial case where you mint one NFT per block, right? So let's say that right now you're on block 4459 and someone minted baby chode 4459. But by looking, someone who's really savvy can look at ipfs and figure out that baby toad 4461 is incredibly rare, right? So in this case, that NFT has the highest rarity score. So knowing that someone who's savvy can wait for two blocks and then mint the exact NFT that they want, and they can snipe it this way. So can the devs do something? How do we fix this problem? So I'm just going to kind of walk through a few of the solutions here. So they kind of ordered from easy to hard. Okay, ipfs submarine is one way to solve this problem. So the way this works is that a creator would publish the metadata to a private ipfs node.
00:06:36.720 - 00:08:14.060, Speaker B: And because of content addressing, nothing has to change on the contract side. So they can go ahead and deploy this contract, but won't have to change any of the token URLs, because once this is published to a public node is going to be exactly the same. Right? So first they publish it to a private node and then they do the minting. Then everyone comes and mints their nfts, and then only afterwards do you publish it to a public node, right? So this way the creator hides all the metadata and there's no way for the minter to know and figure out which NFT they want in order to snipe it. Now the advantages of this is that for the developer, they don't have to do a thing, right? This all kind of falls into the hands of the creator. The disadvantage of this is that the UX is worse, right? So now when the user mints, they don't get to see what they got immediately, right? They have to wait until either a validator, some third party, or the creator themselves goes ahead and publishes the public version of the NFT. All right, and then reveal later is very similar, right? Instead of publishing to a private ipfs node, first the creator goes ahead and publishes a placeholder collection to ipfs.
00:08:14.060 - 00:09:32.516, Speaker B: So generally this is like some kind of animated gif that just kind of rolls through a sampling of the nfts in the collection. Then the user goes ahead and performs the mint. And then when they do that, they just get this kind of like random sample. It's not the real NFT that they minted. And then they have to wait for the creator to go and upload the real version of it and then they get the NFT, right? So the advantage of this again is the developer doesn't have to do anything, but the smart contract has to have the ability to go and update the token URis. Of course, the disadvantage to the user is that they have to wait until the creator goes ahead and uploads the real collection. So what can we do? Can we make the UX better so that the NFT is available as soon as the mint happens? So this can be solved using randomness and a shuffle and shuffling.
00:09:32.516 - 00:10:33.288, Speaker B: Okay, so the way this works is that first you got to generate a random number. The reason you need a random number is because it's an input into the shuffle algo. So in this case we're using fishery eight, which is a well known shuffling algorithm. And I'll get back to the randomness in a little bit, because as some of you may know, it's not trivial to generate a random number on a blockchain is because every node would have to generate the same random number at the same time for it to work. So there's various approaches to solving that problem, but this is the approach that stargaze is taking. And let me just go over this a little bit. So first, when a collection is launched, all the token ids for that collection is randomly shuffled.
00:10:33.288 - 00:11:30.492, Speaker B: Okay? So that solves the sequential minting just a little bit, because now you don't know exactly which one you're going to get next. But someone who's savvy can look into the blockchain and query the data and know which one still is going to be minted next. So this is better than just regular sequential minting, but it adds a bit of extra element to it. You can't just do the single shuffle, right? You have to do a little bit more than that. So what we do is that on the minting process, we do another smaller shuffle. So what this does is that it takes a range of token ids, either from the front of the list or from the back of the list. And that's going to be random.
00:11:30.492 - 00:12:06.190, Speaker B: Right. So you don't know if you're getting one from the front or the back, and then it does a secondary shuffle on the mint. And that's how you get the NFT. Right. So the reason for not doing a full shuffle on each mint is because it's an expensive operation. So if you have a collection of 10,000, you don't want to be shuffling that on every mint. Now, someone could still potentially figure out the order.
00:12:06.190 - 00:12:56.830, Speaker B: So you need another element to this. And that is having a shuffle function that anyone can call. When anyone can call the shuffle function, it adds an element of time to it, right? So now if someone's really savvy, they can figure out exactly what's going on inside the blockchain. They don't know exactly what they're going to get next because anyone can come and call the shuffle function, and that randomizes the order again. So anyone can call this. And generally it's something that maybe whales can do. And when whales call this function, they're kind of socializing the cost of it, and they're also kind of benefiting the blockchain at the same time.
00:12:56.830 - 00:13:56.960, Speaker B: And the reason for this is, at least in the context of stargaze, it has this fee structure called Fairburn. In Fairburn, 50% of the fees are burned and 50% go to stakers, right? So when whales come and do the shuffle, they're actually helping the network in two ways. They're helping to randomize the collections, and they're also potentially increasing the value of the token and also distributing fees to all the stakers. So this is kind of neat. So I mentioned earlier that getting randomness on a blockchain is non trivial. Well, one way to do it is to use a service called drand. Drand is run by a consortium of companies I believe, and they generate a random number every 30 seconds.
00:13:56.960 - 00:14:47.120, Speaker B: Now, blockchains can't talk to the outside world, right? They can't just use the API for drand and get a random number. So the way this has to work is that some external party has to submit the randomness to the chain. So let's say you have a smart contract. In our case it's cosmosm. So there has to be some kind of incentive structure, some kind of bounty, maybe some kind of reward for submitting a random beacon. And also this random beacon is expensive to verify. So one thing we're thinking of doing is to implement this in an SDK go module so the gas will be less to verify.
00:14:47.120 - 00:15:35.272, Speaker B: Another option is to build this into tendermint itself and kind of like provide it as a service to any chain that wants to use it. And once again, this is the input that is fed into the shuffle algorithm. Okay, one more thing I wanted to mention is that another potential way to do this is to use threshold decryption. This is a bit beyond the scope of the talk, because we have decided to go with the random shuffling approach. But this is probably another way you can do it. Right. In Cosmos and intendement you have a validator set.
00:15:35.272 - 00:16:22.830, Speaker B: That validator set could be in control of a decryption key. So when the seller publishes the collection, they can encrypt the ipfscids, or they can also encrypt a shuffled version of the set. And then during the mint operation, the validator set can go and decrypt either the token id or the URI. And this is something you can only do in an app specific chain. And this is probably cheaper than verifying a random beacon. So this is probably more of an advanced way of doing it that we might explore a bit later. Okay.
00:16:22.830 - 00:17:01.350, Speaker B: Anyway folks, that's all I had for my talk. You can reach me on Twitter. I am Shane three V on Twitter. A bunch of people helped me out with this talk, so hats off to them. And also, if you're interested in any of this stuff, if you're interested in nfts with cosmosm and mechanism design around nfts, please get in touch. You can also check us out at stargaze zone. Thank you.
