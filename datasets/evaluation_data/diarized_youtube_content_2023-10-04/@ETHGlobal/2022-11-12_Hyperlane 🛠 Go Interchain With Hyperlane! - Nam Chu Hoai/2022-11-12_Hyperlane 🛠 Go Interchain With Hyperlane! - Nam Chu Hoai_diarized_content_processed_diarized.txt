00:00:07.210 - 00:00:24.870, Speaker A: Howdy everybody? How's everybody doing? Good? Good. Well, we'll be hacking today, and I have 30 minutes to tell you about Hyperlane. So Hyperlane is a developer platform enabling you to build what we call interchange application.
00:00:24.870 - 00:00:51.914, Speaker A: This. So at the core of it, it's a smart contract API that lets you send messages from one smart contract on one chain to another smart contract on another chain. And so you might ask, why the fuck would I care if you build an application today, this weekend, one decision that you will inevitably face is which chain do I deploy on? And that choice is pretty significant in our world in a way that it's not in a Web Two world.
00:00:51.914 - 00:01:08.002, Speaker A: Like, no one cares if you use, like, AWS or GCP, but if you choose Polygon over avalanche over Ethereum, that comes with a pretty significant choice. And that's usually one developer experience, right? Different tooling, different execution environments, those kind of things. User experience.
00:01:08.002 - 00:01:20.600, Speaker A: So whatever chain you're on, all the users on the other chains, by definition, cannot use you. So you're basically forcing all of your users that are not on that chain to come to you somehow. And that's a pretty shitty experience.
00:01:20.600 - 00:01:45.178, Speaker A: Another thing is platform risk, right? So whenever you choose a blockchain, basically all of the state of your application is completely dependent on the security of that chain. And then last but not least, value and network effects, right? Like, if you build a yield farming app on one chain, but on that chain, there's just no other activity that you can kind of farm on. But everything else happens on another chain.
00:01:45.178 - 00:02:06.130, Speaker A: Your application becomes much less valuable. And so some people recognize this and they're kind of doing what we call the copy and paste model, where you just deploy the same contract on every chain, right? So, like, Sushi and Uniswap did something like that where they just effectively deploy a new application on every chain. Like polygon arbitram optimism.
00:02:06.130 - 00:02:37.790, Speaker A: But all of those instances of those applications are completely separate, right? So, like, when you use Uniswap on Ethereum, it has nothing to do with Uniswap on Polygon. And so there's no network effects that your application gets from having state on their chain. Like, if anything, it might actually be vampiric because if you run liquidity incentives on, let's say, Uniswap on Polygon, some liquidity from Ethereum might actually just move over to Polygon.
00:02:37.790 - 00:02:56.760, Speaker A: And so what we believe is the future is what we call interchange applications, which are, again, applications that have smart contracts on every chain. And so users, wherever they might be, can use your application. And so you're no longer constrained by this kind of, like, forcing the user to come to you.
00:02:56.760 - 00:03:07.794, Speaker A: Hyperlain itself is not a blockchain. It's built on top of all of these blockchains that we support. And it effectively eliminates the need to choose a blockchain.
00:03:07.794 - 00:03:20.838, Speaker A: You can just be on every chain. And so we think obviously there's a lot of ways of doing that. We think the first place to start is probably to allow basically your own smart contracts to talk to each other via hyperlane.
00:03:20.838 - 00:03:41.330, Speaker A: But you could imagine in the long term future, dead dupe alternate ways of interoperability, basically. And so what we call basically the previous generation of interoperability, which was like asset based, right? Like you basically forced users to think of assets and how to bridge them. We think that applications will just be inherently cross chain and so it will be like an app based interoperability.
00:03:41.330 - 00:04:03.610, Speaker A: And so again, all in all, we think that's a better user experience. Of course, I think adding this is more complexity and we can talk about that. So hyperlane at the core is really just the messaging API, but we also provide what we call the accounts, the queries and the token bridge API on top, which makes things a little bit easier.
00:04:03.610 - 00:04:21.546, Speaker A: And yeah, I'm just going to do the brave thing of trying to do live demos. So the first thing, the very base API that we have is what we call the messaging API. So on the sending side, you basically call what we call the outbox contract call the dispatch function with three very simple arguments.
00:04:21.546 - 00:04:27.118, Speaker A: One, the destination chain. So that's just like an ID for the chain. Two is the recipient.
00:04:27.118 - 00:04:57.702, Speaker A: So the address of the recipient, it's bytes 32 instead of address because we eventually want to support non EVM chains which where the Identifier does not fit into 20 bytes and so that's why it's bytes 32. And then the message which is just arbitrary bytes, whatever you want to send over. And then on the receiving side, your recipient just implements this handle interface which basically like the system hypoden contract will call and it will basically call handle with, again, three arguments.
00:04:57.702 - 00:05:16.000, Speaker A: One is the origin domain. So where did the message come from? Two, the sender like which address on the origin chain sent this message? And then three, the bytes of the so that's pretty simple. And so if that's that simple, let's see if it actually go.
00:05:16.000 - 00:05:29.426, Speaker A: So on our docs we have basically quickstart tutorials for every API. And I like to think they're going to be simple, so let's try to go for it. So basically, first we have to find the outbox contract.
00:05:29.426 - 00:05:45.530, Speaker A: So we have in our docs here a list of outbox contracts. So let's say here on optimism, this is our outbox contract and here is the dispatch function. So again, what do we do? We have three arguments.
00:05:45.530 - 00:05:56.110, Speaker A: One is the destination domain. So in here we have a list of destination domains. So let's maybe send it over to Fuji.
00:05:56.110 - 00:06:13.822, Speaker A: We want to send it to a recipient. So we have pre deployed like kind of sample recipients on every chain that you can use or you can obviously send it to your own contract if you want to. So in this case, kind of BC three or whatever is our test recipient.
00:06:13.822 - 00:06:35.590, Speaker A: Actually, I can just show you right now on testnet Snow Trace remove the zeros is our test recipient contract. And it's like a pretty simple one if I can find it. Test recipient.
00:06:35.590 - 00:06:52.314, Speaker A: All right, so it has a very simple handle function here that just emits the message and then puts the sender and the data in storage. But so we can basically paste that in here and then we can send message body, right? So whatever bytes we want. So this is just in Hex.
00:06:52.314 - 00:07:05.406, Speaker A: So we can just say kind of like hello from EFSF copy and paste this in here and then do the transaction. I'm pretty sure this should work. So we just sign it with MetaMask.
00:07:05.406 - 00:07:29.914, Speaker A: Obviously, if you use hard hat or foundry or whatever you want, you just kind of send that transaction and then you get this transaction hash. We have a message Explorer that you can use to kind of follow along on the status of your message. It's Explorer Hyperlain XYZ in here and then there you go.
00:07:29.914 - 00:07:46.114, Speaker A: When it was delivered, you can kind of check it out. The transaction is here and you can kind of see that we received the message with our message on Fuji, on Snow Trace. And that's it.
00:07:46.114 - 00:07:59.720, Speaker A: That's how you send a message from one smart contract from, I guess in this case, optimism girly to Fuji. And it was that simple. As I said, like you saw and handle interface is pretty simple.
00:07:59.720 - 00:08:06.070, Speaker A: So let's move back here. So that was the messaging API. That's kind of what we call our low level API.
00:08:06.070 - 00:08:41.678, Speaker A: And one kind of downside it has is that it requires you to basically have the recipient conform to a particular interface, right, like the recipient needed to implement the handle interface. But what if you could do better? And so a common use case, for example, is what if you have, let's say, a Dow and Ethereum that wants to actually own, let's say, assets or wants to own contracts on another chain with the messaging API. You would basically have to kind of create this proxy contract on the destination chain, which basically takes the message and then performs the action on behalf of the sender.
00:08:41.678 - 00:09:16.430, Speaker A: And so we just extracted that out in what we call the Accounts API, which basically deploys you with create two a proxy account for any given sender address on any given origin chain and can then do this for you. So the API looks a little different and I got to do it in a second. But kind of the benefit is basically that if you are like an account on Ethereum, you automatically have all of these proxy accounts on all these other chains that can basically own assets for you and then also do actions for.
00:09:16.430 - 00:09:35.650, Speaker A: And so the interface is very simple. Again, it's like a dispatch like on our Interchange Accounts router, you have a destination chain. You have the recipient for which you want to make a function call, and then data, which is just the function call that the proxy account is supposed to make abi encoded.
00:09:35.650 - 00:09:50.730, Speaker A: And so, yeah, again, an example is governance. You have a dow, you want to do something there and let's do a demo once again. So again, we have a quick start right here under the Accounts API.
00:09:50.730 - 00:10:15.390, Speaker A: So you basically just go like in our case, you go to the Interchange Account router, which is right here and has kind of these two dispatches. You once again specify a destination domain, which let's just do Fuji again. So let me see, what the destination destination domain right here.
00:10:15.390 - 00:10:35.718, Speaker A: And then this is going to look a little bit more awkward in ether scan, but I think when you use, again Hardhead or Foundry, it will be much easier. So basically it's an array of calls. And then a call is really just like two things, right? Like the address that the call supposed to do on the remote chain and then the call data, which is the abi encoded function call.
00:10:35.718 - 00:10:49.980, Speaker A: And so let's say in this case, we basically want to call a function on the test recipient, which just happens to be FUBAR. It takes two arguments, a number and a string. And so if you again wrangle the API, it just ends up looking like this.
00:10:49.980 - 00:11:24.440, Speaker A: So we'll just copy and paste this in here and then let's connect web three MetaMask, yes, and then write and then confirm, right? And so basically I am what I'm like zero xfad on Optimism girly. And so basically I can calculate the proxy address that this address will have on every other chain by just calling a predictable view function. So in this case, the sender oops, that's not what it is.
00:11:24.440 - 00:11:46.154, Speaker A: Copy and paste my address in here, right? Like my sender is on Optimism girly. So the origin, I think it's 420 on there. And so basically the inner chain account address, which again is the address from which the calls will make on every other chain is like c seven, B, A, blah blah, blah.
00:11:46.154 - 00:11:57.540, Speaker A: So let's look at our transaction here. Take the transaction hash, let's put it in Explorer again. There you go.
00:11:57.540 - 00:12:29.078, Speaker A: And what you can see here, for example, Explorer will actually decode your message and will determine like, hey, you are this sender. That means that when the magic is processed, this address, your proxy contract will make a function call to this destination address with this call data. And so if you look at the block Explorer here, you will see that on Fuji, kind of like C seven basically made a call to our test recipient that we specified.
00:12:29.078 - 00:12:56.040, Speaker A: And then the test recipient just emits this event that basically says like, hey, I received this call from my proxy account, right? C seven BA and with these messages. And so we think that's another nice API because you don't actually need to deploy anything under a destination chain. You just from the origin chain can basically own things like contracts or assets on the remote chain via this proxy account.
00:12:56.040 - 00:13:20.086, Speaker A: So that's the accounts API. Another use case that we found that we wanted to make it easier for developers is let's say you are on Polygon but you want to make a view call on Ethereum, right? Like there's some state, let's say you want to know the price of the unisop v two swap of Eve or Die or something. But you want polygon.
00:13:20.086 - 00:13:57.174, Speaker A: How do you do that? Right? And so what you could do is you could deploy a contract on Ethereum and Polygon, send a message over that contract, makes a view call to the uniswap swap and then sends back a message back to Polygon with the results of that view call. And so again, instead of making you deploy these contracts, we've just decided to make a similar kind of router contract that just does that for you. And so basically in this case, what you do is you call our query router with your query of basically the destination chain, which target you want to hit and what's the view call.
00:13:57.174 - 00:14:20.974, Speaker A: And then we'll basically do the hard work of sending the message over, making the view call on the destination chain and then returning you the result in the callback that you specify. And so the API looks a little bit like this. So you do query destination domain, the call that you want to make yourself and then again specifying what function should the router call on the origin chain for you.
00:14:20.974 - 00:14:33.342, Speaker A: And again, on the destination chain you have to specify nothing. Right? I guess we have here an ENS example. If you want to kind of call resolve an ENS name from a different chain.
00:14:33.342 - 00:14:45.570, Speaker A: But let's just do once again the demo. So we have another quick start right here, queries API. Basically it tells you to just navigate to the test query sender.
00:14:45.570 - 00:15:16.146, Speaker A: So we'll go right here. Actually, let's take a quick look at the contract test query sender, right? So basically what you can do is that query an address and all it does is really kind of pass through the destination domain the call and then it just has like a handle query address result function on itself which the router will call whenever it gets back the result. And so let's call it right now.
00:15:16.146 - 00:15:35.894, Speaker A: So again, let's connect MetaMask, let's query an address. And so once again, let's just query what do we want to query. So we can just query this content that we have and we can just kind of query for the owner of it.
00:15:35.894 - 00:15:50.880, Speaker A: And so let's say the owner call abi encoded is this string. Once again, let's figure out which destination domain you want to hit. Let's just do Fuji again because it's been working so well.
00:15:50.880 - 00:16:11.346, Speaker A: And then rewrite it, we confirm. And then this transaction happened here. Once it is reflected, once Etherscance puts it up, I think you will see kind of here, query dispatch, right, which basically means like, hey, we sent a query over there.
00:16:11.346 - 00:16:49.518, Speaker A: Once again we can use our Explorer to use our Explorer to see where the message is at and was already delivered, right? So this is the first transaction where we send the query over on the destination chain here. When the message gets processed, we make the view call and then actually we send a message back. So this is what we call the dispatch event, right? So we basically return the query with the result, which means that this transaction hash actually like the destination processing of the message itself is actually another message.
00:16:49.518 - 00:17:03.890, Speaker A: And so we can see that here. So there's basically kind of this return message that now sends back the query result back to the origin chain. And then once that is done on here, you can see that the query was resolved.
00:17:03.890 - 00:17:21.794, Speaker A: And actually if we look right here Recry, we can see basically what the test query sender will just persist the result in storage. And that's what it is right here. So that's our query API.
00:17:21.794 - 00:17:46.490, Speaker A: And then last but not least, one of the things that people ask a lot about is how do I move value, right? Because a lot of these things was basically information. But what happens when you want to move value? Let's say if I have some yield farm on Polygon, but I actually see there's another yield farm that's really cool on say, Arbitrum. How do I move this as a developer? And so it's a pretty tricky, like definitely come talk to me afterwards if you're interested in the nuances of that.
00:17:46.490 - 00:18:15.020, Speaker A: But basically we have this token bridge API which allows us to wrap other token bridges to basically move value around, right? And so Circle for example, announced their native USDC bridge where you're allowed to burn USDC on one chain and mint it on another. And so basically we let you do that within the same interface because we believe that there will be many different bridges that you can use and Circle is only going to be available in some chains. But what do you do on other chains? And so we will just have this kind of single interface that allows you to move value around.
00:18:15.020 - 00:18:22.714, Speaker A: And it's again pretty simple. It's literally dispatch with just tokens. So basically just specify the token address, the amount and then the bridge name.
00:18:22.714 - 00:18:47.970, Speaker A: So for right now it's only Circle on both Girly and Fuji and then on the nation chain you can handle that message with the token address and the amount. All right, one last demo is for the token bridge API. So this is USDC on, right? And so one thing we need to do is we need to approve the token router with some USDC.
00:18:47.970 - 00:18:58.620, Speaker A: So let's switch over to Gurley. Let's approve the spender will be our token bridge router. So we'll copy that in here.
00:18:58.620 - 00:19:13.082, Speaker A: Approve let's say just one. Because we're stingy, we'll approve the router here and which now means that we can dispatch of tokens. So let's again send to Fuji.
00:19:13.082 - 00:19:31.394, Speaker A: I still didn't remember what the domain is for Fuji. So let's just fuji is 43 one one three recipient address. We just have again like pre deployed recipients, but you can obviously use your own.
00:19:31.394 - 00:19:36.822, Speaker A: So that's right. Here the message body. Again.
00:19:36.822 - 00:19:53.878, Speaker A: We can put whatever we want. I will just say the classic hello world, which is where is the message? All right, here the token. Is the token the USDC address.
00:19:53.878 - 00:20:12.350, Speaker A: So that's this thing right here amount. Let's just do one and then the bridge, in this case a circle or again, whatever other bridges we will use in the future. Got to connect, MetaMask and then write that confirm.
00:20:12.350 - 00:20:19.730, Speaker A: All right. And then the transaction is once again here. Once it gets mined on Girly.
00:20:19.730 - 00:20:32.610, Speaker A: Girly works surprisingly well. And as everybody knows here, girly Eevee is very hard to get. So be careful.
00:20:32.610 - 00:20:42.050, Speaker A: Okay, let's take a little longer. Again. Look at explorer.
00:20:42.050 - 00:20:56.924, Speaker A: Think maybe hopefully girly won't be too content today, but still indexing. There you go. All right.
00:20:56.924 - 00:21:23.922, Speaker A: So now you can see here kind of how this USDC was burned, right? Like to the zero x zero address. And then once it gets processed here, this will happen in 1 second, maybe 2 seconds, I guess. But it will happen in 1 second, I'm pretty sure.
00:21:23.922 - 00:21:41.750, Speaker A: I mean, this is literally the last thing it fails. This will be like, I was so good about life demoing this, but maybe yeah, before we get to that, I guess at the end, obviously, I'm going to happy to take questions. We'll have a booth all the way at the beginning.
00:21:41.750 - 00:21:55.546, Speaker A: We'll be here all weekend. Obviously happy to chat or help out of anything. We'll have four bounties, kind of like best use of hyperlane as well as kind of like best NFT use, best DeFi use, best gaming use as well.
00:21:55.546 - 00:22:11.540, Speaker A: Yeah, but I want to emphasize that we're here to help. We think that the crosschain future is very bright, even if we're very early. And you could be one of the first people to kind of build these crosschain applications because we just think everything will be a crosschain application in the future.
00:22:11.540 - 00:22:28.450, Speaker A: And I would love to end the presentation up. There you go with and so you can see that we minted some USDC to our recipient and our logs basically said like, hey, I got this message hello world. And from this token.
00:22:28.450 - 00:22:32.322, Speaker A: Yeah. So I think that's it. Yeah.
00:22:32.322 - 00:22:32.720, Speaker A: Any questions?
