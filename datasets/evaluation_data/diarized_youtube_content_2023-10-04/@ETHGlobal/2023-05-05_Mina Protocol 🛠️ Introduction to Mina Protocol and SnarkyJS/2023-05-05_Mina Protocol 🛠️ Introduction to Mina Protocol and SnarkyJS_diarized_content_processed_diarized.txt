00:00:07.130 - 00:00:26.950, Speaker A: Konichiwa everyone. My name is Angus, and I'm going to be talking today about Mina protocol and Snarky JS. So as a quick introductory slide here, as I said before, my name is Angus Maidment and I am working doing developer relations for the MENA Foundation.
00:00:26.950 - 00:00:46.330, Speaker A: I live in Edinburgh in Scotland and my Twitter is at blockchainbeard so you can follow me on there. I also have a poll going for all participants of ETH Tokyo. It's about how you add people when you're kind of exchanging telegram information.
00:00:46.330 - 00:01:03.918, Speaker A: So I'd be really grateful if everyone votes in that poll. I've put a prediction for what I think the outcome will be as a Shah two five six hash and I'll reveal it when the poll closes at the end of the day on Sunday. So there's a funny picture of me as well blending into the background of the sign in my mino hoodie.
00:01:03.918 - 00:01:38.198, Speaker A: I've actually got the trackies on today, but no hoodie because it's too hot. So, the structure of the talk today, I'll first of all introduce the MENA Protocol and give you a quick intro as to what zero knowledge proofs are. I'll talk a bit about ZK apps, the kind of applications that you can build on top of Mina Protocol, a bit of a deeper dive into Snarky JS, which is the TypeScript library that you can use to build zero knowledge proof based applications.
00:01:38.198 - 00:02:11.958, Speaker A: And then I'm going to tell you about a program that we have got going at the moment called ZK Ignite and also the next steps for how you can get started building stuff. So the first section, what is Mina? Mina is an L one blockchain that's built from the ground up using zero knowledge proofs. And so to give a general introduction about what zero knowledge proofs are, it allows you to verify information in a private, trustless and decentralized way.
00:02:11.958 - 00:02:39.630, Speaker A: So that has a number of useful properties that allow you to do things like create ZK roll ups and ZK EVMs of which you might hear about from other people here at the conference. You can do private transactions and keep data more private or hidden in some way. It's good for doing private voting.
00:02:39.630 - 00:03:10.198, Speaker A: It's got a lot of applications when it comes to identity as well, which is obviously an important aspect of Web Three. And also you can verify large amounts of computation efficiently. So a zero knowledge proof effectively says that you can prove that a program has run in a valid way and that the output is valid.
00:03:10.198 - 00:03:26.122, Speaker A: You can prove that efficiently. So it's fast to verify the proof and you can do that without seeing all of the inputs necessarily. You can do that just by using what we call the constraints.
00:03:26.122 - 00:03:53.590, Speaker A: So that gives you options to give your users more privacy and security by keeping their information private and also has implications for verifying things and scalability as well. So just to give you an idea. These are kind of like the function prototypes or kind of declarations for some cryptographic primitives that you might be familiar with.
00:03:53.590 - 00:04:10.806, Speaker A: A hash function. You put a string into the hash function, which is h there, and you get out the hash, which is also a string. So you can tell that two pieces of data are the same if they have the same output from the hash function, right? There's public key signatures.
00:04:10.806 - 00:04:54.490, Speaker A: So you have a sign function. So you take a private key, you can sign a message with the sign function and that will give you an output of a signature, right? And then you can verify that signature using the corresponding public key, right? And so you put that signature, the message and the public key into the verification function and you get out. Either this has been signed by that private key or it hasn't, right? So then you can tell if a private key has signed like a message or a transaction with a zero knowledge proof, right? The way to think about it is there's a compilation step.
00:04:54.490 - 00:05:10.960, Speaker A: So you compile your program and then that gives you so you have some code, you compile it and that gives you the verification key, which is a string. The verification key or index, that's a string. Then you have a proving function.
00:05:10.960 - 00:05:34.562, Speaker A: So you have the program. You run the program with some inputs, right? You use the proving function to then generate the proof. The proof is a string as well, right? And so then when you did the compilation step, you get the verification key, you use the proving function to create the proof.
00:05:34.562 - 00:05:53.294, Speaker A: Then you can verify, you take the proof, you take the public inputs, but not the private inputs, and you use the verification key that you created at compilation time. You run the verification function and that gives you the boolean. The proof is valid or it's not.
00:05:53.294 - 00:06:18.870, Speaker A: So now what we're doing is you can verify computation, not just that something has been signed, but you can verify that a program is run correctly and you can keep some of the inputs private or hidden. So you only need some of these inputs, the public inputs. So that kind of gives you an idea of how it's different to these other the zero knowledge proofs are different to other cryptographic primitives.
00:06:18.870 - 00:06:42.570, Speaker A: And I'm going to talk a little bit now about Mina protocol, which is, as I said earlier, a layer one blockchain that is built entirely using zero knowledge proofs. Now, as I said before, zero knowledge proofs you can verify efficiently. And so Mina is a succinct blockchain.
00:06:42.570 - 00:07:02.274, Speaker A: It's been built using zero knowledge proofs. So that it's very efficient to verify the state of the blockchain. So that means that you can verify the state and run like a light node on a variety of different hardware, including a mobile phone.
00:07:02.274 - 00:07:18.306, Speaker A: So that's what that diagram on the left is saying it works using recursive ZK snarks. So recursive proofs to kind of link the states of the blockchain together and to move it on. And that's what this diagram in the middle is signifying.
00:07:18.306 - 00:07:29.260, Speaker A: And so that's what keeps it lightweight as well. The fact that these proofs can be recursive, you can prove the last proof. You can kind of chain them together and the proof stays the same size.
00:07:29.260 - 00:08:05.766, Speaker A: It's a constant size and it's fast to verify. And also it's interoperable in the sense that because you have this lightweight proof that you can quickly verify, you can use Mina as a kind of ZK layer and then take the state of Mina and kind of verify it in other environments, including for example Ethereum, to have it function as a kind of ZK layer for other blockchains or environments. So this isn't just stuff that we're kind of postulating on.
00:08:05.766 - 00:08:35.570, Speaker A: There's actually a grant being given jointly by the MENA Foundation and the Ethereum Foundation to this other foundation called the Nil Foundation. And they're building in EVM MENA state verification. So in the future, when this is ready to go, you'll be able to verify the MENA state in an EVM smart contract, which is pretty cool, because then you can do whatever you want on Mina, verify an EVM and then do stuff on the EVM chain.
00:08:35.570 - 00:08:48.606, Speaker A: I'll take questions at the end, but thank you, Jonathan. We also have the openmina web node. So basically you can run this node in a web browser.
00:08:48.606 - 00:09:20.590, Speaker A: So when I was referring earlier to that diagram where it says you can run a node on your phone, you can actually spin up a meta network node in the web browser, right? So you could, in theory, submit transactions directly through the web browser without having to go to like a third party RPC provider. So coming on to what you can do with Mina at the hackathon right, is you can build apps on top of Mina that use zero knowledge proofs. We call them ZK apps.
00:09:20.590 - 00:09:42.930, Speaker A: And so just to introduce the concept, to think about the concept of ZK apps, ethereum uses on chain computation. So you write your code in solidity and then you put the actual code onto the blockchain. And then all the nodes in the blockchain network, when you say you want to run a function in your smart contract, they all run the code that they have on the blockchain.
00:09:42.930 - 00:10:08.874, Speaker A: And so it's verified by the fact that everyone does the computation right, and gets the same result. All the nodes on the network on Mina, the ZK apps use off chain computation with on chain verification, right? So you do a bunch of compute off chain and then you generate this proof that I was talking about earlier, and then that gets verified by the network. So this has a number of advantages.
00:10:08.874 - 00:10:24.178, Speaker A: One, you can give your users more privacy by keeping inputs to the function private. There's no gas fees in Mina. So you don't pay for computation, you just pay for the block space.
00:10:24.178 - 00:10:39.866, Speaker A: You do all the computation you want, you generate a proof and then you put that proof in a transaction. All you pay is the transaction fee. There's composability using Snarky JS, our TypeScript library, so you can kind of program your own ZK apps to fit your use case.
00:10:39.866 - 00:11:18.840, Speaker A: And there's scalability through rolling things up with this recursion that I'm talking about. So the fact that you can use proofs to generate further proofs means that you can kind of roll things up and collapse them all down into single proofs that kind of verify everything that you've done and also the interoperability thing through the blockchain being lightweight and quick to verify the state of. So to explain that in slightly more depth just the process of it, just to kind of help you get a mental model of what's going on when you do the compilation step that I was talking about.
00:11:18.840 - 00:11:53.486, Speaker A: So you write some code that's going to be your ZK app, and then you compile the code and that produces the verification key. And so then you'd send a transaction to the MENA network that creates a ZK app account. So an account for your ZK app and that verification key is stored in that Zkap account, right? So now you have a ZK app that is associated with this verification key that's on the network right now on the left hand side of this diagram, this is your ZK app.
00:11:53.486 - 00:12:18.302, Speaker A: So you serve the ZK app to a user in a web browser, for example, right? They run the ZK app with some data inputs that they put in to the web browser when they run the app. That's the program bit that we got out of the compilation thing that I was describing earlier. So they run the program and it generates the zero knowledge proof.
00:12:18.302 - 00:12:45.514, Speaker A: So they generate the proof and they include that zero knowledge proof in a transaction. The transaction gets sent to the MENA network and the MENA network uses the verification key that you sent when you deployed the ZK app, right? And then it uses the verification key with that verification function with your proof. And that then says whether this proof that you've generated is valid or invalid.
00:12:45.514 - 00:13:09.450, Speaker A: If it's invalid, then the transaction is denied, doesn't go through. So that's kind of roughly how the verification happens when you deploy. You put the verification key on the network and then the network nodes basically check your proof against that key when you use the ZK app and create the proof.
00:13:09.450 - 00:13:31.790, Speaker A: So ZK apps are composed of methods, right? And methods you can think of as like functions in other smart contracts. So there's this diagram on the right. Basically you have inputs and outputs to these methods, right? You can have arguments that go into the method.
00:13:31.790 - 00:13:52.626, Speaker A: There's a very small amount of on chain state that you can manipulate. And it says here are some values from the state of the world. So that's another database that you have on your website or some other thing that you can kind of control or change and then that's the input to the method the method runs.
00:13:52.626 - 00:14:22.790, Speaker A: And then as a result of the kind of logic in it, you can make updates to the state of the smart contract or you can make updates to some other thing based on something that happens in your method. And so if you want to learn how to write methods, we need to go on to Snarky JS. Snarky JS is the TypeScript library that you can use to define, create and verify zero knowledge proofs.
00:14:22.790 - 00:14:51.962, Speaker A: So it's giving you as a developer the flexibility to build applications that use zero knowledge proofs without having to be a cryptographer or kind of a highly capable functional programmer who can understand DSLs in OCaml. I mean, if you are into that sort of thing, you should definitely still come and talk to us because it's all kind of under the hood. But Snarky JS is basically giving you the TypeScript interface that a lot of developers are more used to.
00:14:51.962 - 00:15:07.550, Speaker A: So here's some logos that you might recognize. So we have basically familiar tooling that you'll be used to. We've got good IntelliSense support in Visual Studio, which makes it the developer journey a bit easier.
00:15:07.550 - 00:15:36.144, Speaker A: And you can write all your tests in JavaScript using Jest. So this is five steps to show you how easy it is to get started. The first one is to install the Zkapp CLI tool, which is yeah, it's a CLI tool that kind of helps you with building, as in compiling, configuring and deploying your ZK apps.
00:15:36.144 - 00:15:48.970, Speaker A: Then it's one simple command. ZK project creates you a new project directory and it actually has a demo kind of smart contract in there already. The fourth step is to configure it with our kind of testnet information.
00:15:48.970 - 00:16:10.400, Speaker A: There's also a step here where you need to go to the faucet. If the faucet's giving you any trouble, you can kind of come to the booth or message me or tweet at me and I can give you some test app meetup because I've managed to secure a supply of it especially for this weekend. And then all you do is ZK deploy Berkeley and then that's it.
00:16:10.400 - 00:16:28.628, Speaker A: You've deployed your ZK app. So to program in Snarky JS you also need to understand that we use field elements. So these are elements of a finite field which we use because that's how the cryptography works.
00:16:28.628 - 00:16:53.564, Speaker A: In Snarky JS it can store quite a large number up to almost 256 bits. So it's a built in type in Snarky JS and it has built in methods as well. So down here you can see an example where you declare a constant called sum and then you make it out of two new fields, one of which is doing the dot add method to another new field, which is three.
00:16:53.564 - 00:17:06.640, Speaker A: So that sum will end up being four. But it'll be a field element, right, which is what you need to use if you want to do things Snrtjs. There's also some other built in types, including some crypto stuff.
00:17:06.640 - 00:17:18.900, Speaker A: So you got public and private keys and signatures. And also there's a Merkel Tree implementation that you can use for things. And these all have built in methods on them as well.
00:17:18.900 - 00:17:42.744, Speaker A: So if you want to find out more about that, it's all in the docs. Or you can use it IntelliSense if you use Visual Studio code that'll tell you what the methods are. So this is kind of an example smart contract that just to give you an idea of what it looks like, I thought I was going to have a kind of pointer that I could use, so I'll try and point and I can actually refer to the lines.
00:17:42.744 - 00:18:09.676, Speaker A: So in line twelve you've got this state, right, kind of variable called NUM. So you have a very small amount of on chain kind of state storage. And then what this is doing is this method down here on line 22 is saying we set the initial state to one, which is a field, remember, because we're using field elements.
00:18:09.676 - 00:18:29.308, Speaker A: And then the update method on line 26 is saying check, get the current state, check that that is actually equal to the current state. So you're kind of putting it into the proof that this is the state that you got and it's equal to the variable that you have. And then it's saying add two to the current state.
00:18:29.308 - 00:18:42.352, Speaker A: So then this is the demo smart contract that you get. So it'll just every time you call update it'll update the state variable by two. So that's what snarky JS looks like.
00:18:42.352 - 00:18:57.990, Speaker A: Also, this is the Mina colored theme that someone made for Visual Studio, like the syntax highlighting. So if you want to get hold of that, I think we can maybe link you up to it. But I'm not entirely sure.
00:18:57.990 - 00:19:21.016, Speaker A: So next steps recursion. We've been talking a lot about recursion, obviously making some bad jokes with the bag within a bag. But one of the really powerful aspects, one of the powerful features of Snarky JS is that you can do infinite recursion, right? So you can use proofs as input to other proofs.
00:19:21.016 - 00:19:35.964, Speaker A: So you can kind of roll proofs up into a single proof to verify that several things have happened with intermediary kind of proof stages. So this is a diagram here of kind of, oh, here's a Snark. And then you put that into the next Snark.
00:19:35.964 - 00:19:54.360, Speaker A: And kind of the proof stays a constant size the whole time. So you can kind of infinitely roll up these proofs, right? And so an example that I'll take you through is in the case of a card game. If you're player one, you take your turn according to the rules of the game.
00:19:54.360 - 00:20:01.188, Speaker A: You produce a proof that you've done a valid move. You pass that proof to player two. Player two can verify the proof.
00:20:01.188 - 00:20:07.292, Speaker A: They can verify that player one has taken a valid turn. Then they can make their turn. They can pass the proof to player three.
00:20:07.292 - 00:20:31.636, Speaker A: Player three can then verify that player two has taken a valid turn as well, right? And so in that way, you can kind of go through as many hands of the game, as many rounds as you want, and then you can do it all off chain. And then when you have the end proof, that's kind of the end state of the game. You can then put that onto the blockchain to show these three players have played 20 rounds of this game.
00:20:31.636 - 00:21:02.792, Speaker A: Okay? And so this is something that's quite interesting. A lot of the time when people talk about roll ups, they're talking about batching transactions together, right? But now with Mina and Snarky JS, you can start to think about rolling proofs up together, right? And that opens up quite a lot of different kind of ideas and use cases. So that's something recursion is something that is really quite exciting about Snarky JS and will open up new, different ideas.
00:21:02.792 - 00:21:21.040, Speaker A: So here is the prize pool for ETH Tokyo hackathon. First prize is 8002nd 6003rd prize, $4,000. And there's a $2,000 pool for kind of runners up who don't get the top three, but still submit a project that's built with Snarky JS.
00:21:21.040 - 00:21:37.704, Speaker A: There's also this program called ZK Ignite, which I mentioned earlier. It's a sort of cohort based grants program. So you submit a proposal, there's some voting, and if you get funded, you get funding for your project.
00:21:37.704 - 00:21:50.124, Speaker A: And also you kind of go through the process with a bunch of other projects. So it's a kind of cohort like that. And you get hands on support and kind of training and kind of community type things going on.
00:21:50.124 - 00:21:58.128, Speaker A: And so there's a new cohort starting on the 24 May. You can scan this QR code to get more information. And one more QR code.
00:21:58.128 - 00:22:12.404, Speaker A: This is like the Hackathon starter kit. It's got a link to the documentation and also a couple of other things. So please come and talk to us after this workshop as well, or at the booth which is in there.
00:22:12.404 - 00:22:20.100, Speaker A: I'm not going to try and describe where it is. We've got a big Mina sign behind our table though. And so that is the end of the presentation.
00:22:20.100 - 00:22:33.630, Speaker A: Thank you very much for being here. We've got about eight minutes left for questions, so I'll take this question down here first. So there's a verification keep per app.
00:22:33.630 - 00:22:38.510, Speaker A: Per ZK app. Yes. That means there's a trusted setup per app.
00:22:38.510 - 00:22:44.480, Speaker A: That's a good question. Reference. There is not a trusted setup per app.
00:22:44.480 - 00:23:24.056, Speaker A: And so it's because the proof system that we use, it's called Kimchi, and it uses something that's like bulletproofs, that uses the inner product argument to avoid the need for trusted setups. Don't ask me to explain it more than that because I don't know all the math. But the inner product argument way of it's kind of like something that I don't want to call it a worker neither, I'm not sure the correct terminology, but basically there isn't a need for trusted setups because they use this inner product argument methodology.
00:23:24.056 - 00:23:35.548, Speaker A: So this verification key, what is it? It's a string. It's an input to each proof of.
00:23:35.554 - 00:23:36.270, Speaker B: The app.
00:23:39.220 - 00:23:53.488, Speaker A: When we're talking about the network, the verification key. When you deploy your ZK app, the verification key gets stored on the network. And then the MENA network uses the verification key to verify the proofs.
00:23:53.488 - 00:24:14.234, Speaker A: So that the verification key and the proof go into the verification function and then out comes proof is valid, proof isn't. In a soda. Mina impress.
00:24:14.234 - 00:24:24.926, Speaker A: Use some plunk. Light setup. Plonk light? The docs say the proof system is Plonkish.
00:24:24.926 - 00:24:38.680, Speaker A: Right? And also there's the Mina book, which is a load of documentation about the proof system, which has a lot of math and a lot of cryptography, which I can point you to, which will have all the answers that you're looking for. Thank you, I'm sure.
00:24:43.410 - 00:24:55.700, Speaker B: So you mentioned when you deploy a ZK app, you store the verification key on chain, and there's also some very small amount of state that is on chain that is accessible to each of these ZK apps, is that correct?
00:24:56.330 - 00:24:57.030, Speaker A: Yes.
00:24:57.180 - 00:25:12.940, Speaker B: How is the blockchain fixed size with that state? I'm assuming there's not an upper limit to the number of ZK apps that can be deployed on chain. So how can you store a verification key on a fixed size blockchain without increasing the size?
00:25:14.030 - 00:25:45.586, Speaker A: The only limit to the amount of ZK apps that we'll have on chain is the imagination of developers like all of you. Also, the blockchain isn't a fixed size in the sense that so the state proof stays a fixed size which you can verify the whole state of the blockchain from. But obviously there's other things which kind of make up the blockchain, right? And that goes into how the Mina network works and the kind of different roles and entities that there are.
00:25:45.586 - 00:26:00.986, Speaker A: There's different kinds of nodes, right, that have different storage requirements. But the fixed size thing, so you may have seen this before as well, it's a number of kilobytes. The fixed size thing is the size it takes to verify the state of one account.
00:26:00.986 - 00:26:08.614, Speaker A: And that includes the kind of the overall state proof for the latest block in the MENA blockchain.
00:26:08.742 - 00:26:15.020, Speaker B: So the state proof is what's? Fixed size? It's not the state yes, fixed size.
00:26:17.330 - 00:26:37.986, Speaker A: But to verify the state of a single account, it's a fixed size per account. So then I think it would be, if you wanted to run a node with the whole state of every account. I think it would be N accounts times that number, but I'm not sure on that.
00:26:37.986 - 00:26:50.620, Speaker A: I'm mainly dealing with the ZK app stuff, but I'm sure we can get someone to go in depth on the node stuff with you, if you like, at the booth. Thank you. There's a question over here.
00:26:53.830 - 00:27:06.278, Speaker C: Thank you. It was nice presentation. Could you tell more about the vision of Zke apps ecosystem? What types of products you want to have on it? Like DeFi some games or whatever?
00:27:06.444 - 00:27:36.110, Speaker A: That is a very good question. So we've just run the first cohort of that ZK Ignite program and the kinds of ZK apps that were funded by a kind of council of electors who were kind of community members. The kind of things that are getting funded are l two roll ups that do kind of batch things together, transactions or other kind of bits and pieces.
00:27:36.110 - 00:27:50.098, Speaker A: We've seen a couple of roll up solutions, we've seen data availability solutions. So at the moment there's still quite a lot of infrastructure and tooling being built. There is one thing was really cool, actually.
00:27:50.098 - 00:28:22.654, Speaker A: It's a kind of verification app for people who get kind of different colored belts in martial arts and you can kind of check who has given whom each belt and things like that. So that one was quite interesting, I think, when it comes to things like DeFi, because the computation model is different to EVM quite a lot of the things that we think about in DeFi. It's not really defined how to do it on MENA yet.
00:28:22.654 - 00:28:40.082, Speaker A: So that presents to you an opportunity, I think, but also a challenge. So you kind of need to figure out a different way to do things on mina. But then if you do figure it out, you'll be the first person to do it.
00:28:40.082 - 00:28:51.398, Speaker A: So that's why it's both a challenge and an opportunity, I think. But we really are just getting started with ZK apps, so it's a good time to get in early.
00:28:51.564 - 00:28:52.520, Speaker C: Thank you.
00:28:54.570 - 00:29:07.290, Speaker A: One last quick question, and you can ask me questions outside as well. I was just wondering where the proving actually gets done. Is it in the user's browser or is it somewhere else? It's in the browser.
00:29:07.290 - 00:29:30.914, Speaker A: I think we have enough time to do this answer. So you run a ZK app in the browser and what that is doing is running the program and then producing the proof and that's the proving, right? So you run the program, you produce the proof in the browser and then the verification happens in the network. Okay, I'll ask later about timing though.
00:29:30.914 - 00:29:42.274, Speaker A: Does that have substantial lag or is it pretty quick? Yes, you're right. That is a question for come to the boot on more death later. There's a lot of asterisks attached to that.
00:29:42.274 - 00:29:46.730, Speaker A: So thank you very much everyone, though. Bye bye to everyone on the internet.
