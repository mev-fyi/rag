00:00:23.300 - 00:00:34.010, Speaker A: Hello, everyone, and welcome to the Hackfs Workshop using Drand and timelock encryption. Joining us today is Patrick McClerg, who will be taking us through the session. And with that, I'll pass it over to Patrick to get the session started.
00:00:35.420 - 00:00:39.076, Speaker B: Thank you very much for it. Yes. Welcome, everybody, to the Drand.
00:00:39.076 - 00:00:52.576, Speaker B: Hackbest Workshop. First we'll go over a little bit about the challenges and then we'll dive into what what Drant is and how it works. Then we'll finish up on what time lock encryption is and how you can use it.
00:00:52.576 - 00:01:14.250, Speaker B: And then I'll field some Q A at the end for any questions you might have along the way. So firstly, the challenges are twofold. First is for the best app built with timelock encryption that might not make any sense to people who have not come across timelock encryption yet, but we will get to that very soon.
00:01:14.250 - 00:01:47.490, Speaker B: Secondly, there's a prize for the best use of DRAM that solves an everyday problem and improves the security profile of a blockchain use case, a game, or improves the DRAM ecosystem. And there's $2,000 redo's up for grabs for people who make the best apps, essentially. Okay, so what is drand? Drand is a decentralized Threshold network for providing publicly verifiable, unbiaseable random numbers.
00:01:47.490 - 00:02:16.940, Speaker B: It's based on Threshold Cryptography, as I said, and supports pairing operations, which we'll come to a little bit later. Essentially, when the network is created, a verifiable secret sharing process happens and a shared private key amongst all the permitted participants of the network is created which no single party has access to. And then they emit randomness at epochs using the signatures from Threshold cryptography scheme.
00:02:16.940 - 00:02:44.192, Speaker B: It's built on BLS twelve 381 has been tested, audited by Kudelsky Security and deployed at scale. The biggest user right now is FalcoIn network who used the randomness from Drand for leader election and some other proof of space time related things. And currently Dran randomness is available on the Fem in the Cosmos ecosystem and kind of on Ethereum.
00:02:44.192 - 00:03:03.320, Speaker B: In fact, in one of the previous ethereum hackathons, a team built ethereum integration for Dran called ORANGESIs, which I've linked in the bottom of the slide here in case any of you want to try it for yourself. So, a bit of a primer on how DRAM works. The notation is not super important.
00:03:03.320 - 00:03:13.432, Speaker B: That's for the math nerds who like all the extras. But in essence, DRAM emits randomness epochs. Each of these epochs map to some time in the clock.
00:03:13.432 - 00:03:33.552, Speaker B: So for our default network, that's every 30 seconds. Every 30 seconds, the nodes in the network gossip a partially signed message over the number of that epoch. And then when any node gains a threshold number of those signatures, they can aggregate them into one group signature.
00:03:33.552 - 00:03:59.324, Speaker B: That's valid for everybody in the network because as I said before, no single node in the network ever has access to the private key. That signature is indistinguishable from randomness as they can pre image in. Then we pass that signature through a hash function to remove some mathematical properties from it and that becomes our random number.
00:03:59.324 - 00:04:18.130, Speaker B: And this happens at every single epoch. Everyone in the network gossips all their partial signatures to one another and create the randomness. You might be familiar with some existing types of randomness, and I'll just give a brief breakdown of how Dran differs from those.
00:04:18.130 - 00:04:37.720, Speaker B: So the one most people are familiar with is dev U random built into all Unix machines and Linux machines and Mac machines. And there's kind of an analog in the Windows world. It's probably what you use to generate your bitcoin private keys and do lots of other day to day randomness operations.
00:04:37.720 - 00:04:54.344, Speaker B: The biggest difference, obviously, is dev U random is private randomness and Dran's public randomness. So naturally you wouldn't want to give your bitcoin private key to anybody else unless you want them to take all your cash. Dran hybrid.
00:04:54.344 - 00:05:04.524, Speaker B: All the random numbers are public. Everybody can read them, everybody gets the same random numbers. Additionally, you random on your own device.
00:05:04.524 - 00:05:27.156, Speaker B: But Drand is a decentralized network, so there are lots of different participants working together to create this randomness. And finally, Drand is verifiable. So if you were to get a number from a random generator, you've sort of got a trust in the fact that it's implemented correctly, that you're using the right generator, that the number that comes out is actually random.
00:05:27.156 - 00:05:57.148, Speaker B: But because Drand is based on a signature scheme, you can verify the fact that that has been generated correctly. And because of that property we mentioned before of not being able to pre image the signatures, it's both random and verifiable, which seems counterintuitive at first. So dipping into some more of the public randomness world for people who've built on Ethereum before, they may be familiar with Randao.
00:05:57.148 - 00:06:22.724, Speaker B: Randao is a dao on a smart contract on the Ethereum network, where users commit to providing some bit of entropy to smart contract and at a later point reveal that entropy. And those bits of randomness are aggregated together into a final random number. How Dran differentiates from this is firstly, it's unbiaseable.
00:06:22.724 - 00:06:55.732, Speaker B: So you can imagine someone who has a lot of power on Ethereum network, like, let's say a coinbase, can actually take up many slots in this Randout contract and they can choose to reveal or not reveal their little bit of that randomness based on the prior output. So if you manage to get some number of slots at the end of any Randall epoch, you can influence the final result. Also, a cool thing about DRAM being based on a signature scheme is that it's not just web three only.
00:06:55.732 - 00:07:05.924, Speaker B: There's not a DRAM blockchain per se. It's not just on one blockchain. In fact, you can get Dran beacons from any CDN, you can even get them from an adversary.
00:07:05.924 - 00:07:33.120, Speaker B: And because they're Verifiable, you can know that the dran network has generated that random number. A final project which is very commonly used at the moment in blockchain ecosystems is Chainlink VRF. Chainlink VRF allows you to request random numbers and they create some proofs and write them somewhere before you use them to show that the randomness has been generated fairly.
00:07:33.120 - 00:07:58.440, Speaker B: Firstly, like Randao, like the difference with Randow chainlink is primarily for on chain applications but also the trust model is very different. You're contacting one party chainlink to run that function to output this random number. Whereas Drand we have a network of participants and you must trust that there's never a threshold number of malicious parties in the network.
00:07:58.440 - 00:08:13.340, Speaker B: So the model is just a little bit different. So a little bit about the networking. We currently run two networks in production, the default network and the fastnet network.
00:08:13.340 - 00:08:39.510, Speaker B: The core differences between them are that the default network emits randomness every 30 seconds, whereas the fastnet network releases randomness every 3 seconds. They have different URLs for interacting with them naturally and also they run in slightly different modes. So in the default network running in chained mode, each beacon contains a reference to the randomness from the beacon before it.
00:08:39.510 - 00:09:12.880, Speaker B: This means that they form a bit of a merkel dag and one drawback of that is that we can't do time lock encryption which I'll come to later using this chained mode, the Fasa network. By contrast, each beacon stands alone, it's not linked to the previous beacon through this chain of signatures. And that means that we can predict all the future messages, although not the signatures for beacons that are going to come out in fastnet.
00:09:12.880 - 00:09:32.460, Speaker B: That's a secret sauce for tambo encryption which we'll come back to in a bit. Also a math nerd extra for any math nerds in Fastnet we swap the G one G two groups in BLS in order to have smaller signatures and bigger public keys. Because at foundation of the network we create one public key and that every epoch.
00:09:32.460 - 00:09:50.030, Speaker B: We create a signature, which obviously is the randomness. So it means you can save gas costs if you're using in the blockchain. So if you were to go into your terminal now and request some randomness from the Drand API, you would come up with something a bit like this.
00:09:50.030 - 00:10:12.710, Speaker B: The top entry here is the round number. So that is an epoch, that's a monotonically increasing number every time the network emits a piece of randomness is at a new round. It also maps the specific time on the clock so you can predictably know when a specific round is going to become available.
00:10:12.710 - 00:10:30.804, Speaker B: The next key in it is the randomist itself, which is a sha two five six digest of the signature. Third field the signature is predictably the signature. It's a group signature for the entire network.
00:10:30.804 - 00:10:55.004, Speaker B: So again, it's the key pair that was done created during the distributed key generation process and it's BLS twelve for chain networks. There's also previous signature, which, like I said, links to all those previous beacons. So the easiest ways to get to your rand are to use the client libraries.
00:10:55.004 - 00:10:59.152, Speaker B: We provided one in Go and one in TypeScript. Those are the official ones. Of course.
00:10:59.152 - 00:11:15.320, Speaker B: You can get it through any CDN, through any HTP client you wish. But these also bundle in verifications of signatures as well, just so you don't have to do it yourself. Also, everyone in our community seems to be a rustician, so there are a whole bunch of different Rust clients for those of you who like writing things in Rust.
00:11:15.320 - 00:11:32.504, Speaker B: And also actually this one, the top 1D is also a CLI that can do time lock encryption and lots of other cool operations. So you should check it out because it's awesome. I've got a slide that says demo time now, which is slightly a lie.
00:11:32.504 - 00:11:48.380, Speaker B: It's more a bit of a code walkthrough than a demo. Let me kill my presentation momentarily. I'm just going to go into the integration tests of the drank client for JavaScript.
00:11:48.380 - 00:12:03.700, Speaker B: I think it's an easiest way to understand exactly what's going on and at least you can find it later in case you don't really remember what happened in that presentation. So we've got an integration test here. Essentially you create some plumbing.
00:12:03.700 - 00:12:17.064, Speaker B: We're fetching the public key of the network, which you can also do out of band. There are some other objects that allow you to not have to make requests for that. We provide three main functions.
00:12:17.064 - 00:12:41.556, Speaker B: Firstly, you can fetch a beacon by the time you can just pass in a classic JavaScript date, and the mapping between wall time and Drand epoch will be figured out magically for you. If you happen to know the epoch that you want to use, you can also pass that in and fetch a beacon just by its round number. Finally, we provide a watch function.
00:12:41.556 - 00:13:12.350, Speaker B: So if you're, for instance, building a game that needs to consume Dran randomness in a timely fashion at every single epoch, you can get an Async generator here that will call some callback whenever you receive the randomness. These are also more or less available in the same format in the Go library. So I shan't go into the Go library, but any questions on that obviously hit me up.
00:13:12.350 - 00:13:27.132, Speaker B: Okay, so that was how to use Drand and a little primer and how it works. Let's now look into time lock encryption. It kind of does exactly what it says in the tin.
00:13:27.132 - 00:13:46.890, Speaker B: It's encrypting something noisy that can't be decrypted until some future time has passed. The crux is that the Dran network is a bit like a reference clock. It ticks for every epoch and emits that piece of randomness so we can rely on it to map clock time.
00:13:46.890 - 00:14:12.450, Speaker B: Also side note, my colleague has presented the tenoc encryption scheme at Real World Crypto. So if you want to give a longer form explanation of how it works and all the gory details, you should definitely go watch the talk of an advanced encryption in real world crypto. So, diving a little bit deeper, how does time lock encryption work? Well, it's simple.
00:14:12.450 - 00:14:27.460, Speaker B: Fancy math, I guess, is a short term for those of you whose eyes have just glazed over after going through school and seeing discussing things like this. We're not going to dive into this, don't worry. I've simplified it just a little bit further.
00:14:27.460 - 00:14:48.780, Speaker B: So I said in one of the first slides that BLS Twelve supports pairing operation. This is essentially exploding some mathematical properties of the equation, as it were, in such that you can move different things around without changing it. So time encryption works a little bit like traditional asymmetric encryption.
00:14:48.780 - 00:15:19.030, Speaker B: In traditional Asymmetric encryption, you've got some public key that you use to encrypt a plain text and the output of some ciphertext. And if you take the ciphertext and some secret key that has a relationship to the public key, you can combine them and decrypt the ciphertext and come out with a plain text. What time lock encryption does is basically turns the round number into a public key and the signature that gets emitted from that round number into a secret key.
00:15:19.030 - 00:15:49.090, Speaker B: So, like I said before, in unchained mode, because each beacon is not linked to the beacon before it, we can predict the exact message and exact bytes that will be signed over by the network at some point in the future. That means we know that message now. We can use that as a public key to encrypt something, and we won't be able to decrypt it until the Dran network emits that piece of randomness in the form of a signature at a later point in time.
00:15:49.090 - 00:16:12.470, Speaker B: We've built some libraries around it, but also a cool web demo, which you're welcome to try now. It's called timevault. It is a web application for encrypting vulnerability reports, so that when you find all those Adobe flaws, even if they take you out with an assassin, the world can still know what you find.
00:16:12.470 - 00:16:23.128, Speaker B: It's built using tlock JS. Obviously, it's backed by the Dran network. I'm not going to demo it now, but you can obviously open it in your browser and give it a fiddle for yourself.
00:16:23.128 - 00:16:35.630, Speaker B: All the code's open source, it's all in GitHub. And there's also a paper and eprint if you want to know how it works. Before we do the Q-A-I will give the same.
00:16:35.630 - 00:16:46.160, Speaker B: Not quite a demo of t JS. Again, we've got some integration tests in there. I think those kind of give the clearest picture of how to use this in practice.
00:16:46.160 - 00:16:57.910, Speaker B: But essentially we bundle some main net and testnet clients in here. There's a function called timelock encrypt. You pass a round number that you wish to encrypt to in there.
00:16:57.910 - 00:17:22.860, Speaker B: There's some tooling as well around mapping that round number to a wall clock and back and forth. And then there's a time octocrypt function which takes also a client and takes your ciphertext. It supports an Asymmetric encryption under the hook called Agay, actually good encryption which works and looks a little bit like PGP.
00:17:22.860 - 00:17:43.590, Speaker B: If you've already filled with timevault, you'll see that the output of a ciphertext here is this cool AG encrypted file, which again looks a bit like a PGP ciphertext. So yeah, I implore you to get involved, check it out and try out all the libraries. Luckily I've left plenty of time for Q A.
00:17:43.590 - 00:18:03.310, Speaker B: So if anyone has any questions about Drand or time lock encryption, I'm all ears. I see there are some in the chat. Here is links to the generated random numbers set.
00:18:03.310 - 00:18:14.160, Speaker B: Yes, indeed. It is a shall two five six digest, so it's got a fixed length. Hypothetically, you could do your own hash key derivation function on top of the signature as well.
00:18:14.160 - 00:18:33.338, Speaker B: There is in fact somebody raised a PR, somebody from the community raised PR to do that on the DRAM repo. So there's some prior art there if you want to go and check out how they've done it or come up with your own derivation function. Tony, is it going to be available on chain? That depends which chain you're using.
00:18:33.338 - 00:19:10.914, Speaker B: It is available in the Cosmos ecosystem already through the noise network that's nois. Also, Dran Randomness is included in every block header of the FalcoIn network, so you can currently access it through the pre randow opcode. If you're building an FVM actor, for instance, it's not currently available out of the box on Ethereum, although, as I said before, there's a project called Rngsis with a G and not a J that have built all the relevant bindings to deal on Ethereum if you'd like to do so yourself.
00:19:10.914 - 00:19:38.990, Speaker B: Unfortunately, BLS operations are a little bit expensive as currently there aren't pre compiles on EVM for that, but there is an EIP up for them. So you should go and if you want them, go and hassle Ethereum people to get it merged. Max Ken asks do you have a link to the PR for the transformation function to decrease the length? I can find one for you very quickly.
00:19:38.990 - 00:19:48.190, Speaker B: Yes, here's some useful links. You can find it somewhere here in the pull request and pull it out for you. HKDF.
00:19:48.190 - 00:19:51.970, Speaker B: Yes. Here it is from Mr. Gorman.
00:19:51.970 - 00:20:18.314, Speaker B: Although there also is some prior art in terms of if you for instance wanted to pick from one of ten items. There's a cool project called De Randomizer with an S, the glorious British spelling and not the American spelling, which provides some tooling around doing that in the correct way to avoid modular bias and stuff. So worth checking that out.
00:20:18.314 - 00:20:33.642, Speaker B: I haven't linked it here, but again, you can find all manner of projects under the Drand organization on GitHub. Surab asks Where can we find some use cases. I joined it late, I'm not sure it's been discussed.
00:20:33.642 - 00:20:41.806, Speaker B: Well, that's up to you. In the hackathon, of course. Some existing use cases we have seen, we've got some people building games on top of Dran.
00:20:41.806 - 00:21:20.190, Speaker B: So for instance, for either randomizing item drops or defining the variables of certain NFTs for certain items and games, that's been one example. We're also working with a not for profit called Social Income who are providing universal basic income in Sierra Leone and they're working to use Dran to randomly select the people who should receive that universal basic income. We also developed a sample FM map called Draffle, which is basically a bit of a raffle lottery type app for drawing winners from a smart contract.
00:21:20.190 - 00:21:42.260, Speaker B: Some other possible use cases time lock encryption, a very cool one, which might be hard work in a hackathon, but mev prevention, minor extractable value. You could for instance, time lock encrypt the mem pool of a blockchain. You could stop miners from either reordering or not mining transactions based on gains they think they might get from them.
00:21:42.260 - 00:22:07.760, Speaker B: Other use cases generally drawing anything, anything needs to be fair lottery wise or in the time lock world, things like wallet recovery, automated deadman switches, auction applications. I'm sure there are plenty more that you guys can think of that I haven't thought of, and I hope that's the case. I'm excited to see what people build.
00:22:07.760 - 00:22:20.434, Speaker B: How can we get your slides? That is a great question. I will make them available through the hackfs people. I'm not sure if there's a centralized channel for that.
00:22:20.434 - 00:22:35.478, Speaker B: I can also stick them on IPFS after this and post the Sid somewhere for people to retrieve them. Yes, obviously if you have any further questions, you can ping us on Twitter. We're also on Bluesguigs, we're hipping with it.
00:22:35.478 - 00:22:46.780, Speaker B: And there's a link to our Slack workspace here as well. Lots of people talking about different use cases and cool things that they're building in there. So feel free to get stuck in.
00:22:46.780 - 00:22:48.934, Speaker B: Hey Patrick.
00:22:48.982 - 00:22:53.946, Speaker A: Yeah. For the slides, if you want to post them in the Discord channel, that might be another option as well.
00:22:54.128 - 00:23:00.240, Speaker B: That's the best idea actually. Yeah, I will do that immediately after this talk. Awesome.
00:23:00.240 - 00:23:22.520, Speaker B: Have we any final questions from the chat? Well, if that's the case, thank you very much everyone. Thank you for listening. I hope to see lots of cool applications built on Drand and any questions, find me, ping me, tag me and hopefully I'll be able to answer them.
00:23:25.770 - 00:23:27.160, Speaker A: There was last question.
00:23:27.850 - 00:23:52.590, Speaker B: Can you iterate on future file encryption? Well, one cool iteration on time off encryption that we would love to have is some kind of proof system on top of it. Right now there's no way to link if I say I'm encrypting something now to prove that what's in there is actually what's been encrypted. That's quite a research project and would be a lot of work for a hackathon, but if somebody does it, that could well be worth a prize.
00:23:52.590 - 00:24:00.750, Speaker B: But anyway, thank you very much and happy hacking. Cheers.
00:24:00.830 - 00:24:08.420, Speaker A: Thank you, Patrick, and thanks for everybody for attending. Good luck with the rest of the week hacking and we'll see you for the next workshop in a little while.
00:24:08.870 - 00:24:09.710, Speaker B: Cheers. Bye.
