00:00:06.870 - 00:00:23.900, Speaker A: Hi and welcome everyone. This is the Decentralized Access Control with Medusa workshop and we have Jonathan with us today who is going to take us through everything. So I'll hand it over to you and feel free to kick things off.
00:00:25.150 - 00:00:25.862, Speaker B: All righty.
00:00:25.926 - 00:00:40.600, Speaker C: Hi everybody. Thanks for joining us today to talk about Medusa and how you can use Medusa in your applications to manage access to data in a decentralized way. Let me just share my screen.
00:00:44.890 - 00:00:48.920, Speaker B: Okay, great.
00:00:50.250 - 00:00:58.780, Speaker C: And not that slideshow. All right? Can you all see that? Just want to confirm before I continue.
00:00:59.710 - 00:01:00.890, Speaker A: Yeah, perfect.
00:01:00.960 - 00:01:16.110, Speaker C: Okay, great. So today we're going to be talking about Medusa. Medusa is a project by Protocol Labs, specifically by the Cryptonet team, which is a research lab within Protocol Labs.
00:01:16.110 - 00:01:29.410, Speaker C: I sent a link to the slides in the chat and so there's also a link on this front page. If you want to talk to us in our discord, you can find us there. Of course, I'm also in the global sort of the hackathon discord so you can find me.
00:01:29.410 - 00:01:41.986, Speaker C: It's at Easter. I'm a software engineer on this team working on Medusa. I also have a teammate, Nicola, and he's sort of a research engineer.
00:01:41.986 - 00:01:45.218, Speaker C: And so together we build Medusa.
00:01:45.394 - 00:01:45.830, Speaker B: Great.
00:01:45.900 - 00:01:54.458, Speaker C: So the sort of outline for the talk today, I'm going to quickly just go through some slides. So I'll give you the high level sort of elevator pitch for Medusa, kind.
00:01:54.464 - 00:01:55.980, Speaker B: Of how it works.
00:01:56.750 - 00:02:12.658, Speaker C: And then we'll talk about an application that I've built with Medusa that's called Only Files to give you sort of an example of what you might build, again give you a little bit more insight into how Medusa works. And then we'll play with a demo. We'll sort of go to the site and kind of interact with it.
00:02:12.658 - 00:02:33.000, Speaker C: And then after that's done, we'll review some documentation, just some key things like smart contract addresses and that sort of stuff. We'll look at the SDK and probably also what we'll do is we'll just jump into the code for this Only Files kind of demo application. And that would give you the best idea of what's sort of required to integrate Medusa into your application.
00:02:33.000 - 00:02:51.786, Speaker C: Right. And then I also have QA here, but I think just sort of as I'm presenting, if things come up, you have questions, just sort of send them through and I will answer them as I see them. Okay, so the elevator pitch.
00:02:51.786 - 00:03:02.706, Speaker C: So I'll give kind of two different ways to think about Medusa. One way is that it gives you programmatic access control on chain. So there's a lot to dissect there.
00:03:02.706 - 00:03:23.590, Speaker C: So let's just break it down by each term. So access control, what is that? So access control in a simple way is that you can control who sees some sort of content or data. There is an additional element to that, which is that you can control who updates data, but that's sort of out of the scope for now, for this presentation, we don't support that with Medusa yet.
00:03:23.590 - 00:03:47.280, Speaker C: So it's more about who can sort of access encrypted data, who can decrypt it and see it, and then programmatic. Meaning I can write these rules of who can see this data with code and on chain. Meaning I write the rules in smart contracts using on chain conditions or really using things that can be verified on chain in order to give access to data.
00:03:47.280 - 00:04:26.182, Speaker C: And then another way to think about it kind of more broadly is that Medusa is sort of a network that allows a smart contract to have a private key because without something like Medusa, at least on a public blockchain, you can't have a smart contract use a private key because everything is public, right? The storage of the contract is public, metadata, transactions, et cetera. So you need something else to make this happen. And of course, if you have a private key, you can do things like encryption and decryption and you can also do signatures.
00:04:26.182 - 00:04:57.958, Speaker C: But for purpose of our talk, we're going to be talking about encryption and decryption and how that you can use that to sort of give access to. So and then the sort of different components that go into a Medusa enabled application is sort of threefold you have on the left you have like your application and your application might consist of a smart contract and some sort of front end mobile app, web app, something like that. And so we have a few different examples here.
00:04:57.958 - 00:05:23.710, Speaker C: The first one is this only files example that we'll go into. But you can think of only files as an application that implements like a simple policy, which is I upload some content so that could be text, it could be images, it could be audio, video, any sort of media or any sort of file really. I upload that, I sort of give a description, I give a price and then I list it for sale.
00:05:23.710 - 00:05:39.794, Speaker C: When I list it for sale, I set a policy. And the policy is that whoever pays the price that I set gets access to the file. That's kind of the simplest access policy that I can think of is just you pay for it, you get it.
00:05:39.794 - 00:06:08.586, Speaker C: But you could do other things like you could have anything sort of content attached to NFTs, so maybe like holders of particular NFT get access to a private mailing list or any other sort of unlockable content. You could do a decentralized document sharing platform. So something like Google Drive where maybe your policy is like anyone with an email address that ends in a certain domain, so ends in your company's domain.
00:06:08.586 - 00:06:38.870, Speaker C: So for Protocol Labs, like anyone who has the email that ends with at protocol AI, and that's something that's a bit more challenging to implement, I think if you wanted to prove that you own an email address, maybe you could have some sort of ZK proof scheme and you could verify that on chain. That's a bit outside the scope but I think you get the idea there's many different applications that you could implement with Medusa. And so in the middle your smart contract is going to interact with sort of the Medusa contract on one of any number of chains.
00:06:38.870 - 00:06:56.394, Speaker C: And really you can think of the Medusa contract as it does a couple of things. It does some sort of interesting, it uses a bit of cryptography to sort of prevent replay attacks and maybe I'll get into that later. But really at its core the Medusa contract is sort of like an inbox and outbox.
00:06:56.394 - 00:07:25.480, Speaker C: It's basically just a way for you to submit requests to Medusa and receive responses. And then on the right you have the Medusa network. And so the Medusa network is essentially a set of many different nodes and those nodes all hold shares of a private key and essentially they run a protocol that says that they receive requests to re encrypt some data.
00:07:25.480 - 00:07:51.742, Speaker C: And so reencrypt meaning taking some data that's encrypted that Medusa is encrypted for Medusa or towards Medusa's private key, medusa can sort of change the audience to someone else. So Alice can kind of say to Medusa, hey Medusa, I want Bob to see this file that I've sort of registered with you. And Medusa can perform an operation to keep that file encrypted but now only Bob can decrypt it.
00:07:51.742 - 00:08:22.382, Speaker C: And so this is sort of like a threshold encryption protocol that Medusa runs. And the other part there is that the sort of threshold part is that you need a threshold or a majority of nodes to sort of see the request, validate it and perform the operation before then submitting a response back on chain. So that was kind of a lot and if it's a bit fuzzy right now, don't worry because I think we're going to go over it a few more times in the slides or in the docs and the SDK, et cetera.
00:08:22.382 - 00:08:25.340, Speaker C: But that's sort of at a high level how things would work.
00:08:28.590 - 00:08:30.890, Speaker B: Just going to check.
00:08:30.960 - 00:08:45.040, Speaker C: Okay, only files. So going a bit more in detail into this. So only files essentially a site for a bunch of sort of secret content that people can pay to unlock or to download it.
00:08:45.040 - 00:09:08.390, Speaker C: Like I said earlier, the policy is that whoever uploads some content can set a price and whoever wants to download that content can pay that price and then they can do that. And the tools for this particular demo are I guess threefold. So one, we have filecoin mainly just to store our encrypted files.
00:09:08.390 - 00:09:29.310, Speaker C: We have a blockchain and so we could use the FBM and Medusa is deployed on the hyperspace testnet so you could use that. We also have it deployed on Arbitrum Gorli. But essentially you need a blockchain to write your policy in a smart contract in solidity for now, but maybe in the future for other platforms.
00:09:29.310 - 00:09:51.054, Speaker C: And you need to set the rules and you also need a medium to collect payment, right? And then the last piece is Medusa, which sort of handles re encrypting or unlocking content based on payment being received. Right. So now we're going to go through this is going to be kind of like a flow diagram.
00:09:51.054 - 00:10:06.886, Speaker C: We're going to basically just go through the flow of how a request and response cycle works for this only files application. So we start with Alice, who has this top secret document. And Alice wants to list this document for sale.
00:10:06.886 - 00:10:27.054, Speaker C: So the first thing that she'll do is locally on her computer using this only policy application, she's going to encrypt her secret document. And so the output of that encryption will be two things. She'll get her encrypted file and she'll also get the key that encrypted the file and that could also decrypt it.
00:10:27.054 - 00:10:37.550, Speaker C: So like a symmetric encryption key. And so the encrypted file, we're going to set it aside for the moment, but essentially she'll encrypt the file. She'll get the key in the file.
00:10:37.550 - 00:10:53.758, Speaker C: She'll take the file and store it somewhere. So on filecoin or IPFS in other places. And then for now, for this diagonal, we're going to forget about the file because actually, Medusa, instead of operating over the file, it's going to operate over the key to unlock that file.
00:10:53.758 - 00:11:10.762, Speaker C: And it's kind of a subtle difference. But the importance there, why we do it this way, is really to save money on gas, right? Because otherwise we'd be emitting events or maybe even using storage on a blockchain. And if we have this variable length file, that could get really expensive.
00:11:10.762 - 00:11:47.350, Speaker C: But if we operate over the key, then we just have sort of a 32 byte constant piece of data to pass through a blockchain. Right? But the kind of key ID, the idea there is that as long as someone has the key to unlock something, then it's almost the same as if they sort of had that file itself. But anyways, I just thought it's important to point out because this diagram may get a bit confusing just with all the keys and all the different terms, but just keep that in mind that Medusa operates over an encryption key to an encrypted file.
00:11:47.350 - 00:12:06.270, Speaker C: So the next step is that we're going to take that key, which isn't encrypted itself, but we're going to actually encrypt it. So we're going to take the key and we're going to encrypt it towards Medusa. So at this point, only a threshold of nodes coming together could actually view the key and in fact, they won't.
00:12:06.270 - 00:12:10.098, Speaker C: But that's sort of the only way that you can lock this key at.
00:12:10.104 - 00:12:10.660, Speaker B: The.
00:12:12.470 - 00:12:34.780, Speaker C: And the next step. So Alice has done all this locally on her computer and then she's going to submit this encrypted key to the only files application and only files is basically going know in a transaction. And then the sort of onlyfiles smart contract will call out to the Medusa contract and basically say, like, hey, this is a new piece of encrypted sort of content.
00:12:34.780 - 00:12:55.482, Speaker C: This is basically a registration step. So now the network is sort of aware of this content and then sort of separately in another transaction flow in another time, another place, another individual. Bob is going to go on the onlyfile site and he's going to know Alice's sort of content that she's advertised.
00:12:55.482 - 00:13:06.226, Speaker C: He's not going to be able to see the content, but whatever Alice, what description or other information she wanted to provide will be there. And Bob's going to decide, okay, yeah, this seems valuable. I want to pay for this.
00:13:06.226 - 00:13:15.910, Speaker C: I want to unlock it. So Bob's going to see the price on the website and he's basically going to click a button to send a transaction to know, here's one ETH. I want to unlock this file.
00:13:15.910 - 00:13:33.114, Speaker C: And so basically in the only Files contract, or really in the application contract, you would verify sort of the policy you would check, okay, Bob is trying to buy Alice's document. What is the price for Alice's document? It's one ETH. And did Bob pay one ETH? Yes, he did.
00:13:33.114 - 00:13:52.850, Speaker C: Okay, that's a valid request. And so it'll then forward that request to the Medusa contract, which will emit an event, and the Medusa nodes will sort of listen for these events to know, to sort of start a new operation, a new re encryption sort of operation.
00:13:55.670 - 00:13:56.082, Speaker B: Right?
00:13:56.136 - 00:14:29.934, Speaker C: And so then the Medusa nodes are going to, you know, they're all going to basically receive this event at some point, and they're going to sort of start this reencryption protocol. And as soon as a majority of the nodes have sort of they've also done some validations on that request and they've decided to run it, they're going to gossip between one another to send their partial result. And as soon as one of them basically receives enough partial results of this re encryption, they will be able to aggregate that into a sort of a fully re encrypted key that only Bob can read.
00:14:29.934 - 00:14:51.506, Speaker C: And one of them will send this key in a transaction back on Know. They'll send that to the Medusa contract, which will then do a bit of a lookup and see, basically find the address for your contract and call back to it and basically say, hey, here's the know. You do what you want to do with it.
00:14:51.506 - 00:15:11.578, Speaker C: And in this case, what we're going to do is our application contract will emit an event so that our front end can sort of read that event. And so Bob can receive the encrypted key on his computer or device. And then now Bob can decrypt the encryption key.
00:15:11.578 - 00:15:30.218, Speaker C: So now he'll get the key in plain text, which he can then use to download Alice's encrypted file and decrypt that. And so now through this, this whole big flow, bob finally paid for this file and he got it back and he downloaded. So again, that was kind of a lot there's kind of a lot of terms, a lot of different keys.
00:15:30.218 - 00:15:43.000, Speaker C: If it's a bit confusing, don't worry. You don't necessarily need to know all this to build with Medusa. And for sure you'll sort of see other examples through code or through reading that might make it a bit more clear.
00:15:43.000 - 00:16:11.818, Speaker C: And then quickly, I won't spend too much time on this, but I just thought I'd include these slides just for extra information. Just give some details about some implementation details of Medusa and some links to our smart contracts and also our also, you know, this more information just on the status of the project. We're sort of in a Buildernet phase, right? So we've deployed on Hyperspace, we've deployed on Arbitrage.
00:16:11.818 - 00:16:25.860, Speaker C: Gorli. We're looking for users to give us feedback to build applications with Medusa. And this is sort of our timeline for what we're doing next when we'll go to Mainnet and kind of what the future of Medusa might look.
00:16:27.750 - 00:16:28.500, Speaker B: Great.
00:16:28.950 - 00:16:52.346, Speaker C: So now I'm going to switch over to actually we'll go to the demo. So this only files thing I've been talking about, let's kind of see it. So we'll go here and right so, you know, not the prettiest front end site, but mainly here to exercise Medusa, just show you what it can do.
00:16:52.346 - 00:17:06.366, Speaker C: So at the moment I'm actually on the sort of Arbitrum network by default. And the reason for this demo why is because there's faster block times on Arbitrum. And so whereas Hyperspace is like a 32nd block time.
00:17:06.366 - 00:17:17.822, Speaker C: So that would kind of take us a while to get through this. So I'm just going to do it here. But if you want to use it, this application on Arbitrum, you can sort of enter this parameter or sorry, on Hyperspace you can enter this parameter.
00:17:17.822 - 00:17:19.540, Speaker C: It'll switch networks for you.
00:17:20.630 - 00:17:20.994, Speaker B: Great.
00:17:21.032 - 00:17:29.080, Speaker C: But I'm not going to do that now. So let's go through here. So basically what we have here is we have a form.
00:17:29.080 - 00:17:40.890, Speaker C: This form is like to upload a file. Let's do it. So we'll upload this picture from Stable Diffusion, which is like an astronaut on a horse, right? So we've uploaded it.
00:17:40.890 - 00:17:48.254, Speaker C: We're going to set a price or sorry, we haven't really uploaded anywhere. We've just sort of loaded it under the page. We're going to set a price.
00:17:48.254 - 00:17:56.490, Speaker C: I'm going to put one e. I'm going to set a description.
00:17:56.650 - 00:18:02.910, Speaker B: This is a pick of an astronaut horse.
00:18:03.490 - 00:18:13.858, Speaker C: Want to advertise correctly there. Actually, I missed the step and maybe let me just go back briefly. So I've come my wallet's already connected to the site.
00:18:13.858 - 00:18:29.834, Speaker C: Normally you'd have to just connect your wallet and sort of the next step is you want to sign in and what signing in with Medusa. What it really means is you're basically just going to sign a message. And from that signature, we can sort of deterministically derive a key pair for you.
00:18:29.834 - 00:18:44.046, Speaker C: And so if you don't really know what that means, don't worry, you don't really have to. But if you do, the reason why we do it this way, I mean, you probably see it in other places as well. But if we do it this way, this means that we don't have to store any extra keys for a user over time.
00:18:44.046 - 00:19:03.480, Speaker C: Basically, as long as someone has a seed phrase to some sort of private key and they have sort of like a web three wallet, like MetaMask or something else, then they can just sign a message and we can always reconstruct their medusa key. So it's nice. And I guess we don't add any extra state, nothing to sort of keep around.
00:19:04.330 - 00:19:04.886, Speaker B: Right.
00:19:04.988 - 00:19:16.902, Speaker C: So we've signed in. Now we can hit this button to sell the secret and what it's okay, that's interesting. Always live demos, something new.
00:19:16.902 - 00:19:22.954, Speaker C: Okay, so we'll add you know what, I'm going to make this just want to make sure I have enough ETH here. I do. Okay.
00:19:22.954 - 00:19:27.914, Speaker C: So I'm going to make that one E. Or actually just for anyone else, I'll make it zero. That's going to make it free.
00:19:27.914 - 00:19:32.366, Speaker C: I said you just have to pay a gas fee to do it. So it'll be free. We're going to sell it.
00:19:32.366 - 00:19:46.894, Speaker C: So first it's just encrypted it. It's going to upload that encrypted file to IPFS and then it's going to ask me to once that's done, we're going to send a transaction to Medusa to sort of register this new ciphertext.
00:19:46.942 - 00:19:47.940, Speaker B: As we call it.
00:19:48.630 - 00:19:55.558, Speaker C: But really this new file great. So that's done. And so now we should be able to see this is my unlocked content, but down here.
00:19:55.558 - 00:20:02.066, Speaker C: Okay, great. This is what we just uploaded. And then there's a button here to view an IPFS.
00:20:02.066 - 00:20:12.038, Speaker C: But this is encrypted at the moment. We can't decrypt it yet. So if we click that, we're going to have a link to something that can't render because it's just sort of encrypted garbage.
00:20:12.134 - 00:20:12.778, Speaker B: Right.
00:20:12.944 - 00:20:30.506, Speaker C: But now let's unlock it and unlocking what we're doing. If you remember that other diagram, we're sending a re encryption request and basically we're going to send the ETH, which in this case it's free, so we don't have to actually send anything. This will be a valid request.
00:20:30.506 - 00:20:46.182, Speaker C: And now we should be able to scroll up and see it here. Does it want to download? Did I have some other error? There it is. Okay, so that delay there, it's basically downloading the file, decrypting it, and then it's displayed it here.
00:20:46.182 - 00:20:55.126, Speaker C: So that's sort of the flow. Again, it's kind of a simple rudimentary demo, but it shows you sort of what's possible. Great.
00:20:55.228 - 00:20:57.062, Speaker B: So that's that.
00:20:57.116 - 00:21:08.910, Speaker C: And let me just make sure. Okay, so now I'm going to go over to this documentation site. So this is Docs medusanet XYZ.
00:21:08.910 - 00:21:15.040, Speaker C: Let me just throw that in the chat for any of you want to kind of follow along and look at this later.
00:21:19.490 - 00:21:23.658, Speaker B: Great. So from here I'm not going to.
00:21:23.764 - 00:21:32.322, Speaker C: Go through the entire documentation end to end. I think a lot of what I said will probably be repeated here, but I'll just go over some of the important tidbits. I guess first there's this about Page.
00:21:32.322 - 00:21:39.400, Speaker C: This gives, again, kind of more of a higher level and it also goes a bit deeper into the cryptography behind Medusa. If you're interested.
00:21:39.930 - 00:21:40.918, Speaker B: This will give you kind of a.
00:21:40.924 - 00:21:56.006, Speaker C: Fuller picture if you really want to know exactly how everything works. But if you just sort of want to kind of hack something together, then you come here to this kind of developers tab. And so the first thing that's important to know are sort of the, I guess parameters for interacting with Medusa.
00:21:56.006 - 00:22:20.746, Speaker C: So you have Arbitram, you have Filecoin and the respective testnets know and you have some links if you want to see it on a block Explorer, you have that. But really what's important is this oracle address. This DKG address is not really that important for developing, but just for those who are interested to sort of create this shared key amongst different nodes.
00:22:20.746 - 00:22:36.866, Speaker C: We run a DKG, which is a distributed key generation process, and we do that on chain as well. So we use a smart contract as sort of a mediator for the DKG process. So, yeah, so you have arbitram.
00:22:36.866 - 00:22:56.202, Speaker C: Gorli, you have hyperspace. And then we'll look into some of the details of the contracts for Medusa. This isn't too important, but some of the data structures, I suppose that we use, we have this notion of a ciphertext and a re encrypted cipher.
00:22:56.202 - 00:23:08.450, Speaker C: So the ciphertext is sort of what gets registered initially. The re encrypted cipher is what is really the response of a successful reencryption request. It's what's created when something is unlocked by a user.
00:23:08.450 - 00:23:23.222, Speaker C: I'll mention this. Here we have this sort of a D LEC proof, or really a proof that we attached to ciphertext. And what that does is basically if we didn't have this, then you could replay another person.
00:23:23.222 - 00:23:52.414, Speaker C: If they wanted to unlock some content without paying for it or fulfilling the policy, they could replay the ciphertext and sort of register a different ciphertext that is the same data and basically claim that it's theirs and then they might be able to unlock it that way. But we attach a proof to it that basically says this ciphertext is tied to an address, the sort of original encryptor. Okay, here we have sort of an interface for the encryption Oracle.
00:23:52.414 - 00:24:20.182, Speaker C: And again, if you want to see more of this code, it's the links in the slides and I'll put it in the chat maybe in a second. But this is sort of the interface that you building an application, the methods that you would call on Medusa's encryption, Oracle contract. And really the two important things are submitting a ciphertext so that's basically registering a ciphertext with Medusa and then later requesting re encryption.
00:24:20.182 - 00:24:32.510, Speaker C: Those are really the two important methods that you would call. And when you're registering certext, you're going to give the cipher as well as the encryptor. I sort of mentioned that about the D like proof that sort of ties the ciphertext to an address.
00:24:32.510 - 00:24:54.520, Speaker C: And then when you're requesting re encryption, you're going to give an ID that is created when a ciphertext is registered, right? And then you're going to basically give the public key of Bob or of whoever you want to request re encryption for. So whoever is going to eventually unlock this data, you provide their public key.
00:24:56.250 - 00:24:56.662, Speaker B: Right.
00:24:56.716 - 00:25:19.850, Speaker C: And then in your client, in your smart contract that you would build the only method that you need to so you need to basically call at some point you would be calling these two methods and then you would implement a method which is called Oracle result. It's basically the callback that once Medusa has re encrypted some data, it's going to submit, it give you a response back. It's going to call this method.
00:25:19.850 - 00:25:41.300, Speaker C: Right? And so call this method and it'll give you the request ID that the callback is being made for and it will give you the result, this re encrypted cipher that your user can then use to unlock some content. Great. And then I think, yeah, we have an example contract here.
00:25:41.300 - 00:25:55.400, Speaker C: So this contract here is kind of a stripped down version of this only files contract, but it does something very similar. And so we're calling it debate, like a decentralized ebay here. And we'll sort of just go through.
00:25:55.400 - 00:26:07.134, Speaker C: Okay, so we'll just go through. Start with you have the address of the Medusa Oracle that you're going to call to. And so remember, I'll just go back here.
00:26:07.134 - 00:26:22.478, Speaker C: That would be one of these two, either this one for Arbitrum or this one for hyperspace. And then you need to keep some storage in your contract. If someone's creating a listing, you're going to keep some metadata about that listing.
00:26:22.478 - 00:26:34.440, Speaker C: So like the price, maybe a description. In this case we're just keeping the price. So we're keeping a mapping of a cipher ID, which is kind of like maps to one piece of content that someone could buy to the price for it.
00:26:34.440 - 00:26:52.278, Speaker C: And then you really have, like I said, you have three methods here, you have this submit entry. So this is like when someone's creating a new listing, they create it. And what we do is we call out to Medusa and we register this new ciphertext with Medusa.
00:26:52.278 - 00:27:15.422, Speaker C: And then we also store the price that the creator, the uploader of the content decided, right? So we store that for later so that when someone goes to buy it, we can look it up, look up the price and make sure that they pay the right amount. And so that's down here in this buy entry function, where like I just said, we look up the price. And this is actually a bit of a bug.
00:27:15.422 - 00:27:32.578, Speaker C: This listings should actually say item to price. But anyways, we look up sort of the price by the cipher ID. If the person who's buying it didn't pay enough, then we would revert and after we've sort of checked our so this method really is it's.
00:27:32.578 - 00:28:08.180, Speaker C: This is the example of implementing your access control policy and checking it, right? And so once you've checked it in your contract, you then call out to Medusa and Medusa handles sort of the re encryption of this data, right? And Medusa does do some additional checks, but really the only thing additional that it'll check is that the ciphertext that your contract is asking to re encrypt was originally submitted by your contract. That's sort of the only check that we make. And any other policy that you sort of want would be implemented by in your contract, in your application.
00:28:08.180 - 00:28:18.534, Speaker C: Great. So once we request to Medusa to re encrypt, we're going to get a request ID. And in this case, we're sort of returning these things.
00:28:18.534 - 00:29:07.830, Speaker C: But I think in an actual application, you'd want to admit an event so that your front end could sort of consume it and use it, right? So in this case, if someone is submitting an entry, we probably want to admit an event so that we can show it as a listing down here in our app, right? And then even here, if someone has paid for an entry and maybe they're waiting for a response to come back, you probably want to give them some feedback in your application. So you would do that through by emitting an event of probably the relevant ID and maybe any other metadata that you might have. And for sure we sort of do that here in this last method, which is this Oracle result, which we said we had to implement sort of from this interface.
00:29:07.830 - 00:29:21.206, Speaker C: So we do that, we do something very simple. We basically just we receive the response, which is the request ID that the response is for. And then this cipher.
00:29:21.206 - 00:29:30.800, Speaker C: And again, this is a bit of a bug. This type here should be the re encrypted ciphertext because this cipher represents the response. Right.
00:29:30.800 - 00:29:47.842, Speaker C: And this is also important as well. I don't know if we include the modifier, but of course to keep your contract secure, you really only want the Oracle to be able to call this method. So you should have some sort of modifier or some sort of check that only the Oracle can send us to.
00:29:47.896 - 00:29:48.500, Speaker B: Right?
00:29:48.950 - 00:29:58.120, Speaker C: And what we actually do in it is very simple. We just emit an event that our front end will consume and we basically say for Bob's request here's, the.
00:30:00.330 - 00:30:00.934, Speaker B: Great.
00:30:01.052 - 00:30:14.202, Speaker C: So let me just check. I think I've gone a bit longer than I thought I would, just going through that. So let me just answer there's a question here.
00:30:14.202 - 00:30:46.306, Speaker C: Can the files be re encrypted for a period of time? So you're sort of asking if at some point access could be removed in the future. It's something that comes up whether you can revoke access or like you said, for a period of time and then the access is gone. It's kind of a difficult question, or it's not a difficult question, but it's a difficult problem because you can imagine as soon as you give someone access to something, even in sort of a Web Two setting, they could always download that data and sort of have it forever.
00:30:46.306 - 00:31:02.170, Speaker C: Right? And it's kind of similar with Filecoin. You can encrypt something and you put it up on filecoin, but depending on what storage deal you've set up and everything, that file may be there for a long period of time. So once you give someone a key to unlock it, it's difficult to be able to revoke that key.
00:31:02.170 - 00:31:36.680, Speaker C: But we have been thinking of so I guess to answer your question, in the core Medusa protocol, no, that's not part of the protocol, but there may be some things that we can implement on top of Medusa to implement this, being able to revoke access or only have something access for a period of time. And that might include you might need to use some other tools like maybe like IPNs or some other way to deal with mutable content, or another way to introduce another layer of indirection so that you can kind of remove access later. But maybe we can talk about this more.
00:31:36.680 - 00:31:46.378, Speaker C: Like I said, you can find in the discord, so maybe we can chat more about that because it does come up. It comes up quite often. It would be really nice to have and we're thinking about ways that we.
00:31:46.384 - 00:31:47.420, Speaker B: Can make it work.
00:31:50.430 - 00:32:05.870, Speaker C: All right, I'm going to wrap this up because I think I'm over time at this point, I just want to see if there's anything if you want to see how to use the SDK, there's a couple of pages here. This encryption to Medusa. Decryption from Medusa.
00:32:05.870 - 00:32:32.438, Speaker C: There's also, like I said, the SDK is here and I'll put a link in the chat so you can also see it here. And there's a little bit of an example of how you would use sort of the different things. The sort of three key operations that you need to do are really just getting the user to sign to create a signature for you so you can drive a key pair for them.
00:32:32.438 - 00:32:52.810, Speaker C: And then you're going to basically encrypt you're going to call this encryption method, which gives you your encrypted data, your encrypted key. And then at some point, you need to save that encrypted data somewhere that's not in the SDK, but you can imagine. You save it in filecoin and you sort of have a Sid, a CID, and you keep track of that maybe in your contract as metadata.
00:32:52.810 - 00:33:12.306, Speaker C: And then the last operation is decrypt, right? So given later, someone's gotten a response, you can basically put in that ciphertext, the re encrypted ciphertext, the encrypted data, and then you'll get some plain text out. So that's kind of, in a nutshell, what you'll do. And so I guess the point to show you here is like the SDK, there's not that many lines of code that you actually need.
00:33:12.306 - 00:33:19.190, Speaker C: There's maybe like three to four. And then when you write your smart contract, I mean, we saw an example here. This was quite short.
00:33:19.190 - 00:33:44.730, Speaker C: You could have a more advanced or more complex policy, for sure, but ultimately, at least you can sort of write those rules in solidity, something that hopefully a lot of you are familiar with, rather know a different DSL or something along those lines. But anyways, if you have more questions or want to talk more, then we can chat in the so, yeah, thanks. Thanks, everyone, for listening.
00:33:46.350 - 00:34:04.782, Speaker A: Thanks so much, Jonathan, and that was great. And if anyone is looking to connect with him again, I will tag all of these links and you in discord and everyone will know where to ask more questions. Thank you so much for your time and appreciate everyone popping in for this workshop.
00:34:04.782 - 00:34:06.740, Speaker A: And have a great day.
00:34:08.070 - 00:34:09.838, Speaker C: All right, thanks, everybody. Bye.
