00:00:07.770 - 00:00:29.846, Speaker A: Hi, I'm Ravital, the founder of Sunscreen, and today you're going to hear all about how to build private DApps with Sunscreen. So specifically, we're going to be looking at what is fully homomorphic encryption, aka Fhe, and how does it fit into Web Three. We'll then talk a little bit about what Sunscreen actually does.
00:00:29.846 - 00:00:43.994, Speaker A: We'll go into two of our main products that are available for this hackathon. We have our fully homomorphic encryption compiler that makes Fhe easy for developers to use. We also have our private testnet parasol available.
00:00:43.994 - 00:01:08.158, Speaker A: And then we'll talk about how exactly you can get started using our Fhe compiler, our private testnet, and what prizes we have available for the hackathon. Before we dive into Fhe and how it fits into the Web Three space, let's talk a little bit about what Fhe is and how it works. So first, let's introduce the idea of a plain text and ciphertext.
00:01:08.158 - 00:01:24.642, Speaker A: A plain text is an unencrypted message or a message entirely in the clear, whereas a ciphertext is an encrypted message. You can think of fully homomorphic encryption as an extension of public key cryptography. So in a public key encryption scheme, we have three major algorithms.
00:01:24.642 - 00:01:39.980, Speaker A: We have keygen that allows us to generate both a public and private key. We have encryption that allows us to encrypt messages to somebody using their public key. And then we have Decryption, which allows us to decrypt messages we've received using our private key.
00:01:39.980 - 00:02:13.190, Speaker A: The public key is supposed to be shared with other parties. That way they can send you encrypted messages, whereas the private key is something you really want to keep secret because it's going to allow you to decrypt messages you've received. What does the homomorphic part mean in fully homomorphic encryption? It really refers to two special properties of the encryption scheme we have that encrypting A and encrypting B, and adding these two ciphertext together is the same as having added A and B as plain text and then encrypting that.
00:02:13.190 - 00:02:43.890, Speaker A: We also have that encrypting A and encrypting B and multiplying those two ciphertexts together is the same as having multiplied A and B as plain text and then encrypting that. Blockchains, like ethereum, are inherently transparent, meaning that all data is public and computations are performed publicly. One of the main questions we want to ask ourselves in this presentation is, can a blockchain keep a secret? And the answer is yes, especially with fully homomorphic encryption.
00:02:43.890 - 00:03:07.494, Speaker A: How does Fhe fit into the web three space? Well, you can think of Fhe as allowing for something called private computation. Here you can take some encrypted inputs, you can run a computation on your encrypted inputs, and you can get some encrypted outputs. The magical thing about Fhe is that anyone can perform this computation directly on the encrypted data.
00:03:07.494 - 00:03:29.120, Speaker A: There's no need for this party to know what the underlying data is. Something important to keep in mind when working with Fhe is that it's really focused on confidentiality. So hiding the inputs and outputs of a computation Fhe on its own does not provide anonymity, so we don't have anything about hiding user identity here.
00:03:29.120 - 00:03:55.990, Speaker A: Next, let's look at an example of how you might use Fhe to update encrypted account balances. Let's say Alice has an encrypted account balance and she's receiving some transaction with an encrypted amount. Her new account balance could be updated to be the sum of her previous encrypted account balance plus the encrypted transfer amount she's just received.
00:03:55.990 - 00:04:28.530, Speaker A: Something important to note is that for most real world use cases of Fhe, especially in the Web Three space, we really need zero knowledge proofs to work in conjunction with the technology. This is mainly for ensuring that user provided data satisfies certain application dependent conditions. So, for example, in that private transaction case, we would really want to make sure that Bob, who is sending Alice some encrypted amount, has enough money in his account to make this transaction.
00:04:28.530 - 00:05:07.530, Speaker A: For this hackathon, we're really going to be focused on Fhe, so there won't be much about zero knowledge proofs, but this is something important to keep in mind when you go from the hackathon into the real world. Now that we've covered how Fhe works, let's look at what exactly is possible with Fhe and what are some interesting applications that are enabled with this technology? Well, there are some interesting applications in both the Web Three and the Web Two space. In terms of what Fhe can enable in Web Three, fhe can allow for private user orders in decentralized exchanges.
00:05:07.530 - 00:05:24.100, Speaker A: It can also allow for private voting in decentralized autonomous organizations. In terms of what's possible in Web Two, fhe allows for private machine learning, so specifically private training and private inference. It also allows for analytics with full user control.
00:05:24.100 - 00:05:44.454, Speaker A: Now that we've gotten you excited about Fhe and its potential in both the Web Two and Web Three space, let's look at what Fhe is like from a developer's point of view. There are a few important things to keep in mind when you start working with Fhe. The first is that Fhe introduces both a time and space overhead.
00:05:44.454 - 00:06:10.500, Speaker A: So when you're working with Fhe, you can expect that computations are going to take longer when they're encrypted versus doing them in the clear. Additionally, when you encrypt data with an Fhe scheme, the data is now quite a bit larger than it was when it was in the clear. Additionally, you'll find that certain computations are quite a bit more difficult to do with Fhe than they were when you weren't working with any encryption technology at all.
00:06:10.500 - 00:06:33.014, Speaker A: What exactly is Fhe like to use if you're a developer right now? Unfortunately, it turns out that Fhe is actually quite difficult to use. You can really think about Fhe as developed by experts for other experts. When you're working with most Fhe libraries, you really have to think about how do you choose scheme parameters to ensure optimal performance.
00:06:33.014 - 00:06:51.082, Speaker A: You also have to worry about ensuring that a certain level of security is met when you choose these scheme parameters. You need to worry quite a bit about key and ciphertext sizes, because there can be a fairly large blowup if you're not careful choosing scheme parameters. And finally, you have to worry quite a bit about computational depth.
00:06:51.082 - 00:07:23.930, Speaker A: For example, how many sequential multiplications do you want to do on your encrypted data that might inform what scheme parameters you actually choose? With all of these challenges in using Fhe, how then can developers harness the power of Fhe to build private applications? Well, that's exactly why Sunscreen was started. At Sunscreen, we build privacy tools for developers. Our goal as a company is to make advanced privacy technology like fully homomorphic encryption easy for developers to use.
00:07:23.930 - 00:07:37.370, Speaker A: We really work at the intersection of both fully homomorphic encryption and zero knowledge proofs. But for this hackathon, we're going to be focused on Fhe. There will be two products available for this hackathon.
00:07:37.370 - 00:07:52.946, Speaker A: We'll have our Fhe compiler that makes Fhe easier for developers to work with. We'll also have our private testnet available, which you can think of as EVM, plus some limited Fhe pre compiles. We have some pretty exciting things in the works.
00:07:52.946 - 00:08:13.610, Speaker A: Specifically, we have our zero knowledge proof compiler, and we're also working on an implementation of a threshold Fhe scheme that would support private shared state. Unfortunately, neither our ZKP compiler nor our threshold Fhe implementation will be available for this hackathon. But stay tuned, you might find this at another hackathon.
00:08:14.110 - 00:08:29.418, Speaker B: Thank you, Robital. My name is Rick, and I'm going to be walking you through how to use Sunscreen today, which we'll be using to approach your off chain bounties. So what is sunscreen? Sunscreen is a library for performing computation using zero knowledge proofs and fully homo roph encryption.
00:08:29.418 - 00:08:44.418, Speaker B: But we're only going to be looking at the Fhe portion today. It consists of three parts. There's a language for expressing Fhe programs, a compiler for turning them into circuits, and a runtime for running said circuits and generating keys and encrypting data.
00:08:44.418 - 00:08:59.174, Speaker B: You can view the docs at docs sunscreen tech or pause your video and visit the QR code on the right. Let's dive right in and create an Fhe program. Here we have an Fhe program called Simple Multiply that returns the product of A and B.
00:08:59.174 - 00:09:14.970, Speaker B: Note that it's a standard rust function, except that it has an Fhe program macro on it that puts it in a form that our compiler can use. There are limitations as to what you can do in an Fhe program, and the full list is available in the documentation I've previously linked. A notable example is comparisons.
00:09:14.970 - 00:09:36.438, Speaker B: You can't perform comparisons in Fhe programs, so please don't attempt any bounties that require them. You'll note that A and B have the type cipher of signed, as does the return value cipher of t means that the value is encrypted and t means that it's not. Sunscreen allows you to perform computations on a mix of encrypted and unencrypted data.
00:09:36.438 - 00:09:52.262, Speaker B: Additionally, Fhe programs can return one value by returning said value, or you can use a tuple to return more than one. Next, let's compile our simple multiply example. First, we create a compiler and then pass the simple multiply function, and then we call compile.
00:09:52.262 - 00:10:12.830, Speaker B: It's that simple. During compilation, the compiler will choose Fhe scheme parameters that maximize performance, and then finally the compiler will return the application that results. You can use this application later when you need to actually run the program, and you can also get the scheme parameters that the Fhe compiler chose.
00:10:12.830 - 00:10:27.870, Speaker B: Next, we'll create a runtime. A runtime allows you to encrypt and decrypt data, perform key generation and run programs. To do this, you call the new constructor and you pass the parameters that previously resulted from the application compilation.
00:10:27.870 - 00:10:37.622, Speaker B: And this returns a runtime that you can later use. And now let's put it all together. We're going to use our runtime to first generate a public and private key.
00:10:37.622 - 00:10:55.098, Speaker B: We're then going to encrypt 15 and five using said public key into the values A and B. And then we're going to run our simple multiply program that we get out of our app. We pass the values A and B in the public key to the run function and this returns a results vector.
00:10:55.098 - 00:11:13.490, Speaker B: This vector contains the return values from your Fhe program. But if you recall, our simple multiply example only had one, which we decrypt and assign to C using the private key. And you'll note that finally we assert that 75 equals 15 times five and the program passes.
00:11:13.490 - 00:11:29.938, Speaker B: Next, let's build a more complex example. We're going to build a quote AMM, and I use quotes because this isn't running on chain and no balances are actually being updated. But what this does do is allow you to see how you can express the constant product formula using Sunscreen.
00:11:29.938 - 00:11:47.726, Speaker B: So Alice is going to encrypt a number of new cipher tokens she wishes to change. For ethereum, send this value to a validator who will then run the constant product formula. homomorphically return an amount of ethereum that Alice should receive encrypted under Alice's key, and Alice can then decrypt its value.
00:11:47.726 - 00:12:11.494, Speaker B: Next, let's look at the code backing our AMM example. First, we need to write an Fhe program that takes a number of new cipher tokens that one wishes to trade and returns the number of ethereum tokens they should receive under the constant product rule. We have hard coded the number of ethereum and new cipher tokens in the liquidity pool and we put the Fhe program macro on our swap new function.
00:12:11.494 - 00:12:30.780, Speaker B: This puts it into a form that our compiler can use. Next, let's look at the miner or the validator. The first thing they will do is run setup which will compile the Fhe program and get the parameters required to run it, which we can pass to an Fhe runtime that we create.
00:12:30.780 - 00:12:49.460, Speaker B: And we stash this runtime for later so that we can run the Fhe program. The run contract function does just that. It takes a number of new cipher tokens to trade encrypted under a particular public key and computes the number of ethereum that individual should receive encrypted under the same public key.
00:12:49.460 - 00:12:57.266, Speaker B: Next, let's look at our client. We have named our client Alice. The first thing Alice will do is run setup.
00:12:57.266 - 00:13:09.730, Speaker B: During setup, she needs to take the parameters associated with the AMM and generate a runtime. She uses this runtime to create her public and private key. And you can imagine that a real situation.
00:13:09.730 - 00:13:29.840, Speaker B: Alice would publish this public key to the chain and keep her private key in her wallet somewhere. Alice can then create transactions by taking an unencrypted amount and encrypting them under her public key. Finally, Alice can decrypt amount of ethereum she's received using her private key, which is done here.
00:13:29.840 - 00:13:43.934, Speaker B: Now, let's tie it all together by looking at the main method. First, we run minersetup, which gets the scheme parameters that Alice can use to create her runtime and generate her public and private key. Alice can then create a transaction.
00:13:43.934 - 00:14:01.290, Speaker B: So she wishes to trade 20 new cipher tokens. Then she can pass this encrypted transaction amount and her public key to the miner, who can run the contract and return to her an encrypted amount of ethereum she should receive. Alice can then decrypt this of balance and we can see it.
00:14:01.290 - 00:14:13.674, Speaker B: So let's run this program and for 20 new cipher tokens, alice should receive 1.96 ethereum. Next, let's talk about some of Sunscreen's offchain bounties.
00:14:13.674 - 00:14:30.878, Speaker B: We're going to be offering a cash prize for the best use of Sunscreen's Fhe compiler. A few of the bounty ideas include private inference training and data analytics. For private inference and training, you can imagine having a neural network that runs homomorphically over encrypted inputs, producing an encrypted output.
00:14:30.878 - 00:14:52.810, Speaker B: For data analytics, you can imagine having an application whereby you want to compute some statistics over user data without compromising user privacy. For a full list of hackathon ideas, go to hackathon Sunscreen tech or pause the video and use the QR code on the right. And now I'm going to throw over to Sam, who's going to talk about some of our on chain bounties.
00:14:54.590 - 00:15:01.790, Speaker C: Thanks, Rick. Hi everyone. I'm Sam Tay and I'm here to tell you about our private testnet parasol.
00:15:01.790 - 00:15:13.550, Speaker C: Fortunately, parasol is easy to explain if you're familiar with the EVM. Our nodes are basically stat EVM nodes. They've just been augmented with additional precompiles to enable Fhe.
00:15:13.550 - 00:15:36.146, Speaker C: In other words, you can do everything you can do on ethereum plus additional Fhe capabilities. Now, if you've ever had to call precompiles manually, you know it is quite a pain and typically requires some gnarly assembly. So we've written an Fhe Sol solidity contract that you can import to have all these Fhe functions at your disposal.
00:15:36.146 - 00:15:56.718, Speaker C: You can view that contract by scanning this QR code. Mostly it contains functions like the ones listed here for performing arithmetic, like add, multiply and subtract on various types and mixes of encrypted and plain text values. In this example, at the bottom of the slide, we're updating an encrypted balance with an incoming encrypted transaction amount.
00:15:56.718 - 00:16:21.318, Speaker C: The public key is required for this operation and the cyprtext arguments should also be encrypted under the same public key provided here. So on our network, each user has their own personal key pair, which we'll call the user key. But if you recall the limitation we mentioned earlier, a given private computation is done on ciphertext encrypted under one public key.
00:16:21.318 - 00:16:30.582, Speaker C: So if you have some shared private state, this is going to be a hurdle. One way around this limitation is to use our Network Key precompiles. Again.
00:16:30.582 - 00:16:45.310, Speaker C: These are exported from FHG Sol. In this scenario, all the relevant ciphertexts for a computation get encrypted under the Network Public Key. Of course, at some point you're going to actually need to decrypt the result of some computation.
00:16:45.310 - 00:17:15.106, Speaker C: The procedure for this is to reencrypt the network ciphertext into ciphertext under your key pair so that you can decrypt locally with your own private key. Note that this reencryption operation is performed by a precompile, but the contract authors need to enforce proper access control so that people can reencrypt data that they shouldn't have access to. Here's a diagram showing the general flow for an application that makes use of the Network Key architecture.
00:17:15.106 - 00:17:32.960, Speaker C: The two parties that want to compete with each other are Alice and Bob. Alice has a private value of ten, Bob has a private value of 20, and both of them encrypt their values under the Network Public Key. Those ciphertexts are shown in Teal here in the middle labeled A and B.
00:17:32.960 - 00:17:59.106, Speaker C: Then on the parasol Network validators will compute the homomorphic addition of these two ciphertexts, which they can do because they're both encrypted under the same public key. This results in a new ciphertext C, which is still encrypted under the Network key pair. Each party then requests a re encryption of the network ciphertext C into a ciphertext encrypted under their user key pair.
00:17:59.106 - 00:18:18.090, Speaker C: We've indicated this by using an orange color for ciphertext encrypted under Alice's key and green for ciphertext encrypted under Bob's key. Finally, they can decrypt with their respective private keys. Lastly, I should mention that you don't necessarily have to use the Network Public Key.
00:18:18.090 - 00:18:33.394, Speaker C: Depending on your application. You'll notice that you can supply whichever public key you wish when performing Fhe operations. And you may want to have certain cyber attacks that are only encrypted under a user key pair depending on your trust model.
00:18:33.394 - 00:18:51.590, Speaker C: But if you have private shared state amongst multiple parties, you'll see that computation becomes much more challenging to implement without the network key. Here's a very simple example demonstrating usage of our Fhe Sol contract. This contract makes use of the network key.
00:18:51.590 - 00:19:06.506, Speaker C: It just stores an encrypted number here on line seven that can be both set and incremented. You can see in the constructor this is set to an encrypted value of zero, and set number is similar. Increment is a bit more interesting.
00:19:06.506 - 00:19:20.298, Speaker C: Here we add the plain text value one to the current encrypted number and get back a new ciphertext. You can also see that we're supplying the network public key as an argument here. Finally, there's the reencrypt number method.
00:19:20.298 - 00:19:35.486, Speaker C: This takes a user's public key and outputs a new ciphertext encrypting the same number. But this ciphertext can be decrypted by the user's private key. One other thing to mention is that in Solidity we represent our ciphertexts and public keys as byte arrays.
00:19:35.486 - 00:19:48.386, Speaker C: This bytes type is just a dynamically sized byte array. In Solidity, you can see this contract in our monorepo template. This is the easiest way to get started hacking on parasol.
00:19:48.386 - 00:20:07.146, Speaker C: This screenshot is specifically of our Rust template, but we actually have a few different options for people that want to use other programming languages. If you add to this QR code on the right, you'll see a list of available language templates and links to the appropriate pages on GitHub. And when you go to GitHub, you'll see the screen button titled Use This Template.
00:20:07.146 - 00:20:21.278, Speaker C: Just click there to create a repository starting from this template. So to briefly explain this directory structure, we've got a contracts directory that is a Foundry project. If you're not familiar, foundry is a framework for writing solidity contracts.
00:20:21.278 - 00:20:41.578, Speaker C: The Foundry project already comes with Sunscreen's Fhe contract as a dependency, so you can hit the ground running. What's really cool about this though, is that the bindings directory contains a Rust crate with bindings that match to the Solidity contracts. So all of the methods you define on your Solidity contract now exist in Rust with the correct type signatures and everything.
00:20:41.578 - 00:20:58.830, Speaker C: It's really nice. If you look at the app directory, you'll see a CLI application that makes use of those generated bindings. And that CLI application also demonstrates usage of our Sunscreen Web Three library that makes it really easy to use Sunscreen Fhe types on parasol.
00:20:58.830 - 00:21:19.190, Speaker C: So this is a really good starting point for people to just start from the template and modify it to your needs. The README should contain everything you need to know to get started. We do have exclusive prizes available that will be awarded to the best use of Parasol, and this is separate from the FHG compiler prize.
00:21:19.190 - 00:21:37.034, Speaker C: While the hackathon is open ended, we do have some bounty ideas to help get you started. One is an AMM with private user orders. There's real value in having private orders, not only in that you get to keep your balances private, but you can also prevent certain attacks like front running.
00:21:37.034 - 00:21:57.198, Speaker C: Earlier we saw one small piece of a potential Encrypted AMM implementation. But this bounty is specifically about implementing this as a contract on the Parasol testnet, so it'll be a bit more challenging than the code example we saw earlier. Another interesting application idea is to implement private voting.
00:21:57.198 - 00:22:15.910, Speaker C: This idea has become increasingly popular, and not just in Web Three. If you're not familiar with voting schemes in general, it is highly desirable to have private vote casting. Without it, voters are subject to bribes and coercion and all sorts of social pressures that can lead to poor outcomes.
00:22:15.910 - 00:22:26.380, Speaker C: The network key precompiles will likely come in handy for both of these projects. Again, here's a link to our hackathon guide. You can scan the QR code to get there.
00:22:26.380 - 00:22:44.640, Speaker C: These bounties are discussed in much greater detail there, and you'll also find more information about Fhe and best practices, so definitely check it out. If you haven't heard of Fhe before this video, I hope we've conveyed to you just how groundbreaking this technology is. Particularly in Web three.
00:22:44.640 - 00:23:01.382, Speaker C: We've seen how it can completely eliminate front running in DFI, and it also just enables a much broader class of applications that require private shared state. We're really excited about this technology, and we hope you are too. That's all for this video.
00:23:01.382 - 00:23:13.638, Speaker C: We'll be at the hackathon at one of the cocktail tables, so drop by to chat or ask us any questions. We'll also have a discord channel dedicated to participants, so you can find us there too. We're excited to see what you come up with.
00:23:13.638 - 00:23:14.290, Speaker C: Happy hacking.
