00:00:06.170 - 00:00:11.390, Speaker A: Hey everyone. Welcome to my workshop building with Polygon. ID API.
00:00:11.390 - 00:00:27.398, Speaker A: What we're going to be doing today is still focusing a lot on the full, kind of like full stack flow of how you would build with Polygon ID, but introducing the concept of also building with the API. So. Hi.
00:00:27.398 - 00:00:36.722, Speaker A: I'm Rahat. I'm the lead developer relations engineer over at Polygon. Previously I've been a frontend engineer as well as a solidity engineer, indie hacker, web three enthusiast.
00:00:36.722 - 00:00:49.386, Speaker A: I've done a few of my own startups which have all failed. So I can't tell you how to succeed on that side of things, but I can tell you what not to do and maybe that'll take you part of the way there. These are just some places you can find me.
00:00:49.386 - 00:00:58.446, Speaker A: I'm most active on Twitter, LinkedIn, I guess. And GitHub is where you can find some of the code examples that we'll be going through and I'll also link.
00:00:58.468 - 00:01:00.206, Speaker B: To that later on as well.
00:01:00.388 - 00:01:12.290, Speaker A: But first, let's play a game. This image that you see for here is a claim. The claim is that I am a pixelated punk.
00:01:12.290 - 00:01:26.440, Speaker A: So can you all verify? Am I a pixelated punk? Are these two images the same, yes or no? Yes. No. So the correct answer is yes.
00:01:26.440 - 00:01:32.970, Speaker A: So corporate needs you to find the difference between these two pictures. There is no difference. It's the same.
00:01:32.970 - 00:01:50.686, Speaker A: That's what we're going to say for now. But essentially what we just did was you just participated in what's sort of like an IRL version of Polygon ID. There is first what's called an issuer, who is issuing some type of claim, some type of information about you.
00:01:50.686 - 00:02:08.906, Speaker A: You're holding that information in some capacity and then some type of Verifier is verifying if that claim is true or not. And we'll break that down a little bit further. But what exactly is polygon ID? So Polygon ID is a blockchain native identity system with programmable privacy.
00:02:08.906 - 00:02:24.278, Speaker A: What does that mean? So a little bit of what I just kind of explained was called a triangle of trust. You can program different parts of the triangle of trust to share specific things about yourself on a need to know basis.
00:02:24.374 - 00:02:24.874, Speaker C: Right?
00:02:24.992 - 00:02:47.150, Speaker A: We're going to be utilizing and taking advantage of ZK proofs to only share information that an end sort of corporation or Verifier needs to know. So this is just a little diagram of that triangle of trust. So this initial claim or this NFT was created by pixel portraits.
00:02:47.150 - 00:02:53.074, Speaker A: Shout out to pixel portraits by the way. They're awesome. And that NFT is owned by me.
00:02:53.074 - 00:03:05.618, Speaker A: You can go to my wallet and see it or whatever. And what you all did was verify that that is indeed me. It's like the PFP that I use on Twitter.
00:03:05.618 - 00:03:16.540, Speaker A: It's PFP I use on a bunch of different places and I don't know how to personify a ZK proof in real life. One day I will figure that out. And it's going to be amazing.
00:03:16.540 - 00:04:12.880, Speaker A: But essentially what you'll usually do in these cases is like, you only share a specific part of that claim or that ID. So let's say a local municipal issued you a driver's license, issued you some type of identification, right? What are some of the key pieces of information on that driver's license? You have your name, date of birth, address, a bunch of different information, right? Anywhere that needs your ID, you end up giving them your ID and they have access to all of this information, but they may only actually need one or two pieces of information from there, right? Or they may not even need to know 100% what your date of birth is. In the case of like, if you're going into a bar or a place that requires you to be 21 or older, what if you could verify you're 21 or older without giving them your actual date of birth? And that's the kind of like the concept we're going to be focusing on today a little bit.
00:04:12.880 - 00:04:30.142, Speaker A: So in previous workshops, we've gone through the flow and we wore two hats. We were both an issuer and a Verifier. In this workshop, we're still going to be both, but we're going to look at two different pathways and two different types of applications you can build during the workshop.
00:04:30.142 - 00:04:58.486, Speaker A: So you can during this hackathon, be your own issuer, build that out yourself and we'll go into what that means in a second. Or you can be a Verifier, create an application that consumes some type of claim that has been issued by whatever issuer you trust in real life. These two entities should be different, hopefully, because you don't want to issue claims and then only trust the claims that you've issued.
00:04:58.486 - 00:05:21.300, Speaker A: That's not really decentralized, I guess. So you would have probably an issuer who is tied to some Verifier, like a local municipal or something like that, who issues you that ID or issues you a claim and you would have these claims that can be verified. It's up to the Verifier to trust the issuer and that's where that triangle trust comes in.
00:05:21.300 - 00:05:40.246, Speaker A: The Verifier has to trust that the issuer gives proper credentials for all of this to work. So let's look at some demos and some code. So what you'll see here right now is what's sort of the UI platform for testing out and giving people claims.
00:05:40.246 - 00:05:53.440, Speaker A: So if I wanted to make a new claim, so I would go here and create Schema. This is all on platform test polygonid.com. This link will be available in the repo, which I'll be tweeting out.
00:05:53.440 - 00:06:10.660, Speaker A: So there's a bunch of different information that you can put in here. But let's say I want to put in something like how old am I? Age verification. Date of birth.
00:06:10.660 - 00:06:25.656, Speaker A: So in this I would name my schema something. So I named it Age Verification and I would give my attribute something which would be date of birth. And I have three data types that I can choose from.
00:06:25.656 - 00:06:31.364, Speaker A: I can choose a boolean yes or no. I can choose a date or I can choose a number. So I'm going to choose date.
00:06:31.364 - 00:06:50.210, Speaker A: Just because we chose date of birth, this is optional over here. What you can do actually is click this and add an expiration date for your claim so that a claim after a certain amount of time will no longer be valid. I don't think it really makes sense in this case, but you might find different use cases for where you might want to do something like that.
00:06:50.210 - 00:07:00.292, Speaker A: So you click save and offer claim. Great. Now in the attribute I can put in my date of birth, I'm not going to put in my real one.
00:07:00.292 - 00:07:17.290, Speaker A: But let's see, we'll do September 25 and this is again optional. So I'm just going to leave that alone. I hit Generate claim offer and I'm going to go ahead and open this link.
00:07:17.290 - 00:07:33.624, Speaker A: So this link is now a claim that I can verify that I can add to my polygon ID wallet. So the Polygon ID wallet is a mobile application. You can download it from the App store or Google Play, and that is where your claims or your credentials are going to be held.
00:07:33.624 - 00:07:46.608, Speaker A: So as soon as I scan this with my polygon ID app, it's going to add this claim to my wallet. When it's added to my wallet, the thing is it's not saved on a blockchain. It's not saved anywhere.
00:07:46.608 - 00:07:55.460, Speaker A: It only exists on your local app, nowhere else. So everything is really dependent on your local storage. It's not saved anywhere.
00:07:55.460 - 00:08:25.096, Speaker A: You'll see that under my attributes. I have my date of birth listed over here. Although this is listed here, when someone makes a query to understand this information, what they can do is query for was this person born after this certain date? So instead of giving them the information that I may have been born on September 25, 1991, their query would simply verify that whatever their starting age point is, is greater than or less than mine.
00:08:25.096 - 00:08:36.064, Speaker A: So they don't need to know my actual date of birth, they just need to know that I meet a requirement. So we'll take a look at those queries in a second. But this is the UI platform for issuing a claim.
00:08:36.064 - 00:09:18.000, Speaker A: Now the issue here is this is not something you can use to make sort of like a robust solution for issuing claims, right? If you wanted to become an issuer yourself, you wanted to maybe partner with a local municipal. If you wanted to verify different things, whether it be date of birth, whether it be income level, whether it be, I don't know, dow membership, NFT, whatever, like pretty much whatever you want, you can create an app that does that verification and creates these claims. So how would we do that? What we've got here is an overview of the Polygon ID documentation.
00:09:18.000 - 00:09:42.028, Speaker A: And one of the things that we've recently launched is the Polygon ID platform API. So now rather than going through and building on top of that UI platform, you have different endpoints that you can use to issue claims yourself through any type of front end that you want. So on your front end, maybe you want to verify someone's ID, maybe you want to verify that they own a certain NFT.
00:09:42.028 - 00:09:53.756, Speaker A: Maybe you want to verify income level in some way for like credit scores or things like that. You can do anything that is traditionally done in web two, gather that information and then issue a claim based on that.
00:09:53.858 - 00:09:54.460, Speaker C: Right?
00:09:54.610 - 00:10:23.510, Speaker A: So now you have the possibility of bringing things into Polygon ID, such as credit scores, income level, age verification, which is again what we're focusing on today, but kind of like whatever you can think of, it's up to your front end. Whatever your front end does is what it does and you issue a claim based on that. So if you wanted to go in and look at that API, we have an API reference here.
00:10:23.510 - 00:10:45.384, Speaker A: All of these different endpoints can be run right away in postman. So you can go in, try them out, play around with them, definitely recommend if you want to build your own issuer, try out all these different endpoints and see what's possible. And one of my teammates, Steph, has actually created an awesome little starter template.
00:10:45.384 - 00:11:06.224, Speaker A: So this is a react front end which allows you to it hooks up immediately with the Polygon ID API. All you have to do is go in and change a few environment variables and you're kind of like already set to go. You can build different things on top of that, but this is a really great starting point, especially if you decide that during this hackathon you want to focus on the issuer side.
00:11:06.224 - 00:11:21.752, Speaker A: You want to build your own issuer, you want to build some type of verification platform. So check this out. You can fork this, repo it's already got a few of the different endpoints that are available on that API, kind of like coded in there.
00:11:21.752 - 00:11:35.100, Speaker A: You can add more as you go depending on your use case. So that is the Polygon IDE platform as well as the API. Those are the two different ways right now that you can issue claims.
00:11:35.100 - 00:11:52.784, Speaker A: So what do you do after you've issued a claim? One thing that we see a lot, especially now in things like social media, Instagram, Twitter and everything like that, it requires you to be 13 years or older at sometimes to use it.
00:11:52.822 - 00:11:53.216, Speaker C: Right.
00:11:53.318 - 00:12:15.240, Speaker A: So again, we come to this point, do we have to share our date of birth every single time to these different platforms? Do they really need to know our date of birth? No, they just need to know if we're 13 or older. So that we can actually use the platform. So in my case, I created a couple of claims already through here that verify that my age is over 13.
00:12:15.240 - 00:12:37.410, Speaker A: When you do your actual verification, if you want to, you can build out a solution that Verifies ID and everything like that totally up to you. Polygon ID itself is really just like the platform that you would use to issue the claims, hold those credentials and verify them. The actual process of verification kind of happens elsewhere and you can bring that into Polygon ID.
00:12:37.410 - 00:13:01.716, Speaker A: So I created this small DAP where it checks whether I am 13 years of age or older or not. And as long as I am 13 years of age or older, I will mint a soul bound NFT that I can use to token gate different social media platforms. For example, let's say you're building on top of Lens Protocol.
00:13:01.716 - 00:13:25.100, Speaker A: Maybe you want to token gate a Lens Protocol specific application. If we wanted to build a social media that's I guess more compliant with what web two standards are right now, and we wanted to make sure that only folks 13 or older were using something like a lens Instagram or a lens Twitter type thing. We could use this to token gate it after verifying someone's 13 or older.
00:13:25.100 - 00:13:46.932, Speaker A: So we've got a couple of contracts in here. The main contract that I'll focus on today is going to be this ERC 721 Verifier and it's inheriting from a couple of different libraries. So these library contracts are ones that you can just copy and paste right into your code.
00:13:46.932 - 00:14:09.464, Speaker A: Cool thing is, if you wanted to just get started and you're not too familiar with the ZK side of things, we give you a couple of library contracts so you can get started, leverage the power of ZK proofs and kind of like abstracted away. At least for this hackathon, though I do definitely recommend you go in, dive into it and learn more about it as you go through. So in my case, I have all of these saved locally.
00:14:09.464 - 00:14:24.796, Speaker A: You would want to make sure that you also have those saved locally. You can grab those from the tutorial in the Polygon ID docs as well as any one of the repos that I'm going to be sharing with you today. And this is just a basic ERC 721 Token.
00:14:24.796 - 00:14:39.696, Speaker A: Nothing fancy going on here. It's called social age check or sac. And the three main things that you want to focus on that do the magic here is this first function before proof submit.
00:14:39.696 - 00:14:54.136, Speaker A: And after proof submit. Before proof submit is going to check that the challenge input of the proof is equal to message sender. So you want to make sure that the person who's actually verifying using their Polygon ID wallet is the person who is also trying to mint this NFT.
00:14:54.136 - 00:15:14.240, Speaker A: They got to be one person, right? And then after proof submit is where you can basically once these verifications are completed, this is where you can do pretty much whatever you want inside of this if statement. It's pretty much nothing related to Polygon ID. It's just me minting an NFT.
00:15:14.240 - 00:15:33.828, Speaker A: So in here I've got the safe Mint function which is taking the message sender as well as a new item ID that I created up here and setting the token Uri for an on chain NFT. So that on chain NFT is just being generated. Over here, it's just an SVG, nothing fancy.
00:15:33.828 - 00:15:49.496, Speaker A: An SVG that just says that I am indeed 13 years of age or older. And you'll see, for my before token transfer, this is where I'm making sure that this becomes a sole bound token that you can no longer transfer it. Your age is your own, not someone else's.
00:15:49.496 - 00:16:06.548, Speaker A: You can't verify your age for someone else. And there's a few other tutorials that do some similar things. Here you can do something like if you were doing like an ERC 20 AirDrop, you want to make sure that that person or whoever you transfer the ERC 20 tokens to have actually been verified by Polygon ID.
00:16:06.548 - 00:16:09.830, Speaker A: So this is the location where you would do everything like that.
00:16:11.480 - 00:16:12.324, Speaker C: Cool.
00:16:12.522 - 00:16:25.864, Speaker A: So let's go back to here and I've got a quick demo of that in action. So this is the polygon ID wallet. Pretty simple.
00:16:25.864 - 00:16:33.070, Speaker A: You open up your app. Actually, hold on, I actually skipped something. Sorry about that.
00:16:33.070 - 00:16:51.856, Speaker A: So one thing I forgot to show you. So we've got so I've shown you how to actually build out the smart contract itself. There are two scripts that need to be run in order for you to actually utilize this.
00:16:51.856 - 00:17:01.296, Speaker A: So these two scripts can be found inside of scripts. First is just your regular deploy. You want to deploy your function, deploy your smart contract.
00:17:01.296 - 00:17:28.552, Speaker A: And then this set request, which is going to be how you connect your contract to this contract that has been deployed onto the Mumbai testnet. So, important thing to remember, polygon ID, the way you're using it right now is on testnet. But essentially this is what's going to connect you to a contract that exists on the Mumbai testnet that allows you to take advantage of a lot of the ZK proofs that are underlying.
00:17:28.552 - 00:17:46.150, Speaker A: And this is also where you would put your initial queries for whatever you need to validate. So in this case, I have an age query. I want to make sure that the person who actually uses this specific platform was born before this date.
00:17:46.150 - 00:17:55.984, Speaker A: Definitely. Take a look at the GitHub documentation linked over here. This is a JSON query language for building out your query.
00:17:55.984 - 00:18:14.684, Speaker A: It's nothing too complex, you just need to figure out what each of these indexes mean. But the operator over here basically lets you know if the operation should be like a greater than, equal to less than. So I believe this number two off the top of my head, I think it's greater than.
00:18:14.684 - 00:18:32.320, Speaker A: But take a look at the documentation and verify that before you do your own query. So this is what would set the actual verification for your smart contract. And then you have to build out a front end for a user to actually validate their claim.
00:18:32.320 - 00:18:58.276, Speaker A: So I forked a small front end here that you can check out. Nothing too fancy, just a page where once again, you're going to be scanning a QR code from your polygon ID wallet app. But you'll see here that once again you have this QR proof which is a JSON query language.
00:18:58.276 - 00:19:11.500, Speaker A: Again, just take a look at the documentation there to understand what pieces of data that you need. But this is going to be more related to the schema that you generate from your claim. So you're going to put some information regarding that.
00:19:11.500 - 00:19:27.540, Speaker A: And you'll see here that for birthday, I am checking if it's less than this specific date. So those are like the key pieces of information that you need as well as the schema details which you can get from your claim after you've claimed it. But from here it's pretty simple.
00:19:27.540 - 00:19:44.216, Speaker A: From here you just use your polygon ID wallet to verify that ownership. So let's go back a little bit. So again, I open up my wallet, I scan the QR code.
00:19:44.216 - 00:19:51.300, Speaker A: A proof request is then sent. I want to generate the proof. Now it'll actually go to my regular wallet.
00:19:51.300 - 00:20:03.274, Speaker A: So I'm going to connect to MetaMask and sign the transaction. So I go ahead, I connect my account. The proof is now being generated.
00:20:03.274 - 00:20:13.966, Speaker A: And remember, we're minting an NFT at this point. So there's going to be another transaction that we have to sign through MetaMask to make sure we pay our gas. So now the actual NFT is being created.
00:20:13.966 - 00:20:15.700, Speaker A: This is the transaction for that.
00:20:18.180 - 00:20:18.930, Speaker C: Cool.
00:20:19.700 - 00:20:35.524, Speaker A: And once you're all set, you hit confirm. Now you own a soulbound NFT that has done some verification that you are 13 years of age or older and you own this as an NFT. So again, I'm not an artist.
00:20:35.524 - 00:20:49.724, Speaker A: So you get a very basic NFT here that says that I am verified 13 or older. This is a solbound NFT that you can use to now gate different social media platforms. This is just like one very basic use case.
00:20:49.724 - 00:21:05.760, Speaker A: So there's a lot of different things that you can build on here. Like I said, if you want to focus on the Issuance side, you have the API, you have a certificate from one of my coworkers steph. If you do end up using it, make sure you star that GitHub repo tweet at her that you're using it.
00:21:05.760 - 00:21:16.230, Speaker A: She'll appreciate that. And yeah, we really love to see what all of you build during this hackathon. Just a couple more things.
00:21:16.230 - 00:21:53.350, Speaker A: These are some additional resources that you can use to build. I actually just tweeted out the link to this GitHub repo, which contains everything, including the slides. So if you go on my Twitter that is at or hotcodes, you can link over to the GitHub which contains the slides, all of the resources, all of the links that you need, and I would highly recommend also going back and checking out Steph's original polygon idea workshop from ETH Bogota.
00:21:53.350 - 00:22:11.310, Speaker A: She did a great, really good introduction on the very core basics of how everything kind of works. Steph and Manny's GitHub repos have additional examples of how you can build on top of it as well. Manny's GitHub repo contains common errors that you might run into as you're building.
00:22:11.310 - 00:22:22.020, Speaker A: So if you ever get stuck, need some help, troubleshooting, manny has listed out and taken screenshots of very common errors you might get and how to fix them.
00:22:23.990 - 00:22:24.594, Speaker C: Cool.
00:22:24.712 - 00:22:38.700, Speaker A: If you've enjoyed this workshop, please let us know on Twitter. We're at zero x polygon devs as well as at Rahatcodes, which is me, and would love to take any questions. I have to wear this.
00:22:38.700 - 00:22:48.024, Speaker A: Anyone have questions? Thanks.
00:22:48.062 - 00:22:49.130, Speaker B: Someone over here.
00:22:56.140 - 00:23:07.436, Speaker D: It so once the issuer issues the claim, what if somebody else scans the QR code than the one whom you have issued it to?
00:23:07.618 - 00:23:12.270, Speaker A: So once one person scans that specific.
00:23:12.720 - 00:23:16.368, Speaker B: QR code, another person would not be able to scan it specifically for that.
00:23:16.374 - 00:23:17.104, Speaker A: One time use case.
00:23:17.142 - 00:23:21.200, Speaker D: Okay, what if before the actual user scans it, somebody else scans?
00:23:23.780 - 00:23:44.008, Speaker A: The ideal kind of situation would be that you do your verification and you send a unique link to that specific person. As long as they're not like that's, just like common web two security issues, as long as they're not doing anything like common phishing attacks or things like that, you should be fine. So that would be up to the.
00:23:44.014 - 00:23:46.040, Speaker B: Kind of like the user to protect their link.
00:23:46.190 - 00:23:55.500, Speaker D: Okay, just one more question. There is this age related thing that we did lesser than 2009, January 1.
00:23:55.570 - 00:23:55.852, Speaker C: Right.
00:23:55.906 - 00:24:00.768, Speaker D: So in a few years, the date will change.
00:24:00.854 - 00:24:01.200, Speaker C: Right.
00:24:01.270 - 00:24:06.480, Speaker D: So how? Well, you have to update the front end accordingly.
00:24:07.700 - 00:24:09.744, Speaker A: So you can update your query at.
00:24:09.782 - 00:24:14.928, Speaker B: Any time, both on the smart contract as well as the front end.
00:24:15.014 - 00:24:16.484, Speaker A: So on the smart contract, the second.
00:24:16.522 - 00:24:18.964, Speaker B: Script that we've run, that can be.
00:24:19.002 - 00:24:20.084, Speaker A: Run as many times as you want.
00:24:20.122 - 00:24:26.840, Speaker B: You can update that with different queries with different parameters, and your new query would be what would be verified?
00:24:27.900 - 00:24:28.650, Speaker C: Okay.
00:24:30.380 - 00:24:57.996, Speaker E: Yeah, hello here. So actually, I wanted to know the way we basically send the zero knowledge proof to the smart contract. Is it possible in a way that someone else I create a zero knowledge proof from the polygon ID app, and then someone else creates a new transaction on the polygon blockchain rather than me doing it? And then basically, we can prove that this person actually approved this transaction.
00:24:57.996 - 00:25:13.030, Speaker E: So someone, let's say I assigned a zero knowledge proof and I gave a string or something like that of the proof to you, a JSON file maybe. And then when you send it to the blockchain, it could be verified that you did it on my behalf and it's allowed to do it.
00:25:13.720 - 00:25:17.344, Speaker A: So I guess I'm trying to rationalize.
00:25:17.392 - 00:25:18.936, Speaker B: Why you would need ZK proofs for.
00:25:18.958 - 00:25:21.416, Speaker A: Something like that because regular signatures pretty.
00:25:21.438 - 00:25:22.776, Speaker B: Much take care of that for you.
00:25:22.878 - 00:25:24.436, Speaker A: With like the ECSA.
00:25:24.548 - 00:25:47.920, Speaker E: The reason I want it to be is that let's say because I want the verification of that, that it is authorized by me onto the blockchain. So in the ZK we are doing this verification on chain. So I don't want it to be onto a device or maybe intermediary or anywhere on the smart contract itself verifies in ZK.
00:25:49.940 - 00:25:56.336, Speaker A: Okay, so again, it's possible everything is.
00:25:56.358 - 00:26:01.632, Speaker B: Kind of built on top of Circom and the idean three protocol that's underlying.
00:26:01.776 - 00:26:04.740, Speaker A: For this specific way you use polygon ID.
00:26:04.810 - 00:26:08.248, Speaker B: We're kind of abstracting a lot of that away, but if you wanted to.
00:26:08.254 - 00:26:16.216, Speaker A: Go in and create your proofs, you can definitely do that. So I guess I'm not sure what the polygon ID specific question is here.
00:26:16.398 - 00:26:35.984, Speaker E: Yeah, the specific question is just is that let's say I have a specific use case in which my transaction is being signed and sent to the blockchain. The smart contract from a centralized server, let's say. But I want the centralized server, like when it sends to the polygon blockchain, I want the smart contract to know that it was sent on my behalf at the smart contract level.
00:26:35.984 - 00:26:44.828, Speaker E: I want to verify this thing. So I'm not sure if signing a message just I can verify that on the smart contract level, but I'm sure if I send the zero knowledge proof, then it could be verified on the blockchain.
00:26:44.924 - 00:26:48.036, Speaker A: So kind of like what you're describing right now is what happens pretty much.
00:26:48.058 - 00:26:54.260, Speaker B: All the time on something like OpenSea. That is literally the process that they use. And that's done without ZK proofs at all.
00:26:54.260 - 00:27:07.592, Speaker B: That's just done with signatures you set an approval for that you want OpenSea to be able to transact on your behalf and to sell an NFT once you have a specific offer or whatever.
00:27:07.646 - 00:27:08.250, Speaker A: Right?
00:27:08.780 - 00:27:12.040, Speaker B: So that's all done without zero knowledge proof.
00:27:12.560 - 00:27:30.288, Speaker E: Okay, got it. So last question is that, let's say, what's the use case of like I saw there are a couple of variables, like types, for example, like date, boolean and a number. So what's the use case of a boolean? Where can we use it and why is it there?
00:27:30.374 - 00:27:31.456, Speaker A: Yeah, I mean, if you wanted to.
00:27:31.478 - 00:27:41.332, Speaker B: Do some true or false, if you wanted to keep the query itself very simple, maybe your front end, like the issuer has some complex sort of like.
00:27:41.386 - 00:27:46.144, Speaker E: Issuer will be proving that something is true. So he can clearly tell this. Like he's telling the value.
00:27:46.144 - 00:27:49.450, Speaker E: Exactly. So why do we need proof and hide that.
00:27:49.980 - 00:27:50.728, Speaker A: I'm sorry.
00:27:50.814 - 00:28:00.910, Speaker E: So the issuer can basically tell. So with the zero knowledge proof, you will be basically telling that is that it's true or not? So it's directly boolean anyway, right?
00:28:04.080 - 00:28:11.692, Speaker A: In that case, I would see your point, but the way I see it is it's for just, like, ease of use, in my opinion.
00:28:11.756 - 00:28:19.450, Speaker C: Okay? Yeah. Thank you. Cool.
00:28:26.270 - 00:28:27.520, Speaker B: Any other questions?
00:28:30.900 - 00:28:31.744, Speaker C: Good.
00:28:31.942 - 00:28:32.544, Speaker A: Okay.
00:28:32.662 - 00:28:33.184, Speaker C: All right.
00:28:33.222 - 00:28:34.530, Speaker A: Thank you all very much.
00:28:36.500 - 00:28:52.180, Speaker F: So where exactly the proving part is? Is it after the claim? The issuer issues a claim, okay. And then it stays in the wallet, right? So the wallet will be sending only the proofs.
00:28:52.840 - 00:28:56.000, Speaker A: So the proving part actually happens in.
00:28:56.010 - 00:29:13.020, Speaker B: Our case, happened within the NFT smart contract, right. We had those different libraries that we imported in that takes care of kind of abstracts away everything so we don't have to worry about it. And there's a smart contract deployed on the Moonmine test network that essentially does a lot of that work for you.
00:29:13.020 - 00:29:30.480, Speaker B: And whenever you take your polygon ID wallet, you scan that QR code with that JSON query inside of it. That's what kicks off the smart contract to start the actual proof. So all of the information from that JSON query is sent to the contract.
00:29:30.480 - 00:29:38.672, Speaker B: It also gets access to the claim that is in your wallet, since that's where you're scanning it from, and that's where the actual proof is verified.
00:29:38.816 - 00:29:39.510, Speaker C: Okay.
00:29:43.960 - 00:29:46.010, Speaker A: Are you all getting feedback too? Yeah.
00:29:46.860 - 00:29:51.604, Speaker F: So where exactly is the proof generation happening? Is it on the device, the mobile.
00:29:51.652 - 00:29:54.292, Speaker A: Device that is on the smart contract?
00:29:54.356 - 00:30:10.590, Speaker F: Oh, in the smart contract. Okay, so if I have a use case in which I'm kind of sending the proof, right, I don't want to expose my public key, right? Is that Doable generating the proof on the device itself?
00:30:11.600 - 00:30:14.236, Speaker A: No, because the device itself, all it.
00:30:14.258 - 00:30:22.580, Speaker B: Does is hold your credential, nothing more than that. That is the only use case for the actual wallet, just for holding the credentials.
00:30:23.480 - 00:30:25.492, Speaker A: And within the smart contract, we're also.
00:30:25.546 - 00:30:32.564, Speaker B: Verifying that this person who's connecting their regular wallet with the polygon ID app.
00:30:32.602 - 00:30:33.380, Speaker A: Is the same person.
00:30:33.450 - 00:30:34.320, Speaker B: So that will require.
