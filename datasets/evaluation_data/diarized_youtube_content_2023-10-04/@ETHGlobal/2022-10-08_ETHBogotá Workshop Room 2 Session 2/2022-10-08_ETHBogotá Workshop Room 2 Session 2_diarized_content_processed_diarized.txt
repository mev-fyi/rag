00:02:07.450 - 00:02:25.360, Speaker A: This is hey.
00:02:27.410 - 00:02:37.560, Speaker B: Welcome. Yeah. Hoping that we get a few more, but you might have a yeah.
00:02:37.560 - 00:02:48.700, Speaker B: Thanks for coming. You were remind me what you're trying to build. Are you still looking around?
00:02:49.070 - 00:02:57.500, Speaker A: No, I think well, see what the team settles on.
00:02:59.090 - 00:02:59.840, Speaker B: Cool.
00:03:00.290 - 00:03:05.950, Speaker A: Probably something with identity.
00:03:08.770 - 00:03:09.520, Speaker B: Cool.
00:03:10.370 - 00:03:14.180, Speaker A: Like, the advantage of the standing having a big team is that you have, like.
00:03:15.910 - 00:03:37.786, Speaker B: More ideas being yeah, I don't know if I should get started, but yeah. Hey. Okay.
00:03:37.968 - 00:03:42.570, Speaker A: We're just, like, having the volunteer school around and announced that, like, workshop is still going on.
00:03:42.640 - 00:03:49.774, Speaker B: Okay, cool. Yeah. Cool.
00:03:49.774 - 00:04:05.890, Speaker B: All right, thanks. 10:00 P.m. Time on the.
00:04:19.420 - 00:04:23.144, Speaker A: Oh, man. Watch the presentation. Online recording, right.
00:04:23.144 - 00:04:26.330, Speaker A: Yeah. Do it for the head.
00:04:29.260 - 00:04:31.496, Speaker B: I'm gonna wait for her to come back for sure.
00:04:31.518 - 00:04:49.544, Speaker A: Yeah. Nice to meet you. Mean like no, I mean not just hacking.
00:04:49.544 - 00:04:56.380, Speaker A: Yeah. Exciting.
00:04:57.280 - 00:04:58.928, Speaker B: I know very little other than a.
00:04:58.934 - 00:05:02.530, Speaker A: Very basic pitch, so I just wanted to check it out.
00:06:17.190 - 00:06:19.460, Speaker B: Hello? Okay, cool.
00:06:21.990 - 00:06:22.306, Speaker A: Yeah.
00:06:22.328 - 00:06:34.280, Speaker B: I don't know if I should wait on the East Global person to come back, but they said that they're, like, going to tell hackers. I guess maybe you guys came from that. I don't know.
00:06:34.280 - 00:06:44.700, Speaker B: I don't know if there's, like, a thing scheduled right after this. There is. Okay, then maybe I should start.
00:06:44.700 - 00:06:47.786, Speaker B: Cool. Well, yeah. Thanks, guys, for coming.
00:06:47.786 - 00:06:54.554, Speaker B: We're going to have a lot of fun. My name is York from Hyperlane. We're formerly known as Abacus.
00:06:54.554 - 00:07:19.190, Speaker B: If you heard of the Abacus protocol we rebranded recently. But yeah, today we're going to be talking about some developer tools that we expose for you guys to use during the hackathon. I know the workshop was labeled with interchange accounts, but we also deployed a new middleware today for, like, interchange queries, so we're going to cover both of those, hopefully.
00:07:19.190 - 00:07:47.950, Speaker B: So, yeah, first and foremost, what is Hyperlane? In case you guys aren't up to speed? Hyperlane is a developer platform that enables interchain applications. And so what that basically means is there's a smart contract API that's deployed on all of our supported chains, and you can use that API to send messages between blockchains. So you kind of enable composability between smart contracts, which exist on different chains.
00:07:47.950 - 00:08:11.062, Speaker B: And we have kind of like a novel security model that we do that we employ to enable this. But I think I want to keep this talk focused on kind of, like, the developer tooling side of things as opposed to the security protocol, but happy to answer questions there that you guys have at the end. So yeah.
00:08:11.062 - 00:08:44.418, Speaker B: Why do we care about interchain applications and why should you be building one? So today developers that are building DApps are faced with this choice of which chain they want to deploy on when they're going out and launching their V zero. And I think what developers don't realize a lot of the time is that that choice has kind of, like, a lot of downstream consequences. So we listed a few here.
00:08:44.418 - 00:09:05.510, Speaker B: Developer Experience the tooling that's around a specific chain might be limited to that chain's ecosystem. Each chain has some idiosyncrasies and sometimes the tooling isn't as mature on newer chains or cheaper chains. So you might be trading that off without realizing.
00:09:05.510 - 00:09:35.326, Speaker B: And then I think this one probably should be the highest on the list. User experience. Just generally, like, when you're choosing which chain you're deploying on, really what you're choosing is, like, who is the user demographic that's actually going to be able to use your application and are they going to be required to? Bridge to some chain that they're not already on, which requires them to go through some third party application, usually taking on a lot of counterparty risk.
00:09:35.326 - 00:10:01.206, Speaker B: We've seen a lot of bridge hacks recently, so generally you don't want to ask users to go through some third party application just to access your app. Then we have the platform risk. So this is kind of like once you've developed a network effect on a specific chain that you've deployed on, it becomes very hard to migrate that application or network effect to a new chain.
00:10:01.206 - 00:10:59.014, Speaker B: If you decide that the current chain has departed from some maybe morals or philosophy that you want to adhere to, maybe it's like some censorship property or something like that, it generally becomes difficult to migrate network effects, capital, et cetera. And yeah, this extends to composability if you want to kind of reach new user demographics which are on different chains or maybe like lower fee chains or higher security chains, et cetera. If your application isn't designed with cross chain composability in mind, when you deploy to these new chains, you end up with these new siloed instances of your application rather than an application where all of the users of your app are benefiting from kind of like the aggregate network effects.
00:10:59.014 - 00:11:23.910, Speaker B: Instead you have these kind of siloed networks that in the case of an AMM, when uniswap goes and deploys on a new chain, it's an entirely new set of liquidity and so you kind of have to rebuild the network effects. A lot of times you have to deploy these artificial injections in the form of incentives to bootstrap the utility there initially. So yeah, there's all these consequences.
00:11:23.910 - 00:11:52.186, Speaker B: And what people are doing today to go MultiChain or go cross chain really is not scaling. Well they're, like I said, deploying these incentive programs and there's all this mercenary capital in the ecosystem that's just like chasing these incentives and as soon as the incentives dry up, they just leave. And so it's not a really sustainable model for scaling to all of these new chain environments.
00:11:52.186 - 00:12:30.522, Speaker B: However, we want our applications to support these new chain environments because there's all these different scalability improvements and enhancements being made which make certain user demographics more likely to use your application. So there's kind of this tension between the proliferation of these scaling solutions and new user demographics and being able to have an application which maintains its network effects across all these different chains. So this is where Hyperlane comes in.
00:12:30.522 - 00:12:46.586, Speaker B: Hyperlane is a network that exists between blockchains, so it's not another blockchain. You don't have to choose Hyperlane. You can just use Hyperlane tooling to deploy everywhere and it eliminates this choice.
00:12:46.586 - 00:13:05.590, Speaker B: So today we're only on EVM chains. And so you still get this nice property of only having to write your application logic once and kind of like deploying it everywhere in like a symmetric interface. And it's built to be this connective tissue that allows smart contracts to communicate between different chains.
00:13:05.590 - 00:13:43.810, Speaker B: And so you can have intra app communication whereby you have a shared state model and some sort of state synchronization that exposes a user interface on all of these different chains, but actually is doing kind of like asynchronous state synchronization on the application side, which is like obfuscated away from the user. Or you can have inter app kind of composability. So even just like an app that's on chain X and another app that's on chain Y, they're not natively composable because they're not in the same runtime.
00:13:43.810 - 00:14:00.406, Speaker B: Hyperlane allows you to build the aggregator app that makes those two apps composable. And yeah, like I said, you bring your app to users on any chain. They don't have to learn a new experience.
00:14:00.406 - 00:14:28.670, Speaker B: They already probably have a wallet that they prefer a certain custody solution on a certain chain that they're comfortable with. You don't want to enforce all of these additional frictions to your users just to use your application. Any friction in the initial onboarding experience is going to massively limit your ability to scale your audience and your customer base and then get rid of this platform risk.
00:14:28.670 - 00:14:48.646, Speaker B: So this is a little bit out of date, but we're going to talk briefly about the lowest level primitive that Hyperlan exposes to you guys, which is the Messaging API. And then we're going to talk about interchange accounts. And then I deployed interchange queries today, so we're going to talk about that too instead of the other examples here.
00:14:48.646 - 00:15:28.606, Speaker B: So Messaging API, basically there's kind of two smart contract interfaces which are necessary to be implemented when using Hyperlink. So on the sending side, you have to basically dispatch mail to an outbox on the source chain, which specifies the identifier of the destination chain that you want to send the mail to the recipient address on that chain to receive the message and then the message itself. And you can see here that the message is just arbitrary bytes.
00:15:28.606 - 00:16:04.490, Speaker B: So we're not enforcing any specific application message encoding on you, really. This is a very low level primitive and you can do a lot with it. And then on the receiving side, in order to receive a Hyperlane message, your contract needs to implement this interface called Imessage recipient and specifically this handle function which takes in an origin chain Identifier, the sender address on that chain from the origin chain and then the message that was passed by the protocol.
00:16:04.490 - 00:16:59.638, Speaker B: And it's important to note that I guess we need to implement this specific interface and actually also access control this function to the Hyperlain protocol because otherwise anyone could just spoof any sort of like cross chain message by calling your smart contract and pretending that it's coming from some chain when it's actually not. And that has a bunch of security implications which again I'm trying to stay away from, but happy to answer questions. So yeah, this slightly annoying that you have to deploy contracts on both sides of the message lifecycle like the sending chain and the receiving chain because it basically means you have to manage an application which is deployed on all these different chains and it can get kind of complicated.
00:16:59.638 - 00:17:40.986, Speaker B: Again, we've built out a bunch of developer tooling to make that much easier. But I want to talk about this concept of interchange accounts which is basically kind of like a middleware implemented on top of the messaging API that slightly constrains the messaging coding but makes your job as a developer potentially much easier in terms of orchestrating and deploying and managing your app across end chains. So the messaging API that we just looked at, again, doesn't enforce a specific encoding.
00:17:40.986 - 00:18:36.270, Speaker B: It could be structured arbitrarily, you could have like JSON in there if you wanted to. And if you want to implement an application specific feature like you're transferring an asset in an asset bridge or you want to do a swap or whatever it is, you have to implement that as like a specific messaging coding on top of the messaging API. But if we constrain the messaging coding to basically actions which can represent kind of like the entire set of actions that can be taken on a destination chain and we leverage some properties of the EVM mainly like the create to opcode.
00:18:36.270 - 00:19:25.962, Speaker B: We can actually create these accounts on remote chains that are controlled only by smart contract on the source chain. And so this allows you to basically have a smart contract on chain A that holds assets on chain B or does like atomic actions on chain B. And yeah, basically the way this works is like there's an interchange account that's deterministically created from the source chain contract and that Interchange accounts bytecode basically restricts any incoming function calls to the source chain contract.
00:19:25.962 - 00:20:28.210, Speaker B: So if you want to make one of these interchange account actions, you basically relay it through the interchain accounts API from the source chain contract, and then the hyperlane protocol will go and relay that to the destination chain interchange account, which will implements this handler that basically has access control saying, you know how we saw the messaging API here? Basically saying that only this origin chain and this origin sender mainly the interchain account owner can run this function. And so the nice property we get from this API is like now you can only implement Hyperland interfaces on the sending side. You don't have to worry about deploying contracts on the receiving side because the hyperlane protocol will go and deploy these interchange accounts for you automatically whenever you route through this API.
00:20:28.210 - 00:21:10.554, Speaker B: So you can basically dispatch API encoded calls to be made from your interchain account on another chain and kind of like the middleware wraps up all of the messaging API receiving. So an example use case of this type of pattern is crosschain governance. So the way crosschain governance works today typically is like voting happens usually on one chain, like the hub chain.
00:21:10.554 - 00:22:03.614, Speaker B: And then there's some basically either trusted multi SIG or Oracle solution to take the results of a vote that happens on a hub chain and actually propagate or broadcast that result to all the destination chains to perform the specific governance proposal that was encoded on the source chain. However, with interchain accounts, if you have a Dao contract that dispatches governance proposals to the interchain accounts API on the kind of receiving chain side of things, you can basically just set the owner of contracts that you want. To be controlled by a dow on another chain to the interchange account of that dow.
00:22:03.614 - 00:22:25.190, Speaker B: And you basically have gotten cross chain governance for free. So just like one example, yeah, I think the Interchain accounts API has, I guess makes it much easier to work with the hyperlain system. So definitely recommend you guys check it out on the docs.
00:22:25.190 - 00:22:54.098, Speaker B: And then I also wanted to highlight the Interchange Query System, which is like super new deployed on testnet today. But yeah, Phil's like another kind of like middleware developer primitive that basically just makes it easier to work with the hyperlan system. So I think you'll notice in the messaging API that there's no kind of like native callback support.
00:22:54.098 - 00:23:19.770, Speaker B: So let's say you wanted to go and dispatch an action to some other chain and get the result of that action and then return back to the calling contract and then resume execution. It's not super obvious how you would do that with this API. Maybe it is obvious to you, but we've found that it's somewhat difficult for people to understand how to implement callbacks.
00:23:19.770 - 00:24:02.310, Speaker B: And so we wanted to build out this kind of like interchange query system that just lets you read remote smart contract state on other blockchains, just like a super simple API. Now that we have basically on any hyperlain supported chain, this now becomes accessible to any smart contracts. And again, the nice property is the receiving contract or the contract which is being queried doesn't need to implement a hyperlane specific interface because we're just dispatching API encoded calls to be run against those to be run against contracts on the remote chain.
00:24:02.310 - 00:25:04.070, Speaker B: So, yeah, you can basically with this API dispatch a sequence of function calls and provide a set of callback function selectors to actually receive those query results. So hopefully you're familiar with how function selectors work in the EVM. But the basic idea here is you need to provide some way on the source chain to resume execution or kind of like recover the stack once you receive the message back from the remote chain of like, what was the value of the query on that chain? And so these function selectors basically say, what functions should I run once my query resolves and I've gotten a return value? What functions do I need to run on the source chain to kind of resolve that value or consume that value? Because we don't have an Async Await syntax in Solidity or the EVM.
00:25:04.070 - 00:25:35.160, Speaker B: But something you could build with this Interchange query system, which I was toying around with hacking this weekend, is actually an Async Await syntax in Solidity that gets transpiled down to the Interchange queries API. Just as kind of a fun demonstration that you can have Asynchronous smart contract runtimes and it just takes a little work. So, yeah, here's like a Quick.
00:25:37.290 - 00:25:37.606, Speaker A: Or.
00:25:37.628 - 00:25:54.854, Speaker B: This is just the API. So, yeah, it's kind of similar to the Interchange Accounts API, except instead of it just being like a sequence of calls, you also have to provide the callback. Again, this is compatible with legacy contracts.
00:25:54.854 - 00:26:06.270, Speaker B: So you can make let's say you're on polygon. You can go and make smart contract queries against uniswap v three. You can go and get price data from Ethereum.
00:26:06.270 - 00:26:29.906, Speaker B: These sorts of things aren't possible right now. And this is an example that I just put together really quickly. Sorry for the lack of syntax highlighting, but yeah, basically this is an example of querying ENS for the owner of an address from a chain which is not Ethereum.
00:26:29.906 - 00:26:45.206, Speaker B: So you can just take the ENS interface. You can figure out what label do you want to query on the ENS registry. In this case, we don't actually have the Hyperlain ETH domain.
00:26:45.206 - 00:27:15.320, Speaker B: Maybe we should go buy it. But yeah, if you wanted to query the owner and the expiry of the owner of that domain, you just abi encode calls to the ENS registry on Ethereum and then you use the Interchange queries API to go and query that in an Asynchronous way. You'll see that we have the resolve owner and resolve Xpri selector here.
00:27:15.320 - 00:27:20.040, Speaker B: So basically these two functions will be run with the return value of.
00:27:22.170 - 00:27:22.534, Speaker A: What.
00:27:22.572 - 00:28:00.766, Speaker B: Was basically queried on Ethereum. I'm still thinking about what the right interface here is. This is a little awkward for a way to implement callbacks, but yeah, I just wanted to give a quick example and yeah, you could imagine building some sort of like so this requires someone to do a round trip between chains and so let's say my contract queries some uniswap v three price oracle.
00:28:00.766 - 00:28:19.850, Speaker B: Let's say it's like USDC and ETH, I want to go get that price. And then some other contract makes the same query. Both of those queries, both of those queries are going to require round trips between the two networks, which kind of sucks.
00:28:19.850 - 00:28:46.180, Speaker B: So another idea for the hackathon is like maybe implementing a caching system with this interchange queries API and ENS is especially amenable to this. That's why I picked it as an example because there's this explicit Unix timestamp expiry attached to every kind of relevant piece of state on the ENS registry. So you could very easily build.
00:28:47.990 - 00:28:48.306, Speaker A: Kind.
00:28:48.328 - 00:29:12.250, Speaker B: Of like cross chain ENS cache contract that not only saves round trips but actually has atomic resolution of maybe addresses which are like popular queries. And the same can be said for other types of interchange queries. This was just the example I picked.
00:29:12.250 - 00:29:26.960, Speaker B: But yeah, I think we're at the timestamp so I wanted to give an opportunity for people to ask questions. That was probably a lot to get through, but yeah.
00:29:29.810 - 00:29:30.222, Speaker A: Yes.
00:29:30.276 - 00:29:49.570, Speaker B: So it will work between roll ups and what's nice is you don't have to wait the optimistic period, right? So all these use cases are optimized for low, latency and high security. So right now I think we're on optimism. Arbitram.
00:29:49.570 - 00:30:03.414, Speaker B: I'm trying to remember what other roll up chains we're on. I think that might be it for now, but those are the, I guess most in demand ones. But yeah, it's very easy for us to expand to new EVM environments.
00:30:03.414 - 00:30:46.774, Speaker B: So if there's like a specific chain that we're not on and you can check that in the docs, but if there's a specific chain that we're not on, we can definitely talk to you about expanding maybe like even tomorrow or something like that. You can that's a great question. So the way our relayer implementation works is it will only include transactions whether they're callbacks or just cross chain messages in general, the transaction will only be included if it's expected to not revert.
00:30:46.774 - 00:31:14.130, Speaker B: And so what that means is in your callback receiver, let's say resolve expiry or whatever in the implementation of that function you could have a reverting condition which says this much time must have elapsed between when I dispatched the query and when the callback is being resolved. And that's kind of like how you could schedule callbacks.
00:31:16.390 - 00:31:28.626, Speaker A: Yeah, sorry, it's a little hard to hear. Yeah.
00:31:28.648 - 00:32:02.080, Speaker B: So what's the security model basically of energy queries? Yeah, great question. So hyperlane is like an example of generalized message passing which is a generalization of asset bridging which has been demonstrated as super insecure and super shitty and probably shouldn't trust any of these things. So we're kind of like making what we think is like a fairly novel security trade off.
00:32:02.080 - 00:32:52.970, Speaker B: We're basically establishing a distributed set of proof of stake validators that sits between all of these blockchains. They're actually staking on the source chains instead of kind of like guaranteeing that we can prevent fraud in kind of like, let's say the return value of one of these interchange queries. Instead, what we can do is we can guarantee that there's an economic cost to fraud, a minimum economic cost to committing fraud associated with a message that is sent outbound from a chain where hyperlan validators are staking.
00:32:52.970 - 00:33:16.130, Speaker B: And we can do that because if those validators sign something which is not committed to by an accumulator that we have in our smart contracts, we can provide a fraud proof which basically slashes them. And so we haven't actually defined all of the economics around the system right now. Right now the validator set is permissioned.
00:33:16.130 - 00:33:36.970, Speaker B: So to some extent you have to kind of trust the existing operators. You can check out our docs and the discord to both see who the validators are. They're fairly reputable organizations around the space, but also you can talk to them in the discord.
00:33:36.970 - 00:34:15.990, Speaker B: But yeah, right now it's a permission set. So you do have to kind of trust the I guess, quorum of signers in that set. But we're hoping in basically the next month or two to transition to this permissionless proof of stake validator set where instead of just like social trust or like reputational trusts, we have full economic security model which basically most of these other bridge systems have not really implemented effectively.
00:34:15.990 - 00:34:42.110, Speaker B: So yeah, great question though. I mean, like that's kind of like the core differentiation of our protocol versus some of the other generalized message passing protocols out. There is this economic security model that has actual enforceable slashing conditions and smart contracts so you can have strong guarantees of what the cost is to commit fraud.
00:34:42.110 - 00:34:52.660, Speaker B: Which is not true of basically like most other security models. Any other questions?
00:34:57.290 - 00:34:57.750, Speaker A: Cool.
00:34:57.820 - 00:35:13.910, Speaker B: Well, yeah, thanks guys for coming. I'd love to see you guys hack on Hyperland. There's four hackathon bounties in general, just like if you use any of these APIs, it's pretty likely that you'll get one of the bounties.
00:35:13.910 - 00:35:47.522, Speaker B: But we have like a DeFi, an NFT, an infrastructure category, infrastructure, kind of like thinking more as like a developer tool or maybe one of these additional middleware smart contract systems like the cash thing I was talking about. And I think we just have like a general category. I think it's don't want to mess the number up, but I think it's like 10,000 USD in total up for grabs.
00:35:47.522 - 00:36:07.020, Speaker B: So yeah, a lot of potential bounties at play here. Another great thing about using hyperlane for the hackathon is it's fairly easy to integrate. So you could totally stack a hyperlane bounty on one of these other protocols and double your money.
00:36:07.870 - 00:36:11.020, Speaker A: Yeah, cool.
00:36:12.370 - 00:36:16.990, Speaker B: Yeah, this is not financial advice.
00:36:19.970 - 00:36:20.430, Speaker A: Awesome.
00:36:20.500 - 00:36:28.990, Speaker B: Yeah. Thanks guys for coming. I'll be around the venue all weekend, so if you have questions or need help with anything, we have a booth upstairs.
00:36:28.990 - 00:36:30.420, Speaker B: Definitely come out.
00:36:35.830 - 00:36:37.170, Speaker A: It oh, yeah.
00:36:37.240 - 00:36:45.780, Speaker B: Last shameless plug is we're also hiring. We just completed our seed rounds. We love to talk to you.
00:36:48.550 - 00:40:07.440, Speaker A: All. It's possible it slideshow really? No, not it. Yeah, this actually get down here.
00:40:07.440 - 00:41:04.980, Speaker A: You. It beginning swap it whenever or cool.
00:41:07.430 - 00:41:17.618, Speaker C: Thanks for coming. So there are two parts to this session. I'll explain the Streamer network and Nico will explain the data unions that run on top of Streamer.
00:41:17.618 - 00:41:51.066, Speaker C: So there are two separate prizes, one for all good, one for using streamer, one for using the data union dao. So I'll go through what is Streamer, how to use it, I'll then talk through some ideas of what I think could be great hacks and then on to Nico for data unions. So what is streamer? So it is a decentralized peer to peer Pub sub network.
00:41:51.066 - 00:42:28.250, Speaker C: It means that data gets streamed to any number of ethereum accounts in real time. And the role of the network is to move data from the publishers to all the subscribers over a decentralized networking topology. So if you're familiar with Pub sub channels or topics, streamer has streams and they mean the same thing and can be any number of publishers, any number of subscribers protocol scales based on this principle of shared responsibility where the users contribute their own bandwidth to support the topologies.
00:42:28.250 - 00:42:46.094, Speaker C: So yeah, this is more a definitions slide. So we get asked these questions a lot. It's not a blockchain, so it's classical networking technologies but it does have touch points in the blockchain.
00:42:46.094 - 00:43:00.262, Speaker C: So it's an ephemeral data transport. But we do also have support for data resending through the storage nodes that we run. And note there is a liveness requirement for this.
00:43:00.262 - 00:43:19.930, Speaker C: So the storage nodes store the encrypted data but you need to have the publishers online to be able to do the key exchange. So that's one small gotcha that you need to be aware of. But essentially the Streamer network provides this infrastructure for many to many data pipelines.
00:43:19.930 - 00:43:57.080, Speaker C: Our access control is online, so this is one of the main touch points in the blockchain. All the data is cryptographically signed, every single data point signed by the private key of the user and comes with end to end encryption out of the box if you choose to use it. It's also free to use as well with the slight caveat that you just need to pay a cent or two for gas to create the stream and any sort of edits on the permissioning layer, the on chain access control.
00:43:57.080 - 00:44:32.900, Speaker C: So in the web two world what we're replacing is this centralized data piece, the the data center. So to move a lot of data around in real time, the Pub sub model is to decouple the publishers from the subscribers using some beefcake server in the middle that can scale up and handle anything that comes at it. But of course we know that this is centralized and we don't want to build our apps that are dependent on google cloud for example.
00:44:32.900 - 00:45:07.470, Speaker C: So the streamer network looks quite different in that it appears more as like this. If the web two way was this vertical flow of data through data centers run by the Silicon Valley giants. The streamer network is the data flows horizontally through this overlay mesh network that is made up from the users of the network, the users that are intrinsically interested in the data from the topics or streams of the network.
00:45:07.470 - 00:45:26.674, Speaker C: So at this point it's good to jump into an example. So this is the streamer network website. It's just like any other website, loads JavaScript and loads image assets from a centralized point.
00:45:26.674 - 00:45:50.262, Speaker C: But if you scroll down the fold you'll reach a data feed. And what's interesting about this data feed is that it's a stream on streamer and the data is not coming from a centralized source, it's actually coming from other visitors that are on the streamer network website at the same time as you. So this is a peer to peer data feed inside the browser.
00:45:50.262 - 00:46:14.130, Speaker C: So while you're visiting the streamer network website, you are becoming a light node in the system. So this is the network Explorer. So I've plugged in that stream ID in the top left there and what it returns to me is the visual representation of what that network looks like.
00:46:14.130 - 00:46:41.530, Speaker C: So in one of these is the actual publishing script but the rest of these nodes are other visitors on the visiting the streamer network website and more likely than not, this is where you are pulling the data from. Okay, so on to the access control. So the on chain stream registry is on polygon.
00:46:41.530 - 00:47:01.380, Speaker C: This is the network source of truth. So it defines who can do what on the network. So on these streams you can typically publish or subscribe and the blockchain looks to this registry to determine who can do what.
00:47:01.380 - 00:47:20.634, Speaker C: And it also unlocks some interesting smart contract access control policies. So this piece, this module, if you're familiar with the lit protocol, it's quite similar. We rolled our own permissioning system for the network but perhaps it could be composable with lit as well.
00:47:20.634 - 00:48:11.542, Speaker C: So this is an open question, maybe it gets answered in the hackathon this weekend. So here is a different view of the access control fine grained permissions, publish, subscribe, changing permissions, edit and delete and whatnot and yeah, like I mentioned, you can start to get a bit creative with these access controls. So you could have a token gated pub sub channel perhaps there's stake to Pub sub different kind of primitives that you can bake to the access control and on our marketplace that Nico will speak to more we have time based pay to access subscriptions.
00:48:11.542 - 00:48:27.502, Speaker C: So this also composes to the access control. You pay tokens to get a time based access or subscription access to a certain stream. So getting into the tooling now.
00:48:27.502 - 00:48:40.402, Speaker C: So the streamer client is your best friend. To make all of this work. So it's designed to be this wrapper that interfaces with the onchain stream registry and the network and it bundles in the light node as well.
00:48:40.402 - 00:48:58.962, Speaker C: So it really kind of takes care of you from all different angles. So you will need a little bit of matic to interact with the stream registry and we're happy to sponsor this of course, so just reach out to us if you need any matic. And it's just an NPM package.
00:48:58.962 - 00:49:22.382, Speaker C: So the Streamer client runs in the browser as well as any sort of node JS environment. Also a shout out to the examples repo has a bunch of code samples to learn from as well. So if you're stuck, head there and we also make it really easy as well.
00:49:22.382 - 00:49:42.198, Speaker C: So we can also create a stream using a user interface. So just using MetaMask or whatever wallet that you have available, you don't even need to touch code to be able to create streams and edit the access control. So it's a nice way to get started, I think.
00:49:42.198 - 00:49:53.046, Speaker C: So this is what's called the Core app. You can visit it at streamer network core and it's super easy. So this is the stream.
00:49:53.046 - 00:50:06.542, Speaker C: ID that I'm configuring here. So the ID is made up of the Ethereum account that creates the stream plus some path name. And this can also be your ENS name.
00:50:06.542 - 00:50:25.790, Speaker C: It will kind of scoop this up from the ENS registry. And in the share settings sidebar you can edit the access control but you can do all of this within the Streamer client as well. And we have Docs.
00:50:25.870 - 00:50:26.530, Speaker A: Yay.
00:50:31.370 - 00:50:46.086, Speaker C: The client is JavaScript Implementation. So if you are building or integrating with a different language, there is a solution for you here. We have what's called broker nodes.
00:50:46.086 - 00:51:13.694, Speaker C: So you would need to run a broker node and open up its interfaces. So it has three interfaces WebSockets, Http and MQTT and just about every single language ever written has these sorts of libraries built into them. So you can publish and subscribe, push and pull into the network using these interfaces if you run a broker node.
00:51:13.694 - 00:51:38.118, Speaker C: So this is an option if you want to work with a different language for the most part. So we have this kind of gateway into the network if JavaScript isn't your thing. So what can be built with the network? One of the most native and most interesting use cases I think is like a decentralized group wallet chat.
00:51:38.118 - 00:52:06.734, Speaker C: So this is using the network for decentralized real time communications between Ethereum Identity Wallets. So a chat room is just a stream and the participants in this chat room have publish and subscribe permissions to write messages. These messages are being signed so you absolutely have full proof that you are talking to who you are talking to.
00:52:06.734 - 00:52:29.094, Speaker C: And there are no servers here, so if you don't count where the JavaScript came from, from the single page application. This is a totally serverless experience extensions to this, creating token gated chat rooms, et cetera, et cetera. Token gated experiences.
00:52:29.094 - 00:52:42.110, Speaker C: This is quite a powerful primitive to build on. Okay, so very long list. Yeah, it all fits in, luckily.
00:52:42.110 - 00:53:08.770, Speaker C: What should you build with Streamer? I think obviously your creativity should guide you, but here are some concepts that often come up as useful. So like I think I talked to the access control policies for Streams you can do a lot. There decentralized metrics gathering and web three open data sharing.
00:53:08.770 - 00:53:44.318, Speaker C: So this is about collecting fine grained metrics from other decentralized systems and using the network to interconnect and kind of improve on decentralized systems without having to reach for centralized solutions to be able to monitor the health of the network in real time. So I think this is quite a rich use case and it can be stacked with many other networks that are also sponsors. Here today wallet to Wallet communications.
00:53:44.318 - 00:54:12.434, Speaker C: I showed you the chat app. So this is what it is essentially off chain multisig chat and conviction voting. So imagine the chat app but with your multisig participants from Gnosisafe for example, you can build conviction over what to vote on and so on in this off chain experience group chat plus lens protocol, I think this would be fantastic.
00:54:12.434 - 00:54:37.766, Speaker C: Protocol stack interconnection so if you have IPFS and it needs to talk with live peer or whatever, then you could use Streamer as this middleware to have this decentralized communication between your stack. We have decentralized wireless network proof of coverage. So this is a bit of a long shot for a hackathon, but something to think about.
00:54:37.766 - 00:54:57.850, Speaker C: If you can create kind of a coverage map for decentralized wireless networks, then yeah, it can feed into the proof of coverage algorithm. So this is fantastic. First mile data transport from data providers to Oracles.
00:54:57.850 - 00:55:13.600, Speaker C: So this is from the provider up until the Oracle. The streamer network is a great technology solution for this. Redstone is one of the kind of next generation Oracles that are using us in this way.
00:55:13.600 - 00:55:39.350, Speaker C: Multiplayer gaming, real time state share, I think that's one quite clear and RPC load balancing, which is not clear. So I will speak briefly to this one. So this is kind of just an internal idea that we have to scale the RPC centralized point in many blockchains.
00:55:39.350 - 00:56:09.262, Speaker C: So yeah, typically if you have this very popular DAP and they're polling the RPC, it's quite a heavy load for the RPC, 10,000 users, 10,000 requests a second if it's fast polling, for example. So that's not great. What we can offer is to use the streamer network to sort of load balance these RPC calls.
00:56:09.262 - 00:56:35.100, Speaker C: So how this would work is you would have these kind of watcher nodes that would do the RPC request as many as you want for as much decentralization as you want. But then your DApps would be interconnected and kind of pulling in the data that originally came from that RPC load. Sorry, that RPC endpoint, they would be getting it from each other.
00:56:35.100 - 00:57:05.774, Speaker C: So this is where the shared responsibility of the streamer protocol comes in. It's kind of similar to what we showed with the streamer network website, where you're getting the data from your visitors. So in this way, we take all the pressure off that RPC endpoint and you can kind of start to imagine other sort of use cases where there is this central point or central data publisher that can get overloaded.
00:57:05.774 - 00:57:27.622, Speaker C: So if you have this system where you sort of protect it with the streamer network where the messages are coming from the other participants, it becomes quite an easy scale solution. So, yeah, this is something to think about. Okay, moving on to data unions.
00:57:27.622 - 00:57:29.626, Speaker C: And Nico will take over.
00:57:29.808 - 00:57:38.330, Speaker D: Awesome. See if I can get this thing a bit down because I'm not as tall as you are. Thank you, Matthew.
00:57:38.330 - 00:57:43.482, Speaker D: Hi, guys. I'm Nico. I'm the Devra engineer for Data Union Dao.
00:57:43.482 - 00:58:00.150, Speaker D: And Matthew just told you how you can handle all the data stuff, and I'm going to now tell you how you can actually monetize this data. So let's jump in. So first of all, how you monetize this data? You monetize it with a data union.
00:58:00.150 - 00:58:22.258, Speaker D: What is a data union? It's an organization with an application where individuals participate in the creation of valuable data. So what does that mean? It means members generate data through data union's application, which crowdsources data. And in the streamer context, this data can then get sold on the streamer marketplace.
00:58:22.258 - 00:58:36.286, Speaker D: And I'll talk about that more in a minute about the marketplace. And with a data union, you can essentially monetize your data streams. So with the data union.
00:58:36.286 - 00:58:58.882, Speaker D: Dao offers the data union framework. And this contains a smart contract template that handles payment distribution for the data union and a TypeScript based SDK that handles all the interaction with the data union or with the smart contract. And this SDK is an NPM package.
00:58:58.882 - 00:59:10.874, Speaker D: And I will talk about that more in a minute. And we also offer server architecture for your member management. So let's see how this payment distribution works.
00:59:10.874 - 00:59:33.300, Speaker D: So you can see here wait, do you see if I move my mouse? No. Okay, well, you see this center contract there? And as I said, it is a smart contract. And essentially money gets or token gets sent into that contract and then distributed to the different members.
00:59:33.300 - 00:59:49.314, Speaker D: I'm just going to talk you through how this kind of works. So you've got an admin and that's going to be your project, right? So you have an Ethereum address that publishes or deploys that contract, and that's going to be the automatic admin. And this admin can then add members.
00:59:49.314 - 01:00:26.398, Speaker D: So essentially the data publishes, right? And then the admin can set an admin fee which will result in this I don't know if you can see the 30%, for example, and you can configure that in the way you want, really. And then if token gets sent into that contract, the admin for example, gets 30% and your data union members will share the 69% of those incoming tokens. 69, because 1% of that of the 100% go to the data union.
01:00:26.398 - 01:01:01.662, Speaker D: Dow and we use this 1% for funding new projects, going to hackathon and those kind of things. Yeah, and once the token gets sent to the smart contract so that could, for example, happen on a marketplace, right? So your data gets someone pays to be able to subscribe to your stream and those token then get sent to that smart contract. And then again your members are able to withdraw their token or they can just accumulate it over time and take them out whenever they want.
01:01:01.716 - 01:01:02.320, Speaker B: Really.
01:01:03.650 - 01:01:20.502, Speaker D: Right, so we have the smart contract and we have the SDK. And the SDK enables you to interact very easily with the contract. As I said, it's just an NPM package and you can really just it's really those few lines of code.
01:01:20.502 - 01:01:50.794, Speaker D: We have more interaction with the contract with this, the essential lines, you can deploy the data union with the SDK, you can set the admin fee, you can add members, remove members, and also withdraw your tokens from there. Alternatively, you can also use the streamer core. Matthew briefly talked about this and it's essentially a front end where you can deploy the data union.
01:01:50.794 - 01:02:15.666, Speaker D: And it's got a nice interface where you can add the name, your admin fee, and even your streams that you want to monetize. Right, and then about the marketplace, you can then publish this data union onto the streamer marketplace. So they're like different data products where all the streams are sent on the marketplace.
01:02:15.666 - 01:02:39.978, Speaker D: And then Data buyer can subscribe to those streams for token, like they will pay for it. By the way, those tokens don't have to be the streamer data token, they can actually be your own custom token. Right, we also have documentation, there will be a little bit of a guide how you can actually deploy data union.
01:02:39.978 - 01:02:52.494, Speaker D: One way is with streamer and the other way is just programmatically with the SDK. Yeah, an example would be, for example, for dataunion is Swash. So Swash is a browser extension.
01:02:52.494 - 01:03:07.750, Speaker D: It's very easy. So you just install your Swash plugin into your Chrome browser, join that data union, and then you can share your browser data and earn by sharing your browser data. So it's actually quite clever.
01:03:07.750 - 01:03:27.520, Speaker D: And then if you're still looking for an idea what to build, EMRA, our community manager, he did a great blog about some ideas that you can build at this hackathon. So feel free to go to this link and check it out. I highly, highly recommend.
01:03:27.520 - 01:03:57.858, Speaker D: And yeah, we're giving out $10,000 in prices. So one track is building with Streamer and the other track is building with Data Union. So I really really recommend integrating this into your project and yeah, I think it works very well together streamer Data Union anyway and if you've got any questions, feel free to reach out to us on Telegram.
01:03:57.858 - 01:04:20.560, Speaker D: You can also join the Discord server of Data Union or of Streamer and will be present there too. And of course the one of ETH Global as well. Cool, right? Do you want to add anything? Okay, so if you guys have got any questions, we're here to answer.
01:04:33.500 - 01:04:34.250, Speaker B: Cool.
01:04:38.700 - 01:04:55.160, Speaker D: No, we don't know. Not in the moment. Yeah, we can, we can, we can we sponsor we sponsor the transaction fee to actually deploy the contract and Stream.
01:04:55.240 - 01:04:55.870, Speaker B: Yeah.
01:05:08.990 - 01:05:23.930, Speaker D: Ideally you do it. So if you built with Stream it, I would recommend doing it on the front end and then you will see how you can add the payment and how much it costs and all that kind of stuff and then publish it to the marketplace.
01:05:25.870 - 01:05:34.660, Speaker A: You is actually post.
01:05:40.870 - 01:05:41.620, Speaker D: Yeah.
01:05:43.350 - 01:06:15.930, Speaker C: So this is this is kind of like the cutting edge of what we have out of the box on the access control. So it's basically in PR at the moment for a very complete code example that is on the chat repo. So you will need to kind of dig there and we have the contracts that do talk to the access control there.
01:06:15.930 - 01:06:31.950, Speaker C: But this is like very well I'll just say it's not documented at all. Like this token gating kind of twist to the access control. It's not like the core functionality of the network.
01:06:31.950 - 01:07:14.690, Speaker C: So I guess we have some catching up to do on that documentation but we have accomplished kind of feature completeness on the chat app that I showed and that's open source. And so there's a few caveats here that the chat app Token Gating is just for ERC 20 tokens on the polygon chain and there's a PR out there for NFT token Gating. So it's very fresh and very hackable to kind of build this in but it's not quite as easy as just taking Lego blocks at the moment.
01:07:14.690 - 01:07:44.734, Speaker C: So we have the examples there but it's quite cutting edge. Think it's too hardcore for me. I think the access control you would need to move to Mumbai as well.
01:07:44.734 - 01:08:05.438, Speaker C: So if you're super brave yeah, don't recommend but we can sponsor the transactions, it only costs a cent to do these things. So very happy to support that. And we will have full native sponsoring of all transactions on Streamer.
01:08:05.438 - 01:08:29.560, Speaker C: It's just not ready this weekend. Any other questions? Okay, well thanks for staying up so late and yeah, really appreciate it and please reach out to us if you have any questions. Thanks.
