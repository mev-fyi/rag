00:00:06.490 - 00:00:06.942, Speaker A: Cool.
00:00:07.076 - 00:00:16.286, Speaker B: Hey, everybody, thanks for being here today. We're going to talk about bringing a superior developer experience to Web Three and how we're doing that at Fuel Labs. And we're going to cover a lot in the next 30 minutes.
00:00:16.286 - 00:00:29.958, Speaker B: So we're going to go over kind of an overview of Sway, the programming language, the VM, and kind of what makes Fuel such a good option for building DApps, and then going to talk about specifically like, going through a workshop. So if you have your laptops, you'll be able to go through it either in real time or you can go.
00:00:29.964 - 00:00:31.106, Speaker A: Through it during the hackathon.
00:00:31.218 - 00:00:37.506, Speaker B: So real quick, just a quick about me. Like I said, my name is Camila. I had a kind of a more traditional path to engineering.
00:00:37.506 - 00:00:51.526, Speaker B: I studied computer science in college. Then I started my career at PayPal, where I was an engineer, before moving on to developer relations almost two years after that. I did devrel for Web Two for maybe like a year before pivoting over to crypto.
00:00:51.526 - 00:00:55.486, Speaker B: I've been working in crypto full time since April of this year, and now.
00:00:55.508 - 00:00:57.790, Speaker A: I'm the head of Developer Relations at Fuel Labs.
00:00:58.450 - 00:01:10.366, Speaker B: So before we start, let's just kind of get like a ground zero where we're all under the same understanding. So when we talk about a tech stack, I find it easiest sometimes to try to map the Web Two tech stack to the Web Three tech stack and kind of draw those relationships so.
00:01:10.388 - 00:01:11.726, Speaker A: We'Re both clear on what it is.
00:01:11.748 - 00:01:15.014, Speaker B: That we're talking about when I say certain things. So when you're building in Web Two.
00:01:15.092 - 00:01:17.686, Speaker A: These kind of five pieces basically are.
00:01:17.708 - 00:01:38.954, Speaker B: The primitives that let you build pretty much anything, right? You have APIs, authentication database, client side frameworks, and file storage. So now if you take that similar idea and kind of try to map it over to Web three, it's not a one to one, right? Because there's a different paradigm to building, but you can kind of map a similar map of all of the different pieces. So this is back from when I was at Edge and no, the team there did research.
00:01:38.954 - 00:01:45.038, Speaker B: This was a year ago, actually almost exactly where we published this research. And as you know, stuff in Web Three moves super fast.
00:01:45.124 - 00:01:47.182, Speaker A: So a year ago, things were way.
00:01:47.236 - 00:01:54.350, Speaker B: Less mature and way more nascent than they are now. So there was a much bigger need to define what a working tech stack could look like at the time.
00:01:54.420 - 00:01:56.082, Speaker A: And this is what they came up with.
00:01:56.216 - 00:02:14.198, Speaker B: So you see you have your layer ones, you have your layer twos, you have your development environments, file storage, indexing and querying, oracles, Identity, Wallet, and client. Okay, so Fuel Labs, that's the organization that I work at. We're building Fuel, and I kind of like to nickname it a layer two, but better.
00:02:14.198 - 00:02:17.042, Speaker B: But the official term that we use is a modular execution layer.
00:02:17.106 - 00:02:19.622, Speaker A: So what that means is that instead.
00:02:19.676 - 00:02:39.262, Speaker B: Of it being just a layer two in maybe the sense of like it being a roll up or a side chain or whatever kind of different types of layer twos there are, it's an execution layer that can be plugged in. It's the engine that can be plugged into any different L one or to any different configuration where you can have Fuel as a side chain, you can have Fuel as a roll up, you can have Fuel. We don't recommend it, but you could have Fuel running as a monolithic L one.
00:02:39.262 - 00:02:55.318, Speaker B: You could have all of these different configurations. And that's kind of the whole modular idea is that you as a protocol developer can define what you want your chain to look like and you can say, I want to use Fuel for execution or I want to use Fuel for execution, but I want to use it as like a side chain or something like that. And the three pillars that we're going.
00:02:55.324 - 00:02:58.838, Speaker A: To talk about are performance wait, so small my screen. There we go.
00:02:58.924 - 00:03:17.386, Speaker B: Performance, flexibility and waste reduction and developer experience. And the two that we're going to focus on today are performance and developer experience just because we don't have a bunch of time. So for those who might be like, oh, what's a modular execution layer? What does that mean exactly? So really what it means is that blockchains have these four functions and we have a bunch of reading on our website if you want to kind of learn more about this.
00:03:17.386 - 00:03:37.454, Speaker B: But basically, blockchains have four functions and when you have a monolithic chain, the node is stressed trying to do all four things right. So you have this limited set of computation power and then you have to divide that by all these different functions. And the thesis of modular is that if we can separate these out, we can have higher performance on each layer individually.
00:03:37.454 - 00:03:44.654, Speaker B: So when you combine them, you have higher performance in general. So what Fuel does is it offloads just execution. So the chain only handles execution.
00:03:44.654 - 00:03:54.582, Speaker B: It doesn't worry about if something is correct, it doesn't worry about settlement, it doesn't worry about consensus. It just executes all of these state changes. So it'll execute all your transactions and then post them back to the L one.
00:03:54.582 - 00:03:58.550, Speaker B: And then the L one is in charge of saying, what order are we going to put these in?
00:03:58.620 - 00:03:59.590, Speaker A: Blah, blah.
00:03:59.930 - 00:04:19.310, Speaker B: So again, the Fuel VM is designed to be modular and it can plug in as the execution engine for any blockchain. It's kind of like the thing to note. All right, so when we talk about Fuel building the fastest modular execution layer, how exactly are we doing that? What are we building that makes it such? So the three things that we're going to focus on are parallel transaction execution, the sway language and the Fuel VM.
00:04:19.970 - 00:04:24.222, Speaker A: So I made this meme laugh because.
00:04:24.356 - 00:04:57.190, Speaker B: The vibe is, how do we stay in the Ethereum ecosystem, right? Because we all, for one reason or another, are like either value aligned, technology aligned, whatever aligned with Ethereum. But how do we take what we know and love about Ethereum and improve it? So the thesis of Fuel is like, how can we bring a more safe, smart, contract language? How can we bring a more performant VM while staying in the Ethereum ecosystem? So let's talk about what we mean by parallel transaction execution and what that actually means. So the EVM, which is a virtual machine for Ethereum versus the Fuel VM, which is the Fuels virtual machine.
00:04:57.190 - 00:05:07.290, Speaker B: So the EVM is single threaded, and because of that, it can only process transactions sequentially. So what that means is it can only process one transaction at a time. Once that one is finished, then it tests on the next one, et cetera.
00:05:07.290 - 00:05:16.702, Speaker B: So because Fuel is UTXO based, which we don't have to get into the weeds of what that means, but basically it's a different model. Ethereum uses an account model. The fuel VM uses UTXO model.
00:05:16.702 - 00:05:38.038, Speaker B: Again, we have a lot of reading on our page where you can kind of dive into this more, but it uses all of your machines, cores and threads. And because we're a UTXO model, we have access to these things called state access lists, where what that means is it looks at the transactions and it says which ones have dependencies. Like, first you have to execute this one and then this one, let's say, right out of ten transactions, there's like these three dependencies, let's say.
00:05:38.038 - 00:06:08.274, Speaker B: So what the VM is able to say is, okay, let's execute all of the other ones that don't have any dependencies in parallel, and then the ones that do have dependencies sequentially. So just based off that, you're able to get much higher throughput just off this one improvement, right, where instead of having to do everything one at a time, you now are able to process things in parallel. So if we look at this graph, if you see the orange triangles at the top, you'll see that the number of transistors on CPUs has been increasing exponentially over the years, also known as Moore's Law.
00:06:08.274 - 00:06:25.446, Speaker B: The single threaded performance over the last years, which is the Blue right under that hasn't you can see like, it was increasing, but it's not increasing exponentially. But what has increased exponentially over the years has been the number of cores. So if you have a system that's sequential that can only leverage a single core, it's like you're running it on.
00:06:25.468 - 00:06:26.690, Speaker A: A ten year old laptop.
00:06:26.850 - 00:06:34.134, Speaker B: You want to leverage the things that are increasing exponentially year over year. And the Fuel VM is designed to do that. It's designed to be able to run transactions in parallel.
00:06:34.134 - 00:06:48.830, Speaker B: And this leads, like I said, to a vast increase in throughput if all other things are equal. So not considering any of the other improvements. Just because of this, you're able to actually access all of the cores and all of the threads of your machine, which like I said, according to this, graph is what's been growing, is what's been improving.
00:06:48.830 - 00:07:06.382, Speaker B: And it's not because you bought a better computer or a more performant machine. It's just because you're using all of the resources that in your computer are wasted in the EVM. The other thing when we talk about developer experience is that the Fuel VM uses a GraphQL endpoint instead of a JSON RPC.
00:07:06.382 - 00:07:17.542, Speaker B: If you've deployed a contract, you got to go find the RPC endpoint and you just paste that in and that's how you deploy. So with Fuel we have a GraphQL endpoint. And what that means is that you have a GraphQL API built in.
00:07:17.542 - 00:07:26.954, Speaker B: So you might have heard of the graph. The graph exists because these other networks don't have that. So you need an external service or someone else to build this layer on top of it.
00:07:26.992 - 00:07:29.980, Speaker A: And with the Fuel VM, you guys can't see this.
00:07:30.350 - 00:07:36.606, Speaker B: You can see it here with the Fuel VM, this link right here is actually the endpoint to where you deploy your contract. So if you were to click on.
00:07:36.628 - 00:07:51.864, Speaker A: This, did it open? Okay, cool.
00:07:51.902 - 00:08:00.504, Speaker B: So if you click on this endpoint, it'll take you to a GraphQL playground where you can actually start making requests right away. And you don't need an external service. You don't have to write new mappings.
00:08:00.504 - 00:08:12.364, Speaker B: You don't have to write the whole API that you have to do to use the graph. Okay, so now moving on sorry about that. So now moving on to the portion of developer experience and we're going to talk about Sway and Fork.
00:08:12.364 - 00:08:20.672, Speaker B: Sway is the rest based language and Fork is the tool chain kind of manager. So we're going to just kind of like fire through because we only now.
00:08:20.726 - 00:08:23.764, Speaker A: Have a few minutes left.
00:08:23.802 - 00:08:34.632, Speaker B: We have 20 minutes left actually, so it's fine. So we're going to kind of speed through some major points. We're not going to get into too much detail, but all of these have QR codes, so you can scan them and go into the actual specs or into the docs and read more about what I'm saying.
00:08:34.632 - 00:08:46.668, Speaker B: So our standard library is actually written in Sway. And the reason why that's notable is because a lot of other languages for blockchains are actually not written in that language. So for example, like Move, the standard library for Move isn't written in Move.
00:08:46.668 - 00:09:02.012, Speaker B: So that's like something that's really interesting about our project is that the standard library is actually written in Sway, so the standard library can move fast. And this is because you don't have to wait for the compiler devs to add features. So for example, if you're like, oh, I have an idea for a library, I want a library.
00:09:02.012 - 00:09:14.916, Speaker B: I don't know, for super scientific edition with like 27 decimals, let's say. You can just write that library and then it'll just work. So you don't have to wait for the official compiler team to build that in and add support for it.
00:09:14.916 - 00:09:22.688, Speaker B: You can just write that library yourself. So because the language is lean, it's able to move much more quickly. Is it back up? I just had a side note.
00:09:22.688 - 00:09:41.624, Speaker B: We have a grants program, and here at the Hackathon, we have a booth over at the kind of in that little corner before you go into the main stage. So if there's something that you build here and you're like, we kind of want to extend this, or we just had a great experience and we want to build something else, the grants program just opened up maybe a month ago. So it's like super open for projects.
00:09:41.624 - 00:10:04.160, Speaker B: There's about, I want to say, like 15 to 20 projects building right now on Fuel through the grants program, which is really fun. And because it's such an early developer ecosystem, well, at least for me, what I think is cool did it work? Is like, you can have a pretty heavy hand in influencing and building the developer ecosystem because it's so early. So imagine being like one of the first 30 projects on Ethereum.
00:10:04.160 - 00:10:17.160, Speaker B: That's kind of the vibe right now where it's like, we're still super early in standing up the ecosystem. So if you have an idea, you can be like the first X. So right now we have the first team building in Oracle on Fuel, which by a later stage project, they've already done that.
00:10:17.160 - 00:10:28.376, Speaker B: So any idea that you have, it's very likely that you're kind of the first person that's building this out in the Fuel ecosystem. So just a note. And we support through grants and we're building out this accelerator program to connect teams with VC funding.
00:10:28.376 - 00:10:57.568, Speaker B: If that's something that they want to pursue, to connect them with legal and marketing, if they want to pursue kind of turning this into a real company, or if you're just like, I just want to build some cool shit and get a grant to support it, that's also an option that we have. Okay, so the other thing about having a standard library, so, like Solidity, for example, doesn't have a standard library. So, you know, if you've ever tried to do an ERC 20 or ERC 721, what people typically do is they go look at a bunch of big uniswap or the big kind of orgs and see how they've done it.
00:10:57.568 - 00:11:19.404, Speaker B: And then they try to deuced and kind of like piece together what the best way to do it is. So with sue, you have this single source of truth for certain things, instead of having to compare the code that seven different orgs wrote to have a custom ERC 720 Implementation or something like that. The other thing that we have that's really cool and kind of the overarching thesis or idea around.
00:11:19.404 - 00:11:27.192, Speaker B: This is like everyone who's written in Rust loves Rust. You've never met someone who writes in Rust and they're like, I'm going back to whatever. Everyone's like fucking rust.
00:11:27.256 - 00:11:27.724, Speaker A: I love it.
00:11:27.762 - 00:11:37.904, Speaker B: And there's a reason why, right, you have this built in type safety. You have this compiler time stuff where it yells at you at compile time. It won't even let you deploy something that has these issues.
00:11:37.904 - 00:11:57.576, Speaker B: So you kind of harness that. In an adversarial environment like Blockchain, where you're dealing with real money, you're dealing with real assets, you want to be in a language and in an environment where something is saying, hey, on line 36, like you have XYZ, we're not even going to let you build this contract, much less deploy it until you address it. So these are the next few things I'm going to talk about is kind of how we do that.
00:11:57.576 - 00:12:10.748, Speaker B: So the first thing are these things called generics and some types. So generics, if you've ever written like in C plus plus or something like that, you know that you can kind of define a function but not define the type right away. You can just say for any type.
00:12:10.748 - 00:12:31.136, Speaker B: And then later on you can actually use int or string or whatever it is. So let's just say, for example, addition, you can write a function called add and then use a generic type because you're saying, I might want to reuse this logic for both INTs and floats. So instead of rewriting the function twice, you can just use this generic type so that you can basically reuse logic without having to rewrite code.
00:12:31.136 - 00:13:02.196, Speaker B: And then the second portion of this is sum types, which is kind of like unions where it's like one or the other. So let's say you have this enum called result, right? And you could have in a result, you could either have like a successful or a not successful that would be a sum type. So when you put those two things together, it allows you to I wish you could see, okay, so if you can imagine these two things together where you can define the types later and you have these sum types where it's one or the other, what happens is that you don't have to in Solidity.
00:13:02.196 - 00:13:13.024, Speaker B: You would have to rewrite this for every single type you wanted to use it on. That's the first thing. And then if you wanted to have similar logic where you're like one or the other, you wouldn't be able to do it in the same way.
00:13:13.024 - 00:13:25.620, Speaker B: And I have an example up here, so maybe when it's working, we can come back to it and you guys can see, okay, the other thing is explicit error handling. So if you guys know in Solidity, the EC recover function, do you guys know that one? Okay, do you guys know what it will return?
00:13:25.690 - 00:13:29.536, Speaker A: If a signature is invalid, it returns.
00:13:29.568 - 00:13:44.584, Speaker B: A zero just returns zero, it returns zero address. So what you have to do as a developer when this happens is that you have to go in and you have to check for the zero. Like you have to remember, say, you have to say like, if zero, like whatever, do this to handle the error and what does that mean?
00:13:44.622 - 00:13:44.776, Speaker A: Right?
00:13:44.798 - 00:14:00.716, Speaker B: Like you could forget, you could not know, or you could just straight up, I don't know, just not handle that case. Just not even out of not remembering, you could just not do it. So what that means is that you might have this variant path where you're not actually handling an error case that could be very problematic.
00:14:00.716 - 00:14:21.536, Speaker B: And in Sway we have explicit error handling. So you can't see again, but with the results that I was talking about in the last slide, we were talking about successful or non successful, you can actually wrap the return of things. So instead of if you just try to run this code and it returns nothing and you don't handle the error, sway will tell you that you're not handling the error.
00:14:21.536 - 00:14:36.444, Speaker B: First, at compile time, it won't let you build your contract, it'll say you haven't done it. And then two, it forces you to call this method unwrap on it to actually see what the error is, to actually access one level in. So in Solidity, you have to manually remember.
00:14:36.444 - 00:14:50.652, Speaker B: In Sway it's done at the language level, at the compiler level, it won't let you build, it won't let you deploy unless you actually handle all the errors explicitly. So again, what does this lead to? Safer code, better applications for end users. The other one is type inference.
00:14:50.652 - 00:14:52.944, Speaker B: Oh, did it work? It glitched over here. No.
00:14:52.982 - 00:14:53.570, Speaker A: Okay.
00:14:53.940 - 00:15:05.696, Speaker B: Type inference with the same type system as Rust. So basically it can infer the type. So even though you're writing in Rust, which is like a language where you're thinking of types all the time, you can just say let, for example, let answer equals 42 and the type will be inferred.
00:15:05.696 - 00:15:32.572, Speaker B: So you don't have to say let int or float or whatever, it'll just infer what's on the other side of the equal sign. The thing that I think is really cool is this concept of namespace storage access. So, you know, for example, in Solidity you might have like a storage variable, let's say, called count, and then you might have a local variable called like CNT or count underscore or something like that, like nomenclature where it's similar because they are related in some way in your code and that's why you name them like that.
00:15:32.572 - 00:15:47.810, Speaker B: But they do different things. One accesses storage and one doesn't. In Sway, not only do you have to define the type of storage access that a function has in the actual function definition itself, so you say read or write or both, or just write or just read.
00:15:47.810 - 00:16:09.096, Speaker B: And so that's the first thing you have to define when you define the function. And then two, when you're actually wanting to access storage, the way that it's done is storage and then the name of the variable. So what does that mean? Two things is one, when you're writing for you as a developer who's writing and any developer that's perhaps using a library that you wrote, it's explicitly clear what type of access to storage these functions have.
00:16:09.096 - 00:16:33.456, Speaker B: But number two is you'll never kind of have this error of like you accidentally access storage or you access storage in a way that has unintended effects because you didn't necessarily know you were accessing storage, you were just like trying to reference a variable that you might not have known was actually in storage. So with Sway, it's super explicit where if you want to access storage, you have to use the storage keyword. And if for example, you didn't define that type of access on that function, it won't even let the developer do that at compile time.
00:16:33.456 - 00:16:34.752, Speaker B: It'll just not work. It worked.
00:16:34.886 - 00:16:35.744, Speaker A: Okay, great.
00:16:35.862 - 00:16:48.020, Speaker B: Yay, you guys can see this big now. Okay, so this is what I was talking about for generics and send types. So if you see this result when I'm talking about explicit error handling.
00:16:49.720 - 00:16:50.084, Speaker A: So.
00:16:50.122 - 00:17:01.316, Speaker B: This is the result I'm talking about. When I'm talking about explicit error handling, you can do this unwrap method on result to actually access. What was it? Was it okay or was it error? That's what I was referencing earlier.
00:17:01.316 - 00:17:08.584, Speaker B: And then this is the explicit error handling. That's kind of what I mean when I say it forces you to call this method unwrapped to actually see the error. Okay, we're going to speed through this.
00:17:08.584 - 00:17:17.680, Speaker B: Oh, so this is what I meant when I say access. So here you're actually saying this function increment has both read and write access, while this storage only has read access to storage.
00:17:18.260 - 00:17:18.624, Speaker A: Okay.
00:17:18.662 - 00:17:37.760, Speaker B: Exhaustive pattern matching. So a match statement to exhaustively enumerate all possible cases and the compiler will tell you if you miss a case. So basically instead of having to again, manually remember to do a bunch of if else, like if it's true, not true, if it's seven, if it's ten, if it's 24, if it's like 100, you have to manually remember to write all of these if else branches.
00:17:37.760 - 00:18:01.644, Speaker B: But with Sway you have exhaustive pattern matching, which is this match statement which you can look in our docs, but basically it'll tell you that if you miss a possible path. So again, how do you write more safe applications? How do you make it safer for your users to be using it and not be kind of at the will or the whim of a developer making sure that they cross all their t's and dotted all their I's use something like Sway. Okay, reentrancy, this is the most exciting feature that we have coming up.
00:18:01.644 - 00:18:03.548, Speaker B: So you guys all know what reentrancy is.
00:18:03.634 - 00:18:04.364, Speaker A: Okay?
00:18:04.562 - 00:18:16.384, Speaker B: So I won't use this. So here's this list that I found, or actually John found, which is like this list that's maintained of all the reentrancy attacks to date. And you can see the last one was September 30, and that's only because I screenshotted this around that time.
00:18:16.384 - 00:18:31.784, Speaker B: There might have been another one since then, but with Sway at the compiler level, it'll call out if you have a potential reentrancy vulnerability. So it'll say on line 36, you have potential reentrancy vulnerability, please address it. So we all know what it means.
00:18:31.784 - 00:18:48.472, Speaker B: But I'll kind of just go over it for maybe people who don't know. You might have the case where it's like you have a function where let's say on line 27 you're sending some money and then on line 28 you're flipping some boolean to let the program know that the money has been sent, right? So that's how you could be. One way that you could be vulnerable to reentrancy is because someone could just keep calling.
00:18:48.472 - 00:19:01.964, Speaker B: Some function that keeps getting to that first line of the execution of that function where it just keeps sending the money over and over, but never actually makes it to that line where it flips the boolean to true or false or something like that. So that's something that the compiler will call out. And again, it won't let you build your contract.
00:19:01.964 - 00:19:11.540, Speaker B: It won't let you deploy your contract until you address this. So with Sway, this list should be zero. This re entrance attack will never happen in period.
00:19:11.540 - 00:19:17.248, Speaker B: So, okay, fork is the Fuel orchestrator. It's the equivalent of foundry cargo. NPM.
00:19:17.248 - 00:19:43.720, Speaker B: So it's what does all the builds manage, dependencies, deploy, format, test the language server. So I kind of made this map to kind of show like part of the draw of Fuel is not only all the things we just talked about, but it kind of unifies part of the developer ecosystem and the developer tooling. So that instead of having to rely on this kind of fragmented ecosystem, right, where one team built Foundry, one team built Hearth, one team built the EVM, one team built Solid.
00:19:43.720 - 00:19:56.176, Speaker B: It's like all of these different things that you kind of have to make them work together as a developer. You have to work with versioning, you have to make sure that everything's talking to each other that works well. With Fuel, we're like, let's just build everything in house and make sure that everything's always maintained up to date.
00:19:56.176 - 00:20:12.600, Speaker B: So for developers and that's what I'm going to show you here, you don't have to worry about installing Ethers, installing Wagme, installing Foundry, using hard hat, copying and pasting your Abi, like all these different pieces to make it work. Okay, now let's just speed run writing a DAP on Fuel. Can you guys see my desktop right here?
00:20:12.750 - 00:20:13.770, Speaker A: Okay, cool.
00:20:14.540 - 00:20:23.530, Speaker B: So this is following the developer Quickstart, which I'll pull up here just so you can see you go to fuel network. You hit read the docs developer quickstart. So we're going to follow this.
00:20:23.530 - 00:20:31.864, Speaker B: If we don't get through it or whatever, this is how you can do it. So we're literally going to speed run this baby. So you just have to install the rest tool chain, install the fuel tool chain.
00:20:31.864 - 00:20:35.564, Speaker B: And then I'm just going to go ahead. I already installed that, obviously. So I'm just going to start.
00:20:35.564 - 00:20:39.408, Speaker B: So I use Warp as a terminal. By the way, if you don't use it, you should check it out.
00:20:39.414 - 00:20:41.920, Speaker A: It's cool. Warp.
00:20:42.340 - 00:20:54.644, Speaker B: Yeah, it's really cool for a lot of different reasons. So what I'm going to do is I'm going to make a new thingy, mob a new thingy. Then I'm going to make a new project.
00:20:54.644 - 00:20:59.160, Speaker B: So the way you do it is fork new. And then I'm going to call it something. I'm going to call this one Counter.
00:21:01.580 - 00:21:11.960, Speaker A: Oh, I didn't CD into it. Sorry. How about now, can you see my Vs code though?
00:21:12.410 - 00:21:14.054, Speaker B: Okay, I'm going to zoom in.
00:21:14.092 - 00:21:14.534, Speaker A: Okay, cool.
00:21:14.572 - 00:21:22.150, Speaker B: So now we did Fork new and then the name of the thing I just called a counter. So if you open this, we have a main file. This is where we're going to be adding all of our code.
00:21:22.150 - 00:21:36.286, Speaker B: So in this thing we're just going to define a simple contract where there's a counter function to increment and then counter function to grab the current value. So I'm going to go here and just copy this and then we can talk about it.
00:21:36.388 - 00:21:37.360, Speaker A: Where are you?
00:21:37.810 - 00:21:58.066, Speaker B: Okay, so the first thing that we're going to do is define our abi. Now, if you were building a real kind of real project, the way you would do this is you would define your Abi in a separate file because ideas, then another developer could use this library and say, if I built a library for, like I said, like scientific math or something, I could just define this Abi. And then you could use my Abi and define your functions.
00:21:58.066 - 00:22:01.400, Speaker B: But we're just going to do it all in one because time.
00:22:01.850 - 00:22:04.134, Speaker A: But let me just copy this whole.
00:22:04.172 - 00:22:07.480, Speaker B: Thing actually and then we'll talk about it.
00:22:09.450 - 00:22:10.390, Speaker A: Delete.
00:22:13.050 - 00:22:14.390, Speaker B: Why didn't it copy?
00:22:16.730 - 00:22:18.078, Speaker A: Okay, there cool.
00:22:18.164 - 00:22:28.810, Speaker B: So the first thing that we're doing is every Sway contract starts with defining what type of file this is. Because you can have a contract. You can have a library, which is what I was talking about, where you would just define your abi and another file that would be a library.
00:22:28.810 - 00:22:39.294, Speaker B: You can have a script. So we're defining a contract. So you'll see what's cool, I really like this, I'm a visual person, is the storage variables are kind of grouped together in this object, like syntax.
00:22:39.294 - 00:22:53.206, Speaker B: If you're coming from JavaScript, which is really nice because then you could have another one, another one and they're all together visually. So you can. Just scroll to the top and be like, what are my storage variables? Then we defined our abi, which are just two functions, increment and count.
00:22:53.206 - 00:23:00.102, Speaker B: So here you see there's actually no function body. That's what you would implement in your actual contract. But like I said, we're doing it all in the same file just for simplicity's sake.
00:23:00.102 - 00:23:12.506, Speaker B: So here's where we're implementing counter. So we implement this one that's just Count, which just returns the value of counter, which starts at zero. This is the equivalent of this, by the way.
00:23:12.506 - 00:23:19.326, Speaker B: This is shorthand. You don't need the word return, and then you don't need the semicolon. And then here, Increment does the same thing.
00:23:19.326 - 00:23:29.060, Speaker B: It accesses the counter variable in storage, takes the current value and adds one. Then we're going to go to terminal fork build, make sure.
00:23:30.950 - 00:23:33.986, Speaker A: Fork build, make.
00:23:34.008 - 00:23:43.960, Speaker B: Sure it builds great. So now the next thing that we're going to do is we're going to build a front end for this. There's actually a part here to test, to write tests, but we're just not going to do that because we don't have time.
00:23:43.960 - 00:23:50.600, Speaker B: Then we're going to deploy our contract. I already have test coin, so I'm just going to go ahead and do this.
00:23:51.130 - 00:23:52.298, Speaker A: So here, if you guys can see.
00:23:52.304 - 00:23:58.554, Speaker B: It says fork deploy Hyphen Hyphen URL. And it's that GraphQL endpoint that I was talking to you about. Because again, like I said, that's where you actually deploy.
00:23:58.554 - 00:24:00.670, Speaker B: So it's not a JSON RPC endpoint.
00:24:02.370 - 00:24:07.310, Speaker A: So this part that we're talking about, it's fine.
00:24:07.380 - 00:24:20.346, Speaker B: It just was creating a new file. So this part that we're going to go through is kind of janky right now because fuel and sway in general just a very early, like we just did testnet maybe a month ago. So there's still a bunch of parts that are in development.
00:24:20.346 - 00:24:31.702, Speaker B: The wallet part is one of those things. So you kind of have to do this manually for now, but in the near future, you'll have like a browser extension, wallet like everything else. So I'm going to do Fork wallet list to show me all of my wallet addresses, which I only have one.
00:24:31.702 - 00:24:36.482, Speaker B: So it says, please provide the address of the wallet you want to sign with. I'm going to pass it in. It's going to give me this transaction.
00:24:36.482 - 00:24:47.578, Speaker B: I go back here, fork wallet sign, pass that in and then index zero. Because here, this address is index zero right here the zero. That's where that zero is coming from.
00:24:47.578 - 00:24:53.040, Speaker B: And do my password. And then it gives me back a signature. Then I give that back here.
00:24:53.040 - 00:24:59.840, Speaker B: Okay, I know that was a lot, but it won't be like this forever. Then you copy your contract ID. I'm just going to put it.
00:25:02.710 - 00:25:03.118, Speaker A: I'm.
00:25:03.134 - 00:25:07.250, Speaker B: Going to put it here so I don't lose it. Don't look at my notes.
00:25:10.310 - 00:25:11.378, Speaker A: Okay, cool.
00:25:11.544 - 00:25:15.938, Speaker B: So now let's go back here. Now it's deployed to the testnet. We have our contract ID.
00:25:15.938 - 00:25:25.506, Speaker B: So now let's go ahead and build a front end for it. So this kind of shows you how to look at it on the Block Explorer, which we're not going to do now. We're going to create a react project in the same folder.
00:25:25.506 - 00:25:33.020, Speaker B: So we're going to CD out one. So we're in the big folder. And then we're going to paste this in, which creates a react project for us.
00:25:33.020 - 00:25:49.710, Speaker B: And then after this loads, we're just going to install two things. One is Fuels is the umbrella package that includes all of the main tools, wallet, contract providers, more, and then the fuel chain which generates your Abis for you. So I'm going to go ahead and copy this while that loads.
00:25:49.710 - 00:25:59.862, Speaker B: Okay, we're running like 1 minute over time, but I lost a few minutes, so it's fine. I feel like I can go over a few minutes.
00:25:59.916 - 00:26:00.326, Speaker A: Yeah.
00:26:00.428 - 00:26:08.540, Speaker B: Okay, cool. So now we're going to go into the front end that was just created. We're going to install the two things that it wants, which are listed here.
00:26:11.310 - 00:26:16.714, Speaker A: Cool. Okay.
00:26:16.752 - 00:26:28.058, Speaker B: Now the next thing that we're going to do is we're going to generate our types. And this gets done automatically with the packages that we just installed. So that's how we're installing them because we want to be able to run this command that will automatically generate types.
00:26:28.058 - 00:26:35.746, Speaker B: So if let's say you update your contract like you're building your front end, you're like, I want to add another function or whatever. I want to update my contract. You go make that contract, you redeploy it.
00:26:35.746 - 00:26:48.600, Speaker B: And then by running this command, it'll regenerate your types automatically without you having to verify your contract. Copy the abi, paste it in your front end, it'll just get done and imported automatically. So I'm going to copy this but without this.
00:26:51.290 - 00:26:51.990, Speaker A: Okay?
00:26:52.140 - 00:27:03.770, Speaker B: And then here I'm going to change the name because here I called it counter instead of counter contract. So there will be a note in this in the quickstart, but it's like the name of this. So counter.
00:27:04.190 - 00:27:06.838, Speaker A: And then if we run this, you'll.
00:27:06.854 - 00:27:09.420, Speaker B: See successfully generated four typings done.
00:27:09.950 - 00:27:10.410, Speaker A: Cool.
00:27:10.480 - 00:27:33.030, Speaker B: So now what we're going to do is we're going to create so this is another part of the thing that I'm saying is Janky, that you won't have to do. So we're going to create this file called Create Wallet JS, which basically makes it so that you create a wallet in your front end so that you can sign these transactions. Just going to copy this, paste it in, Save, and then just run node create Wallet JS.
00:27:33.030 - 00:27:37.926, Speaker B: And then I'm going to copy this because I'm going to need this.
00:27:38.108 - 00:27:42.950, Speaker A: Close your eyes. Okay, great.
00:27:43.020 - 00:27:51.500, Speaker B: So now let's go to our front end project source app TSX. And we're just going to paste in the code from here.
00:27:56.420 - 00:27:57.730, Speaker A: Actually, let's just.
00:28:00.820 - 00:28:01.280, Speaker B: Nice.
00:28:01.350 - 00:28:01.680, Speaker A: Okay.
00:28:01.750 - 00:28:03.196, Speaker B: Can you guys see this? Should I make it bigger?
00:28:03.228 - 00:28:05.232, Speaker A: Smaller? It's fine.
00:28:05.286 - 00:28:10.836, Speaker B: Okay, I'm just going to quick fix this. It just has the wrong so this is Counter contract. That's just the name of the project from the quick start here.
00:28:10.836 - 00:28:13.860, Speaker B: We just called it counter. So we're going to update that same thing here.
00:28:13.930 - 00:28:17.332, Speaker A: Update that quick fix. Okay, cool.
00:28:17.386 - 00:28:26.664, Speaker B: So let's talk through what this looks like really quick. So here at the top, we have our contract factory. And here what we're going to do is we're going to paste in our contract ID and our wallet secret.
00:28:26.664 - 00:28:39.310, Speaker B: So our contract ID is this first one that we got when we deployed the contract. Our wallet secret is a private key from the wallet that we generated in the front end. So I'm going to paste that in here.
00:28:40.320 - 00:28:41.020, Speaker A: Great.
00:28:41.170 - 00:28:49.090, Speaker B: The other thing I'm going to do is I'm going to go get some tokens so this doesn't fail from the faucet. So I'm just going to type in faucet. I'm going to get some coins real quick.
00:28:50.040 - 00:28:50.452, Speaker A: Great.
00:28:50.506 - 00:28:52.230, Speaker B: See how fast that was by the way?
00:28:55.160 - 00:28:55.524, Speaker A: Great.
00:28:55.562 - 00:29:01.110, Speaker B: So now we have this. So this is just like a simple count thing. Where here we have a button.
00:29:01.110 - 00:29:16.692, Speaker B: Here we have a button, where are you? Button here button where when we click it on the front end, it calls this function called increment, which is defined here. And this is how you actually interact with your contract. So await contract functions.
00:29:16.692 - 00:29:22.792, Speaker B: Increment. And we know it's increment because it's defined as increment here. So if this were called like Apple, that's what it would be called.
00:29:22.792 - 00:29:29.088, Speaker B: There transaction parameters. We're passing the gas price to one because it can't be zero. And then we're doing call.
00:29:29.088 - 00:29:39.344, Speaker B: So that's how we actually interact with the contract. So you see, you don't have to install Wagme or you don't have to install Ethers JS. You don't have to install external dependencies to be able to get your contract and your front end to talk to each other.
00:29:39.344 - 00:29:48.964, Speaker B: It's all built in and unified in the tooling that's created by Fuel apps. And then here we want to so remember, we have two functions. One that increments and one that just gets the current count.
00:29:48.964 - 00:29:54.256, Speaker B: So we've called increment. Now we want to get the current count. So here await contract functions.
00:29:54.256 - 00:30:00.600, Speaker B: Count, which is this one, right? If the name was something else, it would be something else, but it's called count. So that's how we reference it.
00:30:00.750 - 00:30:01.544, Speaker A: Get.
00:30:01.742 - 00:30:05.370, Speaker B: So now let's save this. Let's run this.
00:30:16.370 - 00:30:16.782, Speaker A: Okay.
00:30:16.836 - 00:30:36.530, Speaker B: And that was it. So you see, right, the thing that I kind of wanted to highlight is if you've ever developed apps for Ethereum, I was literally just let me see if I can open it up. I was literally just trying to write something for the EVM the other day and I couldn't even get the compiler versioning to work with the thing I was trying to write and I got really annoyed and I just gave up, kind of, but with fuel.
00:30:36.530 - 00:30:51.046, Speaker B: The thing that I really, really like about it is that you have this way better developer experience. And you don't have to deal with puzzle fitting all the different pieces to work. So this slide, let me just show you last 2 seconds.
00:30:51.046 - 00:31:03.970, Speaker B: So this slide, we replaced this whole thing, right? Like we didn't need to use hard hat or truffle or Foundry or Brownie or Anchor. We didn't need to use web three JS or ethers or Anchor. And then we didn't have to use the graph.
00:31:03.970 - 00:31:19.238, Speaker B: We just removed three key kind of pieces that you have to usually finangle with to get something to work. And it all just was integrated directly. Last thing I want to say is here are some resources if you want to check it out more.
00:31:19.238 - 00:31:40.894, Speaker B: The first link or the first QR code is something called awesome Fuel, which is basically this resource where you can find all the articles, podcasts, tweets, like all the best stuff about Fuel publicly. And then the second one is the Fuel Book, which is the developer resource with the Quickstart, with information, with the SDKs and all the different stuff that you could want. And finally, thank you.
00:31:40.894 - 00:31:49.100, Speaker B: My name is Cammie Emily right here is from the compiler team if you want to talk to her about compiler stuff and sway stuff and like I said, we have a booth at the front and yes, thank you.
