00:00:06.330 - 00:00:06.654, Speaker A: All right.
00:00:06.692 - 00:00:23.214, Speaker B: With that, we are ready for our next talk. And for that, I'd like to invite our next speaker, Aichen. Aich is going to be talking about how Zhu RoPS of Zkpms works actually from the context of how scroll is designing it.
00:00:23.214 - 00:00:35.702, Speaker B: And you kind of already saw him talk about the prizes they're giving. We already saw a lot of talks around how to think about these technologies as roll ups become more and more common. And we're going to go into a lot more depth here now.
00:00:35.702 - 00:00:42.306, Speaker B: So without further ado, I'd like to welcome him on stage and get started.
00:00:42.348 - 00:00:43.206, Speaker A: So welcome, my Chen.
00:00:43.238 - 00:00:44.778, Speaker B: It's great to have you here again.
00:00:44.944 - 00:00:53.854, Speaker A: Yeah, thank you Karthik, for the introduction. And thank you for having me here to present to all of the people in the Skating Miserable event.
00:00:53.972 - 00:00:58.320, Speaker B: We're excited. So I'll let you take it from here and all the best.
00:00:58.930 - 00:01:01.390, Speaker A: Okay, cool. Yeah. Hello everyone.
00:01:01.390 - 00:01:15.726, Speaker A: I'm HaiChen from scroll. So today I'm going to give an introduction to the Zkrop and then the Zkevm. And I'm going to dive, just introduce how the Zkvm is built and what is ZKM is going to prove.
00:01:15.726 - 00:01:37.446, Speaker A: So give a little bit more insights of how we are building the Zkvm from the scroll. Okay? So first of all, we all know Ethereum is great because it's decentralized and secure and it has a humongous of community and developers are building on top of that. But ECM also has its own problem that it's not built to be scalable.
00:01:37.446 - 00:01:58.094, Speaker A: So to handle like thousands of transactions per second. So this is because of the blockchain tralemma that one blockchain cannot achieve scalability, decentralization and security at the same time. And we all know decentralization means that the chain can run without any trust, dependencies on a small group of centralized actors.
00:01:58.094 - 00:02:19.286, Speaker A: And this is typically interpreted as to be not trusted by any set of nodes. And security means that you can sustain the attack from a large proportion of the nodes inside the networks. And a scalability just means that the blockchain can process more transactions than a single node.
00:02:19.286 - 00:02:53.086, Speaker A: And we know that the Ethereum and the traditional blockchain for Bitcoin, they all prioritize the decentralization and security and such that it both suffer from the scalability issues. So to take a deep closer look at why Ethereum or other blockchains is not scalable, it's because we can show a diagram of this, how Ethereum works. So users send transactions to an Ethereum node and then the transaction will then be broadcasted to a PTP networks.
00:02:53.086 - 00:03:09.890, Speaker A: The proposers then will submit a block. Then everyone in the network will download this block and re execute all of transactions inside this block to reach consensus. So that means all of the full nodes need to do the same thing, like same computation for every blocks.
00:03:09.890 - 00:03:51.666, Speaker A: And because the ECM is widely decentralized so hundreds of thousands of nodes were repeatedly doing the same computation for every block. And that's why the SM is not good for scalable because it has a lot of redundancies in computation just for being resistant and being censorship resistant and then also being decentralized. So how does the community plan to solve the scalability problems? So, about two and a half years ago, Vitalika posted this blog post on the forum about this RoPS centric roadmap.
00:03:51.666 - 00:04:25.550, Speaker A: So the plan is to scale the ethereum through the RoPS chains that can process more transaction on the Layer Two and then having the efficient settlement and finalization on the Layer One to achieve the scalability and without sacrificing lots of the securities for that. So now let's take a look at how the Rock works in general. So here now you have two chains, the Layer One being the it serves as the settlement layers for any transaction happen on the Layer Twos.
00:04:25.550 - 00:05:01.754, Speaker A: And then the Layer Two becomes a less decentralized blockchain so that it can process more transaction blocks at a faster pace. And theoretically, the Layer Two will batch all of transactions and send sufficient data to the Layer One with some sort of the proof to finalize all of the transactions that in dispatch happen on Layer Twos. So the requirement for a roll up to being a roll up is that the users can recover the latest state route on the Layer Two, purely relying on the data stored in the Layer Ones.
00:05:01.754 - 00:05:13.546, Speaker A: And then there are two types of the RoPS right now. So one is the Optimist Rob and the other is the Zkrop. I give first some of the intro about what is the optimist Rob.
00:05:13.546 - 00:05:41.462, Speaker A: So the optimist Rob is that it will just submit the transaction data to the Layer One, waiting for a period of time for the challenges. So if no one challenged like there is any invalid transaction within that batch for a certain period of time, then that batch of transaction will be considered finalized on the Layer One and it cannot be reverted anymore. However, the drawback of this optimistic Roth approach is that the waiting period time is sufficient.
00:05:41.462 - 00:05:54.314, Speaker A: It's quite long. So that people need to wait for seven days until that connection can be considered finalized on the Layer One. That's why people will tend to work on another type of Rob.
00:05:54.314 - 00:06:14.894, Speaker A: It's called the zkrop. And in the Zkrop every time, you will not only submit the data to the Layer One, but you will also accompany with a ZK proof that can be easily and cheaply verified on the Layer One. And once this proof is verified by a smart contract on the SWMS and then that batch of transactions can be then synced up, finalized.
00:06:14.894 - 00:06:25.430, Speaker A: That's how you achieve fast finality for the ZK. Rock with the Zkrop. But actually, let's simplify the diagram a little bit.
00:06:25.430 - 00:06:57.118, Speaker A: So for the ZK Rocks, basically you need to on the Layer Two you need to build a prover that's going to generate a ZK proof and then accompany with some data and then both were submitted to the layer one for settlement and finalizations. But the problem with the Zkrop is that it is non trivial to build a Zkrop system for many reasons. So first is that to generate a proof for some computations you need to write down your program logic in the form of arithmetic circuit.
00:06:57.118 - 00:08:00.482, Speaker A: And it's quite complicated and hard to being like using only the additions, modifications and some of the mass assertions in the circuit to express your computation, your program logics and also you require certain overhead to handle to generate this nikki proof for the ZK robs. And also even worse that different programs and different applications may have a different circuit such that you need to encode every application, you need to write a new circuit to be able to using the Zkrops and even worse that there will be no composability between the different application specific Zkrops. How to solve this problem of this no composability with different application specific Zkrop is that we need to build a general purpose Zkrop that can run any type of applications and then one of the type is like we are building is called Zke EVM.
00:08:00.482 - 00:08:48.070, Speaker A: What we do is trying to put the Ethereum virtual machine into a ZK circuit so that any application, any DAPs are written using the solidity like built on top of the Ethereum can be run directly on the layer twos. And using the Zke EVM to generate the ZK proof for that any applications that deploy on the layer twos. So that's the benefit of having the Zke EVM in the layer two and the ZK rob you can achieve the composability and being also very developer friendly because all the developers need to know is still the solidity and using the same tool chains, foundry, hard hat, anything like using on the layer ones you can also using on the layer twos.
00:08:48.070 - 00:09:11.174, Speaker A: But there are also some drawbacks for building the ZK EVM. So why reason is it's very hard to build? So the essential virtual machines is not built for the ZK, so it's not very ZK friendly. So you need to be very careful and it's very hard to build putting the entire ethernet virtual machines into the ZK proof.
00:09:11.174 - 00:09:38.842, Speaker A: And due to this incompatibility of the basic field with the finite field using it in the zero notch proof and also there's a lot of special opcodes like catch hack, some bitwise operations and also the signature verifications, the ECDSA signature verification. They are all quite special functions. Like they need to spend a lot of effort to building the ZK circuit and also to generate the proof for the Zkum.
00:09:38.842 - 00:09:57.510, Speaker A: There's quite large proving overhead for that. So that's why initially people are more tense to building the application specific Zkrop instead of building the ZKM. So why is the Zkum possible now? So there are mainly three reasons.
00:09:57.510 - 00:10:21.246, Speaker A: First, we are not having better new knowledge proof systems. We have a lot of new primitives such as the polynomial commitments, the custom gates lookup arguments and the recursive proofs. All those recent advancements in the neonatch proof protocols that makes building the Zkey VM more practically available, viable.
00:10:21.246 - 00:10:46.010, Speaker A: And the second we have more hardware acceleration available right now and more like the state of art GPU proverb algorithms. And then we also were expecting the FPGA or ASIC some accelerator, ZK accelerator solutions in the future that can further bring down the cost of generating a ZK proof. And then third is that we have a lot of new open source toolings and frameworks available.
00:10:46.010 - 00:11:12.926, Speaker A: And also not to mention the scroll is building the Ckevm in the open source communities with the foundation like the PSE team from the XM Foundation and other open source communities. So there's lots of tools and resources available in the open source so that's making the ZKM building viable and practical. So now let's dive deep into a little bit about Zkevm.
00:11:12.926 - 00:11:34.374, Speaker A: So there's a few different Zkevm flavors which people they all call the Zke EVM. The first is language level compatibility with the Ethereums. So that means you can compile some EVM friendly language like Solidity or UO into a Snot friendly VM which differs from the EVMs.
00:11:34.374 - 00:12:00.498, Speaker A: And the second is bytecode level which you directly interpret the EVM bytecode directly inside your ZK circuit so that you don't need to use different compilers, you can reuse all of the same tool chains to directly use that. And then you can run on the Zke EVM. And then the last one would be the consensus level which should target for the full equivalents with the EVM using on the layer ones.
00:12:00.498 - 00:12:26.038, Speaker A: That means this level Zke EVM can directly prove any layer one blocks. And here what we are building in the scroll is that we're trying to target for a bico level compatible or equivalent Zke EVM such that the developers can using all of the existing tools to building on top of the scroll. Okay, now next we're going to talk more about the Zke EVM.
00:12:26.038 - 00:12:50.398, Speaker A: And first let's focus on what the Zkevm trying to prove. So let's simplify the EVM how it works. So first of all, at one time step like T, you have like a state root trees that including all of the state account information and also any storage trees stored in the smart contracts.
00:12:50.398 - 00:13:13.930, Speaker A: And at that time you'll receive a new transactions and trying to do any like the transfers or executing some smart contracts. So you'll input these two as the input to the Ethereum virtual machines are going to execute and output. The result will be a new worst state with a different route after you apply the transactions.
00:13:13.930 - 00:13:35.670, Speaker A: And then looking inside, what happens inside the virtual machine, you basically get a few different modules. First you have a state machine that going to interpret all of the bytecodes inside any smart contracts and you have stack and memory for any transient data keeping the memory. And also you will access to two database.
00:13:35.670 - 00:13:59.282, Speaker A: One is the bytecode database that going to load the smart contract from that and execute them. And the second you have a storage database that can keep any state account information as well as any storage like the stored in the smart contract. So let's take one further step into looking at what happens when you're executing the smart contract.
00:13:59.282 - 00:14:55.030, Speaker A: So after you give these two inputs the world state and then the transaction to the essential virtual machines and then what happens that you are going to execute by opcode written inside this smart contract and it will end up with an execution trace with different steps. It will do the push and then some push and some load and then do like the load some of the core data on the transactions and then execute any special logic from the smart contract that will be finally end up like modifying some data in the storage and in the state of country that will be generate a new state worst state. So now what we can even try to do to add the additional steps inside this like the whole pipeline of executions is that the Zke EVM is taking the specification of the ethereum virtual machines.
00:14:55.030 - 00:15:39.850, Speaker A: And then it will take also, the same input data from how the Ethereum virtual machine does is take a worst state snapshot and taking any new transactions as the input data. And what it's going to prove is that it's going to prove this execution trace generated from the Ethereum virtual machines is correct and it will also prove that the state route will transit from the old state route to the new state route. So to summarize a little bit like what does Ethereum is trying to prove is like you first need to prove the execution trace generate by running the essential virtual machine is correct and unique and the second that you need to prove the global state state route transit from the old route to the new route.
00:15:39.850 - 00:16:18.398, Speaker A: Okay, so this is like some high level like the things about what Zkevm is going to prove and then let's dive a little deep into how we build the ZKM in the circuit. So remind that I just explained that the Zke event is trying to prove that the execution trace is correct after applying certain transactions and then executing some smart contract. So that will be the logic is quite similar to what happens inside the circuit where the core circuit in the Zke EVM that we are building is called EVM circuit.
00:16:18.398 - 00:16:51.722, Speaker A: The EVM circuit is basically state machines mimic the state machine inside the internet virtual machines. So you are also mapping all of the steps inside your execution trace into your circuit which looks like just like the blue table will be just looking like a two dimensional matrix and then each step will map to a slots inside the circuit as well. So like one to one mappings to the steps and then one step will be corresponding to any opcodes you are executing inside the execution trace.
00:16:51.722 - 00:17:24.330, Speaker A: So each step inside the circuit will having slightly different height due to the complexity of different opcodes. For example, the multiply opcode from EVM may be like it's more complicated than add opcode so it may be taking more rows and more resources in the circuit to prove the correctness of that opcode. And then if you take a closer look at each step slot inside the circuit, you will be separated into different sections.
00:17:24.330 - 00:17:41.930, Speaker A: Different sections. So you'll be having the step contact by keeping some of the contacts of the stack pointers, the program counters other information and the second will be a case switch. They're going to switch on different opcode specific constraints.
00:17:41.930 - 00:18:48.950, Speaker A: For example, there will be like one case for each opcode corresponding to opcodes you have inside these virtual machines but it's basically a switch statement like you written inside any languages and then the service section will be any opcode specific witness that going to help you to prove the crapness of any opcode. Yeah, it's like I just explained for the step context you are keeping certain information for this current step is which code hash are you executing, it decides which contract you are executing and then some gas like you left in the transactions, the program counter stack pointer and a current state route et cetera. There be more information and for the case switch it will be basically a bunch of selectors corresponding to each opcode in the ethereum virtual machines and also different error cases that they're also important that you need to prove and handle all possible errors that happen inside when executing the transactions.
00:18:48.950 - 00:19:17.230, Speaker A: And also we need to make sure that exactly only one case is switched on under each step. And the last one will be some opcode specific witnesses will be like some of the input data for example, like the word like you're going to add together and the results you can going do. And then there will be also some additional witness that are going to help you to prove the correctness of each opcode.
00:19:17.230 - 00:19:52.598, Speaker A: So let's take an add opcode as an example to see what happens inside ckevm constraints. So first of all you need to constrain the step context is transitioned correctly from the previous steps. So for example, in the current step, if I'm executing an add op code so the program counter, the next step, program counter will be increased by one from the current step, and then the step pointer will shrink by one because the add up code pops two word from the stack and then push one back to the stack.
00:19:52.598 - 00:20:09.920, Speaker A: And then the gas left will be reduced by three because the ad op code will consume three gas in the EVM. And second it will be a case switch that means only one of the case like one of the case will be selected. We just add here.
00:20:09.920 - 00:20:41.426, Speaker A: So first you need to prove each opcode will be case, the selector will be zero or one. And then finally you need constraint like all of them sum equal to one. And then last will be some opcode specific witness here is that for example because of this field incompatibility between the circuit and then the EVM, the EVM word has 256 bit but inside the circuit you can represent a value up to 253 bits.
00:20:41.426 - 00:21:06.834, Speaker A: So that's why you need to break down those word into two parts like with the high 122 122 eight bit and then low 122 eight bit values. And then though you need to do like additions for the low 122 eight bits. The a low plus below will be equal to zero plus some of the carry on into the next high 108 bit.
00:21:06.834 - 00:21:39.866, Speaker A: And then do the similar things for the high 122 eight bit additions here. And then further what you need to do is to prove that the word AB are correctly popped from the stack and then the output C is correctly pushed back to the stack. So what you really do is you introduce an additional lookup table, help you as an auxiliary data structure to help you to prove any stack or memory operations here.
00:21:39.866 - 00:22:15.938, Speaker A: So here what are you going to do for proving the stack pop is that you just do a lookup thinking like okay, so I'm pop up like the stack at a certain stack pointers with its read and then that's always going to like the value you are going to pop up from the stack. And then after you do the calculation of the word C here inside the circuit, you're going to push the stack back and right back to the correct address inside the lookup tables. And because these lookup tables is also constrained, is also constructed after the executions.
00:22:15.938 - 00:22:44.602, Speaker A: So that we need to have additional circuit to constraint that the lookup table is constrained correctly. So this is some of the just high level explanation of building the ZTE event circuit. There'll be a lot of more details but if you're interested you can definitely look at the open source repo to dive more deep into how the code is constrained there, but just give you a high level of the architecture of the Zkevm.
00:22:44.602 - 00:23:38.038, Speaker A: So the Zkevm, although we call it the circuit but actually construct with a lot of subsurface together to function together constraint together such that it can be built to constrain all of the executions happen in the eastern virtual machine. So in the beginning for the Zkem you have the core part is the EVM circuit serve as the state machine to constrain each opcode that happened inside the eastern virtual machines. But for some of the ZK unfriendly opcodes like the end all XOR, those bitwise operations, the expansion opcode and then the catch up computations we'll be relying on offload those kind of computation into the lookup tables and that will be further constrained by other circuit to help you to constrain the whole disappear.
00:23:38.038 - 00:24:06.470, Speaker A: And then second for any stack memory and storage operations we'll be relying on a Ram lookup table as I just showed before. So those like a Ram lookup table that serves as a database that consists of all of the records of stack and memory and storage operations. So inside the EVM circuit you don't need to reason about the crackings of those operations but you just find a match inside the lookup table, the database of all the records.
00:24:06.470 - 00:24:24.366, Speaker A: Now, once you have a match inside those Ram lookup tables, you will consider those stack and push and pop is correctly. The memory read and write is correct inside the um circuit. And then you have some additional lookup tables to help you to load correct bytecode from the smart contract.
00:24:24.366 - 00:24:58.646, Speaker A: And you can load certain information from the transaction core data and then some block metadata from the block lookup tables. So all these lookup tables will be then further constrained by some other circuits to help you to prove that those lookup tables is correctly constructed inside a circuit. And then in order to serve this to constrain help you to write those all of the lookout table circuit, you will also introduce some additional lookout tables and additional circuits.
00:24:58.646 - 00:25:22.850, Speaker A: For example there will be some workout pressure tree circuit will be constraining any reader write to the storage and state trees and then also there will be some transaction signature circuit, ecdsing circuit helping to verify the transaction signature is correct. And then there will be some RP encoding for the transaction here. There will be some RP lockup table and RP circuit.
00:25:22.850 - 00:26:09.886, Speaker A: And then finally you will introduce a public input circuit that's going to connect the public input data that you uploaded with the rob and then constrain like the certain data is correctly calculated in the whole zke event circuit. Okay, so lastly about scroll is that we are building the Zke event with the community, with a lot of community members. Not only scroll is doing that and we also having this design and all of the code has been peer reviewed by the communities, by the community members, from us and from the PSA team of the Ethereum foundations and also other many more people who are interested in the Zkevium and then contributing to the Zkevium repos.
00:26:09.886 - 00:26:37.898, Speaker A: And if you're also interested you can also take a look at the repo and we welcome you to contribute to the same repo together. And lastly about our principles while we are building the Zkevm to scale the exams, we still follow our principles when building things. First we aim to build an EVM equivalent ZK Rob so that it can achieve the best in class user and developer experience.
00:26:37.898 - 00:26:58.322, Speaker A: And second, we still like to keep a security first mindset when building the layer twos. So we first have the ZK EVM and ZK Rob protocols that can explicitly prove the correctness of any executions and transactions on the layer two. And we're also actively having this external and internal auditing on our code base.
00:26:58.322 - 00:27:46.926, Speaker A: And also being building with the community building in the open so that all of a code can be also peer reviewed by others, not only like us building in house code. And third, we also believe in the decentralization matters in the layer two context which we think will be the key property of the blockchain to be censorship resistant and then to be also social resistant so that we are committed to decentralized across all different layers, including we're having a decentralized proverb network and a decentralized sequence of our validator network. And then last I will just talk about we also have a hackathon bounty program in this event and then we will have three different tracks.
00:27:46.926 - 00:28:01.730, Speaker A: First, we will ask you to deploy your smart contract on top of the scroll testnet, that's a public testnet on the Gurdi. And then the deployment process will be just very similar to what you do on the top of the exams. You only need to change RPC endpoint.
00:28:01.730 - 00:28:18.950, Speaker A: And the second is that we love Zoonorge. So show us your best application building new use cases that leverage the power of zoonoge proofs. And the third track is that we want to see the developers and DApps taking advantage of the cheap gas fees and a faster block time on the layer twos.
00:28:18.950 - 00:28:31.840, Speaker A: And you can benefit from the layer two scaling property and a faster finality with the Zkrops. And I hope you enjoy like the hacking on topless Go testnet. And for more information you can also check out this website.
00:28:31.840 - 00:28:41.810, Speaker A: Okay, that's all about my talk and thank you everyone for listening to the talk. Again, I can take any questions from the audience.
00:28:44.950 - 00:28:56.646, Speaker B: That was awesome. That was such a good overview on how everything is set up. We don't have enough time for questions because I make sure we can get to the next talk as the time gets on either end.
00:28:56.646 - 00:29:12.480, Speaker B: But I'd love to kind of maybe just ask you one little thing as we get the next speaker set up, which is if you have a wish list of what you would like people to build on scroll or just on Sdkbm, is there something that you've been really wanting to see that you haven't seen yet? Or you think there's something that other people to try? What's on your wish list?
00:29:13.570 - 00:29:29.682, Speaker A: Yeah, that's a good question. So I think the wish list, I think the ZK event is building for general purpose. So any type of applications, any innovative applications can be also built on top of that of the Scroll Zke event, layer two.
00:29:29.682 - 00:29:48.694, Speaker A: But I think some interesting thing would be you can think of any ZK applications that'd be interesting, like privacy or any private votings or any social application identities. Like, those application, I think, will be innovate, like the more easily underscore. So that's an interesting point.
00:29:48.732 - 00:29:52.346, Speaker B: So maybe I also misunderstood. How would private voting work here?
00:29:52.368 - 00:29:53.258, Speaker A: Is it just the fact that you.
00:29:53.264 - 00:29:57.180, Speaker B: Don'T get to see the weights or where's the privacy coming from in this example?
00:29:57.870 - 00:30:25.878, Speaker A: Yeah, to just clarify, actually, the Ziki rob usually doesn't provide privacy by default, so it's more for the scaling and the compression of the transaction happened. But for any private applications, you're probably like having a private issued pool so that anyone can hide the identity of the voters. That you don't need to review your vote, but you can still verify that someone in the pool in the Dow voted, and only you can, only about once.
00:30:25.964 - 00:30:32.498, Speaker B: So ease distance checks on making sure that nobody's abusing it and having the information be private.
00:30:32.594 - 00:30:33.254, Speaker A: That's awesome.
00:30:33.372 - 00:30:41.160, Speaker B: Well, thank you so much. And with that, we are ready for our next talk. So go hack on scroll and we'll see what people built.
00:30:41.690 - 00:30:42.740, Speaker A: Thank you. Thank you.
