00:00:10.070 - 00:00:24.140, Speaker A: Hi, I'm Riona from INMAX Project. I'm an architect of INMAX. INMAX is a state like Ziki rollup and it will make you server global's purpose system.
00:00:24.140 - 00:01:06.352, Speaker A: It enhances their whole server layout world. Today, I want you guys to build on layer two interoperable application that traverses over layer twos. Let me explain the overview of WindMax first stateless means that barrier do not need to have databases instead of validators client side logic can invalidate each transaction in INTMAX.
00:01:06.352 - 00:01:24.420, Speaker A: The client side logic is infinite recursive ZKB what is infinity recursive ZKP? Recursive ZKP is a ZKP. Verifying. Another ZTP proof.
00:01:24.420 - 00:02:05.020, Speaker A: Infinite recursive ZKP repeats this process unlimited times unlike usual recursive ZKP infinite recursive ZKP can verify the whole chain of ZKP by verifying only one previous ZKP proof. Once you verify the previous ZKP proof that has already contained the proof prior to that also, the proof contains a proof prior to it. So the probing chain reaches the origin of this chain.
00:02:05.020 - 00:02:37.996, Speaker A: How to remove the transaction data from layer One code Editor this is one of the most important parts. We introduced limited online requirements to Ziggylo lab and this improved both efficiency and privacy. This algorithm rumors almost all onchain data from Ziggy Lolab.
00:02:37.996 - 00:02:58.690, Speaker A: So it's 95% cost reduction compared with other Ziggy Lolabs. A barrier returns their marketplace and result of transactions to users after they sent transaction to the validator.
00:03:01.430 - 00:03:03.790, Speaker B: This proof can be used for withdrawing.
00:03:03.870 - 00:03:26.250, Speaker A: Assets to layer one with ZGP. A double spend or double exit is impossible by the non movement proof which is using non inclusion proof like SMD. There are Gregory lists of transactors in code editor.
00:03:26.250 - 00:03:36.100, Speaker A: This is how INTMAX works statelessly.
00:03:38.200 - 00:03:38.516, Speaker B: Or.
00:03:38.538 - 00:04:15.540, Speaker A: In the mercury route of the many transaction hashes and deposit is recorded in layer one as described. The users will merge the transaction to their offshore storage by clients and Zigbee. If we have the results data of smart contract executions from the other layer zones in this deposit tree like this, we can use these states or conditions of token transfers and minting.
00:04:15.540 - 00:04:23.060, Speaker A: Okay, next, let's start building application.
00:04:29.190 - 00:04:39.446, Speaker B: First, install their tools to use indmags Chrome, the repository from the Intmarks roll.
00:04:39.478 - 00:04:40.490, Speaker A: Up CLI.
00:04:43.900 - 00:05:32.980, Speaker B: Open the terminal on the Git clone. Build the CLI according to the leaveme check if last is installed. If not, please install it beforehand.
00:05:32.980 - 00:06:12.790, Speaker B: Build the CLI if you see something like this. When you are done, you have succeeded. Configure alias settings for easy use of CLI.
00:06:12.790 - 00:06:42.460, Speaker B: Run the help command to confirm. Next, we create an account on INMAX with the default flag so that when we run commands with that specifying account, that account will be reverenced. Create an account above as well.
00:06:42.460 - 00:07:39.690, Speaker B: Alice issues ten tokens on Intmags which we call Alice tokens since they were issued by Alice. Alice transfer their Alice Token to Bob. Check the balance after the transfer and you can see that Alice has nine tokens and Bob has one token.
00:07:39.690 - 00:08:20.824, Speaker B: Let's take a look at the interoperability feature. First, write the private key to the EVM env file. Be careful not to transfer any of mainned as assets since their key originally written is a private key.
00:08:20.824 - 00:08:42.624, Speaker B: For testing purposes, rewrite this part to your private key. Deposit is on scroll at the address corresponding to the private key. 0.5
00:08:42.624 - 00:09:20.320, Speaker B: research is enough for this thing. Next, Carol makes a deposit on scroll at the address corresponding to the private key. Next, we create Carol's account, switch to Bob's account and issue a Bob token.
00:09:20.320 - 00:10:09.370, Speaker B: Check that the balance has increased. Next, make an offer to Bob to pay one Bob token or INTMAX. If Carol pay zell point Zelza One East on scroll dispersion will take 1 minute.
00:10:09.370 - 00:10:54.560, Speaker B: If it succeeds, their offer is accepted. If it succeeds, their offer is accepted. And so recall the offer ID.
00:10:54.560 - 00:11:41.070, Speaker B: Accept their previous offer on Carol account. Replace the part marked Offer ID with the ID you just received and run the INMAX activate command. Looking at the Carol's account, we can see that the Bob token has indeed been transferred.
00:11:41.070 - 00:12:17.640, Speaker B: We will now develop an app or inbox to interoperate with the other EVM compatible networks. Create NPM project install node JS if not already installed and install Hardhead. This operation takes 1 minute.
00:12:17.640 - 00:14:18.850, Speaker B: Create a hard hub project. Okay module inserts finished. We can see that the lock contract has been generated.
00:14:18.850 - 00:14:51.130, Speaker B: This time, we will create a simple auction contract and explain how to create a normal contract so the first one is without emacs. Install the nestle module. Make it possible to import emacs interoperability plugin contract.
00:14:51.130 - 00:15:09.814, Speaker B: Once installed, we fix the solid version back to the simple auction contract. We can import the Offer Manager contract.
00:15:09.882 - 00:15:13.218, Speaker A: By writing it like this from here.
00:15:13.304 - 00:16:07.010, Speaker B: We will write code using INTMAX. In the constructor, we store the address store the address of the Offer manager ink Strange in the construct of causer register function. This function correspond to the INTMAX I register in the CLI and once a simple auction contract has transferred a certain amount or more through their Offer Manager to their message sender the token specified in Sara Asset ID is transferred to their Sarah amount to your address on INMAX.
00:16:07.010 - 00:16:31.488, Speaker B: Sarah INMAX is written to be updated with each bid so that it's written to you when there's no bid. Save the issue Friday to strange. Next, we modify the bid function.
00:16:31.488 - 00:17:07.980, Speaker B: We use their update taker function to allow their higher bidder to specify the address to receive the token on emarks. Finally, the claim function is modified. If there's even one bidder, we call their Offer Manager activates function which triggers their transfer or inbox by sending east to their larger bidder function via Offer Manager.
00:17:07.980 - 00:17:43.180, Speaker B: Also, remove the code for withdrawal amount on line 18 which is forgotten in Dpdl. If there are no bidders, call the deactivate function to pretend there was no offer. The withdrawal function does not need to be modified the send price function is removed because it is no longer needed after the previous modification.
00:17:43.180 - 00:18:34.758, Speaker B: Finally, check that completion passes. Deploy contract to scroll and prepare script to execute transaction register RPC URL and private key for scroll alpha testnet. The private key is obtained from the EMV file.
00:18:34.758 - 00:19:13.040, Speaker B: The address specified in the m file must have the scroll for testnet user deposited. Install m library. I copied the script from sample auction app.
00:19:13.040 - 00:19:27.410, Speaker B: The start auction function is executed by giving the seller's INTMAX address. The minimum bid is set to 0.1 ease.
00:19:27.410 - 00:20:43.890, Speaker B: Bid runs gabrinzer INTMAX address of the buyer bidding at 0.02 ease. This function get auction info.
00:20:43.890 - 00:21:35.768, Speaker B: Get the current bidder. Run claim. It fails because the auction has been open for less than two minutes.
00:21:35.768 - 00:22:27.030, Speaker B: So just wait for a moment. I run claim again. This time it succeeds and you get an explanation of what to do on inbox.
00:22:27.030 - 00:22:48.572, Speaker B: It shows their balance before activating to see the token moving on inbox to the auction.
00:22:48.636 - 00:22:49.440, Speaker A: Winner.
00:22:52.640 - 00:22:53.304, Speaker B: Activate.
00:22:53.352 - 00:22:54.140, Speaker A: Therefore.
00:23:09.120 - 00:23:51.484, Speaker B: After the activation, we can see that the tokens have indeed been moved. Finally, the seller performs a withdrawal function to receive the winning bid. So this is their example contract, example.
00:23:51.602 - 00:23:52.270, Speaker A: Project.
00:23:55.400 - 00:24:09.268, Speaker B: And finally their yeah, okay. Their receipt received is complete and this auction is now over.
00:24:09.434 - 00:24:12.160, Speaker A: Thanks so much for your time. Bye.
