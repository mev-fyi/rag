00:00:08.160 - 00:00:12.928, Speaker A: Hi there. My name is David Snyder. I'm one of the co founders at Lit Protocol.
00:00:12.928 - 00:00:44.540, Speaker A: And over the course of the next hour you will hear from me, Chris, Cassano and Debbie as we talk about what is Lit Protocol, how does it work and how to get started. And so the big question to think about here at the start of this is it's all about keys? Today we're going to talk about keys, key management and the use cases for distributed keys. So some of you may know who this is if you have seen the Matrix trilogy.
00:00:44.540 - 00:01:12.810, Speaker A: This is known as the key maker in that film, in that film series. But from the perspective of keys, if you're familiar with that story, what this individual is, is a centralized trusted custodian, a holder of keys. And so if you've seen that film, spoiler alert, it is the centralized holder of keys that gets compromised and in this story lets neo into the machine backend, so to speak.
00:01:12.810 - 00:01:46.276, Speaker A: And so I use this example, just as a fun example from fiction to illustrate the idea that a centralized holder of keys in our network era that we are all living in really doesn't make sense. And we've been addressing this problem quite specifically over the past few years. And so it really comes down to a big question of where are keys stored? And so another way to say this is can the internet keep a secret? And what we're going to see today is that the answer is yes.
00:01:46.276 - 00:02:05.720, Speaker A: And we'll talk about the methods for doing that. I'll give a brief overview and then Chris will dive into some more detail. But in short, lit is a key management network that uses something called multiparty computation and threshold secret schemes to hold a key in distributed custody.
00:02:05.720 - 00:02:27.564, Speaker A: Then developers can use that distributed custody key for the same thing that you used keys for in general, which is encryption and signing. And we'll take a look at a number of examples in a moment. And some of the core processes at the heart of this are things like distributed key generation, proactive, secret sharing and secure encrypted virtualization.
00:02:27.564 - 00:02:49.504, Speaker A: And this is the methods for distributing the key and protecting the private key material to ensure even the node operators don't have access to it. And really kind of the key insight here, no pun intended, is that nobody ever has the whole key. The whole notion of a distributed key generation is you can have a bunch of parties holding something called a key share.
00:02:49.504 - 00:03:05.228, Speaker A: And this is a threshold crypto system where you need a threshold of the network. In the case of lit, that's two thirds in order to authorize any decryption or signing with that underlying P. So let's talk about the two use cases here.
00:03:05.228 - 00:03:18.864, Speaker A: The first one that we'll talk about is decryption. So these hexagons here in the middle represent the nodes which are custodying. This distributed key again, none of them is a centralized custodian, none of them have the whole key.
00:03:18.864 - 00:03:35.068, Speaker A: And these nodes can read data from public state like blockchains and then determine if a rule is correct and provision access to another person. So, an example of how this might be used is Alice. Let's say Alice is a content creator.
00:03:35.068 - 00:04:08.128, Speaker A: Alice can write a book and can encrypt it client side and then say anybody who buys my NFT, they should be able to decrypt my book. And Alice can take that encrypted Blob and store it on a blockchain or store it on a distributed storage network like Filecoin or Rweave or IPFS based system like Ceramic. And when Bob shows up later on, he can sign a message and broadcast that to the nodes that says hi, I'm Bob, I own Alice's NFT, please give me the key to decrypt the book.
00:04:08.128 - 00:04:25.844, Speaker A: And the nodes can validate in this case against the chain data. Does Bob hold Alice's NFT? And if yes, each of these nodes creates an authorization known as a decryption share and sends it down to Bob. And Bob collects those on his machine client side in order to perform that decryption.
00:04:25.844 - 00:04:54.188, Speaker A: And so what we've got here is really quite cool because there's client side encryption, client side decryption, but the two parties never had to meet because lit is this network, this distributed network that is validating the rules and provisioning the keys. And so another way that this is conceptualized is something called identity based encryption, which definitionally, at least before this offering, did require a central authority. Here you can see the definition from Wikipedia.
00:04:54.188 - 00:05:13.888, Speaker A: But again, lit is the distributed network alternative to doing a central authority, identity based or rules based or conditional based encryption. And so let's look at a couple specific use cases. If you're familiar with Lens Protocol, it is a social media protocol where everything is an NFT.
00:05:13.888 - 00:05:35.996, Speaker A: What I mean by that is like liking, following, et cetera are all on chain NFTs. The Lens Protocol team has integrated lit inside of their SDK in order to create gated posts. So when you go and post on Lens Protocol, you can say only collectors can view this, which is like the equivalent of liking the post, you collect it, or only people who follow me can view this post.
00:05:35.996 - 00:06:05.210, Speaker A: And the encrypted Blob is stored on IPFS and only the parties that meet these rules can perform the decryption. So all of a sudden this creates like a patreon like benefit to these creators that are using Lens. This is also live in Orbis Club for token gated messaging, which is another kind of cool use case, quite similar, but in this case it's more about chat content rather than social content.
00:06:05.210 - 00:06:39.084, Speaker A: And we can also look at this in the context of verifiable credentials. So what we're looking at here in this video is on an application called Credit, where a user is using a third party service to do KYC or know your customer validation. When that proof that in this case, that somebody is over 18 is sent back to the user, it's the same process again where the user is going to encrypt that proof.
00:06:39.084 - 00:07:08.776, Speaker A: Client side is going to encrypt that proof. Client side and is going to encrypt that proof client side and then can set a rule, a selective disclosure around who is able to see that proof. Looks like there's a little bit of video trouble here, but just to repeat, again, get some data, encrypt it client side, it can be KYC data in this example, and this is quite interesting because it's also a verifiable credential.
00:07:08.776 - 00:07:29.730, Speaker A: So it's some signed JSON linked data that in this case is encrypted and stored on ceramic. And then the user, in this case, the individual who's over 18 can have the selective disclosure in the form of provisioning decryption rights via lit to that data. Let us proceed here.
00:07:29.730 - 00:08:00.700, Speaker A: And the other ways that this encryption mechanism is being used is for things like data marketplaces. So this is the logo of a project called Streamer Network that uses lit to let data producers create data, encrypt it, store it on the open web, and then set a rule like you must buy this NFT in order to decrypt that data set. Again, having it be rules based or condition based is kind of the main insight around conditional encryption.
00:08:00.700 - 00:08:35.220, Speaker A: And as mentioned earlier, it's not just chain data that you can use for the rules for who can decrypt this, but really, any data on the web, whether you can get it from an API, an Http request, whatever it might be, any statement that can be made, true or false, can be used as an input for this encryption data. And it's also worth noting that things like cross chain support, boolean logic, all of that. Sophistication if you wanted to implement that in your conditional decryptions, you could.
00:08:35.220 - 00:08:46.004, Speaker A: And those are all in the lit docs. Now let's talk about the other part of keys. So as you know, public key cryptography in general basically has two core features, which is encryption.
00:08:46.004 - 00:09:05.372, Speaker A: We just talked about conditional encryption and signing. Signing is really interesting because you have to sign a transaction in order to make an on chain interaction, in order to log something to the distributed ledger that we call blockchain to that state machine. And so what we're looking at here is a very similar kind of diagram.
00:09:05.372 - 00:09:34.308, Speaker A: As you can see, it's the same underlying architecture, but in this case there is some code, some JavaScript code, and Chris will talk more about this that dictates when this distributed key should sign. And then the nodes can process that JavaScript and output in this case, rather than an authorization to decrypt, an authorization to sign. And so there's a distributed key that is being managed by this network that is signing based on rules.
00:09:34.308 - 00:09:46.696, Speaker A: And again, it's not just one node that is authorizing a signature, but a threshold of the nodes. So 20 out of the 30 nodes in the network. And so let's take a look at some examples.
00:09:46.696 - 00:10:20.736, Speaker A: Here one pretty excellent use case for leveraging. This is for user onboarding where you can do things like set up Discord or Google or Web authent as the authentication method where the private key is held and lit in this distributed network. But the user's Credential in this case OAuth from Google or Discord can basically the network can validate that in that 20 out of 30 model that we discussed before and functionally create an authorized transaction from that distributed key.
00:10:20.736 - 00:10:40.380, Speaker A: So that is pretty exciting as it relates to onboarding if you're building a product that is maybe for non web three natives. This is also really interesting around decentralized finance automation. So what we're looking at in this video is a project called Yacht Labs.
00:10:40.380 - 00:11:10.884, Speaker A: And underneath the hood here there are two parties which are represented by these two windows and there is one of these PKPS, these programmable key pairs which is this programmable key that's managed by lit that we just discussed. And so what is happening here is this team has programmed that PKP or programmable key pair to act as an automated escrow agent for cross chain swaps. So Alice is on Arbitrum and Bob is on ethereum.
00:11:10.884 - 00:11:51.424, Speaker A: They can both send tokens to this wallet and when they both approve a swap happens to the other person's address. And so as we kind of look along here, we can see Alice has set everything up. Go back to that, we see Alice has set up the swap and now Bob is sending in from his side and the swap is ready on Alice's side and now the swap is ready on Bob's side and then they can receive the tokens once they've sent them to that escrow agent.
00:11:51.424 - 00:12:11.610, Speaker A: This is really interesting. Certainly it can apply to swaps, but it may be also interesting to explore using this capacity to program keys for structured financial products such as liquidity loss prevention on DEXes, dollar cost averaging, stop loss orders on stake tokens. Definitely a lot of room for creativity here.
00:12:11.610 - 00:12:35.980, Speaker A: And then one more example from Krebit. What we're looking at here is a video where the Lit PKP which has the capacity to sign programmatically is being used to issue a Verifiable Credential. So Verifiable Credential is some signed data, some signed JSON LD typically, and in this case the user is signing into Discord.
00:12:35.980 - 00:13:03.508, Speaker A: Then a lit is validating that that user has generated that JWT, that OAuth token if you will, from Discord. And lit is essentially signing that and says yes, this address in this case is in fact this user. But what's nice about the way that this team has implemented it is that Verifiable Credential is encrypted and stored on ceramic in this case.
00:13:03.508 - 00:13:15.740, Speaker A: So once again, it uses that private data, it uses that encryption aspect that we talked about before. And if you want to look at these demos more in depth, you can find them all at the Lipprotocol.com blog.
00:13:15.740 - 00:13:44.080, Speaker A: And so that about wraps it up for my section. I'll include a request for startups if you need some ideas in terms of thinking about what you can build with lit. But really the thing before I kind of pass it off to the next person that I'd like to stress here is that this is really a new primitive that you can think very creatively with if you're familiar with how lambda functions work, or serverless functions.
00:13:44.080 - 00:14:03.152, Speaker A: Essentially what lit is, is like a lambda service function and a key management solution, but network based, that's distributed and fault tolerant. I'm really looking forward to seeing what gets built in this event and interacting with a number of you. And with that I will pass it off to Chris.
00:14:03.152 - 00:14:04.250, Speaker A: Thanks so much.
00:14:07.660 - 00:14:35.250, Speaker B: Hello, my name is Chris Cassano and I am here to talk to you about how lit protocol works. Lit Protocol is a decentralized and programmable key management network. What does that actually mean? What that actually means is that lit protocol is a network of node operators similar to like bitcoin nodes or ethereum nodes or something like that.
00:14:35.250 - 00:15:01.396, Speaker B: But what the nodes actually do instead of running a blockchain is they provide key management services. And that means things like giving you keys, providing access to keys when certain conditions are met, signing for you, all kinds of things like that. And it is a generalized programmable network.
00:15:01.396 - 00:15:23.170, Speaker B: Basically the goal of lit protocol is to take this amazing new technology of threshold cryptography and put it into your hands as a developer. And we really want to make it as easy as possible to use this technology and fully programmable. So you could do whatever you want with it.
00:15:23.170 - 00:16:16.000, Speaker B: And the thinking is that you could set up your own threshold cryptography network of nodes, but it's a huge pain, right? Who wants to manage nodes? So instead you can use our nodes and write programs that run on them and do whatever you would like with that. So if you're not familiar with threshold cryptography, the general idea is that you perform a process called distributed key generation. And for this example, let's say that we have a network of 30 nodes and we're going to set a threshold of two thirds, which means that you need 20 out of the 30 nodes to participate in order to use keys within this network.
00:16:16.000 - 00:16:46.284, Speaker B: And so you have 30 nodes and they come together, they perform this process called distributed key generation. And what this does is create a public and private key pair just like the one in your ethereum wallet, but nobody knows the private key. Instead, each node operator only has a private key share and they're able to do the same things with that private key share that you are with a regular private key like sign and decrypt things.
00:16:46.284 - 00:17:15.940, Speaker B: But the difference is that somebody has to combine the resulting signature shares or decryption shares above the threshold to get out a decryption key or a signature. And so in our case of a 30 node network with a two thirds threshold, you have to get a signature share from 20 out of 30 nodes. You can combine those signature shares into a final signature.
00:17:15.940 - 00:17:56.112, Speaker B: And there's kind of like two broad areas of use of lit protocol. One is decentralized access control and in this case, the threshold cryptography is generally used for encryption and decryption. And so some really cool use cases of things like this are let's say you are in a Dao and you want to encrypt some content, upload it to IPFS or Rweave or some kind of public storage, but you only want your Dao members to be able to read it.
00:17:56.112 - 00:18:11.044, Speaker B: You don't want everybody else in the world to be able to read it. If you think about this, it's actually kind of a hard problem if you just use some encryption key that you made up, then you have to share that encryption key with every member of the Dow, right?
00:18:11.082 - 00:18:12.356, Speaker A: Maybe you go on discord, you share.
00:18:12.378 - 00:18:28.456, Speaker B: It with them on there. But then what happens when somebody leaves the Dow? Right now, all of your content is encrypted using this key. You have to rotate the key, give everyone a new key, right? It's like a huge headache.
00:18:28.456 - 00:18:46.220, Speaker B: You can imagine, right? Every time someone joins or leaves, you have to do like a whole operation, basically. And instead, what you can do is encrypt your content using lit. You can set an access control condition that says user has to be a member of a Dao.
00:18:46.220 - 00:19:12.360, Speaker B: And what that means is that somebody on the right here, this is like a user in a web browser or something can make a request to the lit nodes. The lit nodes are these hexagons in the middle, and they can say, hi, I'm in this Dow, I would like to decrypt this content. And they present a wallet signature from their wallet, just a signed message.
00:19:12.360 - 00:19:49.540, Speaker B: And the lit nodes check that signed message and say, okay, this user does actually own this wallet. And then the lit nodes each individually check with the blockchain to see, okay, does this wallet actually meet the condition Aka? Is it actually in the Dow still? Right? And if it is, then each lit node will use its private key share to create a decryption share. The user will collect all of these decryption shares above the threshold, and then they are able to decrypt the content.
00:19:49.540 - 00:20:10.684, Speaker B: And lit supports tons of access control conditions. It's not just like if you're a member of a Dao, that's just an example. You could also do things like does the user hold an NFT? You can basically anything that lives on chain you can use as an access control condition and you can use any smart contract function if you want.
00:20:10.684 - 00:20:39.110, Speaker B: You could make a smart contract that says that checks a ZK proof and says only let a user in, or only let a user decrypt content if they present a ZK proof that's valid, that meets some condition, right? Anything that you can imagine, you can basically use as an access control condition. And we also support essentially using JavaScript as an access control condition where you can say only let the user decrypt if a JavaScript function returns. True.
00:20:39.110 - 00:21:03.752, Speaker B: And we'll talk a little bit more about those JavaScript functions later, which we call Lit Actions. So what is this useful for? It's really cool for permission and private data on the public web. So you could imagine if you're using a cool, fancy, new, decentralized social network and it stores its data on IPFS.
00:21:03.752 - 00:21:14.160, Speaker B: Awesome, right? Anybody can get the data. It's this beautiful open system. But wait, that also means that anybody can read all of your posts, right? There's no privacy.
00:21:14.160 - 00:21:46.280, Speaker B: What you can do is encrypt your posts with Lit Protocol and you can set your access control conditions such that all of your friends are allowed to decrypt it. And that's great, because now you don't have to self host the data, right? It's hosted on IPFS, on the public web, but it's permissioned in private, in that you can still control who is able to access it and when. Another use case for Lit Protocol is essentially signing.
00:21:46.280 - 00:22:00.560, Speaker B: So the first case we talked about was reading from blockchains in order to decrypt something. This use case is talking about writing to blockchains. And the way that you write to a blockchain is with a signature.
00:22:00.560 - 00:22:26.920, Speaker B: The lit nodes hold private key shares and they're able to create threshold signatures that can be used to write to a blockchain. And the way that the lit nodes actually do this is that you are able to upload some content, some JavaScript code to IPFS. And this is called the lit action.
00:22:26.920 - 00:22:45.948, Speaker B: And once it's on IPFS, it's immutable because IPFS is content addressable. So you can kind of think of these like LIT's version of smart contracts, but they're in JavaScript, so they're really easy to use. And these Lit Actions are allowed to also read from the web.
00:22:45.948 - 00:23:13.392, Speaker B: They can make HTP requests, so you can pull in data, you can do all kinds of things that would be really hard to do on traditional blockchain. And so basically, kind of how this actually works is a user shows up and says to the lit nodes like, hi, I would like you to run this program on IPFS. And each lit node pulls this program down and runs it.
00:23:13.392 - 00:23:34.460, Speaker B: And if the program asks for a signature, each node creates a signature share. The signature shares are collected by the user. The user combines them and is then able to broadcast them to or broadcast the resulting signature to a blockchain.
00:23:34.460 - 00:24:15.480, Speaker B: And so that's how you can use lit to write to a blockchain in addition to read. And we think that this is like a really powerful new primitive that you can use for all kinds of things in cryptography. And one thing that I haven't really talked about yet is when you're writing to this blockchain, when these nodes are signing using a private key share, whose private key is this? Right? Is this the network's private key? Which private key shares is it using? And that's where the concept of a programmable key pair comes in.
00:24:15.480 - 00:24:41.856, Speaker B: A programmable key pair is an ECDSA key pair, which is the algorithm that Bitcoin, Ethereum and Cosmos use. And the lit nodes hold the private key shares that correspond to this key pair. You can create a paramable key pair, aka a PKP, by minting an NFT that represents ownership over that PKP.
00:24:41.856 - 00:25:06.276, Speaker B: And then whoever owns that NFT can ask the lit nodes to sign anything on their behalf using the private key shares that correspond to that PKB, including Ethereum or Bitcoin transactions. And I'll show you how this works right now. So this is a lit action, very basic lit action.
00:25:06.276 - 00:25:18.508, Speaker B: And what it does is it defines something to be signed. This is just a simple array that contains the string hello world. But this could be a transaction that you want to sign.
00:25:18.508 - 00:25:26.000, Speaker B: This could be a right to ceramic. Anything that requires a signature, you can sign. It's very, very flexible.
00:25:26.000 - 00:26:01.710, Speaker B: And what you see here is that we are requesting that the lit nodes sign this data using this key and store it in the result of named SIG one. And basically what's happening is the lit nodes hold the private key shares that correspond to this public key. And so when you ask each lit node to do this, it's able to create a signature share.
00:26:01.710 - 00:26:20.840, Speaker B: And those signature shares all get returned to the user, who's able to combine them into a final signature. So here's sort of a basic overview of how that works. The user creates some kind of authentication that could be a Wallet signature.
00:26:20.840 - 00:26:36.452, Speaker B: It could be an OAuth token. We support Google and Discord, and we're working on adding phone and email authentication as well. And they make a request to the lit nodes.
00:26:36.452 - 00:26:52.364, Speaker B: They talk to every single lit node in parallel, and they present their authentication. And they also present an IPFS ID. And they say, hi, lit node, please run this code for me.
00:26:52.364 - 00:27:19.584, Speaker B: The lit nodes pull down the code from IPFS, right, and load it into a JavaScript runtime. The JavaScript runtime executes the code, and it actually checks that the user is authenticated and allowed to actually use the PKP. And the lit action is also allowed to pull down any data from anywhere on the web using an HTP request.
00:27:19.584 - 00:27:45.980, Speaker B: So you can use it like an oracle. You can pull in data from anywhere in the world and use it in your computation. And then if your lit action wants to sign, it can request that the lit nodes use their threshold private key share to create a signature share, which is then returned to the JavaScript runtime.
00:27:45.980 - 00:28:23.850, Speaker B: And what happens is the user down here is running this request across all the nodes and collects signature shares from all the nodes. The user is able to combine those signature shares into one signature and then can then broadcast the signed transaction or use that signature for whatever they want to use it for. And we have a TypeScript SDK that you can use that basically does all of this for you and abstracts it all away, where you just kind of like create a request pass in what you need and you get back a signature at the end.
00:28:23.850 - 00:28:50.770, Speaker B: Another cool pattern that you can use is the mint grant burn pattern. This is really interesting because a PKP, because it's created as an NFT on a blockchain, you can basically create the NFT and mint it. You can grant the access for it to use like some lit action and then you can burn it.
00:28:50.770 - 00:29:19.372, Speaker B: And what that essentially does is lock the PKP such that it can only be used by this lit action forever. Now, interesting kind of toy use case of this, right, is suppose you have a Lid action, so you have some JavaScript code that given a number as input, will check if that number is prime. You can mint grant burn a PKP on that lit action and then you can pass numbers in.
00:29:19.372 - 00:29:35.760, Speaker B: And if the number is prime, then each lit node is running this independently. It will sign using its private key share. The user collects all the signature shares, combines them into a signature.
00:29:35.760 - 00:30:08.840, Speaker B: That signature essentially proves that any given number is prime because the corresponding programmable key pair can only ever be used to run that program. And so what you kind of end up with is something that functions similarly to a ZK proof in the sense that you have a signature that proves that all of the nodes in the network got the same result. And now you don't have to check if a number is prime if it's signed.
00:30:08.840 - 00:30:48.116, Speaker B: Instead, you can trust the signature because you know that the only way that the signature could have been produced from the corresponding PKP is if the lit nodes ran the program correctly and that you got the result that it expected, right, which is the number is actually prime. And you can use this for anything, right? You could use this to certify or to prove that suppose you have to prove that you're in a city, but you don't want to prove where in that radius that you actually are. You just want to prove that you're in a radius without giving away your real latitude.
00:30:48.116 - 00:31:09.084, Speaker B: And longitude. You do something like that, you could prove that the weather was a certain temperature on a certain day in a certain place and time. Because you can pull in data from the web using Http requests, you can essentially create proofs of anything on the web very very easily and very very quickly.
00:31:09.084 - 00:31:31.296, Speaker B: And the proofs are ECDSA signatures so you can pass them right into a smart contract which is able to check those and verify them. A couple other cool use cases, you can use a PKP as a vault. What this means is that a PKP is a public private key pair.
00:31:31.296 - 00:32:05.244, Speaker B: It's a wallet, you could send 100 NFTs to it, right? And then you can trade all 100 NFTs at once because you can actually sell the PKP NFT itself, which is the NFT that controls the PKP to another user. And you effectively have just sold the underlying private key that owns all of those NFTs. And remember, the private key never exists, it never gets created anywhere.
00:32:05.244 - 00:32:49.170, Speaker B: Instead the lit nodes only have private key shares and so you can effectively trustlessly trade a private key in a way that you never could before. This basically breaks things like soulbound tokens. A lot of anti sybil mechanisms like for example Gitcoin passport or polygon ID can be broken by this because now you can actually sell the wallet that owns the sole bond NFTs, right? That's something that you could never do before because in order to do that with a regular private key that you are just like looking at, you would have to prove that you've forgotten the private key, right? And you can't prove that, it's impossible to prove that.
00:32:49.170 - 00:33:04.352, Speaker B: But with lit, since the private key never exists, you are able to actually trade that. You can also use a PKP as a cloud wallet. Lit supports a ton of different auth methods.
00:33:04.352 - 00:33:25.000, Speaker B: So I talked a little bit about like if you hold the PKP NFT, you can ask the lit nodes to sign using that PKP. That's just one of a ton of different auth methods that we support. We also support OAuth with Google and Discord, we support web authent.
00:33:25.000 - 00:33:58.080, Speaker B: We're working on email and phone soon, we don't have that yet, but we will soon. And that basically means that you can use any of those things as auth and there's a smart contract on chain that you can use to set up your auth for a PKP. So you could say I'm going to onboard new users and all they have to do is log in with Google using Google OAuth and I'm just going to pass that Google OAuth access token to the Litnodes as proof.
00:33:58.080 - 00:34:15.048, Speaker B: The lit nodes can verify that access token and let the user sign using that know, assuming that you've set up that user to auth using that Google account. So it's great for onboarding like you don't need to do seed phrases, you don't need. To worry about anything like that.
00:34:15.048 - 00:34:25.612, Speaker B: You can get people a wallet very quickly with one click. You can also use PKPS for automation and signing. So this is a super cool use case.
00:34:25.612 - 00:34:43.924, Speaker B: It's like, imagine you're in some cool 10,000% APY farm and you're like, this is great. I'm making tons of money, but if the token price tanks, then I'm going to lose all my money. We sure would like it if there was some kind of way to set up a stop loss order.
00:34:43.924 - 00:34:54.852, Speaker B: But your tokens are staked. You can't sell staked tokens with lit. You could set up a lit action that checks the price of the token.
00:34:54.852 - 00:35:28.140, Speaker B: If the price of the token drops below a certain level, then it creates a transaction to unstake the tokens, and then it creates another transaction to sell them on uniswap. And you could basically be polling this, have this lit action run every ten minutes or something, right? And if the token price starts to tank, then this will unstake and sell your tokens. And this is really cool because it's just using Raw ECDSA signing.
00:35:28.140 - 00:35:38.550, Speaker B: You can do anything you could do with a regular wallet with this. So you could do things that are cross chain. You could use bridges, literally, like, whatever you can imagine, you can build.
00:35:38.550 - 00:35:58.232, Speaker B: And in order to do this in a sort of traditional way, you would have to set up a hot wallet on a server, kind of like a trading bot type setup. It's very, very prone to error. Having a private key on a server as a hot wallet is really scary.
00:35:58.232 - 00:36:15.760, Speaker B: Like, it's a huge target for attacks. And so this kind of like using lit for this instead gives you the protection of the decentralization, right? Like, somebody doesn't need to hack one computer to steal your money. They need to hack two thirds of the lit nodes.
00:36:15.760 - 00:36:42.520, Speaker B: And the lit nodes run inside of a trusted execution environment powered by AMD Sev SNP. It's actually a secure encrypted virtualization environment, so node operators can't see what their nodes are actually doing. It's fully opaque, and so it's very hard to hack into, and that's part of why we've built it that way.
00:36:42.520 - 00:36:55.660, Speaker B: So anyway, here's some really cool ideas of what you can build with lit. And check out the docs at getlit dev. If you have any questions, pop into discord.
00:36:55.660 - 00:37:02.130, Speaker B: We're always around and we are so excited to see what you build. Thank you.
00:37:02.580 - 00:37:23.280, Speaker C: I'm Debbie and I lead Developer Relations at Lit Protocol. And today I'm going to go over how do you interact with lit, how do you build with lit, as well as some of our documentation and examples that we have ready for you all. So to get started, we're on our documentation page.
00:37:23.280 - 00:37:39.530, Speaker C: So, Developer Litprotocol.com is the home of all of our developer docs on how do you build with lit. Core concepts around lit, as well as example projects and tutorials that you can find.
00:37:39.530 - 00:37:48.700, Speaker C: So it's a bit of a choose your own adventure to start where if you want to start with code first, if you start with examples or do you want to start with concepts.
00:37:50.420 - 00:37:50.784, Speaker A: For.
00:37:50.822 - 00:38:19.268, Speaker C: This hackathon, I want to talk about our product, our programmable key pair and lit actions product which enable programmatic signing and what's possible with programmatic signing with us. So let's dive into first these use cases. So PKPS we see as a way to introduce automation interoperability into DApps.
00:38:19.268 - 00:38:52.380, Speaker C: So what that might look like is for DeFi automation, you can use PKPS and Actions to automate your interactions. So that might mean condition based transactions, recurring payments, liquid staking solutions, or frictionless transaction execution. We have an example just released around using an event listener platform that we've been working on to kick off Lit Actions that does portfolio rebalancing.
00:38:52.380 - 00:39:08.164, Speaker C: So being able to set a trading strategy based on a percentage of what you want your portfolio to look like and then kicking off trading and that swapping is done with uniswap. So be sure to look for that. We have a whole list of examples.
00:39:08.212 - 00:39:09.770, Speaker A: For you all to build with.
00:39:11.580 - 00:39:37.280, Speaker C: And then some more ideas would be around infrastructure as well as Web Three social. So on the infrastructure side, being able to do cross chain bridges, oracles for off chain data. So really leveraging the power of MPC and being able to take in a Web Two endpoint or take in some other kind of bridging data on chain and off chain.
00:39:37.280 - 00:40:25.564, Speaker C: And then on the Web Three social side, thinking about Credentialing systems, user and social graphs as well as a big thing we've been thinking about is account abstraction with support for Web Two auth methods. So being able to authenticate through Google, Apple, Pass key discord, and then having an underlying Web Three wallet associated with that and really abstracting out how someone thinks about their wallet, where rather than saving passphrases, having different recovery methods and ways to access and use a Web Three account. And then lastly, we think a lot about gaming and how programmatic signing can enable different unlocks within gaming.
00:40:25.564 - 00:40:57.736, Speaker C: So signing a wall abstraction for blockchain based games, that programmatic signing app element is really useful with these set programs. So NPCs, non playable characters, being Actions characters, different assets and games that have movement and other interactions just that are very codified, as well as some other ideas around condition based report systems and achievements. And yeah, we're always looking to see really novel projects.
00:40:57.736 - 00:41:31.204, Speaker C: So even outside of this list, please build something that's super cool and that you'll have fun doing. So, next, going down, I'm going to give a little bit of an intro of how y'all would get a programmable key pair as well as after minting your PKP, how do you use that to sign Verlit action? So let's go to the PKP Explorer actually. So PKP explorer you can find it.
00:41:31.204 - 00:41:48.030, Speaker C: I'll go back again here within that program key pair introduction, you can go to that Explorer from the very first page, that introduction. So within the Explorer, you can mint the PKP. So here, I'm going to mint one.
00:41:48.030 - 00:41:57.980, Speaker C: So you'll need some matic to mint. Just go to the test matic faucet and then be able to get that Maddox. So confirming.
00:41:57.980 - 00:42:21.100, Speaker C: Okay, I have one pending transaction. Okay, this was my PKP that we just saw me mint. Let's go view it.
00:42:21.100 - 00:42:29.270, Speaker C: We can check out that public key right here, as well as that ETH address. Okay, sweet. We've got our PKP, so let's go back.
00:42:29.270 - 00:42:49.900, Speaker C: So we want to use our PKP with Litaction. So I'm going to go into our lit action, and everything that you need to know about Lit Actions is within our documentation. If you have any questions, please ask our discord tweet at us.
00:42:49.900 - 00:43:10.130, Speaker C: And the easiest way to test and build with Lit Actions is actually with our Litaction CLI tool. So going into here, it's the getlit CLI command line tool. So it'll help you create your Lidaction, test it, and then once that's ready, you can take that Lid action and put that within your project.
00:43:10.130 - 00:43:26.040, Speaker C: So first install the getlit CLI. I already have that installed. So actually, what I'm going to do is start actually in creating that project.
00:43:26.040 - 00:43:51.216, Speaker C: So from this very first step, that command, we'll need to initialize a new lit project. We'll just initialize it in this folder here. So we've created Actions, and then we want to let's say we want to just test it.
00:43:51.216 - 00:44:23.600, Speaker C: Okay, so if this is your first time setting up the CLI, you'll need to edit that foo file to be able to build it. So every file should have a let's see. Okay.
00:44:23.600 - 00:44:35.174, Speaker C: Every lit action file within here should have actually a name. So that's like that proper schema here. When we check foo, we have that name.
00:44:35.174 - 00:44:51.500, Speaker C: When we check hello or that main, we have that name. And so let's try writing that again. Actually, I skipped a step.
00:44:51.500 - 00:45:14.910, Speaker C: So actually, before we even do that build, we actually have to do the setup. So what the setup does is you get the Auth SIG as well as you tie your PKP. And so generally, if you're writing out a Lid action and you're writing out that code for it, you would put in that PKP public key address.
00:45:14.910 - 00:45:35.540, Speaker C: But here we actually have a way to help you sign for it through UI and then have that within your lit action. So let's actually do get lit setup. And then what you'll see here is this page that popped up.
00:45:35.540 - 00:45:44.816, Speaker C: And then I have a million PKP, so I'll just select one. Okay, great. So Authig and PKP have been saved.
00:45:44.816 - 00:45:52.250, Speaker C: Here config file. You can view them at the getlit JSON. Let's take a look, actually at that really quickly.
00:45:52.250 - 00:46:07.388, Speaker C: So here we have this Authsig. So signature as well as our PKP public key. And then from there, we've updated our food.
00:46:07.388 - 00:46:17.312, Speaker C: That naming is all correct. So actually, let's do a build first before we test. Great.
00:46:17.312 - 00:46:31.342, Speaker C: Build is successful. Why don't we do a test now and test we'll just test foo. Great.
00:46:31.342 - 00:46:44.580, Speaker C: And then let's test main. And I'll show you that code for main. So main is just a simple hello world array that gets signed and then output back.
00:46:44.580 - 00:47:09.260, Speaker C: And so what we're seeing here is that sign DSA function, which we're calling the lit nodes. To sign this message, likely within your project, you'll be using the execute function. So execute JS where you want to execute a lit action that has some logic or some conditional baked in it.
00:47:09.260 - 00:47:29.742, Speaker C: So here we see the signatures have been generated. Great, let's go back here. So outside of that CLI tool, which will help you just get set up really quickly on lit actions likely.
00:47:29.742 - 00:48:21.950, Speaker C: So requesting the signature saying sign, those are the examples that we've really been seeing with this lit action likely going here, what you'll want to do is so for this example, we're calling execute JS, where you'll execute based on some parameters from your lit action code. So example of that might be conditional signing where you only want to sign based on some condition being met. In this case, this is like the condition is if a user has x ether x way and then calling this xqs to be able to do that.
00:48:21.950 - 00:48:39.350, Speaker C: And we have a set of examples on our Replit, so please be able to check that out. As well as fork. Those examples run those.
00:48:39.350 - 00:49:15.688, Speaker C: They're mainly here for you to understand how to build with lit. And then the last thing that I'm going to go over is using how do you set up a way to tie in a Google account with a PKP and then allow people to use that PKP or the underlying Web Three wallet essentially to do Web Three native things. So this will help a lot with onboarding Web Two users to Web Three.
00:49:15.688 - 00:49:48.470, Speaker C: This will help with abstracting away a lot more complicated ideas around keys and key management. So be sure to go to this example, PKP social auth example, and let's go through the flow of it first before I explain some of that code. So here we're going to sign in with lit, and I want to just view my lit protocol account.
00:49:48.470 - 00:50:09.260, Speaker C: So I'm going to select one and then I'm going to sign this message. So in another flow, this would actually mint a PKP for the very first time that I'm loading this in. And then I'm going to sign the message.
00:50:09.260 - 00:50:46.900, Speaker C: So this is my signature and this is my address. And we'd be able to check that on chain. So in this example, we have just a basic repo of how do you set up calling lit, calling our relay server, calling the google PKP API as well, and being able to use that all together to quickly spin up an application where someone could just sign in from just Google.
00:50:46.900 - 00:50:58.772, Speaker C: And we have additional auth methods as well. But you'll need to build in some of those relayers as well. As part of our relayer is a gas abstraction.
00:50:58.772 - 00:51:46.886, Speaker C: So building that in but you could also use many different ways of paying for that gas, not just through lit, but through many other services. Okay, so then now I want to close out a little bit with just letting you all know the resources that are available with our SDK. So making sure that you all know that we have our API docs, as well as examples within our reference here, and then further downline outside of this hackathon, please reach out to us about grants, about things you want to build.
00:51:46.886 - 00:52:09.390, Speaker C: We're looking for ambassadors as well. So being able to support this ecostys system where we're really trying to build decentralized technology to push forward data privacy, to push forward usability of web three. So thank you so much, and I look forward to seeing you all in Tokyo and see what you outbuilt.
