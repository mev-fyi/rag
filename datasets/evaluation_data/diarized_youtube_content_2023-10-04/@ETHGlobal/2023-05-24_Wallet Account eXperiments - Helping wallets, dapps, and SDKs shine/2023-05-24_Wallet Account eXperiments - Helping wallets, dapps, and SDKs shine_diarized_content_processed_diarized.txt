00:00:07.530 - 00:00:13.754, Speaker A: Yeah. So my name is James and we are Wax. We're a team within the Privacy and Scaling Explorations Group and the Ethereum Foundation.
00:00:13.754 - 00:00:35.666, Speaker A: And yeah, our focus is well, the PSE's focus is enhancing ethereum through cryptographic research and we are one of the teams who is exploring a scaling solution. So the privacy and Scaling exploration does a lot of things around privacy, but yeah, our focus initially was on scaling. So in today's talk, we'll be talking over the BLS signature Aggregation, which is where we began.
00:00:35.666 - 00:00:53.622, Speaker A: We'll be talking about user operation compression and reducing costs with that additional verifications that we'll be exploring in our V two and also integrations and how we can make that easier for everyone to integrate and use. And then we'll conclude with the summary. So let's begin with BLS signature aggregation.
00:00:53.622 - 00:01:11.154, Speaker A: So the problem we're trying to solve is the roll up cost problem. So we all know layer twos are cheaper, but we can actually get more savings by doing something called signature Aggregation. For every transaction on a layer two, you've got the transaction data as well as the signature data that gets rolled up to layer one, and that's a significant cost.
00:01:11.154 - 00:01:28.210, Speaker A: With BLS signature Aggregation, we use a different signature scheme that lets us combine every transaction signature into one. So instead of having say, 200 transactions with 200 signatures being rolled up, only one signature needs to be rolled up. So the cost reduction is quite large for the signatures.
00:01:28.210 - 00:01:40.174, Speaker A: And this is possible because rather than use the protocol's ECDSA signature scheme, we're using a different signature scheme which needs to be verified on chain. And for that we need a Smart contract wallet. So lots of in at once.
00:01:40.174 - 00:02:11.590, Speaker A: But basically the way I sort of visualize BLS signature aggregation is that you'll have many unique transactions, sorry, many individual signatures, but they can be combined together or aggregated into one, basically the space of one, but still give you the ability to verify that all of the individual transactions were signed by the corresponding public keys. So again, it's just a nice thing mathematically that BLS does that I don't understand, but we just get to use it from the outside, which is quite nice. So we want to make that easier for others to use and benefit from.
00:02:11.590 - 00:02:24.780, Speaker A: Under the hood, it's something like this. Each private key signs a message to use the corresponding public key to verify all against the single signature. But we don't need to worry too much about that.
00:02:25.710 - 00:02:26.294, Speaker B: Overall.
00:02:26.342 - 00:02:50.862, Speaker A: The way we can make that work is that within the wallet we'll need something that can sign with the BLS scheme and that's a client module on the left. That'll then send the signed user operation, as we're calling it, to an aggregator, which will combine many different user operations and BLS signatures into one. And then submit that on the right to the smart contracts on a layer two, which is our verification gateway and BLS wallets.
00:02:50.862 - 00:02:59.202, Speaker A: That's sort of just the pieces, broad brushstroke. But when we zoom in a little bit, this is what it looks like. Adapt will propose a user operation.
00:02:59.202 - 00:03:14.758, Speaker A: Now this terminology that we're using is four three seven terminology or account abstraction as you've probably heard of. And so the user operation can consist of multiple actions. The DAP proposes that to the user's wallet, the wallet will then sign that user operation.
00:03:14.758 - 00:03:27.070, Speaker A: And many wallets in parallel are obviously signing different transactions. Those get combined together or aggregated via the aggregation server. But also there's additional compression that we do to again reduce the size of what gets rolled up.
00:03:27.070 - 00:03:43.822, Speaker A: So in the end, basically the essence of this is we're trying to reduce the data that will get rolled up. We'll talk more about compression after with that bundle of operations and the single aggregated signature. We then make the call to the smart contracts.
00:03:43.822 - 00:03:56.214, Speaker A: That bridge across to these contracts is what we want to reduce. So now that it's small, we've passed the gap, we've had our savings, we now need to expand it again to fully verify it. So we'll have the expansion done on chain as well as the verification done.
00:03:56.214 - 00:04:13.346, Speaker A: Once we have all those user operations verified, we can then get the smart contract wallet to call its corresponding DAP. So that's sort of the end to end flow. But with the smart contract wallet, we have to do things on chain that would normally be handled by the protocol, like the nonsense and gas.
00:04:13.346 - 00:04:19.920, Speaker A: So those are additional parameters. Now we had to send that we didn't have to send before. So let's look at how we can do some compression to save that.
00:04:24.510 - 00:04:39.906, Speaker B: Thank you, James. So yeah, I'm Andrew and let's talk about user op compression. So I want to give some context zooming know I'm talking about compression, so let's talk about the actual bytes that we have to work with.
00:04:39.906 - 00:05:03.058, Speaker B: So this is what a vanilla transaction looks like to just send some ETH. And about roughly the second half of this transaction data is your signature. So you might imagine when we switch to using BLS signatures that the effect of that is going to be something like removing the second half of these bytes.
00:05:03.058 - 00:05:33.700, Speaker B: However, the reality is a little bit more complicated than that. And so instead of going from 120 down to 60 by doing that, if you just call our gateway directly in order to process your operation, your transaction data is going to look like this instead. So what we thought we can fix this problem with compression, there's quite a bit to do and then we can realize the benefits of those BLS signatures and also take it a step further and apply that compression in other ways as well for additional save it.
00:05:33.700 - 00:05:49.814, Speaker B: So zooming in a little bit because I don't expect anybody to just understand a big blob of bytes like that. This is the same bytes as the previous slide. All of the examples, by the way, here are like properly encoded transactions, and a couple of them are posted on Chain as well.
00:05:49.814 - 00:06:07.254, Speaker B: And there'll be QR codes for viewing those on the Block Explorer here is just pointing out the bits and pieces that are in there. Or draw your attention to the signature that is on this slide. This is the transaction part of the transaction envelope that's around that orange data section.
00:06:07.254 - 00:06:27.570, Speaker B: So we're using BLS signatures and a different system and all that. But in order to actually get this data on Chain, we still need an EOA transaction, which means that there's still an ECDSA signature involved here. And so that becomes part of the data that's shared between all of the user operations that we've bundled together inside of this orange data section.
00:06:27.570 - 00:06:40.854, Speaker B: So let's continue zooming in and have a look at what's inside of those bytes. So this is them. So this is the solidity abi to specify what's going on.
00:06:40.854 - 00:06:56.350, Speaker B: And so we just have that little ease transfer in there as that's represented by those red bytes. The ones that are in black are shared bytes, and we compress those as well. But it's mainly about these red bytes, which are currently sitting at 640 at the moment.
00:06:56.350 - 00:07:17.954, Speaker B: And so those bytes, the compression that we can apply to those, how small we can get, that determines the long term cost performance of this model. So 640 is a lot, but we can also reduce that by a lot, as you'll see. Some of you may be familiar with this tweet from Vitalik last year.
00:07:17.954 - 00:07:35.740, Speaker B: We've been inspired by this and also from the Hubble project and also other sources. So I won't go into this in detail if we don't have time. But I'm pleased to say that what we've implemented is very similar to what's represented in the ideal stateful compression in the bottom right corner there.
00:07:35.740 - 00:07:47.782, Speaker B: So, without further ado, this is what the same transaction as before looks like when compressed. So we've got the link there. You can go view that on the Block Explorer if you like.
00:07:47.782 - 00:08:12.914, Speaker B: But the main thing to note here is the 640 bytes from a couple of slides ago are now represented in just those 17 bytes there instead. And so now that I can fit this all on one slide as well, we can have a look at what this looks like when you include multiple operations into one bundle. So have a look at that empty space in there, just underneath the red bytes.
00:08:12.914 - 00:08:30.762, Speaker B: So we're going to include two more transactions. Let's make them ERC, 20 transfers, which is important to note that you can actually include all sorts of different transactions into the same bundle, and they all benefit from the combined signature aggregation. So that's what that looks like there.
00:08:30.762 - 00:08:48.190, Speaker B: You can see we can just slot them right in there and we have some ERC 20 transfers as well. So, continuing to zoom in, let's see what's actually going on with those 17 bytes. How does it represent what's actually happening in that operation? So this is them, the annotations.
00:08:48.190 - 00:09:03.546, Speaker B: So all of these fields, I won't go through all of them. All of these are variable length fields. So in particular, you take, for example, that nonce field is only currently taking out one byte, but one byte can only represent 256 different nonces.
00:09:03.546 - 00:09:15.618, Speaker B: So that would be a big limitation if it was only that. But this just expands gracefully like all the other fields, if necessary, to accommodate the extra space. So as you get into hundreds of nonces, then you'll start using two bytes.
00:09:15.618 - 00:09:29.150, Speaker B: Eventually you might use three bytes if you're really prolific. And in theory, it can go up as much as you need, but you probably won't go more than three bytes. Secondly, I'll draw your attention to this build is particularly special.
00:09:29.150 - 00:09:44.958, Speaker B: So this is representing the BLS public key of that account. And so, yeah, three bytes is not enough to represent a public key. But what we're doing instead is we're saving this data in a registry.
00:09:44.958 - 00:10:21.200, Speaker B: So the idea with that is that your BLS public key that we use to identify you, that does need to get posted onto L one at some point. But what we can do is effectively it's compression. We're deduplicating that data, but instead of having to do it within one block or like, within one batch that gets rolled up, like in the Zlib stuff that some of the chains are doing now, instead we're deduplicating it across a much wider time span by just saving those bytes on chain, and then we can refer to them again later.
00:10:21.200 - 00:10:49.234, Speaker B: Another thing that we are leaning on quite heavily with the encoding is this format called Pseudofloat, which is a format for representing decimal quantities really efficiently. What this format allows us to do is if you've only got three digits of precision in your font, say you're sending 0.1 e, that's only three digits in there, and we're able to represent that quantity in only two bytes.
00:10:49.234 - 00:11:10.906, Speaker B: If you need more digits than that, obviously sometimes you do need more digits, then it again expands gracefully and you can still do that as well. And it supports the full uint 256 range. Finally, on the compression side, I'll leave you with this to just summarize the amount of bytes that you need for an ERC 20 transfer under different scenarios.
00:11:10.906 - 00:11:34.270, Speaker B: So in the Vanilla transaction, which is the status quo, today, you're looking at 150 bytes to 180 bytes, depending on how you count them. But if you use Wax, if you're in a bundle of five transactions, you're only going to have to pay for 55 bytes each. And if you can aggregate into 100, then you're only paying for 22 bytes each.
00:11:34.270 - 00:11:43.614, Speaker B: So this is pretty exciting. We're looking at reducing the amount of call data by almost a factor of ten. And so that corresponds to being able to do ten times as many transactions.
00:11:43.614 - 00:12:00.750, Speaker B: So we're pretty excited about that. All the stuff of this compression stuff, that's all implemented in our B one contracts, but we're also looking towards a B Two with some new and exciting features. So to talk more about that, I give you Jake.
00:12:04.330 - 00:12:13.842, Speaker C: Thanks, Andrew. So next we're going to go over for our V two some additional verification methods. We're looking into using the ERC Four Three seven kind of framework.
00:12:13.842 - 00:12:51.510, Speaker C: Before we jump too much into that kind of talk about what kind of accounts currently exist on Ethereum and verification methods we use with those, the most common one you have nowadays is an externally owned account, also known as an EOA, uses ECDSA signatures and the same curve that Bitcoin uses as far for the Asymmetric cryptography. These commonly are hierarchical deterministic wallets and sometimes can also be multi party computation wallets with a shared private key. But then on the other side, we also have smart contract wallet accounts which really can use any sort of signature or verification sorry, signature curve that's supported inside of the EVM.
00:12:51.510 - 00:13:06.586, Speaker C: It still commonly is going to be ECDSA, but we can really use a lot of different things such as BLS. Inside of that, you may commonly know existing smart contract accounts with like Safe argent and different protocols like that. So they're kind of two things.
00:13:06.586 - 00:13:28.900, Speaker C: There's a very good comparison given by the one KX network that goes over the difference between all of these different wallets. Highly recommend checking it out at another time. I'm not going to go in depth into this, but I really want to focus in on two advantages that smart contract wallets have, which is their ability to be programmed on chain and then also the composability of the different things that you can use inside of those.
00:13:28.900 - 00:14:02.220, Speaker C: So with Wax v two, we're using ERC, four three seven to implement using that Common Account abstraction spec. In this kind of what we're going to take advantage of here we have our bundler, which is very similar to the aggregator James mentioned earlier, which allows us to bring together those user ops and submit them. We have our entry point contract that's going to be connected to our account, and then we're going to basically validate those user operations, see if we're going to pay for them, and then we're going to execute the actual main functionality inside of them.
00:14:02.220 - 00:14:25.790, Speaker C: One of the cool things about this spec is that the Iaccount interface we use for checking and paying is very generic. It basically takes in a user operation and the wallet basically will tell the entry point and the bundler whether or not it's going to work with that validated data validation data that passes at the end. As part of that user operation, we have a field called Signature, which is just an array of bytes.
00:14:25.790 - 00:15:03.418, Speaker C: And that array of bytes, even though it's commonly going to be a cryptographic signature, we can really put anything we want in there that can be used for the account and for verification. So now that we have this, what new verifications could we use with this smart contract wallet? Well, we could use some basic web Auth, maybe have a username and password accessing something, but there's better things we can use, such as Web Auth N, also commonly known as pass keys. This is basically using Asymmetric keys similar to what we would use in Ethereum and other blockchains for signing into Web Two servers and accounts.
00:15:03.418 - 00:15:17.310, Speaker C: It's device and domain specific, and it already has support from companies such as Google, Microsoft and Apple. But in theory, any Web Two company would be able to implement this as part of a login. And so we can take advantage of the fact that those are asymmetric.
00:15:17.310 - 00:15:36.470, Speaker C: We have those asymmetric keys to actually allow these to sign for a Web Three account. So anyone potentially with accounts already at these places that has the Web authent could control an account using those. Another one is potentially using zero knowledge proofs as a way to sign your user ops.
00:15:36.470 - 00:15:59.154, Speaker C: So on your device, which is the prover, you're going to have your private inputs and you're going to have an expensive computation to generate a proof. We then push that proof and maybe the public signals into the signature field of that user op. And then finally in the EVM and that entry point, our contract can go to a verifier contract and verify whether that proof is valid and whether it's going to process that user op.
00:15:59.154 - 00:16:17.480, Speaker C: And so in this way we can use those proofs to authorize a user op. This opens up a lot of different possibilities of different things we can do, such as using new signatures and curve schemes that the EVM does not support. So anything we can implement in Circom or newer DSLs, such as Noir can be used.
00:16:17.480 - 00:16:41.178, Speaker C: For example, you can already do Ed DSA signatures inside of Circom, so you could use that for verification in a smart contract wallet. You can also use newer BLS curves like BLS Twelve 381, which is what the current Ethereum consensus layer uses to validate those. But really, we can also do anything that's provable inside of a proof as part of that verification.
00:16:41.178 - 00:17:10.550, Speaker C: So one thing that's being looked into, there's a pending paper that will be coming out soon called Contract wallet. Using emails is using an email as a proof, meaning that someone could have a smart contract wallet and actually send transactions just using a normal email message and generating a proof that they control that email address and that the content inside actually matches the transaction they want to do. But you could probably think of a lot of other things you could prove with a zero knowledge proof that you could use to verify via smart contract wallet.
00:17:10.550 - 00:17:31.850, Speaker C: Finally, one of the cool things too with the verification is it generally is cheaper to do inside of the EVM than maybe doing a normal solidity based verification. So the gas costs sometimes are linear with the number of constraints in the circuit. But some work that's being done to lower those could eventually make it log of N or constant time to verify those proofs.
00:17:31.850 - 00:17:53.574, Speaker C: You still have the issue though on the device where the proof generation can still be very computationally expensive. So what does this allow us to do? We can have multifactor off situations where we combine and compose multiple of these together. And so for an account for smaller things, you might be able to use one of these methods for sending small things.
00:17:53.574 - 00:18:17.490, Speaker C: But if you want to upgrade the implementation or send larger amounts, you would need say two of three to do this. So in this example, you might have an ECDSA or BLS signer, your friend may be just using their email to help you, and there may be a bank or institution you trust that also is a backup signer for those. And so for small things like your bank paying your bills for you or you sending money like you would on Venmo or something, you might only need one of these signers.
00:18:17.490 - 00:18:35.678, Speaker C: But if someone wants to change the signing scheme or do a recovery, then you might need two or three of these people to do it. But we can have a bunch of different verification methods for that. Another one fun one is recovery and migration, which we can have basically people move from centralized accounts to decentralized accounts progressively.
00:18:35.678 - 00:18:53.974, Speaker C: So for this example, let's say grandma wants to play Web three poker. She's a poker fiend, she wants to try it out and so she can actually create an account abstraction account with her Facebook login using web authent. She can then choose her best friends on Facebook to be her social recovery people in case she loses access to that account.
00:18:53.974 - 00:19:11.390, Speaker C: Then let's say grandma kills it a poker and makes a ton of money. Now she doesn't want Facebook to be able to rug her and take all that money away. So she and her friends get together and migrate her authentication to something like a hardware wallet so she can really have that secure scheme control over those new funds.
00:19:11.390 - 00:19:33.974, Speaker C: And so what this really leads to is kind of almost a Cambrian explosion of different verification methods we can use. This is when multicellular life kind of exploded into the world 600 million years ago into a wide variety of things we see today. And so using things like our current signatures, BLS, Web, Authentic, ZKPs, we have a lot of different new verification methods we can use.
00:19:33.974 - 00:19:42.746, Speaker C: But there also are a lot of cool ones we want to look into that maybe don't exist yet. Or maybe you will build during this hackathon or some other time. And we're excited to see what those are.
00:19:42.746 - 00:19:47.450, Speaker C: And so to make all this easier, we're going to bring on Blake to talk about integrations.
00:19:51.020 - 00:19:57.630, Speaker D: Thank you, Jake. Yeah. Now I want to talk about what our team is doing to actually get some of this work into developers hands.
00:19:57.630 - 00:20:23.908, Speaker D: And in order to do that, we've been recently working on a node module called Ethdk. This is a node module that we're hoping that will allow developers to easily add some of these experimental features into projects that they're trying to get into end users hands. Because we do know sometimes if you're building a product for a user, it could be hard to take the time to experiment or integrate a cutting edge feature that you don't know exactly how it works.
00:20:23.908 - 00:20:36.010, Speaker D: So we want to take some of that cognitive load out of the hands of the developers. When talking about building this node module, there were two things that we wanted to focus on. First one is just keeping it simple.
00:20:36.010 - 00:20:58.530, Speaker D: And with that we wanted to keep it simple just in the terminology that we use. It seems like, for example, this first one I have up here, wallet versus account, seems like the ecosystem is like settling on the terminology of account over a wallet. So we want to make sure our code reflects that so that users that are developing with this node module know that they're creating an account and it's a programmable smart contract account.
00:20:58.530 - 00:21:29.450, Speaker D: And then another example, this one's, both terminology and in the functionality of this function we implemented is our V one smart contract wallets have a form of social recovery available. And in order to set that up, you need to call the set recovery hash function on the actual wallet contract and pass it a recovery hash, but that requires you to know how to generate that recovery hash. So in our node module, we created a separate method called set trusted account.
00:21:29.450 - 00:21:38.648, Speaker D: The terminology of this better communicates what you're doing. You're setting a different account that you trust to be able to recover the original account. And then we also just pass two parameters.
00:21:38.648 - 00:21:59.776, Speaker D: We pass a recovery phrase as well as an address so that you don't have to know how to actually generate that recovery hash. And then we also wanted to focus on just some sensible defaults. There's a few things that we know based off of building our wallets and our aggregator that you need to do in order to get the full benefits of our tech.
00:21:59.776 - 00:22:16.648, Speaker D: For example, as we talked about earlier, the reduced costs on layer twos, you actually need to be using a layer two. You can't do the big deal of signature aggregation on an L one and get the same cost benefits. So we want to make sure that developers know that they should be using an L two.
00:22:16.648 - 00:22:41.200, Speaker D: And then also we want to make sure that our contracts are already deployed and verified on the specific networks that we're trying to support. So these variables can be constants within the node module that are easily exportable. If you wanted to, you could easily override any of those defaults, but we do want you to just focus on using the features and not finding where a specific contract wallet is deployed on chain.
00:22:41.200 - 00:23:05.076, Speaker D: So where are we now with Ethdk? We currently have a beta version published to MPM, and it works with our implementation of our V one contracts, and then we've also demoed it in our Instant Wallet. You might be familiar with a Burner Wallet. The Instant Wallet is just our version of a burner wallet that uses our Smart contracts behind the scenes.
00:23:05.076 - 00:23:19.710, Speaker D: And then we are starting the work on our B Two Smart Contracts. So the hope is that we'll come out of our beta version when we have the V Two contracts available. And we could also integrate some of the modules that Jake was just speaking about before me.
00:23:19.710 - 00:23:49.172, Speaker D: And to wrap up this section, I just wanted to show a quick example of our V One or our beta version of ETH DK. As you can see at the top, I'm importing a Create Account function as well as the Network's object, and then it's just like a few line of codes to actually create an account and then set your trusted wallet. So here I just called a Create Account factory function with a couple of config properties, and I can await that and then print out the address.
00:23:49.172 - 00:24:00.152, Speaker D: And then down below, I just create a recovery phrase and pick an address that I trust. And then I could call the set trusted account. So as you can see, you don't have to know how the contracts are actually set up.
00:24:00.152 - 00:24:22.850, Speaker D: You could just easily use the functionality that we're trying to get into the hands of developers. But yeah, we're really excited where we can go with this, especially with our V Two contracts, and then with this coming out of the beta version. So keep an eye on the link on MPM, and I think to wrap it up, I want to hand it over to John, who is going to aggregate all of the points that we just spoke about.
00:24:25.300 - 00:24:25.616, Speaker B: Cool?
00:24:25.638 - 00:24:25.824, Speaker C: Yeah.
00:24:25.862 - 00:24:33.124, Speaker E: Thanks, Blake. So to wrap up all that's been said, cool. Yeah.
00:24:33.124 - 00:24:54.648, Speaker E: So Wax started off to bring cheaper L Two transactions to EVM chains to enable new applications. We can do this through BLS signature aggregation, which can reduce the call data that gets posted to L One by combining many signatures into a single signature. But the signature aggregation by itself won't get us all the way.
00:24:54.648 - 00:25:14.464, Speaker E: So we need to do some cool data compression as well, using the techniques that Andrew mentioned earlier in the presentation. And it's important to mention that the gas savings we've spoken about can be used in addition to the gas savings from L two S. So there's a lot of buz around the design space that account abstraction opens up.
00:25:14.464 - 00:25:41.268, Speaker E: ERC, four three seven in particular is a very unappinionated standard and gives developers a lot of choice in what they can do, so a lot of unexplored ground. And as Jake mentioned, we're sort of anticipating or hoping there will be a Cambrian explosion as such of accounts using lots of different verification methods. We're in particular excited to try out Web Auth, N and ZKP email verification in our upcoming modules.
00:25:41.268 - 00:25:58.096, Speaker E: And you'll have the freedom to use these modules in various ways. For example, you might be able to use Web authent as a multifactor authentication. Say if you're sending a transaction that's like over $5, you can use your Web authentic, then you might use your ZKP email to recover your account.
00:25:58.096 - 00:26:15.300, Speaker E: Alternatively, you could even use the ZKP email as your multi factor authentication. The possibilities, know, are fairly broad. And you can do all this while enjoying the cheaper transactions brought about by BLS SIG aggregation and the cool data compression.
00:26:15.300 - 00:26:23.856, Speaker E: And at the top layer we'll have the Efdk, which will wrap all the BLS components together in an intuitive abstraction.
00:26:23.888 - 00:26:25.290, Speaker A: For developers to use.
00:26:25.900 - 00:26:51.170, Speaker E: So we've just about wrapped up our V one contracts and we're looking to V Two to apply some of the lessons learned there. And we're starting that now, basically. So V Two will enable BLS signature aggregation in a four three seven compatible modular smart contract wallet, and you'll be able to add additional verification modules in there to enable more expressive transaction verification and recovery options.
00:26:52.500 - 00:26:53.104, Speaker C: Cool.
00:26:53.222 - 00:27:13.092, Speaker E: So, yeah, the future of where transaction costs are going and also account UX is very exciting and we're really looking forward to bringing these new developments to the ecosystem. If you want to learn more, please check out our website@getwax.org. And if you want to learn more about the BSE and what we get up to, please check out apply zkp.org.
00:27:13.092 - 00:27:14.100, Speaker E: Thank you all for listening.
