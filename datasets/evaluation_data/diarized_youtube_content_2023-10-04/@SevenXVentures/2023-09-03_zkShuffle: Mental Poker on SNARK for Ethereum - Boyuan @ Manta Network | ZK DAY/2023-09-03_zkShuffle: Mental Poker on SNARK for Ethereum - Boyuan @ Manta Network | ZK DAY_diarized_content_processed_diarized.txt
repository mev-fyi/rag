00:00:00.250 - 00:00:02.510, Speaker A: Meta is going to talk about ZK Shuffle.
00:00:06.770 - 00:00:28.582, Speaker B: Thank you guys for coming. So today I'm going to talk about ZK Shuffle. It's a mental poker on Snark for Ethereum. A little bit about me. I come from UCS and Barbara before. Yeah, go culture. So, year 2020, I built the first Ckml research.
00:00:28.582 - 00:01:23.794, Speaker B: And after that I joined Manta Network for the private payment, also optimizing like MSM on wasam and built something for Xerox Park. Okay, so at Manta we are building something called Manta Pacific. Manta Pacific is EVM native layer two ecosystem designed for DK applications. We use Celestial for the DA, also the Codera for the Op stack and rebuild the universal ZK circuits. So what is universal ZK circuit? Basically, our CS is like hey, there are many, many applications, they need privacy using Ziki. However, it's very hard to write Ziki circuit for most developers, right? So basically we provide the universal circuit. So other developers can directly use our circuit to build whatever their depths.
00:01:23.794 - 00:02:03.086, Speaker B: Like the private voting, like many kinds of fully on chain card or poker game, there are many, many things. So we provide CK as a service. Also we provide the solidity compatible things. So people don't need to learn anything new, they just use the Solidity code. Also some TypeScript code in the browser. Yeah, we also provide the SDK, so people don't need to learn many things. Okay, I will provide a very concrete example called Ziki Shuffle as an example of our universal circuits.
00:02:03.086 - 00:02:56.150, Speaker B: So basically, Ziki Shuffle is a universal circuit deployed on Manta Pacific, designed for a fair, decentralized and private fully on chain card poker game. It provides this very simple contract interface like the Shuffle State Manager, also the base game. So basically, for whatever kinds of card game, like the Texas Holden, like the Hearthstone, if you guys are familiar. So they have a central part which is fully on chain shuffle and the deal, right? In addition to that, they can have super different game logic. Basically they share something similar, but they also have something different. So what we have done is central part for shuffle and deal. Then other developers can write only solid code to make it fully on chain.
00:02:56.150 - 00:03:28.910, Speaker B: Okay, so how does this CK Shuffle works? Basically, the goal is to build Foley on chain card board games with Solidity and CKP. There are actually a few problems. The first problem is how do you fairly shuffle decor cards? So basically we have a bunch of people, like three people or five people. We don't trust each other at all. Right. We also don't want to trust any centralized server. So we need to play the car in a remote way and make sure it's a fair shuffle.
00:03:28.910 - 00:04:07.734, Speaker B: The second question is how do you privately deal the deck of cards? Yeah, actually this is a very important cryptographic problem called mental poker. It has been studies for decades. And basically we built up this mental poker and make it on ZK snark. So we have a few things. The first thing is ZK shuffle setup. So before a game starts, everyone takes turn to, I mean basically have some cryptography setup like the public key, private key. Then everyone needs to do one thing called shuffle encrypt.
00:04:07.734 - 00:04:25.934, Speaker B: So basically, in order to shuffle the deck, everyone takes turns to shuffle the deck. The randomness comes from the user machine. It's not from blockchain. It's not any central app server. It's from the user machine. So they have fully controlled. The first thing is called ZK Shuffle decrypt.
00:04:25.934 - 00:04:58.810, Speaker B: So once we have a shuffle deck, everyone takes turns to deal the card. Now, let's talk about how ZK Shuffle works. Basically, suppose we have three player. Alice, Bob and Charlie. They start with deck of cards. It could be 52 cards, one deck, two decks, right? So basically, everyone takes turns to shuffle the card. Like Alice gets the card from the blockchain shuffle it, and Bob shuffle it next.
00:04:58.810 - 00:05:20.466, Speaker B: So let's see so, how it works with solidity. Now we have the contract. Also we have the player. So, on the contract, we start from initial deck. It's just some encoding on the elliptic curves. Then LS gets this deck from the blockchain. It's just a simple read.
00:05:20.466 - 00:06:07.010, Speaker B: Then on LS machine, LS can run a program called Shuffle encrypt and generate a shuffled deck. I mean, basically here whatever order Alice want. At the same time, Alice will generate a proof to say, hey, actually this is correct shuffle. Like I only have four ace instead of ten ace, right? Because every card is encrypted. If they don't have a proof, no one knows what happened. Then Alice will submit this deck to the blockchain storytelling on the chain and send this proof on the blockchain for the proof verification. After that, Bob will get this deck again from the blockchain and verify shuffle.
00:06:07.010 - 00:06:40.220, Speaker B: It's the same story. Let's ask a few questions here. So what is the source of randomness? It's from the user machine instead of the blockchain or the oracle. So it doesn't have many trust assumptions. The second question is why every player needs to join the shuffle. I mean, why don't we only ask one guy to shuffle for all the people? Because they don't trust each other. So I have to shuffle by myself.
00:06:40.220 - 00:07:34.986, Speaker B: The third question is, why do we need additive homophobic encryption? So basically, we want to make sure, hey, whoever shuffles first does not have any advantage over other players, right? So it's a fair game. Now let's talk about the card dealing. So, we start with card. There are three logs on the card because everyone has taken their turn to shuffle and encrypt, right? So basically, there are two logs on each card. Like Bob gets this card from the blockchain and remove Bob's log and Charlie remove Charlie's log. And finally, Alice can see the hand card again. We can see how it works with contract.
00:07:34.986 - 00:08:12.858, Speaker B: And on the contract we have the card LS, read it, decrypt it on LS machine and generate a proof. Then this card is sent to the blockchain and proof is sent to the blockchain for verification. So, one thing I want to mention here is when Alice decrypt card on Alice machine, alice has a choice whether I submit the decrypt card immediately or later. Basically, there are two kinds of cards. One is hand card, I haven't played, I know the value, I can play it whenever I want, but I haven't played. Other people should not know it. Right.
00:08:12.858 - 00:08:55.126, Speaker B: In this case, Ils just does not submit these cards to the blockchain. And another case is, hey, I actually want to play it. Only at this time, Alice will send the card value to the blockchain. Yeah. Again, let's ask a few other questions. So, first, when dealing card to Alice, what prevents other players or anyone else from seeing Alice card? Because what Alice read from the blockchain is encrypted card, right? So other people cannot know the value. The second question is, does the decrypt sequence have to be Bob, Charlie or Alice? Actually, no.
00:08:55.126 - 00:09:27.540, Speaker B: So actually, any order works because we are using the additive homophobic encryption. This is actually very important because during card shuffle and encrypt, we have to choose a specific order, right? ABC. Right. But when we deal the card, we may deal to Alice or Bob or Charlie. So let's say, suppose we deal to Bob. Bob should be the last one to decrypt. Right? So this order is important.
00:09:27.540 - 00:10:19.878, Speaker B: The third question is, when Alice plays her hand, what prevents her from cheating? Like playing a card that doesn't belong to her? So basically, we require Alice to submit a proof for the card dealing for the decryption. So people know this is a quiet computation. Yeah. I can talk a little bit more details on the Algama encryption, the additive homophobic encryption they are using. During the setup, everyone generates a secret key, public key. And basically they aggregate everyone's public key together into a shared public key. And later, when they encrypt, they use this shared public key for encryption and use the individual secret key for the card.
00:10:19.878 - 00:10:50.830, Speaker B: Daring. Also we have the encrypt. So you see, everything is elliptic curve and we have the decryption. So basically, people use something. This is a core for the encryption decryption part. In addition to that, people also need to do the shuffle and check the validity of the random stuff. Yeah, let me talk about the performance side.
00:10:50.830 - 00:11:29.130, Speaker B: So, the performance is very important because one thing unique here is players need to generate the proof on their machine. I mean, this is quite different from many other ZK projects, like Zke, EVM and many other projects. Because they have some super powered machine, they will generate proof. Right. However, this is not the case in our game. Because user don't want to trust any centralized server they only trust the randomness on their own machine. So we care about the performance.
00:11:29.130 - 00:12:19.770, Speaker B: By the way, we are using Go 16 so you see the first thing is RSS constraints is like two hundred k for the encryption and decryption for the proof generation side it's like eleven second for the encryption, 0.1 second for the decryption. So every time when people deal the card, it only takes 0.1 second and this encryption is only done once before the game and we can make it even faster with some other optimizations. This is a gas cost, it's like 2 million. So on layer two it's like every game if we play a Texas hold on it's like $0.3 or even less so it's kind of cheap.
00:12:19.770 - 00:13:36.710, Speaker B: Yeah, actually this is about the prototype and the security design. Prototype is easy but production is hard so we have more optimizations to actually make it work. Meteors has provide a good user experience. One thing is called Pipeline shuffle to hide the proof generation latency. So we have seen there are some a little bit latency for the proof generation, right? And our idea is like hey, we actually don't need to submit the proof for the game to continue, right? So we can submit the shuffled deck first, people can play it and later we can submit the proof and if someone does not submit the proof, other people can challenge and punish this kind of story. The second thing is called optimistic verification to mitigate the onchain verification gas cost so on chain ZKP verification is little bit expensive if we have a bounce many many proof to verify. So basically it's like the optimistic design we don't need to verify until someone challenge.
00:13:36.710 - 00:14:46.080, Speaker B: The third thing is like the pond compression to reduce onchain storage because on chain storage is very expensive. It's like 20K gas per data and if we can compress elliptical points, the gas is smaller. Yeah, we have many more optimizations like this one to make it actually work. So if you don't want to interact with the contract interface, we provide an SDK. It's a TypeScript code, runs in the browser, you can simply call it, it will send all the transaction to the so actually some folks in our ecosystem they actually built the Tesla Holden game with one deck using the Tiki shuffle I can show you guys a very quick demo. So you see there are two players, they are waiting for the third player. Now there are three players, everyone takes turns to shuffle the deck.
00:14:46.080 - 00:15:47.140, Speaker B: So now I have finished. Okay, player two also finishes player three. Okay, everyone finished shuffle you say it's pretty fast. Now people are dealing the card and okay, so now everyone can see their own hand cards. This is a fully decentralized game, I mean, we don't have any centralized server. Yeah, you see most recently comes from sending the transaction to the blockchain. The ZK part is fast.
00:15:47.140 - 00:16:17.210, Speaker B: Yeah. So people can use ZK shuffle to build other card game. You can imagine, they need to write the game logic in solidity, but they don't need to touch any ZKC. Okay. Yeah, that's it for this demo. Let me see the next one. Yeah, actually okay, so the demo was about trading card.
00:16:17.210 - 00:16:47.340, Speaker B: Sorry, card game with one deck. We can build more than that. For example, we can build the trading card games with two decks. So how does this work in this case? So we have two decks like Alice versus Bob. They are playing the hearthstone. So Alice has Alice Deck and Bob has Bob's dag. Basically, Alice shuffle and encrypts the deck sends the deck to the blockchain.
00:16:47.340 - 00:17:22.780, Speaker B: So now other people cannot know the card value. One thing I want to mention here is actually we can have two totally different decks for Alice and Bob. Right. This is very common game design in many trading card game like Hearthstone, people can buy some cards, can freely compose whatever card they want. And so because Alice shuffling encrypts this card, sends this card to the blockchain. There is a log. Other people cannot know the composition of this deck.
00:17:22.780 - 00:17:49.156, Speaker B: Okay. Bob can do the same thing. And then Bob shuffle the deck and Alice shuffled Bob's deck. In this case, we have to shuffle the deck because Alice has shuffled sorry, bob has shuffled Alice deck. Alice cannot know the order of his cards in this deck. Yeah, this is a shuffle for the game with two decks. The dealing is similar.
00:17:49.156 - 00:18:06.504, Speaker B: People take turn to deal. Okay. Yeah. That's all for my talk about the Jiki shuffle, bring card or board game fully on chain. So I have the spec here. If you are interested in the technical details, you can take a look. That's all.
00:18:06.504 - 00:18:07.530, Speaker B: Thank you guys.
00:18:11.280 - 00:18:13.150, Speaker A: Now we open up for questions.
00:18:14.080 - 00:18:16.172, Speaker C: So, first of all, amazing talk.
00:18:16.306 - 00:18:16.604, Speaker B: Thanks.
00:18:16.642 - 00:18:31.024, Speaker C: I'm just curious. Let's say someone goes folds, right? And they rage quit because they were losing in poker and they no longer participate in the dealing process. How do you handle that?
00:18:31.142 - 00:18:49.524, Speaker B: Yeah, this is a very good question. Depending on when you quit, like suppose you quit before the game starts, right? It's okay, we just regenerate the public key. Also, if you quit during the shuffle, it's also okay because people can reshuffle it. Right.
00:18:49.562 - 00:18:52.340, Speaker C: But I quit when I lose in poker, that's when I get mad.
00:18:52.500 - 00:18:53.210, Speaker B: Yeah.
00:18:53.900 - 00:18:54.968, Speaker C: My chips are gone.
00:18:55.054 - 00:19:21.152, Speaker B: Yeah. This is a very complex thing. So let's say suppose we have shuffled the deck and in the game you still have the choice to click fold. Then you don't need to participate anymore. Right. This is the most common case, because when you fold, you will automatically deal all the remaining cards because you have left the game. You just deal the remaining cards though.
00:19:21.286 - 00:19:32.390, Speaker C: Okay, let's say on the third card, right, I hit nothing. I thought I had a pair of kings and three aces just appeared on the board.
00:19:33.960 - 00:19:34.372, Speaker B: Okay.
00:19:34.426 - 00:19:39.716, Speaker C: Is there a way to get around this or do we just need to sort of penalize the players for rage footing?
00:19:39.908 - 00:20:09.100, Speaker B: Yeah, so actually there are some technically we can handle it like there are something called partial homomorphic encryption. You don't need everyone to deal the card. Yeah, it's possible, but we are not doing this yet because there are some trade off between how much trust do you want to have to other players? Like, suppose we have five players. Can we say, hey, four auto five will never cheat.
00:20:09.180 - 00:20:10.530, Speaker C: Of course they will.
00:20:10.980 - 00:20:33.144, Speaker B: Yeah. There are many questions like this. So currently we don't use partial homophobic encryption. We require everyone to deal the card. That's why we are taking something like the economically intensive incentive to say, hey, do not do that. Wait like 10 seconds and click the folder. That's all.
00:20:33.342 - 00:20:38.724, Speaker C: That makes a lot of sense. Even you could just maybe force them to lose all their chips if they don't participate.
00:20:38.772 - 00:20:55.360, Speaker B: Right, yeah. Also in many the trading card game, it's a wine versus wine game, right. So there's no such problem in one. Yes. Thank you. Please.
00:20:55.430 - 00:21:16.592, Speaker D: So just adding on to this question, have you ever considered giving the player a maximum of specifics of the game, but maybe like 30 seconds? If you were to implement that, would you keep track of the block time? 15 blocks. How would you keep track of a time if you were to implement?
00:21:16.736 - 00:21:19.624, Speaker B: Yeah, please. Like the block sorry, block number.
00:21:19.742 - 00:21:24.120, Speaker D: So you can continuously just track the block time. Wouldn't that just require continuous pools.
00:21:28.540 - 00:21:37.368, Speaker B: When players submit a transaction, do an action, there is a timer restarted and the next player have to take action before this timer expired.
00:21:37.464 - 00:21:39.592, Speaker D: But the timer, how is that tracked? Is that on chain?
00:21:39.656 - 00:21:42.140, Speaker B: Yeah, it's on chain. It's on the block number.
00:21:42.290 - 00:21:43.312, Speaker D: It's just a block number?
00:21:43.366 - 00:21:43.970, Speaker B: Yeah.
00:21:45.460 - 00:21:53.360, Speaker D: Sorry. How do you continuously just call the blocks just reading or no gas.
00:21:54.180 - 00:22:11.530, Speaker B: Okay, so because all the logic is fully on chain using solidity, there are some built in API like block number, something to read the block number. You don't need any centralized server or oracle for this block number.
00:22:14.840 - 00:22:33.690, Speaker A: So I probably have one question. So you mentioned there is an optimistic approach we take when it comes to verifying proof submitted by players. I was wondering whether that's purely because of the gas consumption on ethereum or if we are assuming on a super fast chain, we can verify all the proofs if we want.
00:22:34.460 - 00:22:40.552, Speaker B: Yeah, currently it's mainly for the gas constraints. Okay.
00:22:40.606 - 00:23:05.008, Speaker A: Yeah. Because the kind of worry I have is not everybody realize that they're getting cheated when they're actually getting cheated. So in order for people to realize, hey, I'm getting cheated, I need to challenge this guy. That might take a while and then say, for example, somebody built a super fast poker chain with, let's just say death, which might be super cheap, and therefore it makes sense to verify all the proof. I guess we can take that route if we find a solution.
00:23:05.104 - 00:23:23.652, Speaker B: Okay. Gotcha. So basically you're asking, hey, suppose I'm a non technical player. I know nothing about the Zigapi. I don't know why I show that challenge. Right, so basically, people don't need to actively take action for the challenge. We just have built in utility in the browser.
00:23:23.652 - 00:23:46.610, Speaker B: It will run since the backend keep pulling the data from the blockchain and verify it locally. If there are anything wrong, they will challenge automatically. Right. So because in all this card game, it's like people fight against each other. So they have the incentive to challenge other players in the same game.
00:23:47.300 - 00:23:49.280, Speaker D: But do they need like a stake.
00:23:51.480 - 00:24:06.230, Speaker B: If, let's say, someone cheated and just like splashed their steak or something? Yeah, currently it's like because people have the chips by default. Okay, right.
00:24:07.160 - 00:24:09.764, Speaker C: So did they just lose the game if they cheat?
00:24:09.812 - 00:24:12.520, Speaker B: Is it like some kind of period.
00:24:13.340 - 00:24:21.676, Speaker C: Winnings or the pot until the optimistic deadline for proof submissions, like fraud proof submissions is over? Like something like that?
00:24:21.698 - 00:24:24.540, Speaker B: Yeah. They will lose all the chips.
00:24:26.080 - 00:24:32.860, Speaker C: Proof aggregation. And then it's only like 290. What is it? 290k gas to do ground 16 verification.
00:24:34.400 - 00:24:41.268, Speaker B: It's not 200K. Depends. Depending on how many public input to your house, for sure. Yeah.
00:24:41.354 - 00:24:42.180, Speaker C: Gotcha.
00:24:45.160 - 00:24:45.860, Speaker B: Cool.
00:24:46.010 - 00:24:50.608, Speaker A: Beautiful. So I guess no more questions. And thank you, boyan, for this wonderful speech.
00:24:50.704 - 00:24:51.090, Speaker B: Thank you.
