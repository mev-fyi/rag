00:00:08.970 - 00:00:36.946, Speaker A: I am Yannick. I work on Shutter Network. And our mission is kind of to oh, there they are. To prevent users from malicious MV extraction, in particular on L two S on roll ups, because that's what everyone using now. And the approach we're taking is using a threshold encryption. So, cryptographic approach. I want to start with kind of defining what we mean with mev protection because we're not protecting against all mev.
00:00:36.946 - 00:01:09.954, Speaker A: That doesn't make sense. But since we are on this light mode state, I want to start with a positive definition. So what we allow users to do what they normally wouldn't be able to do, instead of just saying what we prevent them from, and this is what we came up with we want to enable users to safely reveal private information to the chain. So let's dissect this a little bit. The important part here is private information. The user knows, for example, a secret that it wants to send to the chain. Maybe it knows the solution to a puzzle that only they know.
00:01:09.954 - 00:01:46.282, Speaker A: Or maybe it could also be the intent of trading. So if they want to send a transaction in the future, this could also be a piece of private information revealing to the chain, meaning sending a transaction and then keyword safely. There's a bunch of things that can go wrong there. The obvious one is that transaction could never end up in the chain. So this would be censorship. The sequencer of the roller, for example, refuses to include the transaction. Or they could be front run, so the information that used to be private before they sent their transaction is not private anymore.
00:01:46.282 - 00:02:28.726, Speaker A: And someone else used that information and got in the chain first. Yeah. What we're not talking about when we mean mev protection is things like arbitration, liquidations, at least those that don't have a clear victim, maybe they have victims, maybe they're good or they're bad, but it's not very easy to define. But we don't worry about this. We mostly care about these types of censorship and front running attacks. Why roll ups? Basically? So the technique we're using can be applied in different layers. It can be applied in L ones, it can be applied in L two S, it can be applied in the application layer.
00:02:28.726 - 00:03:12.662, Speaker A: But we focus on roll ups because we think that the majority of mev will be there simply because the majority of users will be there in the future and majority of applications. That's one reason. The second reason is that roll up protocols are still new and still relatively easy to modify. So there's many of them, they're willing to experiment, they try to find different focuses. So it's a great situation to be in. If you want to suggest a rather big change to how these protocols work, this would be much more difficult in L ones. So proposing a change to how ethereum works is more difficult because they have to be much more conservative.
00:03:12.662 - 00:03:43.874, Speaker A: They're already established they already have lots of users so they have to be careful. And the third point is that most rollabs today have a single sequencer. This might change in the future. We just heard about this. There might be decentralized or distributed sequences but for now most of them are single sequences, centralized sequences. And this has two effects on us. First is it's relatively easy to implement our protocol in that it makes it easier to reason about.
00:03:43.874 - 00:04:11.430, Speaker A: We'll see why later. And also a big issue with having a single sequence is censorship. And we think that our approach can help there too. So it can alleviate the need to decentralize potentially. So therefore we've decided to build this thing that we called Rolling Shutter. It's kind of a plugin that we can integrate into any roller that wants to use it? Pretty much. So how does it work? Essentially it's a commit reveal mechanism.
00:04:11.430 - 00:04:45.670, Speaker A: So a user who wants to send a transaction does not send the transaction directly because then they would leak all the private information but they only send a commitment to that private information. Then the sequencer will pick up these commitments and order them since they don't see what the transactions actually do. So front running is difficult. They can't extract the private information. It's not there. So everything is safe and only once the sequencing step is finished. Once this ordering is final, only then the commitment will be revealed.
00:04:45.670 - 00:05:23.118, Speaker A: Now the naive approach to do a commit reveal scheme is using, for example, a hash commitment. The problem there is then that the user would have to commit it in the have to reveal it in the end and it gives them the option to not reveal. And then we have a big problem because either we have to hold the chain, we don't know what to do with that, or we have to ignore it. And lots of applications would break in that instance because for economic reasons. Another reason is that UX would be horrible. So whenever you send a transaction, you would have to send two transactions with some time in between. That would be very annoying.
00:05:23.118 - 00:05:54.174, Speaker A: So what we do instead we have a committee that performs the revelation. The user only has to send the commitment and then the committee does the reveal. How does it work? Essentially by threshold encryption. The commitment is an encrypted message that the committee has the power to reveal. Yes. And the diagram shows kind of how it will look like. The sequencer produces batches of these encrypted transactions and whenever a batch is closed, it's final.
00:05:54.174 - 00:06:33.786, Speaker A: Then the committee will rebuild the key and then the process starts again. So how do these committees look like? We call them keeper committees because their job is to produce keys. They generate these encryption keys and decryption keys, a lot of them in sequences. It's managed by a dao. So the Dao's job is to pick keepers who are likely to be honest, who are likely to do a good job. And the list is then defined in a smart contract on chain so everyone knows who those people are and we assume that a threshold. So a certain number of these members of this committee are honest and online and do their job well.
00:06:33.786 - 00:07:07.358, Speaker A: And this threshold is a parameter that we can pick, can be one half, could be two thirds, something like that. And ideally it's large enough so that the threshold assumption is justified. These keepers now run a distributed key generation protocol. Unfortunately, these protocols tend to be very inefficient. They have quadratic overhead. Basically every node in that network needs to send one message to every other node. So as you can imagine, there's going to be lots of messages if the committee gets large.
00:07:07.358 - 00:07:45.486, Speaker A: We want to have committees of like 200 nodes maybe. And that would be not very feasible in that case, especially because we want to repeat that process also rapidly. We want to have batches in rapid successions, like five to 10 seconds. So this would be with a standard DKG protocol, this would be infeasible. So therefore what we came up with, with some collaboration with Cryptographers is we found a much nicer protocol that still has this quadratic overhead but it only has it once in a setup phase. So you only have to run it once in advance. And then for every batch, for every decryption key that you generate, you only have linear overhead.
00:07:45.486 - 00:08:28.080, Speaker A: So you only need to collect one message of these members, which is pretty much optimal, I guess. Okay, so how do the transactions look like? The transactions of the system are basically ethereum transactions. They have all the same fields, just that they are encrypted. Unfortunately, we can't encrypt all the fields. We can't encrypt basically the sequencer who has to select those transactions and they need to have enough information that they know that they will get paid so that the sender can pay the transaction fee. So the gas amount, the gas price and a signature needs to be plain text. But this is usually fine because in these fields there's not a lot of private information.
00:08:28.080 - 00:09:13.542, Speaker A: Usually the more important private information is the receiver of the transaction and the contract or the function you call it in a contract because that's actually what the transaction does and these parts are encrypted. In the future we could think of encrypting everything and then attaching a zero knowledge proof so that the sequencer knows that the transaction will pay a fee without seeing the fields directly. But for now, this is too complicated for us and not really worth it. So we took the easy way that's also more feasible at the moment. The sequencing step I e. The batch production step is performed by the Collater. We call it the Collater.
00:09:13.542 - 00:09:56.310, Speaker A: It's run by the same entity as the sequencer, the roll up and sequencer would actually be a better name because their job is to order the transactions. But unfortunately that name is already taken and it's a different piece of software. So we call it the Collater. Their job is to produce these batches, define the list of transactions that are in there, the order of those transactions, and they also commit on the execution context. So the block number, timestamp and things like that, everything that can affect the execution of transactions. And eventually, once they're done, once they sign these and once they close the batch, they will send it to the sequencer. So you might wonder why they need to commit on the execution context.
00:09:56.310 - 00:10:57.406, Speaker A: Why does that matter? And the reason for that is that there's a potential attack that we call Optimistic sandwiching. So even if the sequencer does not know the transaction, this green victim transaction, they don't see what it does, but they guess that there might be a potential attack and they just do the attack anyways. So they sandwich it, they put a front running transaction in front, a back running transaction in the back, and then they just wait until they see what the transaction then they commit, wait until the decryption key is present, they decrypt and then they see what the victim does. And then they kind of switch on this front running and back running transaction or don't switch it on, depending on the timestamp. So for example, they say if the timestamp is even, the front running transaction only will run if it's even. And then they set the timestamp to even if they want to run it in the attack or they set it to OD if they don't want to run the attack. So the message here is basically that defining the order of transactions is not enough in general.
00:10:57.406 - 00:11:24.214, Speaker A: You also need to find basically every input that can change the execution path of a transaction. But yeah, the solution to that is simple. We just make this sequencer commit to all these fields. It's not too many, it's like a couple of block numbers and the timestamp. This is the architecture of how our system looks like. We have two parts. We have this kind of shutter system and we have the roll up.
00:11:24.214 - 00:11:59.810, Speaker A: And the shutter system is the software that we provide. It's the keeper client, it's the Collater. We also have the tendermint chain here. It's kind of a private chain that is run by the keepers only and that the keepers use to coordinate generating these running the setup phase of the DKG, but no one else basically has to care about that. And then on the other side of the roll up, we have the sequencer and the state transition logic. We have to modify a little bit. So we have to provide an interface that the Collater can use to push batches to the sequencer.
00:11:59.810 - 00:12:42.526, Speaker A: And we need to modify the state transition logic so that it execute these batches. So the normal state transition logic executes transactions, ethereum transactions. And now we have to do this additional step of decrypting transactions first and then executing them. But the point I'm trying to make here is that most of the complexity of the system is enclosed in the shutter part on the left part that we write. And then the changes we have to make to the roll up are very trivial, almost or very minimal at least. So it can be without a lot of effort integrated into most roll up designs. We should talk a little bit about what can go wrong.
00:12:42.526 - 00:13:32.442, Speaker A: So what happens if people don't behave as we want them to and how we can discourage or encourage honest behavior. And there's basically two classes of attacks here. One is cryptographically provable and one is non cryptographically provable. Cryptographically provable is an attack by the Collater. They can create two competing batches, so they can first create one batch, wait for the decryption key and once they see the decryption key, create another batch, basically reordering transactions in a way that suits them. So this would allow them to extract mev, which they weren't able to do before. But fortunately this is very easy to prevent, at least it's very easy to punish.
00:13:32.442 - 00:14:19.370, Speaker A: So since these commitments that the Collater sends are signed or the batches are signed, we can simply slash them if anyone provides proof of two batches that are signed by the same Collater from the same block item. So this is easy to discourage. What's more difficult is like misbehavior by the keepers. So things that the keepers can do is they can decrypt transactions early, they can not wait for the commitment by the collateral, they can decrypt it immediately or they can decide to not decrypt at all. Both of these attacks only work if with some collusion. So for the first attack you need at least the threshold number. So half or two thirds or whatever we chose the parameter this number of keepers have to collude.
00:14:19.370 - 00:14:55.734, Speaker A: So it kind of breaks already our honesty assumption. But it's still important to consider. And for not decrypting you need basically N minus the threshold so that not threshold keepers are available to produce the key. So unfortunately these are, as I said, not cryptographically provable. For example, the first attack collusion decrypting early can be done completely in secret, so no one would actually know that or at least have clear proof of that. But fortunately there's evidence. So often you don't have proof, but you have evidence.
00:14:55.734 - 00:15:22.574, Speaker A: So you see some weird things going on. You see sandwiching attacks which shouldn't be possible normally. So in those cases we can use the dow to punish the keepers. They can do what we could call subjective slashing. So even though they don't have proof, they just make the Dao vote on these people, probably colluded. So we slash them, or at least throw them out of the set. And the other solution is to simply incentivize them long term.
00:15:22.574 - 00:15:59.280, Speaker A: So give them long term contracts so that they can probably earn more money by being honest. Yes, that's pretty much all of it. To summarize, basically, I want to say that rolling shutter is like this front running protection plugin that can be integrated into almost all rollups based on threshold and cryptography and ready to be released soon, we hope. Thanks a lot. We have time for questions, apparently. Two questions.
00:16:11.620 - 00:16:30.096, Speaker B: Hi, thanks for the talk. Do you have an idea of the size of the nodes of the keepers? And also my second question follow up question is do they have to decrypt something each time for each transaction or is it linear in the number of transactions?
00:16:30.288 - 00:17:00.990, Speaker A: So our goal is to have like 200 nodes in that set. I think that's a good size and feasible, the bigger the more secure, of course. So it's always nice to have a greater number there. And for the decryption, yes, every transaction has to be decrypted, but this is not part of the job of the keepers. Actually, what the keepers do is they just provide the key and then everyone can execute while they follow the seal transition function. Basically.
00:17:08.120 - 00:17:18.910, Speaker C: Is it an atomic decryption in terms of the entire batch of transaction or otherwise? Is there a possibility that I committed a transaction but then I never decrypt it?
00:17:20.000 - 00:17:32.236, Speaker A: No, that's not possible because it's not your job to decrypt the transaction. It's the job of the keepers who provide the key and then everyone in the network will perform the decryption.
00:17:32.348 - 00:17:38.370, Speaker C: So there's incentive for every transaction to be decrypted by the other noct operator? Basically, yes. Got you.
00:17:39.860 - 00:17:47.590, Speaker B: One more. Thank you.
00:17:48.220 - 00:18:06.828, Speaker D: Thank you for the talk. So one question that I have is regarding the Threshold signatory scheme. So it's a dynamic network, these keepers, so every time there is a new Keeper or one Keeper exiting the network, you need to update the Threshold signature, right?
00:18:06.914 - 00:18:08.012, Speaker A: Yes, that's correct.
00:18:08.146 - 00:18:14.030, Speaker D: So how do you do this in a safe way so you don't lose track?
00:18:14.560 - 00:19:06.876, Speaker A: So, as I said earlier, it's the job of the dow to manage the keeper set and they will probably not do changes every week. They will just collect changes for maybe a month or longer and then only change them like in kind of batches so that we don't have to generate keys or perform this quadratic DKG setup phase. Very often. Yes. So for now, if that happens, we just generate perform a new key generation process. In theory, you could update the protocol to I'm not a cryptographer, so I don't know how it works, but you can kind of update the protocol so that new keys, key keepers can join without changing everything on all the key material that the other nodes have. So that wouldn't make it more efficient.
00:19:06.876 - 00:19:15.820, Speaker A: But we don't do that yet. Cool. Thanks a lot. Clipping.
